{"file_name": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form/SNF_Algorithm_Euclidean_Domain.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smith_Normal_Form", "problem_names": ["lemma zero_less_one_type2: \"(0::2) < 1\"", "lemma bezout_matrix_row_code [code abstract]:\n  \"vec_nth (to_hma\\<^sub>m_row A i) = \n      (\\<lambda>j. A $$ (Mod_Type.to_nat i, Mod_Type.to_nat j))\"", "lemma [code abstract]: \"vec_nth (Mod_Type_Connect.to_hma\\<^sub>m A) = to_hma\\<^sub>m_row A\"", "lemma normalize_bezout_gcd: \n  assumes b: \"(p,q,u,v,d) = bezout a b\"\n  shows \"normalize d = gcd a b\"", "lemma bezout_matrix_works_transpose1:\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_not_b: \"a \\<noteq> b\"\nshows \"(A**transpose (bezout_matrix (transpose A) a b i bezout)) $ i $ a \n    = snd (snd (snd (snd (bezout (A $ i $ a) (A $ i $ b)))))\"", "lemma invertible_bezout_matrix_transpose:\n fixes A::\"'a::{bezout_ring_div}^'cols::{finite,wellorder}^'rows\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_less_b: \"a < b\"\n  and aj: \"A $h i $h a \\<noteq> 0\"\nshows \"invertible (transpose (bezout_matrix (transpose A) a b i bezout))\"", "lemma diagonalize_2x2_aux_works:\n  assumes  \"A = P ** A_input ** Q\"\n    and \"invertible P\" and \"invertible Q\"\n    and \"(P',D,Q') = diagonalize_2x2_aux (P,A,Q)\"\n    and \"A $h 0 $h 0 \\<noteq> 0\"\n  shows \"D = P' ** A_input ** Q' \\<and> invertible P' \\<and> invertible Q' \\<and> isDiagonal D\"", "lemma diagonalize_2x2_works:\n  assumes PDQ: \"(P,D,Q) = diagonalize_2x2 A\"\n  shows \"D = P ** A ** Q \\<and> invertible P \\<and> invertible Q \\<and> isDiagonal D\"", "lemma diagonalize_2x2_JNF_works:\n  assumes A: \"A \\<in> carrier_mat 2 2\"\n  and PDQ: \"(P,D,Q) = diagonalize_2x2_JNF A\"\n  shows \"D = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> isDiagonal_mat D \\<and> P\\<in>carrier_mat 2 2\n  \\<and> Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\"", "lemma Smith_2x2_eucl_works:\n  assumes PBQ: \"(P,S,Q) = Smith_2x2_eucl A\"\n  shows \"S = P ** A ** Q \\<and> invertible P \\<and> invertible Q \\<and> Smith_normal_form S\"", "lemma Smith_2x2_JNF_eucl_works:\n  assumes A: \"A \\<in> carrier_mat 2 2\"\n    and PBQ: \"(P,S,Q) = Smith_2x2_JNF_eucl A\"\n  shows \"is_SNF A (P,S,Q)\"", "lemma Smith_1x2_eucl_works:\n  assumes SQ: \"(S,Q) = Smith_1x2_eucl A\"\n  shows \"S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = 0\"", "lemma Smith_1x2_eucl_JNF_works:\n  assumes A: \"A \\<in> carrier_mat 1 2\"\n  and SQ: \"(S,Q) = Smith_1x2_eucl_JNF A\"\nshows \"is_SNF A (1\\<^sub>m 1, (Smith_1x2_eucl_JNF A))\""], "translations": [["", "lemma zero_less_one_type2: \"(0::2) < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < 1", "have \"Mod_Type.from_nat 0 = (0::2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat 0 = 0", "by (simp add: from_nat_0)"], ["proof (state)\nthis:\n  mod_type_class.from_nat 0 = 0\n\ngoal (1 subgoal):\n 1. 0 < 1", "moreover"], ["proof (state)\nthis:\n  mod_type_class.from_nat 0 = 0\n\ngoal (1 subgoal):\n 1. 0 < 1", "have \"Mod_Type.from_nat 1 = (1::2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat 1 = 1", "using from_nat_1"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat 1 = (1::?'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat 1 = 1", "by blast"], ["proof (state)\nthis:\n  mod_type_class.from_nat 1 = 1\n\ngoal (1 subgoal):\n 1. 0 < 1", "moreover"], ["proof (state)\nthis:\n  mod_type_class.from_nat 1 = 1\n\ngoal (1 subgoal):\n 1. 0 < 1", "have \"(Mod_Type.from_nat 0::2) < Mod_Type.from_nat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat 0 < mod_type_class.from_nat 1", "by (rule from_nat_mono, auto)"], ["proof (state)\nthis:\n  mod_type_class.from_nat 0 < mod_type_class.from_nat 1\n\ngoal (1 subgoal):\n 1. 0 < 1", "ultimately"], ["proof (chain)\npicking this:\n  mod_type_class.from_nat 0 = 0\n  mod_type_class.from_nat 1 = 1\n  mod_type_class.from_nat 0 < mod_type_class.from_nat 1", "show ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat 0 = 0\n  mod_type_class.from_nat 1 = 1\n  mod_type_class.from_nat 0 < mod_type_class.from_nat 1\n\ngoal (1 subgoal):\n 1. 0 < 1", "by simp"], ["proof (state)\nthis:\n  0 < 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Previous code equations\\<close>"], ["", "(*Firstly, code equations for Mod_Type_Connect.to_hma\\<^sub>m*)"], ["", "definition \"to_hma\\<^sub>m_row A i\n  = (vec_lambda (\\<lambda>j. A $$ (Mod_Type.to_nat i, Mod_Type.to_nat j)))\""], ["", "lemma bezout_matrix_row_code [code abstract]:\n  \"vec_nth (to_hma\\<^sub>m_row A i) = \n      (\\<lambda>j. A $$ (Mod_Type.to_nat i, Mod_Type.to_nat j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($h) (to_hma\\<^sub>m_row A i) =\n    (\\<lambda>j. A $$ (mod_type_class.to_nat i, mod_type_class.to_nat j))", "unfolding to_hma\\<^sub>m_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($h)\n     (\\<chi>j. A $$ (mod_type_class.to_nat i, mod_type_class.to_nat j)) =\n    (\\<lambda>j. A $$ (mod_type_class.to_nat i, mod_type_class.to_nat j))", "by auto"], ["", "lemma [code abstract]: \"vec_nth (Mod_Type_Connect.to_hma\\<^sub>m A) = to_hma\\<^sub>m_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($h) (Mod_Type_Connect.to_hma\\<^sub>m A) = to_hma\\<^sub>m_row A", "unfolding Mod_Type_Connect.to_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($h)\n     (\\<chi>i j. A $$ (mod_type_class.to_nat i, mod_type_class.to_nat j)) =\n    to_hma\\<^sub>m_row A", "unfolding to_hma\\<^sub>m_row_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($h)\n     (\\<chi>i j. A $$ (mod_type_class.to_nat i, mod_type_class.to_nat j)) =\n    (\\<lambda>i.\n        \\<chi>j. A $$ (mod_type_class.to_nat i, mod_type_class.to_nat j))", "by auto"], ["", "subsection \\<open>An executable algorithm to transform $2 \\times 2$ matrices into its Smith normal form\nin HOL Analysis\\<close>"], ["", "(*\n\nThere are several alternatives to obtain an algorithm to transform a 2x2 matrix (over \na euclidean domain) into its Smith normal form. One of them is diagonalize + diagonal to Smith.\n\nTo take advantage of existing results in HOL Analysis (HA), we proceed as follows:\n\n  1) We implement an algorithm to diagonalize a matrix in HA, taking advantage of the existing \n     bezout matrix\n  2) Then, we transform the diagonal matrix to its Smith normal form using the diagonal_to_Smith\n     algorithm in HA, already proved.\n  3) We define an algorithm in JNF based on the one in HA, which is possible since the types \n     are known. Then, transfer the results to JNF.\n*)"], ["", "subclass (in euclidean_ring_gcd) bezout_ring_div"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bezout_ring_div (div) (+) (-) (0::'a) (*) (1::'a) (mod)\n     euclidean_size uminus", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "(*value[code] \"let (P,S,Q) = (diagonal_to_Smith_PQ ((list_of_list_to_matrix [[4,0],[0,10]])::int^2^2) euclid_ext2)\n  in (matrix_to_list_of_list P,matrix_to_list_of_list S,matrix_to_list_of_list Q)\"*)"], ["", "context\n  fixes bezout::\"('a::euclidean_ring_gcd \\<Rightarrow> 'a \\<Rightarrow> ('a\\<times>'a\\<times>'a\\<times>'a\\<times>'a))\"\n  assumes ib: \"is_bezout_ext bezout\"\nbegin"], ["", "lemma normalize_bezout_gcd: \n  assumes b: \"(p,q,u,v,d) = bezout a b\"\n  shows \"normalize d = gcd a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize d = gcd a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normalize d = gcd a b", "let ?gcd = \"(\\<lambda>a b. case bezout a b of (x, xa,u,v, gcd') \\<Rightarrow> gcd')\""], ["proof (state)\ngoal (1 subgoal):\n 1. normalize d = gcd a b", "have is_gcd: \"is_gcd ?gcd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_gcd\n     (\\<lambda>a b.\n         case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd')", "by (simp add: ib is_gcd_is_bezout_ext)"], ["proof (state)\nthis:\n  is_gcd\n   (\\<lambda>a b. case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd')\n\ngoal (1 subgoal):\n 1. normalize d = gcd a b", "have \"(?gcd a b) = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') = d", "using b"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = bezout a b\n\ngoal (1 subgoal):\n 1. (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') = d", "by (metis case_prod_conv)"], ["proof (state)\nthis:\n  (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') = d\n\ngoal (1 subgoal):\n 1. normalize d = gcd a b", "moreover"], ["proof (state)\nthis:\n  (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') = d\n\ngoal (1 subgoal):\n 1. normalize d = gcd a b", "have \"normalize (?gcd a b) = normalize (gcd a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') =\n    normalize (gcd a b)", "proof (rule associatedI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') dvd gcd a b\n 2. gcd a b dvd (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd')", "show \"(?gcd a b) dvd (gcd a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') dvd gcd a b", "using is_gcd is_gcd_def"], ["proof (prove)\nusing this:\n  is_gcd\n   (\\<lambda>a b. case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd')\n  is_gcd ?gcd' =\n  (\\<forall>a b.\n      ?gcd' a b dvd a \\<and>\n      ?gcd' a b dvd b \\<and>\n      (\\<forall>d'.\n          d' dvd a \\<and> d' dvd b \\<longrightarrow> d' dvd ?gcd' a b))\n\ngoal (1 subgoal):\n 1. (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') dvd gcd a b", "by fastforce"], ["proof (state)\nthis:\n  (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') dvd gcd a b\n\ngoal (1 subgoal):\n 1. gcd a b dvd (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd')", "show \"(gcd a b) dvd (?gcd a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd a b dvd (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd')", "by (metis (no_types) gcd_dvd1 gcd_dvd2 is_gcd is_gcd_def)"], ["proof (state)\nthis:\n  gcd a b dvd (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  normalize (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') =\n  normalize (gcd a b)\n\ngoal (1 subgoal):\n 1. normalize d = gcd a b", "ultimately"], ["proof (chain)\npicking this:\n  (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') = d\n  normalize (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') =\n  normalize (gcd a b)", "show ?thesis"], ["proof (prove)\nusing this:\n  (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') = d\n  normalize (case bezout a b of (x, xa, u, v, gcd') \\<Rightarrow> gcd') =\n  normalize (gcd a b)\n\ngoal (1 subgoal):\n 1. normalize d = gcd a b", "by auto"], ["proof (state)\nthis:\n  normalize d = gcd a b\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma bezout_matrix_works_transpose1:\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_not_b: \"a \\<noteq> b\"\nshows \"(A**transpose (bezout_matrix (transpose A) a b i bezout)) $ i $ a \n    = snd (snd (snd (snd (bezout (A $ i $ a) (A $ i $ b)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "have \"(A**transpose (bezout_matrix (transpose A) a b i bezout)) $h i $h a \n    = transpose (A**transpose (bezout_matrix (transpose A) a b i bezout)) $h a $h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    Finite_Cartesian_Product.transpose\n     (A **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n         bezout)) $h\n    a $h\n    i", "by (simp add: transpose_code transpose_row_code)"], ["proof (state)\nthis:\n  (A **\n   Finite_Cartesian_Product.transpose\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) $h\n  i $h\n  a =\n  Finite_Cartesian_Product.transpose\n   (A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) $h\n  a $h\n  i\n\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "also"], ["proof (state)\nthis:\n  (A **\n   Finite_Cartesian_Product.transpose\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) $h\n  i $h\n  a =\n  Finite_Cartesian_Product.transpose\n   (A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) $h\n  a $h\n  i\n\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "have \"... = ((bezout_matrix (transpose A) a b i bezout) ** (transpose A)) $h a $h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Cartesian_Product.transpose\n     (A **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n         bezout)) $h\n    a $h\n    i =\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout **\n     Finite_Cartesian_Product.transpose A) $h\n    a $h\n    i", "by (simp add: matrix_transpose_mul)"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose\n   (A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) $h\n  a $h\n  i =\n  (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout **\n   Finite_Cartesian_Product.transpose A) $h\n  a $h\n  i\n\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "also"], ["proof (state)\nthis:\n  Finite_Cartesian_Product.transpose\n   (A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) $h\n  a $h\n  i =\n  (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout **\n   Finite_Cartesian_Product.transpose A) $h\n  a $h\n  i\n\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "have \"... = snd (snd (snd (snd (bezout ((transpose A) $ a $ i) ((transpose A) $ b $ i)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout **\n     Finite_Cartesian_Product.transpose A) $h\n    a $h\n    i =\n    snd (snd (snd (snd (bezout\n                         (Finite_Cartesian_Product.transpose A $h a $h i)\n                         (Finite_Cartesian_Product.transpose A $h b $h\n                          i)))))", "by (rule bezout_matrix_works1[OF ib a_not_b])"], ["proof (state)\nthis:\n  (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout **\n   Finite_Cartesian_Product.transpose A) $h\n  a $h\n  i =\n  snd (snd (snd (snd (bezout\n                       (Finite_Cartesian_Product.transpose A $h a $h i)\n                       (Finite_Cartesian_Product.transpose A $h b $h i)))))\n\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "also"], ["proof (state)\nthis:\n  (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout **\n   Finite_Cartesian_Product.transpose A) $h\n  a $h\n  i =\n  snd (snd (snd (snd (bezout\n                       (Finite_Cartesian_Product.transpose A $h a $h i)\n                       (Finite_Cartesian_Product.transpose A $h b $h i)))))\n\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "have \"... = snd (snd (snd (snd (bezout (A $ i $ a) (A $ i $ b)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (snd (snd (bezout\n                         (Finite_Cartesian_Product.transpose A $h a $h i)\n                         (Finite_Cartesian_Product.transpose A $h b $h\n                          i))))) =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "by (simp add: transpose_code transpose_row_code)"], ["proof (state)\nthis:\n  snd (snd (snd (snd (bezout\n                       (Finite_Cartesian_Product.transpose A $h a $h i)\n                       (Finite_Cartesian_Product.transpose A $h b $h\n                        i))))) =\n  snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))\n\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "finally"], ["proof (chain)\npicking this:\n  (A **\n   Finite_Cartesian_Product.transpose\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) $h\n  i $h\n  a =\n  snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "show ?thesis"], ["proof (prove)\nusing this:\n  (A **\n   Finite_Cartesian_Product.transpose\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) $h\n  i $h\n  a =\n  snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))\n\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n        bezout)) $h\n    i $h\n    a =\n    snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))", "."], ["proof (state)\nthis:\n  (A **\n   Finite_Cartesian_Product.transpose\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) $h\n  i $h\n  a =\n  snd (snd (snd (snd (bezout (A $h i $h a) (A $h i $h b)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_bezout_matrix_transpose:\n fixes A::\"'a::{bezout_ring_div}^'cols::{finite,wellorder}^'rows\"\n  assumes ib: \"is_bezout_ext bezout\"\n  and a_less_b: \"a < b\"\n  and aj: \"A $h i $h a \\<noteq> 0\"\nshows \"invertible (transpose (bezout_matrix (transpose A) a b i bezout))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible\n     (Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout))", "have \"Determinants.det (bezout_matrix (transpose A) a b i bezout) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinants.det\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout) =\n    (1::'a)", "by (rule det_bezout_matrix[OF ib a_less_b], insert aj, auto simp add: transpose_def)"], ["proof (state)\nthis:\n  Determinants.det\n   (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. invertible\n     (Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout))", "hence \"Determinants.det (transpose (bezout_matrix (transpose A) a b i bezout)) = 1\""], ["proof (prove)\nusing this:\n  Determinants.det\n   (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. Determinants.det\n     (Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i\n         bezout)) =\n    (1::'a)", "by simp"], ["proof (state)\nthis:\n  Determinants.det\n   (Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. invertible\n     (Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Determinants.det\n   (Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. invertible\n     (Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout))", "by (simp add: invertible_iff_is_unit)"], ["proof (state)\nthis:\n  invertible\n   (Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) a b i bezout))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*I will have to ensure that a is not zero before starting the algorithm (moving the pivot)*)"], ["", "function diagonalize_2x2_aux :: \"(('a::euclidean_ring_gcd^2^2) \\<times> ('a^2^2)\\<times>('a^2^2)) \\<Rightarrow> \n                                  (('a^2^2) \\<times>('a^2^2)\\<times>('a^2^2))\"\n  where \"diagonalize_2x2_aux (P,A,Q)  =\n(\n  let \n      a = A $h 0 $h 0;\n      b = A $h 0 $h 1;\n      c = A $h 1 $h 0;\n      d = A $h 1 $h 1 in\n      if a\\<noteq> 0 \\<and> \\<not> a dvd b then let bezout_mat = transpose (bezout_matrix (transpose A) 0 1 0 euclid_ext2) in\n       diagonalize_2x2_aux (P, A**bezout_mat,Q**bezout_mat) else\n        if  a \\<noteq> 0 \\<and> \\<not> a dvd c then let bezout_mat = bezout_matrix A 0 1 0 euclid_ext2\n      in diagonalize_2x2_aux (bezout_mat**P,bezout_mat**A,Q) else \\<comment> \\<open>We can divide an get zeros\\<close>\n      let Q' = column_add (Finite_Cartesian_Product.mat 1) 1 0 (- (b div a));\n          P' = row_add (Finite_Cartesian_Product.mat 1) 1 0 (- (c div a)) in\n        (P'**P,P'**A**Q',Q**Q')\n)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>Pa A Q. x = (Pa, A, Q) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>P A Q Pa Aa Qa.\n       (P, A, Q) = (Pa, Aa, Qa) \\<Longrightarrow>\n       (let a = A $h 0 $h 0; b = A $h 0 $h 1; c = A $h 1 $h 0;\n            d = A $h 1 $h 1\n        in if a \\<noteq> (0::'a) \\<and> \\<not> a dvd b\n           then let bezout_mat =\n                      Finite_Cartesian_Product.transpose\n                       (bezout_matrix (Finite_Cartesian_Product.transpose A)\n                         0 1 0 euclid_ext2)\n                in diagonalize_2x2_aux_sumC\n                    (P, A ** bezout_mat, Q ** bezout_mat)\n           else if a \\<noteq> (0::'a) \\<and> \\<not> a dvd c\n                then let bezout_mat = bezout_matrix A 0 1 0 euclid_ext2\n                     in diagonalize_2x2_aux_sumC\n                         (bezout_mat ** P, bezout_mat ** A, Q)\n                else let Q' = column_add\n                               (Finite_Cartesian_Product.mat (1::'a)) 1 0\n                               (- (b div a));\n                         P' = row_add (Finite_Cartesian_Product.mat (1::'a))\n                               1 0 (- (c div a))\n                     in (P' ** P, P' ** A ** Q', Q ** Q')) =\n       (let a = Aa $h 0 $h 0; b = Aa $h 0 $h 1; c = Aa $h 1 $h 0;\n            d = Aa $h 1 $h 1\n        in if a \\<noteq> (0::'a) \\<and> \\<not> a dvd b\n           then let bezout_mat =\n                      Finite_Cartesian_Product.transpose\n                       (bezout_matrix\n                         (Finite_Cartesian_Product.transpose Aa) 0 1 0\n                         euclid_ext2)\n                in diagonalize_2x2_aux_sumC\n                    (Pa, Aa ** bezout_mat, Qa ** bezout_mat)\n           else if a \\<noteq> (0::'a) \\<and> \\<not> a dvd c\n                then let bezout_mat = bezout_matrix Aa 0 1 0 euclid_ext2\n                     in diagonalize_2x2_aux_sumC\n                         (bezout_mat ** Pa, bezout_mat ** Aa, Qa)\n                else let Q' = column_add\n                               (Finite_Cartesian_Product.mat (1::'a)) 1 0\n                               (- (b div a));\n                         P' = row_add (Finite_Cartesian_Product.mat (1::'a))\n                               1 0 (- (c div a))\n                     in (P' ** Pa, P' ** Aa ** Q', Qa ** Q'))", "by auto"], ["", "(*The algorithm terminates since the euclidean size of the A $h 0 $h 0 element gets reduced.*)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All diagonalize_2x2_aux_dom", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. All diagonalize_2x2_aux_dom", "have ib: \"is_bezout_ext euclid_ext2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bezout_ext euclid_ext2", "by (simp add: is_bezout_ext_euclid_ext2)"], ["proof (state)\nthis:\n  is_bezout_ext euclid_ext2\n\ngoal (1 subgoal):\n 1. All diagonalize_2x2_aux_dom", "have \"euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) < euclidean_size (A $h 0 $h 0)\"\n    if a_not_dvd_c: \"\\<not> A $h 0 $h 0 dvd A $h 1 $h 0\" and a_not0: \"A $h 0 $h 0 \\<noteq> 0\" for A::\"'a^2^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "let ?a = \"(A $h 0 $h 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "let ?c = \"(A $h 1 $h 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "obtain p q u v d where pquvd: \"(p,q,u,v,d) = euclid_ext2 ?a ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q u v d.\n        (p, q, u, v, d) =\n        euclid_ext2 (A $h 0 $h 0) (A $h 1 $h 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases5)"], ["proof (state)\nthis:\n  (p, q, u, v, d) = euclid_ext2 (A $h 0 $h 0) (A $h 1 $h 0)\n\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "have \"(bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0 = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0 = d", "by (metis bezout_matrix_works1 ib one_neq_zero pquvd prod.sel(2))"], ["proof (state)\nthis:\n  (bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0 = d\n\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "hence \"normalize ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) = normalize d\""], ["proof (prove)\nusing this:\n  (bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0 = d\n\ngoal (1 subgoal):\n 1. normalize ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) =\n    normalize d", "by auto"], ["proof (state)\nthis:\n  normalize ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) =\n  normalize d\n\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "also"], ["proof (state)\nthis:\n  normalize ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) =\n  normalize d\n\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "have \"... = gcd ?a ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize d = gcd (A $h 0 $h 0) (A $h 1 $h 0)", "by (rule normalize_bezout_gcd[OF ib pquvd])"], ["proof (state)\nthis:\n  normalize d = gcd (A $h 0 $h 0) (A $h 1 $h 0)\n\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "finally"], ["proof (chain)\npicking this:\n  normalize ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) =\n  gcd (A $h 0 $h 0) (A $h 1 $h 0)", "have \"euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) \n      = euclidean_size (gcd ?a ?c)\""], ["proof (prove)\nusing this:\n  normalize ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) =\n  gcd (A $h 0 $h 0) (A $h 1 $h 0)\n\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) =\n    euclidean_size (gcd (A $h 0 $h 0) (A $h 1 $h 0))", "by (metis euclidean_size_normalize)"], ["proof (state)\nthis:\n  euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) =\n  euclidean_size (gcd (A $h 0 $h 0) (A $h 1 $h 0))\n\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "also"], ["proof (state)\nthis:\n  euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0) =\n  euclidean_size (gcd (A $h 0 $h 0) (A $h 1 $h 0))\n\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "have \"... < euclidean_size ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_size (gcd (A $h 0 $h 0) (A $h 1 $h 0))\n    < euclidean_size (A $h 0 $h 0)", "by (rule euclidean_size_gcd_less1[OF a_not0 a_not_dvd_c])"], ["proof (state)\nthis:\n  euclidean_size (gcd (A $h 0 $h 0) (A $h 1 $h 0))\n  < euclidean_size (A $h 0 $h 0)\n\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "finally"], ["proof (chain)\npicking this:\n  euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n  < euclidean_size (A $h 0 $h 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n  < euclidean_size (A $h 0 $h 0)\n\ngoal (1 subgoal):\n 1. euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n    < euclidean_size (A $h 0 $h 0)", "."], ["proof (state)\nthis:\n  euclidean_size ((bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0)\n  < euclidean_size (A $h 0 $h 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> ?A1 $h 0 $h 0 dvd ?A1 $h 1 $h 0;\n   ?A1 $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> euclidean_size\n                     ((bezout_matrix ?A1 0 1 0 euclid_ext2 ** ?A1) $h 0 $h\n                      0)\n                    < euclidean_size (?A1 $h 0 $h 0)\n\ngoal (1 subgoal):\n 1. All diagonalize_2x2_aux_dom", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> ?A1 $h 0 $h 0 dvd ?A1 $h 1 $h 0;\n   ?A1 $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> euclidean_size\n                     ((bezout_matrix ?A1 0 1 0 euclid_ext2 ** ?A1) $h 0 $h\n                      0)\n                    < euclidean_size (?A1 $h 0 $h 0)\n\ngoal (1 subgoal):\n 1. All diagonalize_2x2_aux_dom", "have \"euclidean_size ((A ** transpose (bezout_matrix (transpose A) 0 1 0 euclid_ext2)) $h 0 $h 0)\n      < euclidean_size (A $h 0 $h 0)\"\n    if a_not_dvd_b: \"\\<not> A $h 0 $h 0 dvd A $h 0 $h 1\" and a_not0: \"A $h 0 $h 0 \\<noteq> 0\" for A::\"'a^2^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "let ?a = \"(A $h 0 $h 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "let ?b = \"(A $h 0 $h 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "obtain p q u v d where pquvd: \"(p,q,u,v,d) = euclid_ext2 ?a ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q u v d.\n        (p, q, u, v, d) =\n        euclid_ext2 (A $h 0 $h 0) (A $h 0 $h 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases5)"], ["proof (state)\nthis:\n  (p, q, u, v, d) = euclid_ext2 (A $h 0 $h 0) (A $h 0 $h 1)\n\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "have \"(A ** transpose (bezout_matrix (transpose A) 0 1 0 euclid_ext2)) $h 0 $h 0 = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0 =\n    d", "by (metis bezout_matrix_works_transpose1 ib pquvd prod.sel(2) zero_neq_one)"], ["proof (state)\nthis:\n  (A **\n   Finite_Cartesian_Product.transpose\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n      euclid_ext2)) $h\n  0 $h\n  0 =\n  d\n\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "hence \"normalize ((A ** transpose (bezout_matrix (transpose A) 0 1 0 euclid_ext2)) $h 0 $h 0) = normalize d\""], ["proof (prove)\nusing this:\n  (A **\n   Finite_Cartesian_Product.transpose\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n      euclid_ext2)) $h\n  0 $h\n  0 =\n  d\n\ngoal (1 subgoal):\n 1. normalize\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0) =\n    normalize d", "by auto"], ["proof (state)\nthis:\n  normalize\n   ((A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0) =\n  normalize d\n\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "also"], ["proof (state)\nthis:\n  normalize\n   ((A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0) =\n  normalize d\n\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "have \"... = gcd ?a ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize d = gcd (A $h 0 $h 0) (A $h 0 $h 1)", "by (rule normalize_bezout_gcd[OF ib pquvd])"], ["proof (state)\nthis:\n  normalize d = gcd (A $h 0 $h 0) (A $h 0 $h 1)\n\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "finally"], ["proof (chain)\npicking this:\n  normalize\n   ((A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0) =\n  gcd (A $h 0 $h 0) (A $h 0 $h 1)", "have \"euclidean_size ((A ** transpose (bezout_matrix (transpose A) 0 1 0 euclid_ext2)) $h 0 $h 0)\n      = euclidean_size (gcd ?a ?b)\""], ["proof (prove)\nusing this:\n  normalize\n   ((A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0) =\n  gcd (A $h 0 $h 0) (A $h 0 $h 1)\n\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0) =\n    euclidean_size (gcd (A $h 0 $h 0) (A $h 0 $h 1))", "by (metis euclidean_size_normalize)"], ["proof (state)\nthis:\n  euclidean_size\n   ((A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0) =\n  euclidean_size (gcd (A $h 0 $h 0) (A $h 0 $h 1))\n\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "also"], ["proof (state)\nthis:\n  euclidean_size\n   ((A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0) =\n  euclidean_size (gcd (A $h 0 $h 0) (A $h 0 $h 1))\n\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "have \"... < euclidean_size ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_size (gcd (A $h 0 $h 0) (A $h 0 $h 1))\n    < euclidean_size (A $h 0 $h 0)", "by (rule euclidean_size_gcd_less1[OF a_not0 a_not_dvd_b])"], ["proof (state)\nthis:\n  euclidean_size (gcd (A $h 0 $h 0) (A $h 0 $h 1))\n  < euclidean_size (A $h 0 $h 0)\n\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "finally"], ["proof (chain)\npicking this:\n  euclidean_size\n   ((A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0)\n  < euclidean_size (A $h 0 $h 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  euclidean_size\n   ((A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0)\n  < euclidean_size (A $h 0 $h 0)\n\ngoal (1 subgoal):\n 1. euclidean_size\n     ((A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2)) $h\n      0 $h\n      0)\n    < euclidean_size (A $h 0 $h 0)", "."], ["proof (state)\nthis:\n  euclidean_size\n   ((A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0)\n  < euclidean_size (A $h 0 $h 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> ?A1 $h 0 $h 0 dvd ?A1 $h 0 $h 1;\n   ?A1 $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> euclidean_size\n                     ((?A1 **\n                       Finite_Cartesian_Product.transpose\n                        (bezout_matrix\n                          (Finite_Cartesian_Product.transpose ?A1) 0 1 0\n                          euclid_ext2)) $h\n                      0 $h\n                      0)\n                    < euclidean_size (?A1 $h 0 $h 0)\n\ngoal (1 subgoal):\n 1. All diagonalize_2x2_aux_dom", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> ?A1 $h 0 $h 0 dvd ?A1 $h 1 $h 0;\n   ?A1 $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> euclidean_size\n                     ((bezout_matrix ?A1 0 1 0 euclid_ext2 ** ?A1) $h 0 $h\n                      0)\n                    < euclidean_size (?A1 $h 0 $h 0)\n  \\<lbrakk>\\<not> ?A1 $h 0 $h 0 dvd ?A1 $h 0 $h 1;\n   ?A1 $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> euclidean_size\n                     ((?A1 **\n                       Finite_Cartesian_Product.transpose\n                        (bezout_matrix\n                          (Finite_Cartesian_Product.transpose ?A1) 0 1 0\n                          euclid_ext2)) $h\n                      0 $h\n                      0)\n                    < euclidean_size (?A1 $h 0 $h 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?A1 $h 0 $h 0 dvd ?A1 $h 1 $h 0;\n   ?A1 $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> euclidean_size\n                     ((bezout_matrix ?A1 0 1 0 euclid_ext2 ** ?A1) $h 0 $h\n                      0)\n                    < euclidean_size (?A1 $h 0 $h 0)\n  \\<lbrakk>\\<not> ?A1 $h 0 $h 0 dvd ?A1 $h 0 $h 1;\n   ?A1 $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> euclidean_size\n                     ((?A1 **\n                       Finite_Cartesian_Product.transpose\n                        (bezout_matrix\n                          (Finite_Cartesian_Product.transpose ?A1) 0 1 0\n                          euclid_ext2)) $h\n                      0 $h\n                      0)\n                    < euclidean_size (?A1 $h 0 $h 0)\n\ngoal (1 subgoal):\n 1. All diagonalize_2x2_aux_dom", "by (relation \"Wellfounded.measure (\\<lambda>(P,A,Q). euclidean_size (A $h 0 $h 0))\", auto)"], ["proof (state)\nthis:\n  All diagonalize_2x2_aux_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diagonalize_2x2_aux_works:\n  assumes  \"A = P ** A_input ** Q\"\n    and \"invertible P\" and \"invertible Q\"\n    and \"(P',D,Q') = diagonalize_2x2_aux (P,A,Q)\"\n    and \"A $h 0 $h 0 \\<noteq> 0\"\n  shows \"D = P' ** A_input ** Q' \\<and> invertible P' \\<and> invertible Q' \\<and> isDiagonal D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "using assms"], ["proof (prove)\nusing this:\n  A = P ** A_input ** Q\n  invertible P\n  invertible Q\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "proof (induct \"(P,A,Q)\" arbitrary: P A Q rule: diagonalize_2x2_aux.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P A Q.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1;\n                    xb = A $h 1 $h 0; xc = A $h 1 $h 1;\n                    x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa;\n                    xd =\n                    Finite_Cartesian_Product.transpose\n                     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                       1 0 euclid_ext2);\n                    A ** xd = P ** A_input ** (Q ** xd); invertible P;\n                    invertible (Q ** xd);\n                    (P', D, Q') = diagonalize_2x2_aux (P, A ** xd, Q ** xd);\n                    (A ** xd) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                                     invertible P' \\<and>\n                                     invertible Q' \\<and> isDiagonal D;\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1; xb = A $h 1 $h 0;\n            xc = A $h 1 $h 1;\n            \\<not> (x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa);\n            x \\<noteq> (0::'a) \\<and> \\<not> x dvd xb;\n            xd = bezout_matrix A 0 1 0 euclid_ext2;\n            xd ** A = xd ** P ** A_input ** Q; invertible (xd ** P);\n            invertible Q;\n            (P', D, Q') = diagonalize_2x2_aux (xd ** P, xd ** A, Q);\n            (xd ** A) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                             invertible P' \\<and>\n                             invertible Q' \\<and> isDiagonal D;\n        A = P ** A_input ** Q; invertible P; invertible Q;\n        (P', D, Q') = diagonalize_2x2_aux (P, A, Q);\n        A $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                         invertible P' \\<and>\n                         invertible Q' \\<and> isDiagonal D", "case (1 P A Q)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = A $h 0 $h 0; ?xa = A $h 0 $h 1; ?xb = A $h 1 $h 0;\n   ?xc = A $h 1 $h 1; ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa;\n   ?xd =\n   Finite_Cartesian_Product.transpose\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n      euclid_ext2);\n   A ** ?xd = P ** A_input ** (Q ** ?xd); invertible P;\n   invertible (Q ** ?xd);\n   (P', D, Q') = diagonalize_2x2_aux (P, A ** ?xd, Q ** ?xd);\n   (A ** ?xd) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n  \\<lbrakk>?x = A $h 0 $h 0; ?xa = A $h 0 $h 1; ?xb = A $h 1 $h 0;\n   ?xc = A $h 1 $h 1; \\<not> (?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa);\n   ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xb;\n   ?xd = bezout_matrix A 0 1 0 euclid_ext2;\n   ?xd ** A = ?xd ** P ** A_input ** Q; invertible (?xd ** P); invertible Q;\n   (P', D, Q') = diagonalize_2x2_aux (?xd ** P, ?xd ** A, Q);\n   (?xd ** A) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n  A = P ** A_input ** Q\n  invertible P\n  invertible Q\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>P A Q.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1;\n                    xb = A $h 1 $h 0; xc = A $h 1 $h 1;\n                    x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa;\n                    xd =\n                    Finite_Cartesian_Product.transpose\n                     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                       1 0 euclid_ext2);\n                    A ** xd = P ** A_input ** (Q ** xd); invertible P;\n                    invertible (Q ** xd);\n                    (P', D, Q') = diagonalize_2x2_aux (P, A ** xd, Q ** xd);\n                    (A ** xd) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                                     invertible P' \\<and>\n                                     invertible Q' \\<and> isDiagonal D;\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1; xb = A $h 1 $h 0;\n            xc = A $h 1 $h 1;\n            \\<not> (x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa);\n            x \\<noteq> (0::'a) \\<and> \\<not> x dvd xb;\n            xd = bezout_matrix A 0 1 0 euclid_ext2;\n            xd ** A = xd ** P ** A_input ** Q; invertible (xd ** P);\n            invertible Q;\n            (P', D, Q') = diagonalize_2x2_aux (xd ** P, xd ** A, Q);\n            (xd ** A) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                             invertible P' \\<and>\n                             invertible Q' \\<and> isDiagonal D;\n        A = P ** A_input ** Q; invertible P; invertible Q;\n        (P', D, Q') = diagonalize_2x2_aux (P, A, Q);\n        A $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                         invertible P' \\<and>\n                         invertible Q' \\<and> isDiagonal D", "let ?a = \"A $h 0 $h 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P A Q.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1;\n                    xb = A $h 1 $h 0; xc = A $h 1 $h 1;\n                    x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa;\n                    xd =\n                    Finite_Cartesian_Product.transpose\n                     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                       1 0 euclid_ext2);\n                    A ** xd = P ** A_input ** (Q ** xd); invertible P;\n                    invertible (Q ** xd);\n                    (P', D, Q') = diagonalize_2x2_aux (P, A ** xd, Q ** xd);\n                    (A ** xd) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                                     invertible P' \\<and>\n                                     invertible Q' \\<and> isDiagonal D;\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1; xb = A $h 1 $h 0;\n            xc = A $h 1 $h 1;\n            \\<not> (x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa);\n            x \\<noteq> (0::'a) \\<and> \\<not> x dvd xb;\n            xd = bezout_matrix A 0 1 0 euclid_ext2;\n            xd ** A = xd ** P ** A_input ** Q; invertible (xd ** P);\n            invertible Q;\n            (P', D, Q') = diagonalize_2x2_aux (xd ** P, xd ** A, Q);\n            (xd ** A) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                             invertible P' \\<and>\n                             invertible Q' \\<and> isDiagonal D;\n        A = P ** A_input ** Q; invertible P; invertible Q;\n        (P', D, Q') = diagonalize_2x2_aux (P, A, Q);\n        A $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                         invertible P' \\<and>\n                         invertible Q' \\<and> isDiagonal D", "let ?b = \"A $h 0 $h 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P A Q.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1;\n                    xb = A $h 1 $h 0; xc = A $h 1 $h 1;\n                    x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa;\n                    xd =\n                    Finite_Cartesian_Product.transpose\n                     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                       1 0 euclid_ext2);\n                    A ** xd = P ** A_input ** (Q ** xd); invertible P;\n                    invertible (Q ** xd);\n                    (P', D, Q') = diagonalize_2x2_aux (P, A ** xd, Q ** xd);\n                    (A ** xd) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                                     invertible P' \\<and>\n                                     invertible Q' \\<and> isDiagonal D;\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1; xb = A $h 1 $h 0;\n            xc = A $h 1 $h 1;\n            \\<not> (x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa);\n            x \\<noteq> (0::'a) \\<and> \\<not> x dvd xb;\n            xd = bezout_matrix A 0 1 0 euclid_ext2;\n            xd ** A = xd ** P ** A_input ** Q; invertible (xd ** P);\n            invertible Q;\n            (P', D, Q') = diagonalize_2x2_aux (xd ** P, xd ** A, Q);\n            (xd ** A) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                             invertible P' \\<and>\n                             invertible Q' \\<and> isDiagonal D;\n        A = P ** A_input ** Q; invertible P; invertible Q;\n        (P', D, Q') = diagonalize_2x2_aux (P, A, Q);\n        A $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                         invertible P' \\<and>\n                         invertible Q' \\<and> isDiagonal D", "let ?c = \"A $h 1 $h 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P A Q.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1;\n                    xb = A $h 1 $h 0; xc = A $h 1 $h 1;\n                    x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa;\n                    xd =\n                    Finite_Cartesian_Product.transpose\n                     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                       1 0 euclid_ext2);\n                    A ** xd = P ** A_input ** (Q ** xd); invertible P;\n                    invertible (Q ** xd);\n                    (P', D, Q') = diagonalize_2x2_aux (P, A ** xd, Q ** xd);\n                    (A ** xd) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                                     invertible P' \\<and>\n                                     invertible Q' \\<and> isDiagonal D;\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1; xb = A $h 1 $h 0;\n            xc = A $h 1 $h 1;\n            \\<not> (x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa);\n            x \\<noteq> (0::'a) \\<and> \\<not> x dvd xb;\n            xd = bezout_matrix A 0 1 0 euclid_ext2;\n            xd ** A = xd ** P ** A_input ** Q; invertible (xd ** P);\n            invertible Q;\n            (P', D, Q') = diagonalize_2x2_aux (xd ** P, xd ** A, Q);\n            (xd ** A) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                             invertible P' \\<and>\n                             invertible Q' \\<and> isDiagonal D;\n        A = P ** A_input ** Q; invertible P; invertible Q;\n        (P', D, Q') = diagonalize_2x2_aux (P, A, Q);\n        A $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                         invertible P' \\<and>\n                         invertible Q' \\<and> isDiagonal D", "let ?d = \"A $h 1 $h 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P A Q.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1;\n                    xb = A $h 1 $h 0; xc = A $h 1 $h 1;\n                    x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa;\n                    xd =\n                    Finite_Cartesian_Product.transpose\n                     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                       1 0 euclid_ext2);\n                    A ** xd = P ** A_input ** (Q ** xd); invertible P;\n                    invertible (Q ** xd);\n                    (P', D, Q') = diagonalize_2x2_aux (P, A ** xd, Q ** xd);\n                    (A ** xd) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                                     invertible P' \\<and>\n                                     invertible Q' \\<and> isDiagonal D;\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1; xb = A $h 1 $h 0;\n            xc = A $h 1 $h 1;\n            \\<not> (x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa);\n            x \\<noteq> (0::'a) \\<and> \\<not> x dvd xb;\n            xd = bezout_matrix A 0 1 0 euclid_ext2;\n            xd ** A = xd ** P ** A_input ** Q; invertible (xd ** P);\n            invertible Q;\n            (P', D, Q') = diagonalize_2x2_aux (xd ** P, xd ** A, Q);\n            (xd ** A) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                             invertible P' \\<and>\n                             invertible Q' \\<and> isDiagonal D;\n        A = P ** A_input ** Q; invertible P; invertible Q;\n        (P', D, Q') = diagonalize_2x2_aux (P, A, Q);\n        A $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                         invertible P' \\<and>\n                         invertible Q' \\<and> isDiagonal D", "have a_not_0: \"?a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $h 0 $h 0 \\<noteq> (0::'a)", "using \"1.prems\""], ["proof (prove)\nusing this:\n  A = P ** A_input ** Q\n  invertible P\n  invertible Q\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $h 0 $h 0 \\<noteq> (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>P A Q.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1;\n                    xb = A $h 1 $h 0; xc = A $h 1 $h 1;\n                    x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa;\n                    xd =\n                    Finite_Cartesian_Product.transpose\n                     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                       1 0 euclid_ext2);\n                    A ** xd = P ** A_input ** (Q ** xd); invertible P;\n                    invertible (Q ** xd);\n                    (P', D, Q') = diagonalize_2x2_aux (P, A ** xd, Q ** xd);\n                    (A ** xd) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                                     invertible P' \\<and>\n                                     invertible Q' \\<and> isDiagonal D;\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1; xb = A $h 1 $h 0;\n            xc = A $h 1 $h 1;\n            \\<not> (x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa);\n            x \\<noteq> (0::'a) \\<and> \\<not> x dvd xb;\n            xd = bezout_matrix A 0 1 0 euclid_ext2;\n            xd ** A = xd ** P ** A_input ** Q; invertible (xd ** P);\n            invertible Q;\n            (P', D, Q') = diagonalize_2x2_aux (xd ** P, xd ** A, Q);\n            (xd ** A) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                             invertible P' \\<and>\n                             invertible Q' \\<and> isDiagonal D;\n        A = P ** A_input ** Q; invertible P; invertible Q;\n        (P', D, Q') = diagonalize_2x2_aux (P, A, Q);\n        A $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                         invertible P' \\<and>\n                         invertible Q' \\<and> isDiagonal D", "have ib: \"is_bezout_ext euclid_ext2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bezout_ext euclid_ext2", "by (simp add: is_bezout_ext_euclid_ext2)"], ["proof (state)\nthis:\n  is_bezout_ext euclid_ext2\n\ngoal (1 subgoal):\n 1. \\<And>P A Q.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1;\n                    xb = A $h 1 $h 0; xc = A $h 1 $h 1;\n                    x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa;\n                    xd =\n                    Finite_Cartesian_Product.transpose\n                     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                       1 0 euclid_ext2);\n                    A ** xd = P ** A_input ** (Q ** xd); invertible P;\n                    invertible (Q ** xd);\n                    (P', D, Q') = diagonalize_2x2_aux (P, A ** xd, Q ** xd);\n                    (A ** xd) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                                     invertible P' \\<and>\n                                     invertible Q' \\<and> isDiagonal D;\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1; xb = A $h 1 $h 0;\n            xc = A $h 1 $h 1;\n            \\<not> (x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa);\n            x \\<noteq> (0::'a) \\<and> \\<not> x dvd xb;\n            xd = bezout_matrix A 0 1 0 euclid_ext2;\n            xd ** A = xd ** P ** A_input ** Q; invertible (xd ** P);\n            invertible Q;\n            (P', D, Q') = diagonalize_2x2_aux (xd ** P, xd ** A, Q);\n            (xd ** A) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                             invertible P' \\<and>\n                             invertible Q' \\<and> isDiagonal D;\n        A = P ** A_input ** Q; invertible P; invertible Q;\n        (P', D, Q') = diagonalize_2x2_aux (P, A, Q);\n        A $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                         invertible P' \\<and>\n                         invertible Q' \\<and> isDiagonal D", "have one_not_zero: \"1 \\<noteq> (0::2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>P A Q.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1;\n                    xb = A $h 1 $h 0; xc = A $h 1 $h 1;\n                    x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa;\n                    xd =\n                    Finite_Cartesian_Product.transpose\n                     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                       1 0 euclid_ext2);\n                    A ** xd = P ** A_input ** (Q ** xd); invertible P;\n                    invertible (Q ** xd);\n                    (P', D, Q') = diagonalize_2x2_aux (P, A ** xd, Q ** xd);\n                    (A ** xd) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                                     invertible P' \\<and>\n                                     invertible Q' \\<and> isDiagonal D;\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x = A $h 0 $h 0; xa = A $h 0 $h 1; xb = A $h 1 $h 0;\n            xc = A $h 1 $h 1;\n            \\<not> (x \\<noteq> (0::'a) \\<and> \\<not> x dvd xa);\n            x \\<noteq> (0::'a) \\<and> \\<not> x dvd xb;\n            xd = bezout_matrix A 0 1 0 euclid_ext2;\n            xd ** A = xd ** P ** A_input ** Q; invertible (xd ** P);\n            invertible Q;\n            (P', D, Q') = diagonalize_2x2_aux (xd ** P, xd ** A, Q);\n            (xd ** A) $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n           \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                             invertible P' \\<and>\n                             invertible Q' \\<and> isDiagonal D;\n        A = P ** A_input ** Q; invertible P; invertible Q;\n        (P', D, Q') = diagonalize_2x2_aux (P, A, Q);\n        A $h 0 $h 0 \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> D = P' ** A_input ** Q' \\<and>\n                         invertible P' \\<and>\n                         invertible Q' \\<and> isDiagonal D", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "proof (cases \"\\<not> ?a dvd ?b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "case True"], ["proof (state)\nthis:\n  \\<not> A $h 0 $h 0 dvd A $h 0 $h 1\n\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "let ?bezout_mat_right = \"transpose (bezout_matrix (transpose A) 0 1 0 euclid_ext2)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have \"(P', D, Q') = diagonalize_2x2_aux (P, A, Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P', D, Q') = diagonalize_2x2_aux (P, A, Q)", "using \"1.prems\""], ["proof (prove)\nusing this:\n  A = P ** A_input ** Q\n  invertible P\n  invertible Q\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P', D, Q') = diagonalize_2x2_aux (P, A, Q)", "by blast"], ["proof (state)\nthis:\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "also"], ["proof (state)\nthis:\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have \"... = diagonalize_2x2_aux (P, A** ?bezout_mat_right, Q ** ?bezout_mat_right)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonalize_2x2_aux (P, A, Q) =\n    diagonalize_2x2_aux\n     (P, A **\n         Finite_Cartesian_Product.transpose\n          (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n            euclid_ext2),\n      Q **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2))", "using True a_not_0"], ["proof (prove)\nusing this:\n  \\<not> A $h 0 $h 0 dvd A $h 0 $h 1\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. diagonalize_2x2_aux (P, A, Q) =\n    diagonalize_2x2_aux\n     (P, A **\n         Finite_Cartesian_Product.transpose\n          (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n            euclid_ext2),\n      Q **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  diagonalize_2x2_aux (P, A, Q) =\n  diagonalize_2x2_aux\n   (P, A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2),\n    Q **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2))\n\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "finally"], ["proof (chain)\npicking this:\n  (P', D, Q') =\n  diagonalize_2x2_aux\n   (P, A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2),\n    Q **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2))", "have eq: \"(P',D,Q') = ...\""], ["proof (prove)\nusing this:\n  (P', D, Q') =\n  diagonalize_2x2_aux\n   (P, A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2),\n    Q **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2))\n\ngoal (1 subgoal):\n 1. (P', D, Q') =\n    diagonalize_2x2_aux\n     (P, A **\n         Finite_Cartesian_Product.transpose\n          (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n            euclid_ext2),\n      Q **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2))", "."], ["proof (state)\nthis:\n  (P', D, Q') =\n  diagonalize_2x2_aux\n   (P, A **\n       Finite_Cartesian_Product.transpose\n        (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n          euclid_ext2),\n    Q **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2))\n\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "proof (rule \"1.hyps\"(1)[OF  _ _ _ _ _ _ _ _ _ eq])"], ["proof (state)\ngoal (10 subgoals):\n 1. ?x = A $h 0 $h 0\n 2. ?xa = A $h 0 $h 1\n 3. ?xb = A $h 1 $h 0\n 4. ?xc = A $h 1 $h 1\n 5. ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa\n 6. Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) =\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2)\n 7. A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) =\n    P ** A_input **\n    (Q **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2))\n 8. invertible P\n 9. invertible\n     (Q **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2))\n 10. (A **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2)) $h\n     0 $h\n     0 \\<noteq>\n     (0::'a)", "have \"invertible ?bezout_mat_right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2))", "by (rule invertible_bezout_matrix_transpose[OF ib zero_less_one_type2 a_not_0])"], ["proof (state)\nthis:\n  invertible\n   (Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2))\n\ngoal (10 subgoals):\n 1. ?x = A $h 0 $h 0\n 2. ?xa = A $h 0 $h 1\n 3. ?xb = A $h 1 $h 0\n 4. ?xc = A $h 1 $h 1\n 5. ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa\n 6. Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) =\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2)\n 7. A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) =\n    P ** A_input **\n    (Q **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2))\n 8. invertible P\n 9. invertible\n     (Q **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2))\n 10. (A **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2)) $h\n     0 $h\n     0 \\<noteq>\n     (0::'a)", "thus \"invertible (Q ** ?bezout_mat_right)\""], ["proof (prove)\nusing this:\n  invertible\n   (Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2))\n\ngoal (1 subgoal):\n 1. invertible\n     (Q **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2))", "using \"1.prems\" invertible_mult"], ["proof (prove)\nusing this:\n  invertible\n   (Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2))\n  A = P ** A_input ** Q\n  invertible P\n  invertible Q\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n  A $h 0 $h 0 \\<noteq> (0::'a)\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n\ngoal (1 subgoal):\n 1. invertible\n     (Q **\n      Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2))", "by blast"], ["proof (state)\nthis:\n  invertible\n   (Q **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2))\n\ngoal (9 subgoals):\n 1. ?x = A $h 0 $h 0\n 2. ?xa = A $h 0 $h 1\n 3. ?xb = A $h 1 $h 0\n 4. ?xc = A $h 1 $h 1\n 5. ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa\n 6. Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) =\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2)\n 7. A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) =\n    P ** A_input **\n    (Q **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2))\n 8. invertible P\n 9. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0 \\<noteq>\n    (0::'a)", "show \"A ** ?bezout_mat_right = P ** A_input ** (Q ** ?bezout_mat_right)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) =\n    P ** A_input **\n    (Q **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2))", "by (simp add: \"1.prems\" matrix_mul_assoc)"], ["proof (state)\nthis:\n  A **\n  Finite_Cartesian_Product.transpose\n   (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n     euclid_ext2) =\n  P ** A_input **\n  (Q **\n   Finite_Cartesian_Product.transpose\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n      euclid_ext2))\n\ngoal (8 subgoals):\n 1. ?x = A $h 0 $h 0\n 2. ?xa = A $h 0 $h 1\n 3. ?xb = A $h 1 $h 0\n 4. ?xc = A $h 1 $h 1\n 5. ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa\n 6. Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) =\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2)\n 7. invertible P\n 8. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0 \\<noteq>\n    (0::'a)", "show \"(A ** ?bezout_mat_right) $h 0 $h 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A **\n     Finite_Cartesian_Product.transpose\n      (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n        euclid_ext2)) $h\n    0 $h\n    0 \\<noteq>\n    (0::'a)", "by (metis (no_types, lifting) a_not_0 bezout_matrix_works_transpose1 bezout_matrix_not_zero  \n           bezout_matrix_works1 is_bezout_ext_euclid_ext2 one_neq_zero transpose_code transpose_row_code)"], ["proof (state)\nthis:\n  (A **\n   Finite_Cartesian_Product.transpose\n    (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n      euclid_ext2)) $h\n  0 $h\n  0 \\<noteq>\n  (0::'a)\n\ngoal (7 subgoals):\n 1. ?x = A $h 0 $h 0\n 2. ?xa = A $h 0 $h 1\n 3. ?xb = A $h 1 $h 0\n 4. ?xc = A $h 1 $h 1\n 5. ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa\n 6. Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) =\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2)\n 7. invertible P", "qed (insert True a_not_0  \"1.prems\", blast+)"], ["proof (state)\nthis:\n  D = P' ** A_input ** Q' \\<and>\n  invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "case False"], ["proof (state)\nthis:\n  \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "note a_dvd_b = False"], ["proof (state)\nthis:\n  \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "proof (cases \"\\<not> ?a dvd ?c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "case True"], ["proof (state)\nthis:\n  \\<not> A $h 0 $h 0 dvd A $h 1 $h 0\n\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "let ?bezout_mat = \"(bezout_matrix A 0 1 0 euclid_ext2)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have \"(P', D, Q') = diagonalize_2x2_aux (P, A, Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P', D, Q') = diagonalize_2x2_aux (P, A, Q)", "using \"1.prems\""], ["proof (prove)\nusing this:\n  A = P ** A_input ** Q\n  invertible P\n  invertible Q\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P', D, Q') = diagonalize_2x2_aux (P, A, Q)", "by blast"], ["proof (state)\nthis:\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "also"], ["proof (state)\nthis:\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have \"... = diagonalize_2x2_aux (?bezout_mat**P, ?bezout_mat ** A, Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diagonalize_2x2_aux (P, A, Q) =\n    diagonalize_2x2_aux\n     (bezout_matrix A 0 1 0 euclid_ext2 ** P,\n      bezout_matrix A 0 1 0 euclid_ext2 ** A, Q)", "using True a_dvd_b a_not_0"], ["proof (prove)\nusing this:\n  \\<not> A $h 0 $h 0 dvd A $h 1 $h 0\n  \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. diagonalize_2x2_aux (P, A, Q) =\n    diagonalize_2x2_aux\n     (bezout_matrix A 0 1 0 euclid_ext2 ** P,\n      bezout_matrix A 0 1 0 euclid_ext2 ** A, Q)", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  diagonalize_2x2_aux (P, A, Q) =\n  diagonalize_2x2_aux\n   (bezout_matrix A 0 1 0 euclid_ext2 ** P,\n    bezout_matrix A 0 1 0 euclid_ext2 ** A, Q)\n\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "finally"], ["proof (chain)\npicking this:\n  (P', D, Q') =\n  diagonalize_2x2_aux\n   (bezout_matrix A 0 1 0 euclid_ext2 ** P,\n    bezout_matrix A 0 1 0 euclid_ext2 ** A, Q)", "have eq: \"(P',D,Q') = ...\""], ["proof (prove)\nusing this:\n  (P', D, Q') =\n  diagonalize_2x2_aux\n   (bezout_matrix A 0 1 0 euclid_ext2 ** P,\n    bezout_matrix A 0 1 0 euclid_ext2 ** A, Q)\n\ngoal (1 subgoal):\n 1. (P', D, Q') =\n    diagonalize_2x2_aux\n     (bezout_matrix A 0 1 0 euclid_ext2 ** P,\n      bezout_matrix A 0 1 0 euclid_ext2 ** A, Q)", "."], ["proof (state)\nthis:\n  (P', D, Q') =\n  diagonalize_2x2_aux\n   (bezout_matrix A 0 1 0 euclid_ext2 ** P,\n    bezout_matrix A 0 1 0 euclid_ext2 ** A, Q)\n\ngoal (2 subgoals):\n 1. \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n 2. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "proof (rule \"1.hyps\"(2)[OF _ _ _ _ _ _ _ _ _ _ eq])"], ["proof (state)\ngoal (11 subgoals):\n 1. ?x = A $h 0 $h 0\n 2. ?xa = A $h 0 $h 1\n 3. ?xb = A $h 1 $h 0\n 4. ?xc = A $h 1 $h 1\n 5. \\<not> (?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa)\n 6. ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xb\n 7. bezout_matrix A 0 1 0 euclid_ext2 = bezout_matrix A 0 1 0 euclid_ext2\n 8. bezout_matrix A 0 1 0 euclid_ext2 ** A =\n    bezout_matrix A 0 1 0 euclid_ext2 ** P ** A_input ** Q\n 9. invertible (bezout_matrix A 0 1 0 euclid_ext2 ** P)\n 10. invertible Q\nA total of 11 subgoals...", "have \"invertible ?bezout_mat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (bezout_matrix A 0 1 0 euclid_ext2)", "by (rule invertible_bezout_matrix[OF ib zero_less_one_type2 a_not_0])"], ["proof (state)\nthis:\n  invertible (bezout_matrix A 0 1 0 euclid_ext2)\n\ngoal (11 subgoals):\n 1. ?x = A $h 0 $h 0\n 2. ?xa = A $h 0 $h 1\n 3. ?xb = A $h 1 $h 0\n 4. ?xc = A $h 1 $h 1\n 5. \\<not> (?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa)\n 6. ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xb\n 7. bezout_matrix A 0 1 0 euclid_ext2 = bezout_matrix A 0 1 0 euclid_ext2\n 8. bezout_matrix A 0 1 0 euclid_ext2 ** A =\n    bezout_matrix A 0 1 0 euclid_ext2 ** P ** A_input ** Q\n 9. invertible (bezout_matrix A 0 1 0 euclid_ext2 ** P)\n 10. invertible Q\nA total of 11 subgoals...", "thus \"invertible (?bezout_mat ** P)\""], ["proof (prove)\nusing this:\n  invertible (bezout_matrix A 0 1 0 euclid_ext2)\n\ngoal (1 subgoal):\n 1. invertible (bezout_matrix A 0 1 0 euclid_ext2 ** P)", "using \"1.prems\" invertible_mult"], ["proof (prove)\nusing this:\n  invertible (bezout_matrix A 0 1 0 euclid_ext2)\n  A = P ** A_input ** Q\n  invertible P\n  invertible Q\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n  A $h 0 $h 0 \\<noteq> (0::'a)\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n\ngoal (1 subgoal):\n 1. invertible (bezout_matrix A 0 1 0 euclid_ext2 ** P)", "by blast"], ["proof (state)\nthis:\n  invertible (bezout_matrix A 0 1 0 euclid_ext2 ** P)\n\ngoal (10 subgoals):\n 1. ?x = A $h 0 $h 0\n 2. ?xa = A $h 0 $h 1\n 3. ?xb = A $h 1 $h 0\n 4. ?xc = A $h 1 $h 1\n 5. \\<not> (?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa)\n 6. ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xb\n 7. bezout_matrix A 0 1 0 euclid_ext2 = bezout_matrix A 0 1 0 euclid_ext2\n 8. bezout_matrix A 0 1 0 euclid_ext2 ** A =\n    bezout_matrix A 0 1 0 euclid_ext2 ** P ** A_input ** Q\n 9. invertible Q\n 10. (bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0 \\<noteq> (0::'a)", "show \"?bezout_mat ** A = (?bezout_mat ** P) ** A_input ** Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_matrix A 0 1 0 euclid_ext2 ** A =\n    bezout_matrix A 0 1 0 euclid_ext2 ** P ** A_input ** Q", "by (simp add: \"1.prems\" matrix_mul_assoc)"], ["proof (state)\nthis:\n  bezout_matrix A 0 1 0 euclid_ext2 ** A =\n  bezout_matrix A 0 1 0 euclid_ext2 ** P ** A_input ** Q\n\ngoal (9 subgoals):\n 1. ?x = A $h 0 $h 0\n 2. ?xa = A $h 0 $h 1\n 3. ?xb = A $h 1 $h 0\n 4. ?xc = A $h 1 $h 1\n 5. \\<not> (?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa)\n 6. ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xb\n 7. bezout_matrix A 0 1 0 euclid_ext2 = bezout_matrix A 0 1 0 euclid_ext2\n 8. invertible Q\n 9. (bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0 \\<noteq> (0::'a)", "show \"(?bezout_mat ** A) $h 0 $h 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0 \\<noteq> (0::'a)", "by (simp add: a_not_0 bezout_matrix_not_zero is_bezout_ext_euclid_ext2)"], ["proof (state)\nthis:\n  (bezout_matrix A 0 1 0 euclid_ext2 ** A) $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (8 subgoals):\n 1. ?x = A $h 0 $h 0\n 2. ?xa = A $h 0 $h 1\n 3. ?xb = A $h 1 $h 0\n 4. ?xc = A $h 1 $h 1\n 5. \\<not> (?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xa)\n 6. ?x \\<noteq> (0::'a) \\<and> \\<not> ?x dvd ?xb\n 7. bezout_matrix A 0 1 0 euclid_ext2 = bezout_matrix A 0 1 0 euclid_ext2\n 8. invertible Q", "qed (insert True a_not_0 a_dvd_b \"1.prems\", blast+)"], ["proof (state)\nthis:\n  D = P' ** A_input ** Q' \\<and>\n  invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "case False"], ["proof (state)\nthis:\n  \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "hence a_dvd_c: \"?a dvd ?c\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0\n\ngoal (1 subgoal):\n 1. A $h 0 $h 0 dvd A $h 1 $h 0", "by simp"], ["proof (state)\nthis:\n  A $h 0 $h 0 dvd A $h 1 $h 0\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "let ?Q' = \"column_add (Finite_Cartesian_Product.mat 1) 1 0 (- (?b div ?a))::'a^2^2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "let ?P' = \"(row_add (Finite_Cartesian_Product.mat 1) 1 0 (- (?c div ?a)))::'a^2^2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have eq: \"(P', D, Q') =  (?P'**P,?P'**A**?Q',Q**?Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P', D, Q') =\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     P,\n     row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0)),\n     Q **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0)))", "using \"1.prems\" a_dvd_b a_dvd_c a_not_0"], ["proof (prove)\nusing this:\n  A = P ** A_input ** Q\n  invertible P\n  invertible Q\n  (P', D, Q') = diagonalize_2x2_aux (P, A, Q)\n  A $h 0 $h 0 \\<noteq> (0::'a)\n  \\<not> \\<not> A $h 0 $h 0 dvd A $h 0 $h 1\n  A $h 0 $h 0 dvd A $h 1 $h 0\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P', D, Q') =\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     P,\n     row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0)),\n     Q **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0)))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  (P', D, Q') =\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   P,\n   row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0)),\n   Q **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0)))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have d: \"isDiagonal (?P'**A**?Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isDiagonal\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isDiagonal\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. isDiagonal\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "fix a b::2"], ["proof (state)\ngoal (1 subgoal):\n 1. isDiagonal\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "assume a_not_b: \"a \\<noteq> b\""], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. isDiagonal\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "have \"(?P' ** A ** ?Q') $h a $h b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "proof (cases \"(a,b) = (0,1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (a, b) = (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)\n 2. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  (a, b) = (0, 1)\n\ngoal (2 subgoals):\n 1. (a, b) = (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)\n 2. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "hence a0: \"a = 0\" and b1: \"b = 1\""], ["proof (prove)\nusing this:\n  (a, b) = (0, 1)\n\ngoal (1 subgoal):\n 1. a = 0 &&& b = 1", "by auto"], ["proof (state)\nthis:\n  a = 0\n  b = 1\n\ngoal (2 subgoals):\n 1. (a, b) = (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)\n 2. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "have \"(?P' ** A ** ?Q') $h a $h b = (?P' ** (A ** ?Q')) $h a $h b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     (A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))) $h\n    a $h\n    b", "by (simp add: matrix_mul_assoc)"], ["proof (state)\nthis:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   (A **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))) $h\n  a $h\n  b\n\ngoal (2 subgoals):\n 1. (a, b) = (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)\n 2. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   (A **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))) $h\n  a $h\n  b\n\ngoal (2 subgoals):\n 1. (a, b) = (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)\n 2. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "have \"... = (A**?Q') $h a $h b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     (A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))) $h\n    a $h\n    b =\n    (A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b", "unfolding row_add_mat_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add\n     (A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))\n     1 0 (- (A $h 1 $h 0 div A $h 0 $h 0)) $h\n    a $h\n    b =\n    (A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b", "by (smt True a_not_b prod.sel(2) row_add_def vec_lambda_beta)"], ["proof (state)\nthis:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   (A **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))) $h\n  a $h\n  b =\n  (A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b\n\ngoal (2 subgoals):\n 1. (a, b) = (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)\n 2. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   (A **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))) $h\n  a $h\n  b =\n  (A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b\n\ngoal (2 subgoals):\n 1. (a, b) = (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)\n 2. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "unfolding column_add_mat_1 a0 b1"], ["proof (prove)\ngoal (1 subgoal):\n 1. column_add A 1 0 (- (A $h 0 $h 1 div A $h 0 $h 0)) $h 0 $h 1 = (0::'a)", "by (smt Groups.mult_ac(2) a_dvd_b ab_group_add_class.ab_left_minus add_0_left\n                add_diff_cancel_left' add_uminus_conv_diff column_add_code_nth column_add_row_def\n                comm_semiring_class.distrib dvd_div_mult_self vec_lambda_beta)"], ["proof (state)\nthis:\n  (A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. (a, b) = (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)\n 2. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "."], ["proof (state)\nthis:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  (a, b) \\<noteq> (0, 1)\n\ngoal (1 subgoal):\n 1. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "hence a1: \"a = 1\" and b0: \"b = 0\""], ["proof (prove)\nusing this:\n  (a, b) \\<noteq> (0, 1)\n\ngoal (1 subgoal):\n 1. a = 1 &&& b = 0", "by (metis (no_types, hide_lams) False a_not_b exhaust_2 zero_neq_one)+"], ["proof (state)\nthis:\n  a = 1\n  b = 0\n\ngoal (1 subgoal):\n 1. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "have \"(?P' ** A ** ?Q') $h a $h b = (?P' ** A) $h a $h b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A) $h\n    a $h\n    b", "unfolding a1 b0 column_add_mat_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. column_add\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      A)\n     1 0 (- (A $h 0 $h 1 div A $h 0 $h 0)) $h\n    1 $h\n    0 =\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A) $h\n    1 $h\n    0", "by (simp add: column_add_code_nth column_add_row_def)"], ["proof (state)\nthis:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A) $h\n  a $h\n  b\n\ngoal (1 subgoal):\n 1. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A) $h\n  a $h\n  b\n\ngoal (1 subgoal):\n 1. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A) $h\n    a $h\n    b =\n    (0::'a)", "unfolding row_add_mat_1 a1 b0"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add A 1 0 (- (A $h 1 $h 0 div A $h 0 $h 0)) $h 1 $h 0 = (0::'a)", "by (simp add: a_dvd_c row_add_def)"], ["proof (state)\nthis:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A) $h\n  a $h\n  b =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (a, b) \\<noteq> (0, 1) \\<Longrightarrow>\n    (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n     A **\n     column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n      (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n    a $h\n    b =\n    (0::'a)", "."], ["proof (state)\nthis:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  a $h\n  b =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. isDiagonal\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "}"], ["proof (state)\nthis:\n  ?a3 \\<noteq> ?b3 \\<Longrightarrow>\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  ?a3 $h\n  ?b3 =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. isDiagonal\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?a3 \\<noteq> ?b3 \\<Longrightarrow>\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  ?a3 $h\n  ?b3 =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. isDiagonal\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      A **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "unfolding isDiagonal_def"], ["proof (prove)\nusing this:\n  ?a3 \\<noteq> ?b3 \\<Longrightarrow>\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n  ?a3 $h\n  ?b3 =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       mod_type_class.to_nat a \\<noteq>\n       mod_type_class.to_nat b \\<longrightarrow>\n       (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n         (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n        A **\n        column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n         (- (A $h 0 $h 1 div A $h 0 $h 0))) $h\n       a $h\n       b =\n       (0::'a)", "by auto"], ["proof (state)\nthis:\n  isDiagonal\n   (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n    A **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isDiagonal\n   (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n    A **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have inv_P': \"invertible ?P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)))", "by (rule invertible_row_add[OF one_not_zero])"], ["proof (state)\nthis:\n  invertible\n   (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 1 $h 0 div A $h 0 $h 0)))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have inv_Q': \"invertible ?Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "by (rule invertible_column_add[OF one_not_zero])"], ["proof (state)\nthis:\n  invertible\n   (column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have \"invertible (?P'**P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      P)", "using \"1.prems\"(2) inv_P' invertible_mult"], ["proof (prove)\nusing this:\n  invertible P\n  invertible\n   (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 1 $h 0 div A $h 0 $h 0)))\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n\ngoal (1 subgoal):\n 1. invertible\n     (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n      P)", "by blast"], ["proof (state)\nthis:\n  invertible\n   (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n    P)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "moreover"], ["proof (state)\nthis:\n  invertible\n   (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n    P)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have \"invertible (Q**?Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (Q **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "using \"1.prems\"(3) inv_Q' invertible_mult"], ["proof (prove)\nusing this:\n  invertible Q\n  invertible\n   (column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n\ngoal (1 subgoal):\n 1. invertible\n     (Q **\n      column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n       (- (A $h 0 $h 1 div A $h 0 $h 0)))", "by blast"], ["proof (state)\nthis:\n  invertible\n   (Q **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "moreover"], ["proof (state)\nthis:\n  invertible\n   (Q **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "have \"D = P' ** A_input ** Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P' ** A_input ** Q'", "by (metis (no_types, lifting) \"1.prems\"(1) Pair_inject eq matrix_mul_assoc)"], ["proof (state)\nthis:\n  D = P' ** A_input ** Q'\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> A $h 0 $h 0 dvd A $h 1 $h 0 \\<Longrightarrow>\n    D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "ultimately"], ["proof (chain)\npicking this:\n  invertible\n   (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n    P)\n  invertible\n   (Q **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))\n  D = P' ** A_input ** Q'", "show ?thesis"], ["proof (prove)\nusing this:\n  invertible\n   (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n    P)\n  invertible\n   (Q **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))\n  D = P' ** A_input ** Q'\n\ngoal (1 subgoal):\n 1. D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "using eq d"], ["proof (prove)\nusing this:\n  invertible\n   (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n    P)\n  invertible\n   (Q **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))\n  D = P' ** A_input ** Q'\n  (P', D, Q') =\n  (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   P,\n   row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n   A **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0)),\n   Q **\n   column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n    (- (A $h 0 $h 1 div A $h 0 $h 0)))\n  isDiagonal\n   (row_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 1 $h 0 div A $h 0 $h 0)) **\n    A **\n    column_add (Finite_Cartesian_Product.mat (1::'a)) 1 0\n     (- (A $h 0 $h 1 div A $h 0 $h 0)))\n\ngoal (1 subgoal):\n 1. D = P' ** A_input ** Q' \\<and>\n    invertible P' \\<and> invertible Q' \\<and> isDiagonal D", "by auto"], ["proof (state)\nthis:\n  D = P' ** A_input ** Q' \\<and>\n  invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D = P' ** A_input ** Q' \\<and>\n  invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D = P' ** A_input ** Q' \\<and>\n  invertible P' \\<and> invertible Q' \\<and> isDiagonal D\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"diagonalize_2x2 A = \n  (if A $h 0 $h 0 = 0 then \n        if A $h 0 $h 1 \\<noteq> 0 then \n            let A' = interchange_columns A 0 1;\n                Q' = interchange_columns (Finite_Cartesian_Product.mat 1) 0 1 in\n            diagonalize_2x2_aux (Finite_Cartesian_Product.mat 1, A', Q')\n        else \n            if A $h 1 $h 0 \\<noteq> 0 then\n                  let A' = interchange_rows A 0 1;\n                      P' = interchange_rows (Finite_Cartesian_Product.mat 1) 0 1 in\n                   diagonalize_2x2_aux (P', A', Finite_Cartesian_Product.mat 1)\n            else (Finite_Cartesian_Product.mat 1,A,Finite_Cartesian_Product.mat 1)\n   else diagonalize_2x2_aux (Finite_Cartesian_Product.mat 1,A,Finite_Cartesian_Product.mat 1)\n)\""], ["", "lemma diagonalize_2x2_works:\n  assumes PDQ: \"(P,D,Q) = diagonalize_2x2 A\"\n  shows \"D = P ** A ** Q \\<and> invertible P \\<and> invertible Q \\<and> isDiagonal D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "let ?a = \"A $h 0 $h 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "let ?b = \"A $h 0 $h 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "let ?c = \"A $h 1 $h 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "let ?d = \"A $h 1 $h 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "proof (cases \"?a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. A $h 0 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "case False"], ["proof (state)\nthis:\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. A $h 0 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "hence eq: \"(P,D,Q) = diagonalize_2x2_aux (Finite_Cartesian_Product.mat 1,A,Finite_Cartesian_Product.mat 1)\""], ["proof (prove)\nusing this:\n  A $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    diagonalize_2x2_aux\n     (Finite_Cartesian_Product.mat (1::'a), A,\n      Finite_Cartesian_Product.mat (1::'a))", "using PDQ"], ["proof (prove)\nusing this:\n  A $h 0 $h 0 \\<noteq> (0::'a)\n  (P, D, Q) = diagonalize_2x2 A\n\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    diagonalize_2x2_aux\n     (Finite_Cartesian_Product.mat (1::'a), A,\n      Finite_Cartesian_Product.mat (1::'a))", "unfolding diagonalize_2x2_def"], ["proof (prove)\nusing this:\n  A $h 0 $h 0 \\<noteq> (0::'a)\n  (P, D, Q) =\n  (if A $h 0 $h 0 = (0::'a)\n   then if A $h 0 $h 1 \\<noteq> (0::'a)\n        then let A' = interchange_columns A 0 1;\n                 Q' = interchange_columns\n                       (Finite_Cartesian_Product.mat (1::'a)) 0 1\n             in diagonalize_2x2_aux\n                 (Finite_Cartesian_Product.mat (1::'a), A', Q')\n        else if A $h 1 $h 0 \\<noteq> (0::'a)\n             then let A' = interchange_rows A 0 1;\n                      P' = interchange_rows\n                            (Finite_Cartesian_Product.mat (1::'a)) 0 1\n                  in diagonalize_2x2_aux\n                      (P', A', Finite_Cartesian_Product.mat (1::'a))\n             else (Finite_Cartesian_Product.mat (1::'a), A,\n                   Finite_Cartesian_Product.mat (1::'a))\n   else diagonalize_2x2_aux\n         (Finite_Cartesian_Product.mat (1::'a), A,\n          Finite_Cartesian_Product.mat (1::'a)))\n\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    diagonalize_2x2_aux\n     (Finite_Cartesian_Product.mat (1::'a), A,\n      Finite_Cartesian_Product.mat (1::'a))", "by auto"], ["proof (state)\nthis:\n  (P, D, Q) =\n  diagonalize_2x2_aux\n   (Finite_Cartesian_Product.mat (1::'a), A,\n    Finite_Cartesian_Product.mat (1::'a))\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. A $h 0 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "by (rule diagonalize_2x2_aux_works[OF _ _ _ eq False], auto simp add: invertible_mat_1)"], ["proof (state)\nthis:\n  D = P ** A ** Q \\<and>\n  invertible P \\<and> invertible Q \\<and> isDiagonal D\n\ngoal (1 subgoal):\n 1. A $h 0 $h 0 = (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A $h 0 $h 0 = (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "case True"], ["proof (state)\nthis:\n  A $h 0 $h 0 = (0::'a)\n\ngoal (1 subgoal):\n 1. A $h 0 $h 0 = (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "note a0 = True"], ["proof (state)\nthis:\n  A $h 0 $h 0 = (0::'a)\n\ngoal (1 subgoal):\n 1. A $h 0 $h 0 = (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "proof (cases \"?b \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. \\<not> A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "case True"], ["proof (state)\nthis:\n  A $h 0 $h 1 \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. \\<not> A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "let ?A' = \"interchange_columns A 0 1\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. \\<not> A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "let ?Q' = \"(interchange_columns (Finite_Cartesian_Product.mat 1) 0 1)::'a^2^2\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. \\<not> A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "have eq: \"(P,D,Q) = diagonalize_2x2_aux (Finite_Cartesian_Product.mat 1, ?A', ?Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    diagonalize_2x2_aux\n     (Finite_Cartesian_Product.mat (1::'a), interchange_columns A 0 1,\n      interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1)", "using PDQ a0 True"], ["proof (prove)\nusing this:\n  (P, D, Q) = diagonalize_2x2 A\n  A $h 0 $h 0 = (0::'a)\n  A $h 0 $h 1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    diagonalize_2x2_aux\n     (Finite_Cartesian_Product.mat (1::'a), interchange_columns A 0 1,\n      interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1)", "unfolding diagonalize_2x2_def"], ["proof (prove)\nusing this:\n  (P, D, Q) =\n  (if A $h 0 $h 0 = (0::'a)\n   then if A $h 0 $h 1 \\<noteq> (0::'a)\n        then let A' = interchange_columns A 0 1;\n                 Q' = interchange_columns\n                       (Finite_Cartesian_Product.mat (1::'a)) 0 1\n             in diagonalize_2x2_aux\n                 (Finite_Cartesian_Product.mat (1::'a), A', Q')\n        else if A $h 1 $h 0 \\<noteq> (0::'a)\n             then let A' = interchange_rows A 0 1;\n                      P' = interchange_rows\n                            (Finite_Cartesian_Product.mat (1::'a)) 0 1\n                  in diagonalize_2x2_aux\n                      (P', A', Finite_Cartesian_Product.mat (1::'a))\n             else (Finite_Cartesian_Product.mat (1::'a), A,\n                   Finite_Cartesian_Product.mat (1::'a))\n   else diagonalize_2x2_aux\n         (Finite_Cartesian_Product.mat (1::'a), A,\n          Finite_Cartesian_Product.mat (1::'a)))\n  A $h 0 $h 0 = (0::'a)\n  A $h 0 $h 1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    diagonalize_2x2_aux\n     (Finite_Cartesian_Product.mat (1::'a), interchange_columns A 0 1,\n      interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1)", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  (P, D, Q) =\n  diagonalize_2x2_aux\n   (Finite_Cartesian_Product.mat (1::'a), interchange_columns A 0 1,\n    interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1)\n\ngoal (2 subgoals):\n 1. A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. \\<not> A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "proof (rule diagonalize_2x2_aux_works[OF _ _ _ eq _])"], ["proof (state)\ngoal (4 subgoals):\n 1. interchange_columns A 0 1 =\n    Finite_Cartesian_Product.mat (1::'a) ** A **\n    interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1\n 2. invertible (Finite_Cartesian_Product.mat (1::'a))\n 3. invertible\n     (interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1)\n 4. interchange_columns A 0 1 $h 0 $h 0 \\<noteq> (0::'a)", "show \"?A' $h 0 $h 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_columns A 0 1 $h 0 $h 0 \\<noteq> (0::'a)", "by (simp add: True interchange_columns_code interchange_columns_code_nth)"], ["proof (state)\nthis:\n  interchange_columns A 0 1 $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. interchange_columns A 0 1 =\n    Finite_Cartesian_Product.mat (1::'a) ** A **\n    interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1\n 2. invertible (Finite_Cartesian_Product.mat (1::'a))\n 3. invertible\n     (interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1)", "show \"invertible ?Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1)", "by (simp add: invertible_interchange_columns)"], ["proof (state)\nthis:\n  invertible\n   (interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1)\n\ngoal (2 subgoals):\n 1. interchange_columns A 0 1 =\n    Finite_Cartesian_Product.mat (1::'a) ** A **\n    interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1\n 2. invertible (Finite_Cartesian_Product.mat (1::'a))", "show \"?A' = Finite_Cartesian_Product.mat 1 ** A ** ?Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_columns A 0 1 =\n    Finite_Cartesian_Product.mat (1::'a) ** A **\n    interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1", "by (simp add: interchange_columns_mat_1)"], ["proof (state)\nthis:\n  interchange_columns A 0 1 =\n  Finite_Cartesian_Product.mat (1::'a) ** A **\n  interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.mat (1::'a))", "qed (auto simp add: invertible_mat_1)"], ["proof (state)\nthis:\n  D = P ** A ** Q \\<and>\n  invertible P \\<and> invertible Q \\<and> isDiagonal D\n\ngoal (1 subgoal):\n 1. \\<not> A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "case False"], ["proof (state)\nthis:\n  \\<not> A $h 0 $h 1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "note b0 = False"], ["proof (state)\nthis:\n  \\<not> A $h 0 $h 1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "proof (cases \"?c \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. \\<not> A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "case True"], ["proof (state)\nthis:\n  A $h 1 $h 0 \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. \\<not> A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "let ?A' = \"interchange_rows A 0 1\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. \\<not> A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "let ?P' = \"(interchange_rows (Finite_Cartesian_Product.mat 1) 0 1)::'a^2^2\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. \\<not> A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "have eq: \"(P,D,Q) = diagonalize_2x2_aux (?P', ?A',Finite_Cartesian_Product.mat 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    diagonalize_2x2_aux\n     (interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1,\n      interchange_rows A 0 1, Finite_Cartesian_Product.mat (1::'a))", "using PDQ a0 b0 True"], ["proof (prove)\nusing this:\n  (P, D, Q) = diagonalize_2x2 A\n  A $h 0 $h 0 = (0::'a)\n  \\<not> A $h 0 $h 1 \\<noteq> (0::'a)\n  A $h 1 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    diagonalize_2x2_aux\n     (interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1,\n      interchange_rows A 0 1, Finite_Cartesian_Product.mat (1::'a))", "unfolding diagonalize_2x2_def"], ["proof (prove)\nusing this:\n  (P, D, Q) =\n  (if A $h 0 $h 0 = (0::'a)\n   then if A $h 0 $h 1 \\<noteq> (0::'a)\n        then let A' = interchange_columns A 0 1;\n                 Q' = interchange_columns\n                       (Finite_Cartesian_Product.mat (1::'a)) 0 1\n             in diagonalize_2x2_aux\n                 (Finite_Cartesian_Product.mat (1::'a), A', Q')\n        else if A $h 1 $h 0 \\<noteq> (0::'a)\n             then let A' = interchange_rows A 0 1;\n                      P' = interchange_rows\n                            (Finite_Cartesian_Product.mat (1::'a)) 0 1\n                  in diagonalize_2x2_aux\n                      (P', A', Finite_Cartesian_Product.mat (1::'a))\n             else (Finite_Cartesian_Product.mat (1::'a), A,\n                   Finite_Cartesian_Product.mat (1::'a))\n   else diagonalize_2x2_aux\n         (Finite_Cartesian_Product.mat (1::'a), A,\n          Finite_Cartesian_Product.mat (1::'a)))\n  A $h 0 $h 0 = (0::'a)\n  \\<not> A $h 0 $h 1 \\<noteq> (0::'a)\n  A $h 1 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    diagonalize_2x2_aux\n     (interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1,\n      interchange_rows A 0 1, Finite_Cartesian_Product.mat (1::'a))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  (P, D, Q) =\n  diagonalize_2x2_aux\n   (interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1,\n    interchange_rows A 0 1, Finite_Cartesian_Product.mat (1::'a))\n\ngoal (2 subgoals):\n 1. A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D\n 2. \\<not> A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "proof (rule diagonalize_2x2_aux_works[OF _ _ _ eq _])"], ["proof (state)\ngoal (4 subgoals):\n 1. interchange_rows A 0 1 =\n    interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1 ** A **\n    Finite_Cartesian_Product.mat (1::'a)\n 2. invertible (interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1)\n 3. invertible (Finite_Cartesian_Product.mat (1::'a))\n 4. interchange_rows A 0 1 $h 0 $h 0 \\<noteq> (0::'a)", "show \"?A' $h 0 $h 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A 0 1 $h 0 $h 0 \\<noteq> (0::'a)", "by (simp add: True interchange_columns_code interchange_columns_code_nth)"], ["proof (state)\nthis:\n  interchange_rows A 0 1 $h 0 $h 0 \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. interchange_rows A 0 1 =\n    interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1 ** A **\n    Finite_Cartesian_Product.mat (1::'a)\n 2. invertible (interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1)\n 3. invertible (Finite_Cartesian_Product.mat (1::'a))", "show \"invertible ?P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1)", "by (simp add: invertible_interchange_rows)"], ["proof (state)\nthis:\n  invertible (interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1)\n\ngoal (2 subgoals):\n 1. interchange_rows A 0 1 =\n    interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1 ** A **\n    Finite_Cartesian_Product.mat (1::'a)\n 2. invertible (Finite_Cartesian_Product.mat (1::'a))", "show \"?A' = ?P' ** A ** Finite_Cartesian_Product.mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A 0 1 =\n    interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1 ** A **\n    Finite_Cartesian_Product.mat (1::'a)", "by (simp add: interchange_rows_mat_1)"], ["proof (state)\nthis:\n  interchange_rows A 0 1 =\n  interchange_rows (Finite_Cartesian_Product.mat (1::'a)) 0 1 ** A **\n  Finite_Cartesian_Product.mat (1::'a)\n\ngoal (1 subgoal):\n 1. invertible (Finite_Cartesian_Product.mat (1::'a))", "qed (auto simp add: invertible_mat_1)"], ["proof (state)\nthis:\n  D = P ** A ** Q \\<and>\n  invertible P \\<and> invertible Q \\<and> isDiagonal D\n\ngoal (1 subgoal):\n 1. \\<not> A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "case False"], ["proof (state)\nthis:\n  \\<not> A $h 1 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "have eq: \"(P,D,Q) = (Finite_Cartesian_Product.mat 1, A,Finite_Cartesian_Product.mat 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    (Finite_Cartesian_Product.mat (1::'a), A,\n     Finite_Cartesian_Product.mat (1::'a))", "using PDQ a0 b0 True False"], ["proof (prove)\nusing this:\n  (P, D, Q) = diagonalize_2x2 A\n  A $h 0 $h 0 = (0::'a)\n  \\<not> A $h 0 $h 1 \\<noteq> (0::'a)\n  A $h 0 $h 0 = (0::'a)\n  \\<not> A $h 1 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    (Finite_Cartesian_Product.mat (1::'a), A,\n     Finite_Cartesian_Product.mat (1::'a))", "unfolding diagonalize_2x2_def"], ["proof (prove)\nusing this:\n  (P, D, Q) =\n  (if A $h 0 $h 0 = (0::'a)\n   then if A $h 0 $h 1 \\<noteq> (0::'a)\n        then let A' = interchange_columns A 0 1;\n                 Q' = interchange_columns\n                       (Finite_Cartesian_Product.mat (1::'a)) 0 1\n             in diagonalize_2x2_aux\n                 (Finite_Cartesian_Product.mat (1::'a), A', Q')\n        else if A $h 1 $h 0 \\<noteq> (0::'a)\n             then let A' = interchange_rows A 0 1;\n                      P' = interchange_rows\n                            (Finite_Cartesian_Product.mat (1::'a)) 0 1\n                  in diagonalize_2x2_aux\n                      (P', A', Finite_Cartesian_Product.mat (1::'a))\n             else (Finite_Cartesian_Product.mat (1::'a), A,\n                   Finite_Cartesian_Product.mat (1::'a))\n   else diagonalize_2x2_aux\n         (Finite_Cartesian_Product.mat (1::'a), A,\n          Finite_Cartesian_Product.mat (1::'a)))\n  A $h 0 $h 0 = (0::'a)\n  \\<not> A $h 0 $h 1 \\<noteq> (0::'a)\n  A $h 0 $h 0 = (0::'a)\n  \\<not> A $h 1 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (P, D, Q) =\n    (Finite_Cartesian_Product.mat (1::'a), A,\n     Finite_Cartesian_Product.mat (1::'a))", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  (P, D, Q) =\n  (Finite_Cartesian_Product.mat (1::'a), A,\n   Finite_Cartesian_Product.mat (1::'a))\n\ngoal (1 subgoal):\n 1. \\<not> A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "have \"isDiagonal A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isDiagonal A", "unfolding isDiagonal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       mod_type_class.to_nat a \\<noteq>\n       mod_type_class.to_nat b \\<longrightarrow>\n       A $h a $h b = (0::'a)", "using a0 b0 True False"], ["proof (prove)\nusing this:\n  A $h 0 $h 0 = (0::'a)\n  \\<not> A $h 0 $h 1 \\<noteq> (0::'a)\n  A $h 0 $h 0 = (0::'a)\n  \\<not> A $h 1 $h 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       mod_type_class.to_nat a \\<noteq>\n       mod_type_class.to_nat b \\<longrightarrow>\n       A $h a $h b = (0::'a)", "by (metis (full_types) exhaust_2 one_neq_zero)"], ["proof (state)\nthis:\n  isDiagonal A\n\ngoal (1 subgoal):\n 1. \\<not> A $h 1 $h 0 \\<noteq> (0::'a) \\<Longrightarrow>\n    D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "thus ?thesis"], ["proof (prove)\nusing this:\n  isDiagonal A\n\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "using invertible_mat_1 eq"], ["proof (prove)\nusing this:\n  isDiagonal A\n  invertible (Finite_Cartesian_Product.mat (1::?'a))\n  (P, D, Q) =\n  (Finite_Cartesian_Product.mat (1::'a), A,\n   Finite_Cartesian_Product.mat (1::'a))\n\ngoal (1 subgoal):\n 1. D = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> isDiagonal D", "by auto"], ["proof (state)\nthis:\n  D = P ** A ** Q \\<and>\n  invertible P \\<and> invertible Q \\<and> isDiagonal D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D = P ** A ** Q \\<and>\n  invertible P \\<and> invertible Q \\<and> isDiagonal D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D = P ** A ** Q \\<and>\n  invertible P \\<and> invertible Q \\<and> isDiagonal D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D = P ** A ** Q \\<and>\n  invertible P \\<and> invertible Q \\<and> isDiagonal D\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"diagonalize_2x2_JNF (A::'a::euclidean_ring_gcd mat) \n  = (let (P,D,Q) = diagonalize_2x2 (Mod_Type_Connect.to_hma\\<^sub>m A::'a^2^2) in \n  (Mod_Type_Connect.from_hma\\<^sub>m P,Mod_Type_Connect.from_hma\\<^sub>m D,Mod_Type_Connect.from_hma\\<^sub>m Q))\""], ["", "(*Obtained via transfer rules*)"], ["", "lemma diagonalize_2x2_JNF_works:\n  assumes A: \"A \\<in> carrier_mat 2 2\"\n  and PDQ: \"(P,D,Q) = diagonalize_2x2_JNF A\"\n  shows \"D = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> isDiagonal_mat D \\<and> P\\<in>carrier_mat 2 2\n  \\<and> Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "let ?A = \"(Mod_Type_Connect.to_hma\\<^sub>m A::'a^2^2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "have A[transfer_rule]: \"Mod_Type_Connect.HMA_M A ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. A =\n    Mod_Type_Connect.from_hma\\<^sub>m (Mod_Type_Connect.to_hma\\<^sub>m A)", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M A (Mod_Type_Connect.to_hma\\<^sub>m A)\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "obtain P_HMA D_HMA Q_HMA where PDQ_HMA: \"(P_HMA,D_HMA,Q_HMA) = diagonalize_2x2 ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P_HMA D_HMA Q_HMA.\n        (P_HMA, D_HMA, Q_HMA) =\n        diagonalize_2x2\n         (Mod_Type_Connect.to_hma\\<^sub>m A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (P_HMA, D_HMA, Q_HMA) =\n  diagonalize_2x2 (Mod_Type_Connect.to_hma\\<^sub>m A)\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "(*  have \"HMA_M3 (diagonalize_2x2_JNF A) (diagonalize_2x2 ?A)\"\n    using HMA_diagonalize_2x2 A rel_funE by fastforce*)"], ["proof (state)\nthis:\n  (P_HMA, D_HMA, Q_HMA) =\n  diagonalize_2x2 (Mod_Type_Connect.to_hma\\<^sub>m A)\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "have P: \"P = Mod_Type_Connect.from_hma\\<^sub>m P_HMA\" and Q: \"Q = Mod_Type_Connect.from_hma\\<^sub>m Q_HMA\" \n    and D: \"D = Mod_Type_Connect.from_hma\\<^sub>m D_HMA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Mod_Type_Connect.from_hma\\<^sub>m P_HMA &&&\n    Q = Mod_Type_Connect.from_hma\\<^sub>m Q_HMA &&&\n    D = Mod_Type_Connect.from_hma\\<^sub>m D_HMA", "using PDQ_HMA PDQ"], ["proof (prove)\nusing this:\n  (P_HMA, D_HMA, Q_HMA) =\n  diagonalize_2x2 (Mod_Type_Connect.to_hma\\<^sub>m A)\n  (P, D, Q) = diagonalize_2x2_JNF A\n\ngoal (1 subgoal):\n 1. P = Mod_Type_Connect.from_hma\\<^sub>m P_HMA &&&\n    Q = Mod_Type_Connect.from_hma\\<^sub>m Q_HMA &&&\n    D = Mod_Type_Connect.from_hma\\<^sub>m D_HMA", "unfolding diagonalize_2x2_JNF_def"], ["proof (prove)\nusing this:\n  (P_HMA, D_HMA, Q_HMA) =\n  diagonalize_2x2 (Mod_Type_Connect.to_hma\\<^sub>m A)\n  (P, D, Q) =\n  (let (P, D, Q) = diagonalize_2x2 (Mod_Type_Connect.to_hma\\<^sub>m A)\n   in (Mod_Type_Connect.from_hma\\<^sub>m P,\n       Mod_Type_Connect.from_hma\\<^sub>m D,\n       Mod_Type_Connect.from_hma\\<^sub>m Q))\n\ngoal (1 subgoal):\n 1. P = Mod_Type_Connect.from_hma\\<^sub>m P_HMA &&&\n    Q = Mod_Type_Connect.from_hma\\<^sub>m Q_HMA &&&\n    D = Mod_Type_Connect.from_hma\\<^sub>m D_HMA", "by (metis prod.simps(1) split_conv)+"], ["proof (state)\nthis:\n  P = Mod_Type_Connect.from_hma\\<^sub>m P_HMA\n  Q = Mod_Type_Connect.from_hma\\<^sub>m Q_HMA\n  D = Mod_Type_Connect.from_hma\\<^sub>m D_HMA\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M P P_HMA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M P P_HMA", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Mod_Type_Connect.from_hma\\<^sub>m P_HMA", "using P"], ["proof (prove)\nusing this:\n  P = Mod_Type_Connect.from_hma\\<^sub>m P_HMA\n\ngoal (1 subgoal):\n 1. P = Mod_Type_Connect.from_hma\\<^sub>m P_HMA", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M P P_HMA\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M Q Q_HMA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M Q Q_HMA", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = Mod_Type_Connect.from_hma\\<^sub>m Q_HMA", "using Q"], ["proof (prove)\nusing this:\n  Q = Mod_Type_Connect.from_hma\\<^sub>m Q_HMA\n\ngoal (1 subgoal):\n 1. Q = Mod_Type_Connect.from_hma\\<^sub>m Q_HMA", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M Q Q_HMA\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "have [transfer_rule]: \"Mod_Type_Connect.HMA_M D D_HMA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mod_Type_Connect.HMA_M D D_HMA", "unfolding Mod_Type_Connect.HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D = Mod_Type_Connect.from_hma\\<^sub>m D_HMA", "using D"], ["proof (prove)\nusing this:\n  D = Mod_Type_Connect.from_hma\\<^sub>m D_HMA\n\ngoal (1 subgoal):\n 1. D = Mod_Type_Connect.from_hma\\<^sub>m D_HMA", "by auto"], ["proof (state)\nthis:\n  Mod_Type_Connect.HMA_M D D_HMA\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "have r: \"D_HMA = P_HMA ** ?A ** Q_HMA \\<and> invertible P_HMA \\<and> invertible Q_HMA \\<and> isDiagonal D_HMA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D_HMA = P_HMA ** Mod_Type_Connect.to_hma\\<^sub>m A ** Q_HMA \\<and>\n    invertible P_HMA \\<and> invertible Q_HMA \\<and> isDiagonal D_HMA", "by (rule diagonalize_2x2_works[OF PDQ_HMA])"], ["proof (state)\nthis:\n  D_HMA = P_HMA ** Mod_Type_Connect.to_hma\\<^sub>m A ** Q_HMA \\<and>\n  invertible P_HMA \\<and> invertible Q_HMA \\<and> isDiagonal D_HMA\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "have \"D = P * A * Q \\<and> invertible_mat P \\<and> invertible_mat Q \\<and> isDiagonal_mat D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> isDiagonal_mat D", "using r"], ["proof (prove)\nusing this:\n  D_HMA = P_HMA ** Mod_Type_Connect.to_hma\\<^sub>m A ** Q_HMA \\<and>\n  invertible P_HMA \\<and> invertible Q_HMA \\<and> isDiagonal D_HMA\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and> invertible_mat Q \\<and> isDiagonal_mat D", "by (transfer, rule)"], ["proof (state)\nthis:\n  D = P * A * Q \\<and>\n  invertible_mat P \\<and> invertible_mat Q \\<and> isDiagonal_mat D\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  D = P * A * Q \\<and>\n  invertible_mat P \\<and> invertible_mat Q \\<and> isDiagonal_mat D\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "using P Q D"], ["proof (prove)\nusing this:\n  D = P * A * Q \\<and>\n  invertible_mat P \\<and> invertible_mat Q \\<and> isDiagonal_mat D\n  P = Mod_Type_Connect.from_hma\\<^sub>m P_HMA\n  Q = Mod_Type_Connect.from_hma\\<^sub>m Q_HMA\n  D = Mod_Type_Connect.from_hma\\<^sub>m D_HMA\n\ngoal (1 subgoal):\n 1. D = P * A * Q \\<and>\n    invertible_mat P \\<and>\n    invertible_mat Q \\<and>\n    isDiagonal_mat D \\<and>\n    P \\<in> carrier_mat 2 2 \\<and>\n    Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "by auto"], ["proof (state)\nthis:\n  D = P * A * Q \\<and>\n  invertible_mat P \\<and>\n  invertible_mat Q \\<and>\n  isDiagonal_mat D \\<and>\n  P \\<in> carrier_mat 2 2 \\<and>\n  Q \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\n\ngoal:\nNo subgoals!", "qed"], ["", "(*The full algorithm in HOL Analysis*)"], ["", "definition \"Smith_2x2_eucl A = (\n  let (P,D,Q) = diagonalize_2x2 A;\n      (P',S,Q') = diagonal_to_Smith_PQ D euclid_ext2\n  in (P' ** P, S, Q ** Q'))\""], ["", "lemma Smith_2x2_eucl_works:\n  assumes PBQ: \"(P,S,Q) = Smith_2x2_eucl A\"\n  shows \"S = P ** A ** Q \\<and> invertible P \\<and> invertible Q \\<and> Smith_normal_form S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> Smith_normal_form S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> Smith_normal_form S", "have ib: \"is_bezout_ext euclid_ext2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bezout_ext euclid_ext2", "by (simp add: is_bezout_ext_euclid_ext2)"], ["proof (state)\nthis:\n  is_bezout_ext euclid_ext2\n\ngoal (1 subgoal):\n 1. S = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> Smith_normal_form S", "obtain P1 D Q1 where P1DQ1: \"(P1,D,Q1) = diagonalize_2x2 A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P1 D Q1.\n        (P1, D, Q1) = diagonalize_2x2 A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (P1, D, Q1) = diagonalize_2x2 A\n\ngoal (1 subgoal):\n 1. S = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> Smith_normal_form S", "obtain P2 S' Q2 where P2SQ2:\"(P2,S',Q2) = diagonal_to_Smith_PQ D euclid_ext2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P2 S' Q2.\n        (P2, S', Q2) = diagonal_to_Smith_PQ D euclid_ext2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (P2, S', Q2) = diagonal_to_Smith_PQ D euclid_ext2\n\ngoal (1 subgoal):\n 1. S = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> Smith_normal_form S", "have P: \"P = P2 ** P1\" and S: \"S = S'\" and Q: \"Q = Q1 ** Q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = P2 ** P1 &&& S = S' &&& Q = Q1 ** Q2", "by (metis (mono_tags, lifting) PBQ Pair_inject Smith_2x2_eucl_def P1DQ1 P2SQ2 old.prod.case)+"], ["proof (state)\nthis:\n  P = P2 ** P1\n  S = S'\n  Q = Q1 ** Q2\n\ngoal (1 subgoal):\n 1. S = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> Smith_normal_form S", "have 1: \"D = P1 ** A ** Q1 \\<and> invertible P1 \\<and> invertible Q1 \\<and> isDiagonal D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P1 ** A ** Q1 \\<and>\n    invertible P1 \\<and> invertible Q1 \\<and> isDiagonal D", "by (rule diagonalize_2x2_works[OF P1DQ1])"], ["proof (state)\nthis:\n  D = P1 ** A ** Q1 \\<and>\n  invertible P1 \\<and> invertible Q1 \\<and> isDiagonal D\n\ngoal (1 subgoal):\n 1. S = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> Smith_normal_form S", "have 2: \"S' = P2 ** D ** Q2 \\<and> invertible P2 \\<and> invertible Q2 \\<and> Smith_normal_form S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S' = P2 ** D ** Q2 \\<and>\n    invertible P2 \\<and> invertible Q2 \\<and> Smith_normal_form S'", "by (rule diagonal_to_Smith_PQ'[OF _ ib P2SQ2], insert 1, auto)"], ["proof (state)\nthis:\n  S' = P2 ** D ** Q2 \\<and>\n  invertible P2 \\<and> invertible Q2 \\<and> Smith_normal_form S'\n\ngoal (1 subgoal):\n 1. S = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> Smith_normal_form S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. S = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> Smith_normal_form S", "using 1 2 P S Q"], ["proof (prove)\nusing this:\n  D = P1 ** A ** Q1 \\<and>\n  invertible P1 \\<and> invertible Q1 \\<and> isDiagonal D\n  S' = P2 ** D ** Q2 \\<and>\n  invertible P2 \\<and> invertible Q2 \\<and> Smith_normal_form S'\n  P = P2 ** P1\n  S = S'\n  Q = Q1 ** Q2\n\ngoal (1 subgoal):\n 1. S = P ** A ** Q \\<and>\n    invertible P \\<and> invertible Q \\<and> Smith_normal_form S", "by (simp add: 2 invertible_mult matrix_mul_assoc)"], ["proof (state)\nthis:\n  S = P ** A ** Q \\<and>\n  invertible P \\<and> invertible Q \\<and> Smith_normal_form S\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>An executable algorithm to transform $2 \\times 2$ matrices into its Smith normal form\nin JNF\\<close>"], ["", "(*The full algorithm in JNF*)"], ["", "definition \"Smith_2x2_JNF_eucl A = (\n  let (P,D,Q) = diagonalize_2x2_JNF A;\n      (P',S,Q') = diagonal_to_Smith_PQ_JNF D euclid_ext2\n  in (P' * P, S, Q * Q'))\""], ["", "lemma Smith_2x2_JNF_eucl_works:\n  assumes A: \"A \\<in> carrier_mat 2 2\"\n    and PBQ: \"(P,S,Q) = Smith_2x2_JNF_eucl A\"\n  shows \"is_SNF A (P,S,Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_SNF A (P, S, Q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_SNF A (P, S, Q)", "have ib: \"is_bezout_ext euclid_ext2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bezout_ext euclid_ext2", "by (simp add: is_bezout_ext_euclid_ext2)"], ["proof (state)\nthis:\n  is_bezout_ext euclid_ext2\n\ngoal (1 subgoal):\n 1. is_SNF A (P, S, Q)", "obtain P1 D Q1 where P1DQ1: \"(P1,D,Q1) = diagonalize_2x2_JNF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P1 D Q1.\n        (P1, D, Q1) = diagonalize_2x2_JNF A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (P1, D, Q1) = diagonalize_2x2_JNF A\n\ngoal (1 subgoal):\n 1. is_SNF A (P, S, Q)", "obtain P2 S' Q2 where P2SQ2: \"(P2,S',Q2) = diagonal_to_Smith_PQ_JNF D euclid_ext2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P2 S' Q2.\n        (P2, S', Q2) =\n        diagonal_to_Smith_PQ_JNF D euclid_ext2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (P2, S', Q2) = diagonal_to_Smith_PQ_JNF D euclid_ext2\n\ngoal (1 subgoal):\n 1. is_SNF A (P, S, Q)", "have P: \"P = P2 * P1\" and S: \"S = S'\" and Q: \"Q = Q1 * Q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = P2 * P1 &&& S = S' &&& Q = Q1 * Q2", "by (metis (mono_tags, lifting) PBQ Pair_inject Smith_2x2_JNF_eucl_def P1DQ1 P2SQ2 old.prod.case)+"], ["proof (state)\nthis:\n  P = P2 * P1\n  S = S'\n  Q = Q1 * Q2\n\ngoal (1 subgoal):\n 1. is_SNF A (P, S, Q)", "have 1: \"D = P1 * A * Q1 \\<and> invertible_mat P1 \\<and> invertible_mat Q1 \\<and> isDiagonal_mat D\n    \\<and> P1 \\<in> carrier_mat 2 2 \\<and> Q1 \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = P1 * A * Q1 \\<and>\n    invertible_mat P1 \\<and>\n    invertible_mat Q1 \\<and>\n    isDiagonal_mat D \\<and>\n    P1 \\<in> carrier_mat 2 2 \\<and>\n    Q1 \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2", "by (rule diagonalize_2x2_JNF_works[OF A P1DQ1])"], ["proof (state)\nthis:\n  D = P1 * A * Q1 \\<and>\n  invertible_mat P1 \\<and>\n  invertible_mat Q1 \\<and>\n  isDiagonal_mat D \\<and>\n  P1 \\<in> carrier_mat 2 2 \\<and>\n  Q1 \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. is_SNF A (P, S, Q)", "have 2: \"S' = P2 * D * Q2 \\<and> invertible_mat P2 \\<and> invertible_mat Q2 \\<and> Smith_normal_form_mat S' \n        \\<and> P2 \\<in> carrier_mat 2 2 \\<and> S' \\<in> carrier_mat 2 2 \\<and> Q2 \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S' = P2 * D * Q2 \\<and>\n    invertible_mat P2 \\<and>\n    invertible_mat Q2 \\<and>\n    Smith_normal_form_mat S' \\<and>\n    P2 \\<in> carrier_mat 2 2 \\<and>\n    S' \\<in> carrier_mat 2 2 \\<and> Q2 \\<in> carrier_mat 2 2", "by (rule diagonal_to_Smith_PQ_JNF[OF _ ib _ P2SQ2], insert 1, auto)"], ["proof (state)\nthis:\n  S' = P2 * D * Q2 \\<and>\n  invertible_mat P2 \\<and>\n  invertible_mat Q2 \\<and>\n  Smith_normal_form_mat S' \\<and>\n  P2 \\<in> carrier_mat 2 2 \\<and>\n  S' \\<in> carrier_mat 2 2 \\<and> Q2 \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. is_SNF A (P, S, Q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_SNF A (P, S, Q)", "proof (rule is_SNF_intro)"], ["proof (state)\ngoal (6 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. invertible_mat P\n 4. invertible_mat Q\n 5. Smith_normal_form_mat S\n 6. S = P * A * Q", "have dim_Q: \"Q \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<in> carrier_mat 2 2", "using Q 1 2"], ["proof (prove)\nusing this:\n  Q = Q1 * Q2\n  D = P1 * A * Q1 \\<and>\n  invertible_mat P1 \\<and>\n  invertible_mat Q1 \\<and>\n  isDiagonal_mat D \\<and>\n  P1 \\<in> carrier_mat 2 2 \\<and>\n  Q1 \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\n  S' = P2 * D * Q2 \\<and>\n  invertible_mat P2 \\<and>\n  invertible_mat Q2 \\<and>\n  Smith_normal_form_mat S' \\<and>\n  P2 \\<in> carrier_mat 2 2 \\<and>\n  S' \\<in> carrier_mat 2 2 \\<and> Q2 \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. Q \\<in> carrier_mat 2 2", "by auto"], ["proof (state)\nthis:\n  Q \\<in> carrier_mat 2 2\n\ngoal (6 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. invertible_mat P\n 4. invertible_mat Q\n 5. Smith_normal_form_mat S\n 6. S = P * A * Q", "have P1AQ1: \"(P1*A*Q1) \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1 * A * Q1 \\<in> carrier_mat 2 2", "using 1 2 A"], ["proof (prove)\nusing this:\n  D = P1 * A * Q1 \\<and>\n  invertible_mat P1 \\<and>\n  invertible_mat Q1 \\<and>\n  isDiagonal_mat D \\<and>\n  P1 \\<in> carrier_mat 2 2 \\<and>\n  Q1 \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\n  S' = P2 * D * Q2 \\<and>\n  invertible_mat P2 \\<and>\n  invertible_mat Q2 \\<and>\n  Smith_normal_form_mat S' \\<and>\n  P2 \\<in> carrier_mat 2 2 \\<and>\n  S' \\<in> carrier_mat 2 2 \\<and> Q2 \\<in> carrier_mat 2 2\n  A \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. P1 * A * Q1 \\<in> carrier_mat 2 2", "by auto"], ["proof (state)\nthis:\n  P1 * A * Q1 \\<in> carrier_mat 2 2\n\ngoal (6 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. invertible_mat P\n 4. invertible_mat Q\n 5. Smith_normal_form_mat S\n 6. S = P * A * Q", "have rw1: \"(P1 * A * Q1) * Q2 = (P1 * A * (Q1 * Q2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1 * A * Q1 * Q2 = P1 * A * (Q1 * Q2)", "by (meson \"1\" \"2\" A assoc_mult_mat mult_carrier_mat)"], ["proof (state)\nthis:\n  P1 * A * Q1 * Q2 = P1 * A * (Q1 * Q2)\n\ngoal (6 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. invertible_mat P\n 4. invertible_mat Q\n 5. Smith_normal_form_mat S\n 6. S = P * A * Q", "have rw2: \"(P1 * A * Q) = P1 * (A * Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1 * A * Q = P1 * (A * Q)", "by (rule assoc_mult_mat[OF _ A dim_Q], insert 1, auto)"], ["proof (state)\nthis:\n  P1 * A * Q = P1 * (A * Q)\n\ngoal (6 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. invertible_mat P\n 4. invertible_mat Q\n 5. Smith_normal_form_mat S\n 6. S = P * A * Q", "show \"invertible_mat Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat Q", "using 1 2 Q invertible_mult_JNF"], ["proof (prove)\nusing this:\n  D = P1 * A * Q1 \\<and>\n  invertible_mat P1 \\<and>\n  invertible_mat Q1 \\<and>\n  isDiagonal_mat D \\<and>\n  P1 \\<in> carrier_mat 2 2 \\<and>\n  Q1 \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\n  S' = P2 * D * Q2 \\<and>\n  invertible_mat P2 \\<and>\n  invertible_mat Q2 \\<and>\n  Smith_normal_form_mat S' \\<and>\n  P2 \\<in> carrier_mat 2 2 \\<and>\n  S' \\<in> carrier_mat 2 2 \\<and> Q2 \\<in> carrier_mat 2 2\n  Q = Q1 * Q2\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   invertible_mat ?A; invertible_mat ?B\\<rbrakk>\n  \\<Longrightarrow> invertible_mat (?A * ?B)\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "by blast"], ["proof (state)\nthis:\n  invertible_mat Q\n\ngoal (5 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. invertible_mat P\n 4. Smith_normal_form_mat S\n 5. S = P * A * Q", "show \"invertible_mat P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat P", "using 1 2 P invertible_mult_JNF"], ["proof (prove)\nusing this:\n  D = P1 * A * Q1 \\<and>\n  invertible_mat P1 \\<and>\n  invertible_mat Q1 \\<and>\n  isDiagonal_mat D \\<and>\n  P1 \\<in> carrier_mat 2 2 \\<and>\n  Q1 \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\n  S' = P2 * D * Q2 \\<and>\n  invertible_mat P2 \\<and>\n  invertible_mat Q2 \\<and>\n  Smith_normal_form_mat S' \\<and>\n  P2 \\<in> carrier_mat 2 2 \\<and>\n  S' \\<in> carrier_mat 2 2 \\<and> Q2 \\<in> carrier_mat 2 2\n  P = P2 * P1\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   invertible_mat ?A; invertible_mat ?B\\<rbrakk>\n  \\<Longrightarrow> invertible_mat (?A * ?B)\n\ngoal (1 subgoal):\n 1. invertible_mat P", "by blast"], ["proof (state)\nthis:\n  invertible_mat P\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "have \"P2 * D * Q2 = P2 * (P1 * A * Q1) * Q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 * D * Q2 = P2 * (P1 * A * Q1) * Q2", "using 1 2"], ["proof (prove)\nusing this:\n  D = P1 * A * Q1 \\<and>\n  invertible_mat P1 \\<and>\n  invertible_mat Q1 \\<and>\n  isDiagonal_mat D \\<and>\n  P1 \\<in> carrier_mat 2 2 \\<and>\n  Q1 \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\n  S' = P2 * D * Q2 \\<and>\n  invertible_mat P2 \\<and>\n  invertible_mat Q2 \\<and>\n  Smith_normal_form_mat S' \\<and>\n  P2 \\<in> carrier_mat 2 2 \\<and>\n  S' \\<in> carrier_mat 2 2 \\<and> Q2 \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. P2 * D * Q2 = P2 * (P1 * A * Q1) * Q2", "by auto"], ["proof (state)\nthis:\n  P2 * D * Q2 = P2 * (P1 * A * Q1) * Q2\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "also"], ["proof (state)\nthis:\n  P2 * D * Q2 = P2 * (P1 * A * Q1) * Q2\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "have \"... = P2 * ((P1 * A * Q1) * Q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 * (P1 * A * Q1) * Q2 = P2 * (P1 * A * Q1 * Q2)", "using 1 2"], ["proof (prove)\nusing this:\n  D = P1 * A * Q1 \\<and>\n  invertible_mat P1 \\<and>\n  invertible_mat Q1 \\<and>\n  isDiagonal_mat D \\<and>\n  P1 \\<in> carrier_mat 2 2 \\<and>\n  Q1 \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\n  S' = P2 * D * Q2 \\<and>\n  invertible_mat P2 \\<and>\n  invertible_mat Q2 \\<and>\n  Smith_normal_form_mat S' \\<and>\n  P2 \\<in> carrier_mat 2 2 \\<and>\n  S' \\<in> carrier_mat 2 2 \\<and> Q2 \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. P2 * (P1 * A * Q1) * Q2 = P2 * (P1 * A * Q1 * Q2)", "by auto"], ["proof (state)\nthis:\n  P2 * (P1 * A * Q1) * Q2 = P2 * (P1 * A * Q1 * Q2)\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "also"], ["proof (state)\nthis:\n  P2 * (P1 * A * Q1) * Q2 = P2 * (P1 * A * Q1 * Q2)\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "have \"... = P2 * (P1 * A * (Q1 * Q2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 * (P1 * A * Q1 * Q2) = P2 * (P1 * A * (Q1 * Q2))", "unfolding rw1"], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 * (P1 * A * (Q1 * Q2)) = P2 * (P1 * A * (Q1 * Q2))", "by simp"], ["proof (state)\nthis:\n  P2 * (P1 * A * Q1 * Q2) = P2 * (P1 * A * (Q1 * Q2))\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "also"], ["proof (state)\nthis:\n  P2 * (P1 * A * Q1 * Q2) = P2 * (P1 * A * (Q1 * Q2))\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "have \"... = P2 * (P1 * A * Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 * (P1 * A * (Q1 * Q2)) = P2 * (P1 * A * Q)", "using Q"], ["proof (prove)\nusing this:\n  Q = Q1 * Q2\n\ngoal (1 subgoal):\n 1. P2 * (P1 * A * (Q1 * Q2)) = P2 * (P1 * A * Q)", "by auto"], ["proof (state)\nthis:\n  P2 * (P1 * A * (Q1 * Q2)) = P2 * (P1 * A * Q)\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "also"], ["proof (state)\nthis:\n  P2 * (P1 * A * (Q1 * Q2)) = P2 * (P1 * A * Q)\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "have \"... = P2 * (P1 * (A * Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 * (P1 * A * Q) = P2 * (P1 * (A * Q))", "unfolding rw2"], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 * (P1 * (A * Q)) = P2 * (P1 * (A * Q))", "by simp"], ["proof (state)\nthis:\n  P2 * (P1 * A * Q) = P2 * (P1 * (A * Q))\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "also"], ["proof (state)\nthis:\n  P2 * (P1 * A * Q) = P2 * (P1 * (A * Q))\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "have \"... = P2 * P1 * (A * Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 * (P1 * (A * Q)) = P2 * P1 * (A * Q)", "by (rule assoc_mult_mat[symmetric], insert 1 2 A Q, auto)"], ["proof (state)\nthis:\n  P2 * (P1 * (A * Q)) = P2 * P1 * (A * Q)\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "also"], ["proof (state)\nthis:\n  P2 * (P1 * (A * Q)) = P2 * P1 * (A * Q)\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "have \"... = P*(A*Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 * P1 * (A * Q) = P * (A * Q)", "unfolding P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P2 * P1 * (A * Q) = P2 * P1 * (A * Q)", "by simp"], ["proof (state)\nthis:\n  P2 * P1 * (A * Q) = P * (A * Q)\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "also"], ["proof (state)\nthis:\n  P2 * P1 * (A * Q) = P * (A * Q)\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "have \"... = P*A*Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * (A * Q) = P * A * Q", "by (rule assoc_mult_mat[symmetric], insert 1 2 A Q P, auto)"], ["proof (state)\nthis:\n  P * (A * Q) = P * A * Q\n\ngoal (4 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S\n 4. S = P * A * Q", "finally"], ["proof (chain)\npicking this:\n  P2 * D * Q2 = P * A * Q", "show \"S = P * A * Q\""], ["proof (prove)\nusing this:\n  P2 * D * Q2 = P * A * Q\n\ngoal (1 subgoal):\n 1. S = P * A * Q", "using 1 2 S"], ["proof (prove)\nusing this:\n  P2 * D * Q2 = P * A * Q\n  D = P1 * A * Q1 \\<and>\n  invertible_mat P1 \\<and>\n  invertible_mat Q1 \\<and>\n  isDiagonal_mat D \\<and>\n  P1 \\<in> carrier_mat 2 2 \\<and>\n  Q1 \\<in> carrier_mat 2 2 \\<and> D \\<in> carrier_mat 2 2\n  S' = P2 * D * Q2 \\<and>\n  invertible_mat P2 \\<and>\n  invertible_mat Q2 \\<and>\n  Smith_normal_form_mat S' \\<and>\n  P2 \\<in> carrier_mat 2 2 \\<and>\n  S' \\<in> carrier_mat 2 2 \\<and> Q2 \\<in> carrier_mat 2 2\n  S = S'\n\ngoal (1 subgoal):\n 1. S = P * A * Q", "by auto"], ["proof (state)\nthis:\n  S = P * A * Q\n\ngoal (3 subgoals):\n 1. P \\<in> carrier_mat (dim_row A) (dim_row A)\n 2. Q \\<in> carrier_mat (dim_col A) (dim_col A)\n 3. Smith_normal_form_mat S", "qed (insert 1 2 P Q A S, auto)"], ["proof (state)\nthis:\n  is_SNF A (P, S, Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>An executable algorithm to transform $1 \\times 2$ matrices into its Smith normal form\\<close>"], ["", "(*Let's move to prove the case 1x2*)\n\n(*This is not executable since type 1 is not mod_type*)"], ["", "definition \"Smith_1x2_eucl (A::'a::euclidean_ring_gcd^2^1) = (\n  if A $h 0 $h 0 = 0 \\<and> A $h 0 $h 1 \\<noteq> 0 then \n    let Q = interchange_columns (Finite_Cartesian_Product.mat 1) 0 1;\n        A' = interchange_columns A 0 1 in (A',Q)\n  else\n    if A $h 0 $h 0 \\<noteq> 0 \\<and> A $h 0 $h 1 \\<noteq> 0 then\n      let bezout_matrix_right = transpose (bezout_matrix (transpose A) 0 1 0 euclid_ext2)\n      in (A ** bezout_matrix_right, bezout_matrix_right)\n    else (A, Finite_Cartesian_Product.mat 1)\n  )\""], ["", "lemma Smith_1x2_eucl_works:\n  assumes SQ: \"(S,Q) = Smith_1x2_eucl A\"\n  shows \"S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "proof (cases \"A $h 0 $h 0 = 0 \\<and> A $h 0 $h 1 \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "case True"], ["proof (state)\nthis:\n  A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "have Q: \"Q = interchange_columns (Finite_Cartesian_Product.mat 1) 0 1\"\n    and S: \"S = interchange_columns A 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1 &&&\n    S = interchange_columns A 0 1", "using SQ True"], ["proof (prove)\nusing this:\n  (S, Q) = Smith_1x2_eucl A\n  A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Q = interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1 &&&\n    S = interchange_columns A 0 1", "unfolding Smith_1x2_eucl_def"], ["proof (prove)\nusing this:\n  (S, Q) =\n  (if A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n   then let Q = interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0\n                 1;\n            A' = interchange_columns A 0 1\n        in (A', Q)\n   else if A $h 0 $h 0 \\<noteq> (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n        then let bezout_matrix_right =\n                   Finite_Cartesian_Product.transpose\n                    (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                      1 0 euclid_ext2)\n             in (A ** bezout_matrix_right, bezout_matrix_right)\n        else (A, Finite_Cartesian_Product.mat (1::'a)))\n  A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Q = interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1 &&&\n    S = interchange_columns A 0 1", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  Q = interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1\n  S = interchange_columns A 0 1\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "have \"S $h 0 $h 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S $h 0 $h 1 = (0::'a)", "by (simp add: S True interchange_columns_code interchange_columns_code_nth)"], ["proof (state)\nthis:\n  S $h 0 $h 1 = (0::'a)\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "moreover"], ["proof (state)\nthis:\n  S $h 0 $h 1 = (0::'a)\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "have \"invertible Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible Q", "using Q invertible_interchange_columns"], ["proof (prove)\nusing this:\n  Q = interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0 1\n  invertible\n   (interchange_columns (Finite_Cartesian_Product.mat (1::?'a)) ?a ?b)\n\ngoal (1 subgoal):\n 1. invertible Q", "by blast"], ["proof (state)\nthis:\n  invertible Q\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "moreover"], ["proof (state)\nthis:\n  invertible Q\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "have \"S = A ** Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = A ** Q", "by (simp add: Q S interchange_columns_mat_1)"], ["proof (state)\nthis:\n  S = A ** Q\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 = (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  S $h 0 $h 1 = (0::'a)\n  invertible Q\n  S = A ** Q", "show ?thesis"], ["proof (prove)\nusing this:\n  S $h 0 $h 1 = (0::'a)\n  invertible Q\n  S = A ** Q\n\ngoal (1 subgoal):\n 1. S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "by simp"], ["proof (state)\nthis:\n  S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> (A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "note A00_A01 = False"], ["proof (state)\nthis:\n  \\<not> (A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (A $h 0 $h 0 = (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "proof (cases \"A $h 0 $h 0 \\<noteq> 0 \\<and> A $h 0 $h 1 \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "case True"], ["proof (state)\nthis:\n  A $h 0 $h 0 \\<noteq> (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "have ib: \"is_bezout_ext euclid_ext2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bezout_ext euclid_ext2", "by (simp add: is_bezout_ext_euclid_ext2)"], ["proof (state)\nthis:\n  is_bezout_ext euclid_ext2\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "let ?bezout_matrix_right = \"transpose (bezout_matrix (transpose A) 0 1 0 euclid_ext2)\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "have Q: \"Q = ?bezout_matrix_right\" and S: \"S = A**?bezout_matrix_right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q =\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) &&&\n    S =\n    A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2)", "using SQ True A00_A01"], ["proof (prove)\nusing this:\n  (S, Q) = Smith_1x2_eucl A\n  A $h 0 $h 0 \\<noteq> (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n  \\<not> (A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Q =\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) &&&\n    S =\n    A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2)", "unfolding Smith_1x2_eucl_def"], ["proof (prove)\nusing this:\n  (S, Q) =\n  (if A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n   then let Q = interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0\n                 1;\n            A' = interchange_columns A 0 1\n        in (A', Q)\n   else if A $h 0 $h 0 \\<noteq> (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n        then let bezout_matrix_right =\n                   Finite_Cartesian_Product.transpose\n                    (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                      1 0 euclid_ext2)\n             in (A ** bezout_matrix_right, bezout_matrix_right)\n        else (A, Finite_Cartesian_Product.mat (1::'a)))\n  A $h 0 $h 0 \\<noteq> (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n  \\<not> (A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Q =\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) &&&\n    S =\n    A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2)", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  Q =\n  Finite_Cartesian_Product.transpose\n   (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0 euclid_ext2)\n  S =\n  A **\n  Finite_Cartesian_Product.transpose\n   (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0 euclid_ext2)\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "have \"invertible Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible Q", "unfolding Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (Finite_Cartesian_Product.transpose\n       (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n         euclid_ext2))", "by (rule invertible_bezout_matrix_transpose[OF ib zero_less_one_type2], insert True, auto)"], ["proof (state)\nthis:\n  invertible Q\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "moreover"], ["proof (state)\nthis:\n  invertible Q\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "have \"S $h 0 $h 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S $h 0 $h 1 = (0::'a)", "by (smt Finite_Cartesian_Product.transpose_transpose S True bezout_matrix_works2 ib \n          matrix_transpose_mul rel_simps(92) transpose_code transpose_row_code)"], ["proof (state)\nthis:\n  S $h 0 $h 1 = (0::'a)\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "moreover"], ["proof (state)\nthis:\n  S $h 0 $h 1 = (0::'a)\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "have \"S = A**Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = A ** Q", "unfolding S Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2) =\n    A **\n    Finite_Cartesian_Product.transpose\n     (bezout_matrix (Finite_Cartesian_Product.transpose A) 0 1 0\n       euclid_ext2)", "by simp"], ["proof (state)\nthis:\n  S = A ** Q\n\ngoal (2 subgoals):\n 1. A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n    A $h 0 $h 1 \\<noteq> (0::'a) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n 2. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  invertible Q\n  S $h 0 $h 1 = (0::'a)\n  S = A ** Q", "show ?thesis"], ["proof (prove)\nusing this:\n  invertible Q\n  S $h 0 $h 1 = (0::'a)\n  S = A ** Q\n\ngoal (1 subgoal):\n 1. S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "by simp"], ["proof (state)\nthis:\n  S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "have Q: \"Q = (Finite_Cartesian_Product.mat 1)\" and S: \"S = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = Finite_Cartesian_Product.mat (1::'a) &&& S = A", "using SQ False A00_A01"], ["proof (prove)\nusing this:\n  (S, Q) = Smith_1x2_eucl A\n  \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n  \\<not> (A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Q = Finite_Cartesian_Product.mat (1::'a) &&& S = A", "unfolding Smith_1x2_eucl_def"], ["proof (prove)\nusing this:\n  (S, Q) =\n  (if A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n   then let Q = interchange_columns (Finite_Cartesian_Product.mat (1::'a)) 0\n                 1;\n            A' = interchange_columns A 0 1\n        in (A', Q)\n   else if A $h 0 $h 0 \\<noteq> (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a)\n        then let bezout_matrix_right =\n                   Finite_Cartesian_Product.transpose\n                    (bezout_matrix (Finite_Cartesian_Product.transpose A) 0\n                      1 0 euclid_ext2)\n             in (A ** bezout_matrix_right, bezout_matrix_right)\n        else (A, Finite_Cartesian_Product.mat (1::'a)))\n  \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n  \\<not> (A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Q = Finite_Cartesian_Product.mat (1::'a) &&& S = A", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  Q = Finite_Cartesian_Product.mat (1::'a)\n  S = A\n\ngoal (1 subgoal):\n 1. \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and>\n            A $h 0 $h 1 \\<noteq> (0::'a)) \\<Longrightarrow>\n    S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "using False A00_A01 S Q invertible_mat_1"], ["proof (prove)\nusing this:\n  \\<not> (A $h 0 $h 0 \\<noteq> (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n  \\<not> (A $h 0 $h 0 = (0::'a) \\<and> A $h 0 $h 1 \\<noteq> (0::'a))\n  S = A\n  Q = Finite_Cartesian_Product.mat (1::'a)\n  invertible (Finite_Cartesian_Product.mat (1::?'a))\n\ngoal (1 subgoal):\n 1. S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)", "by auto"], ["proof (state)\nthis:\n  S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S = A ** Q \\<and> invertible Q \\<and> S $h 0 $h 1 = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*Bezout_matrix in JNF*)"], ["", "definition bezout_matrix_JNF :: \"'a::comm_ring_1 mat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \n    \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> ('a \\<times> 'a \\<times> 'a \\<times> 'a \\<times> 'a)) \\<Rightarrow> 'a mat\"\n  where \n  \"bezout_matrix_JNF A a b j bezout = Matrix.mat (dim_row A) (dim_row A) (\\<lambda>(x,y). \n      (let \n        (p, q, u, v, d) = bezout (A $$ (a, j)) (A $$ (b, j)) \n       in\n         if x = a \\<and> y = a then p else\n         if x = a \\<and> y = b then q else\n         if x = b \\<and> y = a then u else\n         if x = b \\<and> y = b then v else\n         if x = y then 1 else 0))\""], ["", "definition \"Smith_1x2_eucl_JNF (A::'a::euclidean_ring_gcd mat) = (\n  if A $$ (0, 0) = 0 \\<and> A $$ (0, 1) \\<noteq> 0 then \n    let Q = swaprows_mat 2 0 1;\n        A' = swapcols 0 1 A \n     in (A',Q)\n  else\n    if A $$ (0, 0) \\<noteq> 0 \\<and> A $$ (0, 1) \\<noteq> 0 then\n      let bezout_matrix_right = transpose_mat (bezout_matrix_JNF (transpose_mat A) 0 1 0 euclid_ext2)\n      in (A * bezout_matrix_right, bezout_matrix_right)\n    else (A, 1\\<^sub>m 2)\n  )\""], ["", "lemma Smith_1x2_eucl_JNF_works:\n  assumes A: \"A \\<in> carrier_mat 1 2\"\n  and SQ: \"(S,Q) = Smith_1x2_eucl_JNF A\"\nshows \"is_SNF A (1\\<^sub>m 1, (Smith_1x2_eucl_JNF A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have i: \"0<dim_row A\" and j: \"1<dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < dim_row A &&& 1 < dim_col A", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat 1 2\n\ngoal (1 subgoal):\n 1. 0 < dim_row A &&& 1 < dim_col A", "by auto"], ["proof (state)\nthis:\n  0 < dim_row A\n  1 < dim_col A\n\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have ib: \"is_bezout_ext euclid_ext2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bezout_ext euclid_ext2", "by (simp add: is_bezout_ext_euclid_ext2)"], ["proof (state)\nthis:\n  is_bezout_ext euclid_ext2\n\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "proof (cases \"A $$ (0, 0) = 0 \\<and> A $$ (0, 1) \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "case True"], ["proof (state)\nthis:\n  A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have Q: \"Q = swaprows_mat 2 0 1\"\n      and S: \"S = swapcols 0 1 A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = swaprows_mat 2 0 1 &&& S = swapcols 0 1 A", "using SQ True"], ["proof (prove)\nusing this:\n  (S, Q) = Smith_1x2_eucl_JNF A\n  A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Q = swaprows_mat 2 0 1 &&& S = swapcols 0 1 A", "unfolding Smith_1x2_eucl_JNF_def"], ["proof (prove)\nusing this:\n  (S, Q) =\n  (if A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n   then let Q = swaprows_mat 2 0 1; A' = swapcols 0 1 A in (A', Q)\n   else if A $$ (0, 0) \\<noteq> (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n        then let bezout_matrix_right =\n                   (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n             in (A * bezout_matrix_right, bezout_matrix_right)\n        else (A, 1\\<^sub>m 2))\n  A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Q = swaprows_mat 2 0 1 &&& S = swapcols 0 1 A", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  Q = swaprows_mat 2 0 1\n  S = swapcols 0 1 A\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have S01: \"S $$ (0,1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "unfolding S"], ["proof (prove)\ngoal (1 subgoal):\n 1. swapcols 0 1 A $$ (0, 1) = (0::'a)", "using index_mat_swapcols j i True"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < dim_row ?A; ?j < dim_col ?A\\<rbrakk>\n  \\<Longrightarrow> swapcols ?k ?l ?A $$ (?i, ?j) =\n                    (if ?k = ?j then ?A $$ (?i, ?l)\n                     else if ?l = ?j then ?A $$ (?i, ?k)\n                          else ?A $$ (?i, ?j))\n  dim_row (swapcols ?k ?l ?A) = dim_row ?A\n  dim_col (swapcols ?k ?l ?A) = dim_col ?A\n  1 < dim_col A\n  0 < dim_row A\n  A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. swapcols 0 1 A $$ (0, 1) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  S $$ (0, 1) = (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have dim_S: \"S \\<in> carrier_mat 1 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> carrier_mat 1 2", "using S A"], ["proof (prove)\nusing this:\n  S = swapcols 0 1 A\n  A \\<in> carrier_mat 1 2\n\ngoal (1 subgoal):\n 1. S \\<in> carrier_mat 1 2", "by auto"], ["proof (state)\nthis:\n  S \\<in> carrier_mat 1 2\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "moreover"], ["proof (state)\nthis:\n  S \\<in> carrier_mat 1 2\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have dim_Q: \"Q \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<in> carrier_mat 2 2", "using S Q"], ["proof (prove)\nusing this:\n  S = swapcols 0 1 A\n  Q = swaprows_mat 2 0 1\n\ngoal (1 subgoal):\n 1. Q \\<in> carrier_mat 2 2", "by auto"], ["proof (state)\nthis:\n  Q \\<in> carrier_mat 2 2\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "moreover"], ["proof (state)\nthis:\n  Q \\<in> carrier_mat 2 2\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have \"invertible_mat Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat Q", "(*TODO: better a lemma for invertible swaprows_mat, etc*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat Q", "have \"Determinant.det (swaprows_mat 2 0 1) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det (swaprows_mat 2 0 1) = - (1::'b)", "by (rule det_swaprows_mat, auto)"], ["proof (state)\nthis:\n  Determinant.det (swaprows_mat 2 0 1) = - (1::?'b2)\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "also"], ["proof (state)\nthis:\n  Determinant.det (swaprows_mat 2 0 1) = - (1::?'b2)\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "have \"... dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (1::'b) dvd (1::'b)", "by simp"], ["proof (state)\nthis:\n  - (1::?'b3) dvd (1::?'b3)\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "finally"], ["proof (chain)\npicking this:\n  Determinant.det (swaprows_mat 2 0 1) dvd (1::?'b4)", "show ?thesis"], ["proof (prove)\nusing this:\n  Determinant.det (swaprows_mat 2 0 1) dvd (1::?'b4)\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "using Q dim_Q invertible_iff_is_unit_JNF"], ["proof (prove)\nusing this:\n  Determinant.det (swaprows_mat 2 0 1) dvd (1::?'b4)\n  Q = swaprows_mat 2 0 1\n  Q \\<in> carrier_mat 2 2\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat ?A = (Determinant.det ?A dvd (1::?'a))\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "by blast"], ["proof (state)\nthis:\n  invertible_mat Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invertible_mat Q\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "moreover"], ["proof (state)\nthis:\n  invertible_mat Q\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have \"S = A * Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = A * Q", "unfolding S Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. swapcols 0 1 A = A * swaprows_mat 2 0 1", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat 1 2\n\ngoal (1 subgoal):\n 1. swapcols 0 1 A = A * swaprows_mat 2 0 1", "by (simp add: swapcols_mat)"], ["proof (state)\nthis:\n  S = A * Q\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "moreover"], ["proof (state)\nthis:\n  S = A * Q\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have \"Smith_normal_form_mat S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Smith_normal_form_mat S", "unfolding Smith_normal_form_mat_def isDiagonal_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a.\n        a + 1 < min (dim_row S) (dim_col S) \\<longrightarrow>\n        S $$ (a, a) dvd S $$ (a + 1, a + 1)) \\<and>\n    (\\<forall>i j.\n        i \\<noteq> j \\<and>\n        i < dim_row S \\<and> j < dim_col S \\<longrightarrow>\n        S $$ (i, j) = (0::'a))", "using S01 dim_S less_2_cases"], ["proof (prove)\nusing this:\n  S $$ (0, 1) = (0::'a)\n  S \\<in> carrier_mat 1 2\n  ?n < 2 \\<Longrightarrow> ?n = 0 \\<or> ?n = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<forall>a.\n        a + 1 < min (dim_row S) (dim_col S) \\<longrightarrow>\n        S $$ (a, a) dvd S $$ (a + 1, a + 1)) \\<and>\n    (\\<forall>i j.\n        i \\<noteq> j \\<and>\n        i < dim_row S \\<and> j < dim_col S \\<longrightarrow>\n        S $$ (i, j) = (0::'a))", "by fastforce"], ["proof (state)\nthis:\n  Smith_normal_form_mat S\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) = (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "ultimately"], ["proof (chain)\npicking this:\n  S \\<in> carrier_mat 1 2\n  Q \\<in> carrier_mat 2 2\n  invertible_mat Q\n  S = A * Q\n  Smith_normal_form_mat S", "show ?thesis"], ["proof (prove)\nusing this:\n  S \\<in> carrier_mat 1 2\n  Q \\<in> carrier_mat 2 2\n  invertible_mat Q\n  S = A * Q\n  Smith_normal_form_mat S\n\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "using SQ S Q A"], ["proof (prove)\nusing this:\n  S \\<in> carrier_mat 1 2\n  Q \\<in> carrier_mat 2 2\n  invertible_mat Q\n  S = A * Q\n  Smith_normal_form_mat S\n  (S, Q) = Smith_1x2_eucl_JNF A\n  S = swapcols 0 1 A\n  Q = swaprows_mat 2 0 1\n  A \\<in> carrier_mat 1 2\n\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "unfolding is_SNF_def"], ["proof (prove)\nusing this:\n  S \\<in> carrier_mat 1 2\n  Q \\<in> carrier_mat 2 2\n  invertible_mat Q\n  S = A * Q\n  Smith_normal_form_mat S\n  (S, Q) = Smith_1x2_eucl_JNF A\n  S = swapcols 0 1 A\n  Q = swaprows_mat 2 0 1\n  A \\<in> carrier_mat 1 2\n\ngoal (1 subgoal):\n 1. case (1\\<^sub>m 1, Smith_1x2_eucl_JNF A) of\n    (P, S, Q) \\<Rightarrow>\n      P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n      Q \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n      invertible_mat P \\<and>\n      invertible_mat Q \\<and> Smith_normal_form_mat S \\<and> S = P * A * Q", "by auto"], ["proof (state)\nthis:\n  is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n\ngoal (1 subgoal):\n 1. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "case False"], ["proof (state)\nthis:\n  \\<not> (A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "note A00_A01 = False"], ["proof (state)\nthis:\n  \\<not> (A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (A $$ (0, 0) = (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "proof (cases \"A $$ (0,0) \\<noteq> 0 \\<and> A $$ (0,1) \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "case True"], ["proof (state)\nthis:\n  A $$ (0, 0) \\<noteq> (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have ib: \"is_bezout_ext euclid_ext2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bezout_ext euclid_ext2", "by (simp add: is_bezout_ext_euclid_ext2)"], ["proof (state)\nthis:\n  is_bezout_ext euclid_ext2\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "let ?BM = \"(bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have Q: \"Q = ?BM\" and S: \"S = A*?BM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T &&&\n    S = A * (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T", "using SQ True A00_A01"], ["proof (prove)\nusing this:\n  (S, Q) = Smith_1x2_eucl_JNF A\n  A $$ (0, 0) \\<noteq> (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n  \\<not> (A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Q = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T &&&\n    S = A * (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T", "unfolding Smith_1x2_eucl_JNF_def"], ["proof (prove)\nusing this:\n  (S, Q) =\n  (if A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n   then let Q = swaprows_mat 2 0 1; A' = swapcols 0 1 A in (A', Q)\n   else if A $$ (0, 0) \\<noteq> (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n        then let bezout_matrix_right =\n                   (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n             in (A * bezout_matrix_right, bezout_matrix_right)\n        else (A, 1\\<^sub>m 2))\n  A $$ (0, 0) \\<noteq> (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n  \\<not> (A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Q = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T &&&\n    S = A * (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  Q = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n  S = A * (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "let ?a = \"A $$ (0, 0)\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "let ?b = \"A $$ (0, Suc 0)\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "obtain p q u v d where pquvd: \"(p,q,u,v,d) = euclid_ext2 ?a ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q u v d.\n        (p, q, u, v, d) =\n        euclid_ext2 (A $$ (0, 0)) (A $$ (0, Suc 0)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases5)"], ["proof (state)\nthis:\n  (p, q, u, v, d) = euclid_ext2 (A $$ (0, 0)) (A $$ (0, Suc 0))\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have d: \"p*?a + q*?b = d\" and u: \"u = - ?b div d\" and v: \"v = ?a div d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * A $$ (0, 0) + q * A $$ (0, Suc 0) = d &&&\n    u = - A $$ (0, Suc 0) div d &&& v = A $$ (0, 0) div d", "using pquvd"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = euclid_ext2 (A $$ (0, 0)) (A $$ (0, Suc 0))\n\ngoal (1 subgoal):\n 1. p * A $$ (0, 0) + q * A $$ (0, Suc 0) = d &&&\n    u = - A $$ (0, Suc 0) div d &&& v = A $$ (0, 0) div d", "unfolding euclid_ext2_def"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) =\n  (fst (bezout_coefficients (A $$ (0, 0)) (A $$ (0, Suc 0))),\n   snd (bezout_coefficients (A $$ (0, 0)) (A $$ (0, Suc 0))),\n   - A $$ (0, Suc 0) div gcd (A $$ (0, 0)) (A $$ (0, Suc 0)),\n   A $$ (0, 0) div gcd (A $$ (0, 0)) (A $$ (0, Suc 0)),\n   gcd (A $$ (0, 0)) (A $$ (0, Suc 0)))\n\ngoal (1 subgoal):\n 1. p * A $$ (0, 0) + q * A $$ (0, Suc 0) = d &&&\n    u = - A $$ (0, Suc 0) div d &&& v = A $$ (0, 0) div d", "using bezout_coefficients_fst_snd"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) =\n  (fst (bezout_coefficients (A $$ (0, 0)) (A $$ (0, Suc 0))),\n   snd (bezout_coefficients (A $$ (0, 0)) (A $$ (0, Suc 0))),\n   - A $$ (0, Suc 0) div gcd (A $$ (0, 0)) (A $$ (0, Suc 0)),\n   A $$ (0, 0) div gcd (A $$ (0, 0)) (A $$ (0, Suc 0)),\n   gcd (A $$ (0, 0)) (A $$ (0, Suc 0)))\n  fst (bezout_coefficients ?a ?b) * ?a +\n  snd (bezout_coefficients ?a ?b) * ?b =\n  gcd ?a ?b\n\ngoal (1 subgoal):\n 1. p * A $$ (0, 0) + q * A $$ (0, Suc 0) = d &&&\n    u = - A $$ (0, Suc 0) div d &&& v = A $$ (0, 0) div d", "by blast+"], ["proof (state)\nthis:\n  p * A $$ (0, 0) + q * A $$ (0, Suc 0) = d\n  u = - A $$ (0, Suc 0) div d\n  v = A $$ (0, 0) div d\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have da: \"d dvd ?a\" and db: \"d dvd ?b\" and gcd_ab: \"d = gcd ?a ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd A $$ (0, 0) &&&\n    d dvd A $$ (0, Suc 0) &&& d = gcd (A $$ (0, 0)) (A $$ (0, Suc 0))", "by (metis euclid_ext2_def gcd_dvd1 gcd_dvd2 pquvd prod.sel(2))+"], ["proof (state)\nthis:\n  d dvd A $$ (0, 0)\n  d dvd A $$ (0, Suc 0)\n  d = gcd (A $$ (0, 0)) (A $$ (0, Suc 0))\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have dim_S: \"S \\<in> carrier_mat 1 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> carrier_mat 1 2", "using S A"], ["proof (prove)\nusing this:\n  S = A * (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n  A \\<in> carrier_mat 1 2\n\ngoal (1 subgoal):\n 1. S \\<in> carrier_mat 1 2", "by (simp add: bezout_matrix_JNF_def)"], ["proof (state)\nthis:\n  S \\<in> carrier_mat 1 2\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "moreover"], ["proof (state)\nthis:\n  S \\<in> carrier_mat 1 2\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have dim_Q: \"Q \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<in> carrier_mat 2 2", "using A Q"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat 1 2\n  Q = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n\ngoal (1 subgoal):\n 1. Q \\<in> carrier_mat 2 2", "by (simp add: bezout_matrix_JNF_def)"], ["proof (state)\nthis:\n  Q \\<in> carrier_mat 2 2\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have \"invertible_mat Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat Q", "have \"Determinant.det ?BM = ?BM $$ (0, 0) * ?BM $$ (1, 1) - ?BM $$ (0, 1) * ?BM $$ (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det\n     (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T =\n    (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 0) *\n    (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) -\n    (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) *\n    (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 0)", "by (rule det_2, insert A, auto simp add: bezout_matrix_JNF_def)"], ["proof (state)\nthis:\n  Determinant.det (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T =\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 0) *\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) -\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) *\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 0)\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "also"], ["proof (state)\nthis:\n  Determinant.det (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T =\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 0) *\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) -\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) *\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 0)\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "have \"... = p * v - u*q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 0) *\n    (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) -\n    (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) *\n    (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 0) =\n    p * v - u * q", "by (insert i j pquvd, auto simp add: bezout_matrix_JNF_def, metis split_conv)"], ["proof (state)\nthis:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 0) *\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) -\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) *\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 0) =\n  p * v - u * q\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "also"], ["proof (state)\nthis:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 0) *\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) -\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) *\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 0) =\n  p * v - u * q\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "have \"... = (p * ?a) div d - (q * (-?b)) div d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * v - u * q = p * A $$ (0, 0) div d - q * - A $$ (0, Suc 0) div d", "unfolding v u"], ["proof (prove)\ngoal (1 subgoal):\n 1. p * (A $$ (0, 0) div d) - - A $$ (0, Suc 0) div d * q =\n    p * A $$ (0, 0) div d - q * - A $$ (0, Suc 0) div d", "by (simp add: da db div_mult_swap mult.commute)"], ["proof (state)\nthis:\n  p * v - u * q = p * A $$ (0, 0) div d - q * - A $$ (0, Suc 0) div d\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "also"], ["proof (state)\nthis:\n  p * v - u * q = p * A $$ (0, 0) div d - q * - A $$ (0, Suc 0) div d\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "have \"... = (p * ?a + q * ?b) div d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * A $$ (0, 0) div d - q * - A $$ (0, Suc 0) div d =\n    (p * A $$ (0, 0) + q * A $$ (0, Suc 0)) div d", "by (metis (no_types, lifting) da db diff_minus_eq_add div_diff dvd_minus_iff dvd_trans \n              dvd_triv_right more_arith_simps(8))"], ["proof (state)\nthis:\n  p * A $$ (0, 0) div d - q * - A $$ (0, Suc 0) div d =\n  (p * A $$ (0, 0) + q * A $$ (0, Suc 0)) div d\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "also"], ["proof (state)\nthis:\n  p * A $$ (0, 0) div d - q * - A $$ (0, Suc 0) div d =\n  (p * A $$ (0, 0) + q * A $$ (0, Suc 0)) div d\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "have \"... = 1 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p * A $$ (0, 0) + q * A $$ (0, Suc 0)) div d = (1::'a)", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. d div d = (1::'a)", "using True da"], ["proof (prove)\nusing this:\n  A $$ (0, 0) \\<noteq> (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n  d dvd A $$ (0, 0)\n\ngoal (1 subgoal):\n 1. d div d = (1::'a)", "by fastforce"], ["proof (state)\nthis:\n  (p * A $$ (0, 0) + q * A $$ (0, Suc 0)) div d = (1::'a)\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "finally"], ["proof (chain)\npicking this:\n  Determinant.det (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T =\n  (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  Determinant.det (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. invertible_mat Q", "unfolding Q"], ["proof (prove)\nusing this:\n  Determinant.det (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. invertible_mat (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T", "by (metis (full_types) Determinant.det_def Q carrier_matI invertible_iff_is_unit_JNF \n              not_is_unit_0 one_dvd)"], ["proof (state)\nthis:\n  invertible_mat Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invertible_mat Q\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "moreover"], ["proof (state)\nthis:\n  invertible_mat Q\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have S_AQ: \"S = A*Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = A * Q", "unfolding S Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T =\n    A * (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  S = A * Q\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "moreover"], ["proof (state)\nthis:\n  S = A * Q\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have S01: \"S $$ (0,1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "have Q01: \"Q $$ (0, 1) = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q $$ (0, 1) = u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q $$ (0, 1) = u", "have \"?BM $$ (0,1) = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2) $$ (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) =\n    bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 0)", "using Q dim_Q"], ["proof (prove)\nusing this:\n  Q = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n  Q \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) =\n    bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 0)", "by auto"], ["proof (state)\nthis:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) =\n  bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 0)\n\ngoal (1 subgoal):\n 1. Q $$ (0, 1) = u", "also"], ["proof (state)\nthis:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) =\n  bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 0)\n\ngoal (1 subgoal):\n 1. Q $$ (0, 1) = u", "have \"... =  (\\<lambda>(x::nat, y::nat).\n          let (p, q, u, v, d) = euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0)) in if x = 0 \\<and> y = 0 then p\n            else if x = 0 \\<and> y = 1 then q else if x = 1 \\<and> y = 0 then u else if x = 1 \\<and> y = 1 then v\n            else if x = y then 1 else 0) (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 0) =\n    (case (1, 0) of\n     (x, y) \\<Rightarrow>\n       let (p, q, u, v, d) =\n             euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n       in if x = 0 \\<and> y = 0 then p\n          else if x = 0 \\<and> y = 1 then q\n               else if x = 1 \\<and> y = 0 then u\n                    else if x = 1 \\<and> y = 1 then v\n                         else if x = y then 1::'a else (0::'a))", "unfolding bezout_matrix_JNF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat (dim_row A\\<^sup>T) (dim_row A\\<^sup>T)\n     (\\<lambda>(x, y).\n         let (p, q, u, v, d) =\n               euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n         in if x = 0 \\<and> y = 0 then p\n            else if x = 0 \\<and> y = 1 then q\n                 else if x = 1 \\<and> y = 0 then u\n                      else if x = 1 \\<and> y = 1 then v\n                           else if x = y then 1::'a else (0::'a)) $$\n    (1, 0) =\n    (case (1, 0) of\n     (x, y) \\<Rightarrow>\n       let (p, q, u, v, d) =\n             euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n       in if x = 0 \\<and> y = 0 then p\n          else if x = 0 \\<and> y = 1 then q\n               else if x = 1 \\<and> y = 0 then u\n                    else if x = 1 \\<and> y = 1 then v\n                         else if x = y then 1::'a else (0::'a))", "by (rule index_mat(1), insert A, auto)"], ["proof (state)\nthis:\n  bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 0) =\n  (case (1, 0) of\n   (x, y) \\<Rightarrow>\n     let (p, q, u, v, d) =\n           euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n     in if x = 0 \\<and> y = 0 then p\n        else if x = 0 \\<and> y = 1 then q\n             else if x = 1 \\<and> y = 0 then u\n                  else if x = 1 \\<and> y = 1 then v\n                       else if x = y then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. Q $$ (0, 1) = u", "also"], ["proof (state)\nthis:\n  bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 0) =\n  (case (1, 0) of\n   (x, y) \\<Rightarrow>\n     let (p, q, u, v, d) =\n           euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n     in if x = 0 \\<and> y = 0 then p\n        else if x = 0 \\<and> y = 1 then q\n             else if x = 1 \\<and> y = 0 then u\n                  else if x = 1 \\<and> y = 1 then v\n                       else if x = y then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. Q $$ (0, 1) = u", "have \"... = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (1, 0) of\n     (x, y) \\<Rightarrow>\n       let (p, q, u, v, d) =\n             euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n       in if x = 0 \\<and> y = 0 then p\n          else if x = 0 \\<and> y = 1 then q\n               else if x = 1 \\<and> y = 0 then u\n                    else if x = 1 \\<and> y = 1 then v\n                         else if x = y then 1::'a else (0::'a)) =\n    u", "using pquvd"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = euclid_ext2 (A $$ (0, 0)) (A $$ (0, Suc 0))\n\ngoal (1 subgoal):\n 1. (case (1, 0) of\n     (x, y) \\<Rightarrow>\n       let (p, q, u, v, d) =\n             euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n       in if x = 0 \\<and> y = 0 then p\n          else if x = 0 \\<and> y = 1 then q\n               else if x = 1 \\<and> y = 0 then u\n                    else if x = 1 \\<and> y = 1 then v\n                         else if x = y then 1::'a else (0::'a)) =\n    u", "unfolding split_beta Let_def"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = euclid_ext2 (A $$ (0, 0)) (A $$ (0, Suc 0))\n\ngoal (1 subgoal):\n 1. (if fst (1, 0) = 0 \\<and> snd (1, 0) = 0\n     then fst (euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0)))\n     else if fst (1, 0) = 0 \\<and> snd (1, 0) = 1\n          then fst (snd (euclid_ext2 (A\\<^sup>T $$ (0, 0))\n                          (A\\<^sup>T $$ (1, 0))))\n          else if fst (1, 0) = 1 \\<and> snd (1, 0) = 0\n               then fst (snd (snd (euclid_ext2 (A\\<^sup>T $$ (0, 0))\n                                    (A\\<^sup>T $$ (1, 0)))))\n               else if fst (1, 0) = 1 \\<and> snd (1, 0) = 1\n                    then fst (snd (snd (snd\n   (euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))))))\n                    else if fst (1, 0) = snd (1, 0) then 1::'a\n                         else (0::'a)) =\n    u", "by (auto, metis A One_nat_def carrier_matD(2) fst_conv i index_transpose_mat(1) \n                j rel_simps(51) snd_conv)"], ["proof (state)\nthis:\n  (case (1, 0) of\n   (x, y) \\<Rightarrow>\n     let (p, q, u, v, d) =\n           euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n     in if x = 0 \\<and> y = 0 then p\n        else if x = 0 \\<and> y = 1 then q\n             else if x = 1 \\<and> y = 0 then u\n                  else if x = 1 \\<and> y = 1 then v\n                       else if x = y then 1::'a else (0::'a)) =\n  u\n\ngoal (1 subgoal):\n 1. Q $$ (0, 1) = u", "finally"], ["proof (chain)\npicking this:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) = u", "show ?thesis"], ["proof (prove)\nusing this:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) = u\n\ngoal (1 subgoal):\n 1. Q $$ (0, 1) = u", "unfolding Q"], ["proof (prove)\nusing this:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) = u\n\ngoal (1 subgoal):\n 1. (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (0, 1) = u", "by auto"], ["proof (state)\nthis:\n  Q $$ (0, 1) = u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Q $$ (0, 1) = u\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "have Q11: \"Q $$ (1, 1) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q $$ (1, 1) = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q $$ (1, 1) = v", "have \"?BM $$ (1,1) = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2) $$ (1, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) =\n    bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 1)", "using Q dim_Q"], ["proof (prove)\nusing this:\n  Q = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n  Q \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) =\n    bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 1)", "by auto"], ["proof (state)\nthis:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) =\n  bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 1)\n\ngoal (1 subgoal):\n 1. Q $$ (1, 1) = v", "also"], ["proof (state)\nthis:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) =\n  bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 1)\n\ngoal (1 subgoal):\n 1. Q $$ (1, 1) = v", "have \"... =  (\\<lambda>(x::nat, y::nat).\n          let (p, q, u, v, d) = euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0)) in if x = 0 \\<and> y = 0 then p\n            else if x = 0 \\<and> y = 1 then q else if x = 1 \\<and> y = 0 then u else if x = 1 \\<and> y = 1 then v\n            else if x = y then 1 else 0) (1, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 1) =\n    (case (1, 1) of\n     (x, y) \\<Rightarrow>\n       let (p, q, u, v, d) =\n             euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n       in if x = 0 \\<and> y = 0 then p\n          else if x = 0 \\<and> y = 1 then q\n               else if x = 1 \\<and> y = 0 then u\n                    else if x = 1 \\<and> y = 1 then v\n                         else if x = y then 1::'a else (0::'a))", "unfolding bezout_matrix_JNF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat (dim_row A\\<^sup>T) (dim_row A\\<^sup>T)\n     (\\<lambda>(x, y).\n         let (p, q, u, v, d) =\n               euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n         in if x = 0 \\<and> y = 0 then p\n            else if x = 0 \\<and> y = 1 then q\n                 else if x = 1 \\<and> y = 0 then u\n                      else if x = 1 \\<and> y = 1 then v\n                           else if x = y then 1::'a else (0::'a)) $$\n    (1, 1) =\n    (case (1, 1) of\n     (x, y) \\<Rightarrow>\n       let (p, q, u, v, d) =\n             euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n       in if x = 0 \\<and> y = 0 then p\n          else if x = 0 \\<and> y = 1 then q\n               else if x = 1 \\<and> y = 0 then u\n                    else if x = 1 \\<and> y = 1 then v\n                         else if x = y then 1::'a else (0::'a))", "by (rule index_mat(1), insert A, auto)"], ["proof (state)\nthis:\n  bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 1) =\n  (case (1, 1) of\n   (x, y) \\<Rightarrow>\n     let (p, q, u, v, d) =\n           euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n     in if x = 0 \\<and> y = 0 then p\n        else if x = 0 \\<and> y = 1 then q\n             else if x = 1 \\<and> y = 0 then u\n                  else if x = 1 \\<and> y = 1 then v\n                       else if x = y then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. Q $$ (1, 1) = v", "also"], ["proof (state)\nthis:\n  bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2 $$ (1, 1) =\n  (case (1, 1) of\n   (x, y) \\<Rightarrow>\n     let (p, q, u, v, d) =\n           euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n     in if x = 0 \\<and> y = 0 then p\n        else if x = 0 \\<and> y = 1 then q\n             else if x = 1 \\<and> y = 0 then u\n                  else if x = 1 \\<and> y = 1 then v\n                       else if x = y then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. Q $$ (1, 1) = v", "have \"... = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (1, 1) of\n     (x, y) \\<Rightarrow>\n       let (p, q, u, v, d) =\n             euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n       in if x = 0 \\<and> y = 0 then p\n          else if x = 0 \\<and> y = 1 then q\n               else if x = 1 \\<and> y = 0 then u\n                    else if x = 1 \\<and> y = 1 then v\n                         else if x = y then 1::'a else (0::'a)) =\n    v", "using pquvd"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = euclid_ext2 (A $$ (0, 0)) (A $$ (0, Suc 0))\n\ngoal (1 subgoal):\n 1. (case (1, 1) of\n     (x, y) \\<Rightarrow>\n       let (p, q, u, v, d) =\n             euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n       in if x = 0 \\<and> y = 0 then p\n          else if x = 0 \\<and> y = 1 then q\n               else if x = 1 \\<and> y = 0 then u\n                    else if x = 1 \\<and> y = 1 then v\n                         else if x = y then 1::'a else (0::'a)) =\n    v", "unfolding split_beta Let_def"], ["proof (prove)\nusing this:\n  (p, q, u, v, d) = euclid_ext2 (A $$ (0, 0)) (A $$ (0, Suc 0))\n\ngoal (1 subgoal):\n 1. (if fst (1, 1) = 0 \\<and> snd (1, 1) = 0\n     then fst (euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0)))\n     else if fst (1, 1) = 0 \\<and> snd (1, 1) = 1\n          then fst (snd (euclid_ext2 (A\\<^sup>T $$ (0, 0))\n                          (A\\<^sup>T $$ (1, 0))))\n          else if fst (1, 1) = 1 \\<and> snd (1, 1) = 0\n               then fst (snd (snd (euclid_ext2 (A\\<^sup>T $$ (0, 0))\n                                    (A\\<^sup>T $$ (1, 0)))))\n               else if fst (1, 1) = 1 \\<and> snd (1, 1) = 1\n                    then fst (snd (snd (snd\n   (euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))))))\n                    else if fst (1, 1) = snd (1, 1) then 1::'a\n                         else (0::'a)) =\n    v", "by (auto, metis A One_nat_def carrier_matD(2) fst_conv i index_transpose_mat(1) \n                j rel_simps(51) snd_conv)"], ["proof (state)\nthis:\n  (case (1, 1) of\n   (x, y) \\<Rightarrow>\n     let (p, q, u, v, d) =\n           euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n     in if x = 0 \\<and> y = 0 then p\n        else if x = 0 \\<and> y = 1 then q\n             else if x = 1 \\<and> y = 0 then u\n                  else if x = 1 \\<and> y = 1 then v\n                       else if x = y then 1::'a else (0::'a)) =\n  v\n\ngoal (1 subgoal):\n 1. Q $$ (1, 1) = v", "finally"], ["proof (chain)\npicking this:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) = v", "show ?thesis"], ["proof (prove)\nusing this:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) = v\n\ngoal (1 subgoal):\n 1. Q $$ (1, 1) = v", "unfolding Q"], ["proof (prove)\nusing this:\n  (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) = v\n\ngoal (1 subgoal):\n 1. (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T $$ (1, 1) = v", "by auto"], ["proof (state)\nthis:\n  Q $$ (1, 1) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Q $$ (1, 1) = v\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "have \"S $$ (0,1) = Matrix.row A 0 \\<bullet> col Q 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S $$ (0, 1) = Matrix.row A 0 \\<bullet> col Q 1", "using index_mult_mat Q S dim_S i"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < dim_row ?A; ?j < dim_col ?B\\<rbrakk>\n  \\<Longrightarrow> (?A * ?B) $$ (?i, ?j) =\n                    Matrix.row ?A ?i \\<bullet> col ?B ?j\n  dim_row (?A * ?B) = dim_row ?A\n  dim_col (?A * ?B) = dim_col ?B\n  Q = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n  S = A * (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n  S \\<in> carrier_mat 1 2\n  0 < dim_row A\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = Matrix.row A 0 \\<bullet> col Q 1", "by auto"], ["proof (state)\nthis:\n  S $$ (0, 1) = Matrix.row A 0 \\<bullet> col Q 1\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "also"], ["proof (state)\nthis:\n  S $$ (0, 1) = Matrix.row A 0 \\<bullet> col Q 1\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "have \"... = (\\<Sum>i = 0..<2. Matrix.row A 0 $v i * Q $$ (i, 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.row A 0 \\<bullet> col Q 1 =\n    (\\<Sum>i = 0..<2. Matrix.row A 0 $v i * Q $$ (i, 1))", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec (col Q 1). Matrix.row A 0 $v i * col Q 1 $v i) =\n    (\\<Sum>i = 0..<2. Matrix.row A 0 $v i * Q $$ (i, 1))", "using dim_S dim_Q"], ["proof (prove)\nusing this:\n  S \\<in> carrier_mat 1 2\n  Q \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec (col Q 1). Matrix.row A 0 $v i * col Q 1 $v i) =\n    (\\<Sum>i = 0..<2. Matrix.row A 0 $v i * Q $$ (i, 1))", "by auto"], ["proof (state)\nthis:\n  Matrix.row A 0 \\<bullet> col Q 1 =\n  (\\<Sum>i = 0..<2. Matrix.row A 0 $v i * Q $$ (i, 1))\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "also"], ["proof (state)\nthis:\n  Matrix.row A 0 \\<bullet> col Q 1 =\n  (\\<Sum>i = 0..<2. Matrix.row A 0 $v i * Q $$ (i, 1))\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "have \"... = (\\<Sum>i \\<in> {0,1}. Matrix.row A 0 $v i * Q $$ (i, 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<2. Matrix.row A 0 $v i * Q $$ (i, 1)) =\n    (\\<Sum>i\\<in>{0, 1}. Matrix.row A 0 $v i * Q $$ (i, 1))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<2. Matrix.row A 0 $v i * Q $$ (i, 1)) =\n  (\\<Sum>i\\<in>{0, 1}. Matrix.row A 0 $v i * Q $$ (i, 1))\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<2. Matrix.row A 0 $v i * Q $$ (i, 1)) =\n  (\\<Sum>i\\<in>{0, 1}. Matrix.row A 0 $v i * Q $$ (i, 1))\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "have \"... = Matrix.row A 0 $v 0 * Q $$ (0, 1) + Matrix.row A 0 $v 1 * Q $$ (1, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{0, 1}. Matrix.row A 0 $v i * Q $$ (i, 1)) =\n    Matrix.row A 0 $v 0 * Q $$ (0, 1) + Matrix.row A 0 $v 1 * Q $$ (1, 1)", "using sum_two_elements"], ["proof (prove)\nusing this:\n  ?a \\<noteq> ?b \\<Longrightarrow> sum ?f {?a, ?b} = ?f ?a + ?f ?b\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{0, 1}. Matrix.row A 0 $v i * Q $$ (i, 1)) =\n    Matrix.row A 0 $v 0 * Q $$ (0, 1) + Matrix.row A 0 $v 1 * Q $$ (1, 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{0, 1}. Matrix.row A 0 $v i * Q $$ (i, 1)) =\n  Matrix.row A 0 $v 0 * Q $$ (0, 1) + Matrix.row A 0 $v 1 * Q $$ (1, 1)\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{0, 1}. Matrix.row A 0 $v i * Q $$ (i, 1)) =\n  Matrix.row A 0 $v 0 * Q $$ (0, 1) + Matrix.row A 0 $v 1 * Q $$ (1, 1)\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "have \"... =  ?a*u + ?b * v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.row A 0 $v 0 * Q $$ (0, 1) + Matrix.row A 0 $v 1 * Q $$ (1, 1) =\n    A $$ (0, 0) * u + A $$ (0, Suc 0) * v", "unfolding Q01 Q11"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.row A 0 $v 0 * u + Matrix.row A 0 $v 1 * v =\n    A $$ (0, 0) * u + A $$ (0, Suc 0) * v", "using i index_row(1) j A"], ["proof (prove)\nusing this:\n  0 < dim_row A\n  \\<lbrakk>?i < dim_row ?A; ?j < dim_col ?A\\<rbrakk>\n  \\<Longrightarrow> Matrix.row ?A ?i $v ?j = ?A $$ (?i, ?j)\n  1 < dim_col A\n  A \\<in> carrier_mat 1 2\n\ngoal (1 subgoal):\n 1. Matrix.row A 0 $v 0 * u + Matrix.row A 0 $v 1 * v =\n    A $$ (0, 0) * u + A $$ (0, Suc 0) * v", "by auto"], ["proof (state)\nthis:\n  Matrix.row A 0 $v 0 * Q $$ (0, 1) + Matrix.row A 0 $v 1 * Q $$ (1, 1) =\n  A $$ (0, 0) * u + A $$ (0, Suc 0) * v\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "also"], ["proof (state)\nthis:\n  Matrix.row A 0 $v 0 * Q $$ (0, 1) + Matrix.row A 0 $v 1 * Q $$ (1, 1) =\n  A $$ (0, 0) * u + A $$ (0, Suc 0) * v\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (0, 0) * u + A $$ (0, Suc 0) * v = (0::'a)", "unfolding u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (0, 0) * (- A $$ (0, Suc 0) div d) +\n    A $$ (0, Suc 0) * (A $$ (0, 0) div d) =\n    (0::'a)", "by (smt Groups.mult_ac(2) Groups.mult_ac(3) add.right_inverse add_uminus_conv_diff da db \n              diff_minus_eq_add dvd_div_mult_self dvd_neg_div minus_mult_left)"], ["proof (state)\nthis:\n  A $$ (0, 0) * u + A $$ (0, Suc 0) * v = (0::'a)\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  S $$ (0, 1) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  S $$ (0, 1) = (0::'a)\n\ngoal (1 subgoal):\n 1. S $$ (0, 1) = (0::'a)", "."], ["proof (state)\nthis:\n  S $$ (0, 1) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S $$ (0, 1) = (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "moreover"], ["proof (state)\nthis:\n  S $$ (0, 1) = (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have \"Smith_normal_form_mat S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Smith_normal_form_mat S", "using less_2_cases S01 dim_S"], ["proof (prove)\nusing this:\n  ?n < 2 \\<Longrightarrow> ?n = 0 \\<or> ?n = Suc 0\n  S $$ (0, 1) = (0::'a)\n  S \\<in> carrier_mat 1 2\n\ngoal (1 subgoal):\n 1. Smith_normal_form_mat S", "unfolding Smith_normal_form_mat_def isDiagonal_mat_def"], ["proof (prove)\nusing this:\n  ?n < 2 \\<Longrightarrow> ?n = 0 \\<or> ?n = Suc 0\n  S $$ (0, 1) = (0::'a)\n  S \\<in> carrier_mat 1 2\n\ngoal (1 subgoal):\n 1. (\\<forall>a.\n        a + 1 < min (dim_row S) (dim_col S) \\<longrightarrow>\n        S $$ (a, a) dvd S $$ (a + 1, a + 1)) \\<and>\n    (\\<forall>i j.\n        i \\<noteq> j \\<and>\n        i < dim_row S \\<and> j < dim_col S \\<longrightarrow>\n        S $$ (i, j) = (0::'a))", "by fastforce"], ["proof (state)\nthis:\n  Smith_normal_form_mat S\n\ngoal (2 subgoals):\n 1. A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n    A $$ (0, 1) \\<noteq> (0::'a) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "ultimately"], ["proof (chain)\npicking this:\n  S \\<in> carrier_mat 1 2\n  invertible_mat Q\n  S = A * Q\n  S $$ (0, 1) = (0::'a)\n  Smith_normal_form_mat S", "show ?thesis"], ["proof (prove)\nusing this:\n  S \\<in> carrier_mat 1 2\n  invertible_mat Q\n  S = A * Q\n  S $$ (0, 1) = (0::'a)\n  Smith_normal_form_mat S\n\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "using S Q A SQ"], ["proof (prove)\nusing this:\n  S \\<in> carrier_mat 1 2\n  invertible_mat Q\n  S = A * Q\n  S $$ (0, 1) = (0::'a)\n  Smith_normal_form_mat S\n  S = A * (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n  Q = (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n  A \\<in> carrier_mat 1 2\n  (S, Q) = Smith_1x2_eucl_JNF A\n\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "unfolding is_SNF_def bezout_matrix_JNF_def"], ["proof (prove)\nusing this:\n  S \\<in> carrier_mat 1 2\n  invertible_mat Q\n  S = A * Q\n  S $$ (0, 1) = (0::'a)\n  Smith_normal_form_mat S\n  S =\n  A *\n  (Matrix.mat (dim_row A\\<^sup>T) (dim_row A\\<^sup>T)\n    (\\<lambda>(x, y).\n        let (p, q, u, v, d) =\n              euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n        in if x = 0 \\<and> y = 0 then p\n           else if x = 0 \\<and> y = 1 then q\n                else if x = 1 \\<and> y = 0 then u\n                     else if x = 1 \\<and> y = 1 then v\n                          else if x = y then 1::'a else (0::'a)))\\<^sup>T\n  Q =\n  (Matrix.mat (dim_row A\\<^sup>T) (dim_row A\\<^sup>T)\n    (\\<lambda>(x, y).\n        let (p, q, u, v, d) =\n              euclid_ext2 (A\\<^sup>T $$ (0, 0)) (A\\<^sup>T $$ (1, 0))\n        in if x = 0 \\<and> y = 0 then p\n           else if x = 0 \\<and> y = 1 then q\n                else if x = 1 \\<and> y = 0 then u\n                     else if x = 1 \\<and> y = 1 then v\n                          else if x = y then 1::'a else (0::'a)))\\<^sup>T\n  A \\<in> carrier_mat 1 2\n  (S, Q) = Smith_1x2_eucl_JNF A\n\ngoal (1 subgoal):\n 1. case (1\\<^sub>m 1, Smith_1x2_eucl_JNF A) of\n    (P, S, Q) \\<Rightarrow>\n      P \\<in> carrier_mat (dim_row A) (dim_row A) \\<and>\n      Q \\<in> carrier_mat (dim_col A) (dim_col A) \\<and>\n      invertible_mat P \\<and>\n      invertible_mat Q \\<and> Smith_normal_form_mat S \\<and> S = P * A * Q", "by force"], ["proof (state)\nthis:\n  is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n\ngoal (1 subgoal):\n 1. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "case False"], ["proof (state)\nthis:\n  \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have Q: \"Q = 1\\<^sub>m 2\" and S: \"S = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = 1\\<^sub>m 2 &&& S = A", "using SQ False A00_A01"], ["proof (prove)\nusing this:\n  (S, Q) = Smith_1x2_eucl_JNF A\n  \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a))\n  \\<not> (A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Q = 1\\<^sub>m 2 &&& S = A", "unfolding Smith_1x2_eucl_JNF_def"], ["proof (prove)\nusing this:\n  (S, Q) =\n  (if A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n   then let Q = swaprows_mat 2 0 1; A' = swapcols 0 1 A in (A', Q)\n   else if A $$ (0, 0) \\<noteq> (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a)\n        then let bezout_matrix_right =\n                   (bezout_matrix_JNF A\\<^sup>T 0 1 0 euclid_ext2)\\<^sup>T\n             in (A * bezout_matrix_right, bezout_matrix_right)\n        else (A, 1\\<^sub>m 2))\n  \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a))\n  \\<not> (A $$ (0, 0) = (0::'a) \\<and> A $$ (0, 1) \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Q = 1\\<^sub>m 2 &&& S = A", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  Q = 1\\<^sub>m 2\n  S = A\n\ngoal (1 subgoal):\n 1. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "have \"is_SNF A (1\\<^sub>m 1, A, 1\\<^sub>m 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, A, 1\\<^sub>m 2)", "by (rule is_SNF_intro, insert A False A00_A01 S Q A less_2_cases, \n          unfold Smith_normal_form_mat_def isDiagonal_mat_def, fastforce+)"], ["proof (state)\nthis:\n  is_SNF A (1\\<^sub>m 1, A, 1\\<^sub>m 2)\n\ngoal (1 subgoal):\n 1. \\<not> (A $$ (0, 0) \\<noteq> (0::'a) \\<and>\n            A $$ (0, 1) \\<noteq> (0::'a)) \\<Longrightarrow>\n    is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_SNF A (1\\<^sub>m 1, A, 1\\<^sub>m 2)\n\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "using SQ S Q"], ["proof (prove)\nusing this:\n  is_SNF A (1\\<^sub>m 1, A, 1\\<^sub>m 2)\n  (S, Q) = Smith_1x2_eucl_JNF A\n  S = A\n  Q = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "by auto"], ["proof (state)\nthis:\n  is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The final executable algorithm to transform any matrix into its Smith normal form\\<close>"], ["", "global_interpretation Smith_ED: Smith_Impl Smith_1x2_eucl_JNF Smith_2x2_JNF_eucl \"(div)\"\n  defines Smith_ED_1xn_aux = Smith_ED.Smith_1xn_aux\n    and Smith_ED_nx1 = Smith_ED.Smith_nx1\n  and Smith_ED_1xn = Smith_ED.Smith_1xn\n  and Smith_ED_2xn = Smith_ED.Smith_2xn\n  and Smith_ED_nx2 = Smith_ED.Smith_nx2\n  and Smith_ED_mxn = Smith_ED.Smith_mxn"], ["proof (prove)\ngoal (1 subgoal):\n 1. Smith_Impl Smith_1x2_eucl_JNF Smith_2x2_JNF_eucl (div)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>A\\<in>carrier_mat 1 2.\n       is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n 2. \\<forall>A\\<in>carrier_mat 2 2. is_SNF A (Smith_2x2_JNF_eucl A)\n 3. is_div_op (div)", "show \"\\<forall>(A::'a mat)\\<in>carrier_mat 1 2. is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat 1 2.\n       is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "using Smith_1x2_eucl_JNF_works prod.collapse"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat 1 2;\n   (?S, ?Q) = Smith_1x2_eucl_JNF ?A\\<rbrakk>\n  \\<Longrightarrow> is_SNF ?A (1\\<^sub>m 1, Smith_1x2_eucl_JNF ?A)\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat 1 2.\n       is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)", "by blast"], ["proof (state)\nthis:\n  \\<forall>A\\<in>carrier_mat 1 2.\n     is_SNF A (1\\<^sub>m 1, Smith_1x2_eucl_JNF A)\n\ngoal (2 subgoals):\n 1. \\<forall>A\\<in>carrier_mat 2 2. is_SNF A (Smith_2x2_JNF_eucl A)\n 2. is_div_op (div)", "show \"\\<forall>A\\<in>carrier_mat 2 2. is_SNF A (Smith_2x2_JNF_eucl A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>carrier_mat 2 2. is_SNF A (Smith_2x2_JNF_eucl A)", "by (simp add: Smith_2x2_JNF_eucl_def Smith_2x2_JNF_eucl_works split_beta)"], ["proof (state)\nthis:\n  \\<forall>A\\<in>carrier_mat 2 2. is_SNF A (Smith_2x2_JNF_eucl A)\n\ngoal (1 subgoal):\n 1. is_div_op (div)", "show \"is_div_op ((div)::'a\\<Rightarrow>'a\\<Rightarrow>'a::euclidean_ring_gcd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_div_op (div)", "by (unfold is_div_op_def, simp)"], ["proof (state)\nthis:\n  is_div_op (div)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nvalue[code] \"let (P,S,Q) = diagonalize_2x2 ((list_of_list_to_matrix [[32,128],[24,20]])::int^2^2)\n  in (matrix_to_list_of_list P,matrix_to_list_of_list S,matrix_to_list_of_list Q)\"\nvalue [code]  \"show (diagonalize_2x2_JNF (mat_of_rows_list 2 [[1,2::int],[3,4]]))\"\n*)\n\n\n(*\nvalue [code]  \"show (Smith_ED_mxn (mat_of_rows_list 2 [[1,2::int],[3,4]]))\"\n\nvalue [code]  \"show (Smith_ED_mxn (mat_of_rows_list 2 \n  [\n    [[:2,4,1:]::rat poly, [:3,2,0,2:]],\n    [[:0,2:]  , [:3,2:]]\n  ]\n))\"\n*)"], ["", "end"]]}