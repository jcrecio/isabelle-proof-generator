{"file_name": "/home/qj213/afp-2021-10-22/thys/ROBDD/Level_Collapse.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ROBDD", "problem_names": ["lemma bdd_relator_mono[intro!]: \"q \\<subseteq> p \\<Longrightarrow> bdd_relator p s \\<Longrightarrow>\\<^sub>A bdd_relator q s\"", "lemma bdd_relator_absorb_true[simp]: \"bdd_relator p s * true = bdd_relator p s\"", "lemma join_hlp1: \"is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\\<^sub>A is_bdd_impl a s * is_bdd_impl b s * \\<up>(a = b)\"", "lemma join_hlp: \"is_bdd_impl a s * is_bdd_impl b s = is_bdd_impl b s * is_bdd_impl a s * \\<up>(a = b)\"", "lemma add_true_asm:\n  assumes \"<b * true> p <a>\\<^sub>t\"\n  shows \"<b> p <a>\\<^sub>t\"", "lemma add_anything:\n  assumes \"<b> p <a>\"\n  shows \"<b * x> p <\\<lambda>r. a r * x>\\<^sub>t\"", "lemma add_true:\n  assumes \"<b> p <a>\\<^sub>t\"\n  shows \"<b * true> p <a>\\<^sub>t\"", "lemma node_relatorI: \"x \\<in> y \\<Longrightarrow> node_relator x y\"", "lemma node_relatorD: \"node_relator x y \\<Longrightarrow> x \\<in> y\"", "lemma iteci_rule[sep_heap_rules]: \"\n\\<lbrakk>node_relator (ib, ic)  rp; node_relator (tb, tc) rp; node_relator (eb, ec) rp\\<rbrakk> \\<Longrightarrow>\n<bdd_relator rp s> \n  iteci_lu ic tc ec s\n<\\<lambda>(r,s'). bdd_relator (insert (bf_ite ib tb eb,r) rp) s'>\"", "lemma tci_rule[sep_heap_rules]:\n\"<bdd_relator rp s> \n  tci s\n<\\<lambda>(r,s'). bdd_relator (insert (bf_True,r) rp) s'>\"", "lemma fci_rule[sep_heap_rules]:\n\"<bdd_relator rp s> \n  fci s\n<\\<lambda>(r,s'). bdd_relator (insert (bf_False,r) rp) s'>\"", "lemma [sep_heap_rules]:\n\"\\<lbrakk>(tb, tc) \\<in> rp; (eb, ec) \\<in> rp\\<rbrakk> \\<Longrightarrow>\n<bdd_relator rp s> \n  ifci v tc ec s\n<\\<lambda>(r,s'). bdd_relator (insert (bf_if v tb eb,r) rp) s'>\"", "lemma notci_rule[sep_heap_rules]:\n  assumes \"node_relator (tb, tc) rp\"\n  shows \"<bdd_relator rp s> notci tc s <\\<lambda>(r,s'). bdd_relator (insert (bf_not tb,r) rp) s'>\"", "lemma cirules1[sep_heap_rules]:\n  assumes \"node_relator (tb, tc) rp\" \"node_relator (eb, ec) rp\"\n  shows\n    \"<bdd_relator rp s> andci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_and tb eb,r) rp) s'>\"\n    \"<bdd_relator rp s> orci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_or tb eb,r) rp) s'>\"\n    \"<bdd_relator rp s> biimpci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_biimp tb eb,r) rp) s'>\"\n    \"<bdd_relator rp s> xorci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_xor tb eb,r) rp) s'>\"", "lemma cirules2[sep_heap_rules]:\n  assumes \"node_relator (tb, tc) rp\" \"node_relator (eb, ec) rp\"\n  shows\n    \"<bdd_relator rp s> nandci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_nand tb eb,r) rp) s'>\"\n    \"<bdd_relator rp s> norci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_nor tb eb,r) rp) s'>\"", "lemma litci_rule[sep_heap_rules]:\n  \"<bdd_relator rp s> litci v s <\\<lambda>(r,s'). bdd_relator (insert (bf_lit v,r) rp) s'>\"", "lemma tautci_rule[sep_heap_rules]:\n  shows \"node_relator (tb, tc) rp \\<Longrightarrow> <bdd_relator rp s> tautci tc s <\\<lambda>r. bdd_relator rp s * \\<up>(r \\<longleftrightarrow> tb = bf_True)>\"", "lemma emptyci_rule[sep_heap_rules]:\n  shows \"<emp> emptyci <\\<lambda>r. bdd_relator {} r>\"", "lemmas [simp] = bf_ite_def", "lemma iteeq_rule[sep_heap_rules]: \"\n\\<lbrakk>node_relator (xb, xc)  rp; node_relator (yb, yc) rp\\<rbrakk> \\<Longrightarrow>\n<bdd_relator rp s>\n  eqci xc yc\n<\\<lambda>r. \\<up>(r \\<longleftrightarrow> xb = yb)>\\<^sub>t\""], "translations": [["", "lemma bdd_relator_mono[intro!]: \"q \\<subseteq> p \\<Longrightarrow> bdd_relator p s \\<Longrightarrow>\\<^sub>A bdd_relator q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<subseteq> p \\<Longrightarrow>\n    bdd_relator p s \\<Longrightarrow>\\<^sub>A bdd_relator q s", "unfolding bdd_relator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<subseteq> p \\<Longrightarrow>\n    \\<exists>\\<^sub>Acs.\n       is_bdd_impl cs s *\n       \\<up> (p \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n       true \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Acs.\n       is_bdd_impl cs s *\n       \\<up> (q \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n       true", "by sep_auto"], ["", "lemma bdd_relator_absorb_true[simp]: \"bdd_relator p s * true = bdd_relator p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_relator p s * true = bdd_relator p s", "unfolding bdd_relator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>Acs.\n        is_bdd_impl cs s *\n        \\<up> (p \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n        true) *\n    true =\n    (\\<exists>\\<^sub>Acs.\n        is_bdd_impl cs s *\n        \\<up> (p \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n        true)", "by simp"], ["", "thm bdd_relator_def[unfolded bddmi_rel_def, simplified]"], ["", "lemma join_hlp1: \"is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\\<^sub>A is_bdd_impl a s * is_bdd_impl b s * \\<up>(a = b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\\<^sub>A\n    is_bdd_impl a s * is_bdd_impl b s * \\<up> (a = b)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       (aa, ba) \\<Turnstile>\n       is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\n       a = b", "apply(rule preciseD[where p=s and R=\"is_bdd_impl\" and F=\"is_bdd_impl b s\" and F'=\"is_bdd_impl a s\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       (aa, ba) \\<Turnstile>\n       is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\n       precise is_bdd_impl\n 2. \\<And>aa ba.\n       (aa, ba) \\<Turnstile>\n       is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\n       ?h6 aa ba \\<Turnstile>\n       is_bdd_impl a s * is_bdd_impl b s \\<and>\\<^sub>A\n       is_bdd_impl b s * is_bdd_impl a s", "apply(rule is_bdd_impl_prec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       (aa, ba) \\<Turnstile>\n       is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\n       ?h6 aa ba \\<Turnstile>\n       is_bdd_impl a s * is_bdd_impl b s \\<and>\\<^sub>A\n       is_bdd_impl b s * is_bdd_impl a s", "apply(unfold mod_and_dist)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       (aa, ba) \\<Turnstile>\n       is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\n       ?h6 aa ba \\<Turnstile> is_bdd_impl a s * is_bdd_impl b s \\<and>\n       ?h6 aa ba \\<Turnstile> is_bdd_impl b s * is_bdd_impl a s", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       (aa, ba) \\<Turnstile>\n       is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\n       ?h6 aa ba \\<Turnstile> is_bdd_impl a s * is_bdd_impl b s\n 2. \\<And>aa ba.\n       (aa, ba) \\<Turnstile>\n       is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\n       ?h6 aa ba \\<Turnstile> is_bdd_impl b s * is_bdd_impl a s", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       (aa, ba) \\<Turnstile>\n       is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\n       (aa, ba) \\<Turnstile> is_bdd_impl b s * is_bdd_impl a s", "apply(simp add: star_aci(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma join_hlp: \"is_bdd_impl a s * is_bdd_impl b s = is_bdd_impl b s * is_bdd_impl a s * \\<up>(a = b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bdd_impl a s * is_bdd_impl b s =\n    is_bdd_impl b s * is_bdd_impl a s * \\<up> (a = b)", "apply(rule ent_iffI[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_bdd_impl b s * is_bdd_impl a s *\n    \\<up> (a = b) \\<Longrightarrow>\\<^sub>A\n    is_bdd_impl a s * is_bdd_impl b s\n 2. is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\\<^sub>A\n    is_bdd_impl b s * is_bdd_impl a s * \\<up> (a = b)", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\\<^sub>A\n    is_bdd_impl b s * is_bdd_impl a s * \\<up> (a = b)", "apply(rule ent_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_bdd_impl a s * is_bdd_impl b s \\<Longrightarrow>\\<^sub>A ?Q5\n 2. ?Q5 \\<Longrightarrow>\\<^sub>A\n    is_bdd_impl b s * is_bdd_impl a s * \\<up> (a = b)", "apply(rule join_hlp1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bdd_impl a s * is_bdd_impl b s *\n    \\<up> (a = b) \\<Longrightarrow>\\<^sub>A\n    is_bdd_impl b s * is_bdd_impl a s * \\<up> (a = b)", "apply(simp; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma add_true_asm:\n  assumes \"<b * true> p <a>\\<^sub>t\"\n  shows \"<b> p <a>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <b> p <a>\\<^sub>t", "apply(rule cons_pre_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\\<^sub>A ?P'\n 2. <?P'> p <a>\\<^sub>t", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. <?P'> p <a>\\<^sub>t\n 2. b \\<Longrightarrow>\\<^sub>A ?P'", "apply(rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<Longrightarrow>\\<^sub>A b * true", "apply(simp add: ent_true_drop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma add_anything:\n  assumes \"<b> p <a>\"\n  shows \"<b * x> p <\\<lambda>r. a r * x>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <b * x> p <\\<lambda>r. a r * x>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <b * x> p <\\<lambda>r. a r * x>\\<^sub>t", "note [sep_heap_rules] = assms"], ["proof (state)\nthis:\n  <b> p <a>\n\ngoal (1 subgoal):\n 1. <b * x> p <\\<lambda>r. a r * x>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <b * x> p <\\<lambda>r. a r * x>\\<^sub>t", "by sep_auto"], ["proof (state)\nthis:\n  <b * x> p <\\<lambda>r. a r * x>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_true:\n  assumes \"<b> p <a>\\<^sub>t\"\n  shows \"<b * true> p <a>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <b * true> p <a>\\<^sub>t", "using assms add_anything[where x=true]"], ["proof (prove)\nusing this:\n  <b> p <a>\\<^sub>t\n  <?b> ?p <?a> \\<Longrightarrow>\n  <?b * true> ?p <\\<lambda>r. ?a r * true>\\<^sub>t\n\ngoal (1 subgoal):\n 1. <b * true> p <a>\\<^sub>t", "by force"], ["", "definition node_relator where \"node_relator x y \\<longleftrightarrow> x \\<in> y\""], ["", "text \\<open>\\<open>sep_auto\\<close> behaves sub-optimal when having @{term \"(bf,bdd) \\<in> computed_pointer_relation\"} as assumption in our cases. Using @{const node_relator} instead fixes this behavior with a custom solver for \\<open>simp\\<close>.\\<close>"], ["", "lemma node_relatorI: \"x \\<in> y \\<Longrightarrow> node_relator x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> y \\<Longrightarrow> node_relator x y", "unfolding node_relator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> y \\<Longrightarrow> x \\<in> y", "."], ["", "lemma node_relatorD: \"node_relator x y \\<Longrightarrow> x \\<in> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. node_relator x y \\<Longrightarrow> x \\<in> y", "unfolding node_relator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> y \\<Longrightarrow> x \\<in> y", "."], ["", "ML\\<open>fun TRY' tac = tac ORELSE' K all_tac\\<close>"], ["", "setup \\<open>map_theory_simpset (fn ctxt =>\n  ctxt addSolver (Simplifier.mk_solver \"node_relator\"\n    (fn ctxt => fn n =>\n      let\n        val tac =\n          resolve_tac ctxt @{thms node_relatorI} THEN'\n          REPEAT_ALL_NEW (resolve_tac ctxt @{thms Set.insertI1 Set.insertI2}) THEN'\n          TRY' (dresolve_tac ctxt @{thms node_relatorD} THEN' assume_tac ctxt)\n      in\n        SOLVED' tac n\n      end))\n)\\<close>"], ["", "text\\<open>\nThis is the general form one wants to work with:\nif a function on the bdd is called with a set of already existing and valid pointers, the arguments to the function have to be in that set.\nThe result is that one more pointer is the set of existing and valid pointers.\n\\<close>"], ["", "thm iteci_rule[THEN mp] mi.ite_impl_R ifex_ite_rel_bf"], ["", "lemma iteci_rule[sep_heap_rules]: \"\n\\<lbrakk>node_relator (ib, ic)  rp; node_relator (tb, tc) rp; node_relator (eb, ec) rp\\<rbrakk> \\<Longrightarrow>\n<bdd_relator rp s> \n  iteci_lu ic tc ec s\n<\\<lambda>(r,s'). bdd_relator (insert (bf_ite ib tb eb,r) rp) s'>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>node_relator (ib, ic) rp; node_relator (tb, tc) rp;\n     node_relator (eb, ec) rp\\<rbrakk>\n    \\<Longrightarrow> <bdd_relator rp s> iteci_lu ic tc ec s\n                      <\\<lambda>(r, s').\n                          bdd_relator (insert (bf_ite ib tb eb, r) rp) s'>", "apply(unfold bdd_relator_def node_relator_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ib, ic) \\<in> rp; (tb, tc) \\<in> rp;\n     (eb, ec) \\<in> rp\\<rbrakk>\n    \\<Longrightarrow> <\\<exists>\\<^sub>Acs.\n                          is_bdd_impl cs s *\n                          \\<up>\n                           (rp \\<subseteq> bddmi_rel cs \\<and>\n                            bdd_sane cs) *\n                          true>\n                      iteci_lu ic tc ec s\n                      <\\<lambda>(r, s').\n                          \\<exists>\\<^sub>Acs.\n                             is_bdd_impl cs s' *\n                             \\<up>\n                              (insert (bf_ite ib tb eb, r) rp\n                               \\<subseteq> bddmi_rel cs \\<and>\n                               bdd_sane cs) *\n                             true>", "apply(intro norm_pre_ex_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>(ib, ic) \\<in> rp; (tb, tc) \\<in> rp;\n        (eb, ec) \\<in> rp\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s *\n                          \\<up>\n                           (rp \\<subseteq> bddmi_rel cs \\<and>\n                            bdd_sane cs) *\n                          true>\n                         iteci_lu ic tc ec s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 (insert (bf_ite ib tb eb, r) rp\n                                  \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>(ib, ic) \\<in> rp; (tb, tc) \\<in> rp; (eb, ec) \\<in> rp;\n        rp \\<subseteq> bddmi_rel cs; bdd_sane cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> iteci_lu ic tc ec s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_ite ib tb eb, r)\n                                  \\<in> bddmi_rel cs \\<and>\n                                  rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(unfold bddmi_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>(ib, ic) \\<in> rp; (tb, tc) \\<in> rp; (eb, ec) \\<in> rp;\n        rp \\<subseteq> {uu_.\n                        \\<exists>a b c.\n                           uu_ = (a, c) \\<and>\n                           (a, b) \\<in> bf_ifex_rel \\<and>\n                           (c, b) \\<in> Rmi cs};\n        bdd_sane cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> iteci_lu ic tc ec s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_ite ib tb eb, r)\n                                  \\<in> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(drule (1) rev_subsetD)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs;\n        (ib, ic)\n        \\<in> {uu_.\n               \\<exists>a b c.\n                  uu_ = (a, c) \\<and>\n                  (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs};\n        (tb, tc)\n        \\<in> {uu_.\n               \\<exists>a b c.\n                  uu_ = (a, c) \\<and>\n                  (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs};\n        (eb, ec)\n        \\<in> {uu_.\n               \\<exists>a b c.\n                  uu_ = (a, c) \\<and>\n                  (a, b) \\<in> bf_ifex_rel \\<and>\n                  (c, b) \\<in> Rmi cs}\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> iteci_lu ic tc ec s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_ite ib tb eb, r)\n                                  \\<in> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> iteci_lu ic tc ec s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((\\<exists>b.\n(bf_ite ib tb eb, b) \\<in> bf_ifex_rel \\<and> (r, b) \\<in> Rmi cs) \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(drule (3) mi.ite_impl_lu_R[where ii=ic and ti=tc and ei=ec, unfolded in_rel_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        ospec (mi.ite_impl_lu ic tc ec cs)\n         (\\<lambda>(r, s').\n             (r, ifex_ite_opt b ba bb) \\<in> Rmi s' \\<and>\n             bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> iteci_lu ic tc ec s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((\\<exists>b.\n(bf_ite ib tb eb, b) \\<in> bf_ifex_rel \\<and> (r, b) \\<in> Rmi cs) \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(drule ospecD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        \\<exists>y.\n           mi.ite_impl_lu ic tc ec cs = Some y \\<and>\n           (case y of\n            (r, s') \\<Rightarrow>\n              (r, ifex_ite_opt b ba bb) \\<in> Rmi s' \\<and>\n              bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> iteci_lu ic tc ec s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((\\<exists>b.\n(bf_ite ib tb eb, b) \\<in> bf_ifex_rel \\<and> (r, b) \\<in> Rmi cs) \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(clarsimp simp del: ifex_ite.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb a bc.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> iteci_lu ic tc ec s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((\\<exists>b.\n(bf_ite ib tb eb, b) \\<in> bf_ifex_rel \\<and> (r, b) \\<in> Rmi cs) \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs b ba bb a bc.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> iteci_lu ic tc ec s\n                         <?Q30 cs b ba bb a bc>\n 2. \\<And>cs b ba bb a bc x.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> ?Q30 cs b ba bb a bc x \\<Longrightarrow>\\<^sub>A\n                         (case x of\n                          (r, s') \\<Rightarrow>\n                            \\<exists>\\<^sub>Acs.\n                               is_bdd_impl cs s' *\n                               \\<up>\n                                ((\\<exists>b.\n                                     (bf_ite ib tb eb, b)\n                                     \\<in> bf_ifex_rel \\<and>\n                                     (r, b) \\<in> Rmi cs) \\<and>\n                                 rp \\<subseteq> {uu_.\n           \\<exists>a b c.\n              uu_ = (a, c) \\<and>\n              (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                 bdd_sane cs) *\n                               true)", "apply(rule cons_pre_rule[rotated])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>cs b ba bb a bc.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> <?P'33 cs b ba bb a bc> iteci_lu ic tc ec s\n                         <?Q30 cs b ba bb a bc>\n 2. \\<And>cs b ba bb a bc.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl cs s * true \\<Longrightarrow>\\<^sub>A\n                         ?P'33 cs b ba bb a bc\n 3. \\<And>cs b ba bb a bc x.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> ?Q30 cs b ba bb a bc x \\<Longrightarrow>\\<^sub>A\n                         (case x of\n                          (r, s') \\<Rightarrow>\n                            \\<exists>\\<^sub>Acs.\n                               is_bdd_impl cs s' *\n                               \\<up>\n                                ((\\<exists>b.\n                                     (bf_ite ib tb eb, b)\n                                     \\<in> bf_ifex_rel \\<and>\n                                     (r, b) \\<in> Rmi cs) \\<and>\n                                 rp \\<subseteq> {uu_.\n           \\<exists>a b c.\n              uu_ = (a, c) \\<and>\n              (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                 bdd_sane cs) *\n                               true)", "apply(rule iteci_lu_rule[THEN mp, THEN add_true])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>cs b ba bb a bc.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> mi.ite_impl_lu ic tc ec (?bdd38 cs b ba bb a bc) =\n                         Some\n                          (?p38 cs b ba bb a bc, ?bdd'38 cs b ba bb a bc)\n 2. \\<And>cs b ba bb a bc.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl cs s * true \\<Longrightarrow>\\<^sub>A\n                         is_bdd_impl (?bdd38 cs b ba bb a bc) s * true\n 3. \\<And>cs b ba bb a bc x.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (pi, bddi') \\<Rightarrow>\n                            is_bdd_impl (?bdd'38 cs b ba bb a bc) bddi' *\n                            \\<up> (pi = ?p38 cs b ba bb a bc)) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         (case x of\n                          (r, s') \\<Rightarrow>\n                            \\<exists>\\<^sub>Acs.\n                               is_bdd_impl cs s' *\n                               \\<up>\n                                ((\\<exists>b.\n                                     (bf_ite ib tb eb, b)\n                                     \\<in> bf_ifex_rel \\<and>\n                                     (r, b) \\<in> Rmi cs) \\<and>\n                                 rp \\<subseteq> {uu_.\n           \\<exists>a b c.\n              uu_ = (a, c) \\<and>\n              (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                 bdd_sane cs) *\n                               true)", "apply(assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs b ba bb a bc.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl cs s * true \\<Longrightarrow>\\<^sub>A\n                         is_bdd_impl cs s * true\n 2. \\<And>cs b ba bb a bc x.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (pi, bddi') \\<Rightarrow>\n                            is_bdd_impl bc bddi' * \\<up> (pi = a)) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         (case x of\n                          (r, s') \\<Rightarrow>\n                            \\<exists>\\<^sub>Acs.\n                               is_bdd_impl cs s' *\n                               \\<up>\n                                ((\\<exists>b.\n                                     (bf_ite ib tb eb, b)\n                                     \\<in> bf_ifex_rel \\<and>\n                                     (r, b) \\<in> Rmi cs) \\<and>\n                                 rp \\<subseteq> {uu_.\n           \\<exists>a b c.\n              uu_ = (a, c) \\<and>\n              (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                 bdd_sane cs) *\n                               true)", "apply(sep_auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb a bc x.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (pi, bddi') \\<Rightarrow>\n                            is_bdd_impl bc bddi' * \\<up> (pi = a)) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         (case x of\n                          (r, s') \\<Rightarrow>\n                            \\<exists>\\<^sub>Acs.\n                               is_bdd_impl cs s' *\n                               \\<up>\n                                ((\\<exists>b.\n                                     (bf_ite ib tb eb, b)\n                                     \\<in> bf_ifex_rel \\<and>\n                                     (r, b) \\<in> Rmi cs) \\<and>\n                                 rp \\<subseteq> {uu_.\n           \\<exists>a b c.\n              uu_ = (a, c) \\<and>\n              (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                 bdd_sane cs) *\n                               true)", "apply(clarsimp simp del: ifex_ite.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb a bc bd.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl bc bd * true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Acs.\n                            is_bdd_impl cs bd * true *\n                            \\<up>\n                             ((\\<exists>b.\n                                  (bf_ite ib tb eb, b)\n                                  \\<in> bf_ifex_rel \\<and>\n                                  (a, b) \\<in> Rmi cs) \\<and>\n                              rp \\<subseteq> {uu_.\n        \\<exists>a b c.\n           uu_ = (a, c) \\<and>\n           (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                              bdd_sane cs)", "apply(rule ent_ex_postI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb a bc bd.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl bc bd * true \\<Longrightarrow>\\<^sub>A\n                         is_bdd_impl (?cs44 cs b ba bb a bc bd) bd * true *\n                         \\<up>\n                          ((\\<exists>be.\n                               (bf_ite ib tb eb, be)\n                               \\<in> bf_ifex_rel \\<and>\n                               (a, be)\n                               \\<in> Rmi (?cs44 cs b ba bb a bc bd)) \\<and>\n                           rp \\<subseteq> {uu_.\n     \\<exists>aa be c.\n        uu_ = (aa, c) \\<and>\n        (aa, be) \\<in> bf_ifex_rel \\<and>\n        (c, be) \\<in> Rmi (?cs44 cs b ba bb a bc bd)} \\<and>\n                           bdd_sane (?cs44 cs b ba bb a bc bd))", "apply(subst ent_pure_post_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb a bc bd.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>h.\n                             h \\<Turnstile>\n                             is_bdd_impl bc bd * true \\<longrightarrow>\n                             (\\<exists>be.\n                                 (bf_ite ib tb eb, be)\n                                 \\<in> bf_ifex_rel \\<and>\n                                 (a, be)\n                                 \\<in> Rmi\n  (?cs46 cs b ba bb a bc bd (?csa46 cs b ba bb a bc bd)\n    (?b46 cs b ba bb a bc bd) (?ba46 cs b ba bb a bc bd)\n    (?bb46 cs b ba bb a bc bd) a bc bd)) \\<and>\n                             rp \\<subseteq> {uu_.\n       \\<exists>aa be c.\n          uu_ = (aa, c) \\<and>\n          (aa, be) \\<in> bf_ifex_rel \\<and>\n          (c, be)\n          \\<in> Rmi (?cs46 cs b ba bb a bc bd (?csa46 cs b ba bb a bc bd)\n                      (?b46 cs b ba bb a bc bd) (?ba46 cs b ba bb a bc bd)\n                      (?bb46 cs b ba bb a bc bd) a bc bd)} \\<and>\n                             bdd_sane\n                              (?cs46 cs b ba bb a bc bd\n                                (?csa46 cs b ba bb a bc bd)\n                                (?b46 cs b ba bb a bc bd)\n                                (?ba46 cs b ba bb a bc bd)\n                                (?bb46 cs b ba bb a bc bd) a bc bd)) \\<and>\n                         (is_bdd_impl bc bd * true \\<Longrightarrow>\\<^sub>A\n                          is_bdd_impl\n                           (?cs46 cs b ba bb a bc bd\n                             (?csa46 cs b ba bb a bc bd)\n                             (?b46 cs b ba bb a bc bd)\n                             (?ba46 cs b ba bb a bc bd)\n                             (?bb46 cs b ba bb a bc bd) a bc bd)\n                           bd *\n                          true)", "apply(rule conjI[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs b ba bb a bc bd.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl bc bd * true \\<Longrightarrow>\\<^sub>A\n                         is_bdd_impl\n                          (?cs46 cs b ba bb a bc bd\n                            (?csa46 cs b ba bb a bc bd)\n                            (?b46 cs b ba bb a bc bd)\n                            (?ba46 cs b ba bb a bc bd)\n                            (?bb46 cs b ba bb a bc bd) a bc bd)\n                          bd *\n                         true\n 2. \\<And>cs b ba bb a bc bd.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> \\<forall>h.\n                            h \\<Turnstile>\n                            is_bdd_impl bc bd * true \\<longrightarrow>\n                            (\\<exists>be.\n                                (bf_ite ib tb eb, be)\n                                \\<in> bf_ifex_rel \\<and>\n                                (a, be)\n                                \\<in> Rmi\n (?cs46 cs b ba bb a bc bd (?csa46 cs b ba bb a bc bd)\n   (?b46 cs b ba bb a bc bd) (?ba46 cs b ba bb a bc bd)\n   (?bb46 cs b ba bb a bc bd) a bc bd)) \\<and>\n                            rp \\<subseteq> {uu_.\n      \\<exists>aa be c.\n         uu_ = (aa, c) \\<and>\n         (aa, be) \\<in> bf_ifex_rel \\<and>\n         (c, be)\n         \\<in> Rmi (?cs46 cs b ba bb a bc bd (?csa46 cs b ba bb a bc bd)\n                     (?b46 cs b ba bb a bc bd) (?ba46 cs b ba bb a bc bd)\n                     (?bb46 cs b ba bb a bc bd) a bc bd)} \\<and>\n                            bdd_sane\n                             (?cs46 cs b ba bb a bc bd\n                               (?csa46 cs b ba bb a bc bd)\n                               (?b46 cs b ba bb a bc bd)\n                               (?ba46 cs b ba bb a bc bd)\n                               (?bb46 cs b ba bb a bc bd) a bc bd)", "apply(sep_auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb a bc bd.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc;\n        mi.les cs bc\\<rbrakk>\n       \\<Longrightarrow> \\<forall>h.\n                            h \\<Turnstile>\n                            is_bdd_impl bc bd * true \\<longrightarrow>\n                            (\\<exists>b.\n                                (bf_ite ib tb eb, b)\n                                \\<in> bf_ifex_rel \\<and>\n                                (a, b) \\<in> Rmi bc) \\<and>\n                            rp \\<subseteq> {uu_.\n      \\<exists>a b c.\n         uu_ = (a, c) \\<and>\n         (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi bc} \\<and>\n                            bdd_sane bc", "apply(clarsimp simp del: ifex_ite.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb a bc bd aa be.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc; mi.les cs bc;\n        (aa, be) \\<Turnstile> is_bdd_impl bc bd * true\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>b.\n                             (bf_ite ib tb eb, b) \\<in> bf_ifex_rel \\<and>\n                             (a, b) \\<in> Rmi bc) \\<and>\n                         rp \\<subseteq> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi bc}", "apply(rule conjI[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs b ba bb a bc bd aa be.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc; mi.les cs bc;\n        (aa, be) \\<Turnstile> is_bdd_impl bc bd * true\\<rbrakk>\n       \\<Longrightarrow> rp \\<subseteq> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi bc}\n 2. \\<And>cs b ba bb a bc bd aa be.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc; mi.les cs bc;\n        (aa, be) \\<Turnstile> is_bdd_impl bc bd * true\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            (bf_ite ib tb eb, b) \\<in> bf_ifex_rel \\<and>\n                            (a, b) \\<in> Rmi bc", "apply(force simp add: mi.les_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb a bc bd aa be.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc; mi.les cs bc;\n        (aa, be) \\<Turnstile> is_bdd_impl bc bd * true\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            (bf_ite ib tb eb, b) \\<in> bf_ifex_rel \\<and>\n                            (a, b) \\<in> Rmi bc", "apply(rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb a bc bd aa be.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc; mi.les cs bc;\n        (aa, be) \\<Turnstile> is_bdd_impl bc bd * true\\<rbrakk>\n       \\<Longrightarrow> (bf_ite ib tb eb, ?b80 cs b ba bb a bc bd aa be)\n                         \\<in> bf_ifex_rel \\<and>\n                         (a, ?b80 cs b ba bb a bc bd aa be) \\<in> Rmi bc", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs b ba bb a bc bd aa be.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc; mi.les cs bc;\n        (aa, be) \\<Turnstile> is_bdd_impl bc bd * true\\<rbrakk>\n       \\<Longrightarrow> (bf_ite ib tb eb, ?b80 cs b ba bb a bc bd aa be)\n                         \\<in> bf_ifex_rel\n 2. \\<And>cs b ba bb a bc bd aa be.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc; mi.les cs bc;\n        (aa, be) \\<Turnstile> is_bdd_impl bc bd * true\\<rbrakk>\n       \\<Longrightarrow> (a, ?b80 cs b ba bb a bc bd aa be) \\<in> Rmi bc", "apply(erule (2) ifex_ite_opt_rel_bf[unfolded in_rel_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba bb a bc bd aa be.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        (ib, b) \\<in> bf_ifex_rel; (ic, b) \\<in> Rmi cs;\n        (tb, ba) \\<in> bf_ifex_rel; (tc, ba) \\<in> Rmi cs;\n        (eb, bb) \\<in> bf_ifex_rel; (ec, bb) \\<in> Rmi cs;\n        mi.ite_impl_lu ic tc ec cs = Some (a, bc);\n        (a, ifex_ite_opt b ba bb) \\<in> Rmi bc; bdd_sane bc; mi.les cs bc;\n        (aa, be) \\<Turnstile> is_bdd_impl bc bd * true\\<rbrakk>\n       \\<Longrightarrow> (a, ifex_ite_opt b ba bb) \\<in> Rmi bc", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tci_rule[sep_heap_rules]:\n\"<bdd_relator rp s> \n  tci s\n<\\<lambda>(r,s'). bdd_relator (insert (bf_True,r) rp) s'>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <bdd_relator rp s> tci s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_True, r) rp) s'>", "apply(unfold bdd_relator_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Acs.\n        is_bdd_impl cs s *\n        \\<up> (rp \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n        true>\n    tci s\n    <\\<lambda>(r, s').\n        \\<exists>\\<^sub>Acs.\n           is_bdd_impl cs s' *\n           \\<up>\n            (insert (bf_True, r) rp \\<subseteq> bddmi_rel cs \\<and>\n             bdd_sane cs) *\n           true>", "apply(intro norm_pre_ex_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       <is_bdd_impl cs s *\n        \\<up> (rp \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n        true>\n       tci s\n       <\\<lambda>(r, s').\n           \\<exists>\\<^sub>Acs.\n              is_bdd_impl cs s' *\n              \\<up>\n               (insert (bf_True, r) rp \\<subseteq> bddmi_rel cs \\<and>\n                bdd_sane cs) *\n              true>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> tci s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_True, r) \\<in> bddmi_rel cs \\<and>\n                                  rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(frule mi.Timpl_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs;\n        ospec (tmi' cs)\n         (\\<lambda>(ni, s').\n             (ni, Trueif) \\<in> Rmi s' \\<and>\n             bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> tci s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_True, r) \\<in> bddmi_rel cs \\<and>\n                                  rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(drule ospecD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs;\n        \\<exists>y.\n           tmi' cs = Some y \\<and>\n           (case y of\n            (ni, s') \\<Rightarrow>\n              (ni, Trueif) \\<in> Rmi s' \\<and>\n              bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> tci s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_True, r) \\<in> bddmi_rel cs \\<and>\n                                  rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs a b.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs;\n        tmi' cs = Some (a, b); (a, Trueif) \\<in> Rmi b; bdd_sane b;\n        mi.les cs b\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> tci s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_True, r) \\<in> bddmi_rel cs \\<and>\n                                  rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs;\n        tmi' cs = Some (Suc 0, b); bdd_sane b; mi.les cs b;\n        (a, bb) \\<Turnstile> is_bdd_impl b ba * true\\<rbrakk>\n       \\<Longrightarrow> (bf_True, Suc 0) \\<in> bddmi_rel b\n 2. \\<And>cs b ba.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs;\n        tmi' cs = Some (Suc 0, b); bdd_sane b; mi.les cs b;\n        \\<exists>h. h \\<Turnstile> is_bdd_impl b ba * true\\<rbrakk>\n       \\<Longrightarrow> rp \\<subseteq> bddmi_rel b", "apply(unfold bddmi_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; tmi' cs = Some (Suc 0, b); bdd_sane b; mi.les cs b;\n        (a, bb) \\<Turnstile> is_bdd_impl b ba * true\\<rbrakk>\n       \\<Longrightarrow> (bf_True, Suc 0)\n                         \\<in> {uu_.\n                                \\<exists>a ba c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, ba) \\<in> bf_ifex_rel \\<and>\n                                   (c, ba) \\<in> Rmi b}\n 2. \\<And>cs b ba.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; tmi' cs = Some (Suc 0, b); bdd_sane b; mi.les cs b;\n        \\<exists>h. h \\<Turnstile> is_bdd_impl b ba * true\\<rbrakk>\n       \\<Longrightarrow> rp \\<subseteq> {uu_.\n   \\<exists>a ba c.\n      uu_ = (a, c) \\<and>\n      (a, ba) \\<in> bf_ifex_rel \\<and> (c, ba) \\<in> Rmi b}", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; tmi' cs = Some (Suc 0, b); bdd_sane b; mi.les cs b;\n        \\<exists>h. h \\<Turnstile> is_bdd_impl b ba * true\\<rbrakk>\n       \\<Longrightarrow> rp \\<subseteq> {uu_.\n   \\<exists>a ba c.\n      uu_ = (a, c) \\<and>\n      (a, ba) \\<in> bf_ifex_rel \\<and> (c, ba) \\<in> Rmi b}", "apply(force simp add: mi.les_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fci_rule[sep_heap_rules]:\n\"<bdd_relator rp s> \n  fci s\n<\\<lambda>(r,s'). bdd_relator (insert (bf_False,r) rp) s'>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <bdd_relator rp s> fci s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_False, r) rp) s'>", "apply(unfold bdd_relator_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Acs.\n        is_bdd_impl cs s *\n        \\<up> (rp \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n        true>\n    fci s\n    <\\<lambda>(r, s').\n        \\<exists>\\<^sub>Acs.\n           is_bdd_impl cs s' *\n           \\<up>\n            (insert (bf_False, r) rp \\<subseteq> bddmi_rel cs \\<and>\n             bdd_sane cs) *\n           true>", "apply(intro norm_pre_ex_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       <is_bdd_impl cs s *\n        \\<up> (rp \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n        true>\n       fci s\n       <\\<lambda>(r, s').\n           \\<exists>\\<^sub>Acs.\n              is_bdd_impl cs s' *\n              \\<up>\n               (insert (bf_False, r) rp \\<subseteq> bddmi_rel cs \\<and>\n                bdd_sane cs) *\n              true>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> fci s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_False, r) \\<in> bddmi_rel cs \\<and>\n                                  rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(frule mi.Fimpl_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs;\n        ospec (fmi' cs)\n         (\\<lambda>(ni, s').\n             (ni, Falseif) \\<in> Rmi s' \\<and>\n             bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> fci s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_False, r) \\<in> bddmi_rel cs \\<and>\n                                  rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(drule ospecD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs;\n        \\<exists>y.\n           fmi' cs = Some y \\<and>\n           (case y of\n            (ni, s') \\<Rightarrow>\n              (ni, Falseif) \\<in> Rmi s' \\<and>\n              bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> fci s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_False, r) \\<in> bddmi_rel cs \\<and>\n                                  rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs a b.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs;\n        fmi' cs = Some (a, b); (a, Falseif) \\<in> Rmi b; bdd_sane b;\n        mi.les cs b\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> fci s\n                         <\\<lambda>(r, s').\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s' *\n                                \\<up>\n                                 ((bf_False, r) \\<in> bddmi_rel cs \\<and>\n                                  rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs;\n        fmi' cs = Some (0, b); bdd_sane b; mi.les cs b;\n        (a, bb) \\<Turnstile> is_bdd_impl b ba * true\\<rbrakk>\n       \\<Longrightarrow> (bf_False, 0) \\<in> bddmi_rel b\n 2. \\<And>cs b ba.\n       \\<lbrakk>rp \\<subseteq> bddmi_rel cs; bdd_sane cs;\n        fmi' cs = Some (0, b); bdd_sane b; mi.les cs b;\n        \\<exists>h. h \\<Turnstile> is_bdd_impl b ba * true\\<rbrakk>\n       \\<Longrightarrow> rp \\<subseteq> bddmi_rel b", "apply(unfold bddmi_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; fmi' cs = Some (0, b); bdd_sane b; mi.les cs b;\n        (a, bb) \\<Turnstile> is_bdd_impl b ba * true\\<rbrakk>\n       \\<Longrightarrow> (bf_False, 0)\n                         \\<in> {uu_.\n                                \\<exists>a ba c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, ba) \\<in> bf_ifex_rel \\<and>\n                                   (c, ba) \\<in> Rmi b}\n 2. \\<And>cs b ba.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; fmi' cs = Some (0, b); bdd_sane b; mi.les cs b;\n        \\<exists>h. h \\<Turnstile> is_bdd_impl b ba * true\\<rbrakk>\n       \\<Longrightarrow> rp \\<subseteq> {uu_.\n   \\<exists>a ba c.\n      uu_ = (a, c) \\<and>\n      (a, ba) \\<in> bf_ifex_rel \\<and> (c, ba) \\<in> Rmi b}", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; fmi' cs = Some (0, b); bdd_sane b; mi.les cs b;\n        \\<exists>h. h \\<Turnstile> is_bdd_impl b ba * true\\<rbrakk>\n       \\<Longrightarrow> rp \\<subseteq> {uu_.\n   \\<exists>a ba c.\n      uu_ = (a, c) \\<and>\n      (a, ba) \\<in> bf_ifex_rel \\<and> (c, ba) \\<in> Rmi b}", "apply(force simp add: mi.les_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>IFC/ifmi/ifci require that the variable order is ensured by the user. \nInstead of using ifci, a combination of litci and iteci has to be used.\\<close>"], ["", "lemma [sep_heap_rules]:\n\"\\<lbrakk>(tb, tc) \\<in> rp; (eb, ec) \\<in> rp\\<rbrakk> \\<Longrightarrow>\n<bdd_relator rp s> \n  ifci v tc ec s\n<\\<lambda>(r,s'). bdd_relator (insert (bf_if v tb eb,r) rp) s'>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(tb, tc) \\<in> rp; (eb, ec) \\<in> rp\\<rbrakk>\n    \\<Longrightarrow> <bdd_relator rp s> ifci v tc ec s\n                      <\\<lambda>(r, s').\n                          bdd_relator (insert (bf_if v tb eb, r) rp) s'>", "text\\<open>This probably doesn't hold.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(tb, tc) \\<in> rp; (eb, ec) \\<in> rp\\<rbrakk>\n    \\<Longrightarrow> <bdd_relator rp s> ifci v tc ec s\n                      <\\<lambda>(r, s').\n                          bdd_relator (insert (bf_if v tb eb, r) rp) s'>", "oops"], ["", "lemma notci_rule[sep_heap_rules]:\n  assumes \"node_relator (tb, tc) rp\"\n  shows \"<bdd_relator rp s> notci tc s <\\<lambda>(r,s'). bdd_relator (insert (bf_not tb,r) rp) s'>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <bdd_relator rp s> notci tc s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_not tb, r) rp) s'>", "using assms"], ["proof (prove)\nusing this:\n  node_relator (tb, tc) rp\n\ngoal (1 subgoal):\n 1. <bdd_relator rp s> notci tc s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_not tb, r) rp) s'>", "by(sep_auto simp: notci_def)"], ["", "lemma cirules1[sep_heap_rules]:\n  assumes \"node_relator (tb, tc) rp\" \"node_relator (eb, ec) rp\"\n  shows\n    \"<bdd_relator rp s> andci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_and tb eb,r) rp) s'>\"\n    \"<bdd_relator rp s> orci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_or tb eb,r) rp) s'>\"\n    \"<bdd_relator rp s> biimpci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_biimp tb eb,r) rp) s'>\"\n    \"<bdd_relator rp s> xorci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_xor tb eb,r) rp) s'>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<bdd_relator rp s> andci tc ec s\n     <\\<lambda>(r, s'). bdd_relator (insert (bf_and tb eb, r) rp) s'> &&&\n     <bdd_relator rp s> orci tc ec s\n     <\\<lambda>(r, s'). bdd_relator (insert (bf_or tb eb, r) rp) s'>) &&&\n    <bdd_relator rp s> biimpci tc ec s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_biimp tb eb, r) rp) s'> &&&\n    <bdd_relator rp s> xorci tc ec s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_xor tb eb, r) rp) s'>", "(* actually, these functions would allow for more insert. I think that would be inconvenient though. *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (<bdd_relator rp s> andci tc ec s\n     <\\<lambda>(r, s'). bdd_relator (insert (bf_and tb eb, r) rp) s'> &&&\n     <bdd_relator rp s> orci tc ec s\n     <\\<lambda>(r, s'). bdd_relator (insert (bf_or tb eb, r) rp) s'>) &&&\n    <bdd_relator rp s> biimpci tc ec s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_biimp tb eb, r) rp) s'> &&&\n    <bdd_relator rp s> xorci tc ec s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_xor tb eb, r) rp) s'>", "using assms"], ["proof (prove)\nusing this:\n  node_relator (tb, tc) rp\n  node_relator (eb, ec) rp\n\ngoal (1 subgoal):\n 1. (<bdd_relator rp s> andci tc ec s\n     <\\<lambda>(r, s'). bdd_relator (insert (bf_and tb eb, r) rp) s'> &&&\n     <bdd_relator rp s> orci tc ec s\n     <\\<lambda>(r, s'). bdd_relator (insert (bf_or tb eb, r) rp) s'>) &&&\n    <bdd_relator rp s> biimpci tc ec s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_biimp tb eb, r) rp) s'> &&&\n    <bdd_relator rp s> xorci tc ec s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_xor tb eb, r) rp) s'>", "by (sep_auto simp: andci_def orci_def biimpci_def xorci_def)+"], ["", "lemma cirules2[sep_heap_rules]:\n  assumes \"node_relator (tb, tc) rp\" \"node_relator (eb, ec) rp\"\n  shows\n    \"<bdd_relator rp s> nandci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_nand tb eb,r) rp) s'>\"\n    \"<bdd_relator rp s> norci tc ec s <\\<lambda>(r,s'). bdd_relator (insert (bf_nor tb eb,r) rp) s'>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <bdd_relator rp s> nandci tc ec s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_nand tb eb, r) rp) s'> &&&\n    <bdd_relator rp s> norci tc ec s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_nor tb eb, r) rp) s'>", "using assms"], ["proof (prove)\nusing this:\n  node_relator (tb, tc) rp\n  node_relator (eb, ec) rp\n\ngoal (1 subgoal):\n 1. <bdd_relator rp s> nandci tc ec s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_nand tb eb, r) rp) s'> &&&\n    <bdd_relator rp s> norci tc ec s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_nor tb eb, r) rp) s'>", "by(sep_auto simp: nandci_def norci_def)+"], ["", "lemma litci_rule[sep_heap_rules]:\n  \"<bdd_relator rp s> litci v s <\\<lambda>(r,s'). bdd_relator (insert (bf_lit v,r) rp) s'>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <bdd_relator rp s> litci v s\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_lit v, r) rp) s'>", "apply(unfold litci_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <bdd_relator rp s>\n    tci s \\<bind>\n    (\\<lambda>(t, bdd). fci bdd \\<bind> (\\<lambda>(f, bdd). ifci v t f bdd))\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_lit v, r) rp) s'>", "apply(subgoal_tac \\<open>\\<And>t ab bb. \\<comment> \\<open>introducing some vars \\dots\\<close>\n         <bdd_relator (insert (bf_False, ab) (insert (bf_True, t) rp)) bb * true> \n           ifci v t ab bb\n         <\\<lambda>r. case r of (r, x) \\<Rightarrow> bdd_relator (insert (bf_lit v, r) rp) x>\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>t ab bb.\n        <bdd_relator (insert (bf_False, ab) (insert (bf_True, t) rp)) bb *\n         true>\n        ifci v t ab bb\n        <\\<lambda>r.\n            case r of\n            (r, x) \\<Rightarrow>\n              bdd_relator (insert (bf_lit v, r) rp) x>) \\<Longrightarrow>\n    <bdd_relator rp s>\n    tci s \\<bind>\n    (\\<lambda>(t, bdd). fci bdd \\<bind> (\\<lambda>(f, bdd). ifci v t f bdd))\n    <\\<lambda>(r, s'). bdd_relator (insert (bf_lit v, r) rp) s'>\n 2. \\<And>t ab bb.\n       <bdd_relator (insert (bf_False, ab) (insert (bf_True, t) rp)) bb *\n        true>\n       ifci v t ab bb\n       <\\<lambda>r.\n           case r of\n           (r, x) \\<Rightarrow> bdd_relator (insert (bf_lit v, r) rp) x>", "apply(sep_auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t ab bb.\n       <bdd_relator (insert (bf_False, ab) (insert (bf_True, t) rp)) bb *\n        true>\n       ifci v t ab bb\n       <\\<lambda>r.\n           case r of\n           (r, x) \\<Rightarrow> bdd_relator (insert (bf_lit v, r) rp) x>", "apply(rename_tac tc fc sc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc.\n       <bdd_relator (insert (bf_False, fc) (insert (bf_True, tc) rp)) sc *\n        true>\n       ifci v tc fc sc\n       <\\<lambda>r.\n           case r of\n           (r, x) \\<Rightarrow> bdd_relator (insert (bf_lit v, r) rp) x>", "apply(unfold bdd_relator_def[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc.\n       <(\\<exists>\\<^sub>Acs.\n            is_bdd_impl cs sc *\n            \\<up>\n             (insert (bf_False, fc) (insert (bf_True, tc) rp)\n              \\<subseteq> bddmi_rel cs \\<and>\n              bdd_sane cs) *\n            true) *\n        true>\n       ifci v tc fc sc\n       <\\<lambda>r.\n           case r of\n           (r, x) \\<Rightarrow>\n             \\<exists>\\<^sub>Acs.\n                is_bdd_impl cs x *\n                \\<up>\n                 (insert (bf_lit v, r) rp \\<subseteq> bddmi_rel cs \\<and>\n                  bdd_sane cs) *\n                true>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc.\n       <\\<exists>\\<^sub>Acs.\n           is_bdd_impl cs sc * true *\n           \\<up>\n            ((bf_False, fc) \\<in> bddmi_rel cs \\<and>\n             (bf_True, tc) \\<in> bddmi_rel cs \\<and>\n             rp \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs)>\n       ifci v tc fc sc\n       <\\<lambda>(r, x).\n           \\<exists>\\<^sub>Acs.\n              is_bdd_impl cs x *\n              \\<up>\n               ((bf_lit v, r) \\<in> bddmi_rel cs \\<and>\n                rp \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n              true>", "apply(intro norm_pre_ex_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc cs.\n       <is_bdd_impl cs sc * true *\n        \\<up>\n         ((bf_False, fc) \\<in> bddmi_rel cs \\<and>\n          (bf_True, tc) \\<in> bddmi_rel cs \\<and>\n          rp \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs)>\n       ifci v tc fc sc\n       <\\<lambda>(r, x).\n           \\<exists>\\<^sub>Acs.\n              is_bdd_impl cs x *\n              \\<up>\n               ((bf_lit v, r) \\<in> bddmi_rel cs \\<and>\n                rp \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n              true>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc cs.\n       \\<lbrakk>(bf_False, fc) \\<in> bddmi_rel cs;\n        (bf_True, tc) \\<in> bddmi_rel cs; rp \\<subseteq> bddmi_rel cs;\n        bdd_sane cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v tc fc sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((bf_lit v, r) \\<in> bddmi_rel cs \\<and>\n                                  rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(unfold bddmi_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc cs.\n       \\<lbrakk>(bf_False, fc)\n                \\<in> {uu_.\n                       \\<exists>a b c.\n                          uu_ = (a, c) \\<and>\n                          (a, b) \\<in> bf_ifex_rel \\<and>\n                          (c, b) \\<in> Rmi cs};\n        (bf_True, tc)\n        \\<in> {uu_.\n               \\<exists>a b c.\n                  uu_ = (a, c) \\<and>\n                  (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs};\n        rp \\<subseteq> {uu_.\n                        \\<exists>a b c.\n                           uu_ = (a, c) \\<and>\n                           (a, b) \\<in> bf_ifex_rel \\<and>\n                           (c, b) \\<in> Rmi cs};\n        bdd_sane cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v tc fc sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((bf_lit v, r)\n                                  \\<in> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(clarsimp simp only: bf_ifex_rel_consts_ensured)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs;\n        (ca, Trueif) \\<in> Rmi cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v ca c sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((bf_lit v, r)\n                                  \\<in> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(frule mi.IFimpl_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs;\n        (ca, Trueif) \\<in> Rmi cs\\<rbrakk>\n       \\<Longrightarrow> (?ni1.37 tc fc sc cs a aa b ba c ca,\n                          ?n1.37 tc fc sc cs a aa b ba c ca)\n                         \\<in> Rmi cs\n 2. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs;\n        (ca, Trueif) \\<in> Rmi cs\\<rbrakk>\n       \\<Longrightarrow> (?ni2.37 tc fc sc cs a aa b ba c ca,\n                          ?n2.37 tc fc sc cs a aa b ba c ca)\n                         \\<in> Rmi cs\n 3. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs; (ca, Trueif) \\<in> Rmi cs;\n        ospec\n         (ifmi' (?v37 tc fc sc cs a aa b ba c ca)\n           (?ni1.37 tc fc sc cs a aa b ba c ca)\n           (?ni2.37 tc fc sc cs a aa b ba c ca) cs)\n         (\\<lambda>(ni, s').\n             (ni,\n              IFC (?v37 tc fc sc cs a aa b ba c ca)\n               (?n1.37 tc fc sc cs a aa b ba c ca)\n               (?n2.37 tc fc sc cs a aa b ba c ca))\n             \\<in> Rmi s' \\<and>\n             bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v ca c sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((bf_lit v, r)\n                                  \\<in> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(rename_tac tc fc sc sm a aa b ba fm tm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>tc fc sc sm a aa b ba fm tm.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi sm};\n        bdd_sane sm; (fm, Falseif) \\<in> Rmi sm;\n        (tm, Trueif) \\<in> Rmi sm\\<rbrakk>\n       \\<Longrightarrow> (?ni1.37 tc fc sc sm a aa b ba fm tm,\n                          ?n1.37 tc fc sc sm a aa b ba fm tm)\n                         \\<in> Rmi sm\n 2. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs;\n        (ca, Trueif) \\<in> Rmi cs\\<rbrakk>\n       \\<Longrightarrow> (?ni2.37 tc fc sc cs a aa b ba c ca,\n                          ?n2.37 tc fc sc cs a aa b ba c ca)\n                         \\<in> Rmi cs\n 3. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs; (ca, Trueif) \\<in> Rmi cs;\n        ospec\n         (ifmi' (?v37 tc fc sc cs a aa b ba c ca)\n           (?ni1.37 tc fc sc cs a aa b ba c ca)\n           (?ni2.37 tc fc sc cs a aa b ba c ca) cs)\n         (\\<lambda>(ni, s').\n             (ni,\n              IFC (?v37 tc fc sc cs a aa b ba c ca)\n               (?n1.37 tc fc sc cs a aa b ba c ca)\n               (?n2.37 tc fc sc cs a aa b ba c ca))\n             \\<in> Rmi s' \\<and>\n             bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v ca c sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((bf_lit v, r)\n                                  \\<in> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(thin_tac \"(fm, Falseif) \\<in> Rmi sm\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>tc fc sc sm a aa b ba fm tm.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi sm};\n        bdd_sane sm; (tm, Trueif) \\<in> Rmi sm\\<rbrakk>\n       \\<Longrightarrow> (?ni1.37 tc fc sc sm a aa b ba fm tm,\n                          ?n1.37 tc fc sc sm a aa b ba fm tm)\n                         \\<in> Rmi sm\n 2. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs;\n        (ca, Trueif) \\<in> Rmi cs\\<rbrakk>\n       \\<Longrightarrow> (?ni2.37 tc fc sc cs a aa b ba c ca,\n                          ?n2.37 tc fc sc cs a aa b ba c ca)\n                         \\<in> Rmi cs\n 3. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs; (ca, Trueif) \\<in> Rmi cs;\n        ospec\n         (ifmi' (?v37 tc fc sc cs a aa b ba c ca)\n           (?ni1.37 tc fc sc cs a aa b ba c ca)\n           (?ni2.37 tc fc sc cs a aa b ba c ca) cs)\n         (\\<lambda>(ni, s').\n             (ni,\n              IFC (?v37 tc fc sc cs a aa b ba c ca)\n               (?n1.37 tc fc sc cs a aa b ba c ca)\n               (?n2.37 tc fc sc cs a aa b ba c ca))\n             \\<in> Rmi s' \\<and>\n             bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v ca c sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((bf_lit v, r)\n                                  \\<in> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs;\n        (ca, Trueif) \\<in> Rmi cs\\<rbrakk>\n       \\<Longrightarrow> (?ni2.37 tc fc sc cs a aa b ba c ca,\n                          ?n2.37 tc fc sc cs a aa b ba c ca)\n                         \\<in> Rmi cs\n 2. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs; (ca, Trueif) \\<in> Rmi cs;\n        ospec\n         (ifmi' (?v37 tc fc sc cs a aa b ba c ca) ca\n           (?ni2.37 tc fc sc cs a aa b ba c ca) cs)\n         (\\<lambda>(ni, s').\n             (ni,\n              IFC (?v37 tc fc sc cs a aa b ba c ca) Trueif\n               (?n2.37 tc fc sc cs a aa b ba c ca))\n             \\<in> Rmi s' \\<and>\n             bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v ca c sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((bf_lit v, r)\n                                  \\<in> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "(* hack: instantiate the first premise of mi.IFimpl_rule with the second assumption that matches. The other way around would be fine, too. *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs;\n        (ca, Trueif) \\<in> Rmi cs\\<rbrakk>\n       \\<Longrightarrow> (?ni2.37 tc fc sc cs a aa b ba c ca,\n                          ?n2.37 tc fc sc cs a aa b ba c ca)\n                         \\<in> Rmi cs\n 2. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs; (ca, Trueif) \\<in> Rmi cs;\n        ospec\n         (ifmi' (?v37 tc fc sc cs a aa b ba c ca) ca\n           (?ni2.37 tc fc sc cs a aa b ba c ca) cs)\n         (\\<lambda>(ni, s').\n             (ni,\n              IFC (?v37 tc fc sc cs a aa b ba c ca) Trueif\n               (?n2.37 tc fc sc cs a aa b ba c ca))\n             \\<in> Rmi s' \\<and>\n             bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v ca c sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((bf_lit v, r)\n                                  \\<in> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc cs a aa b ba c ca.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (c, Falseif) \\<in> Rmi cs; (ca, Trueif) \\<in> Rmi cs;\n        ospec (ifmi' (?v37 tc fc sc cs a aa b ba c ca) ca c cs)\n         (\\<lambda>(ni, s').\n             (ni, IFC (?v37 tc fc sc cs a aa b ba c ca) Trueif Falseif)\n             \\<in> Rmi s' \\<and>\n             bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v ca c sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((bf_lit v, r)\n                                  \\<in> {uu_.\n   \\<exists>a b c.\n      uu_ = (a, c) \\<and>\n      (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc cs a aa b ba.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs;\n        ospec (ifmi' (?v37 tc fc sc cs a aa b ba 0 (Suc 0)) (Suc 0) 0 cs)\n         (\\<lambda>(ni, s').\n             (ni, IFC (?v37 tc fc sc cs a aa b ba 0 (Suc 0)) Trueif Falseif)\n             \\<in> Rmi s' \\<and>\n             bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v (Suc 0) 0 sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((\\<exists>b.\n(bf_lit v, b) \\<in> bf_ifex_rel \\<and> (r, b) \\<in> Rmi cs) \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(drule ospecD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc cs a aa b ba.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs;\n        \\<exists>y.\n           ifmi' (?v37 tc fc sc cs a aa b ba 0 (Suc 0)) (Suc 0) 0 cs =\n           Some y \\<and>\n           (case y of\n            (ni, s') \\<Rightarrow>\n              (ni,\n               IFC (?v37 tc fc sc cs a aa b ba 0 (Suc 0)) Trueif Falseif)\n              \\<in> Rmi s' \\<and>\n              bdd_sane s' \\<and> mi.les cs s')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v (Suc 0) 0 sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((\\<exists>b.\n(bf_lit v, b) \\<in> bf_ifex_rel \\<and> (r, b) \\<in> Rmi cs) \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tc fc sc cs a aa b ba ab bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs;\n        ifmi' (?v37 tc fc sc cs a aa b ba 0 (Suc 0)) (Suc 0) 0 cs =\n        Some (ab, bb);\n        (ab, IFC (?v37 tc fc sc cs a aa b ba 0 (Suc 0)) Trueif Falseif)\n        \\<in> Rmi bb;\n        bdd_sane bb; mi.les cs bb\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs sc * true> ifci v (Suc 0) 0 sc\n                         <\\<lambda>(r, x).\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs x *\n                                \\<up>\n                                 ((\\<exists>b.\n(bf_lit v, b) \\<in> bf_ifex_rel \\<and> (r, b) \\<in> Rmi cs) \\<and>\n                                  rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs) *\n                                true>", "apply(sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs ab bb b a ba aa bc.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; ifmi' v (Suc 0) 0 cs = Some (ab, bb);\n        (ab, IFC v Trueif Falseif) \\<in> Rmi bb; bdd_sane bb; mi.les cs bb;\n        (a, ba) \\<in> rp;\n        (aa, bc) \\<Turnstile> is_bdd_impl bb b * true\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            (a, b) \\<in> bf_ifex_rel \\<and>\n                            (ba, b) \\<in> Rmi bb", "apply(force simp add: mi.les_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tautci_rule[sep_heap_rules]:\n  shows \"node_relator (tb, tc) rp \\<Longrightarrow> <bdd_relator rp s> tautci tc s <\\<lambda>r. bdd_relator rp s * \\<up>(r \\<longleftrightarrow> tb = bf_True)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. node_relator (tb, tc) rp \\<Longrightarrow>\n    <bdd_relator rp s> tautci tc s\n    <\\<lambda>r. bdd_relator rp s * \\<up> (r = (tb = bf_True))>", "apply(unfold node_relator_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tb, tc) \\<in> rp \\<Longrightarrow>\n    <bdd_relator rp s> tautci tc s\n    <\\<lambda>r. bdd_relator rp s * \\<up> (r = (tb = bf_True))>", "apply(unfold tautci_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tb, tc) \\<in> rp \\<Longrightarrow>\n    <bdd_relator rp s> destrci tc s \\<bind> (\\<lambda>d. return (d = TD))\n    <\\<lambda>r. bdd_relator rp s * \\<up> (r = (tb = bf_True))>", "apply(unfold bdd_relator_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tb, tc) \\<in> rp \\<Longrightarrow>\n    <\\<exists>\\<^sub>Acs.\n        is_bdd_impl cs s *\n        \\<up> (rp \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n        true>\n    destrci tc s \\<bind> (\\<lambda>d. return (d = TD))\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Acs.\n            is_bdd_impl cs s *\n            \\<up> (rp \\<subseteq> bddmi_rel cs \\<and> bdd_sane cs) *\n            true) *\n        \\<up> (r = (tb = bf_True))>", "apply(intro norm_pre_ex_rule; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>(tb, tc) \\<in> rp; rp \\<subseteq> bddmi_rel cs;\n        bdd_sane cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true>\n                         destrci tc s \\<bind> (\\<lambda>d. return (d = TD))\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s * true *\n                                \\<up>\n                                 (rp \\<subseteq> bddmi_rel cs \\<and>\n                                  bdd_sane cs \\<and> r = (tb = bf_True))>", "apply(unfold bddmi_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>(tb, tc) \\<in> rp;\n        rp \\<subseteq> {uu_.\n                        \\<exists>a b c.\n                           uu_ = (a, c) \\<and>\n                           (a, b) \\<in> bf_ifex_rel \\<and>\n                           (c, b) \\<in> Rmi cs};\n        bdd_sane cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true>\n                         destrci tc s \\<bind> (\\<lambda>d. return (d = TD))\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s * true *\n                                \\<up>\n                                 (rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs \\<and> r = (tb = bf_True))>", "apply(drule (1) rev_subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs;\n        (tb, tc)\n        \\<in> {uu_.\n               \\<exists>a b c.\n                  uu_ = (a, c) \\<and>\n                  (a, b) \\<in> bf_ifex_rel \\<and>\n                  (c, b) \\<in> Rmi cs}\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true>\n                         destrci tc s \\<bind> (\\<lambda>d. return (d = TD))\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s * true *\n                                \\<up>\n                                 (rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs \\<and> r = (tb = bf_True))>", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (tb, b) \\<in> bf_ifex_rel;\n        (tc, b) \\<in> Rmi cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true>\n                         destrci tc s \\<bind> (\\<lambda>d. return (d = TD))\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s * true *\n                                \\<up>\n                                 (rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs \\<and> r = (tb = bf_True))>", "apply(rename_tac sm ti)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sm ti.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi sm};\n        bdd_sane sm; (tb, ti) \\<in> bf_ifex_rel;\n        (tc, ti) \\<in> Rmi sm\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl sm s * true>\n                         destrci tc s \\<bind> (\\<lambda>d. return (d = TD))\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s * true *\n                                \\<up>\n                                 (rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs \\<and> r = (tb = bf_True))>", "apply(frule (1) mi.DESTRimpl_rule; drule ospecD2; clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sm ti y.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi sm};\n        bdd_sane sm; (tb, ti) \\<in> bf_ifex_rel; (tc, ti) \\<in> Rmi sm;\n        destrmi' tc sm = Some y;\n        case ti of Trueif \\<Rightarrow> y = TD\n        | Falseif \\<Rightarrow> y = FD\n        | IF v t e \\<Rightarrow>\n            \\<exists>tn en.\n               y = IFD v tn en \\<and>\n               (tn, t) \\<in> Rmi sm \\<and> (en, e) \\<in> Rmi sm\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl sm s * true>\n                         destrci tc s \\<bind> (\\<lambda>d. return (d = TD))\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Acs.\n                                is_bdd_impl cs s * true *\n                                \\<up>\n                                 (rp \\<subseteq> {uu_.\n            \\<exists>a b c.\n               uu_ = (a, c) \\<and>\n               (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs} \\<and>\n                                  bdd_sane cs \\<and> r = (tb = bf_True))>", "apply(sep_auto split: ifex.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma emptyci_rule[sep_heap_rules]:\n  shows \"<emp> emptyci <\\<lambda>r. bdd_relator {} r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> emptyci <bdd_relator {}>", "by(sep_auto simp: bdd_relator_def)"], ["", "(* TODO: make sure that emptyci_rule and firends don't appear duplicate, once concrete-impl style, once level-collapsed. *)"], ["", "lemmas [simp] = bf_ite_def"], ["", "text\\<open>Efficient comparison of two nodes.\\<close>"], ["", "definition \"eqci a b \\<equiv> return (a = b)\""], ["", "(* wrapping definition so sep_auto does not run into nowhere *)"], ["", "lemma iteeq_rule[sep_heap_rules]: \"\n\\<lbrakk>node_relator (xb, xc)  rp; node_relator (yb, yc) rp\\<rbrakk> \\<Longrightarrow>\n<bdd_relator rp s>\n  eqci xc yc\n<\\<lambda>r. \\<up>(r \\<longleftrightarrow> xb = yb)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>node_relator (xb, xc) rp; node_relator (yb, yc) rp\\<rbrakk>\n    \\<Longrightarrow> <bdd_relator rp\n                        s> eqci xc\n                            yc <\\<lambda>r. \\<up> (r = (xb = yb))>\\<^sub>t", "apply(unfold bdd_relator_def node_relator_def eqci_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xb, xc) \\<in> rp; (yb, yc) \\<in> rp\\<rbrakk>\n    \\<Longrightarrow> <\\<exists>\\<^sub>Acs.\n                          is_bdd_impl cs s *\n                          \\<up>\n                           (rp \\<subseteq> bddmi_rel cs \\<and>\n                            bdd_sane cs) *\n                          true> return\n                                 (xc =\n                                  yc) <\\<lambda>r.\n    \\<up> (r = (xb = yb))>\\<^sub>t", "apply(intro norm_pre_ex_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>(xb, xc) \\<in> rp; (yb, yc) \\<in> rp\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s *\n                          \\<up>\n                           (rp \\<subseteq> bddmi_rel cs \\<and>\n                            bdd_sane cs) *\n                          true> return\n                                 (xc =\n                                  yc) <\\<lambda>r.\n    \\<up> (r = (xb = yb))>\\<^sub>t", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>(xb, xc) \\<in> rp; (yb, yc) \\<in> rp;\n        rp \\<subseteq> bddmi_rel cs; bdd_sane cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> return (xc = yc)\n                         <\\<lambda>r. true * \\<up> (r = (xb = yb))>", "apply(unfold bddmi_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>(xb, xc) \\<in> rp; (yb, yc) \\<in> rp;\n        rp \\<subseteq> {uu_.\n                        \\<exists>a b c.\n                           uu_ = (a, c) \\<and>\n                           (a, b) \\<in> bf_ifex_rel \\<and>\n                           (c, b) \\<in> Rmi cs};\n        bdd_sane cs\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> return (xc = yc)\n                         <\\<lambda>r. true * \\<up> (r = (xb = yb))>", "apply(drule (1) rev_subsetD)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs;\n        (xb, xc)\n        \\<in> {uu_.\n               \\<exists>a b c.\n                  uu_ = (a, c) \\<and>\n                  (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs};\n        (yb, yc)\n        \\<in> {uu_.\n               \\<exists>a b c.\n                  uu_ = (a, c) \\<and>\n                  (a, b) \\<in> bf_ifex_rel \\<and>\n                  (c, b) \\<in> Rmi cs}\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl cs s * true> return (xc = yc)\n                         <\\<lambda>r. true * \\<up> (r = (xb = yb))>", "apply(rule return_cons_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs;\n        (xb, xc)\n        \\<in> {uu_.\n               \\<exists>a b c.\n                  uu_ = (a, c) \\<and>\n                  (a, b) \\<in> bf_ifex_rel \\<and> (c, b) \\<in> Rmi cs};\n        (yb, yc)\n        \\<in> {uu_.\n               \\<exists>a b c.\n                  uu_ = (a, c) \\<and>\n                  (a, b) \\<in> bf_ifex_rel \\<and>\n                  (c, b) \\<in> Rmi cs}\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl cs s * true \\<Longrightarrow>\\<^sub>A\n                         true * \\<up> ((xc = yc) = (xb = yb))", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (xb, b) \\<in> bf_ifex_rel; (xc, b) \\<in> Rmi cs;\n        (yb, ba) \\<in> bf_ifex_rel; (yc, ba) \\<in> Rmi cs;\n        (a, bb) \\<Turnstile> is_bdd_impl cs s * true\\<rbrakk>\n       \\<Longrightarrow> (xc = yc) = (xb = yb)", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (xb, b) \\<in> bf_ifex_rel; (xc, b) \\<in> Rmi cs;\n        (yb, ba) \\<in> bf_ifex_rel; (yc, ba) \\<in> Rmi cs;\n        (a, bb) \\<Turnstile> is_bdd_impl cs s * true; xc = yc\\<rbrakk>\n       \\<Longrightarrow> xb = yb\n 2. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (xb, b) \\<in> bf_ifex_rel; (xc, b) \\<in> Rmi cs;\n        (yb, ba) \\<in> bf_ifex_rel; (yc, ba) \\<in> Rmi cs;\n        (a, bb) \\<Turnstile> is_bdd_impl cs s * true; xb = yb\\<rbrakk>\n       \\<Longrightarrow> xc = yc", "using bf_ifex_eq mi.cmp_rule_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?af, ?at) \\<in> bf_ifex_rel;\n   (?bf, ?bt) \\<in> bf_ifex_rel\\<rbrakk>\n  \\<Longrightarrow> (?af = ?bf) = (?at = ?bt)\n  \\<lbrakk>bdd_sane ?s; (?ni, ?i) \\<in> Rmi ?s;\n   (?ni', ?i') \\<in> Rmi ?s\\<rbrakk>\n  \\<Longrightarrow> (?ni = ?ni') = (?i = ?i')\n\ngoal (2 subgoals):\n 1. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (xb, b) \\<in> bf_ifex_rel; (xc, b) \\<in> Rmi cs;\n        (yb, ba) \\<in> bf_ifex_rel; (yc, ba) \\<in> Rmi cs;\n        (a, bb) \\<Turnstile> is_bdd_impl cs s * true; xc = yc\\<rbrakk>\n       \\<Longrightarrow> xb = yb\n 2. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (xb, b) \\<in> bf_ifex_rel; (xc, b) \\<in> Rmi cs;\n        (yb, ba) \\<in> bf_ifex_rel; (yc, ba) \\<in> Rmi cs;\n        (a, bb) \\<Turnstile> is_bdd_impl cs s * true; xb = yb\\<rbrakk>\n       \\<Longrightarrow> xc = yc", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (xb, b) \\<in> bf_ifex_rel; (xc, b) \\<in> Rmi cs;\n        (yb, ba) \\<in> bf_ifex_rel; (yc, ba) \\<in> Rmi cs;\n        (a, bb) \\<Turnstile> is_bdd_impl cs s * true; xb = yb\\<rbrakk>\n       \\<Longrightarrow> xc = yc", "using bf_ifex_eq mi.cmp_rule_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?af, ?at) \\<in> bf_ifex_rel;\n   (?bf, ?bt) \\<in> bf_ifex_rel\\<rbrakk>\n  \\<Longrightarrow> (?af = ?bf) = (?at = ?bt)\n  \\<lbrakk>bdd_sane ?s; (?ni, ?i) \\<in> Rmi ?s;\n   (?ni', ?i') \\<in> Rmi ?s\\<rbrakk>\n  \\<Longrightarrow> (?ni = ?ni') = (?i = ?i')\n\ngoal (1 subgoal):\n 1. \\<And>cs b ba a bb.\n       \\<lbrakk>rp \\<subseteq> {uu_.\n                                \\<exists>a b c.\n                                   uu_ = (a, c) \\<and>\n                                   (a, b) \\<in> bf_ifex_rel \\<and>\n                                   (c, b) \\<in> Rmi cs};\n        bdd_sane cs; (xb, b) \\<in> bf_ifex_rel; (xc, b) \\<in> Rmi cs;\n        (yb, ba) \\<in> bf_ifex_rel; (yc, ba) \\<in> Rmi cs;\n        (a, bb) \\<Turnstile> is_bdd_impl cs s * true; xb = yb\\<rbrakk>\n       \\<Longrightarrow> xc = yc", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}