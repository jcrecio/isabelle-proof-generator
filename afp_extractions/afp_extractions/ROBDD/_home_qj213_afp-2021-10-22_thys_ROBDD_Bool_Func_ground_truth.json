{"file_name": "/home/qj213/afp-2021-10-22/thys/ROBDD/Bool_Func.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ROBDD", "problem_names": ["lemma \"(bf_and a b) as \\<longleftrightarrow> a as \\<and> b as\"", "lemma bf_not_alt: \"bf_not a as \\<longleftrightarrow> \\<not>a as\"", "lemma bf_if_alt: \"bf_if v t e = (\\<lambda>l. if l v then t l else e l)\"", "lemma bf_biimp_alt: \"bf_biimp a b = (\\<lambda>l. a l \\<longleftrightarrow> b l)\"", "lemma bf_xor_alt: \"bf_xor a b = (bf_ite a (bf_not b) b)\"", "lemma bf_imp_alt: \"bf_imp a b = bf_or (bf_not a) b\"", "lemma [dest!,elim!]: \"bf_False = bf_True \\<Longrightarrow> False\" \"bf_True = bf_False \\<Longrightarrow> False\"", "lemmas [simp] = bf_and_def bf_or_def bf_nand_def bf_biimp_def bf_xor_alt bf_nor_def bf_not_def", "lemma \"var \\<notin> bf_vars (bf_restrict var val ex)\"", "lemma brace90shannon: \"bf_ite F G H ass =\n  bf_ite (\\<lambda>l. l i) \n         (bf_ite (bf_restrict i True F) (bf_restrict i True G) (bf_restrict i True H))\n         (bf_ite (bf_restrict i False F) (bf_restrict i False G) (bf_restrict i False H)) ass\""], "translations": [["", "lemma \"(bf_and a b) as \\<longleftrightarrow> a as \\<and> b as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bf_and a b as = (a as \\<and> b as)", "unfolding bf_and_def  bf_ite_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a as then b as else False) = (a as \\<and> b as)", "by meson"], ["", "definition \"bf_not b \\<equiv> bf_ite b bf_False bf_True\""], ["", "lemma bf_not_alt: \"bf_not a as \\<longleftrightarrow> \\<not>a as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bf_not a as = (\\<not> a as)", "unfolding bf_not_def bf_ite_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a as then False else True) = (\\<not> a as)", "by meson"], ["", "text\\<open>For convenience, we want a few functions more:\\<close>"], ["", "definition \"bf_or a b \\<equiv> bf_ite a bf_True b\""], ["", "definition \"bf_lit v \\<equiv> (\\<lambda>l. l v)\""], ["", "definition \"bf_if v t e \\<equiv> bf_ite (bf_lit v) t e\""], ["", "lemma bf_if_alt: \"bf_if v t e = (\\<lambda>l. if l v then t l else e l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bf_if v t e = (\\<lambda>l. if l v then t l else e l)", "unfolding bf_if_def bf_ite_def bf_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l. if l v then t l else e l) =\n    (\\<lambda>l. if l v then t l else e l)", ".."], ["", "definition \"bf_nand a b = bf_not (bf_and a b)\""], ["", "definition \"bf_nor a b = bf_not (bf_or a b)\""], ["", "definition \"bf_biimp a b = (bf_ite a b (bf_not b))\""], ["", "lemma bf_biimp_alt: \"bf_biimp a b = (\\<lambda>l. a l \\<longleftrightarrow> b l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bf_biimp a b = (\\<lambda>l. a l = b l)", "unfolding bf_biimp_def bf_not_def bf_ite_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l. if a l then b l else if b l then False else True) =\n    (\\<lambda>l. a l = b l)", "by(simp add: fun_eq_iff)"], ["", "definition \"bf_xor a b = bf_not (bf_biimp a b)\""], ["", "lemma bf_xor_alt: \"bf_xor a b = (bf_ite a (bf_not b) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bf_xor a b = bf_ite a (bf_not b) b", "(* two application version *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bf_xor a b = bf_ite a (bf_not b) b", "unfolding bf_xor_def bf_biimp_def bf_not_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bf_ite (bf_ite a b (bf_ite b bf_False bf_True)) bf_False bf_True =\n    bf_ite a (bf_ite b bf_False bf_True) b", "unfolding bf_ite_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l.\n        if if a l then b l else if b l then False else True then False\n        else True) =\n    (\\<lambda>l. if a l then if b l then False else True else b l)", "by simp"], ["", "text\\<open>All of these are implemented and had their implementation verified.\\<close>"], ["", "definition \"bf_imp a b = bf_ite a b bf_True\""], ["", "lemma bf_imp_alt: \"bf_imp a b = bf_or (bf_not a) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bf_imp a b = bf_or (bf_not a) b", "unfolding bf_or_def bf_not_def bf_imp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bf_ite a b bf_True = bf_ite (bf_ite a bf_False bf_True) bf_True b", "unfolding bf_ite_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l. if a l then b l else True) =\n    (\\<lambda>l. if if a l then False else True then True else b l)", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (if a x then b x else True) =\n       (if if a x then False else True then True else b x)", "by simp"], ["", "lemma [dest!,elim!]: \"bf_False = bf_True \\<Longrightarrow> False\" \"bf_True = bf_False \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bf_False = bf_True \\<Longrightarrow> False) &&&\n    (bf_True = bf_False \\<Longrightarrow> False)", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. False = True \\<Longrightarrow> False) &&&\n    (\\<forall>x. True = False \\<Longrightarrow> False)", "by simp_all"], ["", "(* Occurs here and there as goal for sep_auto *)"], ["", "lemmas [simp] = bf_and_def bf_or_def bf_nand_def bf_biimp_def bf_xor_alt bf_nor_def bf_not_def"], ["", "subsection\\<open>Shannon decomposition\\<close>"], ["", "text\\<open>\n  A restriction of a boolean function on a variable is creating the boolean function that evaluates as if that variable was set to a fixed value:\n\\<close>"], ["", "definition \"bf_restrict (i::'a) (val::bool) (f::'a boolfunc) \\<equiv> (\\<lambda>v. f (v(i:=val)))\""], ["", "text \\<open>\n  Restrictions are useful, because they remove variables from the set of significant variables:\n\\<close>"], ["", "definition \"bf_vars bf = {v. \\<exists>as. bf_restrict v True bf as \\<noteq> bf_restrict v False bf as}\""], ["", "lemma \"var \\<notin> bf_vars (bf_restrict var val ex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var \\<notin> bf_vars (bf_restrict var val ex)", "unfolding bf_vars_def bf_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. var\n    \\<notin> {v. \\<exists>as.\n                    ex (as(v := True, var := val)) \\<noteq>\n                    ex (as(v := False, var := val))}", "by(simp)"], ["", "text\\<open>\n  We can decompose calculating if-then-else into computing if-then-else of two triples of functions with one variable restricted to true / false.\n  Given that the functions have finite arity, we can use this to construct a recursive definition.\n\\<close>"], ["", "lemma brace90shannon: \"bf_ite F G H ass =\n  bf_ite (\\<lambda>l. l i) \n         (bf_ite (bf_restrict i True F) (bf_restrict i True G) (bf_restrict i True H))\n         (bf_ite (bf_restrict i False F) (bf_restrict i False G) (bf_restrict i False H)) ass\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bf_ite F G H ass =\n    bf_ite (\\<lambda>l. l i)\n     (bf_ite (bf_restrict i True F) (bf_restrict i True G)\n       (bf_restrict i True H))\n     (bf_ite (bf_restrict i False F) (bf_restrict i False G)\n       (bf_restrict i False H))\n     ass", "unfolding bf_ite_def bf_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if F ass then G ass else H ass) =\n    (if ass i\n     then if F (ass(i := True)) then G (ass(i := True))\n          else H (ass(i := True))\n     else if F (ass(i := False)) then G (ass(i := False))\n          else H (ass(i := False)))", "by (auto simp add: fun_upd_idem)"], ["", "end"]]}