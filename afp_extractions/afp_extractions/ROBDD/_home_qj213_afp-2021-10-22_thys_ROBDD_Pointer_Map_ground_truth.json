{"file_name": "/home/qj213/afp-2021-10-22/thys/ROBDD/Pointer_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ROBDD", "problem_names": ["lemma pointermap_empty_sane[simp, intro!]: \"pointermap_sane empty_pointermap\"", "lemma pointermap_sane_appendD: \"pointermap_sane s \\<Longrightarrow> m \\<notin> set (entries s) \\<Longrightarrow> pointermap_sane (pointermap_insert m s)\"", "lemma luentries_noneD: \"getentry s a = None \\<Longrightarrow> pointermap_sane s \\<Longrightarrow> a \\<notin> set (entries s)\"", "lemma pm_pth_append: \"pointermap_p_valid p m \\<Longrightarrow> pm_pth (pointermap_insert a m) p = pm_pth m p\"", "lemma pointermap_insert_in: \"u = (pointermap_insert a m) \\<Longrightarrow> pm_pth u (the (getentry u a)) = a\"", "lemma pointermap_insert_p_validI: \"pointermap_p_valid p m \\<Longrightarrow> pointermap_p_valid p (pointermap_insert a m)\"", "lemma pth_eq_iff_index_eq: \"pointermap_sane m \\<Longrightarrow> pointermap_p_valid p1 m \\<Longrightarrow> pointermap_p_valid p2 m \\<Longrightarrow> (pm_pth m p1 = pm_pth m p2) \\<longleftrightarrow> (p1 = p2)\"", "lemma pointermap_p_valid_updateI: \"pointermap_sane m \\<Longrightarrow> getentry m a = None \\<Longrightarrow> u = pointermap_insert a m \\<Longrightarrow> p = the (getentry u a) \\<Longrightarrow> pointermap_p_valid p u\"", "lemma pointermap_get_validI: \"pointermap_sane m \\<Longrightarrow> getentry m a = Some p \\<Longrightarrow> pointermap_p_valid p m\"", "lemma pointermap_sane_getmkD: \n  assumes sn: \"pointermap_sane m\"\n  assumes res: \"pointermap_getmk a m = (p,u)\"\n  shows \"pointermap_sane u \\<and> pointermap_p_valid p u\"", "lemma pointermap_update_pthI: \n  assumes sn: \"pointermap_sane m\"\n  assumes res: \"pointermap_getmk a m = (p,u)\"\n  shows \"pm_pth u p = a\"", "lemma pointermap_p_valid_inv:\n  assumes \"pointermap_p_valid p m\"\n  assumes \"pointermap_getmk a m = (x,u)\"\n  shows \"pointermap_p_valid p u\"", "lemma pointermap_p_pth_inv:\n  assumes pv: \"pointermap_p_valid p m\"\n  assumes u: \"pointermap_getmk a m = (x,u)\"\n  shows \"pm_pth u p = pm_pth m p\"", "lemma pointermap_backward_valid:\n  assumes puv: \"pointermap_p_valid p u\"\n  assumes u: \"pointermap_getmk a m = (x,u)\"\n  assumes ne: \"x \\<noteq> p\"\n  shows \"pointermap_p_valid p m\""], "translations": [["", "lemma pointermap_empty_sane[simp, intro!]: \"pointermap_sane empty_pointermap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointermap_sane empty_pointermap", "unfolding empty_pointermap_def pointermap_sane_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (entries \\<lparr>entries = [], getentry = Map.empty\\<rparr>) \\<and>\n    (\\<forall>n\\<in>{..<length\n                         (entries\n                           \\<lparr>entries = [],\n                              getentry = Map.empty\\<rparr>)}.\n        getentry \\<lparr>entries = [], getentry = Map.empty\\<rparr>\n         (entries \\<lparr>entries = [], getentry = Map.empty\\<rparr> ! n) =\n        Some n) \\<and>\n    (\\<forall>p i.\n        getentry \\<lparr>entries = [], getentry = Map.empty\\<rparr> p =\n        Some i \\<longrightarrow>\n        entries \\<lparr>entries = [], getentry = Map.empty\\<rparr> ! i =\n        p \\<and>\n        i < length\n             (entries \\<lparr>entries = [], getentry = Map.empty\\<rparr>))", "by simp"], ["", "definition \"pointermap_insert a m \\<equiv> \\<lparr>entries = (entries m)@[a], getentry = (getentry m)(a \\<mapsto> length (entries m))\\<rparr>\""], ["", "definition \"pm_pth m p \\<equiv> entries m ! p\""], ["", "definition \"pointermap_p_valid p m \\<equiv> p < length (entries m)\""], ["", "definition \"pointermap_getmk a m \\<equiv> (case getentry m a of Some p \\<Rightarrow> (p,m) | None \\<Rightarrow> let u = pointermap_insert a m in (the (getentry u a), u))\""], ["", "lemma pointermap_sane_appendD: \"pointermap_sane s \\<Longrightarrow> m \\<notin> set (entries s) \\<Longrightarrow> pointermap_sane (pointermap_insert m s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pointermap_sane s; m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> pointermap_sane (pointermap_insert m s)", "unfolding pointermap_sane_def pointermap_insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr>) \\<and>\n                      (\\<forall>n\\<in>{..<length\n     (entries\n       \\<lparr>entries = entries s @ [m],\n          getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                          getentry\n                           \\<lparr>entries = entries s @ [m],\n                              getentry = getentry s(m \\<mapsto>\n                                length (entries s))\\<rparr>\n                           (entries\n                             \\<lparr>entries = entries s @ [m],\n                                getentry = getentry s(m \\<mapsto>\n                                  length (entries s))\\<rparr> !\n                            n) =\n                          Some n) \\<and>\n                      (\\<forall>p i.\n                          getentry\n                           \\<lparr>entries = entries s @ [m],\n                              getentry = getentry s(m \\<mapsto>\n                                length (entries s))\\<rparr>\n                           p =\n                          Some i \\<longrightarrow>\n                          entries\n                           \\<lparr>entries = entries s @ [m],\n                              getentry = getentry s(m \\<mapsto>\n                                length (entries s))\\<rparr> !\n                          i =\n                          p \\<and>\n                          i < length\n                               (entries\n                                 \\<lparr>entries = entries s @ [m],\n                                    getentry = getentry s(m \\<mapsto>\nlength (entries s))\\<rparr>))", "proof(intro conjI[rotated],goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{..<length\n    (entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          (entries\n                            \\<lparr>entries = entries s @ [m],\n                               getentry = getentry s(m \\<mapsto>\n                                 length (entries s))\\<rparr> !\n                           n) =\n                         Some n\n 3. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr>)", "case 3"], ["proof (state)\nthis:\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{..<length\n    (entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          (entries\n                            \\<lparr>entries = entries s @ [m],\n                               getentry = getentry s(m \\<mapsto>\n                                 length (entries s))\\<rparr> !\n                           n) =\n                         Some n\n 3. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr>)", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n\ngoal (1 subgoal):\n 1. distinct\n     (entries\n       \\<lparr>entries = entries s @ [m],\n          getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  distinct\n   (entries\n     \\<lparr>entries = entries s @ [m],\n        getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{..<length\n    (entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          (entries\n                            \\<lparr>entries = entries s @ [m],\n                               getentry = getentry s(m \\<mapsto>\n                                 length (entries s))\\<rparr> !\n                           n) =\n                         Some n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{..<length\n    (entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          (entries\n                            \\<lparr>entries = entries s @ [m],\n                               getentry = getentry s(m \\<mapsto>\n                                 length (entries s))\\<rparr> !\n                           n) =\n                         Some n", "case 2"], ["proof (state)\nthis:\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{..<length\n    (entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          (entries\n                            \\<lparr>entries = entries s @ [m],\n                               getentry = getentry s(m \\<mapsto>\n                                 length (entries s))\\<rparr> !\n                           n) =\n                         Some n", "{"], ["proof (state)\nthis:\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{..<length\n    (entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          (entries\n                            \\<lparr>entries = entries s @ [m],\n                               getentry = getentry s(m \\<mapsto>\n                                 length (entries s))\\<rparr> !\n                           n) =\n                         Some n", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{..<length\n    (entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          (entries\n                            \\<lparr>entries = entries s @ [m],\n                               getentry = getentry s(m \\<mapsto>\n                                 length (entries s))\\<rparr> !\n                           n) =\n                         Some n", "have \" \\<lbrakk>distinct (entries s) \\<and> (\\<forall>x. x \\<in> {..<length (entries s)} \\<longrightarrow> getentry s (entries s ! x) = Some x) \\<and> (\\<forall>p i. getentry s p = Some i \\<longrightarrow> entries s ! i = p \\<and> i < length (entries s)); m \\<notin> set (entries s);\n          n \\<in> {..<length (entries \\<lparr>entries = entries s @ [m], getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}; n < length (entries s)\\<rbrakk>\n         \\<Longrightarrow> getentry \\<lparr>entries = entries s @ [m], getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> (entries \\<lparr>entries = entries s @ [m], getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> ! n) = Some n\"\n         \"\\<lbrakk>distinct (entries s) \\<and> (\\<forall>x. x \\<in> {..<length (entries s)} \\<longrightarrow> getentry s (entries s ! x) = Some x) \\<and> (\\<forall>p i. getentry s p = Some i \\<longrightarrow> entries s ! i = p \\<and> i < length (entries s)); m \\<notin> set (entries s);\n          n \\<in> {..<length (entries \\<lparr>entries = entries s @ [m], getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}; \\<not> n < length (entries s)\\<rbrakk>\n         \\<Longrightarrow> getentry \\<lparr>entries = entries s @ [m], getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> (entries \\<lparr>entries = entries s @ [m], getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> ! n) = Some n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>distinct (entries s) \\<and>\n              (\\<forall>x.\n                  x \\<in> {..<length (entries s)} \\<longrightarrow>\n                  getentry s (entries s ! x) = Some x) \\<and>\n              (\\<forall>p i.\n                  getentry s p = Some i \\<longrightarrow>\n                  entries s ! i = p \\<and> i < length (entries s));\n      m \\<notin> set (entries s);\n      n \\<in> {..<length\n                   (entries\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>)};\n      n < length (entries s)\\<rbrakk>\n     \\<Longrightarrow> getentry\n                        \\<lparr>entries = entries s @ [m],\n                           getentry = getentry s(m \\<mapsto>\n                             length (entries s))\\<rparr>\n                        (entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         n) =\n                       Some n) &&&\n    (\\<lbrakk>distinct (entries s) \\<and>\n              (\\<forall>x.\n                  x \\<in> {..<length (entries s)} \\<longrightarrow>\n                  getentry s (entries s ! x) = Some x) \\<and>\n              (\\<forall>p i.\n                  getentry s p = Some i \\<longrightarrow>\n                  entries s ! i = p \\<and> i < length (entries s));\n      m \\<notin> set (entries s);\n      n \\<in> {..<length\n                   (entries\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>)};\n      \\<not> n < length (entries s)\\<rbrakk>\n     \\<Longrightarrow> getentry\n                        \\<lparr>entries = entries s @ [m],\n                           getentry = getentry s(m \\<mapsto>\n                             length (entries s))\\<rparr>\n                        (entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         n) =\n                       Some n)", "proof(goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "case 1"], ["proof (state)\nthis:\n  distinct (entries s) \\<and>\n  (\\<forall>x.\n      x \\<in> {..<length (entries s)} \\<longrightarrow>\n      getentry s (entries s ! x) = Some x) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n  n \\<in> {..<length\n               (entries\n                 \\<lparr>entries = entries s @ [m],\n                    getentry = getentry s(m \\<mapsto>\n                      length (entries s))\\<rparr>)}\n  n < length (entries s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "note goal1 = 1"], ["proof (state)\nthis:\n  distinct (entries s) \\<and>\n  (\\<forall>x.\n      x \\<in> {..<length (entries s)} \\<longrightarrow>\n      getentry s (entries s ! x) = Some x) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n  n \\<in> {..<length\n               (entries\n                 \\<lparr>entries = entries s @ [m],\n                    getentry = getentry s(m \\<mapsto>\n                      length (entries s))\\<rparr>)}\n  n < length (entries s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "from goal1(4)"], ["proof (chain)\npicking this:\n  n < length (entries s)", "have sa: \"\\<And>a. (entries s @ a) ! n = entries s ! n\""], ["proof (prove)\nusing this:\n  n < length (entries s)\n\ngoal (1 subgoal):\n 1. \\<And>a. (entries s @ a) ! n = entries s ! n", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (entries s @ ?a) ! n = entries s ! n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "from goal1(1,4)"], ["proof (chain)\npicking this:\n  distinct (entries s) \\<and>\n  (\\<forall>x.\n      x \\<in> {..<length (entries s)} \\<longrightarrow>\n      getentry s (entries s ! x) = Some x) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  n < length (entries s)", "have ih: \"getentry s (entries s ! n) = Some n\""], ["proof (prove)\nusing this:\n  distinct (entries s) \\<and>\n  (\\<forall>x.\n      x \\<in> {..<length (entries s)} \\<longrightarrow>\n      getentry s (entries s ! x) = Some x) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  n < length (entries s)\n\ngoal (1 subgoal):\n 1. getentry s (entries s ! n) = Some n", "by simp"], ["proof (state)\nthis:\n  getentry s (entries s ! n) = Some n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "from goal1(2,4)"], ["proof (chain)\npicking this:\n  m \\<notin> set (entries s)\n  n < length (entries s)", "have ne: \"entries s ! n \\<noteq> m\""], ["proof (prove)\nusing this:\n  m \\<notin> set (entries s)\n  n < length (entries s)\n\ngoal (1 subgoal):\n 1. entries s ! n \\<noteq> m", "using nth_mem"], ["proof (prove)\nusing this:\n  m \\<notin> set (entries s)\n  n < length (entries s)\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. entries s ! n \\<noteq> m", "by fastforce"], ["proof (state)\nthis:\n  entries s ! n \\<noteq> m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "from sa ih ne"], ["proof (chain)\npicking this:\n  (entries s @ ?a) ! n = entries s ! n\n  getentry s (entries s ! n) = Some n\n  entries s ! n \\<noteq> m", "show ?case"], ["proof (prove)\nusing this:\n  (entries s @ ?a) ! n = entries s ! n\n  getentry s (entries s ! n) = Some n\n  entries s ! n \\<noteq> m\n\ngoal (1 subgoal):\n 1. getentry\n     \\<lparr>entries = entries s @ [m],\n        getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>\n     (entries\n       \\<lparr>entries = entries s @ [m],\n          getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> !\n      n) =\n    Some n", "by simp"], ["proof (state)\nthis:\n  getentry\n   \\<lparr>entries = entries s @ [m],\n      getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>\n   (entries\n     \\<lparr>entries = entries s @ [m],\n        getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> !\n    n) =\n  Some n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "case 2"], ["proof (state)\nthis:\n  distinct (entries s) \\<and>\n  (\\<forall>x.\n      x \\<in> {..<length (entries s)} \\<longrightarrow>\n      getentry s (entries s ! x) = Some x) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n  n \\<in> {..<length\n               (entries\n                 \\<lparr>entries = entries s @ [m],\n                    getentry = getentry s(m \\<mapsto>\n                      length (entries s))\\<rparr>)}\n  \\<not> n < length (entries s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "note goal2 = 2"], ["proof (state)\nthis:\n  distinct (entries s) \\<and>\n  (\\<forall>x.\n      x \\<in> {..<length (entries s)} \\<longrightarrow>\n      getentry s (entries s ! x) = Some x) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n  n \\<in> {..<length\n               (entries\n                 \\<lparr>entries = entries s @ [m],\n                    getentry = getentry s(m \\<mapsto>\n                      length (entries s))\\<rparr>)}\n  \\<not> n < length (entries s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "from goal2(3,4)"], ["proof (chain)\npicking this:\n  n \\<in> {..<length\n               (entries\n                 \\<lparr>entries = entries s @ [m],\n                    getentry = getentry s(m \\<mapsto>\n                      length (entries s))\\<rparr>)}\n  \\<not> n < length (entries s)", "have ln: \"n = length (entries s)\""], ["proof (prove)\nusing this:\n  n \\<in> {..<length\n               (entries\n                 \\<lparr>entries = entries s @ [m],\n                    getentry = getentry s(m \\<mapsto>\n                      length (entries s))\\<rparr>)}\n  \\<not> n < length (entries s)\n\ngoal (1 subgoal):\n 1. n = length (entries s)", "by simp"], ["proof (state)\nthis:\n  n = length (entries s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "hence sa: \"\\<And>a. (entries s @ [a]) ! n = a\""], ["proof (prove)\nusing this:\n  n = length (entries s)\n\ngoal (1 subgoal):\n 1. \\<And>a. (entries s @ [a]) ! n = a", "by simp"], ["proof (state)\nthis:\n  (entries s @ [?a]) ! n = ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>x.\n                 x \\<in> {..<length (entries s)} \\<longrightarrow>\n                 getentry s (entries s ! x) = Some x) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s);\n     n \\<in> {..<length\n                  (entries\n                    \\<lparr>entries = entries s @ [m],\n                       getentry = getentry s(m \\<mapsto>\n                         length (entries s))\\<rparr>)};\n     \\<not> n < length (entries s)\\<rbrakk>\n    \\<Longrightarrow> getentry\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr>\n                       (entries\n                         \\<lparr>entries = entries s @ [m],\n                            getentry = getentry s(m \\<mapsto>\n                              length (entries s))\\<rparr> !\n                        n) =\n                      Some n", "from sa ln"], ["proof (chain)\npicking this:\n  (entries s @ [?a]) ! n = ?a\n  n = length (entries s)", "show ?case"], ["proof (prove)\nusing this:\n  (entries s @ [?a]) ! n = ?a\n  n = length (entries s)\n\ngoal (1 subgoal):\n 1. getentry\n     \\<lparr>entries = entries s @ [m],\n        getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>\n     (entries\n       \\<lparr>entries = entries s @ [m],\n          getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> !\n      n) =\n    Some n", "by simp"], ["proof (state)\nthis:\n  getentry\n   \\<lparr>entries = entries s @ [m],\n      getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>\n   (entries\n     \\<lparr>entries = entries s @ [m],\n        getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> !\n    n) =\n  Some n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (entries s) \\<and>\n           (\\<forall>x.\n               x \\<in> {..<length (entries s)} \\<longrightarrow>\n               getentry s (entries s ! x) = Some x) \\<and>\n           (\\<forall>p i.\n               getentry s p = Some i \\<longrightarrow>\n               entries s ! i = p \\<and> i < length (entries s));\n   m \\<notin> set (entries s);\n   n \\<in> {..<length\n                (entries\n                  \\<lparr>entries = entries s @ [m],\n                     getentry = getentry s(m \\<mapsto>\n                       length (entries s))\\<rparr>)};\n   n < length (entries s)\\<rbrakk>\n  \\<Longrightarrow> getentry\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>\n                     (entries\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr> !\n                      n) =\n                    Some n\n  \\<lbrakk>distinct (entries s) \\<and>\n           (\\<forall>x.\n               x \\<in> {..<length (entries s)} \\<longrightarrow>\n               getentry s (entries s ! x) = Some x) \\<and>\n           (\\<forall>p i.\n               getentry s p = Some i \\<longrightarrow>\n               entries s ! i = p \\<and> i < length (entries s));\n   m \\<notin> set (entries s);\n   n \\<in> {..<length\n                (entries\n                  \\<lparr>entries = entries s @ [m],\n                     getentry = getentry s(m \\<mapsto>\n                       length (entries s))\\<rparr>)};\n   \\<not> n < length (entries s)\\<rbrakk>\n  \\<Longrightarrow> getentry\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>\n                     (entries\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr> !\n                      n) =\n                    Some n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{..<length\n    (entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          (entries\n                            \\<lparr>entries = entries s @ [m],\n                               getentry = getentry s(m \\<mapsto>\n                                 length (entries s))\\<rparr> !\n                           n) =\n                         Some n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (entries s) \\<and>\n           (\\<forall>x.\n               x \\<in> {..<length (entries s)} \\<longrightarrow>\n               getentry s (entries s ! x) = Some x) \\<and>\n           (\\<forall>p i.\n               getentry s p = Some i \\<longrightarrow>\n               entries s ! i = p \\<and> i < length (entries s));\n   m \\<notin> set (entries s);\n   ?n2\n   \\<in> {..<length\n              (entries\n                \\<lparr>entries = entries s @ [m],\n                   getentry = getentry s(m \\<mapsto>\n                     length (entries s))\\<rparr>)};\n   ?n2 < length (entries s)\\<rbrakk>\n  \\<Longrightarrow> getentry\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>\n                     (entries\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr> !\n                      ?n2) =\n                    Some ?n2\n  \\<lbrakk>distinct (entries s) \\<and>\n           (\\<forall>x.\n               x \\<in> {..<length (entries s)} \\<longrightarrow>\n               getentry s (entries s ! x) = Some x) \\<and>\n           (\\<forall>p i.\n               getentry s p = Some i \\<longrightarrow>\n               entries s ! i = p \\<and> i < length (entries s));\n   m \\<notin> set (entries s);\n   ?n2\n   \\<in> {..<length\n              (entries\n                \\<lparr>entries = entries s @ [m],\n                   getentry = getentry s(m \\<mapsto>\n                     length (entries s))\\<rparr>)};\n   \\<not> ?n2 < length (entries s)\\<rbrakk>\n  \\<Longrightarrow> getentry\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>\n                     (entries\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr> !\n                      ?n2) =\n                    Some ?n2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{..<length\n    (entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          (entries\n                            \\<lparr>entries = entries s @ [m],\n                               getentry = getentry s(m \\<mapsto>\n                                 length (entries s))\\<rparr> !\n                           n) =\n                         Some n", "note h = this"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (entries s) \\<and>\n           (\\<forall>x.\n               x \\<in> {..<length (entries s)} \\<longrightarrow>\n               getentry s (entries s ! x) = Some x) \\<and>\n           (\\<forall>p i.\n               getentry s p = Some i \\<longrightarrow>\n               entries s ! i = p \\<and> i < length (entries s));\n   m \\<notin> set (entries s);\n   ?n2\n   \\<in> {..<length\n              (entries\n                \\<lparr>entries = entries s @ [m],\n                   getentry = getentry s(m \\<mapsto>\n                     length (entries s))\\<rparr>)};\n   ?n2 < length (entries s)\\<rbrakk>\n  \\<Longrightarrow> getentry\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>\n                     (entries\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr> !\n                      ?n2) =\n                    Some ?n2\n  \\<lbrakk>distinct (entries s) \\<and>\n           (\\<forall>x.\n               x \\<in> {..<length (entries s)} \\<longrightarrow>\n               getentry s (entries s ! x) = Some x) \\<and>\n           (\\<forall>p i.\n               getentry s p = Some i \\<longrightarrow>\n               entries s ! i = p \\<and> i < length (entries s));\n   m \\<notin> set (entries s);\n   ?n2\n   \\<in> {..<length\n              (entries\n                \\<lparr>entries = entries s @ [m],\n                   getentry = getentry s(m \\<mapsto>\n                     length (entries s))\\<rparr>)};\n   \\<not> ?n2 < length (entries s)\\<rbrakk>\n  \\<Longrightarrow> getentry\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>\n                     (entries\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr> !\n                      ?n2) =\n                    Some ?n2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)\n 2. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{..<length\n    (entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>)}.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          (entries\n                            \\<lparr>entries = entries s @ [m],\n                               getentry = getentry s(m \\<mapsto>\n                                 length (entries s))\\<rparr> !\n                           n) =\n                         Some n", "with 2"], ["proof (chain)\npicking this:\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n  \\<lbrakk>distinct (entries s) \\<and>\n           (\\<forall>x.\n               x \\<in> {..<length (entries s)} \\<longrightarrow>\n               getentry s (entries s ! x) = Some x) \\<and>\n           (\\<forall>p i.\n               getentry s p = Some i \\<longrightarrow>\n               entries s ! i = p \\<and> i < length (entries s));\n   m \\<notin> set (entries s);\n   ?n2\n   \\<in> {..<length\n              (entries\n                \\<lparr>entries = entries s @ [m],\n                   getentry = getentry s(m \\<mapsto>\n                     length (entries s))\\<rparr>)};\n   ?n2 < length (entries s)\\<rbrakk>\n  \\<Longrightarrow> getentry\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>\n                     (entries\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr> !\n                      ?n2) =\n                    Some ?n2\n  \\<lbrakk>distinct (entries s) \\<and>\n           (\\<forall>x.\n               x \\<in> {..<length (entries s)} \\<longrightarrow>\n               getentry s (entries s ! x) = Some x) \\<and>\n           (\\<forall>p i.\n               getentry s p = Some i \\<longrightarrow>\n               entries s ! i = p \\<and> i < length (entries s));\n   m \\<notin> set (entries s);\n   ?n2\n   \\<in> {..<length\n              (entries\n                \\<lparr>entries = entries s @ [m],\n                   getentry = getentry s(m \\<mapsto>\n                     length (entries s))\\<rparr>)};\n   \\<not> ?n2 < length (entries s)\\<rbrakk>\n  \\<Longrightarrow> getentry\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>\n                     (entries\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr> !\n                      ?n2) =\n                    Some ?n2", "show ?case"], ["proof (prove)\nusing this:\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n  \\<lbrakk>distinct (entries s) \\<and>\n           (\\<forall>x.\n               x \\<in> {..<length (entries s)} \\<longrightarrow>\n               getentry s (entries s ! x) = Some x) \\<and>\n           (\\<forall>p i.\n               getentry s p = Some i \\<longrightarrow>\n               entries s ! i = p \\<and> i < length (entries s));\n   m \\<notin> set (entries s);\n   ?n2\n   \\<in> {..<length\n              (entries\n                \\<lparr>entries = entries s @ [m],\n                   getentry = getentry s(m \\<mapsto>\n                     length (entries s))\\<rparr>)};\n   ?n2 < length (entries s)\\<rbrakk>\n  \\<Longrightarrow> getentry\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>\n                     (entries\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr> !\n                      ?n2) =\n                    Some ?n2\n  \\<lbrakk>distinct (entries s) \\<and>\n           (\\<forall>x.\n               x \\<in> {..<length (entries s)} \\<longrightarrow>\n               getentry s (entries s ! x) = Some x) \\<and>\n           (\\<forall>p i.\n               getentry s p = Some i \\<longrightarrow>\n               entries s ! i = p \\<and> i < length (entries s));\n   m \\<notin> set (entries s);\n   ?n2\n   \\<in> {..<length\n              (entries\n                \\<lparr>entries = entries s @ [m],\n                   getentry = getentry s(m \\<mapsto>\n                     length (entries s))\\<rparr>)};\n   \\<not> ?n2 < length (entries s)\\<rbrakk>\n  \\<Longrightarrow> getentry\n                     \\<lparr>entries = entries s @ [m],\n                        getentry = getentry s(m \\<mapsto>\n                          length (entries s))\\<rparr>\n                     (entries\n                       \\<lparr>entries = entries s @ [m],\n                          getentry = getentry s(m \\<mapsto>\n                            length (entries s))\\<rparr> !\n                      ?n2) =\n                    Some ?n2\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<length\n                        (entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>)}.\n       getentry\n        \\<lparr>entries = entries s @ [m],\n           getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>\n        (entries\n          \\<lparr>entries = entries s @ [m],\n             getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> !\n         n) =\n       Some n", "by blast"], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<length\n                      (entries\n                        \\<lparr>entries = entries s @ [m],\n                           getentry = getentry s(m \\<mapsto>\n                             length (entries s))\\<rparr>)}.\n     getentry\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>\n      (entries\n        \\<lparr>entries = entries s @ [m],\n           getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> !\n       n) =\n     Some n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)", "(*apply(unfold Ball_def) \n    apply(rule)\n    apply(rule)\n    apply(rename_tac n)\n    apply(case_tac \"n < length (entries s)\")\n  by(fact h)+*)"], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<length\n                      (entries\n                        \\<lparr>entries = entries s @ [m],\n                           getentry = getentry s(m \\<mapsto>\n                             length (entries s))\\<rparr>)}.\n     getentry\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>\n      (entries\n        \\<lparr>entries = entries s @ [m],\n           getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> !\n       n) =\n     Some n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)", "case 1"], ["proof (state)\nthis:\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries s) \\<and>\n             (\\<forall>n\\<in>{..<length (entries s)}.\n                 getentry s (entries s ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry s p = Some i \\<longrightarrow>\n                 entries s ! i = p \\<and> i < length (entries s));\n     m \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p i.\n                         getentry\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr>\n                          p =\n                         Some i \\<longrightarrow>\n                         entries\n                          \\<lparr>entries = entries s @ [m],\n                             getentry = getentry s(m \\<mapsto>\n                               length (entries s))\\<rparr> !\n                         i =\n                         p \\<and>\n                         i < length\n                              (entries\n                                \\<lparr>entries = entries s @ [m],\n                                   getentry = getentry s(m \\<mapsto>\n                                     length (entries s))\\<rparr>)", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  m \\<notin> set (entries s)\n\ngoal (1 subgoal):\n 1. \\<forall>p i.\n       getentry\n        \\<lparr>entries = entries s @ [m],\n           getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>\n        p =\n       Some i \\<longrightarrow>\n       entries\n        \\<lparr>entries = entries s @ [m],\n           getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> !\n       i =\n       p \\<and>\n       i < length\n            (entries\n              \\<lparr>entries = entries s @ [m],\n                 getentry = getentry s(m \\<mapsto>\n                   length (entries s))\\<rparr>)", "by(clarsimp simp add: nth_append fun_upd_same Ball_def) force"], ["proof (state)\nthis:\n  \\<forall>p i.\n     getentry\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr>\n      p =\n     Some i \\<longrightarrow>\n     entries\n      \\<lparr>entries = entries s @ [m],\n         getentry = getentry s(m \\<mapsto> length (entries s))\\<rparr> !\n     i =\n     p \\<and>\n     i < length\n          (entries\n            \\<lparr>entries = entries s @ [m],\n               getentry = getentry s(m \\<mapsto>\n                 length (entries s))\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma luentries_noneD: \"getentry s a = None \\<Longrightarrow> pointermap_sane s \\<Longrightarrow> a \\<notin> set (entries s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>getentry s a = None; pointermap_sane s\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set (entries s)", "unfolding pointermap_sane_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>getentry s a = None;\n     distinct (entries s) \\<and>\n     (\\<forall>n\\<in>{..<length (entries s)}.\n         getentry s (entries s ! n) = Some n) \\<and>\n     (\\<forall>p i.\n         getentry s p = Some i \\<longrightarrow>\n         entries s ! i = p \\<and> i < length (entries s))\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set (entries s)", "proof(rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>getentry s a = None;\n     distinct (entries s) \\<and>\n     (\\<forall>n\\<in>{..<length (entries s)}.\n         getentry s (entries s ! n) = Some n) \\<and>\n     (\\<forall>p i.\n         getentry s p = Some i \\<longrightarrow>\n         entries s ! i = p \\<and> i < length (entries s));\n     \\<not> a \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  getentry s a = None\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  \\<not> a \\<notin> set (entries s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getentry s a = None;\n     distinct (entries s) \\<and>\n     (\\<forall>n\\<in>{..<length (entries s)}.\n         getentry s (entries s ! n) = Some n) \\<and>\n     (\\<forall>p i.\n         getentry s p = Some i \\<longrightarrow>\n         entries s ! i = p \\<and> i < length (entries s));\n     \\<not> a \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> False", "from 1(3)"], ["proof (chain)\npicking this:\n  \\<not> a \\<notin> set (entries s)", "obtain n where \"n < length (entries s)\" \"entries s ! n = a\""], ["proof (prove)\nusing this:\n  \\<not> a \\<notin> set (entries s)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < length (entries s); entries s ! n = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_set_conv_nth"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<exists>i<length (entries s). entries s ! i = a)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < length (entries s); entries s ! n = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n < length (entries s)\n  entries s ! n = a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getentry s a = None;\n     distinct (entries s) \\<and>\n     (\\<forall>n\\<in>{..<length (entries s)}.\n         getentry s (entries s ! n) = Some n) \\<and>\n     (\\<forall>p i.\n         getentry s p = Some i \\<longrightarrow>\n         entries s ! i = p \\<and> i < length (entries s));\n     \\<not> a \\<notin> set (entries s)\\<rbrakk>\n    \\<Longrightarrow> False", "with 1(2,1)"], ["proof (chain)\npicking this:\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  getentry s a = None\n  n < length (entries s)\n  entries s ! n = a", "show False"], ["proof (prove)\nusing this:\n  distinct (entries s) \\<and>\n  (\\<forall>n\\<in>{..<length (entries s)}.\n      getentry s (entries s ! n) = Some n) \\<and>\n  (\\<forall>p i.\n      getentry s p = Some i \\<longrightarrow>\n      entries s ! i = p \\<and> i < length (entries s))\n  getentry s a = None\n  n < length (entries s)\n  entries s ! n = a\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pm_pth_append: \"pointermap_p_valid p m \\<Longrightarrow> pm_pth (pointermap_insert a m) p = pm_pth m p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointermap_p_valid p m \\<Longrightarrow>\n    pm_pth (pointermap_insert a m) p = pm_pth m p", "unfolding pointermap_p_valid_def pm_pth_def pointermap_insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p < length (entries m) \\<Longrightarrow>\n    entries\n     \\<lparr>entries = entries m @ [a],\n        getentry = getentry m(a \\<mapsto> length (entries m))\\<rparr> !\n    p =\n    entries m ! p", "by(simp add: nth_append)"], ["", "lemma pointermap_insert_in: \"u = (pointermap_insert a m) \\<Longrightarrow> pm_pth u (the (getentry u a)) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = pointermap_insert a m \\<Longrightarrow>\n    pm_pth u (the (getentry u a)) = a", "unfolding pointermap_insert_def pm_pth_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u =\n    \\<lparr>entries = entries m @ [a],\n       getentry = getentry m(a \\<mapsto>\n         length (entries m))\\<rparr> \\<Longrightarrow>\n    entries u ! the (getentry u a) = a", "by(simp)"], ["", "lemma pointermap_insert_p_validI: \"pointermap_p_valid p m \\<Longrightarrow> pointermap_p_valid p (pointermap_insert a m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointermap_p_valid p m \\<Longrightarrow>\n    pointermap_p_valid p (pointermap_insert a m)", "unfolding pointermap_insert_def pointermap_p_valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p < length (entries m) \\<Longrightarrow>\n    p < length\n         (entries\n           \\<lparr>entries = entries m @ [a],\n              getentry = getentry m(a \\<mapsto> length (entries m))\\<rparr>)", "by simp"], ["", "thm nth_eq_iff_index_eq"], ["", "lemma pth_eq_iff_index_eq: \"pointermap_sane m \\<Longrightarrow> pointermap_p_valid p1 m \\<Longrightarrow> pointermap_p_valid p2 m \\<Longrightarrow> (pm_pth m p1 = pm_pth m p2) \\<longleftrightarrow> (p1 = p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pointermap_sane m; pointermap_p_valid p1 m;\n     pointermap_p_valid p2 m\\<rbrakk>\n    \\<Longrightarrow> (pm_pth m p1 = pm_pth m p2) = (p1 = p2)", "unfolding pointermap_sane_def pointermap_p_valid_def pm_pth_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries m) \\<and>\n             (\\<forall>n\\<in>{..<length (entries m)}.\n                 getentry m (entries m ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry m p = Some i \\<longrightarrow>\n                 entries m ! i = p \\<and> i < length (entries m));\n     p1 < length (entries m); p2 < length (entries m)\\<rbrakk>\n    \\<Longrightarrow> (entries m ! p1 = entries m ! p2) = (p1 = p2)", "using nth_eq_iff_index_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?xs; ?i < length ?xs; ?j < length ?xs\\<rbrakk>\n  \\<Longrightarrow> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (entries m) \\<and>\n             (\\<forall>n\\<in>{..<length (entries m)}.\n                 getentry m (entries m ! n) = Some n) \\<and>\n             (\\<forall>p i.\n                 getentry m p = Some i \\<longrightarrow>\n                 entries m ! i = p \\<and> i < length (entries m));\n     p1 < length (entries m); p2 < length (entries m)\\<rbrakk>\n    \\<Longrightarrow> (entries m ! p1 = entries m ! p2) = (p1 = p2)", "by blast"], ["", "lemma pointermap_p_valid_updateI: \"pointermap_sane m \\<Longrightarrow> getentry m a = None \\<Longrightarrow> u = pointermap_insert a m \\<Longrightarrow> p = the (getentry u a) \\<Longrightarrow> pointermap_p_valid p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pointermap_sane m; getentry m a = None;\n     u = pointermap_insert a m; p = the (getentry u a)\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid p u", "by(simp add: pointermap_sane_def pointermap_p_valid_def pointermap_insert_def)"], ["", "lemma pointermap_get_validI: \"pointermap_sane m \\<Longrightarrow> getentry m a = Some p \\<Longrightarrow> pointermap_p_valid p m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pointermap_sane m; getentry m a = Some p\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid p m", "by(simp add: pointermap_sane_def pointermap_p_valid_def)"], ["", "lemma pointermap_sane_getmkD: \n  assumes sn: \"pointermap_sane m\"\n  assumes res: \"pointermap_getmk a m = (p,u)\"\n  shows \"pointermap_sane u \\<and> pointermap_p_valid p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointermap_sane u \\<and> pointermap_p_valid p u", "using sn res[symmetric]"], ["proof (prove)\nusing this:\n  pointermap_sane m\n  (p, u) = pointermap_getmk a m\n\ngoal (1 subgoal):\n 1. pointermap_sane u \\<and> pointermap_p_valid p u", "apply(cases \"getentry m a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pointermap_sane m; (p, u) = pointermap_getmk a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_sane u \\<and> pointermap_p_valid p u\n 2. \\<And>aa.\n       \\<lbrakk>pointermap_sane m; (p, u) = pointermap_getmk a m;\n        getentry m a = Some aa\\<rbrakk>\n       \\<Longrightarrow> pointermap_sane u \\<and> pointermap_p_valid p u", "apply(simp_all add: pointermap_getmk_def Let_def split: option.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_sane (pointermap_insert a m) \\<and>\n                      pointermap_p_valid\n                       (the (getentry (pointermap_insert a m) a))\n                       (pointermap_insert a m)\n 2. \\<lbrakk>pointermap_sane m; u = m; getentry m a = Some p\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid p m", "apply(rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_sane (pointermap_insert a m)\n 2. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid\n                       (the (getentry (pointermap_insert a m) a))\n                       (pointermap_insert a m)\n 3. \\<lbrakk>pointermap_sane m; u = m; getentry m a = Some p\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid p m", "apply(rule pointermap_sane_appendD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_sane m\n 2. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set (entries m)\n 3. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid\n                       (the (getentry (pointermap_insert a m) a))\n                       (pointermap_insert a m)\n 4. \\<lbrakk>pointermap_sane m; u = m; getentry m a = Some p\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid p m", "apply(clarify;fail)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> set (entries m)\n 2. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid\n                       (the (getentry (pointermap_insert a m) a))\n                       (pointermap_insert a m)\n 3. \\<lbrakk>pointermap_sane m; u = m; getentry m a = Some p\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid p m", "apply(rule luentries_noneD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> getentry m a = None\n 2. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_sane m\n 3. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid\n                       (the (getentry (pointermap_insert a m) a))\n                       (pointermap_insert a m)\n 4. \\<lbrakk>pointermap_sane m; u = m; getentry m a = Some p\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid p m", "apply(clarify;fail)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid\n                       (the (getentry (pointermap_insert a m) a))\n                       (pointermap_insert a m)\n 2. \\<lbrakk>pointermap_sane m; u = m; getentry m a = Some p\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid p m", "apply(rule pointermap_p_valid_updateI[OF _ _ refl refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> pointermap_sane m\n 2. \\<lbrakk>pointermap_sane m;\n     p = the (getentry (pointermap_insert a m) a) \\<and>\n     u = pointermap_insert a m;\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> getentry m a = None\n 3. \\<lbrakk>pointermap_sane m; u = m; getentry m a = Some p\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid p m", "apply(clarify;fail)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pointermap_sane m; u = m; getentry m a = Some p\\<rbrakk>\n    \\<Longrightarrow> pointermap_p_valid p m", "apply(erule pointermap_get_validI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u = m; getentry m a = Some p\\<rbrakk>\n    \\<Longrightarrow> getentry m ?a29 = Some p", "by simp"], ["", "lemma pointermap_update_pthI: \n  assumes sn: \"pointermap_sane m\"\n  assumes res: \"pointermap_getmk a m = (p,u)\"\n  shows \"pm_pth u p = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_pth u p = a", "using assms"], ["proof (prove)\nusing this:\n  pointermap_sane m\n  pointermap_getmk a m = (p, u)\n\ngoal (1 subgoal):\n 1. pm_pth u p = a", "apply(simp add: pointermap_getmk_def Let_def split: option.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pointermap_sane m; getentry m a = None;\n     the (getentry (pointermap_insert a m) a) = p \\<and>\n     pointermap_insert a m = u\\<rbrakk>\n    \\<Longrightarrow> pm_pth u p = a\n 2. \\<lbrakk>pointermap_sane u; getentry u a = Some p; m = u\\<rbrakk>\n    \\<Longrightarrow> pm_pth u p = a", "apply(meson pointermap_insert_in)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pointermap_sane u; getentry u a = Some p; m = u\\<rbrakk>\n    \\<Longrightarrow> pm_pth u p = a", "apply(clarsimp simp: pointermap_sane_def pm_pth_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pointermap_p_valid_inv:\n  assumes \"pointermap_p_valid p m\"\n  assumes \"pointermap_getmk a m = (x,u)\"\n  shows \"pointermap_p_valid p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointermap_p_valid p u", "using assms"], ["proof (prove)\nusing this:\n  pointermap_p_valid p m\n  pointermap_getmk a m = (x, u)\n\ngoal (1 subgoal):\n 1. pointermap_p_valid p u", "by(simp add: pointermap_getmk_def Let_def split: option.splits) (meson pointermap_insert_p_validI)"], ["", "lemma pointermap_p_pth_inv:\n  assumes pv: \"pointermap_p_valid p m\"\n  assumes u: \"pointermap_getmk a m = (x,u)\"\n  shows \"pm_pth u p = pm_pth m p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_pth u p = pm_pth m p", "using pm_pth_append[OF pv] u"], ["proof (prove)\nusing this:\n  pm_pth (pointermap_insert ?a m) p = pm_pth m p\n  pointermap_getmk a m = (x, u)\n\ngoal (1 subgoal):\n 1. pm_pth u p = pm_pth m p", "by(clarsimp simp: pointermap_getmk_def Let_def split: option.splits)"], ["", "lemma pointermap_backward_valid:\n  assumes puv: \"pointermap_p_valid p u\"\n  assumes u: \"pointermap_getmk a m = (x,u)\"\n  assumes ne: \"x \\<noteq> p\"\n  shows \"pointermap_p_valid p m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointermap_p_valid p m", "(*using u\nunfolding pointermap_getmk_def\napply(simp add: Let_def split: option.splits)\nprefer 2 using puv apply(simp)\napply(clarify)\napply(simp add: pointermap_insert_def)\nusing puv apply(clarify)\napply(simp add: pointermap_p_valid_def)\nusing ne by linarith\n*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pointermap_p_valid p m", "using assms"], ["proof (prove)\nusing this:\n  pointermap_p_valid p u\n  pointermap_getmk a m = (x, u)\n  x \\<noteq> p\n\ngoal (1 subgoal):\n 1. pointermap_p_valid p m", "by (auto simp: Let_def pointermap_getmk_def pointermap_p_valid_def pointermap_insert_def split: option.splits)"], ["", "end"]]}