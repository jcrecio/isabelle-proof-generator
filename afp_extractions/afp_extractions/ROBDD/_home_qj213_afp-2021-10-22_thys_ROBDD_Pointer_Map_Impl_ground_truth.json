{"file_name": "/home/qj213/afp-2021-10-22/thys/ROBDD/Pointer_Map_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ROBDD", "problem_names": ["lemma pointermapieq_exhaust: \"entries a = entries b \\<Longrightarrow> getentry a = getentry b \\<Longrightarrow> a = (b :: 'a pointermap)\"", "lemma is_pointermap_impl_prec: \"precise is_pointermap_impl\"", "lemma [sep_heap_rules]: \"< emp > pointermap_empty <is_pointermap_impl empty_pointermap>\\<^sub>t\"", "lemma [sep_heap_rules]: \"pointermap_sane m \\<Longrightarrow> pointermap_p_valid p m \\<Longrightarrow>\n    < is_pointermap_impl m mi > pm_pthi mi p <\\<lambda>ai. is_pointermap_impl m mi * \\<up>(ai = pm_pth m p)>\"", "lemmas pointermap_getmki_defs = pointermap_getmki_def pointermap_getmk_def pointermap_insert_def is_pointermap_impl_def", "lemma [sep_heap_rules]: \"pointermap_sane m \\<Longrightarrow> pointermap_getmk a m = (p,u) \\<Longrightarrow>\n    < is_pointermap_impl m mi >\n      pointermap_getmki a mi\n    <\\<lambda>(pi,ui). is_pointermap_impl u ui * \\<up>(pi = p)>\\<^sub>t\""], "translations": [["", "lemma pointermapieq_exhaust: \"entries a = entries b \\<Longrightarrow> getentry a = getentry b \\<Longrightarrow> a = (b :: 'a pointermap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>entries a = entries b; getentry a = getentry b\\<rbrakk>\n    \\<Longrightarrow> a = b", "by simp"], ["", "definition is_pointermap_impl :: \"('a::{hashable,heap}) pointermap \\<Rightarrow> 'a pointermap_impl \\<Rightarrow> assn\" where\n    \"is_pointermap_impl b bi \\<equiv> \n      is_array_list (entries b) (entriesi bi) \n    * is_hashmap (getentry b) (getentryi bi)\""], ["", "lemma is_pointermap_impl_prec: \"precise is_pointermap_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_pointermap_impl", "unfolding is_pointermap_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise\n     (\\<lambda>b bi.\n         is_array_list (entries b) (entriesi bi) *\n         is_hashmap (getentry b) (getentryi bi))", "apply(rule preciseI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       is_hashmap (getentry a) (getentryi p) *\n       F \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       is_hashmap (getentry a') (getentryi p) *\n       F' \\<Longrightarrow>\n       a = a'", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F'.\n       (aa, b) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       is_hashmap (getentry a) (getentryi p) *\n       F \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       is_hashmap (getentry a') (getentryi p) *\n       F' \\<Longrightarrow>\n       a = a'", "apply(rename_tac a a' x y p F F')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       is_hashmap (getentry a) (getentryi p) *\n       F \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       is_hashmap (getentry a') (getentryi p) *\n       F' \\<Longrightarrow>\n       a = a'", "apply(rule pointermapieq_exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       is_hashmap (getentry a) (getentryi p) *\n       F \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       is_hashmap (getentry a') (getentryi p) *\n       F' \\<Longrightarrow>\n       entries a = entries a'\n 2. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       is_hashmap (getentry a) (getentryi p) *\n       F \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       is_hashmap (getentry a') (getentryi p) *\n       F' \\<Longrightarrow>\n       getentry a = getentry a'", "apply(rule_tac p = \"entriesi p\" and h = \"(x,y)\" in preciseD[OF is_array_list_prec])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       is_hashmap (getentry a) (getentryi p) *\n       F \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       is_hashmap (getentry a') (getentryi p) *\n       F' \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       ?F5 a a' x y p F F' \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) * ?F'5 a a' x y p F F'\n 2. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       is_hashmap (getentry a) (getentryi p) *\n       F \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       is_hashmap (getentry a') (getentryi p) *\n       F' \\<Longrightarrow>\n       getentry a = getentry a'", "apply(unfold star_aci(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       (is_hashmap (getentry a) (getentryi p) * F) \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       (is_hashmap (getentry a') (getentryi p) * F') \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       ?F5 a a' x y p F F' \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) * ?F'5 a a' x y p F F'\n 2. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       (is_hashmap (getentry a) (getentryi p) * F) \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       (is_hashmap (getentry a') (getentryi p) * F') \\<Longrightarrow>\n       getentry a = getentry a'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       (is_hashmap (getentry a) (getentryi p) * F) \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       (is_hashmap (getentry a') (getentryi p) * F') \\<Longrightarrow>\n       getentry a = getentry a'", "apply(rule_tac p = \"getentryi p\" and h = \"(x,y)\" in preciseD[OF is_hashmap_prec])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       (is_hashmap (getentry a) (getentryi p) * F) \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       (is_hashmap (getentry a') (getentryi p) * F') \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_hashmap (getentry a) (getentryi p) *\n       ?F8 a a' x y p F F' \\<and>\\<^sub>A\n       is_hashmap (getentry a') (getentryi p) * ?F'8 a a' x y p F F'", "apply(simp only: star_aci(2)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) *\n       (F * is_hashmap (getentry a) (getentryi p)) \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) *\n       (F' * is_hashmap (getentry a') (getentryi p)) \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_hashmap (getentry a) (getentryi p) *\n       ?F8 a a' x y p F F' \\<and>\\<^sub>A\n       is_hashmap (getentry a') (getentryi p) * ?F'8 a a' x y p F F'", "apply(simp only: star_aci(1)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) * F *\n       is_hashmap (getentry a) (getentryi p) \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) * F' *\n       is_hashmap (getentry a') (getentryi p) \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_hashmap (getentry a) (getentryi p) *\n       ?F8 a a' x y p F F' \\<and>\\<^sub>A\n       is_hashmap (getentry a') (getentryi p) * ?F'8 a a' x y p F F'", "(* black unfold magic *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_array_list (entries a) (entriesi p) * F *\n       is_hashmap (getentry a) (getentryi p) \\<and>\\<^sub>A\n       is_array_list (entries a') (entriesi p) * F' *\n       is_hashmap (getentry a') (getentryi p) \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_hashmap (getentry a) (getentryi p) *\n       ?F8 a a' x y p F F' \\<and>\\<^sub>A\n       is_hashmap (getentry a') (getentryi p) * ?F'8 a a' x y p F F'", "apply(simp only: star_aci(2)[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition pointermap_empty where\n    \"pointermap_empty \\<equiv> do {\n      hm \\<leftarrow> hm_new;\n      arl \\<leftarrow> arl_empty;\n      return \\<lparr>entriesi = arl, getentryi = hm \\<rparr>\n    }\""], ["", "lemma [sep_heap_rules]: \"< emp > pointermap_empty <is_pointermap_impl empty_pointermap>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> pointermap_empty <is_pointermap_impl empty_pointermap>\\<^sub>t", "unfolding is_pointermap_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> pointermap_empty <\\<lambda>r.\n                               is_array_list (entries empty_pointermap)\n                                (entriesi r) *\n                               is_hashmap (getentry empty_pointermap)\n                                (getentryi r)>\\<^sub>t", "by (sep_auto simp: pointermap_empty_def empty_pointermap_def)"], ["", "definition pm_pthi where\n    \"pm_pthi m p \\<equiv> arl_nth (entriesi m) p\""], ["", "lemma [sep_heap_rules]: \"pointermap_sane m \\<Longrightarrow> pointermap_p_valid p m \\<Longrightarrow>\n    < is_pointermap_impl m mi > pm_pthi mi p <\\<lambda>ai. is_pointermap_impl m mi * \\<up>(ai = pm_pth m p)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pointermap_sane m; pointermap_p_valid p m\\<rbrakk>\n    \\<Longrightarrow> <is_pointermap_impl m mi> pm_pthi mi p\n                      <\\<lambda>ai.\n                          is_pointermap_impl m mi * \\<up> (ai = pm_pth m p)>", "by (sep_auto simp: pm_pthi_def pm_pth_def is_pointermap_impl_def pointermap_p_valid_def)"], ["", "definition pointermap_getmki where\n    \"pointermap_getmki a m \\<equiv> do {\n        lo \\<leftarrow> ht_lookup a (getentryi m);\n        (case lo of \n          Some l \\<Rightarrow> return (l,m) | \n          None \\<Rightarrow> do {\n            p \\<leftarrow> return (snd (entriesi m));\n        ent \\<leftarrow> arl_append (entriesi m) a;\n        lut \\<leftarrow> hm_update a p (getentryi m);\n        u \\<leftarrow> return \\<lparr>entriesi = ent, getentryi = lut\\<rparr>;\n        return (p,u)\n          }\n        )\n    }\""], ["", "lemmas pointermap_getmki_defs = pointermap_getmki_def pointermap_getmk_def pointermap_insert_def is_pointermap_impl_def"], ["", "lemma [sep_heap_rules]: \"pointermap_sane m \\<Longrightarrow> pointermap_getmk a m = (p,u) \\<Longrightarrow>\n    < is_pointermap_impl m mi >\n      pointermap_getmki a mi\n    <\\<lambda>(pi,ui). is_pointermap_impl u ui * \\<up>(pi = p)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u)\\<rbrakk>\n    \\<Longrightarrow> <is_pointermap_impl m\n                        mi> pointermap_getmki a\n                             mi <\\<lambda>r.\n                                    case r of\n                                    (pi, ui) \\<Rightarrow>\nis_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t", "apply(cases \"getentry m a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> <is_pointermap_impl m\n                        mi> pointermap_getmki a\n                             mi <\\<lambda>r.\n                                    case r of\n                                    (pi, ui) \\<Rightarrow>\nis_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t\n 2. \\<And>aa.\n       \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n        getentry m a = Some aa\\<rbrakk>\n       \\<Longrightarrow> <is_pointermap_impl m\n                           mi> pointermap_getmki a\n                                mi <\\<lambda>r.\n case r of\n (pi, ui) \\<Rightarrow> is_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t", "apply(unfold pointermap_getmki_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> <is_pointermap_impl m\n                        mi> hm_lookup a (getentryi mi) \\<bind>\n                            (\\<lambda>lo.\n                                case lo of\n                                None \\<Rightarrow>\n                                  return (snd (entriesi mi)) \\<bind>\n                                  (\\<lambda>p.\narl_append (entriesi mi) a \\<bind>\n(\\<lambda>ent.\n    hm_update a p (getentryi mi) \\<bind>\n    (\\<lambda>lut.\n        return \\<lparr>entriesi = ent, getentryi = lut\\<rparr> \\<bind>\n        (\\<lambda>u. return (p, u)))))\n                                | Some l \\<Rightarrow>\n                                    return\n                                     (l,\nmi)) <\\<lambda>r.\n         case r of\n         (pi, ui) \\<Rightarrow>\n           is_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t\n 2. \\<And>aa.\n       \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n        getentry m a = Some aa\\<rbrakk>\n       \\<Longrightarrow> <is_pointermap_impl m\n                           mi> hm_lookup a (getentryi mi) \\<bind>\n                               (\\<lambda>lo.\n                                   case lo of\n                                   None \\<Rightarrow>\n                                     return (snd (entriesi mi)) \\<bind>\n                                     (\\<lambda>p.\n   arl_append (entriesi mi) a \\<bind>\n   (\\<lambda>ent.\n       hm_update a p (getentryi mi) \\<bind>\n       (\\<lambda>lut.\n           return \\<lparr>entriesi = ent, getentryi = lut\\<rparr> \\<bind>\n           (\\<lambda>u. return (p, u)))))\n                                   | Some l \\<Rightarrow>\n return\n  (l, mi)) <\\<lambda>r.\n               case r of\n               (pi, ui) \\<Rightarrow>\n                 is_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t", "apply(unfold return_bind)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> <is_pointermap_impl m\n                        mi> hm_lookup a (getentryi mi) \\<bind>\n                            (\\<lambda>lo.\n                                case lo of\n                                None \\<Rightarrow>\n                                  arl_append (entriesi mi) a \\<bind>\n                                  (\\<lambda>ent.\nhm_update a (snd (entriesi mi)) (getentryi mi) \\<bind>\n(\\<lambda>lut.\n    return\n     (snd (entriesi mi), \\<lparr>entriesi = ent, getentryi = lut\\<rparr>)))\n                                | Some l \\<Rightarrow>\n                                    return\n                                     (l,\nmi)) <\\<lambda>r.\n         case r of\n         (pi, ui) \\<Rightarrow>\n           is_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t\n 2. \\<And>aa.\n       \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n        getentry m a = Some aa\\<rbrakk>\n       \\<Longrightarrow> <is_pointermap_impl m\n                           mi> hm_lookup a (getentryi mi) \\<bind>\n                               (\\<lambda>lo.\n                                   case lo of\n                                   None \\<Rightarrow>\n                                     arl_append (entriesi mi) a \\<bind>\n                                     (\\<lambda>ent.\n   hm_update a (snd (entriesi mi)) (getentryi mi) \\<bind>\n   (\\<lambda>lut.\n       return\n        (snd (entriesi mi),\n         \\<lparr>entriesi = ent, getentryi = lut\\<rparr>)))\n                                   | Some l \\<Rightarrow>\n return\n  (l, mi)) <\\<lambda>r.\n               case r of\n               (pi, ui) \\<Rightarrow>\n                 is_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t", "apply(rule bind_rule[where R = \"\\<lambda>r. is_pointermap_impl m mi * \\<up>(r = None \\<and> (snd (entriesi mi) = p)) * true\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n     getentry m a = None\\<rbrakk>\n    \\<Longrightarrow> <is_pointermap_impl m\n                        mi> hm_lookup a\n                             (getentryi\n                               mi) <\\<lambda>r.\n is_pointermap_impl m mi *\n \\<up> (r = None \\<and> snd (entriesi mi) = p)>\\<^sub>t\n 2. \\<And>x.\n       \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n        getentry m a = None\\<rbrakk>\n       \\<Longrightarrow> <is_pointermap_impl m mi *\n                          \\<up> (x = None \\<and> snd (entriesi mi) = p) *\n                          true> case x of\n                                None \\<Rightarrow>\n                                  arl_append (entriesi mi) a \\<bind>\n                                  (\\<lambda>ent.\nhm_update a (snd (entriesi mi)) (getentryi mi) \\<bind>\n(\\<lambda>lut.\n    return\n     (snd (entriesi mi), \\<lparr>entriesi = ent, getentryi = lut\\<rparr>)))\n                                | Some l \\<Rightarrow>\n                                    return\n                                     (l,\nmi) <\\<lambda>r.\n        case r of\n        (pi, ui) \\<Rightarrow>\n          is_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t\n 3. \\<And>aa.\n       \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n        getentry m a = Some aa\\<rbrakk>\n       \\<Longrightarrow> <is_pointermap_impl m\n                           mi> hm_lookup a (getentryi mi) \\<bind>\n                               (\\<lambda>lo.\n                                   case lo of\n                                   None \\<Rightarrow>\n                                     arl_append (entriesi mi) a \\<bind>\n                                     (\\<lambda>ent.\n   hm_update a (snd (entriesi mi)) (getentryi mi) \\<bind>\n   (\\<lambda>lut.\n       return\n        (snd (entriesi mi),\n         \\<lparr>entriesi = ent, getentryi = lut\\<rparr>)))\n                                   | Some l \\<Rightarrow>\n return\n  (l, mi)) <\\<lambda>r.\n               case r of\n               (pi, ui) \\<Rightarrow>\n                 is_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t", "apply(sep_auto simp: pointermap_getmki_defs is_array_list_def split: prod.splits;fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n        getentry m a = None\\<rbrakk>\n       \\<Longrightarrow> <is_pointermap_impl m mi *\n                          \\<up> (x = None \\<and> snd (entriesi mi) = p) *\n                          true> case x of\n                                None \\<Rightarrow>\n                                  arl_append (entriesi mi) a \\<bind>\n                                  (\\<lambda>ent.\nhm_update a (snd (entriesi mi)) (getentryi mi) \\<bind>\n(\\<lambda>lut.\n    return\n     (snd (entriesi mi), \\<lparr>entriesi = ent, getentryi = lut\\<rparr>)))\n                                | Some l \\<Rightarrow>\n                                    return\n                                     (l,\nmi) <\\<lambda>r.\n        case r of\n        (pi, ui) \\<Rightarrow>\n          is_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t\n 2. \\<And>aa.\n       \\<lbrakk>pointermap_sane m; pointermap_getmk a m = (p, u);\n        getentry m a = Some aa\\<rbrakk>\n       \\<Longrightarrow> <is_pointermap_impl m\n                           mi> hm_lookup a (getentryi mi) \\<bind>\n                               (\\<lambda>lo.\n                                   case lo of\n                                   None \\<Rightarrow>\n                                     arl_append (entriesi mi) a \\<bind>\n                                     (\\<lambda>ent.\n   hm_update a (snd (entriesi mi)) (getentryi mi) \\<bind>\n   (\\<lambda>lut.\n       return\n        (snd (entriesi mi),\n         \\<lparr>entriesi = ent, getentryi = lut\\<rparr>)))\n                                   | Some l \\<Rightarrow>\n return\n  (l, mi)) <\\<lambda>r.\n               case r of\n               (pi, ui) \\<Rightarrow>\n                 is_pointermap_impl u ui * \\<up> (pi = p)>\\<^sub>t", "apply(sep_auto simp: pointermap_getmki_defs)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}