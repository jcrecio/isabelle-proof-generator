{"file_name": "/home/qj213/afp-2021-10-22/thys/ROBDD/Option_Helpers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ROBDD", "problem_names": ["lemma oassert_iff[simp]: \n  \"oassert \\<Phi> = Some x \\<longleftrightarrow> \\<Phi>\" \n  \"oassert \\<Phi> = None \\<longleftrightarrow> \\<not>\\<Phi>\"", "lemma oreturn_rule[ospec_rules]: \"\\<lbrakk> P r \\<rbrakk> \\<Longrightarrow> ospec (Some r) P\"", "lemma obind_rule[ospec_rules]: \"\\<lbrakk> ospec m Q; \\<And>r. Q r \\<Longrightarrow> ospec (f r) P \\<rbrakk> \\<Longrightarrow> ospec (m \\<bind> f) P\"", "lemma ospec_alt: \"ospec m P = (case m of None \\<Rightarrow> False | Some x \\<Rightarrow> P x)\"", "lemma ospec_bind_simp: \"ospec (m \\<bind> f) P \\<longleftrightarrow> (ospec m (\\<lambda>r. ospec (f r) P))\"", "lemma ospec_cons: \n  assumes \"ospec m Q\"\n  assumes \"\\<And>r. Q r \\<Longrightarrow> P r\"\n  shows \"ospec m P\"", "lemma oreturn_synth: \"ospec (Some x) (\\<lambda>r. r=x)\"", "lemma ospecD: \"ospec x P \\<Longrightarrow> x = Some y \\<Longrightarrow> P y\"", "lemma ospecD2: \"ospec x P \\<Longrightarrow> \\<exists>y. x = Some y \\<and> P y\""], "translations": [["", "lemma oassert_iff[simp]: \n  \"oassert \\<Phi> = Some x \\<longleftrightarrow> \\<Phi>\" \n  \"oassert \\<Phi> = None \\<longleftrightarrow> \\<not>\\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oassert \\<Phi> = Some x) = \\<Phi> &&&\n    (oassert \\<Phi> = None) = (\\<not> \\<Phi>)", "by (cases \\<Phi>) auto"], ["", "text\\<open>The idea is that we want the result of some computation to be @{term \"Some v\"} and the contents of @{term v} to satisfy some property @{term Q}.\\<close>"], ["", "primrec ospec :: \"('a option) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"ospec None _ = False\"\n| \"ospec (Some v) Q = Q v\""], ["", "named_theorems ospec_rules"], ["", "lemma oreturn_rule[ospec_rules]: \"\\<lbrakk> P r \\<rbrakk> \\<Longrightarrow> ospec (Some r) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P r \\<Longrightarrow> ospec (Some r) P", "by simp"], ["", "lemma obind_rule[ospec_rules]: \"\\<lbrakk> ospec m Q; \\<And>r. Q r \\<Longrightarrow> ospec (f r) P \\<rbrakk> \\<Longrightarrow> ospec (m \\<bind> f) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ospec m Q;\n     \\<And>r. Q r \\<Longrightarrow> ospec (f r) P\\<rbrakk>\n    \\<Longrightarrow> ospec (m \\<bind> f) P", "apply (cases m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ospec m Q; \\<And>r. Q r \\<Longrightarrow> ospec (f r) P;\n     m = None\\<rbrakk>\n    \\<Longrightarrow> ospec (m \\<bind> f) P\n 2. \\<And>a.\n       \\<lbrakk>ospec m Q; \\<And>r. Q r \\<Longrightarrow> ospec (f r) P;\n        m = Some a\\<rbrakk>\n       \\<Longrightarrow> ospec (m \\<bind> f) P", "apply (auto split: Option.bind_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ospec_alt: \"ospec m P = (case m of None \\<Rightarrow> False | Some x \\<Rightarrow> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ospec m P =\n    (case m of None \\<Rightarrow> False | Some x \\<Rightarrow> P x)", "by (auto split: option.splits)"], ["", "lemma ospec_bind_simp: \"ospec (m \\<bind> f) P \\<longleftrightarrow> (ospec m (\\<lambda>r. ospec (f r) P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ospec (m \\<bind> f) P = ospec m (\\<lambda>r. ospec (f r) P)", "apply (cases m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = None \\<Longrightarrow>\n    ospec (m \\<bind> f) P = ospec m (\\<lambda>r. ospec (f r) P)\n 2. \\<And>a.\n       m = Some a \\<Longrightarrow>\n       ospec (m \\<bind> f) P = ospec m (\\<lambda>r. ospec (f r) P)", "apply (auto split: Option.bind_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ospec_cons: \n  assumes \"ospec m Q\"\n  assumes \"\\<And>r. Q r \\<Longrightarrow> P r\"\n  shows \"ospec m P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ospec m P", "using assms"], ["proof (prove)\nusing this:\n  ospec m Q\n  Q ?r \\<Longrightarrow> P ?r\n\ngoal (1 subgoal):\n 1. ospec m P", "by (cases m) auto"], ["", "lemma oreturn_synth: \"ospec (Some x) (\\<lambda>r. r=x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ospec (Some x) (\\<lambda>r. r = x)", "by simp"], ["", "lemma ospecD: \"ospec x P \\<Longrightarrow> x = Some y \\<Longrightarrow> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ospec x P; x = Some y\\<rbrakk> \\<Longrightarrow> P y", "by simp"], ["", "lemma ospecD2: \"ospec x P \\<Longrightarrow> \\<exists>y. x = Some y \\<and> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ospec x P \\<Longrightarrow> \\<exists>y. x = Some y \\<and> P y", "by(cases x) simp_all"], ["", "end"]]}