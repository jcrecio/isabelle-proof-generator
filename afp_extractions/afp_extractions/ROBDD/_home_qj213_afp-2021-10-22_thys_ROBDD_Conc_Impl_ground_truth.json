{"file_name": "/home/qj213/afp-2021-10-22/thys/ROBDD/Conc_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ROBDD", "problem_names": ["lemma bdd_exhaust: \"dpm a = dpm b \\<Longrightarrow> dcl a = dcl b \\<Longrightarrow> a = (b :: bdd)\"", "lemma is_bdd_impl_prec: \"precise is_bdd_impl\"", "lemma emptyci_rule[sep_heap_rules]: \"<emp> emptyci <is_bdd_impl emptymi>\\<^sub>t\"", "lemma [sep_heap_rules]: \"tmi' bdd = Some (p,bdd') \n  \\<Longrightarrow> <is_bdd_impl bdd bddi>\n        tci bddi\n      <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi = p)>\"", "lemma [sep_heap_rules]: \"fmi' bdd = Some (p,bdd') \n  \\<Longrightarrow> <is_bdd_impl bdd bddi>\n        fci bddi\n      <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi = p)>\"", "lemma [sep_heap_rules]: \"ifmi' v t e bdd = Some (p, bdd') \\<Longrightarrow>\n  <is_bdd_impl bdd bddi> ifci v t e bddi\n  <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi = p)>\\<^sub>t\"", "lemma destrci_rule[sep_heap_rules]: \"\n  destrmi' n bdd = Some r \\<Longrightarrow>\n  <is_bdd_impl bdd bddi> destrci n bddi\n  <\\<lambda>r'. is_bdd_impl bdd bddi * \\<up>(r' = r)>\"", "lemma [sep_decon_rules]:\n  assumes S: \"mi.case_ifexi fti ffi fii ni bdd = Some r\"\n  assumes [sep_heap_rules]: \n    \"destrmi' ni bdd = Some TD \\<Longrightarrow> fti bdd = Some r \\<Longrightarrow> <is_bdd_impl bdd bddi> ftci <Q>\"\n    \"destrmi' ni bdd = Some FD \\<Longrightarrow> ffi bdd = Some r \\<Longrightarrow> <is_bdd_impl bdd bddi> ffci <Q>\"\n    \"\\<And>v t e. destrmi' ni bdd = Some (IFD v t e) \\<Longrightarrow> fii v t e bdd = Some r\n     \\<Longrightarrow> <is_bdd_impl bdd bddi> fici v t e <Q> \"\n  shows \"<is_bdd_impl bdd bddi> case_ifexici ftci ffci fici ni bddi <Q>\"", "lemma [sep_heap_rules]:\n  assumes \"mi.restrict_top_impl p var val bdd = Some (r,bdd')\"\n  shows \"<is_bdd_impl bdd bddi> restrict_topci p var val bddi\n          <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up>(ri = r)>\"", "lemma [sep_heap_rules]:\n  assumes \"mi.lowest_tops_impl es bdd = Some (r,bdd')\"\n  shows \"<is_bdd_impl bdd bddi> lowest_topsci es bddi\n  <\\<lambda>(ri). is_bdd_impl bdd bddi * \\<up>(ri = r \\<and> bdd'=bdd)>\"", "lemma iteci_rule: \"\n  ( mi.ite_impl i t e bdd = Some (p,bdd'))  \\<longrightarrow>\n  <is_bdd_impl bdd bddi>\n    iteci i t e bddi\n  <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi=p )>\\<^sub>t\"", "lemma param_optci_rule: \"\n  ( mi.param_opt_impl i t e bdd = Some (p,bdd'))  \\<Longrightarrow>\n  <is_bdd_impl bdd bddi> \n    param_optci i t e bddi \n  <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi=p)>\\<^sub>t\"", "lemma bdd_hm_lookup_rule: \"\n  (dcl bdd (i,t,e) = p) \\<Longrightarrow>\n  <is_bdd_impl bdd bddi> \n    hm_lookup (i, t, e) (dcli bddi)\n  <\\<lambda>(pi). is_bdd_impl bdd bddi * \\<up>(pi = p)>\\<^sub>t\"", "lemma bdd_hm_update_rule'[sep_heap_rules]:\n  \"<is_bdd_impl bdd bddi> \n    hm_update k v (dcli bddi)\n  <\\<lambda>r. is_bdd_impl (updS bdd k v) (dcli_update (const r) bddi) * true>\"", "lemma iteci_lu_code[code_unfold]: \"iteci_lu i t e s = iteci_lu_code i t e s\"", "lemma iteci_lu_rule: \"\n  ( mi.ite_impl_lu i t e bdd = Some (p,bdd'))  \\<longrightarrow>\n  <is_bdd_impl bdd bddi> \n    iteci_lu i t e bddi \n  <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi=p )>\\<^sub>t\"", "lemma \"liftM (map f) (sequence l) = sequence (map (liftM f) l)\""], "translations": [["", "lemma bdd_exhaust: \"dpm a = dpm b \\<Longrightarrow> dcl a = dcl b \\<Longrightarrow> a = (b :: bdd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dpm a = dpm b; dcl a = dcl b\\<rbrakk> \\<Longrightarrow> a = b", "by simp"], ["", "instantiation prod :: (default, default) default\nbegin"], ["", "definition \"default_prod :: ('a \\<times> 'b) \\<equiv> (default, default)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, default_class)", ".."], ["", "end"], ["", "(* can be found in \"~~/src/HOL/Proofs/Extraction/Greatest_Common_Divisor\" or \"~~/src/HOL/Proofs/Lambda/WeakNorm\" *)"], ["", "instantiation nat :: default\nbegin"], ["", "definition \"default_nat \\<equiv> 0 :: nat\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, default_class)", ".."], ["", "end"], ["", "definition \"is_bdd_impl (bdd::bdd) (bddi::bddi) = is_pointermap_impl (dpm bdd) (dpmi bddi) * is_hashmap (dcl bdd) (dcli bddi)\""], ["", "lemma is_bdd_impl_prec: \"precise is_bdd_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_bdd_impl", "apply(rule preciseI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_bdd_impl a p * F \\<and>\\<^sub>A\n       is_bdd_impl a' p * F' \\<Longrightarrow>\n       a = a'", "apply(unfold is_bdd_impl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) * is_hashmap (dcl a) (dcli p) *\n       F \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * is_hashmap (dcl a') (dcli p) *\n       F' \\<Longrightarrow>\n       a = a'", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F'.\n       (aa, b) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) * is_hashmap (dcl a) (dcli p) *\n       F \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * is_hashmap (dcl a') (dcli p) *\n       F' \\<Longrightarrow>\n       a = a'", "apply(rename_tac a a' x y p F F')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) * is_hashmap (dcl a) (dcli p) *\n       F \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * is_hashmap (dcl a') (dcli p) *\n       F' \\<Longrightarrow>\n       a = a'", "apply(rule bdd_exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) * is_hashmap (dcl a) (dcli p) *\n       F \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * is_hashmap (dcl a') (dcli p) *\n       F' \\<Longrightarrow>\n       dpm a = dpm a'\n 2. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) * is_hashmap (dcl a) (dcli p) *\n       F \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * is_hashmap (dcl a') (dcli p) *\n       F' \\<Longrightarrow>\n       dcl a = dcl a'", "apply(rule_tac p = \"dpmi p\" and h = \"(x,y)\" in preciseD[OF is_pointermap_impl_prec])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) * is_hashmap (dcl a) (dcli p) *\n       F \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * is_hashmap (dcl a') (dcli p) *\n       F' \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) *\n       ?F5 a a' x y p F F' \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * ?F'5 a a' x y p F F'\n 2. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) * is_hashmap (dcl a) (dcli p) *\n       F \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * is_hashmap (dcl a') (dcli p) *\n       F' \\<Longrightarrow>\n       dcl a = dcl a'", "apply(unfold star_aci(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) *\n       (is_hashmap (dcl a) (dcli p) * F) \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) *\n       (is_hashmap (dcl a') (dcli p) * F') \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) *\n       ?F5 a a' x y p F F' \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * ?F'5 a a' x y p F F'\n 2. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) *\n       (is_hashmap (dcl a) (dcli p) * F) \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) *\n       (is_hashmap (dcl a') (dcli p) * F') \\<Longrightarrow>\n       dcl a = dcl a'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) *\n       (is_hashmap (dcl a) (dcli p) * F) \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) *\n       (is_hashmap (dcl a') (dcli p) * F') \\<Longrightarrow>\n       dcl a = dcl a'", "apply(rule_tac p = \"dcli p\" and h = \"(x,y)\" in preciseD[OF is_hashmap_prec])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) *\n       (is_hashmap (dcl a) (dcli p) * F) \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) *\n       (is_hashmap (dcl a') (dcli p) * F') \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_hashmap (dcl a) (dcli p) * ?F8 a a' x y p F F' \\<and>\\<^sub>A\n       is_hashmap (dcl a') (dcli p) * ?F'8 a a' x y p F F'", "apply(simp only: star_aci(2)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) *\n       (F * is_hashmap (dcl a) (dcli p)) \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) *\n       (F' * is_hashmap (dcl a') (dcli p)) \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_hashmap (dcl a) (dcli p) * ?F8 a a' x y p F F' \\<and>\\<^sub>A\n       is_hashmap (dcl a') (dcli p) * ?F'8 a a' x y p F F'", "apply(simp only: star_aci(1)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) * F *\n       is_hashmap (dcl a) (dcli p) \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * F' *\n       is_hashmap (dcl a') (dcli p) \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_hashmap (dcl a) (dcli p) * ?F8 a a' x y p F F' \\<and>\\<^sub>A\n       is_hashmap (dcl a') (dcli p) * ?F'8 a a' x y p F F'", "(* black unfold magic *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x y p F F'.\n       (x, y) \\<Turnstile>\n       is_pointermap_impl (dpm a) (dpmi p) * F *\n       is_hashmap (dcl a) (dcli p) \\<and>\\<^sub>A\n       is_pointermap_impl (dpm a') (dpmi p) * F' *\n       is_hashmap (dcl a') (dcli p) \\<Longrightarrow>\n       (x, y) \\<Turnstile>\n       is_hashmap (dcl a) (dcli p) * ?F8 a a' x y p F F' \\<and>\\<^sub>A\n       is_hashmap (dcl a') (dcli p) * ?F'8 a a' x y p F F'", "apply(simp only: star_aci(2)[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "(* This proof is exactly the same as for pointermap. One could make a rule from it. *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"emptyci :: bddi Heap \\<equiv> do { ep \\<leftarrow> pointermap_empty; ehm \\<leftarrow> hm_new; return \\<lparr>dpmi=ep, dcli=ehm\\<rparr> }\""], ["", "definition \"tci bdd \\<equiv> return (1::nat,bdd::bddi)\""], ["", "definition \"fci bdd \\<equiv> return (0::nat,bdd::bddi)\""], ["", "definition \"ifci v t e bdd \\<equiv> (if t = e then return (t, bdd) else do {\n                              (p,u) \\<leftarrow> pointermap_getmki (v, t, e) (dpmi bdd);\n                              return (Suc (Suc p), dpmi_update (const u) bdd)\n})\""], ["", "definition destrci :: \"nat \\<Rightarrow> bddi \\<Rightarrow> (nat, nat) IFEXD Heap\" where\n\"destrci n bdd \\<equiv> (case n of\n  0 \\<Rightarrow> return FD |\n  Suc 0 \\<Rightarrow> return TD |\n  Suc (Suc p) \\<Rightarrow> pm_pthi (dpmi bdd) p \\<bind> (\\<lambda>(v,t,e). return (IFD v t e)))\""], ["", "term \"mi.les\""], ["", "lemma emptyci_rule[sep_heap_rules]: \"<emp> emptyci <is_bdd_impl emptymi>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> emptyci <is_bdd_impl emptymi>\\<^sub>t", "by(sep_auto simp: is_bdd_impl_def emptyci_def emptymi_def)"], ["", "lemma [sep_heap_rules]: \"tmi' bdd = Some (p,bdd') \n  \\<Longrightarrow> <is_bdd_impl bdd bddi>\n        tci bddi\n      <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi = p)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tmi' bdd = Some (p, bdd') \\<Longrightarrow>\n    <is_bdd_impl bdd bddi> tci bddi\n    <\\<lambda>(pi, bddi'). is_bdd_impl bdd' bddi' * \\<up> (pi = p)>", "by (sep_auto simp: tci_def tmi'_def split: Option.bind_splits)"], ["", "lemma [sep_heap_rules]: \"fmi' bdd = Some (p,bdd') \n  \\<Longrightarrow> <is_bdd_impl bdd bddi>\n        fci bddi\n      <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi = p)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmi' bdd = Some (p, bdd') \\<Longrightarrow>\n    <is_bdd_impl bdd bddi> fci bddi\n    <\\<lambda>(pi, bddi'). is_bdd_impl bdd' bddi' * \\<up> (pi = p)>", "by(sep_auto simp: fci_def fmi'_def split: Option.bind_splits)"], ["", "lemma [sep_heap_rules]: \"ifmi' v t e bdd = Some (p, bdd') \\<Longrightarrow>\n  <is_bdd_impl bdd bddi> ifci v t e bddi\n  <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi = p)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ifmi' v t e bdd = Some (p, bdd') \\<Longrightarrow>\n    <is_bdd_impl bdd\n      bddi> ifci v t e\n             bddi <\\<lambda>r.\n                      case r of\n                      (pi, bddi') \\<Rightarrow>\n                        is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t", "apply(clarsimp simp: is_bdd_impl_def ifmi'_def simp del: ifmi.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. oassert\n     (bdd_sane bdd \\<and>\n      bdd_node_valid bdd t \\<and> bdd_node_valid bdd e) \\<bind>\n    (\\<lambda>_. Some (ifmi v t e bdd)) =\n    Some (p, bdd') \\<Longrightarrow>\n    <is_pointermap_impl (dpm bdd) (dpmi bddi) *\n     is_hashmap (dcl bdd)\n      (dcli\n        bddi)> ifci v t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_pointermap_impl (dpm bdd') (dpmi bddi') *\n                           is_hashmap (dcl bdd') (dcli bddi') *\n                           \\<up> (pi = p)>\\<^sub>t", "by (sep_auto simp: ifci_def apfst_def map_prod_def is_bdd_impl_def bdd_sane_def\n               split: prod.splits if_splits Option.bind_splits)"], ["", "lemma destrci_rule[sep_heap_rules]: \"\n  destrmi' n bdd = Some r \\<Longrightarrow>\n  <is_bdd_impl bdd bddi> destrci n bddi\n  <\\<lambda>r'. is_bdd_impl bdd bddi * \\<up>(r' = r)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. destrmi' n bdd = Some r \\<Longrightarrow>\n    <is_bdd_impl bdd bddi> destrci n bddi\n    <\\<lambda>r'. is_bdd_impl bdd bddi * \\<up> (r' = r)>", "unfolding destrmi'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. oassert (bdd_sane bdd \\<and> bdd_node_valid bdd n) \\<bind>\n    (\\<lambda>_. Some (destrmi n bdd)) =\n    Some r \\<Longrightarrow>\n    <is_bdd_impl bdd bddi> destrci n bddi\n    <\\<lambda>r'. is_bdd_impl bdd bddi * \\<up> (r' = r)>", "apply (clarsimp split: Option.bind_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = destrmi n bdd; bdd_sane bdd; bdd_node_valid bdd n\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd bddi> destrci n bddi\n                      <\\<lambda>r'.\n                          is_bdd_impl bdd bddi * \\<up> (r' = destrmi n bdd)>", "apply(cases \"(n, bdd)\" rule: destrmi.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>bdda.\n       \\<lbrakk>r = destrmi n bdd; bdd_sane bdd; bdd_node_valid bdd n;\n        (n, bdd) = (0, bdda)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi> destrci n bddi\n                         <\\<lambda>r'.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (r' = destrmi n bdd)>\n 2. \\<And>bdda.\n       \\<lbrakk>r = destrmi n bdd; bdd_sane bdd; bdd_node_valid bdd n;\n        (n, bdd) = (Suc 0, bdda)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi> destrci n bddi\n                         <\\<lambda>r'.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (r' = destrmi n bdd)>\n 3. \\<And>na bdda.\n       \\<lbrakk>r = destrmi n bdd; bdd_sane bdd; bdd_node_valid bdd n;\n        (n, bdd) = (Suc (Suc na), bdda)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi> destrci n bddi\n                         <\\<lambda>r'.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (r' = destrmi n bdd)>", "by (sep_auto simp: destrci_def bdd_node_valid_def is_bdd_impl_def ifexd_valid_def bdd_sane_def\n                 dest: p_valid_RmiI)+"], ["", "term mi.restrict_top_impl"], ["", "thm mi.case_ifexi_def"], ["", "definition \"case_ifexici fti ffi fii ni bddi \\<equiv> do {\n  dest \\<leftarrow> destrci ni bddi;\n  case dest of TD \\<Rightarrow> fti | FD \\<Rightarrow> ffi | IFD v ti ei \\<Rightarrow> fii v ti ei\n}\""], ["", "lemma [sep_decon_rules]:\n  assumes S: \"mi.case_ifexi fti ffi fii ni bdd = Some r\"\n  assumes [sep_heap_rules]: \n    \"destrmi' ni bdd = Some TD \\<Longrightarrow> fti bdd = Some r \\<Longrightarrow> <is_bdd_impl bdd bddi> ftci <Q>\"\n    \"destrmi' ni bdd = Some FD \\<Longrightarrow> ffi bdd = Some r \\<Longrightarrow> <is_bdd_impl bdd bddi> ffci <Q>\"\n    \"\\<And>v t e. destrmi' ni bdd = Some (IFD v t e) \\<Longrightarrow> fii v t e bdd = Some r\n     \\<Longrightarrow> <is_bdd_impl bdd bddi> fici v t e <Q> \"\n  shows \"<is_bdd_impl bdd bddi> case_ifexici ftci ffci fici ni bddi <Q>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi> case_ifexici ftci ffci fici ni bddi <Q>", "using S"], ["proof (prove)\nusing this:\n  mi.case_ifexi fti ffi fii ni bdd = Some r\n\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi> case_ifexici ftci ffci fici ni bddi <Q>", "unfolding mi.case_ifexi_def"], ["proof (prove)\nusing this:\n  destrmi' ni bdd \\<bind>\n  (\\<lambda>dest.\n      case dest of TD \\<Rightarrow> fti bdd | FD \\<Rightarrow> ffi bdd\n      | IFD v ti ei \\<Rightarrow> fii v ti ei bdd) =\n  Some r\n\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi> case_ifexici ftci ffci fici ni bddi <Q>", "apply (clarsimp split: Option.bind_splits IFEXD.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>destrmi' ni bdd = Some TD; fti bdd = Some r\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd bddi>\n                      case_ifexici ftci ffci fici ni bddi <Q>\n 2. \\<lbrakk>destrmi' ni bdd = Some FD; ffi bdd = Some r\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd bddi>\n                      case_ifexici ftci ffci fici ni bddi <Q>\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>destrmi' ni bdd = Some (IFD x31 x32 x33);\n        fii x31 x32 x33 bdd = Some r\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi>\n                         case_ifexici ftci ffci fici ni bddi <Q>", "by (sep_auto simp: case_ifexici_def)+"], ["", "definition \"restrict_topci p vr vl bdd = \n  case_ifexici\n    (return p)\n    (return p)\n    (\\<lambda>v te ee. return (if v = vr then (if vl then te else ee) else p))\n    p bdd\""], ["", "lemma [sep_heap_rules]:\n  assumes \"mi.restrict_top_impl p var val bdd = Some (r,bdd')\"\n  shows \"<is_bdd_impl bdd bddi> restrict_topci p var val bddi\n          <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up>(ri = r)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi> restrict_topci p var val bddi\n    <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up> (ri = r)>", "using assms"], ["proof (prove)\nusing this:\n  mi.restrict_top_impl p var val bdd = Some (r, bdd')\n\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi> restrict_topci p var val bddi\n    <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up> (ri = r)>", "unfolding mi.restrict_top_impl_def restrict_topci_def"], ["proof (prove)\nusing this:\n  mi.case_ifexi (\\<lambda>s. Some (p, s)) (\\<lambda>s. Some (p, s))\n   (\\<lambda>v te ee s.\n       Some (if v = var then if val then te else ee else p, s))\n   p bdd =\n  Some (r, bdd')\n\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi>\n    case_ifexici (return p) (return p)\n     (\\<lambda>v te ee.\n         return (if v = var then if val then te else ee else p))\n     p bddi\n    <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up> (ri = r)>", "by sep_auto"], ["", "fun lowest_topsci where\n\"lowest_topsci [] s = return None\" |\n\"lowest_topsci (e#es) s = \n    case_ifexici \n      (lowest_topsci es s) \n      (lowest_topsci es s) \n      (\\<lambda>v t e. do {\n      (rec) \\<leftarrow> lowest_topsci es s;\n        (case rec of \n          Some u \\<Rightarrow> return ((Some (min u v))) | \n          None \\<Rightarrow> return ((Some v)))\n       }) e s\""], ["", "declare lowest_topsci.simps[simp del]"], ["", "lemma [sep_heap_rules]:\n  assumes \"mi.lowest_tops_impl es bdd = Some (r,bdd')\"\n  shows \"<is_bdd_impl bdd bddi> lowest_topsci es bddi\n  <\\<lambda>(ri). is_bdd_impl bdd bddi * \\<up>(ri = r \\<and> bdd'=bdd)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi> lowest_topsci es bddi\n    <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up> (ri = r \\<and> bdd' = bdd)>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi> lowest_topsci es bddi\n    <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up> (ri = r \\<and> bdd' = bdd)>", "note [simp] = lowest_topsci.simps mi.lowest_tops_impl.simps"], ["proof (state)\nthis:\n  lowest_topsci [] ?s = return None\n  lowest_topsci (?e # ?es) ?s =\n  case_ifexici (lowest_topsci ?es ?s) (lowest_topsci ?es ?s)\n   (\\<lambda>v t e.\n       lowest_topsci ?es ?s \\<bind>\n       case_option (return (Some v)) (\\<lambda>u. return (Some (min u v))))\n   ?e ?s\n  mi.lowest_tops_impl [] ?s = Some (None, ?s)\n  mi.lowest_tops_impl (?e # ?es) ?s =\n  mi.case_ifexi (mi.lowest_tops_impl ?es) (mi.lowest_tops_impl ?es)\n   (\\<lambda>v t e s.\n       mi.lowest_tops_impl ?es s \\<bind>\n       (\\<lambda>(rec, s).\n           case rec of None \\<Rightarrow> Some (Some v, s)\n           | Some u \\<Rightarrow> Some (Some (min u v), s)))\n   ?e ?s\n\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi> lowest_topsci es bddi\n    <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up> (ri = r \\<and> bdd' = bdd)>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi> lowest_topsci es bddi\n    <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up> (ri = r \\<and> bdd' = bdd)>", "using assms"], ["proof (prove)\nusing this:\n  mi.lowest_tops_impl es bdd = Some (r, bdd')\n\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd bddi> lowest_topsci es bddi\n    <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up> (ri = r \\<and> bdd' = bdd)>", "apply (induction es arbitrary: bdd r bdd' bddi)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bdd r bdd' bddi.\n       mi.lowest_tops_impl [] bdd = Some (r, bdd') \\<Longrightarrow>\n       <is_bdd_impl bdd bddi> lowest_topsci [] bddi\n       <\\<lambda>ri.\n           is_bdd_impl bdd bddi * \\<up> (ri = r \\<and> bdd' = bdd)>\n 2. \\<And>a es bdd r bdd' bddi.\n       \\<lbrakk>\\<And>bdd r bdd' bddi.\n                   mi.lowest_tops_impl es bdd =\n                   Some (r, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd bddi> lowest_topsci es bddi\n                   <\\<lambda>ri.\n                       is_bdd_impl bdd bddi *\n                       \\<up> (ri = r \\<and> bdd' = bdd)>;\n        mi.lowest_tops_impl (a # es) bdd = Some (r, bdd')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi> lowest_topsci (a # es) bddi\n                         <\\<lambda>ri.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (ri = r \\<and> bdd' = bdd)>", "apply (sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a es bdd r bdd' bddi.\n       \\<lbrakk>\\<And>bdd r bdd' bddi.\n                   mi.lowest_tops_impl es bdd =\n                   Some (r, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd bddi> lowest_topsci es bddi\n                   <\\<lambda>ri.\n                       is_bdd_impl bdd bddi *\n                       \\<up> (ri = r \\<and> bdd' = bdd)>;\n        mi.lowest_tops_impl (a # es) bdd = Some (r, bdd')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi> lowest_topsci (a # es) bddi\n                         <\\<lambda>ri.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (ri = r \\<and> bdd' = bdd)>", "(* Unfortunately, we have to split on destrmi'-cases manually, else sep-aut introduces schematic before case-split is done *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a es bdd r bdd' bddi.\n       \\<lbrakk>\\<And>bdd r bdd' bddi.\n                   mi.lowest_tops_impl es bdd =\n                   Some (r, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd bddi> lowest_topsci es bddi\n                   <\\<lambda>ri.\n                       is_bdd_impl bdd bddi *\n                       \\<up> (ri = r \\<and> bdd' = bdd)>;\n        mi.lowest_tops_impl (a # es) bdd = Some (r, bdd')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi> lowest_topsci (a # es) bddi\n                         <\\<lambda>ri.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (ri = r \\<and> bdd' = bdd)>", "apply (clarsimp simp: mi.case_ifexi_def split: Option.bind_splits IFEXD.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a es bdd r bdd' bddi.\n       \\<lbrakk>\\<And>bdd r bdd' bddi.\n                   mi.lowest_tops_impl es bdd =\n                   Some (r, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd bddi> lowest_topsci es bddi\n                   <\\<lambda>ri.\n                       is_bdd_impl bdd bddi *\n                       \\<up> (ri = r \\<and> bdd' = bdd)>;\n        destrmi' a bdd = Some TD;\n        mi.lowest_tops_impl es bdd = Some (r, bdd')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi>\n                         case_ifexici (lowest_topsci es bddi)\n                          (lowest_topsci es bddi)\n                          (\\<lambda>v t e.\n                              lowest_topsci es bddi \\<bind>\n                              case_option (return (Some v))\n                               (\\<lambda>u. return (Some (min u v))))\n                          a bddi\n                         <\\<lambda>ri.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (ri = r \\<and> bdd' = bdd)>\n 2. \\<And>a es bdd r bdd' bddi.\n       \\<lbrakk>\\<And>bdd r bdd' bddi.\n                   mi.lowest_tops_impl es bdd =\n                   Some (r, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd bddi> lowest_topsci es bddi\n                   <\\<lambda>ri.\n                       is_bdd_impl bdd bddi *\n                       \\<up> (ri = r \\<and> bdd' = bdd)>;\n        destrmi' a bdd = Some FD;\n        mi.lowest_tops_impl es bdd = Some (r, bdd')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi>\n                         case_ifexici (lowest_topsci es bddi)\n                          (lowest_topsci es bddi)\n                          (\\<lambda>v t e.\n                              lowest_topsci es bddi \\<bind>\n                              case_option (return (Some v))\n                               (\\<lambda>u. return (Some (min u v))))\n                          a bddi\n                         <\\<lambda>ri.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (ri = r \\<and> bdd' = bdd)>\n 3. \\<And>a es bdd r bdd' bddi x31 x32 x33 aa b.\n       \\<lbrakk>\\<And>bdd r bdd' bddi.\n                   mi.lowest_tops_impl es bdd =\n                   Some (r, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd bddi> lowest_topsci es bddi\n                   <\\<lambda>ri.\n                       is_bdd_impl bdd bddi *\n                       \\<up> (ri = r \\<and> bdd' = bdd)>;\n        destrmi' a bdd = Some (IFD x31 x32 x33);\n        mi.lowest_tops_impl es bdd = Some (aa, b);\n        (case aa of None \\<Rightarrow> Some (Some x31, b)\n         | Some u \\<Rightarrow> Some (Some (min u x31), b)) =\n        Some (r, bdd')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi>\n                         case_ifexici (lowest_topsci es bddi)\n                          (lowest_topsci es bddi)\n                          (\\<lambda>v t e.\n                              lowest_topsci es bddi \\<bind>\n                              case_option (return (Some v))\n                               (\\<lambda>u. return (Some (min u v))))\n                          a bddi\n                         <\\<lambda>ri.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (ri = r \\<and> bdd' = bdd)>", "apply (sep_auto simp: mi.case_ifexi_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a es bdd r bdd' bddi.\n       \\<lbrakk>\\<And>bdd r bdd' bddi.\n                   mi.lowest_tops_impl es bdd =\n                   Some (r, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd bddi> lowest_topsci es bddi\n                   <\\<lambda>ri.\n                       is_bdd_impl bdd bddi *\n                       \\<up> (ri = r \\<and> bdd' = bdd)>;\n        destrmi' a bdd = Some FD;\n        mi.lowest_tops_impl es bdd = Some (r, bdd')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi>\n                         case_ifexici (lowest_topsci es bddi)\n                          (lowest_topsci es bddi)\n                          (\\<lambda>v t e.\n                              lowest_topsci es bddi \\<bind>\n                              case_option (return (Some v))\n                               (\\<lambda>u. return (Some (min u v))))\n                          a bddi\n                         <\\<lambda>ri.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (ri = r \\<and> bdd' = bdd)>\n 2. \\<And>a es bdd r bdd' bddi x31 x32 x33 aa b.\n       \\<lbrakk>\\<And>bdd r bdd' bddi.\n                   mi.lowest_tops_impl es bdd =\n                   Some (r, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd bddi> lowest_topsci es bddi\n                   <\\<lambda>ri.\n                       is_bdd_impl bdd bddi *\n                       \\<up> (ri = r \\<and> bdd' = bdd)>;\n        destrmi' a bdd = Some (IFD x31 x32 x33);\n        mi.lowest_tops_impl es bdd = Some (aa, b);\n        (case aa of None \\<Rightarrow> Some (Some x31, b)\n         | Some u \\<Rightarrow> Some (Some (min u x31), b)) =\n        Some (r, bdd')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi>\n                         case_ifexici (lowest_topsci es bddi)\n                          (lowest_topsci es bddi)\n                          (\\<lambda>v t e.\n                              lowest_topsci es bddi \\<bind>\n                              case_option (return (Some v))\n                               (\\<lambda>u. return (Some (min u v))))\n                          a bddi\n                         <\\<lambda>ri.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (ri = r \\<and> bdd' = bdd)>", "apply (sep_auto simp: mi.case_ifexi_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a es bdd r bdd' bddi x31 x32 x33 aa b.\n       \\<lbrakk>\\<And>bdd r bdd' bddi.\n                   mi.lowest_tops_impl es bdd =\n                   Some (r, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd bddi> lowest_topsci es bddi\n                   <\\<lambda>ri.\n                       is_bdd_impl bdd bddi *\n                       \\<up> (ri = r \\<and> bdd' = bdd)>;\n        destrmi' a bdd = Some (IFD x31 x32 x33);\n        mi.lowest_tops_impl es bdd = Some (aa, b);\n        (case aa of None \\<Rightarrow> Some (Some x31, b)\n         | Some u \\<Rightarrow> Some (Some (min u x31), b)) =\n        Some (r, bdd')\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd bddi>\n                         case_ifexici (lowest_topsci es bddi)\n                          (lowest_topsci es bddi)\n                          (\\<lambda>v t e.\n                              lowest_topsci es bddi \\<bind>\n                              case_option (return (Some v))\n                               (\\<lambda>u. return (Some (min u v))))\n                          a bddi\n                         <\\<lambda>ri.\n                             is_bdd_impl bdd bddi *\n                             \\<up> (ri = r \\<and> bdd' = bdd)>", "apply (sep_auto simp: mi.case_ifexi_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <is_bdd_impl bdd bddi> lowest_topsci es bddi\n  <\\<lambda>ri. is_bdd_impl bdd bddi * \\<up> (ri = r \\<and> bdd' = bdd)>\n\ngoal:\nNo subgoals!", "qed"], ["", "partial_function(heap) iteci where\n\"iteci i t e s = do {\n  (lt) \\<leftarrow> lowest_topsci [i, t, e] s;\n  case lt of\n    Some a \\<Rightarrow> do {\n      ti \\<leftarrow> restrict_topci i a True s;\n      tt \\<leftarrow> restrict_topci t a True s;\n      te \\<leftarrow> restrict_topci e a True s;\n      fi \\<leftarrow> restrict_topci i a False s;\n      ft \\<leftarrow> restrict_topci t a False s;\n      fe \\<leftarrow> restrict_topci e a False s;\n      (tb,s') \\<leftarrow> iteci ti tt te s;\n      (fb,s'') \\<leftarrow> iteci fi ft fe s';\n      (ifci a tb fb s'')\n     }\n  | None \\<Rightarrow> do {\n    case_ifexici (return (t,s)) (return (e,s)) (\\<lambda>_ _ _. raise STR ''Cannot happen'') i s\n   }\n  }\""], ["", "declare iteci.simps[code]"], ["", "lemma iteci_rule: \"\n  ( mi.ite_impl i t e bdd = Some (p,bdd'))  \\<longrightarrow>\n  <is_bdd_impl bdd bddi>\n    iteci i t e bddi\n  <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi=p )>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mi.ite_impl i t e bdd = Some (p, bdd') \\<longrightarrow>\n    <is_bdd_impl bdd\n      bddi> iteci i t e\n             bddi <\\<lambda>r.\n                      case r of\n                      (pi, bddi') \\<Rightarrow>\n                        is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t", "apply (induction arbitrary: i t e bddi bdd p bdd' rule: mi.ite_impl.fixp_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. option.admissible\n     (\\<lambda>ite_impl.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            curry (curry (curry ite_impl)) x xa xaa xaaaa =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)\n 2. \\<And>i t e bddi bdd p bdd'.\n       None = Some (p, bdd') \\<longrightarrow>\n       <is_bdd_impl bdd\n         bddi> iteci i t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t\n 3. \\<And>s i t e bddi bdd p bdd'.\n       (\\<And>i t e bddi bdd p bdd'.\n           s i t e bdd = Some (p, bdd') \\<longrightarrow>\n           <is_bdd_impl bdd\n             bddi> iteci i t e\n                    bddi <\\<lambda>r.\n                             case r of\n                             (pi, bddi') \\<Rightarrow>\n                               is_bdd_impl bdd' bddi' *\n                               \\<up> (pi = p)>\\<^sub>t) \\<Longrightarrow>\n       mi.lowest_tops_impl [i, t, e] bdd \\<bind>\n       (\\<lambda>(lt, uu_).\n           case lt of\n           None \\<Rightarrow>\n             mi.case_ifexi (\\<lambda>_. Some (t, bdd))\n              (\\<lambda>_. Some (e, bdd)) (\\<lambda>_ _ _. Map.empty) i bdd\n           | Some a \\<Rightarrow>\n               mi.restrict_top_impl i a True bdd \\<bind>\n               (\\<lambda>(ti, uu_).\n                   mi.restrict_top_impl t a True bdd \\<bind>\n                   (\\<lambda>(tt, uu_).\n                       mi.restrict_top_impl e a True bdd \\<bind>\n                       (\\<lambda>(te, uu_).\n                           mi.restrict_top_impl i a False bdd \\<bind>\n                           (\\<lambda>(fi, uu_).\n                               mi.restrict_top_impl t a False bdd \\<bind>\n                               (\\<lambda>(ft, uu_).\n                                   mi.restrict_top_impl e a False\n                                    bdd \\<bind>\n                                   (\\<lambda>(fe, uu_).\n s ti tt te bdd \\<bind>\n (\\<lambda>(tb, sa).\n     s fi ft fe sa \\<bind> (\\<lambda>(x, y). ifmi' a tb x y))))))))) =\n       Some (p, bdd') \\<longrightarrow>\n       <is_bdd_impl bdd\n         bddi> iteci i t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>ite_impl.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            curry (curry (curry ite_impl)) x xa xaa xaaaa =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>ite_impl.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            ite_impl (((x, xa), xaa), xaaaa) =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)", "(* Warning: Dragons ahead! *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>ite_impl.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            ite_impl (((x, xa), xaa), xaaaa) =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)", "using option_admissible[where P=\n             \"\\<lambda>(((x1,x2),x3),x4) (r1,r2). \\<forall>bddi. \n              <is_bdd_impl x4 bddi> \n                iteci x1 x2 x3 bddi  \n              <\\<lambda>r. case r of (p\\<^sub>i, bddi') \\<Rightarrow> is_bdd_impl r2 bddi' * \\<up> (p\\<^sub>i = r1)>\\<^sub>t\"]"], ["proof (prove)\nusing this:\n  option.admissible\n   (\\<lambda>f.\n       \\<forall>x y.\n          f x = Some y \\<longrightarrow>\n          (case x of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (x1, x2) \\<Rightarrow>\n                   \\<lambda>x3 x4 (r1, r2).\n                      \\<forall>bddi.\n                         <is_bdd_impl x4\n                           bddi> iteci x1 x2 x3\n                                  bddi <\\<lambda>r.\n     case r of\n     (p\\<^sub>i, bddi') \\<Rightarrow>\n       is_bdd_impl r2 bddi' * \\<up> (p\\<^sub>i = r1)>\\<^sub>t)\n                 xa)\n              xa)\n           y)\n\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>ite_impl.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            ite_impl (((x, xa), xaa), xaaaa) =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>f.\n         \\<forall>a b ba baa aa baaa.\n            f (((a, b), ba), baa) = Some (aa, baaa) \\<longrightarrow>\n            (\\<forall>bddi.\n                <is_bdd_impl baa\n                  bddi> iteci a b ba\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (p\\<^sub>i, bddi') \\<Rightarrow>\n                                    is_bdd_impl baaa bddi' *\n                                    \\<up>\n                                     (p\\<^sub>i =\naa)>\\<^sub>t)) \\<Longrightarrow>\n    option.admissible\n     (\\<lambda>ite_impl.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            ite_impl (((x, xa), xaa), xaaaa) =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)", "apply (fo_rule subst[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. option.admissible\n     (\\<lambda>f.\n         \\<forall>a b ba baa aa baaa.\n            f (((a, b), ba), baa) = Some (aa, baaa) \\<longrightarrow>\n            (\\<forall>bddi.\n                <is_bdd_impl baa\n                  bddi> iteci a b ba\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (p\\<^sub>i, bddi') \\<Rightarrow>\n                                    is_bdd_impl baaa bddi' *\n                                    \\<up>\n                                     (p\\<^sub>i =\naa)>\\<^sub>t)) \\<Longrightarrow>\n    option.admissible ?s8\n 2. option.admissible\n     (\\<lambda>f.\n         \\<forall>a b ba baa aa baaa.\n            f (((a, b), ba), baa) = Some (aa, baaa) \\<longrightarrow>\n            (\\<forall>bddi.\n                <is_bdd_impl baa\n                  bddi> iteci a b ba\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (p\\<^sub>i, bddi') \\<Rightarrow>\n                                    is_bdd_impl baaa bddi' *\n                                    \\<up>\n                                     (p\\<^sub>i =\naa)>\\<^sub>t)) \\<Longrightarrow>\n    ?s8 =\n    (\\<lambda>ite_impl.\n        \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n           ite_impl (((x, xa), xaa), xaaaa) =\n           Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n           <is_bdd_impl xaaaa\n             xaaa> iteci x xa xaa\n                    xaaa <\\<lambda>r.\n                             case r of\n                             (pi, bddi') \\<Rightarrow>\n                               is_bdd_impl xaaaaaa bddi' *\n                               \\<up> (pi = xaaaaa)>\\<^sub>t)", "apply (assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>f.\n         \\<forall>a b ba baa aa baaa.\n            f (((a, b), ba), baa) = Some (aa, baaa) \\<longrightarrow>\n            (\\<forall>bddi.\n                <is_bdd_impl baa\n                  bddi> iteci a b ba\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (p\\<^sub>i, bddi') \\<Rightarrow>\n                                    is_bdd_impl baaa bddi' *\n                                    \\<up>\n                                     (p\\<^sub>i =\naa)>\\<^sub>t)) \\<Longrightarrow>\n    (\\<lambda>f.\n        \\<forall>a b ba baa aa baaa.\n           f (((a, b), ba), baa) = Some (aa, baaa) \\<longrightarrow>\n           (\\<forall>bddi.\n               <is_bdd_impl baa\n                 bddi> iteci a b ba\n                        bddi <\\<lambda>r.\n                                 case r of\n                                 (p\\<^sub>i, bddi') \\<Rightarrow>\n                                   is_bdd_impl baaa bddi' *\n                                   \\<up> (p\\<^sub>i = aa)>\\<^sub>t)) =\n    (\\<lambda>ite_impl.\n        \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n           ite_impl (((x, xa), xaa), xaaaa) =\n           Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n           <is_bdd_impl xaaaa\n             xaaa> iteci x xa xaa\n                    xaaa <\\<lambda>r.\n                             case r of\n                             (pi, bddi') \\<Rightarrow>\n                               is_bdd_impl xaaaaaa bddi' *\n                               \\<up> (pi = xaaaaa)>\\<^sub>t)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t e bddi bdd p bdd'.\n       None = Some (p, bdd') \\<longrightarrow>\n       <is_bdd_impl bdd\n         bddi> iteci i t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t\n 2. \\<And>s i t e bddi bdd p bdd'.\n       (\\<And>i t e bddi bdd p bdd'.\n           s i t e bdd = Some (p, bdd') \\<longrightarrow>\n           <is_bdd_impl bdd\n             bddi> iteci i t e\n                    bddi <\\<lambda>r.\n                             case r of\n                             (pi, bddi') \\<Rightarrow>\n                               is_bdd_impl bdd' bddi' *\n                               \\<up> (pi = p)>\\<^sub>t) \\<Longrightarrow>\n       mi.lowest_tops_impl [i, t, e] bdd \\<bind>\n       (\\<lambda>(lt, uu_).\n           case lt of\n           None \\<Rightarrow>\n             mi.case_ifexi (\\<lambda>_. Some (t, bdd))\n              (\\<lambda>_. Some (e, bdd)) (\\<lambda>_ _ _. Map.empty) i bdd\n           | Some a \\<Rightarrow>\n               mi.restrict_top_impl i a True bdd \\<bind>\n               (\\<lambda>(ti, uu_).\n                   mi.restrict_top_impl t a True bdd \\<bind>\n                   (\\<lambda>(tt, uu_).\n                       mi.restrict_top_impl e a True bdd \\<bind>\n                       (\\<lambda>(te, uu_).\n                           mi.restrict_top_impl i a False bdd \\<bind>\n                           (\\<lambda>(fi, uu_).\n                               mi.restrict_top_impl t a False bdd \\<bind>\n                               (\\<lambda>(ft, uu_).\n                                   mi.restrict_top_impl e a False\n                                    bdd \\<bind>\n                                   (\\<lambda>(fe, uu_).\n s ti tt te bdd \\<bind>\n (\\<lambda>(tb, sa).\n     s fi ft fe sa \\<bind> (\\<lambda>(x, y). ifmi' a tb x y))))))))) =\n       Some (p, bdd') \\<longrightarrow>\n       <is_bdd_impl bdd\n         bddi> iteci i t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. None = Some (p_, bdd'_) \\<longrightarrow>\n    <is_bdd_impl bdd_\n      bddi_> iteci i_ t_ e_\n              bddi_ <\\<lambda>r.\n                        case r of\n                        (pi, bddi') \\<Rightarrow>\n                          is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i t e bddi bdd p bdd'.\n       (\\<And>i t e bddi bdd p bdd'.\n           s i t e bdd = Some (p, bdd') \\<longrightarrow>\n           <is_bdd_impl bdd\n             bddi> iteci i t e\n                    bddi <\\<lambda>r.\n                             case r of\n                             (pi, bddi') \\<Rightarrow>\n                               is_bdd_impl bdd' bddi' *\n                               \\<up> (pi = p)>\\<^sub>t) \\<Longrightarrow>\n       mi.lowest_tops_impl [i, t, e] bdd \\<bind>\n       (\\<lambda>(lt, uu_).\n           case lt of\n           None \\<Rightarrow>\n             mi.case_ifexi (\\<lambda>_. Some (t, bdd))\n              (\\<lambda>_. Some (e, bdd)) (\\<lambda>_ _ _. Map.empty) i bdd\n           | Some a \\<Rightarrow>\n               mi.restrict_top_impl i a True bdd \\<bind>\n               (\\<lambda>(ti, uu_).\n                   mi.restrict_top_impl t a True bdd \\<bind>\n                   (\\<lambda>(tt, uu_).\n                       mi.restrict_top_impl e a True bdd \\<bind>\n                       (\\<lambda>(te, uu_).\n                           mi.restrict_top_impl i a False bdd \\<bind>\n                           (\\<lambda>(fi, uu_).\n                               mi.restrict_top_impl t a False bdd \\<bind>\n                               (\\<lambda>(ft, uu_).\n                                   mi.restrict_top_impl e a False\n                                    bdd \\<bind>\n                                   (\\<lambda>(fe, uu_).\n s ti tt te bdd \\<bind>\n (\\<lambda>(tb, sa).\n     s fi ft fe sa \\<bind> (\\<lambda>(x, y). ifmi' a tb x y))))))))) =\n       Some (p, bdd') \\<longrightarrow>\n       <is_bdd_impl bdd\n         bddi> iteci i t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i t e bddi bdd p bdd'.\n        s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n        <is_bdd_impl bdd\n          bddi> iteci i t e\n                 bddi <\\<lambda>r.\n                          case r of\n                          (pi, bddi') \\<Rightarrow>\n                            is_bdd_impl bdd' bddi' *\n                            \\<up> (pi = p)>\\<^sub>t) \\<Longrightarrow>\n    mi.lowest_tops_impl [i_, t_, e_] bdd_ \\<bind>\n    (\\<lambda>(lt, uu_).\n        case lt of\n        None \\<Rightarrow>\n          mi.case_ifexi (\\<lambda>_. Some (t_, bdd_))\n           (\\<lambda>_. Some (e_, bdd_)) (\\<lambda>_ _ _. Map.empty) i_ bdd_\n        | Some a \\<Rightarrow>\n            mi.restrict_top_impl i_ a True bdd_ \\<bind>\n            (\\<lambda>(ti, uu_).\n                mi.restrict_top_impl t_ a True bdd_ \\<bind>\n                (\\<lambda>(tt, uu_).\n                    mi.restrict_top_impl e_ a True bdd_ \\<bind>\n                    (\\<lambda>(te, uu_).\n                        mi.restrict_top_impl i_ a False bdd_ \\<bind>\n                        (\\<lambda>(fi, uu_).\n                            mi.restrict_top_impl t_ a False bdd_ \\<bind>\n                            (\\<lambda>(ft, uu_).\n                                mi.restrict_top_impl e_ a False bdd_ \\<bind>\n                                (\\<lambda>(fe, uu_).\n                                    s_ ti tt te bdd_ \\<bind>\n                                    (\\<lambda>(tb, sa).\n  s_ fi ft fe sa \\<bind> (\\<lambda>(x, y). ifmi' a tb x y))))))))) =\n    Some (p_, bdd'_) \\<longrightarrow>\n    <is_bdd_impl bdd_\n      bddi_> iteci i_ t_ e_\n              bddi_ <\\<lambda>r.\n                        case r of\n                        (pi, bddi') \\<Rightarrow>\n                          is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     mi.lowest_tops_impl [i_, t_, e_] bdd_ \\<bind>\n     (\\<lambda>(lt, uu_).\n         case lt of\n         None \\<Rightarrow>\n           mi.case_ifexi (\\<lambda>_. Some (t_, bdd_))\n            (\\<lambda>_. Some (e_, bdd_)) (\\<lambda>_ _ _. Map.empty) i_\n            bdd_\n         | Some a \\<Rightarrow>\n             mi.restrict_top_impl i_ a True bdd_ \\<bind>\n             (\\<lambda>(ti, uu_).\n                 mi.restrict_top_impl t_ a True bdd_ \\<bind>\n                 (\\<lambda>(tt, uu_).\n                     mi.restrict_top_impl e_ a True bdd_ \\<bind>\n                     (\\<lambda>(te, uu_).\n                         mi.restrict_top_impl i_ a False bdd_ \\<bind>\n                         (\\<lambda>(fi, uu_).\n                             mi.restrict_top_impl t_ a False bdd_ \\<bind>\n                             (\\<lambda>(ft, uu_).\n                                 mi.restrict_top_impl e_ a False\n                                  bdd_ \\<bind>\n                                 (\\<lambda>(fe, uu_).\n                                     s_ ti tt te bdd_ \\<bind>\n                                     (\\<lambda>(tb, sa).\n   s_ fi ft fe sa \\<bind> (\\<lambda>(x, y). ifmi' a tb x y))))))))) =\n     Some (p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_\n                        bddi_> iteci i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply (clarsimp split: option.splits Option.bind_splits prod.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (None, x2);\n        mi.case_ifexi (\\<lambda>_. Some (t_, bdd_))\n         (\\<lambda>_. Some (e_, bdd_)) (\\<lambda>_ _ _. Map.empty) i_ bdd_ =\n        Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_\n                           bddi_> iteci i_ t_ e_\n                                   bddi_ <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t\n 2. \\<And>x2 x2a x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h\n       x2i.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x2a, x2);\n        mi.restrict_top_impl i_ x2a True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x2a True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x2a True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x2a False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x2a False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x2a False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x2a x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_\n                           bddi_> iteci i_ t_ e_\n                                   bddi_ <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply (subst iteci.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (None, x2);\n        mi.case_ifexi (\\<lambda>_. Some (t_, bdd_))\n         (\\<lambda>_. Some (e_, bdd_)) (\\<lambda>_ _ _. Map.empty) i_ bdd_ =\n        Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_\n                           bddi_> lowest_topsci [i_, t_, e_] bddi_ \\<bind>\n                                  case_option\n                                   (case_ifexici (return (t_, bddi_))\n                                     (return (e_, bddi_))\n                                     (\\<lambda>_ _ _.\n   raise STR ''Cannot happen'')\n                                     i_ bddi_)\n                                   (\\<lambda>a.\n restrict_topci i_ a True bddi_ \\<bind>\n (\\<lambda>ti.\n     restrict_topci t_ a True bddi_ \\<bind>\n     (\\<lambda>tt.\n         restrict_topci e_ a True bddi_ \\<bind>\n         (\\<lambda>te.\n             restrict_topci i_ a False bddi_ \\<bind>\n             (\\<lambda>fi.\n                 restrict_topci t_ a False bddi_ \\<bind>\n                 (\\<lambda>ft.\n                     restrict_topci e_ a False bddi_ \\<bind>\n                     (\\<lambda>fe.\n                         iteci ti tt te bddi_ \\<bind>\n                         (\\<lambda>(tb, s').\n                             iteci fi ft fe s' \\<bind>\n                             (\\<lambda>(x, y).\n                                 ifci a tb x\n                                  y))))))))) <\\<lambda>r.\n           case r of\n           (pi, bddi') \\<Rightarrow>\n             is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t\n 2. \\<And>x2 x2a x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h\n       x2i.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x2a, x2);\n        mi.restrict_top_impl i_ x2a True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x2a True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x2a True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x2a False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x2a False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x2a False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x2a x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_\n                           bddi_> iteci i_ t_ e_\n                                   bddi_ <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply (sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x2a x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h\n       x2i.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x2a, x2);\n        mi.restrict_top_impl i_ x2a True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x2a True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x2a True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x2a False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x2a False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x2a False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x2a x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_\n                           bddi_> iteci i_ t_ e_\n                                   bddi_ <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply (subst iteci.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x2a x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h\n       x2i.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x2a, x2);\n        mi.restrict_top_impl i_ x2a True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x2a True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x2a True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x2a False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x2a False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x2a False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x2a x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_\n                           bddi_> lowest_topsci [i_, t_, e_] bddi_ \\<bind>\n                                  case_option\n                                   (case_ifexici (return (t_, bddi_))\n                                     (return (e_, bddi_))\n                                     (\\<lambda>_ _ _.\n   raise STR ''Cannot happen'')\n                                     i_ bddi_)\n                                   (\\<lambda>a.\n restrict_topci i_ a True bddi_ \\<bind>\n (\\<lambda>ti.\n     restrict_topci t_ a True bddi_ \\<bind>\n     (\\<lambda>tt.\n         restrict_topci e_ a True bddi_ \\<bind>\n         (\\<lambda>te.\n             restrict_topci i_ a False bddi_ \\<bind>\n             (\\<lambda>fi.\n                 restrict_topci t_ a False bddi_ \\<bind>\n                 (\\<lambda>ft.\n                     restrict_topci e_ a False bddi_ \\<bind>\n                     (\\<lambda>fe.\n                         iteci ti tt te bddi_ \\<bind>\n                         (\\<lambda>(tb, s').\n                             iteci fi ft fe s' \\<bind>\n                             (\\<lambda>(x, y).\n                                 ifci a tb x\n                                  y))))))))) <\\<lambda>r.\n           case r of\n           (pi, bddi') \\<Rightarrow>\n             is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply (sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_ bddi_> iteci x1a x1b x1c bddi_\n                         <?R360 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f\n                           x2g x1g x2h x1h x2i x x1a x1b x1c x1d x1e x1f>\n 2. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       xa xb xc xd xe xf xg.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_); xa = x1a; xb = x1b;\n        xc = x1c; xd = x1d; xe = x1e; xf = x1f\\<rbrakk>\n       \\<Longrightarrow> <?R360 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f\n                           x2g x1g x2h x1h x2i x xa xb xc xd xe xf\n                           xg> case xg of\n                               (tb, s') \\<Rightarrow>\n                                 iteci x1d x1e x1f s' \\<bind>\n                                 (\\<lambda>(xa, y).\n                                     ifci x tb xa\ny) <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "unfolding imp_to_meta"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_ bddi_> iteci x1a x1b x1c bddi_\n                         <?R360 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f\n                           x2g x1g x2h x1h x2i x x1a x1b x1c x1d x1e x1f>\n 2. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       xa xb xc xd xe xf xg.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_); xa = x1a; xb = x1b;\n        xc = x1c; xd = x1d; xe = x1e; xf = x1f\\<rbrakk>\n       \\<Longrightarrow> <?R360 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f\n                           x2g x1g x2h x1h x2i x xa xb xc xd xe xf\n                           xg> case xg of\n                               (tb, s') \\<Rightarrow>\n                                 iteci x1d x1e x1f s' \\<bind>\n                                 (\\<lambda>(xa, y).\n                                     ifci x tb xa\ny) <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply rprems"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x.\n       \\<lbrakk>mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> s_ x1a x1b x1c bdd_ =\n                         Some\n                          (?p373 x1a x1a x2b x1b x1b x2c x1c x1c x2d x1d x1d\n                            x2e x1e x1e x2f x1f x1f x2g x1g x2h x1h x2i x,\n                           ?bdd'374 x1a x1a x2b x1b x1b x2c x1c x1c x2d x1d\n                            x1d x2e x1e x1e x2f x1f x1f x2g x1g x2h x1h x2i\n                            x)\n 2. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       xa xb xc xd xe xf xg.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_); xa = x1a; xb = x1b;\n        xc = x1c; xd = x1d; xe = x1e; xf = x1f\\<rbrakk>\n       \\<Longrightarrow> <(case xg of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl\n                              (?bdd'374 x1a xa x2b x1b xb x2c x1c xc x2d x1d\n                                xd x2e x1e xe x2f x1f xf x2g x1g x2h x1h x2i\n                                x)\n                              bddi' *\n                             \\<up>\n                              (pi =\n                               ?p373 x1a xa x2b x1b xb x2c x1c xc x2d x1d xd\n                                x2e x1e xe x2f x1f xf x2g x1g x2h x1h x2i\n                                x)) *\n                          true> case xg of\n                                (tb, s') \\<Rightarrow>\n                                  iteci x1d x1e x1f s' \\<bind>\n                                  (\\<lambda>(xa, y).\nifci x tb xa\n y) <\\<lambda>r.\n        case r of\n        (pi, bddi') \\<Rightarrow>\n          is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       xa xb xc xd xe xf xg.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_); xa = x1a; xb = x1b;\n        xc = x1c; xd = x1d; xe = x1e; xf = x1f\\<rbrakk>\n       \\<Longrightarrow> <(case xg of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl x2h bddi' * \\<up> (pi = x1g)) *\n                          true> case xg of\n                                (tb, s') \\<Rightarrow>\n                                  iteci x1d x1e x1f s' \\<bind>\n                                  (\\<lambda>(xa, y).\nifci x tb xa\n y) <\\<lambda>r.\n        case r of\n        (pi, bddi') \\<Rightarrow>\n          is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                      s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                      <is_bdd_impl bdd\n                        bddi> iteci i t e\n                               bddi <\\<lambda>r.\n  case r of\n  (pi, bddi') \\<Rightarrow>\n    is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n           mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n           mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n           mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n           mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n           mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n           mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n           mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n           s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n           s_ x1d x1e x1f x2h = Some (x1h, x2i);\n           ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n          \\<Longrightarrow> <is_bdd_impl x2h b * true> iteci x1d x1e x1f b\n                            <?R387 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f\n                              x1f x2g x1g x2h x1h x2i x b>\n 2. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b xa.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <?R387 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f\n                           x2g x1g x2h x1h x2i x b\n                           xa> case xa of\n                               (xa, xb) \\<Rightarrow>\n                                 ifci x x1g xa\n                                  xb <\\<lambda>r.\n   case r of\n   (pi, bddi') \\<Rightarrow>\n     is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply (rule fi_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                      s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                      <is_bdd_impl bdd\n                        bddi> iteci i t e\n                               bddi <\\<lambda>r.\n  case r of\n  (pi, bddi') \\<Rightarrow>\n    is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n           mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n           mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n           mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n           mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n           mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n           mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n           mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n           s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n           s_ x1d x1e x1f x2h = Some (x1h, x2i);\n           ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n          \\<Longrightarrow> <?P388 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f\n                              x1f x2g x1g x2h x1h x2i x b>\n                            iteci x1d x1e x1f b\n                            <?Q388 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f\n                              x1f x2g x1g x2h x1h x2i x b>\n 2. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                      s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                      <is_bdd_impl bdd\n                        bddi> iteci i t e\n                               bddi <\\<lambda>r.\n  case r of\n  (pi, bddi') \\<Rightarrow>\n    is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n           mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n           mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n           mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n           mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n           mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n           mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n           mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n           s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n           s_ x1d x1e x1f x2h = Some (x1h, x2i);\n           ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n          \\<Longrightarrow> is_bdd_impl x2h b *\n                            true \\<Longrightarrow>\\<^sub>A\n                            ?P388 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f\n                             x1f x2g x1g x2h x1h x2i x b *\n                            ?F388 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f\n                             x1f x2g x1g x2h x1h x2i x b\n 3. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b xa.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <?Q388 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f\n                           x2g x1g x2h x1h x2i x b xa *\n                          ?F388 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f\n                           x2g x1g x2h x1h x2i x\n                           b> case xa of\n                              (xa, xb) \\<Rightarrow>\n                                ifci x x1g xa\n                                 xb <\\<lambda>r.\n  case r of\n  (pi, bddi') \\<Rightarrow>\n    is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply rprems"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b. \\<lbrakk>mi.lowest_tops_impl [i_, t_, e_] bdd_ =\n                   Some (Some x, bdd_);\n           mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n           mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n           mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n           mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n           mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n           mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n           s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n           s_ x1d x1e x1f x2h = Some (x1h, x2i);\n           ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n          \\<Longrightarrow> s_ x1d x1e x1f\n                             (?bdd392 x1a x2b x1b x2c x1c x2d x1d x2e x1e\n                               x2f x1f x2g x1g x2h x1h x2i x b) =\n                            Some\n                             (?p392 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f\n                               x1f x2g x1g x2h x1h x2i x b,\n                              ?bdd'392 x1a x2b x1b x2c x1c x2d x1d x2e x1e\n                               x2f x1f x2g x1g x2h x1h x2i x b)\n 2. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                      s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                      <is_bdd_impl bdd\n                        bddi> iteci i t e\n                               bddi <\\<lambda>r.\n  case r of\n  (pi, bddi') \\<Rightarrow>\n    is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n           mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n           mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n           mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n           mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n           mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n           mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n           mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n           s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n           s_ x1d x1e x1f x2h = Some (x1h, x2i);\n           ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n          \\<Longrightarrow> is_bdd_impl x2h b *\n                            true \\<Longrightarrow>\\<^sub>A\n                            is_bdd_impl\n                             (?bdd392 x1a x2b x1b x2c x1c x2d x1d x2e x1e\n                               x2f x1f x2g x1g x2h x1h x2i x b)\n                             b *\n                            ?F388 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f\n                             x1f x2g x1g x2h x1h x2i x b\n 3. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b xa.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <(case xa of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl\n                              (?bdd'392 x1a x2b x1b x2c x1c x2d x1d x2e x1e\n                                x2f x1f x2g x1g x2h x1h x2i x b)\n                              bddi' *\n                             \\<up>\n                              (pi =\n                               ?p392 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f\n                                x1f x2g x1g x2h x1h x2i x b)) *\n                          true *\n                          ?F388 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f\n                           x2g x1g x2h x1h x2i x\n                           b> case xa of\n                              (xa, xb) \\<Rightarrow>\n                                ifci x x1g xa\n                                 xb <\\<lambda>r.\n  case r of\n  (pi, bddi') \\<Rightarrow>\n    is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                      s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                      <is_bdd_impl bdd\n                        bddi> iteci i t e\n                               bddi <\\<lambda>r.\n  case r of\n  (pi, bddi') \\<Rightarrow>\n    is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n           mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n           mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n           mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n           mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n           mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n           mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n           mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n           s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n           s_ x1d x1e x1f x2h = Some (x1h, x2i);\n           ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n          \\<Longrightarrow> is_bdd_impl x2h b *\n                            true \\<Longrightarrow>\\<^sub>A\n                            is_bdd_impl x2h b *\n                            ?F388 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f\n                             x1f x2g x1g x2h x1h x2i x b\n 2. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b xa.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <(case xa of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl x2i bddi' * \\<up> (pi = x1h)) *\n                          true *\n                          ?F388 x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f\n                           x2g x1g x2h x1h x2i x\n                           b> case xa of\n                              (xa, xb) \\<Rightarrow>\n                                ifci x x1g xa\n                                 xb <\\<lambda>r.\n  case r of\n  (pi, bddi') \\<Rightarrow>\n    is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i x\n       b xa.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        mi.lowest_tops_impl [i_, t_, e_] bdd_ = Some (Some x, bdd_);\n        mi.restrict_top_impl i_ x True bdd_ = Some (x1a, x2b);\n        mi.restrict_top_impl t_ x True bdd_ = Some (x1b, x2c);\n        mi.restrict_top_impl e_ x True bdd_ = Some (x1c, x2d);\n        mi.restrict_top_impl i_ x False bdd_ = Some (x1d, x2e);\n        mi.restrict_top_impl t_ x False bdd_ = Some (x1e, x2f);\n        mi.restrict_top_impl e_ x False bdd_ = Some (x1f, x2g);\n        s_ x1a x1b x1c bdd_ = Some (x1g, x2h);\n        s_ x1d x1e x1f x2h = Some (x1h, x2i);\n        ifmi' x x1g x1h x2i = Some (p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <(case xa of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl x2i bddi' * \\<up> (pi = x1h)) *\n                          true *\n                          true> case xa of\n                                (xa, xb) \\<Rightarrow>\n                                  ifci x x1g xa\n                                   xb <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "by sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare iteci_rule[THEN mp, sep_heap_rules]"], ["", "definition param_optci where\n  \"param_optci i t e bdd = do {\n    (tr, bdd) \\<leftarrow> tci bdd;\n    (fl, bdd) \\<leftarrow> fci bdd;\n    id \\<leftarrow> destrci i bdd;\n    td \\<leftarrow> destrci t bdd;\n    ed \\<leftarrow> destrci e bdd;\n              return (\n              if id = TD then Some t else\n                        if id = FD then Some e else\n                        if td = TD \\<and> ed = FD then Some i else\n                        if t = e then Some t else\n                        if ed = TD \\<and> i = t then Some tr else\n                        if td = FD \\<and> i = e then Some fl else\n                        None, bdd)\n  }\""], ["", "lemma param_optci_rule: \"\n  ( mi.param_opt_impl i t e bdd = Some (p,bdd'))  \\<Longrightarrow>\n  <is_bdd_impl bdd bddi> \n    param_optci i t e bddi \n  <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi=p)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mi.param_opt_impl i t e bdd = Some (p, bdd') \\<Longrightarrow>\n    <is_bdd_impl bdd\n      bddi> param_optci i t e\n             bddi <\\<lambda>r.\n                      case r of\n                      (pi, bddi') \\<Rightarrow>\n                        is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t", "by (sep_auto simp add: mi.param_opt_impl.simps param_optci_def tmi'_def fmi'_def\n             split: Option.bind_splits)"], ["", "lemma bdd_hm_lookup_rule: \"\n  (dcl bdd (i,t,e) = p) \\<Longrightarrow>\n  <is_bdd_impl bdd bddi> \n    hm_lookup (i, t, e) (dcli bddi)\n  <\\<lambda>(pi). is_bdd_impl bdd bddi * \\<up>(pi = p)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dcl bdd (i, t, e) = p \\<Longrightarrow>\n    <is_bdd_impl bdd\n      bddi> hm_lookup (i, t, e)\n             (dcli\n               bddi) <\\<lambda>r.\n                         is_bdd_impl bdd bddi * \\<up> (r = p)>\\<^sub>t", "unfolding is_bdd_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dcl bdd (i, t, e) = p \\<Longrightarrow>\n    <is_pointermap_impl (dpm bdd) (dpmi bddi) *\n     is_hashmap (dcl bdd)\n      (dcli\n        bddi)> hm_lookup (i, t, e)\n                (dcli\n                  bddi) <\\<lambda>r.\n                            is_pointermap_impl (dpm bdd) (dpmi bddi) *\n                            is_hashmap (dcl bdd) (dcli bddi) *\n                            \\<up> (r = p)>\\<^sub>t", "by (sep_auto)"], ["", "lemma bdd_hm_update_rule'[sep_heap_rules]:\n  \"<is_bdd_impl bdd bddi> \n    hm_update k v (dcli bddi)\n  <\\<lambda>r. is_bdd_impl (updS bdd k v) (dcli_update (const r) bddi) * true>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_bdd_impl bdd\n      bddi> hm_update k v\n             (dcli\n               bddi) <\\<lambda>r.\n                         is_bdd_impl (updS bdd k v)\n                          (dcli_update (const r) bddi)>\\<^sub>t", "unfolding is_bdd_impl_def updS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_pointermap_impl (dpm bdd) (dpmi bddi) *\n     is_hashmap (dcl bdd)\n      (dcli\n        bddi)> hm_update k v\n                (dcli\n                  bddi) <\\<lambda>r.\n                            is_pointermap_impl\n                             (dpm (dcl_update (\\<lambda>m. m(k \\<mapsto> v))\n                                    bdd))\n                             (dpmi (dcli_update (const r) bddi)) *\n                            is_hashmap\n                             (dcl (dcl_update (\\<lambda>m. m(k \\<mapsto> v))\n                                    bdd))\n                             (dcli (dcli_update (const r) bddi))>\\<^sub>t", "by (sep_auto)"], ["", "partial_function(heap) iteci_lu where\n\"iteci_lu i t e s = do {\n  lu \\<leftarrow> ht_lookup (i,t,e) (dcli s);\n  (case lu of Some b \\<Rightarrow> return (b,s)\n    | None \\<Rightarrow> do {\n      (po,s) \\<leftarrow> param_optci i t e s;\n      (case po of Some b \\<Rightarrow> do {\n        return (b,s)}\n      | None \\<Rightarrow> do {\n        (lt) \\<leftarrow> lowest_topsci [i, t, e] s;\n        (case lt of Some a \\<Rightarrow> do {\n        ti \\<leftarrow> restrict_topci i a True s;\n        tt \\<leftarrow> restrict_topci t a True s;\n        te \\<leftarrow> restrict_topci e a True s;\n        fi \\<leftarrow> restrict_topci i a False s;\n        ft \\<leftarrow> restrict_topci t a False s;\n        fe \\<leftarrow> restrict_topci e a False s;\n        (tb,s) \\<leftarrow> iteci_lu ti tt te s;\n        (fb,s) \\<leftarrow> iteci_lu fi ft fe s;\n        (r,s) \\<leftarrow> ifci a tb fb s;\n        cl \\<leftarrow> hm_update (i,t,e) r (dcli s);\n        return (r,dcli_update (const cl) s)\n       } \n         | None \\<Rightarrow> raise STR ''Cannot happen'' )})\n  })}\""], ["", "term ht_lookup"], ["", "declare iteci_lu.simps[code]"], ["", "thm iteci_lu.simps[unfolded restrict_topci_def case_ifexici_def  param_optci_def lowest_topsci.simps]"], ["", "partial_function(heap) iteci_lu_code where \"iteci_lu_code i t e s = do {\n  lu \\<leftarrow> hm_lookup (i, t, e) (dcli s);\n  case lu of None \\<Rightarrow> let po = if i = 1 then Some t\n                              else if i = 0 then Some e else if t = 1 \\<and> e = 0 then Some i else if t = e then Some t else if e = 1 \\<and> i = t then Some 1 else if t = 0 \\<and> i = e then Some 0 else None\n                     in case po of None \\<Rightarrow> do {\n                                       id \\<leftarrow> destrci i s;\n                                       td \\<leftarrow> destrci t s;\n                                       ed \\<leftarrow> destrci e s;\n                                       let a = (case id of IFD v t e \\<Rightarrow> v);\n                                       let a = (case td of IFD v t e \\<Rightarrow> min a v | _ \\<Rightarrow> a);\n                                       let a = (case ed of IFD v t e \\<Rightarrow> min a v | _ \\<Rightarrow> a);\n                                       let ti = (case id of IFD v ti ei \\<Rightarrow> if v = a then ti else i | _ \\<Rightarrow> i);\n                                       let tt = (case td of IFD v ti ei \\<Rightarrow> if v = a then ti else t | _ \\<Rightarrow> t);\n                                       let te = (case ed of IFD v ti ei \\<Rightarrow> if v = a then ti else e | _ \\<Rightarrow> e);\n                                       let fi = (case id of IFD v ti ei \\<Rightarrow> if v = a then ei else i | _ \\<Rightarrow> i);\n                                       let ft = (case td of IFD v ti ei \\<Rightarrow> if v = a then ei else t | _ \\<Rightarrow> t);\n                                       let fe = (case ed of IFD v ti ei \\<Rightarrow> if v = a then ei else e | _ \\<Rightarrow> e);\n                                       (tb, s) \\<leftarrow> iteci_lu_code ti tt te s;\n                                       (fb, s) \\<leftarrow> iteci_lu_code fi ft fe s;\n                                       (r, s) \\<leftarrow> ifci a tb fb s;\n                                       cl \\<leftarrow> hm_update (i, t, e) r (dcli s);\n                                       return (r, dcli_update (const cl) s)\n                                     }\n                        | Some b \\<Rightarrow> return (b, s)\n  | Some b \\<Rightarrow> return (b, s)\n}\""], ["", "declare iteci_lu_code.simps[code]"], ["", "(* reduced the run-time of our examples by around 30%.\n  But we would need some efficient automated machinery to show this,\n  and I'm not even sure how to correctly use induction correctly for this.\n  Thus: Future work.*)"], ["", "lemma iteci_lu_code[code_unfold]: \"iteci_lu i t e s = iteci_lu_code i t e s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iteci_lu i t e s = iteci_lu_code i t e s", "oops"], ["", "(* Proof by copy-paste *)"], ["", "lemma iteci_lu_rule: \"\n  ( mi.ite_impl_lu i t e bdd = Some (p,bdd'))  \\<longrightarrow>\n  <is_bdd_impl bdd bddi> \n    iteci_lu i t e bddi \n  <\\<lambda>(pi,bddi'). is_bdd_impl bdd' bddi' * \\<up>(pi=p )>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mi.ite_impl_lu i t e bdd = Some (p, bdd') \\<longrightarrow>\n    <is_bdd_impl bdd\n      bddi> iteci_lu i t e\n             bddi <\\<lambda>r.\n                      case r of\n                      (pi, bddi') \\<Rightarrow>\n                        is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t", "apply (induction arbitrary: i t e bddi bdd p bdd' rule: mi.ite_impl_lu.fixp_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. option.admissible\n     (\\<lambda>ite_impl_lu.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            curry (curry (curry ite_impl_lu)) x xa xaa xaaaa =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci_lu x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)\n 2. \\<And>i t e bddi bdd p bdd'.\n       None = Some (p, bdd') \\<longrightarrow>\n       <is_bdd_impl bdd\n         bddi> iteci_lu i t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t\n 3. \\<And>s i t e bddi bdd p bdd'.\n       (\\<And>i t e bddi bdd p bdd'.\n           s i t e bdd = Some (p, bdd') \\<longrightarrow>\n           <is_bdd_impl bdd\n             bddi> iteci_lu i t e\n                    bddi <\\<lambda>r.\n                             case r of\n                             (pi, bddi') \\<Rightarrow>\n                               is_bdd_impl bdd' bddi' *\n                               \\<up> (pi = p)>\\<^sub>t) \\<Longrightarrow>\n       (case dcl bdd (i, t, e) of\n        None \\<Rightarrow>\n          mi.param_opt_impl i t e bdd \\<bind>\n          (\\<lambda>(ld, sa).\n              case ld of\n              None \\<Rightarrow>\n                mi.lowest_tops_impl [i, t, e] sa \\<bind>\n                (\\<lambda>(lt, uu_).\n                    case lt of None \\<Rightarrow> None\n                    | Some a \\<Rightarrow>\n                        mi.restrict_top_impl i a True sa \\<bind>\n                        (\\<lambda>(ti, uu_).\n                            mi.restrict_top_impl t a True sa \\<bind>\n                            (\\<lambda>(tt, uu_).\n                                mi.restrict_top_impl e a True sa \\<bind>\n                                (\\<lambda>(te, uu_).\n                                    mi.restrict_top_impl i a False\n                                     sa \\<bind>\n                                    (\\<lambda>(fi, uu_).\n  mi.restrict_top_impl t a False sa \\<bind>\n  (\\<lambda>(ft, uu_).\n      mi.restrict_top_impl e a False sa \\<bind>\n      (\\<lambda>(fe, uu_).\n          s ti tt te sa \\<bind>\n          (\\<lambda>(tb, sa).\n              s fi ft fe sa \\<bind>\n              (\\<lambda>(fb, s).\n                  ifmi' a tb fb s \\<bind>\n                  (\\<lambda>(r, s).\n                      let s = updS s (i, t, e) r in Some (r, s)))))))))))\n              | Some b \\<Rightarrow> Some (b, sa))\n        | Some b \\<Rightarrow> Some (b, bdd)) =\n       Some (p, bdd') \\<longrightarrow>\n       <is_bdd_impl bdd\n         bddi> iteci_lu i t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>ite_impl_lu.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            curry (curry (curry ite_impl_lu)) x xa xaa xaaaa =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci_lu x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>ite_impl_lu.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            ite_impl_lu (((x, xa), xaa), xaaaa) =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci_lu x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)", "(* More Dragons *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>ite_impl_lu.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            ite_impl_lu (((x, xa), xaa), xaaaa) =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci_lu x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)", "using option_admissible[where P=\n             \"\\<lambda>(((x1,x2),x3),x4) (r1,r2). \\<forall>bddi.\n              <is_bdd_impl x4 bddi>\n                iteci_lu x1 x2 x3 bddi  \n              <\\<lambda>r. case r of (p\\<^sub>i, bddi') \\<Rightarrow> is_bdd_impl r2 bddi' * \\<up> (p\\<^sub>i = r1)>\\<^sub>t\"]"], ["proof (prove)\nusing this:\n  option.admissible\n   (\\<lambda>f.\n       \\<forall>x y.\n          f x = Some y \\<longrightarrow>\n          (case x of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (x1, x2) \\<Rightarrow>\n                   \\<lambda>x3 x4 (r1, r2).\n                      \\<forall>bddi.\n                         <is_bdd_impl x4\n                           bddi> iteci_lu x1 x2 x3\n                                  bddi <\\<lambda>r.\n     case r of\n     (p\\<^sub>i, bddi') \\<Rightarrow>\n       is_bdd_impl r2 bddi' * \\<up> (p\\<^sub>i = r1)>\\<^sub>t)\n                 xa)\n              xa)\n           y)\n\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>ite_impl_lu.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            ite_impl_lu (((x, xa), xaa), xaaaa) =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci_lu x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>f.\n         \\<forall>a b ba baa aa baaa.\n            f (((a, b), ba), baa) = Some (aa, baaa) \\<longrightarrow>\n            (\\<forall>bddi.\n                <is_bdd_impl baa\n                  bddi> iteci_lu a b ba\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (p\\<^sub>i, bddi') \\<Rightarrow>\n                                    is_bdd_impl baaa bddi' *\n                                    \\<up>\n                                     (p\\<^sub>i =\naa)>\\<^sub>t)) \\<Longrightarrow>\n    option.admissible\n     (\\<lambda>ite_impl_lu.\n         \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n            ite_impl_lu (((x, xa), xaa), xaaaa) =\n            Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n            <is_bdd_impl xaaaa\n              xaaa> iteci_lu x xa xaa\n                     xaaa <\\<lambda>r.\n                              case r of\n                              (pi, bddi') \\<Rightarrow>\n                                is_bdd_impl xaaaaaa bddi' *\n                                \\<up> (pi = xaaaaa)>\\<^sub>t)", "apply (fo_rule subst[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. option.admissible\n     (\\<lambda>f.\n         \\<forall>a b ba baa aa baaa.\n            f (((a, b), ba), baa) = Some (aa, baaa) \\<longrightarrow>\n            (\\<forall>bddi.\n                <is_bdd_impl baa\n                  bddi> iteci_lu a b ba\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (p\\<^sub>i, bddi') \\<Rightarrow>\n                                    is_bdd_impl baaa bddi' *\n                                    \\<up>\n                                     (p\\<^sub>i =\naa)>\\<^sub>t)) \\<Longrightarrow>\n    option.admissible ?s8\n 2. option.admissible\n     (\\<lambda>f.\n         \\<forall>a b ba baa aa baaa.\n            f (((a, b), ba), baa) = Some (aa, baaa) \\<longrightarrow>\n            (\\<forall>bddi.\n                <is_bdd_impl baa\n                  bddi> iteci_lu a b ba\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (p\\<^sub>i, bddi') \\<Rightarrow>\n                                    is_bdd_impl baaa bddi' *\n                                    \\<up>\n                                     (p\\<^sub>i =\naa)>\\<^sub>t)) \\<Longrightarrow>\n    ?s8 =\n    (\\<lambda>ite_impl_lu.\n        \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n           ite_impl_lu (((x, xa), xaa), xaaaa) =\n           Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n           <is_bdd_impl xaaaa\n             xaaa> iteci_lu x xa xaa\n                    xaaa <\\<lambda>r.\n                             case r of\n                             (pi, bddi') \\<Rightarrow>\n                               is_bdd_impl xaaaaaa bddi' *\n                               \\<up> (pi = xaaaaa)>\\<^sub>t)", "apply (assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>f.\n         \\<forall>a b ba baa aa baaa.\n            f (((a, b), ba), baa) = Some (aa, baaa) \\<longrightarrow>\n            (\\<forall>bddi.\n                <is_bdd_impl baa\n                  bddi> iteci_lu a b ba\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (p\\<^sub>i, bddi') \\<Rightarrow>\n                                    is_bdd_impl baaa bddi' *\n                                    \\<up>\n                                     (p\\<^sub>i =\naa)>\\<^sub>t)) \\<Longrightarrow>\n    (\\<lambda>f.\n        \\<forall>a b ba baa aa baaa.\n           f (((a, b), ba), baa) = Some (aa, baaa) \\<longrightarrow>\n           (\\<forall>bddi.\n               <is_bdd_impl baa\n                 bddi> iteci_lu a b ba\n                        bddi <\\<lambda>r.\n                                 case r of\n                                 (p\\<^sub>i, bddi') \\<Rightarrow>\n                                   is_bdd_impl baaa bddi' *\n                                   \\<up> (p\\<^sub>i = aa)>\\<^sub>t)) =\n    (\\<lambda>ite_impl_lu.\n        \\<forall>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n           ite_impl_lu (((x, xa), xaa), xaaaa) =\n           Some (xaaaaa, xaaaaaa) \\<longrightarrow>\n           <is_bdd_impl xaaaa\n             xaaa> iteci_lu x xa xaa\n                    xaaa <\\<lambda>r.\n                             case r of\n                             (pi, bddi') \\<Rightarrow>\n                               is_bdd_impl xaaaaaa bddi' *\n                               \\<up> (pi = xaaaaa)>\\<^sub>t)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t e bddi bdd p bdd'.\n       None = Some (p, bdd') \\<longrightarrow>\n       <is_bdd_impl bdd\n         bddi> iteci_lu i t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t\n 2. \\<And>s i t e bddi bdd p bdd'.\n       (\\<And>i t e bddi bdd p bdd'.\n           s i t e bdd = Some (p, bdd') \\<longrightarrow>\n           <is_bdd_impl bdd\n             bddi> iteci_lu i t e\n                    bddi <\\<lambda>r.\n                             case r of\n                             (pi, bddi') \\<Rightarrow>\n                               is_bdd_impl bdd' bddi' *\n                               \\<up> (pi = p)>\\<^sub>t) \\<Longrightarrow>\n       (case dcl bdd (i, t, e) of\n        None \\<Rightarrow>\n          mi.param_opt_impl i t e bdd \\<bind>\n          (\\<lambda>(ld, sa).\n              case ld of\n              None \\<Rightarrow>\n                mi.lowest_tops_impl [i, t, e] sa \\<bind>\n                (\\<lambda>(lt, uu_).\n                    case lt of None \\<Rightarrow> None\n                    | Some a \\<Rightarrow>\n                        mi.restrict_top_impl i a True sa \\<bind>\n                        (\\<lambda>(ti, uu_).\n                            mi.restrict_top_impl t a True sa \\<bind>\n                            (\\<lambda>(tt, uu_).\n                                mi.restrict_top_impl e a True sa \\<bind>\n                                (\\<lambda>(te, uu_).\n                                    mi.restrict_top_impl i a False\n                                     sa \\<bind>\n                                    (\\<lambda>(fi, uu_).\n  mi.restrict_top_impl t a False sa \\<bind>\n  (\\<lambda>(ft, uu_).\n      mi.restrict_top_impl e a False sa \\<bind>\n      (\\<lambda>(fe, uu_).\n          s ti tt te sa \\<bind>\n          (\\<lambda>(tb, sa).\n              s fi ft fe sa \\<bind>\n              (\\<lambda>(fb, s).\n                  ifmi' a tb fb s \\<bind>\n                  (\\<lambda>(r, s).\n                      let s = updS s (i, t, e) r in Some (r, s)))))))))))\n              | Some b \\<Rightarrow> Some (b, sa))\n        | Some b \\<Rightarrow> Some (b, bdd)) =\n       Some (p, bdd') \\<longrightarrow>\n       <is_bdd_impl bdd\n         bddi> iteci_lu i t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. None = Some (p_, bdd'_) \\<longrightarrow>\n    <is_bdd_impl bdd_\n      bddi_> iteci_lu i_ t_ e_\n              bddi_ <\\<lambda>r.\n                        case r of\n                        (pi, bddi') \\<Rightarrow>\n                          is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i t e bddi bdd p bdd'.\n       (\\<And>i t e bddi bdd p bdd'.\n           s i t e bdd = Some (p, bdd') \\<longrightarrow>\n           <is_bdd_impl bdd\n             bddi> iteci_lu i t e\n                    bddi <\\<lambda>r.\n                             case r of\n                             (pi, bddi') \\<Rightarrow>\n                               is_bdd_impl bdd' bddi' *\n                               \\<up> (pi = p)>\\<^sub>t) \\<Longrightarrow>\n       (case dcl bdd (i, t, e) of\n        None \\<Rightarrow>\n          mi.param_opt_impl i t e bdd \\<bind>\n          (\\<lambda>(ld, sa).\n              case ld of\n              None \\<Rightarrow>\n                mi.lowest_tops_impl [i, t, e] sa \\<bind>\n                (\\<lambda>(lt, uu_).\n                    case lt of None \\<Rightarrow> None\n                    | Some a \\<Rightarrow>\n                        mi.restrict_top_impl i a True sa \\<bind>\n                        (\\<lambda>(ti, uu_).\n                            mi.restrict_top_impl t a True sa \\<bind>\n                            (\\<lambda>(tt, uu_).\n                                mi.restrict_top_impl e a True sa \\<bind>\n                                (\\<lambda>(te, uu_).\n                                    mi.restrict_top_impl i a False\n                                     sa \\<bind>\n                                    (\\<lambda>(fi, uu_).\n  mi.restrict_top_impl t a False sa \\<bind>\n  (\\<lambda>(ft, uu_).\n      mi.restrict_top_impl e a False sa \\<bind>\n      (\\<lambda>(fe, uu_).\n          s ti tt te sa \\<bind>\n          (\\<lambda>(tb, sa).\n              s fi ft fe sa \\<bind>\n              (\\<lambda>(fb, s).\n                  ifmi' a tb fb s \\<bind>\n                  (\\<lambda>(r, s).\n                      let s = updS s (i, t, e) r in Some (r, s)))))))))))\n              | Some b \\<Rightarrow> Some (b, sa))\n        | Some b \\<Rightarrow> Some (b, bdd)) =\n       Some (p, bdd') \\<longrightarrow>\n       <is_bdd_impl bdd\n         bddi> iteci_lu i t e\n                bddi <\\<lambda>r.\n                         case r of\n                         (pi, bddi') \\<Rightarrow>\n                           is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i t e bddi bdd p bdd'.\n        s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n        <is_bdd_impl bdd\n          bddi> iteci_lu i t e\n                 bddi <\\<lambda>r.\n                          case r of\n                          (pi, bddi') \\<Rightarrow>\n                            is_bdd_impl bdd' bddi' *\n                            \\<up> (pi = p)>\\<^sub>t) \\<Longrightarrow>\n    (case dcl bdd_ (i_, t_, e_) of\n     None \\<Rightarrow>\n       mi.param_opt_impl i_ t_ e_ bdd_ \\<bind>\n       (\\<lambda>(ld, sa).\n           case ld of\n           None \\<Rightarrow>\n             mi.lowest_tops_impl [i_, t_, e_] sa \\<bind>\n             (\\<lambda>(lt, uu_).\n                 case lt of None \\<Rightarrow> None\n                 | Some a \\<Rightarrow>\n                     mi.restrict_top_impl i_ a True sa \\<bind>\n                     (\\<lambda>(ti, uu_).\n                         mi.restrict_top_impl t_ a True sa \\<bind>\n                         (\\<lambda>(tt, uu_).\n                             mi.restrict_top_impl e_ a True sa \\<bind>\n                             (\\<lambda>(te, uu_).\n                                 mi.restrict_top_impl i_ a False sa \\<bind>\n                                 (\\<lambda>(fi, uu_).\n                                     mi.restrict_top_impl t_ a False\nsa \\<bind>\n                                     (\\<lambda>(ft, uu_).\n   mi.restrict_top_impl e_ a False sa \\<bind>\n   (\\<lambda>(fe, uu_).\n       s_ ti tt te sa \\<bind>\n       (\\<lambda>(tb, sa).\n           s_ fi ft fe sa \\<bind>\n           (\\<lambda>(fb, s).\n               ifmi' a tb fb s \\<bind>\n               (\\<lambda>(r, s).\n                   let s = updS s (i_, t_, e_) r in Some (r, s)))))))))))\n           | Some b \\<Rightarrow> Some (b, sa))\n     | Some b \\<Rightarrow> Some (b, bdd_)) =\n    Some (p_, bdd'_) \\<longrightarrow>\n    <is_bdd_impl bdd_\n      bddi_> iteci_lu i_ t_ e_\n              bddi_ <\\<lambda>r.\n                        case r of\n                        (pi, bddi') \\<Rightarrow>\n                          is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     (case dcl bdd_ (i_, t_, e_) of\n      None \\<Rightarrow>\n        mi.param_opt_impl i_ t_ e_ bdd_ \\<bind>\n        (\\<lambda>(ld, sa).\n            case ld of\n            None \\<Rightarrow>\n              mi.lowest_tops_impl [i_, t_, e_] sa \\<bind>\n              (\\<lambda>(lt, uu_).\n                  case lt of None \\<Rightarrow> None\n                  | Some a \\<Rightarrow>\n                      mi.restrict_top_impl i_ a True sa \\<bind>\n                      (\\<lambda>(ti, uu_).\n                          mi.restrict_top_impl t_ a True sa \\<bind>\n                          (\\<lambda>(tt, uu_).\n                              mi.restrict_top_impl e_ a True sa \\<bind>\n                              (\\<lambda>(te, uu_).\n                                  mi.restrict_top_impl i_ a False sa \\<bind>\n                                  (\\<lambda>(fi, uu_).\nmi.restrict_top_impl t_ a False sa \\<bind>\n(\\<lambda>(ft, uu_).\n    mi.restrict_top_impl e_ a False sa \\<bind>\n    (\\<lambda>(fe, uu_).\n        s_ ti tt te sa \\<bind>\n        (\\<lambda>(tb, sa).\n            s_ fi ft fe sa \\<bind>\n            (\\<lambda>(fb, s).\n                ifmi' a tb fb s \\<bind>\n                (\\<lambda>(r, s).\n                    let s = updS s (i_, t_, e_) r in Some (r, s)))))))))))\n            | Some b \\<Rightarrow> Some (b, sa))\n      | Some b \\<Rightarrow> Some (b, bdd_)) =\n     Some (p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_\n                        bddi_> iteci_lu i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply (clarsimp split: option.splits Option.bind_splits prod.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2 x2a x2b x1b x2c x1c x2d x1d x2e x1e x2f x1f x2g x1g x2h x1h x2i\n       x1i x2j x2k.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2);\n        mi.lowest_tops_impl [i_, t_, e_] x2 = Some (Some x2b, x2a);\n        mi.restrict_top_impl i_ x2b True x2 = Some (x1b, x2c);\n        mi.restrict_top_impl t_ x2b True x2 = Some (x1c, x2d);\n        mi.restrict_top_impl e_ x2b True x2 = Some (x1d, x2e);\n        mi.restrict_top_impl i_ x2b False x2 = Some (x1e, x2f);\n        mi.restrict_top_impl t_ x2b False x2 = Some (x1f, x2g);\n        mi.restrict_top_impl e_ x2b False x2 = Some (x1g, x2h);\n        s_ x1b x1c x1d x2 = Some (x1h, x2i);\n        s_ x1e x1f x1g x2i = Some (x1i, x2j);\n        ifmi' x2b x1h x1i x2j = Some (p_, x2k);\n        bdd'_ = updS x2k (i_, t_, e_) p_\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_\n                           bddi_> iteci_lu i_ t_ e_\n                                   bddi_ <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl (updS x2k (i_, t_, e_) p_) bddi' *\n         \\<up> (pi = p_)>\\<^sub>t\n 2. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_\n                        bddi_> iteci_lu i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t\n 3. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd'_ (i_, t_, e_) = Some p_; bdd_ = bdd'_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd'_\n                        bddi_> iteci_lu i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ = updS x2k_ (i_, t_, e_) p_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_\n                        bddi_> iteci_lu i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl (updS x2k_ (i_, t_, e_) p_) bddi' *\n      \\<up> (pi = p_)>\\<^sub>t", "unfolding updS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ =\n     dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_\n                        bddi_> iteci_lu i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl\n       (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_) bddi' *\n      \\<up> (pi = p_)>\\<^sub>t", "apply (subst iteci_lu.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ =\n     dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_\n                        bddi_> hm_lookup (i_, t_, e_) (dcli bddi_) \\<bind>\n                               case_option\n                                (param_optci i_ t_ e_ bddi_ \\<bind>\n                                 (\\<lambda>(po, s).\n                                     case po of\n                                     None \\<Rightarrow>\n lowest_topsci [i_, t_, e_] s \\<bind>\n case_option (raise STR ''Cannot happen'')\n  (\\<lambda>a.\n      restrict_topci i_ a True s \\<bind>\n      (\\<lambda>ti.\n          restrict_topci t_ a True s \\<bind>\n          (\\<lambda>tt.\n              restrict_topci e_ a True s \\<bind>\n              (\\<lambda>te.\n                  restrict_topci i_ a False s \\<bind>\n                  (\\<lambda>fi.\n                      restrict_topci t_ a False s \\<bind>\n                      (\\<lambda>ft.\n                          restrict_topci e_ a False s \\<bind>\n                          (\\<lambda>fe.\n                              iteci_lu ti tt te s \\<bind>\n                              (\\<lambda>(tb, s).\n                                  iteci_lu fi ft fe s \\<bind>\n                                  (\\<lambda>(fb, s).\nifci a tb fb s \\<bind>\n(\\<lambda>(r, s).\n    hm_update (i_, t_, e_) r (dcli s) \\<bind>\n    (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n                                     | Some b \\<Rightarrow> return (b, s)))\n                                (\\<lambda>b.\n                                    return\n                                     (b,\nbddi_)) <\\<lambda>r.\n            case r of\n            (pi, bddi') \\<Rightarrow>\n              is_bdd_impl\n               (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n               bddi' *\n              \\<up> (pi = p_)>\\<^sub>t", "apply (sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ =\n     dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_ bddi_>\n                      hm_lookup (i_, t_, e_) (dcli bddi_) <?R1>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ =\n        dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n       \\<Longrightarrow> <?R1 x> case x of\n                                 None \\<Rightarrow>\n                                   param_optci i_ t_ e_ bddi_ \\<bind>\n                                   (\\<lambda>(po, s).\n case po of\n None \\<Rightarrow>\n   lowest_topsci [i_, t_, e_] s \\<bind>\n   case_option (raise STR ''Cannot happen'')\n    (\\<lambda>a.\n        restrict_topci i_ a True s \\<bind>\n        (\\<lambda>ti.\n            restrict_topci t_ a True s \\<bind>\n            (\\<lambda>tt.\n                restrict_topci e_ a True s \\<bind>\n                (\\<lambda>te.\n                    restrict_topci i_ a False s \\<bind>\n                    (\\<lambda>fi.\n                        restrict_topci t_ a False s \\<bind>\n                        (\\<lambda>ft.\n                            restrict_topci e_ a False s \\<bind>\n                            (\\<lambda>fe.\n                                iteci_lu ti tt te s \\<bind>\n                                (\\<lambda>(tb, s).\n                                    iteci_lu fi ft fe s \\<bind>\n                                    (\\<lambda>(fb, s).\n  ifci a tb fb s \\<bind>\n  (\\<lambda>(r, s).\n      hm_update (i_, t_, e_) r (dcli s) \\<bind>\n      (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n | Some b \\<Rightarrow> return (b, s))\n                                 | Some b \\<Rightarrow>\n                                     return\n(b, bddi_) <\\<lambda>r.\n               case r of\n               (pi, bddi') \\<Rightarrow>\n                 is_bdd_impl\n                  (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_))\n                    x2k_)\n                  bddi' *\n                 \\<up> (pi = p_)>\\<^sub>t", "using bdd_hm_lookup_rule"], ["proof (prove)\nusing this:\n  dcl ?bdd (?i, ?t, ?e) = ?p \\<Longrightarrow>\n  <is_bdd_impl ?bdd\n    ?bddi> hm_lookup (?i, ?t, ?e)\n            (dcli\n              ?bddi) <\\<lambda>r.\n                         is_bdd_impl ?bdd ?bddi * \\<up> (r = ?p)>\\<^sub>t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ =\n     dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_ bddi_>\n                      hm_lookup (i_, t_, e_) (dcli bddi_) <?R1>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ =\n        dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n       \\<Longrightarrow> <?R1 x> case x of\n                                 None \\<Rightarrow>\n                                   param_optci i_ t_ e_ bddi_ \\<bind>\n                                   (\\<lambda>(po, s).\n case po of\n None \\<Rightarrow>\n   lowest_topsci [i_, t_, e_] s \\<bind>\n   case_option (raise STR ''Cannot happen'')\n    (\\<lambda>a.\n        restrict_topci i_ a True s \\<bind>\n        (\\<lambda>ti.\n            restrict_topci t_ a True s \\<bind>\n            (\\<lambda>tt.\n                restrict_topci e_ a True s \\<bind>\n                (\\<lambda>te.\n                    restrict_topci i_ a False s \\<bind>\n                    (\\<lambda>fi.\n                        restrict_topci t_ a False s \\<bind>\n                        (\\<lambda>ft.\n                            restrict_topci e_ a False s \\<bind>\n                            (\\<lambda>fe.\n                                iteci_lu ti tt te s \\<bind>\n                                (\\<lambda>(tb, s).\n                                    iteci_lu fi ft fe s \\<bind>\n                                    (\\<lambda>(fb, s).\n  ifci a tb fb s \\<bind>\n  (\\<lambda>(r, s).\n      hm_update (i_, t_, e_) r (dcli s) \\<bind>\n      (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n | Some b \\<Rightarrow> return (b, s))\n                                 | Some b \\<Rightarrow>\n                                     return\n(b, bddi_) <\\<lambda>r.\n               case r of\n               (pi, bddi') \\<Rightarrow>\n                 is_bdd_impl\n                  (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_))\n                    x2k_)\n                  bddi' *\n                 \\<up> (pi = p_)>\\<^sub>t", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ =\n        dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_ bddi_ * \\<up> (x = None) *\n                          true> case x of\n                                None \\<Rightarrow>\n                                  param_optci i_ t_ e_ bddi_ \\<bind>\n                                  (\\<lambda>(po, s).\ncase po of\nNone \\<Rightarrow>\n  lowest_topsci [i_, t_, e_] s \\<bind>\n  case_option (raise STR ''Cannot happen'')\n   (\\<lambda>a.\n       restrict_topci i_ a True s \\<bind>\n       (\\<lambda>ti.\n           restrict_topci t_ a True s \\<bind>\n           (\\<lambda>tt.\n               restrict_topci e_ a True s \\<bind>\n               (\\<lambda>te.\n                   restrict_topci i_ a False s \\<bind>\n                   (\\<lambda>fi.\n                       restrict_topci t_ a False s \\<bind>\n                       (\\<lambda>ft.\n                           restrict_topci e_ a False s \\<bind>\n                           (\\<lambda>fe.\n                               iteci_lu ti tt te s \\<bind>\n                               (\\<lambda>(tb, s).\n                                   iteci_lu fi ft fe s \\<bind>\n                                   (\\<lambda>(fb, s).\n ifci a tb fb s \\<bind>\n (\\<lambda>(r, s).\n     hm_update (i_, t_, e_) r (dcli s) \\<bind>\n     (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n| Some b \\<Rightarrow> return (b, s))\n                                | Some b \\<Rightarrow>\n                                    return\n                                     (b,\nbddi_) <\\<lambda>r.\n           case r of\n           (pi, bddi') \\<Rightarrow>\n             is_bdd_impl\n              (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n              bddi' *\n             \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ =\n     dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_ bddi_ * true>\n                      param_optci i_ t_ e_ bddi_ <?R56>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ =\n        dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n       \\<Longrightarrow> <?R56\n                           x> case x of\n                              (None, s) \\<Rightarrow>\n                                lowest_topsci [i_, t_, e_] s \\<bind>\n                                case_option (raise STR ''Cannot happen'')\n                                 (\\<lambda>a.\n                                     restrict_topci i_ a True s \\<bind>\n                                     (\\<lambda>ti.\n   restrict_topci t_ a True s \\<bind>\n   (\\<lambda>tt.\n       restrict_topci e_ a True s \\<bind>\n       (\\<lambda>te.\n           restrict_topci i_ a False s \\<bind>\n           (\\<lambda>fi.\n               restrict_topci t_ a False s \\<bind>\n               (\\<lambda>ft.\n                   restrict_topci e_ a False s \\<bind>\n                   (\\<lambda>fe.\n                       iteci_lu ti tt te s \\<bind>\n                       (\\<lambda>(tb, s).\n                           iteci_lu fi ft fe s \\<bind>\n                           (\\<lambda>(fb, s).\n                               ifci a tb fb s \\<bind>\n                               (\\<lambda>(r, s).\n                                   hm_update (i_, t_, e_) r (dcli s) \\<bind>\n                                   (\\<lambda>cl.\n return (r, dcli_update (const cl) s))))))))))))\n                              | (Some b, s) \\<Rightarrow>\n                                  return\n                                   (b, s) <\\<lambda>r.\n        case r of\n        (pi, bddi') \\<Rightarrow>\n          is_bdd_impl\n           (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n           bddi' *\n          \\<up> (pi = p_)>\\<^sub>t", "apply(rule fi_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ =\n     dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n    \\<Longrightarrow> <?P57> param_optci i_ t_ e_ bddi_ <?Q57>\n 2. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ =\n     dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n    \\<Longrightarrow> is_bdd_impl bdd_ bddi_ *\n                      true \\<Longrightarrow>\\<^sub>A\n                      ?P57 * ?F57\n 3. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ =\n        dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n       \\<Longrightarrow> <?Q57 x *\n                          ?F57> case x of\n                                (None, s) \\<Rightarrow>\n                                  lowest_topsci [i_, t_, e_] s \\<bind>\n                                  case_option (raise STR ''Cannot happen'')\n                                   (\\<lambda>a.\n restrict_topci i_ a True s \\<bind>\n (\\<lambda>ti.\n     restrict_topci t_ a True s \\<bind>\n     (\\<lambda>tt.\n         restrict_topci e_ a True s \\<bind>\n         (\\<lambda>te.\n             restrict_topci i_ a False s \\<bind>\n             (\\<lambda>fi.\n                 restrict_topci t_ a False s \\<bind>\n                 (\\<lambda>ft.\n                     restrict_topci e_ a False s \\<bind>\n                     (\\<lambda>fe.\n                         iteci_lu ti tt te s \\<bind>\n                         (\\<lambda>(tb, s).\n                             iteci_lu fi ft fe s \\<bind>\n                             (\\<lambda>(fb, s).\n                                 ifci a tb fb s \\<bind>\n                                 (\\<lambda>(r, s).\n                                     hm_update (i_, t_, e_) r\n(dcli s) \\<bind>\n                                     (\\<lambda>cl.\n   return (r, dcli_update (const cl) s))))))))))))\n                                | (Some b, s) \\<Rightarrow>\n                                    return\n                                     (b,\ns) <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl\n          (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n          bddi' *\n         \\<up> (pi = p_)>\\<^sub>t", "apply(rule param_optci_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ =\n     dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n    \\<Longrightarrow> mi.param_opt_impl i_ t_ e_ ?bdd60 =\n                      Some (?p60, ?bdd'60)\n 2. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ =\n     dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n    \\<Longrightarrow> is_bdd_impl bdd_ bddi_ *\n                      true \\<Longrightarrow>\\<^sub>A\n                      is_bdd_impl ?bdd60 bddi_ * ?F57\n 3. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ =\n        dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl ?bdd'60 bddi' *\n                             \\<up> (pi = ?p60)) *\n                          true *\n                          ?F57> case x of\n                                (None, s) \\<Rightarrow>\n                                  lowest_topsci [i_, t_, e_] s \\<bind>\n                                  case_option (raise STR ''Cannot happen'')\n                                   (\\<lambda>a.\n restrict_topci i_ a True s \\<bind>\n (\\<lambda>ti.\n     restrict_topci t_ a True s \\<bind>\n     (\\<lambda>tt.\n         restrict_topci e_ a True s \\<bind>\n         (\\<lambda>te.\n             restrict_topci i_ a False s \\<bind>\n             (\\<lambda>fi.\n                 restrict_topci t_ a False s \\<bind>\n                 (\\<lambda>ft.\n                     restrict_topci e_ a False s \\<bind>\n                     (\\<lambda>fe.\n                         iteci_lu ti tt te s \\<bind>\n                         (\\<lambda>(tb, s).\n                             iteci_lu fi ft fe s \\<bind>\n                             (\\<lambda>(fb, s).\n                                 ifci a tb fb s \\<bind>\n                                 (\\<lambda>(r, s).\n                                     hm_update (i_, t_, e_) r\n(dcli s) \\<bind>\n                                     (\\<lambda>cl.\n   return (r, dcli_update (const cl) s))))))))))))\n                                | (Some b, s) \\<Rightarrow>\n                                    return\n                                     (b,\ns) <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl\n          (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n          bddi' *\n         \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n     mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n     mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n     mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n     mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n     mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n     mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n     mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n     s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n     s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n     ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n     bdd'_ =\n     dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n    \\<Longrightarrow> is_bdd_impl bdd_ bddi_ *\n                      true \\<Longrightarrow>\\<^sub>A\n                      is_bdd_impl bdd_ bddi_ * ?F57\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ =\n        dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl x2_ bddi' * \\<up> (pi = None)) *\n                          true *\n                          ?F57> case x of\n                                (None, s) \\<Rightarrow>\n                                  lowest_topsci [i_, t_, e_] s \\<bind>\n                                  case_option (raise STR ''Cannot happen'')\n                                   (\\<lambda>a.\n restrict_topci i_ a True s \\<bind>\n (\\<lambda>ti.\n     restrict_topci t_ a True s \\<bind>\n     (\\<lambda>tt.\n         restrict_topci e_ a True s \\<bind>\n         (\\<lambda>te.\n             restrict_topci i_ a False s \\<bind>\n             (\\<lambda>fi.\n                 restrict_topci t_ a False s \\<bind>\n                 (\\<lambda>ft.\n                     restrict_topci e_ a False s \\<bind>\n                     (\\<lambda>fe.\n                         iteci_lu ti tt te s \\<bind>\n                         (\\<lambda>(tb, s).\n                             iteci_lu fi ft fe s \\<bind>\n                             (\\<lambda>(fb, s).\n                                 ifci a tb fb s \\<bind>\n                                 (\\<lambda>(r, s).\n                                     hm_update (i_, t_, e_) r\n(dcli s) \\<bind>\n                                     (\\<lambda>cl.\n   return (r, dcli_update (const cl) s))))))))))))\n                                | (Some b, s) \\<Rightarrow>\n                                    return\n                                     (b,\ns) <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl\n          (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n          bddi' *\n         \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2a_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ =\n        dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl x2_ bddi' * \\<up> (pi = None)) *\n                          true *\n                          true> case x of\n                                (None, s) \\<Rightarrow>\n                                  lowest_topsci [i_, t_, e_] s \\<bind>\n                                  case_option (raise STR ''Cannot happen'')\n                                   (\\<lambda>a.\n restrict_topci i_ a True s \\<bind>\n (\\<lambda>ti.\n     restrict_topci t_ a True s \\<bind>\n     (\\<lambda>tt.\n         restrict_topci e_ a True s \\<bind>\n         (\\<lambda>te.\n             restrict_topci i_ a False s \\<bind>\n             (\\<lambda>fi.\n                 restrict_topci t_ a False s \\<bind>\n                 (\\<lambda>ft.\n                     restrict_topci e_ a False s \\<bind>\n                     (\\<lambda>fe.\n                         iteci_lu ti tt te s \\<bind>\n                         (\\<lambda>(tb, s).\n                             iteci_lu fi ft fe s \\<bind>\n                             (\\<lambda>(fb, s).\n                                 ifci a tb fb s \\<bind>\n                                 (\\<lambda>(r, s).\n                                     hm_update (i_, t_, e_) r\n(dcli s) \\<bind>\n                                     (\\<lambda>cl.\n   return (r, dcli_update (const cl) s))))))))))))\n                                | (Some b, s) \\<Rightarrow>\n                                    return\n                                     (b,\ns) <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl\n          (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n          bddi' *\n         \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl x2_ b * true>\n                         iteci_lu x1b_ x1c_ x1d_ b\n                         <?R238 b x1b_ x1c_ x1d_ x1e_ x1f_ x1g_>\n 2. \\<And>b x xa xb xc xd xe xf.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_; x = x1b_; xa = x1c_; xb = x1d_; xc = x1e_; xd = x1f_;\n        xe = x1g_\\<rbrakk>\n       \\<Longrightarrow> <?R238 b x xa xb xc xd xe\n                           xf> case xf of\n                               (tb, s) \\<Rightarrow>\n                                 iteci_lu x1e_ x1f_ x1g_ s \\<bind>\n                                 (\\<lambda>(fb, s).\n                                     ifci x2b_ tb fb s \\<bind>\n                                     (\\<lambda>(r, s).\n   hm_update (i_, t_, e_) r (dcli s) \\<bind>\n   (\\<lambda>cl.\n       return\n        (r, dcli_update (const cl)\n             s)))) <\\<lambda>r.\n                       case r of\n                       (pi, bddi') \\<Rightarrow>\n                         is_bdd_impl\n                          (dcl_update\n                            (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n                          bddi' *\n                         \\<up> (pi = p_)>\\<^sub>t", "unfolding imp_to_meta"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl x2_ b * true>\n                         iteci_lu x1b_ x1c_ x1d_ b\n                         <?R238 b x1b_ x1c_ x1d_ x1e_ x1f_ x1g_>\n 2. \\<And>b x xa xb xc xd xe xf.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_; x = x1b_; xa = x1c_; xb = x1d_; xc = x1e_; xd = x1f_;\n        xe = x1g_\\<rbrakk>\n       \\<Longrightarrow> <?R238 b x xa xb xc xd xe\n                           xf> case xf of\n                               (tb, s) \\<Rightarrow>\n                                 iteci_lu x1e_ x1f_ x1g_ s \\<bind>\n                                 (\\<lambda>(fb, s).\n                                     ifci x2b_ tb fb s \\<bind>\n                                     (\\<lambda>(r, s).\n   hm_update (i_, t_, e_) r (dcli s) \\<bind>\n   (\\<lambda>cl.\n       return\n        (r, dcli_update (const cl)\n             s)))) <\\<lambda>r.\n                       case r of\n                       (pi, bddi') \\<Rightarrow>\n                         is_bdd_impl\n                          (dcl_update\n                            (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n                          bddi' *\n                         \\<up> (pi = p_)>\\<^sub>t", "apply(rule fi_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> <?P247 b> iteci_lu x1b_ x1c_ x1d_ b\n                         <?Q249 b x1b_ x1c_ x1d_ x1e_ x1f_ x1g_>\n 2. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl x2_ b * true \\<Longrightarrow>\\<^sub>A\n                         ?P247 b * ?F250 b x1b_ x1c_ x1d_ x1e_ x1f_ x1g_\n 3. \\<And>b x xa xb xc xd xe xf.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_; x = x1b_; xa = x1c_; xb = x1d_; xc = x1e_; xd = x1f_;\n        xe = x1g_\\<rbrakk>\n       \\<Longrightarrow> <?Q249 b x xa xb xc xd xe xf *\n                          ?F250 b x xa xb xc xd\n                           xe> case xf of\n                               (tb, s) \\<Rightarrow>\n                                 iteci_lu x1e_ x1f_ x1g_ s \\<bind>\n                                 (\\<lambda>(fb, s).\n                                     ifci x2b_ tb fb s \\<bind>\n                                     (\\<lambda>(r, s).\n   hm_update (i_, t_, e_) r (dcli s) \\<bind>\n   (\\<lambda>cl.\n       return\n        (r, dcli_update (const cl)\n             s)))) <\\<lambda>r.\n                       case r of\n                       (pi, bddi') \\<Rightarrow>\n                         is_bdd_impl\n                          (dcl_update\n                            (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n                          bddi' *\n                         \\<up> (pi = p_)>\\<^sub>t", "apply(rprems)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> s_ x1b_ x1c_ x1d_ (?bdd254 b) =\n                         Some\n                          (?p257 b x1b_ x1c_ x1d_ x1e_ x1f_ x1g_,\n                           ?bdd'258 b x1b_ x1c_ x1d_ x1e_ x1f_ x1g_)\n 2. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl x2_ b * true \\<Longrightarrow>\\<^sub>A\n                         is_bdd_impl (?bdd254 b) b *\n                         ?F250 b x1b_ x1c_ x1d_ x1e_ x1f_ x1g_\n 3. \\<And>b x xa xb xc xd xe xf.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_; x = x1b_; xa = x1c_; xb = x1d_; xc = x1e_; xd = x1f_;\n        xe = x1g_\\<rbrakk>\n       \\<Longrightarrow> <(case xf of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl (?bdd'258 b x xa xb xc xd xe)\n                              bddi' *\n                             \\<up> (pi = ?p257 b x xa xb xc xd xe)) *\n                          true *\n                          ?F250 b x xa xb xc xd\n                           xe> case xf of\n                               (tb, s) \\<Rightarrow>\n                                 iteci_lu x1e_ x1f_ x1g_ s \\<bind>\n                                 (\\<lambda>(fb, s).\n                                     ifci x2b_ tb fb s \\<bind>\n                                     (\\<lambda>(r, s).\n   hm_update (i_, t_, e_) r (dcli s) \\<bind>\n   (\\<lambda>cl.\n       return\n        (r, dcli_update (const cl)\n             s)))) <\\<lambda>r.\n                       case r of\n                       (pi, bddi') \\<Rightarrow>\n                         is_bdd_impl\n                          (dcl_update\n                            (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n                          bddi' *\n                         \\<up> (pi = p_)>\\<^sub>t", "apply(simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl x2_ b * true \\<Longrightarrow>\\<^sub>A\n                         is_bdd_impl x2_ b *\n                         ?F250 b x1b_ x1c_ x1d_ x1e_ x1f_ x1g_\n 2. \\<And>b x xa xb xc xd xe xf.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_; x = x1b_; xa = x1c_; xb = x1d_; xc = x1e_; xd = x1f_;\n        xe = x1g_\\<rbrakk>\n       \\<Longrightarrow> <(case xf of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl x2i_ bddi' * \\<up> (pi = x1h_)) *\n                          true *\n                          ?F250 b x xa xb xc xd\n                           xe> case xf of\n                               (tb, s) \\<Rightarrow>\n                                 iteci_lu x1e_ x1f_ x1g_ s \\<bind>\n                                 (\\<lambda>(fb, s).\n                                     ifci x2b_ tb fb s \\<bind>\n                                     (\\<lambda>(r, s).\n   hm_update (i_, t_, e_) r (dcli s) \\<bind>\n   (\\<lambda>cl.\n       return\n        (r, dcli_update (const cl)\n             s)))) <\\<lambda>r.\n                       case r of\n                       (pi, bddi') \\<Rightarrow>\n                         is_bdd_impl\n                          (dcl_update\n                            (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n                          bddi' *\n                         \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x xa xb xc xd xe xf.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_; x = x1b_; xa = x1c_; xb = x1d_; xc = x1e_; xd = x1f_;\n        xe = x1g_\\<rbrakk>\n       \\<Longrightarrow> <(case xf of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl x2i_ bddi' * \\<up> (pi = x1h_)) *\n                          true *\n                          true> case xf of\n                                (tb, s) \\<Rightarrow>\n                                  iteci_lu x1e_ x1f_ x1g_ s \\<bind>\n                                  (\\<lambda>(fb, s).\nifci x2b_ tb fb s \\<bind>\n(\\<lambda>(r, s).\n    hm_update (i_, t_, e_) r (dcli s) \\<bind>\n    (\\<lambda>cl.\n        return\n         (r, dcli_update (const cl)\n              s)))) <\\<lambda>r.\n                        case r of\n                        (pi, bddi') \\<Rightarrow>\n                          is_bdd_impl\n                           (dcl_update\n                             (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_))\n                             x2k_)\n                           bddi' *\n                          \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl x2i_ b * true>\n                         iteci_lu x1e_ x1f_ x1g_ b <?R274 b>\n 2. \\<And>b x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> <?R274 b\n                           x> case x of\n                              (fb, s) \\<Rightarrow>\n                                ifci x2b_ x1h_ fb s \\<bind>\n                                (\\<lambda>(r, s).\n                                    hm_update (i_, t_, e_) r\n                                     (dcli s) \\<bind>\n                                    (\\<lambda>cl.\n  return\n   (r, dcli_update (const cl)\n        s))) <\\<lambda>r.\n                 case r of\n                 (pi, bddi') \\<Rightarrow>\n                   is_bdd_impl\n                    (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_))\n                      x2k_)\n                    bddi' *\n                   \\<up> (pi = p_)>\\<^sub>t", "apply(rule fi_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> <?P275 b> iteci_lu x1e_ x1f_ x1g_ b <?Q275 b>\n 2. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl x2i_ b * true \\<Longrightarrow>\\<^sub>A\n                         ?P275 b * ?F275 b\n 3. \\<And>b x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> <?Q275 b x *\n                          ?F275\n                           b> case x of\n                              (fb, s) \\<Rightarrow>\n                                ifci x2b_ x1h_ fb s \\<bind>\n                                (\\<lambda>(r, s).\n                                    hm_update (i_, t_, e_) r\n                                     (dcli s) \\<bind>\n                                    (\\<lambda>cl.\n  return\n   (r, dcli_update (const cl)\n        s))) <\\<lambda>r.\n                 case r of\n                 (pi, bddi') \\<Rightarrow>\n                   is_bdd_impl\n                    (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_))\n                      x2k_)\n                    bddi' *\n                   \\<up> (pi = p_)>\\<^sub>t", "apply(rprems)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> s_ x1e_ x1f_ x1g_ (?bdd279 b) =\n                         Some (?p279 b, ?bdd'279 b)\n 2. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl x2i_ b * true \\<Longrightarrow>\\<^sub>A\n                         is_bdd_impl (?bdd279 b) b * ?F275 b\n 3. \\<And>b x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl (?bdd'279 b) bddi' *\n                             \\<up> (pi = ?p279 b)) *\n                          true *\n                          ?F275\n                           b> case x of\n                              (fb, s) \\<Rightarrow>\n                                ifci x2b_ x1h_ fb s \\<bind>\n                                (\\<lambda>(r, s).\n                                    hm_update (i_, t_, e_) r\n                                     (dcli s) \\<bind>\n                                    (\\<lambda>cl.\n  return\n   (r, dcli_update (const cl)\n        s))) <\\<lambda>r.\n                 case r of\n                 (pi, bddi') \\<Rightarrow>\n                   is_bdd_impl\n                    (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_))\n                      x2k_)\n                    bddi' *\n                   \\<up> (pi = p_)>\\<^sub>t", "apply(simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl x2i_ b * true \\<Longrightarrow>\\<^sub>A\n                         is_bdd_impl x2i_ b * ?F275 b\n 2. \\<And>b x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl x2j_ bddi' * \\<up> (pi = x1i_)) *\n                          true *\n                          ?F275\n                           b> case x of\n                              (fb, s) \\<Rightarrow>\n                                ifci x2b_ x1h_ fb s \\<bind>\n                                (\\<lambda>(r, s).\n                                    hm_update (i_, t_, e_) r\n                                     (dcli s) \\<bind>\n                                    (\\<lambda>cl.\n  return\n   (r, dcli_update (const cl)\n        s))) <\\<lambda>r.\n                 case r of\n                 (pi, bddi') \\<Rightarrow>\n                   is_bdd_impl\n                    (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_))\n                      x2k_)\n                    bddi' *\n                   \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl x2j_ bddi' * \\<up> (pi = x1i_)) *\n                          true *\n                          true> case x of\n                                (fb, s) \\<Rightarrow>\n                                  ifci x2b_ x1h_ fb s \\<bind>\n                                  (\\<lambda>(r, s).\nhm_update (i_, t_, e_) r (dcli s) \\<bind>\n(\\<lambda>cl.\n    return\n     (r, dcli_update (const cl)\n          s))) <\\<lambda>r.\n                   case r of\n                   (pi, bddi') \\<Rightarrow>\n                     is_bdd_impl\n                      (dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_))\n                        x2k_)\n                      bddi' *\n                     \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa xa.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl (updS x2k_ (i_, t_, e_) p_)\n                          (dcli_update (const xa) sa) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         is_bdd_impl\n                          (dcl_update\n                            (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n                          (dcli_update (const xa) sa) *\n                         true", "unfolding updS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa xa.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<Longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (None, x2_);\n        mi.lowest_tops_impl [i_, t_, e_] x2_ = Some (Some x2b_, x2_);\n        mi.restrict_top_impl i_ x2b_ True x2_ = Some (x1b_, x2c_);\n        mi.restrict_top_impl t_ x2b_ True x2_ = Some (x1c_, x2d_);\n        mi.restrict_top_impl e_ x2b_ True x2_ = Some (x1d_, x2e_);\n        mi.restrict_top_impl i_ x2b_ False x2_ = Some (x1e_, x2f_);\n        mi.restrict_top_impl t_ x2b_ False x2_ = Some (x1f_, x2g_);\n        mi.restrict_top_impl e_ x2b_ False x2_ = Some (x1g_, x2h_);\n        s_ x1b_ x1c_ x1d_ x2_ = Some (x1h_, x2i_);\n        s_ x1e_ x1f_ x1g_ x2i_ = Some (x1i_, x2j_);\n        ifmi' x2b_ x1h_ x1i_ x2j_ = Some (p_, x2k_);\n        bdd'_ = dcl_update (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_;\n        x2a_ = x2_\\<rbrakk>\n       \\<Longrightarrow> is_bdd_impl\n                          (dcl_update\n                            (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n                          (dcli_update (const xa) sa) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         is_bdd_impl\n                          (dcl_update\n                            (\\<lambda>m. m((i_, t_, e_) \\<mapsto> p_)) x2k_)\n                          (dcli_update (const xa) sa) *\n                         true", "by (sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_\n                        bddi_> iteci_lu i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t\n 2. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd'_ (i_, t_, e_) = Some p_; bdd_ = bdd'_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd'_\n                        bddi_> iteci_lu i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_\n                        bddi_> iteci_lu i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(subst iteci_lu.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_\n                        bddi_> hm_lookup (i_, t_, e_) (dcli bddi_) \\<bind>\n                               case_option\n                                (param_optci i_ t_ e_ bddi_ \\<bind>\n                                 (\\<lambda>(po, s).\n                                     case po of\n                                     None \\<Rightarrow>\n lowest_topsci [i_, t_, e_] s \\<bind>\n case_option (raise STR ''Cannot happen'')\n  (\\<lambda>a.\n      restrict_topci i_ a True s \\<bind>\n      (\\<lambda>ti.\n          restrict_topci t_ a True s \\<bind>\n          (\\<lambda>tt.\n              restrict_topci e_ a True s \\<bind>\n              (\\<lambda>te.\n                  restrict_topci i_ a False s \\<bind>\n                  (\\<lambda>fi.\n                      restrict_topci t_ a False s \\<bind>\n                      (\\<lambda>ft.\n                          restrict_topci e_ a False s \\<bind>\n                          (\\<lambda>fe.\n                              iteci_lu ti tt te s \\<bind>\n                              (\\<lambda>(tb, s).\n                                  iteci_lu fi ft fe s \\<bind>\n                                  (\\<lambda>(fb, s).\nifci a tb fb s \\<bind>\n(\\<lambda>(r, s).\n    hm_update (i_, t_, e_) r (dcli s) \\<bind>\n    (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n                                     | Some b \\<Rightarrow> return (b, s)))\n                                (\\<lambda>b.\n                                    return\n                                     (b,\nbddi_)) <\\<lambda>r.\n            case r of\n            (pi, bddi') \\<Rightarrow>\n              is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_ bddi_>\n                      hm_lookup (i_, t_, e_) (dcli bddi_) <?R1>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <?R1 x> case x of\n                                 None \\<Rightarrow>\n                                   param_optci i_ t_ e_ bddi_ \\<bind>\n                                   (\\<lambda>(po, s).\n case po of\n None \\<Rightarrow>\n   lowest_topsci [i_, t_, e_] s \\<bind>\n   case_option (raise STR ''Cannot happen'')\n    (\\<lambda>a.\n        restrict_topci i_ a True s \\<bind>\n        (\\<lambda>ti.\n            restrict_topci t_ a True s \\<bind>\n            (\\<lambda>tt.\n                restrict_topci e_ a True s \\<bind>\n                (\\<lambda>te.\n                    restrict_topci i_ a False s \\<bind>\n                    (\\<lambda>fi.\n                        restrict_topci t_ a False s \\<bind>\n                        (\\<lambda>ft.\n                            restrict_topci e_ a False s \\<bind>\n                            (\\<lambda>fe.\n                                iteci_lu ti tt te s \\<bind>\n                                (\\<lambda>(tb, s).\n                                    iteci_lu fi ft fe s \\<bind>\n                                    (\\<lambda>(fb, s).\n  ifci a tb fb s \\<bind>\n  (\\<lambda>(r, s).\n      hm_update (i_, t_, e_) r (dcli s) \\<bind>\n      (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n | Some b \\<Rightarrow> return (b, s))\n                                 | Some b \\<Rightarrow>\n                                     return\n(b, bddi_) <\\<lambda>r.\n               case r of\n               (pi, bddi') \\<Rightarrow>\n                 is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "using bdd_hm_lookup_rule"], ["proof (prove)\nusing this:\n  dcl ?bdd (?i, ?t, ?e) = ?p \\<Longrightarrow>\n  <is_bdd_impl ?bdd\n    ?bddi> hm_lookup (?i, ?t, ?e)\n            (dcli\n              ?bddi) <\\<lambda>r.\n                         is_bdd_impl ?bdd ?bddi * \\<up> (r = ?p)>\\<^sub>t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_ bddi_>\n                      hm_lookup (i_, t_, e_) (dcli bddi_) <?R1>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <?R1 x> case x of\n                                 None \\<Rightarrow>\n                                   param_optci i_ t_ e_ bddi_ \\<bind>\n                                   (\\<lambda>(po, s).\n case po of\n None \\<Rightarrow>\n   lowest_topsci [i_, t_, e_] s \\<bind>\n   case_option (raise STR ''Cannot happen'')\n    (\\<lambda>a.\n        restrict_topci i_ a True s \\<bind>\n        (\\<lambda>ti.\n            restrict_topci t_ a True s \\<bind>\n            (\\<lambda>tt.\n                restrict_topci e_ a True s \\<bind>\n                (\\<lambda>te.\n                    restrict_topci i_ a False s \\<bind>\n                    (\\<lambda>fi.\n                        restrict_topci t_ a False s \\<bind>\n                        (\\<lambda>ft.\n                            restrict_topci e_ a False s \\<bind>\n                            (\\<lambda>fe.\n                                iteci_lu ti tt te s \\<bind>\n                                (\\<lambda>(tb, s).\n                                    iteci_lu fi ft fe s \\<bind>\n                                    (\\<lambda>(fb, s).\n  ifci a tb fb s \\<bind>\n  (\\<lambda>(r, s).\n      hm_update (i_, t_, e_) r (dcli s) \\<bind>\n      (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n | Some b \\<Rightarrow> return (b, s))\n                                 | Some b \\<Rightarrow>\n                                     return\n(b, bddi_) <\\<lambda>r.\n               case r of\n               (pi, bddi') \\<Rightarrow>\n                 is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd_ bddi_ * \\<up> (x = None) *\n                          true> case x of\n                                None \\<Rightarrow>\n                                  param_optci i_ t_ e_ bddi_ \\<bind>\n                                  (\\<lambda>(po, s).\ncase po of\nNone \\<Rightarrow>\n  lowest_topsci [i_, t_, e_] s \\<bind>\n  case_option (raise STR ''Cannot happen'')\n   (\\<lambda>a.\n       restrict_topci i_ a True s \\<bind>\n       (\\<lambda>ti.\n           restrict_topci t_ a True s \\<bind>\n           (\\<lambda>tt.\n               restrict_topci e_ a True s \\<bind>\n               (\\<lambda>te.\n                   restrict_topci i_ a False s \\<bind>\n                   (\\<lambda>fi.\n                       restrict_topci t_ a False s \\<bind>\n                       (\\<lambda>ft.\n                           restrict_topci e_ a False s \\<bind>\n                           (\\<lambda>fe.\n                               iteci_lu ti tt te s \\<bind>\n                               (\\<lambda>(tb, s).\n                                   iteci_lu fi ft fe s \\<bind>\n                                   (\\<lambda>(fb, s).\n ifci a tb fb s \\<bind>\n (\\<lambda>(r, s).\n     hm_update (i_, t_, e_) r (dcli s) \\<bind>\n     (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n| Some b \\<Rightarrow> return (b, s))\n                                | Some b \\<Rightarrow>\n                                    return\n                                     (b,\nbddi_) <\\<lambda>r.\n           case r of\n           (pi, bddi') \\<Rightarrow>\n             is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd_ bddi_ * true>\n                      param_optci i_ t_ e_ bddi_ <?R36>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <?R36\n                           x> case x of\n                              (None, s) \\<Rightarrow>\n                                lowest_topsci [i_, t_, e_] s \\<bind>\n                                case_option (raise STR ''Cannot happen'')\n                                 (\\<lambda>a.\n                                     restrict_topci i_ a True s \\<bind>\n                                     (\\<lambda>ti.\n   restrict_topci t_ a True s \\<bind>\n   (\\<lambda>tt.\n       restrict_topci e_ a True s \\<bind>\n       (\\<lambda>te.\n           restrict_topci i_ a False s \\<bind>\n           (\\<lambda>fi.\n               restrict_topci t_ a False s \\<bind>\n               (\\<lambda>ft.\n                   restrict_topci e_ a False s \\<bind>\n                   (\\<lambda>fe.\n                       iteci_lu ti tt te s \\<bind>\n                       (\\<lambda>(tb, s).\n                           iteci_lu fi ft fe s \\<bind>\n                           (\\<lambda>(fb, s).\n                               ifci a tb fb s \\<bind>\n                               (\\<lambda>(r, s).\n                                   hm_update (i_, t_, e_) r (dcli s) \\<bind>\n                                   (\\<lambda>cl.\n return (r, dcli_update (const cl) s))))))))))))\n                              | (Some b, s) \\<Rightarrow>\n                                  return\n                                   (b, s) <\\<lambda>r.\n        case r of\n        (pi, bddi') \\<Rightarrow>\n          is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(rule fi_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> <?P37> param_optci i_ t_ e_ bddi_ <?Q37>\n 2. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> is_bdd_impl bdd_ bddi_ *\n                      true \\<Longrightarrow>\\<^sub>A\n                      ?P37 * ?F37\n 3. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <?Q37 x *\n                          ?F37> case x of\n                                (None, s) \\<Rightarrow>\n                                  lowest_topsci [i_, t_, e_] s \\<bind>\n                                  case_option (raise STR ''Cannot happen'')\n                                   (\\<lambda>a.\n restrict_topci i_ a True s \\<bind>\n (\\<lambda>ti.\n     restrict_topci t_ a True s \\<bind>\n     (\\<lambda>tt.\n         restrict_topci e_ a True s \\<bind>\n         (\\<lambda>te.\n             restrict_topci i_ a False s \\<bind>\n             (\\<lambda>fi.\n                 restrict_topci t_ a False s \\<bind>\n                 (\\<lambda>ft.\n                     restrict_topci e_ a False s \\<bind>\n                     (\\<lambda>fe.\n                         iteci_lu ti tt te s \\<bind>\n                         (\\<lambda>(tb, s).\n                             iteci_lu fi ft fe s \\<bind>\n                             (\\<lambda>(fb, s).\n                                 ifci a tb fb s \\<bind>\n                                 (\\<lambda>(r, s).\n                                     hm_update (i_, t_, e_) r\n(dcli s) \\<bind>\n                                     (\\<lambda>cl.\n   return (r, dcli_update (const cl) s))))))))))))\n                                | (Some b, s) \\<Rightarrow>\n                                    return\n                                     (b,\ns) <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(rule param_optci_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> mi.param_opt_impl i_ t_ e_ ?bdd40 =\n                      Some (?p40, ?bdd'40)\n 2. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> is_bdd_impl bdd_ bddi_ *\n                      true \\<Longrightarrow>\\<^sub>A\n                      is_bdd_impl ?bdd40 bddi_ * ?F37\n 3. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl ?bdd'40 bddi' *\n                             \\<up> (pi = ?p40)) *\n                          true *\n                          ?F37> case x of\n                                (None, s) \\<Rightarrow>\n                                  lowest_topsci [i_, t_, e_] s \\<bind>\n                                  case_option (raise STR ''Cannot happen'')\n                                   (\\<lambda>a.\n restrict_topci i_ a True s \\<bind>\n (\\<lambda>ti.\n     restrict_topci t_ a True s \\<bind>\n     (\\<lambda>tt.\n         restrict_topci e_ a True s \\<bind>\n         (\\<lambda>te.\n             restrict_topci i_ a False s \\<bind>\n             (\\<lambda>fi.\n                 restrict_topci t_ a False s \\<bind>\n                 (\\<lambda>ft.\n                     restrict_topci e_ a False s \\<bind>\n                     (\\<lambda>fe.\n                         iteci_lu ti tt te s \\<bind>\n                         (\\<lambda>(tb, s).\n                             iteci_lu fi ft fe s \\<bind>\n                             (\\<lambda>(fb, s).\n                                 ifci a tb fb s \\<bind>\n                                 (\\<lambda>(r, s).\n                                     hm_update (i_, t_, e_) r\n(dcli s) \\<bind>\n                                     (\\<lambda>cl.\n   return (r, dcli_update (const cl) s))))))))))))\n                                | (Some b, s) \\<Rightarrow>\n                                    return\n                                     (b,\ns) <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd_ (i_, t_, e_) = None;\n     mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n    \\<Longrightarrow> is_bdd_impl bdd_ bddi_ *\n                      true \\<Longrightarrow>\\<^sub>A\n                      is_bdd_impl bdd_ bddi_ * ?F37\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl bdd'_ bddi' *\n                             \\<up> (pi = Some p_)) *\n                          true *\n                          ?F37> case x of\n                                (None, s) \\<Rightarrow>\n                                  lowest_topsci [i_, t_, e_] s \\<bind>\n                                  case_option (raise STR ''Cannot happen'')\n                                   (\\<lambda>a.\n restrict_topci i_ a True s \\<bind>\n (\\<lambda>ti.\n     restrict_topci t_ a True s \\<bind>\n     (\\<lambda>tt.\n         restrict_topci e_ a True s \\<bind>\n         (\\<lambda>te.\n             restrict_topci i_ a False s \\<bind>\n             (\\<lambda>fi.\n                 restrict_topci t_ a False s \\<bind>\n                 (\\<lambda>ft.\n                     restrict_topci e_ a False s \\<bind>\n                     (\\<lambda>fe.\n                         iteci_lu ti tt te s \\<bind>\n                         (\\<lambda>(tb, s).\n                             iteci_lu fi ft fe s \\<bind>\n                             (\\<lambda>(fb, s).\n                                 ifci a tb fb s \\<bind>\n                                 (\\<lambda>(r, s).\n                                     hm_update (i_, t_, e_) r\n(dcli s) \\<bind>\n                                     (\\<lambda>cl.\n   return (r, dcli_update (const cl) s))))))))))))\n                                | (Some b, s) \\<Rightarrow>\n                                    return\n                                     (b,\ns) <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd_ (i_, t_, e_) = None;\n        mi.param_opt_impl i_ t_ e_ bdd_ = Some (Some p_, bdd'_)\\<rbrakk>\n       \\<Longrightarrow> <(case x of\n                           (pi, bddi') \\<Rightarrow>\n                             is_bdd_impl bdd'_ bddi' *\n                             \\<up> (pi = Some p_)) *\n                          true *\n                          true> case x of\n                                (None, s) \\<Rightarrow>\n                                  lowest_topsci [i_, t_, e_] s \\<bind>\n                                  case_option (raise STR ''Cannot happen'')\n                                   (\\<lambda>a.\n restrict_topci i_ a True s \\<bind>\n (\\<lambda>ti.\n     restrict_topci t_ a True s \\<bind>\n     (\\<lambda>tt.\n         restrict_topci e_ a True s \\<bind>\n         (\\<lambda>te.\n             restrict_topci i_ a False s \\<bind>\n             (\\<lambda>fi.\n                 restrict_topci t_ a False s \\<bind>\n                 (\\<lambda>ft.\n                     restrict_topci e_ a False s \\<bind>\n                     (\\<lambda>fe.\n                         iteci_lu ti tt te s \\<bind>\n                         (\\<lambda>(tb, s).\n                             iteci_lu fi ft fe s \\<bind>\n                             (\\<lambda>(fb, s).\n                                 ifci a tb fb s \\<bind>\n                                 (\\<lambda>(r, s).\n                                     hm_update (i_, t_, e_) r\n(dcli s) \\<bind>\n                                     (\\<lambda>cl.\n   return (r, dcli_update (const cl) s))))))))))))\n                                | (Some b, s) \\<Rightarrow>\n                                    return\n                                     (b,\ns) <\\<lambda>r.\n       case r of\n       (pi, bddi') \\<Rightarrow>\n         is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "by (sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd'_ (i_, t_, e_) = Some p_; bdd_ = bdd'_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd'_\n                        bddi_> iteci_lu i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd'_ (i_, t_, e_) = Some p_; bdd_ = bdd'_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd'_\n                        bddi_> iteci_lu i_ t_ e_\n                                bddi_ <\\<lambda>r.\n    case r of\n    (pi, bddi') \\<Rightarrow>\n      is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(subst iteci_lu.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd'_ (i_, t_, e_) = Some p_; bdd_ = bdd'_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd'_\n                        bddi_> hm_lookup (i_, t_, e_) (dcli bddi_) \\<bind>\n                               case_option\n                                (param_optci i_ t_ e_ bddi_ \\<bind>\n                                 (\\<lambda>(po, s).\n                                     case po of\n                                     None \\<Rightarrow>\n lowest_topsci [i_, t_, e_] s \\<bind>\n case_option (raise STR ''Cannot happen'')\n  (\\<lambda>a.\n      restrict_topci i_ a True s \\<bind>\n      (\\<lambda>ti.\n          restrict_topci t_ a True s \\<bind>\n          (\\<lambda>tt.\n              restrict_topci e_ a True s \\<bind>\n              (\\<lambda>te.\n                  restrict_topci i_ a False s \\<bind>\n                  (\\<lambda>fi.\n                      restrict_topci t_ a False s \\<bind>\n                      (\\<lambda>ft.\n                          restrict_topci e_ a False s \\<bind>\n                          (\\<lambda>fe.\n                              iteci_lu ti tt te s \\<bind>\n                              (\\<lambda>(tb, s).\n                                  iteci_lu fi ft fe s \\<bind>\n                                  (\\<lambda>(fb, s).\nifci a tb fb s \\<bind>\n(\\<lambda>(r, s).\n    hm_update (i_, t_, e_) r (dcli s) \\<bind>\n    (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n                                     | Some b \\<Rightarrow> return (b, s)))\n                                (\\<lambda>b.\n                                    return\n                                     (b,\nbddi_)) <\\<lambda>r.\n            case r of\n            (pi, bddi') \\<Rightarrow>\n              is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd'_ (i_, t_, e_) = Some p_; bdd_ = bdd'_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd'_ bddi_>\n                      hm_lookup (i_, t_, e_) (dcli bddi_) <?R1>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd'_ (i_, t_, e_) = Some p_; bdd_ = bdd'_\\<rbrakk>\n       \\<Longrightarrow> <?R1 x> case x of\n                                 None \\<Rightarrow>\n                                   param_optci i_ t_ e_ bddi_ \\<bind>\n                                   (\\<lambda>(po, s).\n case po of\n None \\<Rightarrow>\n   lowest_topsci [i_, t_, e_] s \\<bind>\n   case_option (raise STR ''Cannot happen'')\n    (\\<lambda>a.\n        restrict_topci i_ a True s \\<bind>\n        (\\<lambda>ti.\n            restrict_topci t_ a True s \\<bind>\n            (\\<lambda>tt.\n                restrict_topci e_ a True s \\<bind>\n                (\\<lambda>te.\n                    restrict_topci i_ a False s \\<bind>\n                    (\\<lambda>fi.\n                        restrict_topci t_ a False s \\<bind>\n                        (\\<lambda>ft.\n                            restrict_topci e_ a False s \\<bind>\n                            (\\<lambda>fe.\n                                iteci_lu ti tt te s \\<bind>\n                                (\\<lambda>(tb, s).\n                                    iteci_lu fi ft fe s \\<bind>\n                                    (\\<lambda>(fb, s).\n  ifci a tb fb s \\<bind>\n  (\\<lambda>(r, s).\n      hm_update (i_, t_, e_) r (dcli s) \\<bind>\n      (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n | Some b \\<Rightarrow> return (b, s))\n                                 | Some b \\<Rightarrow>\n                                     return\n(b, bddi_) <\\<lambda>r.\n               case r of\n               (pi, bddi') \\<Rightarrow>\n                 is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "using bdd_hm_lookup_rule"], ["proof (prove)\nusing this:\n  dcl ?bdd (?i, ?t, ?e) = ?p \\<Longrightarrow>\n  <is_bdd_impl ?bdd\n    ?bddi> hm_lookup (?i, ?t, ?e)\n            (dcli\n              ?bddi) <\\<lambda>r.\n                         is_bdd_impl ?bdd ?bddi * \\<up> (r = ?p)>\\<^sub>t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                <is_bdd_impl bdd\n                  bddi> iteci_lu i t e\n                         bddi <\\<lambda>r.\n                                  case r of\n                                  (pi, bddi') \\<Rightarrow>\n                                    is_bdd_impl bdd' bddi' *\n                                    \\<up> (pi = p)>\\<^sub>t;\n     dcl bdd'_ (i_, t_, e_) = Some p_; bdd_ = bdd'_\\<rbrakk>\n    \\<Longrightarrow> <is_bdd_impl bdd'_ bddi_>\n                      hm_lookup (i_, t_, e_) (dcli bddi_) <?R1>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd'_ (i_, t_, e_) = Some p_; bdd_ = bdd'_\\<rbrakk>\n       \\<Longrightarrow> <?R1 x> case x of\n                                 None \\<Rightarrow>\n                                   param_optci i_ t_ e_ bddi_ \\<bind>\n                                   (\\<lambda>(po, s).\n case po of\n None \\<Rightarrow>\n   lowest_topsci [i_, t_, e_] s \\<bind>\n   case_option (raise STR ''Cannot happen'')\n    (\\<lambda>a.\n        restrict_topci i_ a True s \\<bind>\n        (\\<lambda>ti.\n            restrict_topci t_ a True s \\<bind>\n            (\\<lambda>tt.\n                restrict_topci e_ a True s \\<bind>\n                (\\<lambda>te.\n                    restrict_topci i_ a False s \\<bind>\n                    (\\<lambda>fi.\n                        restrict_topci t_ a False s \\<bind>\n                        (\\<lambda>ft.\n                            restrict_topci e_ a False s \\<bind>\n                            (\\<lambda>fe.\n                                iteci_lu ti tt te s \\<bind>\n                                (\\<lambda>(tb, s).\n                                    iteci_lu fi ft fe s \\<bind>\n                                    (\\<lambda>(fb, s).\n  ifci a tb fb s \\<bind>\n  (\\<lambda>(r, s).\n      hm_update (i_, t_, e_) r (dcli s) \\<bind>\n      (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n | Some b \\<Rightarrow> return (b, s))\n                                 | Some b \\<Rightarrow>\n                                     return\n(b, bddi_) <\\<lambda>r.\n               case r of\n               (pi, bddi') \\<Rightarrow>\n                 is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>i t e bddi bdd p bdd'.\n                   s_ i t e bdd = Some (p, bdd') \\<longrightarrow>\n                   <is_bdd_impl bdd\n                     bddi> iteci_lu i t e\n                            bddi <\\<lambda>r.\n                                     case r of\n                                     (pi, bddi') \\<Rightarrow>\n is_bdd_impl bdd' bddi' * \\<up> (pi = p)>\\<^sub>t;\n        dcl bdd'_ (i_, t_, e_) = Some p_; bdd_ = bdd'_\\<rbrakk>\n       \\<Longrightarrow> <is_bdd_impl bdd'_ bddi_ * \\<up> (x = Some p_) *\n                          true> case x of\n                                None \\<Rightarrow>\n                                  param_optci i_ t_ e_ bddi_ \\<bind>\n                                  (\\<lambda>(po, s).\ncase po of\nNone \\<Rightarrow>\n  lowest_topsci [i_, t_, e_] s \\<bind>\n  case_option (raise STR ''Cannot happen'')\n   (\\<lambda>a.\n       restrict_topci i_ a True s \\<bind>\n       (\\<lambda>ti.\n           restrict_topci t_ a True s \\<bind>\n           (\\<lambda>tt.\n               restrict_topci e_ a True s \\<bind>\n               (\\<lambda>te.\n                   restrict_topci i_ a False s \\<bind>\n                   (\\<lambda>fi.\n                       restrict_topci t_ a False s \\<bind>\n                       (\\<lambda>ft.\n                           restrict_topci e_ a False s \\<bind>\n                           (\\<lambda>fe.\n                               iteci_lu ti tt te s \\<bind>\n                               (\\<lambda>(tb, s).\n                                   iteci_lu fi ft fe s \\<bind>\n                                   (\\<lambda>(fb, s).\n ifci a tb fb s \\<bind>\n (\\<lambda>(r, s).\n     hm_update (i_, t_, e_) r (dcli s) \\<bind>\n     (\\<lambda>cl. return (r, dcli_update (const cl) s))))))))))))\n| Some b \\<Rightarrow> return (b, s))\n                                | Some b \\<Rightarrow>\n                                    return\n                                     (b,\nbddi_) <\\<lambda>r.\n           case r of\n           (pi, bddi') \\<Rightarrow>\n             is_bdd_impl bdd'_ bddi' * \\<up> (pi = p_)>\\<^sub>t", "by(sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>A standard library of functions\\<close>"], ["", "declare iteci_rule[THEN mp, sep_heap_rules]"], ["", "definition \"notci e s \\<equiv> do {\n  (f,s) \\<leftarrow> fci s;\n  (t,s) \\<leftarrow> tci s;\n  iteci_lu e f t s\n}\""], ["", "definition \"orci e1 e2 s \\<equiv> do {\n  (t,s) \\<leftarrow> tci s;\n  iteci_lu e1 t e2 s\n}\""], ["", "definition \"andci e1 e2 s \\<equiv> do {\n  (f,s) \\<leftarrow> fci s;\n  iteci_lu e1 e2 f s\n}\""], ["", "definition \"norci e1 e2 s \\<equiv> do {\n  (r,s) \\<leftarrow> orci e1 e2 s;\n  notci r s\n}\""], ["", "definition \"nandci e1 e2 s \\<equiv> do {\n  (r,s) \\<leftarrow> andci e1 e2 s;\n  notci r s\n}\""], ["", "definition \"biimpci a b s \\<equiv> do {\n  (nb,s) \\<leftarrow> notci b s;\n  iteci_lu a b nb s\n}\""], ["", "definition \"xorci a b s \\<equiv> do {\n  (nb,s) \\<leftarrow> notci b s;\n  iteci_lu a nb b s\n}\""], ["", "definition \"litci v bdd \\<equiv> do {\n  (t,bdd) \\<leftarrow> tci bdd;\n  (f,bdd) \\<leftarrow> fci bdd;\n  ifci v t f bdd\n}\""], ["", "definition \"tautci v bdd \\<equiv> do {\n  d \\<leftarrow> destrci v bdd;\n  return (d = TD)\n}\""], ["", "subsection\\<open>Printing\\<close>"], ["", "text\\<open>The following functions are exported unverified. They are intended for BDD debugging purposes.\\<close>"], ["", "partial_function(heap) serializeci :: \"nat \\<Rightarrow> bddi \\<Rightarrow> ((nat \\<times> nat) \\<times> nat) list Heap\" where\n\"serializeci p s = do {\n  d \\<leftarrow> destrci p s;\n  (case d of \n    IFD v t e \\<Rightarrow> do {\n      r \\<leftarrow> serializeci t s;\n      l \\<leftarrow> serializeci e s;\n      return (remdups ([((p,t),1),((p,e),0)] @ r @ l))\n    } |\n    _ \\<Rightarrow> return []\n  )\n}\""], ["", "declare serializeci.simps[code]"], ["", "(* This snaps to heap as a Monad, which is not intended, but irrelevant. *)"], ["", "fun mapM where\n\"mapM f [] = return []\" |\n\"mapM f (a#as) = do {\n  r \\<leftarrow> f a;\n  rs \\<leftarrow> mapM f as;\n  return (r#rs)\n}\""], ["", "definition \"liftM f ma = do { a \\<leftarrow> ma; return (f a) }\""], ["", "definition \"sequence = mapM id\""], ["", "term \"liftM (map f)\""], ["", "lemma \"liftM (map f) (sequence l) = sequence (map (liftM f) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftM (map f) (sequence l) = sequence (map (liftM f) l)", "apply(induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. liftM (map f) (sequence []) = sequence (map (liftM f) [])\n 2. \\<And>a l.\n       liftM (map f) (sequence l) =\n       sequence (map (liftM f) l) \\<Longrightarrow>\n       liftM (map f) (sequence (a # l)) = sequence (map (liftM f) (a # l))", "apply(simp add: sequence_def liftM_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       liftM (map f) (sequence l) =\n       sequence (map (liftM f) l) \\<Longrightarrow>\n       liftM (map f) (sequence (a # l)) = sequence (map (liftM f) (a # l))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       liftM (map f) (sequence l) =\n       sequence (map (liftM f) l) \\<Longrightarrow>\n       liftM (map f) (sequence (a # l)) =\n       sequence (liftM f a # map (liftM f) l)", "oops"], ["", "(*http://stackoverflow.com/questions/23864965/string-of-nat-in-isabelle*)"], ["", "fun string_of_nat :: \"nat \\<Rightarrow> string\" where\n  \"string_of_nat n = (if n < 10 then [char_of_nat (48 + n)]\n                                else string_of_nat (n div 10) @ [char_of_nat (48 + (n mod 10))])\""], ["", "definition labelci :: \"bddi \\<Rightarrow> nat \\<Rightarrow> (string \\<times> string \\<times> string) Heap\" where\n\"labelci s n = do {\n   d \\<leftarrow> destrci n s;\n   let son = string_of_nat n;\n   let label = (case d of\n     TD \\<Rightarrow> ''T'' |\n     FD \\<Rightarrow> ''F'' |\n     (IFD v _ _) \\<Rightarrow> string_of_nat v);\n   return (label, son, son @ ''[label='' @ label @ ''];\\010'')\n}\""], ["", "definition \"graphifyci1 bdd a \\<equiv> do {\n  let ((f,t),y) = a;\n  let c = (string_of_nat f @ '' -> '' @ string_of_nat t);\n  return (c @ (case y of 0 \\<Rightarrow> '' [style=dotted]'' | Suc _ \\<Rightarrow> '''') @ '';\\010'')\n}\""], ["", "definition \"trd = snd \\<circ> snd\""], ["", "definition \"fstp = apsnd fst\""], ["", "definition \"the_thing_By f l = (let \n  nub = remdups (map fst l) in\n  map (\\<lambda>e. (e, map snd (filter (\\<lambda>g. (f e (fst g))) l))) nub)\""], ["", "definition \"the_thing = the_thing_By (=)\""], ["", "definition graphifyci :: \"string \\<Rightarrow> nat \\<Rightarrow> bddi \\<Rightarrow> string Heap\" where\n\"graphifyci name ep bdd \\<equiv> do {\n  s \\<leftarrow> serializeci ep bdd;\n  let e = map fst s;\n  l \\<leftarrow> mapM (labelci bdd) (rev (remdups (map fst e @ map snd e)));\n  let grp =  (map (\\<lambda>l. foldr (\\<lambda>a t. t @ a @ '';'') (snd l) ''{rank=same;'' @ ''}\\010'') (the_thing (map fstp l)));\n  e \\<leftarrow> mapM (graphifyci1 bdd) s;\n  let emptyhlp = (case ep of 0 \\<Rightarrow> ''F;\\010'' | Suc 0 \\<Rightarrow> ''T;\\010'' | _ \\<Rightarrow> '''');  \n  return (''digraph '' @ name @ '' {\\010'' @ concat (map trd l) @ concat grp @ concat e @ emptyhlp @ ''}'')\n}\""], ["", "end"]]}