{"file_name": "/home/qj213/afp-2021-10-22/thys/Vickrey_Clarke_Groves/Argmax.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Vickrey_Clarke_Groves", "problem_names": ["lemma structInduct: assumes \"P []\" and \"\\<forall>x xs. P (xs) \\<longrightarrow> P (x#xs)\" \n                    shows \"P l\"", "lemma argmaxLemma: \"argmax f A = { x \\<in> A . f x = Max (f ` A) }\"", "lemma maxLemma: \n  assumes \"x \\<in> X\" \"finite X\" \n  shows \"Max (f`X) >= f x\" \n  (is \"?L >= ?R\")", "lemma lm01: \n  \"argmax f A = A \\<inter> f -` {Max (f ` A)}\"", "lemma lm02: \n  assumes \"y \\<in> f`A\" \n  shows \"A \\<inter> f -` {y} \\<noteq> {}\"", "lemma argmaxEquivalence: \n  assumes \"\\<forall>x\\<in>X. f x = g x\" \n  shows \"argmax f X = argmax g X\"", "lemma lm03: \"maxpositions l = [n. n\\<leftarrow>[0..<size l], l!n \\<ge> Max(set l)]\"", "lemma lm04: \"[n . n <- l, P n] = [n . n <- l, n \\<in> set l, P n]\"", "lemma lm05: \"[n . n <- [0..<m], P n] = [n . n <- [0..<m], n \\<in> set [0..<m], P n]\"", "lemma lm06: fixes f m P \n            shows \"(map f [n . n <- [0..<m], P n]) = [ f n . n <- [0..<m], P n]\"", "lemma map_commutes_a: \"[f n . n <- [], Q (f n)] = [x <- (map f []). Q x]\"", "lemma map_commutes_b: \"\\<forall> x xs. ([f n . n <- xs,     Q (f n)] = [x <- (map f xs).     Q x] \\<longrightarrow> \n                                [f n . n <- (x#xs), Q (f n)] = [x <- (map f (x#xs)). Q x])\"", "lemma map_commutes: fixes f::\"'a => 'b\" fixes Q::\"'b => bool\" fixes xs::\"'a list\" \n                    shows \"[f n . n <- xs, Q (f n)] = [x <- (map f xs). Q x]\"", "lemma lm07: fixes f l \n            shows \"maxpositions (map f l) = \n                   [n . n <- [0..<size l], f (l!n) \\<ge> Max (f`(set l))]\" \n            (is \"maxpositions (?fl) = _\")", "lemma lm08: fixes f l \n            shows \"argmaxList f l = \n                   [ l!n . n <- [0..<size l], f (l!n) \\<ge> Max (f`(set l))]\"", "theorem argmaxadequacy: fixes f::\"'a => ('b::linorder)\" fixes l::\"'a list\" \n                        shows \"argmaxList f l = [ x <- l. f x \\<ge> Max (f`(set l))]\"\n                        (is \"?lh=_\")"], "translations": [["", "lemma structInduct: assumes \"P []\" and \"\\<forall>x xs. P (xs) \\<longrightarrow> P (x#xs)\" \n                    shows \"P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P l", "using assms list_nonempty_induct"], ["proof (prove)\nusing this:\n  P []\n  \\<forall>x xs. P xs \\<longrightarrow> P (x # xs)\n  \\<lbrakk>?xs \\<noteq> []; \\<And>x. ?P [x];\n   \\<And>x xs.\n      \\<lbrakk>xs \\<noteq> []; ?P xs\\<rbrakk>\n      \\<Longrightarrow> ?P (x # xs)\\<rbrakk>\n  \\<Longrightarrow> ?P ?xs\n\ngoal (1 subgoal):\n 1. P l", "by (metis)"], ["", "text \\<open>the subset of elements of a set where a function reaches its maximum\\<close>"], ["", "fun argmax :: \"('a \\<Rightarrow> 'b::linorder) \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\n    where \"argmax f A = { x \\<in> A . f x = Max (f ` A) }\""], ["", "(* For reasons we do not understand we have to duplicate the definition as a lemma \n   in order to prove lm16 in CombinatorialAuctions.thy. *)"], ["", "lemma argmaxLemma: \"argmax f A = { x \\<in> A . f x = Max (f ` A) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmax f A = {x \\<in> A. f x = Max (f ` A)}", "by simp"], ["", "lemma maxLemma: \n  assumes \"x \\<in> X\" \"finite X\" \n  shows \"Max (f`X) >= f x\" \n  (is \"?L >= ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> Max (f ` X)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> X\n  finite X\n\ngoal (1 subgoal):\n 1. f x \\<le> Max (f ` X)", "by (metis (hide_lams, no_types) Max.coboundedI finite_imageI image_eqI)"], ["", "lemma lm01: \n  \"argmax f A = A \\<inter> f -` {Max (f ` A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmax f A = A \\<inter> f -` {Max (f ` A)}", "by force"], ["", "lemma lm02: \n  assumes \"y \\<in> f`A\" \n  shows \"A \\<inter> f -` {y} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> f -` {y} \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> f ` A\n\ngoal (1 subgoal):\n 1. A \\<inter> f -` {y} \\<noteq> {}", "by blast"], ["", "lemma argmaxEquivalence: \n  assumes \"\\<forall>x\\<in>X. f x = g x\" \n  shows \"argmax f X = argmax g X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmax f X = argmax g X", "using assms argmaxLemma Collect_cong image_cong"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. f x = g x\n  argmax ?f ?A = {x \\<in> ?A. ?f x = Max (?f ` ?A)}\n  (\\<And>x. ?P x = ?Q x) \\<Longrightarrow> {x. ?P x} = {x. ?Q x}\n  \\<lbrakk>?M = ?N;\n   \\<And>x. x \\<in> ?N \\<Longrightarrow> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?M = ?g ` ?N\n\ngoal (1 subgoal):\n 1. argmax f X = argmax g X", "by (metis(no_types,lifting))"], ["", "text \\<open>The arg max of a function over a non-empty set is non-empty.\\<close>"], ["", "corollary argmax_non_empty_iff: assumes \"finite X\" \"X \\<noteq> {}\" \n                                shows \"argmax f X \\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmax f X \\<noteq> {}", "using assms Max_in finite_imageI image_is_empty lm01 lm02"], ["proof (prove)\nusing this:\n  finite X\n  X \\<noteq> {}\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max ?A \\<in> ?A\n  finite ?F \\<Longrightarrow> finite (?h ` ?F)\n  (?f ` ?A = {}) = (?A = {})\n  argmax ?f ?A = ?A \\<inter> ?f -` {Max (?f ` ?A)}\n  ?y \\<in> ?f ` ?A \\<Longrightarrow> ?A \\<inter> ?f -` {?y} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. argmax f X \\<noteq> {}", "by (metis(no_types))"], ["", "text \\<open>The previous definition of argmax operates on sets. In the following we define a corresponding notion on lists. To this end, we start with defining a filter predicate and are looking for the elements of a list satisfying a given predicate;\nbut, rather than returning them directly, we return the (sorted) list of their indices. \nThis is done, in different ways, by @{term filterpositions} and @{term filterpositions2}.\\<close>"], ["", "(* Given a list l, filterpositions yields the indices of its elements which satisfy a given pred P*)"], ["", "definition filterpositions :: \"('a => bool) => 'a list => nat list\"\n           where \"filterpositions P l = map snd (filter (P o fst) (zip l (upt 0 (size l))))\""], ["", "(* That is, you take the list [a0, a1, ..., an] pair with the indices [0, 1, ..., n], i.e., you get\n   [(a0,0), (a1,1), ..., (an,n)] look where the predicate (P o fst) holds and return the list of the\n   corresponding snd elements. *)\n\n\n(* Alternative definition, making use of list comprehension. In the next line the type info is\n   commented out, since the type inference can be left to Isabelle. *)"], ["", "definition filterpositions2 (*  :: \"('a => bool) => 'a list => nat list\" *)\n           where \"filterpositions2 P l = [n. n \\<leftarrow> [0..<size l], P (l!n)]\""], ["", "definition maxpositions (*:: \"'a::linorder list => nat list\"*) \n           where \"maxpositions l = filterpositions2 (%x . x \\<ge> Max (set l)) l\""], ["", "lemma lm03: \"maxpositions l = [n. n\\<leftarrow>[0..<size l], l!n \\<ge> Max(set l)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxpositions l =\n    concat\n     (map (\\<lambda>n. if Max (set l) \\<le> l ! n then [n] else [])\n       [0..<length l])", "unfolding maxpositions_def filterpositions2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n. if Max (set l) \\<le> l ! n then [n] else [])\n       [0..<length l]) =\n    concat\n     (map (\\<lambda>n. if Max (set l) \\<le> l ! n then [n] else [])\n       [0..<length l])", "by fastforce"], ["", "(* argmaxList takes a function and a list as arguments and looks for the positions of the elements at which the function applied to the list element is maximal, e.g., \nfor the list [9, 3, 5, 9, 13] and the function `modulo 8', the function applied to the list would give the list [1, 3, 5, 1, 5], that is, argmaxList will return [2, 4]. *)"], ["", "definition argmaxList (*:: \"('a => ('b::linorder)) => 'a list => 'a list\"*)\n           where \"argmaxList f l = map (nth l) (maxpositions (map f l))\""], ["", "(* The following lemmas state some relationships between different representation such as map and list comprehension *)"], ["", "lemma lm04: \"[n . n <- l, P n] = [n . n <- l, n \\<in> set l, P n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. if P n then [n] else []) l) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set l then if P n then [n] else [] else [])\n       l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. if P n then [n] else []) l) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set l then if P n then [n] else [] else [])\n       l)", "(*sledgehammer-generated proof. \n  Commented out the first three lines (they look quite useless), making it more readable. \n  assume \"\\<forall>v0. SMT2.fun_app uu__ v0 = (if P v0 then [v0] else [])\"\n  assume \"\\<forall>v0. SMT2.fun_app uua__ v0 = (if v0 \\<in> set l then if P v0 then [v0] else [] else [])\" \n  obtain v3_0 :: \"('a \\<Rightarrow> 'a list) \\<Rightarrow> 'a list \\<Rightarrow> ('a \\<Rightarrow> 'a list) \\<Rightarrow> 'a\" where *)"], ["proof (state)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. if P n then [n] else []) l) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set l then if P n then [n] else [] else [])\n       l)", "have \"map (\\<lambda>uu. if P uu then [uu] else []) l = \n    map (\\<lambda>uu. if uu \\<in> set l then if P uu then [uu] else [] else []) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>uu. if P uu then [uu] else []) l =\n    map (\\<lambda>uu.\n            if uu \\<in> set l then if P uu then [uu] else [] else [])\n     l", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>uu. if P uu then [uu] else []) l =\n  map (\\<lambda>uu.\n          if uu \\<in> set l then if P uu then [uu] else [] else [])\n   l\n\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. if P n then [n] else []) l) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set l then if P n then [n] else [] else [])\n       l)", "thus \"concat (map (\\<lambda>n. if P n then [n] else []) l) = \n    concat (map (\\<lambda>n. if n \\<in> set l then if P n then [n] else [] else []) l)\""], ["proof (prove)\nusing this:\n  map (\\<lambda>uu. if P uu then [uu] else []) l =\n  map (\\<lambda>uu.\n          if uu \\<in> set l then if P uu then [uu] else [] else [])\n   l\n\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. if P n then [n] else []) l) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set l then if P n then [n] else [] else [])\n       l)", "by presburger"], ["proof (state)\nthis:\n  concat (map (\\<lambda>n. if P n then [n] else []) l) =\n  concat\n   (map (\\<lambda>n. if n \\<in> set l then if P n then [n] else [] else [])\n     l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lm05: \"[n . n <- [0..<m], P n] = [n . n <- [0..<m], n \\<in> set [0..<m], P n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. if P n then [n] else []) [0..<m]) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set [0..<m] then if P n then [n] else [] else [])\n       [0..<m])", "using lm04"], ["proof (prove)\nusing this:\n  concat (map (\\<lambda>n. if ?P n then [n] else []) ?l) =\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set ?l then if ?P n then [n] else [] else [])\n     ?l)\n\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. if P n then [n] else []) [0..<m]) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set [0..<m] then if P n then [n] else [] else [])\n       [0..<m])", "by fast"], ["", "(* sledgehammer suggested:  concat_map_singleton map_ident  map_ext by smt*)"], ["", "lemma lm06: fixes f m P \n            shows \"(map f [n . n <- [0..<m], P n]) = [ f n . n <- [0..<m], P n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (concat (map (\\<lambda>n. if P n then [n] else []) [0..<m])) =\n    concat (map (\\<lambda>n. if P n then [f n] else []) [0..<m])", "by (induct m) auto"], ["", "(* Base case stating the property for the empty list *)"], ["", "lemma map_commutes_a: \"[f n . n <- [], Q (f n)] = [x <- (map f []). Q x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. if Q (f n) then [f n] else []) []) =\n    filter Q (map f [])", "by simp"], ["", "(* Step case where the element x is added to the list xs *)"], ["", "lemma map_commutes_b: \"\\<forall> x xs. ([f n . n <- xs,     Q (f n)] = [x <- (map f xs).     Q x] \\<longrightarrow> \n                                [f n . n <- (x#xs), Q (f n)] = [x <- (map f (x#xs)). Q x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xs.\n       concat (map (\\<lambda>n. if Q (f n) then [f n] else []) xs) =\n       filter Q (map f xs) \\<longrightarrow>\n       concat (map (\\<lambda>n. if Q (f n) then [f n] else []) (x # xs)) =\n       filter Q (map f (x # xs))", "by simp"], ["", "(* General case comprising the two previous cases. *)"], ["", "lemma map_commutes: fixes f::\"'a => 'b\" fixes Q::\"'b => bool\" fixes xs::\"'a list\" \n                    shows \"[f n . n <- xs, Q (f n)] = [x <- (map f xs). Q x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. if Q (f n) then [f n] else []) xs) =\n    filter Q (map f xs)", "using map_commutes_a map_commutes_b structInduct"], ["proof (prove)\nusing this:\n  concat (map (\\<lambda>n. if ?Q (?f n) then [?f n] else []) []) =\n  filter ?Q (map ?f [])\n  \\<forall>x xs.\n     concat (map (\\<lambda>n. if ?Q (?f n) then [?f n] else []) xs) =\n     filter ?Q (map ?f xs) \\<longrightarrow>\n     concat (map (\\<lambda>n. if ?Q (?f n) then [?f n] else []) (x # xs)) =\n     filter ?Q (map ?f (x # xs))\n  \\<lbrakk>?P [];\n   \\<forall>x xs. ?P xs \\<longrightarrow> ?P (x # xs)\\<rbrakk>\n  \\<Longrightarrow> ?P ?l\n\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>n. if Q (f n) then [f n] else []) xs) =\n    filter Q (map f xs)", "by fast"], ["", "lemma lm07: fixes f l \n            shows \"maxpositions (map f l) = \n                   [n . n <- [0..<size l], f (l!n) \\<ge> Max (f`(set l))]\" \n            (is \"maxpositions (?fl) = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "(* Pattern matching abbreviation ?fl corresponds to (map f l). Used in the proof, not part of lemma itself *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "have \"maxpositions ?fl = \n  [n. n <- [0..<size ?fl], n\\<in> set[0..<size ?fl], ?fl!n \\<ge> Max (set ?fl)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set [0..<length (map f l)]\n              then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n              else [])\n       [0..<length (map f l)])", "using lm04"], ["proof (prove)\nusing this:\n  concat (map (\\<lambda>n. if ?P n then [n] else []) ?l) =\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set ?l then if ?P n then [n] else [] else [])\n     ?l)\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set [0..<length (map f l)]\n              then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n              else [])\n       [0..<length (map f l)])", "unfolding filterpositions2_def maxpositions_def"], ["proof (prove)\nusing this:\n  concat (map (\\<lambda>n. if ?P n then [n] else []) ?l) =\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set ?l then if ?P n then [n] else [] else [])\n     ?l)\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n.\n              if Max (set (map f l)) \\<le> map f l ! n then [n] else [])\n       [0..<length (map f l)]) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set [0..<length (map f l)]\n              then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n              else [])\n       [0..<length (map f l)])", "."], ["proof (state)\nthis:\n  maxpositions (map f l) =\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set [0..<length (map f l)]\n            then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n            else [])\n     [0..<length (map f l)])\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "also"], ["proof (state)\nthis:\n  maxpositions (map f l) =\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set [0..<length (map f l)]\n            then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n            else [])\n     [0..<length (map f l)])\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "have \"... = \n  [n . n <- [0..<size l], (n<size l), (?fl!n  \\<ge> Max (set ?fl))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n.\n              if n \\<in> set [0..<length (map f l)]\n              then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n              else [])\n       [0..<length (map f l)]) =\n    concat\n     (map (\\<lambda>n.\n              if n < length l\n              then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n              else [])\n       [0..<length l])", "by simp"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set [0..<length (map f l)]\n            then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n            else [])\n     [0..<length (map f l)]) =\n  concat\n   (map (\\<lambda>n.\n            if n < length l\n            then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n            else [])\n     [0..<length l])\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "also"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set [0..<length (map f l)]\n            then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n            else [])\n     [0..<length (map f l)]) =\n  concat\n   (map (\\<lambda>n.\n            if n < length l\n            then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n            else [])\n     [0..<length l])\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "have \"... = \n  [n . n <- [0..<size l], (n<size l) \\<and> (f (l!n)  \\<ge> Max (set ?fl))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n.\n              if n < length l\n              then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n              else [])\n       [0..<length l]) =\n    concat\n     (map (\\<lambda>n.\n              if n < length l \\<and> Max (set (map f l)) \\<le> f (l ! n)\n              then [n] else [])\n       [0..<length l])", "using nth_map"], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n.\n              if n < length l\n              then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n              else [])\n       [0..<length l]) =\n    concat\n     (map (\\<lambda>n.\n              if n < length l \\<and> Max (set (map f l)) \\<le> f (l ! n)\n              then [n] else [])\n       [0..<length l])", "by (metis (poly_guards_query, hide_lams))"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>n.\n            if n < length l\n            then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n            else [])\n     [0..<length l]) =\n  concat\n   (map (\\<lambda>n.\n            if n < length l \\<and> Max (set (map f l)) \\<le> f (l ! n)\n            then [n] else [])\n     [0..<length l])\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "also"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>n.\n            if n < length l\n            then if Max (set (map f l)) \\<le> map f l ! n then [n] else []\n            else [])\n     [0..<length l]) =\n  concat\n   (map (\\<lambda>n.\n            if n < length l \\<and> Max (set (map f l)) \\<le> f (l ! n)\n            then [n] else [])\n     [0..<length l])\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "have \"... = \n  [n . n <- [0..<size l], (n\\<in> set [0..<size l]),(f (l!n)  \\<ge> Max (set ?fl))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n.\n              if n < length l \\<and> Max (set (map f l)) \\<le> f (l ! n)\n              then [n] else [])\n       [0..<length l]) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set [0..<length l]\n              then if Max (set (map f l)) \\<le> f (l ! n) then [n] else []\n              else [])\n       [0..<length l])", "using atLeastLessThan_iff le0 set_upt"], ["proof (prove)\nusing this:\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  0 \\<le> ?n\n  set [?i..<?j] = {?i..<?j}\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n.\n              if n < length l \\<and> Max (set (map f l)) \\<le> f (l ! n)\n              then [n] else [])\n       [0..<length l]) =\n    concat\n     (map (\\<lambda>n.\n              if n \\<in> set [0..<length l]\n              then if Max (set (map f l)) \\<le> f (l ! n) then [n] else []\n              else [])\n       [0..<length l])", "by (metis(no_types))"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>n.\n            if n < length l \\<and> Max (set (map f l)) \\<le> f (l ! n)\n            then [n] else [])\n     [0..<length l]) =\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set [0..<length l]\n            then if Max (set (map f l)) \\<le> f (l ! n) then [n] else []\n            else [])\n     [0..<length l])\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "also"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>n.\n            if n < length l \\<and> Max (set (map f l)) \\<le> f (l ! n)\n            then [n] else [])\n     [0..<length l]) =\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set [0..<length l]\n            then if Max (set (map f l)) \\<le> f (l ! n) then [n] else []\n            else [])\n     [0..<length l])\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "have \"... =  \n  [n . n <- [0..<size l], f (l!n) \\<ge> Max (set ?fl)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n.\n              if n \\<in> set [0..<length l]\n              then if Max (set (map f l)) \\<le> f (l ! n) then [n] else []\n              else [])\n       [0..<length l]) =\n    concat\n     (map (\\<lambda>n.\n              if Max (set (map f l)) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "using lm05"], ["proof (prove)\nusing this:\n  concat (map (\\<lambda>n. if ?P n then [n] else []) [0..<?m]) =\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set [0..<?m] then if ?P n then [n] else [] else [])\n     [0..<?m])\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n.\n              if n \\<in> set [0..<length l]\n              then if Max (set (map f l)) \\<le> f (l ! n) then [n] else []\n              else [])\n       [0..<length l]) =\n    concat\n     (map (\\<lambda>n.\n              if Max (set (map f l)) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "by presburger"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>n.\n            if n \\<in> set [0..<length l]\n            then if Max (set (map f l)) \\<le> f (l ! n) then [n] else []\n            else [])\n     [0..<length l]) =\n  concat\n   (map (\\<lambda>n.\n            if Max (set (map f l)) \\<le> f (l ! n) then [n] else [])\n     [0..<length l])\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "finally"], ["proof (chain)\npicking this:\n  maxpositions (map f l) =\n  concat\n   (map (\\<lambda>n.\n            if Max (set (map f l)) \\<le> f (l ! n) then [n] else [])\n     [0..<length l])", "show ?thesis"], ["proof (prove)\nusing this:\n  maxpositions (map f l) =\n  concat\n   (map (\\<lambda>n.\n            if Max (set (map f l)) \\<le> f (l ! n) then [n] else [])\n     [0..<length l])\n\ngoal (1 subgoal):\n 1. maxpositions (map f l) =\n    concat\n     (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n       [0..<length l])", "by auto"], ["proof (state)\nthis:\n  maxpositions (map f l) =\n  concat\n   (map (\\<lambda>n. if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n     [0..<length l])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lm08: fixes f l \n            shows \"argmaxList f l = \n                   [ l!n . n <- [0..<size l], f (l!n) \\<ge> Max (f`(set l))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmaxList f l =\n    concat\n     (map (\\<lambda>n.\n              if Max (f ` set l) \\<le> f (l ! n) then [l ! n] else [])\n       [0..<length l])", "unfolding lm07 argmaxList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) l)\n     (concat\n       (map (\\<lambda>n.\n                if Max (f ` set l) \\<le> f (l ! n) then [n] else [])\n         [0..<length l])) =\n    concat\n     (map (\\<lambda>n.\n              if Max (f ` set l) \\<le> f (l ! n) then [l ! n] else [])\n       [0..<length l])", "by (metis lm06)"], ["", "text\\<open>The theorem expresses that argmaxList is the list of arguments greater equal the Max of the list.\\<close>"], ["", "theorem argmaxadequacy: fixes f::\"'a => ('b::linorder)\" fixes l::\"'a list\" \n                        shows \"argmaxList f l = [ x <- l. f x \\<ge> Max (f`(set l))]\"\n                        (is \"?lh=_\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "(* pattern match ?lh abbreviates \"argmaxList f l\" *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "let ?P=\"% y::('b::linorder) . y \\<ge> Max (f`(set l))\""], ["proof (state)\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "let ?mh=\"[nth l n . n <- [0..<size l], ?P (f (nth l n))]\""], ["proof (state)\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "let ?rh=\"[ x <- (map (nth l) [0..<size l]). ?P (f x)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "have \"?lh = ?mh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. argmaxList f l =\n    concat\n     (map (\\<lambda>n.\n              if Max (f ` set l) \\<le> f (l ! n) then [l ! n] else [])\n       [0..<length l])", "using lm08"], ["proof (prove)\nusing this:\n  argmaxList ?f ?l =\n  concat\n   (map (\\<lambda>n.\n            if Max (?f ` set ?l) \\<le> ?f (?l ! n) then [?l ! n] else [])\n     [0..<length ?l])\n\ngoal (1 subgoal):\n 1. argmaxList f l =\n    concat\n     (map (\\<lambda>n.\n              if Max (f ` set l) \\<le> f (l ! n) then [l ! n] else [])\n       [0..<length l])", "by fast"], ["proof (state)\nthis:\n  argmaxList f l =\n  concat\n   (map (\\<lambda>n.\n            if Max (f ` set l) \\<le> f (l ! n) then [l ! n] else [])\n     [0..<length l])\n\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "also"], ["proof (state)\nthis:\n  argmaxList f l =\n  concat\n   (map (\\<lambda>n.\n            if Max (f ` set l) \\<le> f (l ! n) then [l ! n] else [])\n     [0..<length l])\n\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "have \"... = ?rh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n.\n              if Max (f ` set l) \\<le> f (l ! n) then [l ! n] else [])\n       [0..<length l]) =\n    filter (\\<lambda>x. Max (f ` set l) \\<le> f x)\n     (map ((!) l) [0..<length l])", "using map_commutes"], ["proof (prove)\nusing this:\n  concat (map (\\<lambda>n. if ?Q (?f n) then [?f n] else []) ?xs) =\n  filter ?Q (map ?f ?xs)\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>n.\n              if Max (f ` set l) \\<le> f (l ! n) then [l ! n] else [])\n       [0..<length l]) =\n    filter (\\<lambda>x. Max (f ` set l) \\<le> f x)\n     (map ((!) l) [0..<length l])", "by fast"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>n.\n            if Max (f ` set l) \\<le> f (l ! n) then [l ! n] else [])\n     [0..<length l]) =\n  filter (\\<lambda>x. Max (f ` set l) \\<le> f x)\n   (map ((!) l) [0..<length l])\n\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "also"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>n.\n            if Max (f ` set l) \\<le> f (l ! n) then [l ! n] else [])\n     [0..<length l]) =\n  filter (\\<lambda>x. Max (f ` set l) \\<le> f x)\n   (map ((!) l) [0..<length l])\n\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "have \"...= [x <- l. ?P (f x)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. Max (f ` set l) \\<le> f x)\n     (map ((!) l) [0..<length l]) =\n    filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "using map_nth"], ["proof (prove)\nusing this:\n  map ((!) ?xs) [0..<length ?xs] = ?xs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. Max (f ` set l) \\<le> f x)\n     (map ((!) l) [0..<length l]) =\n    filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "by metis"], ["proof (state)\nthis:\n  filter (\\<lambda>x. Max (f ` set l) \\<le> f x)\n   (map ((!) l) [0..<length l]) =\n  filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l\n\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "finally"], ["proof (chain)\npicking this:\n  argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "show ?thesis"], ["proof (prove)\nusing this:\n  argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l\n\ngoal (1 subgoal):\n 1. argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l", "by force"], ["proof (state)\nthis:\n  argmaxList f l = filter (\\<lambda>x. Max (f ` set l) \\<le> f x) l\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}