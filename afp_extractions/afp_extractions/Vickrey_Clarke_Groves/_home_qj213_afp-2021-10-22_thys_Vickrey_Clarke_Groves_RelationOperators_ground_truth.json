{"file_name": "/home/qj213/afp-2021-10-22/thys/Vickrey_Clarke_Groves/RelationOperators.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Vickrey_Clarke_Groves", "problem_names": ["lemma restrict_ext: \"R || X = {(x, y) | x y . x \\<in> X \\<and> (x, y) \\<in> R}\"", "lemma restrict_ext': \"R || X = {p . fst p \\<in> X \\<and> p \\<in> R}\"", "lemma restrict_empty: \"P || {} = {}\"", "lemma restriction_is_subrel: \"P || X \\<subseteq> P\"", "lemma restriction_within_domain: \"P || X = P || (X \\<inter> (Domain P))\"", "lemma restrict_to_singleton: \"P || {x} = {x} \\<times> (P `` {x})\"", "lemma outside_reduces_domain: \"Domain (P outside X) = (Domain P) - X\"", "lemma outside_union_restrict: \"P = (P outside X) \\<union> (P || X)\"", "lemma Range_outside_sub_Image_Domain: \"Range (R outside X) \\<subseteq> R `` (Domain R - X)\"", "lemma Range_outside_sub:\n  assumes \"Range R \\<subseteq> Y\"\n  shows \"Range (R outside X) \\<subseteq> Y\"", "lemma flip_in_conv:\n  assumes \"tup \\<in> R\"\n  shows \"flip tup \\<in> R\\<inverse>\"", "lemma flip_flip: \"flip (flip tup) = tup\"", "lemma flip_conv: \"flip ` R = R\\<inverse>\"", "lemma paste_subrel: \n   assumes \"P || Domain Q \\<subseteq> Q\" \n   shows \"P +* Q = P \\<union> Q\"", "lemma paste_disj_domains: \n   assumes \"Domain P \\<inter> Domain Q = {}\" \n   shows \"P +* Q = P \\<union> Q\"", "lemma paste_outside_restrict: \"P = (P outside X) +* (P || X)\"", "lemma paste_Domain: \"Domain(P +* Q)=Domain P\\<union>Domain Q\"", "lemma paste_sub_Un: \"P +* Q \\<subseteq> P \\<union> Q\"", "lemma paste_Range: \"Range (P +* Q) \\<subseteq> Range P \\<union> Range Q\""], "translations": [["", "lemma restrict_ext: \"R || X = {(x, y) | x y . x \\<in> X \\<and> (x, y) \\<in> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R || X = {(x, y) |x y. x \\<in> X \\<and> (x, y) \\<in> R}", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<times> Range R \\<inter> R =\n    {(x, y) |x y. x \\<in> X \\<and> (x, y) \\<in> R}", "using Range_iff"], ["proof (prove)\nusing this:\n  (?a \\<in> Range ?r) = (\\<exists>y. (y, ?a) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. X \\<times> Range R \\<inter> R =\n    {(x, y) |x y. x \\<in> X \\<and> (x, y) \\<in> R}", "by blast"], ["", "text \\<open>alternative statement of @{thm restrict_ext} without explicitly naming the pair's components\\<close>"], ["", "lemma restrict_ext': \"R || X = {p . fst p \\<in> X \\<and> p \\<in> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R || X = {p. fst p \\<in> X \\<and> p \\<in> R}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R || X = {p. fst p \\<in> X \\<and> p \\<in> R}", "have \"R || X = {(x, y) | x y . x \\<in> X \\<and> (x, y) \\<in> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R || X = {(x, y) |x y. x \\<in> X \\<and> (x, y) \\<in> R}", "by (rule restrict_ext)"], ["proof (state)\nthis:\n  R || X = {(x, y) |x y. x \\<in> X \\<and> (x, y) \\<in> R}\n\ngoal (1 subgoal):\n 1. R || X = {p. fst p \\<in> X \\<and> p \\<in> R}", "also"], ["proof (state)\nthis:\n  R || X = {(x, y) |x y. x \\<in> X \\<and> (x, y) \\<in> R}\n\ngoal (1 subgoal):\n 1. R || X = {p. fst p \\<in> X \\<and> p \\<in> R}", "have \"\\<dots> = { p . fst p \\<in> X \\<and> p \\<in> R }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y) |x y. x \\<in> X \\<and> (x, y) \\<in> R} =\n    {p. fst p \\<in> X \\<and> p \\<in> R}", "by force"], ["proof (state)\nthis:\n  {(x, y) |x y. x \\<in> X \\<and> (x, y) \\<in> R} =\n  {p. fst p \\<in> X \\<and> p \\<in> R}\n\ngoal (1 subgoal):\n 1. R || X = {p. fst p \\<in> X \\<and> p \\<in> R}", "finally"], ["proof (chain)\npicking this:\n  R || X = {p. fst p \\<in> X \\<and> p \\<in> R}", "show ?thesis"], ["proof (prove)\nusing this:\n  R || X = {p. fst p \\<in> X \\<and> p \\<in> R}\n\ngoal (1 subgoal):\n 1. R || X = {p. fst p \\<in> X \\<and> p \\<in> R}", "."], ["proof (state)\nthis:\n  R || X = {p. fst p \\<in> X \\<and> p \\<in> R}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Restricting a relation to the empty set yields the empty set.\\<close>"], ["", "lemma restrict_empty: \"P || {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P || {} = {}", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<times> Range P \\<inter> P = {}", "by simp"], ["", "text \\<open>A restriction is a subrelation of the original relation.\\<close>"], ["", "lemma restriction_is_subrel: \"P || X \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P || X \\<subseteq> P", "using restrict_def"], ["proof (prove)\nusing this:\n  ?R || ?X = ?X \\<times> Range ?R \\<inter> ?R\n\ngoal (1 subgoal):\n 1. P || X \\<subseteq> P", "by blast"], ["", "text \\<open>Restricting a relation only has an effect within its domain.\\<close>"], ["", "lemma restriction_within_domain: \"P || X = P || (X \\<inter> (Domain P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P || X = P || (X \\<inter> Domain P)", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<times> Range P \\<inter> P =\n    (X \\<inter> Domain P) \\<times> Range P \\<inter> P", "by fast"], ["", "text \\<open>alternative characterization of the restriction of a relation to a singleton set\\<close>"], ["", "lemma restrict_to_singleton: \"P || {x} = {x} \\<times> (P `` {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P || {x} = {x} \\<times> P `` {x}", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} \\<times> Range P \\<inter> P = {x} \\<times> P `` {x}", "by fast"], ["", "subsection \\<open>Relation outside some set\\<close>"], ["", "text \\<open>For a set-theoretical relation @{term R} and an ``exclusion'' set @{term X}, return those\n  tuples of @{term R} whose first component is not in @{term X}.  In other words, exclude @{term X}\n  from the domain of @{term R}.\\<close>"], ["", "definition Outside :: \"('a \\<times> 'b) set \\<Rightarrow> 'a set \\<Rightarrow> ('a \\<times> 'b) set\" (infix \"outside\" 75)\n   where \"R outside X = R - (X \\<times> Range R)\""], ["", "text \\<open>Considering a relation outside some set @{term X} reduces its domain by @{term X}.\\<close>"], ["", "lemma outside_reduces_domain: \"Domain (P outside X) = (Domain P) - X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (P outside X) = Domain P - X", "unfolding Outside_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (P - X \\<times> Range P) = Domain P - X", "by fast"], ["", "text \\<open>Considering a relation outside a singleton set @{term \"{x}\"} reduces its domain by \n  @{term x}.\\<close>"], ["", "corollary Domain_outside_singleton:\n  assumes \"Domain R = insert x A\"\n      and \"x \\<notin> A\"\n  shows \"Domain (R outside {x}) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (R outside {x}) = A", "using assms outside_reduces_domain"], ["proof (prove)\nusing this:\n  Domain R = insert x A\n  x \\<notin> A\n  Domain (?P outside ?X) = Domain ?P - ?X\n\ngoal (1 subgoal):\n 1. Domain (R outside {x}) = A", "by (metis Diff_insert_absorb)"], ["", "text \\<open>For any set, a relation equals the union of its restriction to that set and its\n  pairs outside that set.\\<close>"], ["", "lemma outside_union_restrict: \"P = (P outside X) \\<union> (P || X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = P outside X \\<union> P || X", "unfolding Outside_def restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = P - X \\<times> Range P \\<union> X \\<times> Range P \\<inter> P", "by fast"], ["", "text \\<open>The range of a relation @{term R} outside some exclusion set @{term X} is a \n  subset of the image of the domain of @{term R}, minus @{term X}, under @{term R}.\\<close>"], ["", "lemma Range_outside_sub_Image_Domain: \"Range (R outside X) \\<subseteq> R `` (Domain R - X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (R outside X) \\<subseteq> R `` (Domain R - X)", "using Outside_def Image_def Domain_def Range_def"], ["proof (prove)\nusing this:\n  ?R outside ?X = ?R - ?X \\<times> Range ?R\n  ?r `` ?s = {y. \\<exists>x\\<in>?s. (x, y) \\<in> ?r}\n  Domain \\<equiv>\n  \\<lambda>r. {x. Domainp (\\<lambda>x xa. (x, xa) \\<in> r) x}\n  Range \\<equiv> \\<lambda>r. {x. Rangep (\\<lambda>x xa. (x, xa) \\<in> r) x}\n\ngoal (1 subgoal):\n 1. Range (R outside X) \\<subseteq> R `` (Domain R - X)", "by blast"], ["", "text \\<open>Considering a relation outside some set does not enlarge its range.\\<close>"], ["", "lemma Range_outside_sub:\n  assumes \"Range R \\<subseteq> Y\"\n  shows \"Range (R outside X) \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (R outside X) \\<subseteq> Y", "using assms outside_union_restrict"], ["proof (prove)\nusing this:\n  Range R \\<subseteq> Y\n  ?P = ?P outside ?X \\<union> ?P || ?X\n\ngoal (1 subgoal):\n 1. Range (R outside X) \\<subseteq> Y", "by (metis Range_mono inf_sup_ord(3) subset_trans)"], ["", "subsection \\<open>Flipping pairs of relations\\<close>"], ["", "text \\<open>flipping a pair: exchanging first and second component\\<close>"], ["", "definition flip where \"flip tup = (snd tup, fst tup)\""], ["", "text \\<open>Flipped pairs can be found in the converse relation.\\<close>"], ["", "lemma flip_in_conv:\n  assumes \"tup \\<in> R\"\n  shows \"flip tup \\<in> R\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip tup \\<in> R\\<inverse>", "using assms"], ["proof (prove)\nusing this:\n  tup \\<in> R\n\ngoal (1 subgoal):\n 1. flip tup \\<in> R\\<inverse>", "unfolding flip_def"], ["proof (prove)\nusing this:\n  tup \\<in> R\n\ngoal (1 subgoal):\n 1. (snd tup, fst tup) \\<in> R\\<inverse>", "by simp"], ["", "text \\<open>Flipping a pair twice doesn't change it.\\<close>"], ["", "lemma flip_flip: \"flip (flip tup) = tup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip (flip tup) = tup", "by (metis flip_def fst_conv snd_conv surjective_pairing)"], ["", "text \\<open>Flipping all pairs in a relation yields the converse relation.\\<close>"], ["", "lemma flip_conv: \"flip ` R = R\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip ` R = R\\<inverse>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flip ` R = R\\<inverse>", "have \"flip ` R = { flip tup | tup . tup \\<in> R }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip ` R = {flip tup |tup. tup \\<in> R}", "by (metis image_Collect_mem)"], ["proof (state)\nthis:\n  flip ` R = {flip tup |tup. tup \\<in> R}\n\ngoal (1 subgoal):\n 1. flip ` R = R\\<inverse>", "also"], ["proof (state)\nthis:\n  flip ` R = {flip tup |tup. tup \\<in> R}\n\ngoal (1 subgoal):\n 1. flip ` R = R\\<inverse>", "have \"\\<dots> = { tup . tup \\<in> R\\<inverse> }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {flip tup |tup. tup \\<in> R} = {tup. tup \\<in> R\\<inverse>}", "using flip_in_conv"], ["proof (prove)\nusing this:\n  ?tup \\<in> ?R \\<Longrightarrow> flip ?tup \\<in> ?R\\<inverse>\n\ngoal (1 subgoal):\n 1. {flip tup |tup. tup \\<in> R} = {tup. tup \\<in> R\\<inverse>}", "by (metis converse_converse flip_flip)"], ["proof (state)\nthis:\n  {flip tup |tup. tup \\<in> R} = {tup. tup \\<in> R\\<inverse>}\n\ngoal (1 subgoal):\n 1. flip ` R = R\\<inverse>", "also"], ["proof (state)\nthis:\n  {flip tup |tup. tup \\<in> R} = {tup. tup \\<in> R\\<inverse>}\n\ngoal (1 subgoal):\n 1. flip ` R = R\\<inverse>", "have \"\\<dots> = R\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {tup. tup \\<in> R\\<inverse>} = R\\<inverse>", "by simp"], ["proof (state)\nthis:\n  {tup. tup \\<in> R\\<inverse>} = R\\<inverse>\n\ngoal (1 subgoal):\n 1. flip ` R = R\\<inverse>", "finally"], ["proof (chain)\npicking this:\n  flip ` R = R\\<inverse>", "show ?thesis"], ["proof (prove)\nusing this:\n  flip ` R = R\\<inverse>\n\ngoal (1 subgoal):\n 1. flip ` R = R\\<inverse>", "."], ["proof (state)\nthis:\n  flip ` R = R\\<inverse>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Evaluation as a function\\<close>"], ["", "text \\<open>Evaluates a relation @{term R} for a single argument, as if it were a function.\n  This will only work if @{term R} is right-unique, i.e. if the image is always a singleton set.\\<close>"], ["", "fun eval_rel :: \"('a \\<times> 'b) set \\<Rightarrow> 'a \\<Rightarrow> 'b\" (infix \",,\" 75) (* . (Mizar's notation) confuses Isar *)\n    where \"R ,, a = the_elem (R `` {a})\""], ["", "subsection \\<open>Paste\\<close>"], ["", "text \\<open>the union of two binary relations @{term P} and @{term Q}, where pairs from @{term Q}\n  override pairs from @{term P} when their first components coincide.\nThis is particularly useful when P, Q are @{term runiq}, and one wants to preserve that property.\\<close>"], ["", "definition paste (infix \"+*\" 75)\n   where \"P +* Q = (P outside Domain Q) \\<union> Q\""], ["", "text \\<open>If a relation @{term P} is a subrelation of another relation @{term Q} on @{term Q}'s\n  domain, pasting @{term Q} on @{term P} is the same as forming their union.\\<close>"], ["", "lemma paste_subrel: \n   assumes \"P || Domain Q \\<subseteq> Q\" \n   shows \"P +* Q = P \\<union> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P +* Q = P \\<union> Q", "unfolding paste_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P outside Domain Q \\<union> Q = P \\<union> Q", "using assms outside_union_restrict"], ["proof (prove)\nusing this:\n  P || Domain Q \\<subseteq> Q\n  ?P = ?P outside ?X \\<union> ?P || ?X\n\ngoal (1 subgoal):\n 1. P outside Domain Q \\<union> Q = P \\<union> Q", "by blast"], ["", "text \\<open>Pasting two relations with disjoint domains is the same as forming their union.\\<close>"], ["", "lemma paste_disj_domains: \n   assumes \"Domain P \\<inter> Domain Q = {}\" \n   shows \"P +* Q = P \\<union> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P +* Q = P \\<union> Q", "unfolding paste_def Outside_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P - Domain Q \\<times> Range P \\<union> Q = P \\<union> Q", "using assms"], ["proof (prove)\nusing this:\n  Domain P \\<inter> Domain Q = {}\n\ngoal (1 subgoal):\n 1. P - Domain Q \\<times> Range P \\<union> Q = P \\<union> Q", "by fast"], ["", "text \\<open>A relation @{term P} is equivalent to pasting its restriction to some set @{term X} on \n  @{term \"P outside X\"}.\\<close>"], ["", "lemma paste_outside_restrict: \"P = (P outside X) +* (P || X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = (P outside X) +* (P || X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P = (P outside X) +* (P || X)", "have \"Domain (P outside X) \\<inter> Domain (P || X) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (P outside X) \\<inter> Domain (P || X) = {}", "unfolding Outside_def restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (P - X \\<times> Range P) \\<inter>\n    Domain (X \\<times> Range P \\<inter> P) =\n    {}", "by fast"], ["proof (state)\nthis:\n  Domain (P outside X) \\<inter> Domain (P || X) = {}\n\ngoal (1 subgoal):\n 1. P = (P outside X) +* (P || X)", "moreover"], ["proof (state)\nthis:\n  Domain (P outside X) \\<inter> Domain (P || X) = {}\n\ngoal (1 subgoal):\n 1. P = (P outside X) +* (P || X)", "have \"P = P outside X \\<union> P || X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = P outside X \\<union> P || X", "by (rule outside_union_restrict)"], ["proof (state)\nthis:\n  P = P outside X \\<union> P || X\n\ngoal (1 subgoal):\n 1. P = (P outside X) +* (P || X)", "ultimately"], ["proof (chain)\npicking this:\n  Domain (P outside X) \\<inter> Domain (P || X) = {}\n  P = P outside X \\<union> P || X", "show ?thesis"], ["proof (prove)\nusing this:\n  Domain (P outside X) \\<inter> Domain (P || X) = {}\n  P = P outside X \\<union> P || X\n\ngoal (1 subgoal):\n 1. P = (P outside X) +* (P || X)", "using paste_disj_domains"], ["proof (prove)\nusing this:\n  Domain (P outside X) \\<inter> Domain (P || X) = {}\n  P = P outside X \\<union> P || X\n  Domain ?P \\<inter> Domain ?Q = {} \\<Longrightarrow>\n  ?P +* ?Q = ?P \\<union> ?Q\n\ngoal (1 subgoal):\n 1. P = (P outside X) +* (P || X)", "by metis"], ["proof (state)\nthis:\n  P = (P outside X) +* (P || X)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The domain of two pasted relations equals the union of their domains.\\<close>"], ["", "lemma paste_Domain: \"Domain(P +* Q)=Domain P\\<union>Domain Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (P +* Q) = Domain P \\<union> Domain Q", "unfolding paste_def Outside_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (P - Domain Q \\<times> Range P \\<union> Q) =\n    Domain P \\<union> Domain Q", "by blast"], ["", "text \\<open>Pasting two relations yields a subrelation of their union.\\<close>"], ["", "lemma paste_sub_Un: \"P +* Q \\<subseteq> P \\<union> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P +* Q \\<subseteq> P \\<union> Q", "unfolding paste_def Outside_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P - Domain Q \\<times> Range P \\<union> Q \\<subseteq> P \\<union> Q", "by fast"], ["", "text \\<open>The range of two pasted relations is a subset of the union of their ranges.\\<close>"], ["", "lemma paste_Range: \"Range (P +* Q) \\<subseteq> Range P \\<union> Range Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (P +* Q) \\<subseteq> Range P \\<union> Range Q", "using paste_sub_Un"], ["proof (prove)\nusing this:\n  ?P +* ?Q \\<subseteq> ?P \\<union> ?Q\n\ngoal (1 subgoal):\n 1. Range (P +* Q) \\<subseteq> Range P \\<union> Range Q", "by blast"], ["", "end"]]}