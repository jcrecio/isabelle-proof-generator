{"file_name": "/home/qj213/afp-2021-10-22/thys/Vickrey_Clarke_Groves/Partitions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Vickrey_Clarke_Groves", "problem_names": ["lemma subset_is_non_overlapping:\n  assumes subset: \"P \\<subseteq> Q\" and \n          non_overlapping: \"is_non_overlapping Q\"\n  shows \"is_non_overlapping P\"", "lemma remove_from_eq_class_preserves_disjoint:\n      fixes elem::'a\n        and X::\"'a set\"\n        and P::\"'a set set\"\n      assumes non_overlapping: \"is_non_overlapping P\"\n        and eq_class: \"X \\<in> P\"\n        and elem: \"elem \\<in> X\"\n      shows \"X - {elem} \\<notin> P\"", "lemma non_overlapping_extension1:\n  fixes P::\"'a set set\"\n    and X::\"'a set\"\n  assumes partition: \"is_non_overlapping P\"\n       and disjoint: \"X \\<inter> \\<Union> P = {}\" \n      and non_empty: \"X \\<noteq> {}\"\n  shows \"is_non_overlapping (insert X P)\"", "lemma disj_eq_classes:\n  fixes P::\"'a set set\"\n    and X::\"'a set\"\n  assumes \"is_non_overlapping P\"\n      and \"X \\<in> P\"\n  shows \"X \\<inter> \\<Union> (P - {X}) = {}\"", "lemma no_empty_in_non_overlapping:\n  assumes \"is_non_overlapping p\"\n  shows \"{} \\<notin> p\"", "lemma non_empty_imp_non_empty_partition:\n  assumes \"A \\<noteq> {}\"\n      and \"P partitions A\"\n  shows \"P \\<noteq> {}\"", "lemma elem_in_partition:\n  assumes in_set: \"x \\<in> A\"\n      and part: \"P partitions A\"\n  obtains X where \"x \\<in> X\" and \"X \\<in> P\"", "lemma diff_elem_in_partition:\n  assumes x: \"x \\<in> A - B\"\n      and part: \"P partitions A\"\n  shows \"\\<exists> S \\<in> P - { B } . x \\<in> S\"", "lemma elem_in_uniq_set:\n  assumes in_set: \"x \\<in> A\"\n      and part: \"P partitions A\"\n  shows \"\\<exists>! X \\<in> P . x \\<in> X\"", "lemma set_partitions_itself:\n  assumes \"A \\<noteq> {}\"\n  shows \"{A} partitions A\"", "lemma emptyset_part_emptyset1:\n  shows \"{} partitions {}\"", "lemma emptyset_part_emptyset2:\n  assumes \"P partitions {}\"\n  shows \"P = {}\"", "lemma emptyset_part_emptyset3:\n  shows \"all_partitions {} = {{}}\"", "lemma non_overlapping_extension2:\n  fixes new_el::'a\n    and P::\"'a set set\"\n    and X::\"'a set\"\n  assumes non_overlapping: \"is_non_overlapping P\"\n      and class_element: \"X \\<in> P\"\n      and new: \"new_el \\<notin> \\<Union> P\"\n  shows \"is_non_overlapping (insert_into_member new_el P X)\"", "lemma insert_into_member_list_equivalence:\n  fixes new_el::'a\n    and Sets::\"'a set list\"\n    and S::\"'a set\"\n  assumes \"distinct Sets\"\n  shows \"set (insert_into_member_list new_el Sets S) = insert_into_member new_el (set Sets) S\"", "lemma insert_into_member_partition1:\n  fixes elem::'a\n    and P::\"'a set set\"\n    and set::\"'a set\"\n  shows \"\\<Union> (insert_into_member elem P set) = \\<Union> (insert (set \\<union> {elem}) (P - {set}))\"", "lemma coarser_partitions_with_list_equivalence:\n  assumes \"distinct P\"\n  shows \"set (map set (coarser_partitions_with_list new_el P)) = \n         coarser_partitions_with new_el (set P)\"", "lemma non_overlapping_extension3:\n  fixes elem::'a\n    and P::\"'a set set\"\n    and Q::\"'a set set\"\n  assumes P_non_overlapping: \"is_non_overlapping P\"\n      and new_elem: \"elem \\<notin> \\<Union> P\"\n      and Q_coarser: \"Q \\<in> coarser_partitions_with elem P\"\n  shows \"is_non_overlapping Q\"", "lemma coarser_partitions_covers:\n  fixes elem::'a\n    and P::\"'a set set\"\n    and Q::\"'a set set\"\n  assumes \"Q \\<in> coarser_partitions_with elem P\"\n  shows \"\\<Union> Q = insert elem (\\<Union> P)\"", "lemma partition_without_covers:\n  fixes elem::'a\n    and P::\"'a set set\"\n  shows \"\\<Union> (partition_without elem P) = (\\<Union> P) - {elem}\"", "lemma super_class:\n  assumes \"X \\<in> partition_without elem P\"\n  obtains Z where \"Z \\<in> P\" and \"X = Z - {elem}\"", "lemma non_overlapping_without_is_non_overlapping:\n  fixes elem::'a\n    and P::\"'a set set\"\n  assumes \"is_non_overlapping P\"\n  shows \"is_non_overlapping (partition_without elem P)\" (is \"is_non_overlapping ?Q\")", "lemma coarser_partitions_inv_without:\n  fixes elem::'a\n    and P::\"'a set set\"\n  assumes non_overlapping: \"is_non_overlapping P\"\n      and elem: \"elem \\<in> \\<Union> P\" \n  shows \"P \\<in> coarser_partitions_with elem (partition_without elem P)\"\n    (is \"P \\<in> coarser_partitions_with elem ?Q\")", "lemma all_coarser_partitions_with_list_equivalence:\n  fixes elem::'a\n    and Ps::\"'a set list list\"\n  assumes distinct: \"\\<forall> P \\<in> set Ps . distinct P\"\n  shows \"set (map set (all_coarser_partitions_with_list elem Ps)) = all_coarser_partitions_with elem (set (map set Ps))\"\n    (is \"?list_expr = ?set_expr\")", "lemma coarser_partitions_with_list_distinct:\n  fixes ps\n  assumes ps_coarser: \"ps \\<in> set (coarser_partitions_with_list x Q)\"\n      and distinct: \"distinct Q\"\n      and partition: \"is_non_overlapping (set Q)\"\n      and new: \"{x} \\<notin> set Q\"\n  shows \"distinct ps\"", "lemma all_partitions_equivalence':\n  fixes xs::\"'a list\"\n  shows \"distinct xs \\<Longrightarrow> \n         ((set (map set (all_partitions_list xs)) = \n          all_partitions (set xs)) \\<and> (\\<forall> ps \\<in> set (all_partitions_list xs) . distinct ps))\"", "theorem all_partitions_paper_equiv_alg:\n  fixes xs::\"'a list\"\n  shows \"distinct xs \\<Longrightarrow> set (map set (all_partitions_list xs)) = all_partitions (set xs)\""], "translations": [["", "lemma subset_is_non_overlapping:\n  assumes subset: \"P \\<subseteq> Q\" and \n          non_overlapping: \"is_non_overlapping Q\"\n  shows \"is_non_overlapping P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_non_overlapping P", "(* CL: The following takes 387 ms with Isabelle2013-1-RC1:\n   by (metis is_non_overlapping_def non_overlapping rev_subsetD subset). MC: possibly useful for TPTP *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_non_overlapping P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping P", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping P", "fix X Y"], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping P", "assume \"X \\<in> P \\<and> Y \\<in> P\""], ["proof (state)\nthis:\n  X \\<in> P \\<and> Y \\<in> P\n\ngoal (1 subgoal):\n 1. is_non_overlapping P", "then"], ["proof (chain)\npicking this:\n  X \\<in> P \\<and> Y \\<in> P", "have \"X \\<in> Q \\<and> Y \\<in> Q\""], ["proof (prove)\nusing this:\n  X \\<in> P \\<and> Y \\<in> P\n\ngoal (1 subgoal):\n 1. X \\<in> Q \\<and> Y \\<in> Q", "using subset"], ["proof (prove)\nusing this:\n  X \\<in> P \\<and> Y \\<in> P\n  P \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. X \\<in> Q \\<and> Y \\<in> Q", "by fast"], ["proof (state)\nthis:\n  X \\<in> Q \\<and> Y \\<in> Q\n\ngoal (1 subgoal):\n 1. is_non_overlapping P", "then"], ["proof (chain)\npicking this:\n  X \\<in> Q \\<and> Y \\<in> Q", "have \"X \\<inter> Y \\<noteq> {} \\<longleftrightarrow> X = Y\""], ["proof (prove)\nusing this:\n  X \\<in> Q \\<and> Y \\<in> Q\n\ngoal (1 subgoal):\n 1. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "using non_overlapping"], ["proof (prove)\nusing this:\n  X \\<in> Q \\<and> Y \\<in> Q\n  is_non_overlapping Q\n\ngoal (1 subgoal):\n 1. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "unfolding is_non_overlapping_def"], ["proof (prove)\nusing this:\n  X \\<in> Q \\<and> Y \\<in> Q\n  \\<forall>X\\<in>Q. \\<forall>Y\\<in>Q. (X \\<inter> Y \\<noteq> {}) = (X = Y)\n\ngoal (1 subgoal):\n 1. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "by force"], ["proof (state)\nthis:\n  (X \\<inter> Y \\<noteq> {}) = (X = Y)\n\ngoal (1 subgoal):\n 1. is_non_overlapping P", "}"], ["proof (state)\nthis:\n  ?X2 \\<in> P \\<and> ?Y2 \\<in> P \\<Longrightarrow>\n  (?X2 \\<inter> ?Y2 \\<noteq> {}) = (?X2 = ?Y2)\n\ngoal (1 subgoal):\n 1. is_non_overlapping P", "then"], ["proof (chain)\npicking this:\n  ?X2 \\<in> P \\<and> ?Y2 \\<in> P \\<Longrightarrow>\n  (?X2 \\<inter> ?Y2 \\<noteq> {}) = (?X2 = ?Y2)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?X2 \\<in> P \\<and> ?Y2 \\<in> P \\<Longrightarrow>\n  (?X2 \\<inter> ?Y2 \\<noteq> {}) = (?X2 = ?Y2)\n\ngoal (1 subgoal):\n 1. is_non_overlapping P", "unfolding is_non_overlapping_def"], ["proof (prove)\nusing this:\n  ?X2 \\<in> P \\<and> ?Y2 \\<in> P \\<Longrightarrow>\n  (?X2 \\<inter> ?Y2 \\<noteq> {}) = (?X2 = ?Y2)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>P. \\<forall>Y\\<in>P. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "by force"], ["proof (state)\nthis:\n  is_non_overlapping P\n\ngoal:\nNo subgoals!", "qed"], ["", "(* This is not used at the moment, but it is interesting, as the proof\n   was very hard to find for Sledgehammer. MC: possibly useful for TPTP *)"], ["", "text \\<open>The family that results from removing one element from an equivalence class of a non-overlapping family is not otherwise a member of the family.\\<close>"], ["", "lemma remove_from_eq_class_preserves_disjoint:\n      fixes elem::'a\n        and X::\"'a set\"\n        and P::\"'a set set\"\n      assumes non_overlapping: \"is_non_overlapping P\"\n        and eq_class: \"X \\<in> P\"\n        and elem: \"elem \\<in> X\"\n      shows \"X - {elem} \\<notin> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X - {elem} \\<notin> P", "using assms Int_Diff is_non_overlapping_def Diff_disjoint Diff_eq_empty_iff \n        Int_absorb2 insert_Diff_if insert_not_empty"], ["proof (prove)\nusing this:\n  is_non_overlapping P\n  X \\<in> P\n  elem \\<in> X\n  ?A \\<inter> ?B - ?C = ?A \\<inter> (?B - ?C)\n  is_non_overlapping ?P =\n  (\\<forall>X\\<in>?P.\n      \\<forall>Y\\<in>?P. (X \\<inter> Y \\<noteq> {}) = (X = Y))\n  ?A \\<inter> (?B - ?A) = {}\n  (?A - ?B = {}) = (?A \\<subseteq> ?B)\n  ?A \\<subseteq> ?B \\<Longrightarrow> ?A \\<inter> ?B = ?A\n  insert ?x ?A - ?B = (if ?x \\<in> ?B then ?A - ?B else insert ?x (?A - ?B))\n  insert ?a ?A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X - {elem} \\<notin> P", "by (metis)"], ["", "text \\<open>Inserting into a non-overlapping family @{term P} a set @{term X}, which is disjoint with the set \n  partitioned by @{term P}, yields another non-overlapping family.\\<close>"], ["", "lemma non_overlapping_extension1:\n  fixes P::\"'a set set\"\n    and X::\"'a set\"\n  assumes partition: \"is_non_overlapping P\"\n       and disjoint: \"X \\<inter> \\<Union> P = {}\" \n      and non_empty: \"X \\<noteq> {}\"\n  shows \"is_non_overlapping (insert X P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_non_overlapping (insert X P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping (insert X P)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping (insert X P)", "fix Y::\"'a set\" and Z::\"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping (insert X P)", "assume Y_Z_in_ext_P: \"Y \\<in> insert X P \\<and> Z \\<in> insert X P\""], ["proof (state)\nthis:\n  Y \\<in> insert X P \\<and> Z \\<in> insert X P\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert X P)", "have \"Y \\<inter> Z \\<noteq> {} \\<longleftrightarrow> Y = Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Y \\<inter> Z \\<noteq> {}) = (Y = Z)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Y \\<inter> Z \\<noteq> {} \\<Longrightarrow> Y = Z\n 2. Y = Z \\<Longrightarrow> Y \\<inter> Z \\<noteq> {}", "assume \"Y \\<inter> Z \\<noteq> {}\""], ["proof (state)\nthis:\n  Y \\<inter> Z \\<noteq> {}\n\ngoal (2 subgoals):\n 1. Y \\<inter> Z \\<noteq> {} \\<Longrightarrow> Y = Z\n 2. Y = Z \\<Longrightarrow> Y \\<inter> Z \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  Y \\<inter> Z \\<noteq> {}", "show \"Y = Z\""], ["proof (prove)\nusing this:\n  Y \\<inter> Z \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Y = Z", "using Y_Z_in_ext_P partition disjoint"], ["proof (prove)\nusing this:\n  Y \\<inter> Z \\<noteq> {}\n  Y \\<in> insert X P \\<and> Z \\<in> insert X P\n  is_non_overlapping P\n  X \\<inter> \\<Union> P = {}\n\ngoal (1 subgoal):\n 1. Y = Z", "unfolding is_non_overlapping_def"], ["proof (prove)\nusing this:\n  Y \\<inter> Z \\<noteq> {}\n  Y \\<in> insert X P \\<and> Z \\<in> insert X P\n  \\<forall>X\\<in>P. \\<forall>Y\\<in>P. (X \\<inter> Y \\<noteq> {}) = (X = Y)\n  X \\<inter> \\<Union> P = {}\n\ngoal (1 subgoal):\n 1. Y = Z", "by fast"], ["proof (state)\nthis:\n  Y = Z\n\ngoal (1 subgoal):\n 1. Y = Z \\<Longrightarrow> Y \\<inter> Z \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Y = Z \\<Longrightarrow> Y \\<inter> Z \\<noteq> {}", "assume \"Y = Z\""], ["proof (state)\nthis:\n  Y = Z\n\ngoal (1 subgoal):\n 1. Y = Z \\<Longrightarrow> Y \\<inter> Z \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  Y = Z", "show \"Y \\<inter> Z \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Y = Z\n\ngoal (1 subgoal):\n 1. Y \\<inter> Z \\<noteq> {}", "using Y_Z_in_ext_P partition non_empty"], ["proof (prove)\nusing this:\n  Y = Z\n  Y \\<in> insert X P \\<and> Z \\<in> insert X P\n  is_non_overlapping P\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Y \\<inter> Z \\<noteq> {}", "unfolding is_non_overlapping_def"], ["proof (prove)\nusing this:\n  Y = Z\n  Y \\<in> insert X P \\<and> Z \\<in> insert X P\n  \\<forall>X\\<in>P. \\<forall>Y\\<in>P. (X \\<inter> Y \\<noteq> {}) = (X = Y)\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Y \\<inter> Z \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Y \\<inter> Z \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Y \\<inter> Z \\<noteq> {}) = (Y = Z)\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert X P)", "}"], ["proof (state)\nthis:\n  ?Y2 \\<in> insert X P \\<and> ?Z2 \\<in> insert X P \\<Longrightarrow>\n  (?Y2 \\<inter> ?Z2 \\<noteq> {}) = (?Y2 = ?Z2)\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert X P)", "then"], ["proof (chain)\npicking this:\n  ?Y2 \\<in> insert X P \\<and> ?Z2 \\<in> insert X P \\<Longrightarrow>\n  (?Y2 \\<inter> ?Z2 \\<noteq> {}) = (?Y2 = ?Z2)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?Y2 \\<in> insert X P \\<and> ?Z2 \\<in> insert X P \\<Longrightarrow>\n  (?Y2 \\<inter> ?Z2 \\<noteq> {}) = (?Y2 = ?Z2)\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert X P)", "unfolding is_non_overlapping_def"], ["proof (prove)\nusing this:\n  ?Y2 \\<in> insert X P \\<and> ?Z2 \\<in> insert X P \\<Longrightarrow>\n  (?Y2 \\<inter> ?Z2 \\<noteq> {}) = (?Y2 = ?Z2)\n\ngoal (1 subgoal):\n 1. \\<forall>Xa\\<in>insert X P.\n       \\<forall>Y\\<in>insert X P. (Xa \\<inter> Y \\<noteq> {}) = (Xa = Y)", "by force"], ["proof (state)\nthis:\n  is_non_overlapping (insert X P)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>An element of a non-overlapping family has no intersection with any other of its elements.\\<close>"], ["", "lemma disj_eq_classes:\n  fixes P::\"'a set set\"\n    and X::\"'a set\"\n  assumes \"is_non_overlapping P\"\n      and \"X \\<in> P\"\n  shows \"X \\<inter> \\<Union> (P - {X}) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "fix x::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "assume x_in_two_eq_classes: \"x \\<in> X \\<inter> \\<Union> (P - {X})\""], ["proof (state)\nthis:\n  x \\<in> X \\<inter> \\<Union> (P - {X})\n\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "then"], ["proof (chain)\npicking this:\n  x \\<in> X \\<inter> \\<Union> (P - {X})", "obtain Y where other_eq_class: \"Y \\<in> P - {X} \\<and> x \\<in> Y\""], ["proof (prove)\nusing this:\n  x \\<in> X \\<inter> \\<Union> (P - {X})\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        Y \\<in> P - {X} \\<and> x \\<in> Y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Y \\<in> P - {X} \\<and> x \\<in> Y\n\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "have \"x \\<in> X \\<inter> Y \\<and> Y \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<inter> Y \\<and> Y \\<in> P", "using x_in_two_eq_classes other_eq_class"], ["proof (prove)\nusing this:\n  x \\<in> X \\<inter> \\<Union> (P - {X})\n  Y \\<in> P - {X} \\<and> x \\<in> Y\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<inter> Y \\<and> Y \\<in> P", "by force"], ["proof (state)\nthis:\n  x \\<in> X \\<inter> Y \\<and> Y \\<in> P\n\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "then"], ["proof (chain)\npicking this:\n  x \\<in> X \\<inter> Y \\<and> Y \\<in> P", "have \"X = Y\""], ["proof (prove)\nusing this:\n  x \\<in> X \\<inter> Y \\<and> Y \\<in> P\n\ngoal (1 subgoal):\n 1. X = Y", "using assms is_non_overlapping_def"], ["proof (prove)\nusing this:\n  x \\<in> X \\<inter> Y \\<and> Y \\<in> P\n  is_non_overlapping P\n  X \\<in> P\n  is_non_overlapping ?P =\n  (\\<forall>X\\<in>?P.\n      \\<forall>Y\\<in>?P. (X \\<inter> Y \\<noteq> {}) = (X = Y))\n\ngoal (1 subgoal):\n 1. X = Y", "by fast"], ["proof (state)\nthis:\n  X = Y\n\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "then"], ["proof (chain)\npicking this:\n  X = Y", "have \"x \\<in> {}\""], ["proof (prove)\nusing this:\n  X = Y\n\ngoal (1 subgoal):\n 1. x \\<in> {}", "using other_eq_class"], ["proof (prove)\nusing this:\n  X = Y\n  Y \\<in> P - {X} \\<and> x \\<in> Y\n\ngoal (1 subgoal):\n 1. x \\<in> {}", "by fast"], ["proof (state)\nthis:\n  x \\<in> {}\n\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> X \\<inter> \\<Union> (P - {X}) \\<Longrightarrow> ?x2 \\<in> {}\n\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "then"], ["proof (chain)\npicking this:\n  ?x2 \\<in> X \\<inter> \\<Union> (P - {X}) \\<Longrightarrow> ?x2 \\<in> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x2 \\<in> X \\<inter> \\<Union> (P - {X}) \\<Longrightarrow> ?x2 \\<in> {}\n\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "by blast"], ["proof (state)\nthis:\n  X \\<inter> \\<Union> (P - {X}) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The empty set is not element of a non-overlapping family.\\<close>"], ["", "lemma no_empty_in_non_overlapping:\n  assumes \"is_non_overlapping p\"\n  shows \"{} \\<notin> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<notin> p", "(* CL: The following takes 36 ms with Isabelle2013-1-RC1:\n   by (metis Int_iff all_not_in_conv assms is_non_overlapping_def). MC: possibly useful for TPTP *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<notin> p", "using assms is_non_overlapping_def"], ["proof (prove)\nusing this:\n  is_non_overlapping p\n  is_non_overlapping ?P =\n  (\\<forall>X\\<in>?P.\n      \\<forall>Y\\<in>?P. (X \\<inter> Y \\<noteq> {}) = (X = Y))\n\ngoal (1 subgoal):\n 1. {} \\<notin> p", "by fast"], ["", "text \\<open>@{term P} is a partition of the set @{term A}. The infix notation takes the form ``noun-verb-object''\\<close>"], ["", "definition is_partition_of (infix \"partitions\" 75)\n           where \"is_partition_of P A = (\\<Union> P = A \\<and> is_non_overlapping P)\""], ["", "text \\<open>No partition of a non-empty set is empty.\\<close>"], ["", "lemma non_empty_imp_non_empty_partition:\n  assumes \"A \\<noteq> {}\"\n      and \"P partitions A\"\n  shows \"P \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  P partitions A\n\ngoal (1 subgoal):\n 1. P \\<noteq> {}", "unfolding is_partition_of_def"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  \\<Union> P = A \\<and> is_non_overlapping P\n\ngoal (1 subgoal):\n 1. P \\<noteq> {}", "by fast"], ["", "text \\<open>Every element of a partitioned set ends up in one element in the partition.\\<close>"], ["", "lemma elem_in_partition:\n  assumes in_set: \"x \\<in> A\"\n      and part: \"P partitions A\"\n  obtains X where \"x \\<in> X\" and \"X \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>x \\<in> X; X \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using part in_set"], ["proof (prove)\nusing this:\n  P partitions A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>x \\<in> X; X \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_partition_of_def is_non_overlapping_def"], ["proof (prove)\nusing this:\n  \\<Union> P = A \\<and>\n  (\\<forall>X\\<in>P. \\<forall>Y\\<in>P. (X \\<inter> Y \\<noteq> {}) = (X = Y))\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>x \\<in> X; X \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: UnionE)"], ["", "text \\<open>Every element of the difference of a set @{term A} and another set @{term B} ends up in \n  an element of a partition of @{term A}, but not in an element of the partition of @{term \"{B}\"}.\\<close>"], ["", "lemma diff_elem_in_partition:\n  assumes x: \"x \\<in> A - B\"\n      and part: \"P partitions A\"\n  shows \"\\<exists> S \\<in> P - { B } . x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>P - {B}. x \\<in> S", "(* Sledgehammer in Isabelle2013-1-RC1 can't do this within the default time limit. \nMC: possibly useful for TPTP *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>P - {B}. x \\<in> S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>P - {B}. x \\<in> S", "from part x"], ["proof (chain)\npicking this:\n  P partitions A\n  x \\<in> A - B", "obtain X where \"x \\<in> X\" and \"X \\<in> P\""], ["proof (prove)\nusing this:\n  P partitions A\n  x \\<in> A - B\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>x \\<in> X; X \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Diff_iff elem_in_partition)"], ["proof (state)\nthis:\n  x \\<in> X\n  X \\<in> P\n\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>P - {B}. x \\<in> S", "with x"], ["proof (chain)\npicking this:\n  x \\<in> A - B\n  x \\<in> X\n  X \\<in> P", "have \"X \\<noteq> B\""], ["proof (prove)\nusing this:\n  x \\<in> A - B\n  x \\<in> X\n  X \\<in> P\n\ngoal (1 subgoal):\n 1. X \\<noteq> B", "by fast"], ["proof (state)\nthis:\n  X \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>P - {B}. x \\<in> S", "with \\<open>x \\<in> X\\<close> \\<open>X \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> X\n  X \\<in> P\n  X \\<noteq> B", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> X\n  X \\<in> P\n  X \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<exists>S\\<in>P - {B}. x \\<in> S", "by blast"], ["proof (state)\nthis:\n  \\<exists>S\\<in>P - {B}. x \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Every element of a partitioned set ends up in exactly one set.\\<close>"], ["", "lemma elem_in_uniq_set:\n  assumes in_set: \"x \\<in> A\"\n      and part: \"P partitions A\"\n  shows \"\\<exists>! X \\<in> P . x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!X. X \\<in> P \\<and> x \\<in> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!X. X \\<in> P \\<and> x \\<in> X", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> A\n  P partitions A", "obtain X where *: \"X \\<in> P \\<and> x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  P partitions A\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        X \\<in> P \\<and> x \\<in> X \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule elem_in_partition) blast"], ["proof (state)\nthis:\n  X \\<in> P \\<and> x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>!X. X \\<in> P \\<and> x \\<in> X", "moreover"], ["proof (state)\nthis:\n  X \\<in> P \\<and> x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>!X. X \\<in> P \\<and> x \\<in> X", "{"], ["proof (state)\nthis:\n  X \\<in> P \\<and> x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>!X. X \\<in> P \\<and> x \\<in> X", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!X. X \\<in> P \\<and> x \\<in> X", "assume \"Y \\<in> P \\<and> x \\<in> Y\""], ["proof (state)\nthis:\n  Y \\<in> P \\<and> x \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<exists>!X. X \\<in> P \\<and> x \\<in> X", "then"], ["proof (chain)\npicking this:\n  Y \\<in> P \\<and> x \\<in> Y", "have \"Y = X\""], ["proof (prove)\nusing this:\n  Y \\<in> P \\<and> x \\<in> Y\n\ngoal (1 subgoal):\n 1. Y = X", "using part in_set *"], ["proof (prove)\nusing this:\n  Y \\<in> P \\<and> x \\<in> Y\n  P partitions A\n  x \\<in> A\n  X \\<in> P \\<and> x \\<in> X\n\ngoal (1 subgoal):\n 1. Y = X", "unfolding is_partition_of_def is_non_overlapping_def"], ["proof (prove)\nusing this:\n  Y \\<in> P \\<and> x \\<in> Y\n  \\<Union> P = A \\<and>\n  (\\<forall>X\\<in>P. \\<forall>Y\\<in>P. (X \\<inter> Y \\<noteq> {}) = (X = Y))\n  x \\<in> A\n  X \\<in> P \\<and> x \\<in> X\n\ngoal (1 subgoal):\n 1. Y = X", "by (metis disjoint_iff_not_equal)"], ["proof (state)\nthis:\n  Y = X\n\ngoal (1 subgoal):\n 1. \\<exists>!X. X \\<in> P \\<and> x \\<in> X", "}"], ["proof (state)\nthis:\n  ?Y2 \\<in> P \\<and> x \\<in> ?Y2 \\<Longrightarrow> ?Y2 = X\n\ngoal (1 subgoal):\n 1. \\<exists>!X. X \\<in> P \\<and> x \\<in> X", "ultimately"], ["proof (chain)\npicking this:\n  X \\<in> P \\<and> x \\<in> X\n  ?Y2 \\<in> P \\<and> x \\<in> ?Y2 \\<Longrightarrow> ?Y2 = X", "show ?thesis"], ["proof (prove)\nusing this:\n  X \\<in> P \\<and> x \\<in> X\n  ?Y2 \\<in> P \\<and> x \\<in> ?Y2 \\<Longrightarrow> ?Y2 = X\n\ngoal (1 subgoal):\n 1. \\<exists>!X. X \\<in> P \\<and> x \\<in> X", "by (rule ex1I)"], ["proof (state)\nthis:\n  \\<exists>!X. X \\<in> P \\<and> x \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A non-empty set ``is'' a partition of itself.\\<close>"], ["", "lemma set_partitions_itself:\n  assumes \"A \\<noteq> {}\"\n  shows \"{A} partitions A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {A} partitions A", "unfolding is_partition_of_def is_non_overlapping_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {A} = A \\<and>\n    (\\<forall>X\\<in>{A}.\n        \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y))", "(* CL: the following takes 48 ms on my machine with Isabelle2013:\n   by (metis Sup_empty Sup_insert assms inf_idem singletonE sup_bot_right). MC: possibly useful for TPTP *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {A} = A \\<and>\n    (\\<forall>X\\<in>{A}.\n        \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Union> {A} = A\n 2. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "show \"\\<Union> {A} = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {A} = A", "by simp"], ["proof (state)\nthis:\n  \\<Union> {A} = A\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "{"], ["proof (state)\nthis:\n  \\<Union> {A} = A\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "fix X Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "assume \"X \\<in> {A}\""], ["proof (state)\nthis:\n  X \\<in> {A}\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "then"], ["proof (chain)\npicking this:\n  X \\<in> {A}", "have \"X = A\""], ["proof (prove)\nusing this:\n  X \\<in> {A}\n\ngoal (1 subgoal):\n 1. X = A", "by (rule singletonD)"], ["proof (state)\nthis:\n  X = A\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "assume \"Y \\<in> {A}\""], ["proof (state)\nthis:\n  Y \\<in> {A}\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "then"], ["proof (chain)\npicking this:\n  Y \\<in> {A}", "have \"Y = A\""], ["proof (prove)\nusing this:\n  Y \\<in> {A}\n\ngoal (1 subgoal):\n 1. Y = A", "by (rule singletonD)"], ["proof (state)\nthis:\n  Y = A\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "from \\<open>X = A\\<close> \\<open>Y = A\\<close>"], ["proof (chain)\npicking this:\n  X = A\n  Y = A", "have \"X \\<inter> Y \\<noteq> {} \\<longleftrightarrow> X = Y\""], ["proof (prove)\nusing this:\n  X = A\n  Y = A\n\ngoal (1 subgoal):\n 1. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "using assms"], ["proof (prove)\nusing this:\n  X = A\n  Y = A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "by simp"], ["proof (state)\nthis:\n  (X \\<inter> Y \\<noteq> {}) = (X = Y)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?X2 \\<in> {A}; ?Y2 \\<in> {A}\\<rbrakk>\n  \\<Longrightarrow> (?X2 \\<inter> ?Y2 \\<noteq> {}) = (?X2 = ?Y2)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?X2 \\<in> {A}; ?Y2 \\<in> {A}\\<rbrakk>\n  \\<Longrightarrow> (?X2 \\<inter> ?Y2 \\<noteq> {}) = (?X2 = ?Y2)", "show \"\\<forall> X \\<in> {A} . \\<forall> Y \\<in> {A} . X \\<inter> Y \\<noteq> {} \\<longleftrightarrow> X = Y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?X2 \\<in> {A}; ?Y2 \\<in> {A}\\<rbrakk>\n  \\<Longrightarrow> (?X2 \\<inter> ?Y2 \\<noteq> {}) = (?X2 = ?Y2)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{A}.\n       \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)", "by force"], ["proof (state)\nthis:\n  \\<forall>X\\<in>{A}.\n     \\<forall>Y\\<in>{A}. (X \\<inter> Y \\<noteq> {}) = (X = Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The empty set is a partition of the empty set.\\<close>"], ["", "lemma emptyset_part_emptyset1:\n  shows \"{} partitions {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} partitions {}", "unfolding is_partition_of_def is_non_overlapping_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {} = {} \\<and>\n    (\\<forall>X\\<in>{}.\n        \\<forall>Y\\<in>{}. (X \\<inter> Y \\<noteq> {}) = (X = Y))", "by fast"], ["", "text \\<open>Any partition of the empty set is empty.\\<close>"], ["", "lemma emptyset_part_emptyset2:\n  assumes \"P partitions {}\"\n  shows \"P = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = {}", "using assms"], ["proof (prove)\nusing this:\n  P partitions {}\n\ngoal (1 subgoal):\n 1. P = {}", "unfolding is_partition_of_def is_non_overlapping_def"], ["proof (prove)\nusing this:\n  \\<Union> P = {} \\<and>\n  (\\<forall>X\\<in>P. \\<forall>Y\\<in>P. (X \\<inter> Y \\<noteq> {}) = (X = Y))\n\ngoal (1 subgoal):\n 1. P = {}", "by fastforce"], ["", "text \\<open>Classical set-theoretical definition of ``all partitions of a set @{term A}''\\<close>"], ["", "definition all_partitions where \n\"all_partitions A = {P . P partitions A}\""], ["", "text \\<open>The set of all partitions of the empty set only contains the empty set.\n  We need this to prove the base case of @{term all_partitions_paper_equiv_alg}.\\<close>"], ["", "lemma emptyset_part_emptyset3:\n  shows \"all_partitions {} = {{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_partitions {} = {{}}", "unfolding all_partitions_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {P. P partitions {}} = {{}}", "using emptyset_part_emptyset1 emptyset_part_emptyset2"], ["proof (prove)\nusing this:\n  {} partitions {}\n  ?P partitions {} \\<Longrightarrow> ?P = {}\n\ngoal (1 subgoal):\n 1. {P. P partitions {}} = {{}}", "by fast"], ["", "text \\<open>inserts an element new\\_el into a specified set S inside a given family of sets\\<close>"], ["", "definition insert_into_member :: \"'a \\<Rightarrow> 'a set set \\<Rightarrow> 'a set \\<Rightarrow> 'a set set\"\n   where \"insert_into_member new_el Sets S = insert (S \\<union> {new_el}) (Sets - {S})\""], ["", "text \\<open>Using @{const insert_into_member} to insert a fresh element, which is not a member of the\n  set @{term S} being partitioned, into a non-overlapping family of sets yields another\n  non-overlapping family.\\<close>"], ["", "lemma non_overlapping_extension2:\n  fixes new_el::'a\n    and P::\"'a set set\"\n    and X::\"'a set\"\n  assumes non_overlapping: \"is_non_overlapping P\"\n      and class_element: \"X \\<in> P\"\n      and new: \"new_el \\<notin> \\<Union> P\"\n  shows \"is_non_overlapping (insert_into_member new_el P X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_non_overlapping (insert_into_member new_el P X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping (insert_into_member new_el P X)", "let ?Y = \"insert new_el X\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping (insert_into_member new_el P X)", "have rest_is_non_overlapping: \"is_non_overlapping (P - {X})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_non_overlapping (P - {X})", "using non_overlapping subset_is_non_overlapping"], ["proof (prove)\nusing this:\n  is_non_overlapping P\n  \\<lbrakk>?P \\<subseteq> ?Q; is_non_overlapping ?Q\\<rbrakk>\n  \\<Longrightarrow> is_non_overlapping ?P\n\ngoal (1 subgoal):\n 1. is_non_overlapping (P - {X})", "by blast"], ["proof (state)\nthis:\n  is_non_overlapping (P - {X})\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert_into_member new_el P X)", "have *: \"X \\<inter> \\<Union> (P - {X}) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "using non_overlapping class_element"], ["proof (prove)\nusing this:\n  is_non_overlapping P\n  X \\<in> P\n\ngoal (1 subgoal):\n 1. X \\<inter> \\<Union> (P - {X}) = {}", "by (rule disj_eq_classes)"], ["proof (state)\nthis:\n  X \\<inter> \\<Union> (P - {X}) = {}\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert_into_member new_el P X)", "from *"], ["proof (chain)\npicking this:\n  X \\<inter> \\<Union> (P - {X}) = {}", "have non_empty: \"?Y \\<noteq> {}\""], ["proof (prove)\nusing this:\n  X \\<inter> \\<Union> (P - {X}) = {}\n\ngoal (1 subgoal):\n 1. insert new_el X \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  insert new_el X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert_into_member new_el P X)", "from *"], ["proof (chain)\npicking this:\n  X \\<inter> \\<Union> (P - {X}) = {}", "have disjoint: \"?Y \\<inter> \\<Union> (P - {X}) = {}\""], ["proof (prove)\nusing this:\n  X \\<inter> \\<Union> (P - {X}) = {}\n\ngoal (1 subgoal):\n 1. insert new_el X \\<inter> \\<Union> (P - {X}) = {}", "using new"], ["proof (prove)\nusing this:\n  X \\<inter> \\<Union> (P - {X}) = {}\n  new_el \\<notin> \\<Union> P\n\ngoal (1 subgoal):\n 1. insert new_el X \\<inter> \\<Union> (P - {X}) = {}", "by force"], ["proof (state)\nthis:\n  insert new_el X \\<inter> \\<Union> (P - {X}) = {}\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert_into_member new_el P X)", "have \"is_non_overlapping (insert ?Y (P - {X}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_non_overlapping (insert (insert new_el X) (P - {X}))", "using rest_is_non_overlapping disjoint non_empty"], ["proof (prove)\nusing this:\n  is_non_overlapping (P - {X})\n  insert new_el X \\<inter> \\<Union> (P - {X}) = {}\n  insert new_el X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert (insert new_el X) (P - {X}))", "by (rule non_overlapping_extension1)"], ["proof (state)\nthis:\n  is_non_overlapping (insert (insert new_el X) (P - {X}))\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert_into_member new_el P X)", "then"], ["proof (chain)\npicking this:\n  is_non_overlapping (insert (insert new_el X) (P - {X}))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_non_overlapping (insert (insert new_el X) (P - {X}))\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert_into_member new_el P X)", "unfolding insert_into_member_def"], ["proof (prove)\nusing this:\n  is_non_overlapping (insert (insert new_el X) (P - {X}))\n\ngoal (1 subgoal):\n 1. is_non_overlapping (insert (X \\<union> {new_el}) (P - {X}))", "by simp"], ["proof (state)\nthis:\n  is_non_overlapping (insert_into_member new_el P X)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>inserts an element into a specified set inside the given list of sets --\n   the list variant of @{const insert_into_member}\n\n   The rationale for this variant and for everything that depends on it is:\n   While it is possible to computationally enumerate ``all partitions of a set'' as an\n   @{typ \"'a set set set\"}, we need a list representation to apply further computational\n   functions to partitions.  Because of the way we construct partitions (using functions\n   such as @{term all_coarser_partitions_with} below) it is not sufficient to simply use \n   @{typ \"'a set set list\"}, but we need @{typ \"'a set list list\"}.  This is because it is hard \n   to impossible to convert a set to a list, whereas it is easy to convert a @{type list} to a @{type set}.\n\\<close>"], ["", "definition insert_into_member_list :: \"'a \\<Rightarrow> 'a set list \\<Rightarrow> 'a set \\<Rightarrow> 'a set list\"\n  where \"insert_into_member_list new_el Sets S = (S \\<union> {new_el}) # (remove1 S Sets)\""], ["", "text \\<open>@{const insert_into_member_list} and @{const insert_into_member} are equivalent\n  (as in returning the same set).\\<close>"], ["", "lemma insert_into_member_list_equivalence:\n  fixes new_el::'a\n    and Sets::\"'a set list\"\n    and S::\"'a set\"\n  assumes \"distinct Sets\"\n  shows \"set (insert_into_member_list new_el Sets S) = insert_into_member new_el (set Sets) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insert_into_member_list new_el Sets S) =\n    insert_into_member new_el (set Sets) S", "unfolding insert_into_member_list_def insert_into_member_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((S \\<union> {new_el}) # remove1 S Sets) =\n    insert (S \\<union> {new_el}) (set Sets - {S})", "using assms"], ["proof (prove)\nusing this:\n  distinct Sets\n\ngoal (1 subgoal):\n 1. set ((S \\<union> {new_el}) # remove1 S Sets) =\n    insert (S \\<union> {new_el}) (set Sets - {S})", "by simp"], ["", "text \\<open>an alternative characterization of the set partitioned by a partition obtained by \n  inserting an element into an equivalence class of a given partition (if @{term P}\n  \\emph{is} a partition)\\<close>"], ["", "lemma insert_into_member_partition1:\n  fixes elem::'a\n    and P::\"'a set set\"\n    and set::\"'a set\"\n  shows \"\\<Union> (insert_into_member elem P set) = \\<Union> (insert (set \\<union> {elem}) (P - {set}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (insert_into_member elem P set) =\n    \\<Union> (insert (set \\<union> {elem}) (P - {set}))", "(* CL: The following takes 12 ms in Isabelle2013-1-RC1:\n   by (metis insert_into_member_def). MC: possibly useful for TPTP *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (insert_into_member elem P set) =\n    \\<Union> (insert (set \\<union> {elem}) (P - {set}))", "unfolding insert_into_member_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (insert (set \\<union> {elem}) (P - {set})) =\n    \\<Union> (insert (set \\<union> {elem}) (P - {set}))", "by fast"], ["", "text \\<open>Assuming that @{term P} is a partition of a set @{term S}, and @{term \"new_el \\<notin> S\"}, the function defined below yields\n  all possible partitions of @{term \"S \\<union> {new_el}\"} that are coarser than @{term P}\n  (i.e.\\ not splitting classes that already exist in @{term P}).  These comprise one partition \n  with a class @{term \"{new_el}\"} and all other classes unchanged,\n  as well as all partitions obtained by inserting @{term new_el} into one class of @{term P} at a time. While we use the definition to build coarser partitions of an existing partition P, the definition itself does not require P to be a partition.\\<close>"], ["", "definition coarser_partitions_with ::\"'a \\<Rightarrow> 'a set set \\<Rightarrow> 'a set set set\"\n  where \"coarser_partitions_with new_el P = \n    insert\n    \\<comment> \\<open>Let \\<open>P\\<close> be a partition of a set \\<open>Set\\<close>,\\<close>\n    \\<comment> \\<open>and suppose \\<open>new_el \\<notin> Set\\<close>, i.e. \\<open>{new_el} \\<notin> P\\<close>,\\<close>\n    \\<comment> \\<open>then the following constructs a partition of \\<open>Set \\<union> {new_el}\\<close> obtained by\\<close>\n    \\<comment> \\<open>inserting a new class \\<open>{new_el}\\<close> and leaving all previous classes unchanged.\\<close>\n    (insert {new_el} P)\n    \\<comment> \\<open>Let \\<open>P\\<close> be a partition of a set \\<open>Set\\<close>,\\<close>\n    \\<comment> \\<open>and suppose \\<open>new_el \\<notin> Set\\<close>,\\<close>\n    \\<comment> \\<open>then the following constructs\\<close>\n    \\<comment> \\<open>the set of those partitions of \\<open>Set \\<union> {new_el}\\<close> obtained by\\<close>\n    \\<comment> \\<open>inserting \\<open>new_el\\<close> into one class of \\<open>P\\<close> at a time.\\<close>\n    ((insert_into_member new_el P) ` P)\""], ["", "text \\<open>the list variant of @{const coarser_partitions_with}\\<close>"], ["", "definition coarser_partitions_with_list ::\"'a \\<Rightarrow> 'a set list \\<Rightarrow> 'a set list list\"\n  where \"coarser_partitions_with_list new_el P = \n    \\<comment> \\<open>Let \\<open>P\\<close> be a partition of a set \\<open>Set\\<close>,\\<close>\n    \\<comment> \\<open>and suppose \\<open>new_el \\<notin> Set\\<close>, i.e. \\<open>{new_el} \\<notin> set P\\<close>,\\<close>\n    \\<comment> \\<open>then the following constructs a partition of \\<open>Set \\<union> {new_el}\\<close> obtained by\\<close>\n    \\<comment> \\<open>inserting a new class \\<open>{new_el}\\<close> and leaving all previous classes unchanged.\\<close>\n    ({new_el} # P)\n    #\n    \\<comment> \\<open>Let \\<open>P\\<close> be a partition of a set \\<open>Set\\<close>,\\<close>\n    \\<comment> \\<open>and suppose \\<open>new_el \\<notin> Set\\<close>,\\<close>\n    \\<comment> \\<open>then the following constructs\\<close>\n    \\<comment> \\<open>the set of those partitions of \\<open>Set \\<union> {new_el}\\<close> obtained by\\<close>\n    \\<comment> \\<open>inserting \\<open>new_el\\<close> into one class of \\<open>P\\<close> at a time.\\<close>\n    (map ((insert_into_member_list new_el P)) P)\""], ["", "text \\<open>@{const coarser_partitions_with_list} and @{const coarser_partitions_with} are equivalent.\\<close>"], ["", "lemma coarser_partitions_with_list_equivalence:\n  assumes \"distinct P\"\n  shows \"set (map set (coarser_partitions_with_list new_el P)) = \n         coarser_partitions_with new_el (set P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (coarser_partitions_with_list new_el P)) =\n    coarser_partitions_with new_el (set P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map set (coarser_partitions_with_list new_el P)) =\n    coarser_partitions_with new_el (set P)", "have \"set (map set (coarser_partitions_with_list new_el P)) = set (map set (({new_el} # P) # (map ((insert_into_member_list new_el P)) P)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (coarser_partitions_with_list new_el P)) =\n    set (map set\n          (({new_el} # P) # map (insert_into_member_list new_el P) P))", "unfolding coarser_partitions_with_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set\n          (({new_el} # P) # map (insert_into_member_list new_el P) P)) =\n    set (map set\n          (({new_el} # P) # map (insert_into_member_list new_el P) P))", ".."], ["proof (state)\nthis:\n  set (map set (coarser_partitions_with_list new_el P)) =\n  set (map set (({new_el} # P) # map (insert_into_member_list new_el P) P))\n\ngoal (1 subgoal):\n 1. set (map set (coarser_partitions_with_list new_el P)) =\n    coarser_partitions_with new_el (set P)", "also"], ["proof (state)\nthis:\n  set (map set (coarser_partitions_with_list new_el P)) =\n  set (map set (({new_el} # P) # map (insert_into_member_list new_el P) P))\n\ngoal (1 subgoal):\n 1. set (map set (coarser_partitions_with_list new_el P)) =\n    coarser_partitions_with new_el (set P)", "have \"\\<dots> = insert (insert {new_el} (set P)) ((set \\<circ> (insert_into_member_list new_el P)) ` set P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set\n          (({new_el} # P) # map (insert_into_member_list new_el P) P)) =\n    insert (insert {new_el} (set P))\n     ((set \\<circ> insert_into_member_list new_el P) ` set P)", "by simp"], ["proof (state)\nthis:\n  set (map set\n        (({new_el} # P) # map (insert_into_member_list new_el P) P)) =\n  insert (insert {new_el} (set P))\n   ((set \\<circ> insert_into_member_list new_el P) ` set P)\n\ngoal (1 subgoal):\n 1. set (map set (coarser_partitions_with_list new_el P)) =\n    coarser_partitions_with new_el (set P)", "also"], ["proof (state)\nthis:\n  set (map set\n        (({new_el} # P) # map (insert_into_member_list new_el P) P)) =\n  insert (insert {new_el} (set P))\n   ((set \\<circ> insert_into_member_list new_el P) ` set P)\n\ngoal (1 subgoal):\n 1. set (map set (coarser_partitions_with_list new_el P)) =\n    coarser_partitions_with new_el (set P)", "have \"\\<dots> = insert (insert {new_el} (set P)) ((insert_into_member new_el (set P)) ` set P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (insert {new_el} (set P))\n     ((set \\<circ> insert_into_member_list new_el P) ` set P) =\n    insert (insert {new_el} (set P))\n     (insert_into_member new_el (set P) ` set P)", "using assms insert_into_member_list_equivalence"], ["proof (prove)\nusing this:\n  distinct P\n  distinct ?Sets \\<Longrightarrow>\n  set (insert_into_member_list ?new_el ?Sets ?S) =\n  insert_into_member ?new_el (set ?Sets) ?S\n\ngoal (1 subgoal):\n 1. insert (insert {new_el} (set P))\n     ((set \\<circ> insert_into_member_list new_el P) ` set P) =\n    insert (insert {new_el} (set P))\n     (insert_into_member new_el (set P) ` set P)", "by (metis comp_apply)"], ["proof (state)\nthis:\n  insert (insert {new_el} (set P))\n   ((set \\<circ> insert_into_member_list new_el P) ` set P) =\n  insert (insert {new_el} (set P))\n   (insert_into_member new_el (set P) ` set P)\n\ngoal (1 subgoal):\n 1. set (map set (coarser_partitions_with_list new_el P)) =\n    coarser_partitions_with new_el (set P)", "finally"], ["proof (chain)\npicking this:\n  set (map set (coarser_partitions_with_list new_el P)) =\n  insert (insert {new_el} (set P))\n   (insert_into_member new_el (set P) ` set P)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (map set (coarser_partitions_with_list new_el P)) =\n  insert (insert {new_el} (set P))\n   (insert_into_member new_el (set P) ` set P)\n\ngoal (1 subgoal):\n 1. set (map set (coarser_partitions_with_list new_el P)) =\n    coarser_partitions_with new_el (set P)", "unfolding coarser_partitions_with_def"], ["proof (prove)\nusing this:\n  set (map set (coarser_partitions_with_list new_el P)) =\n  insert (insert {new_el} (set P))\n   (insert_into_member new_el (set P) ` set P)\n\ngoal (1 subgoal):\n 1. set (map set (coarser_partitions_with_list new_el P)) =\n    insert (insert {new_el} (set P))\n     (insert_into_member new_el (set P) ` set P)", "."], ["proof (state)\nthis:\n  set (map set (coarser_partitions_with_list new_el P)) =\n  coarser_partitions_with new_el (set P)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Any member of the set of coarser partitions of a given partition, obtained by inserting \n  a given fresh element into each of its classes, is non\\_overlapping.\\<close>"], ["", "lemma non_overlapping_extension3:\n  fixes elem::'a\n    and P::\"'a set set\"\n    and Q::\"'a set set\"\n  assumes P_non_overlapping: \"is_non_overlapping P\"\n      and new_elem: \"elem \\<notin> \\<Union> P\"\n      and Q_coarser: \"Q \\<in> coarser_partitions_with elem P\"\n  shows \"is_non_overlapping Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_non_overlapping Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping Q", "let ?q = \"insert {elem} P\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping Q", "have Q_coarser_unfolded: \"Q \\<in> insert ?q (insert_into_member elem P ` P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<in> insert (insert {elem} P) (insert_into_member elem P ` P)", "using Q_coarser"], ["proof (prove)\nusing this:\n  Q \\<in> coarser_partitions_with elem P\n\ngoal (1 subgoal):\n 1. Q \\<in> insert (insert {elem} P) (insert_into_member elem P ` P)", "unfolding coarser_partitions_with_def"], ["proof (prove)\nusing this:\n  Q \\<in> insert (insert {elem} P) (insert_into_member elem P ` P)\n\ngoal (1 subgoal):\n 1. Q \\<in> insert (insert {elem} P) (insert_into_member elem P ` P)", "by fast"], ["proof (state)\nthis:\n  Q \\<in> insert (insert {elem} P) (insert_into_member elem P ` P)\n\ngoal (1 subgoal):\n 1. is_non_overlapping Q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_non_overlapping Q", "proof (cases \"Q = ?q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Q = insert {elem} P \\<Longrightarrow> is_non_overlapping Q\n 2. Q \\<noteq> insert {elem} P \\<Longrightarrow> is_non_overlapping Q", "case True"], ["proof (state)\nthis:\n  Q = insert {elem} P\n\ngoal (2 subgoals):\n 1. Q = insert {elem} P \\<Longrightarrow> is_non_overlapping Q\n 2. Q \\<noteq> insert {elem} P \\<Longrightarrow> is_non_overlapping Q", "then"], ["proof (chain)\npicking this:\n  Q = insert {elem} P", "show ?thesis"], ["proof (prove)\nusing this:\n  Q = insert {elem} P\n\ngoal (1 subgoal):\n 1. is_non_overlapping Q", "using P_non_overlapping new_elem non_overlapping_extension1"], ["proof (prove)\nusing this:\n  Q = insert {elem} P\n  is_non_overlapping P\n  elem \\<notin> \\<Union> P\n  \\<lbrakk>is_non_overlapping ?P; ?X \\<inter> \\<Union> ?P = {};\n   ?X \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> is_non_overlapping (insert ?X ?P)\n\ngoal (1 subgoal):\n 1. is_non_overlapping Q", "by fastforce"], ["proof (state)\nthis:\n  is_non_overlapping Q\n\ngoal (1 subgoal):\n 1. Q \\<noteq> insert {elem} P \\<Longrightarrow> is_non_overlapping Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Q \\<noteq> insert {elem} P \\<Longrightarrow> is_non_overlapping Q", "case False"], ["proof (state)\nthis:\n  Q \\<noteq> insert {elem} P\n\ngoal (1 subgoal):\n 1. Q \\<noteq> insert {elem} P \\<Longrightarrow> is_non_overlapping Q", "then"], ["proof (chain)\npicking this:\n  Q \\<noteq> insert {elem} P", "have \"Q \\<in> (insert_into_member elem P) ` P\""], ["proof (prove)\nusing this:\n  Q \\<noteq> insert {elem} P\n\ngoal (1 subgoal):\n 1. Q \\<in> insert_into_member elem P ` P", "using Q_coarser_unfolded"], ["proof (prove)\nusing this:\n  Q \\<noteq> insert {elem} P\n  Q \\<in> insert (insert {elem} P) (insert_into_member elem P ` P)\n\ngoal (1 subgoal):\n 1. Q \\<in> insert_into_member elem P ` P", "by fastforce"], ["proof (state)\nthis:\n  Q \\<in> insert_into_member elem P ` P\n\ngoal (1 subgoal):\n 1. Q \\<noteq> insert {elem} P \\<Longrightarrow> is_non_overlapping Q", "then"], ["proof (chain)\npicking this:\n  Q \\<in> insert_into_member elem P ` P", "show ?thesis"], ["proof (prove)\nusing this:\n  Q \\<in> insert_into_member elem P ` P\n\ngoal (1 subgoal):\n 1. is_non_overlapping Q", "using non_overlapping_extension2 P_non_overlapping new_elem"], ["proof (prove)\nusing this:\n  Q \\<in> insert_into_member elem P ` P\n  \\<lbrakk>is_non_overlapping ?P; ?X \\<in> ?P;\n   ?new_el \\<notin> \\<Union> ?P\\<rbrakk>\n  \\<Longrightarrow> is_non_overlapping (insert_into_member ?new_el ?P ?X)\n  is_non_overlapping P\n  elem \\<notin> \\<Union> P\n\ngoal (1 subgoal):\n 1. is_non_overlapping Q", "by fast"], ["proof (state)\nthis:\n  is_non_overlapping Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_non_overlapping Q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Let @{term P} be a partition of a set @{term S}, and @{term elem} an element (which may or may not be\n  in @{term S} already).  Then, any member of @{term \"coarser_partitions_with elem P\"} is a set of sets\n  whose union is @{term \"S \\<union> {elem}\"}, i.e.\\ it satisfies one of the necessary criteria for being a partition of @{term \"S \\<union> {elem}\"}.\n\\<close>"], ["", "lemma coarser_partitions_covers:\n  fixes elem::'a\n    and P::\"'a set set\"\n    and Q::\"'a set set\"\n  assumes \"Q \\<in> coarser_partitions_with elem P\"\n  shows \"\\<Union> Q = insert elem (\\<Union> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "let ?S = \"\\<Union> P\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "have Q_cases: \"Q \\<in> (insert_into_member elem P) ` P \\<or> Q = insert {elem} P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<in> insert_into_member elem P ` P \\<or> Q = insert {elem} P", "using assms"], ["proof (prove)\nusing this:\n  Q \\<in> coarser_partitions_with elem P\n\ngoal (1 subgoal):\n 1. Q \\<in> insert_into_member elem P ` P \\<or> Q = insert {elem} P", "unfolding coarser_partitions_with_def"], ["proof (prove)\nusing this:\n  Q \\<in> insert (insert {elem} P) (insert_into_member elem P ` P)\n\ngoal (1 subgoal):\n 1. Q \\<in> insert_into_member elem P ` P \\<or> Q = insert {elem} P", "by fast"], ["proof (state)\nthis:\n  Q \\<in> insert_into_member elem P ` P \\<or> Q = insert {elem} P\n\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "{"], ["proof (state)\nthis:\n  Q \\<in> insert_into_member elem P ` P \\<or> Q = insert {elem} P\n\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "fix eq_class"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "assume eq_class_in_P: \"eq_class \\<in> P\""], ["proof (state)\nthis:\n  eq_class \\<in> P\n\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "have \"\\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) = ?S \\<union> (eq_class \\<union> {elem})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) =\n    \\<Union> P \\<union> (eq_class \\<union> {elem})", "using insert_into_member_partition1"], ["proof (prove)\nusing this:\n  \\<Union> (insert_into_member ?elem ?P ?set) =\n  \\<Union> (insert (?set \\<union> {?elem}) (?P - {?set}))\n\ngoal (1 subgoal):\n 1. \\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) =\n    \\<Union> P \\<union> (eq_class \\<union> {elem})", "by (metis Sup_insert Un_commute Un_empty_right Un_insert_right insert_Diff_single)"], ["proof (state)\nthis:\n  \\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) =\n  \\<Union> P \\<union> (eq_class \\<union> {elem})\n\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "with eq_class_in_P"], ["proof (chain)\npicking this:\n  eq_class \\<in> P\n  \\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) =\n  \\<Union> P \\<union> (eq_class \\<union> {elem})", "have \"\\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) = ?S \\<union> {elem}\""], ["proof (prove)\nusing this:\n  eq_class \\<in> P\n  \\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) =\n  \\<Union> P \\<union> (eq_class \\<union> {elem})\n\ngoal (1 subgoal):\n 1. \\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) =\n    \\<Union> P \\<union> {elem}", "by blast"], ["proof (state)\nthis:\n  \\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) =\n  \\<Union> P \\<union> {elem}\n\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "then"], ["proof (chain)\npicking this:\n  \\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) =\n  \\<Union> P \\<union> {elem}", "have \"\\<Union> (insert_into_member elem P eq_class) = ?S \\<union> {elem}\""], ["proof (prove)\nusing this:\n  \\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) =\n  \\<Union> P \\<union> {elem}\n\ngoal (1 subgoal):\n 1. \\<Union> (insert_into_member elem P eq_class) =\n    \\<Union> P \\<union> {elem}", "using insert_into_member_partition1"], ["proof (prove)\nusing this:\n  \\<Union> (insert (eq_class \\<union> {elem}) (P - {eq_class})) =\n  \\<Union> P \\<union> {elem}\n  \\<Union> (insert_into_member ?elem ?P ?set) =\n  \\<Union> (insert (?set \\<union> {?elem}) (?P - {?set}))\n\ngoal (1 subgoal):\n 1. \\<Union> (insert_into_member elem P eq_class) =\n    \\<Union> P \\<union> {elem}", "by (rule subst)"], ["proof (state)\nthis:\n  \\<Union> (insert_into_member elem P eq_class) = \\<Union> P \\<union> {elem}\n\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "}"], ["proof (state)\nthis:\n  ?eq_class2 \\<in> P \\<Longrightarrow>\n  \\<Union> (insert_into_member elem P ?eq_class2) =\n  \\<Union> P \\<union> {elem}\n\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "then"], ["proof (chain)\npicking this:\n  ?eq_class2 \\<in> P \\<Longrightarrow>\n  \\<Union> (insert_into_member elem P ?eq_class2) =\n  \\<Union> P \\<union> {elem}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?eq_class2 \\<in> P \\<Longrightarrow>\n  \\<Union> (insert_into_member elem P ?eq_class2) =\n  \\<Union> P \\<union> {elem}\n\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "using Q_cases"], ["proof (prove)\nusing this:\n  ?eq_class2 \\<in> P \\<Longrightarrow>\n  \\<Union> (insert_into_member elem P ?eq_class2) =\n  \\<Union> P \\<union> {elem}\n  Q \\<in> insert_into_member elem P ` P \\<or> Q = insert {elem} P\n\ngoal (1 subgoal):\n 1. \\<Union> Q = insert elem (\\<Union> P)", "by blast"], ["proof (state)\nthis:\n  \\<Union> Q = insert elem (\\<Union> P)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Removes the element @{term elem} from every set in @{term P}, and removes from @{term P} any\n  remaining empty sets.  This function is intended to be applied to partitions, i.e. @{term elem}\n  occurs in at most one set.  @{term \"partition_without e\"} reverses @{term \"coarser_partitions_with e\"}.\n@{const coarser_partitions_with} is one-to-many, while this is one-to-one, so we can think of a tree relation,\nwhere coarser partitions of a set @{term \"S \\<union> {elem}\"} are child nodes of one partition of @{term S}.\\<close>"], ["", "definition partition_without :: \"'a \\<Rightarrow> 'a set set \\<Rightarrow> 'a set set\"\n  where \"partition_without elem P = (\\<lambda>X . X - {elem}) ` P - {{}}\""], ["", "(* Set comprehension notation { x - {elem} | x . x \\<in> P } would look nicer but is harder to do proofs about *)\n\n(* We don't need to define partition_without_list. *)"], ["", "text \\<open>alternative characterization of the set partitioned by the partition obtained \n  by removing an element from a given partition using @{const partition_without}\\<close>"], ["", "lemma partition_without_covers:\n  fixes elem::'a\n    and P::\"'a set set\"\n  shows \"\\<Union> (partition_without elem P) = (\\<Union> P) - {elem}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (partition_without elem P) = \\<Union> P - {elem}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (partition_without elem P) = \\<Union> P - {elem}", "have \"\\<Union> (partition_without elem P) = \\<Union> ((\\<lambda>x . x - {elem}) ` P - {{}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (partition_without elem P) =\n    \\<Union> ((\\<lambda>x. x - {elem}) ` P - {{}})", "unfolding partition_without_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> ((\\<lambda>X. X - {elem}) ` P - {{}}) =\n    \\<Union> ((\\<lambda>x. x - {elem}) ` P - {{}})", "by fast"], ["proof (state)\nthis:\n  \\<Union> (partition_without elem P) =\n  \\<Union> ((\\<lambda>x. x - {elem}) ` P - {{}})\n\ngoal (1 subgoal):\n 1. \\<Union> (partition_without elem P) = \\<Union> P - {elem}", "also"], ["proof (state)\nthis:\n  \\<Union> (partition_without elem P) =\n  \\<Union> ((\\<lambda>x. x - {elem}) ` P - {{}})\n\ngoal (1 subgoal):\n 1. \\<Union> (partition_without elem P) = \\<Union> P - {elem}", "have \"\\<dots> = \\<Union> P - {elem}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> ((\\<lambda>x. x - {elem}) ` P - {{}}) = \\<Union> P - {elem}", "by blast"], ["proof (state)\nthis:\n  \\<Union> ((\\<lambda>x. x - {elem}) ` P - {{}}) = \\<Union> P - {elem}\n\ngoal (1 subgoal):\n 1. \\<Union> (partition_without elem P) = \\<Union> P - {elem}", "finally"], ["proof (chain)\npicking this:\n  \\<Union> (partition_without elem P) = \\<Union> P - {elem}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Union> (partition_without elem P) = \\<Union> P - {elem}\n\ngoal (1 subgoal):\n 1. \\<Union> (partition_without elem P) = \\<Union> P - {elem}", "."], ["proof (state)\nthis:\n  \\<Union> (partition_without elem P) = \\<Union> P - {elem}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Any class of the partition obtained by removing an element @{term elem} from an\n  original partition @{term P} using @{const partition_without} equals some\n  class of @{term P}, reduced by @{term elem}.\\<close>"], ["", "lemma super_class:\n  assumes \"X \\<in> partition_without elem P\"\n  obtains Z where \"Z \\<in> P\" and \"X = Z - {elem}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>Z \\<in> P; X = Z - {elem}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>Z \\<in> P; X = Z - {elem}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  X \\<in> partition_without elem P", "have \"X \\<in> (\\<lambda>X . X - {elem}) ` P - {{}}\""], ["proof (prove)\nusing this:\n  X \\<in> partition_without elem P\n\ngoal (1 subgoal):\n 1. X \\<in> (\\<lambda>X. X - {elem}) ` P - {{}}", "unfolding partition_without_def"], ["proof (prove)\nusing this:\n  X \\<in> (\\<lambda>X. X - {elem}) ` P - {{}}\n\ngoal (1 subgoal):\n 1. X \\<in> (\\<lambda>X. X - {elem}) ` P - {{}}", "."], ["proof (state)\nthis:\n  X \\<in> (\\<lambda>X. X - {elem}) ` P - {{}}\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>Z \\<in> P; X = Z - {elem}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  X \\<in> (\\<lambda>X. X - {elem}) ` P - {{}}", "obtain Z where Z_in_P: \"Z \\<in> P\" and Z_sup: \"X = Z - {elem}\""], ["proof (prove)\nusing this:\n  X \\<in> (\\<lambda>X. X - {elem}) ` P - {{}}\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>Z \\<in> P; X = Z - {elem}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (lifting) Diff_iff image_iff)"], ["proof (state)\nthis:\n  Z \\<in> P\n  X = Z - {elem}\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>Z \\<in> P; X = Z - {elem}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  Z \\<in> P\n  X = Z - {elem}", "show ?thesis"], ["proof (prove)\nusing this:\n  Z \\<in> P\n  X = Z - {elem}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The class of sets obtained by removing an element from a non-overlapping class is another\n  non-overlapping clas.\\<close>"], ["", "lemma non_overlapping_without_is_non_overlapping:\n  fixes elem::'a\n    and P::\"'a set set\"\n  assumes \"is_non_overlapping P\"\n  shows \"is_non_overlapping (partition_without elem P)\" (is \"is_non_overlapping ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_non_overlapping (partition_without elem P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_non_overlapping (partition_without elem P)", "have \"\\<forall> X1 \\<in> ?Q. \\<forall> X2 \\<in> ?Q. X1 \\<inter> X2 \\<noteq> {} \\<longleftrightarrow> X1 = X2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X1\\<in>partition_without elem P.\n       \\<forall>X2\\<in>partition_without elem P.\n          (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X1.\n       X1 \\<in> partition_without elem P \\<Longrightarrow>\n       \\<forall>X2\\<in>partition_without elem P.\n          (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "fix X1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X1.\n       X1 \\<in> partition_without elem P \\<Longrightarrow>\n       \\<forall>X2\\<in>partition_without elem P.\n          (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "assume X1_in_Q: \"X1 \\<in> ?Q\""], ["proof (state)\nthis:\n  X1 \\<in> partition_without elem P\n\ngoal (1 subgoal):\n 1. \\<And>X1.\n       X1 \\<in> partition_without elem P \\<Longrightarrow>\n       \\<forall>X2\\<in>partition_without elem P.\n          (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "then"], ["proof (chain)\npicking this:\n  X1 \\<in> partition_without elem P", "obtain Z1 where Z1_in_P: \"Z1 \\<in> P\" and Z1_sup: \"X1 = Z1 - {elem}\""], ["proof (prove)\nusing this:\n  X1 \\<in> partition_without elem P\n\ngoal (1 subgoal):\n 1. (\\<And>Z1.\n        \\<lbrakk>Z1 \\<in> P; X1 = Z1 - {elem}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule super_class)"], ["proof (state)\nthis:\n  Z1 \\<in> P\n  X1 = Z1 - {elem}\n\ngoal (1 subgoal):\n 1. \\<And>X1.\n       X1 \\<in> partition_without elem P \\<Longrightarrow>\n       \\<forall>X2\\<in>partition_without elem P.\n          (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "have X1_non_empty: \"X1 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "using X1_in_Q partition_without_def"], ["proof (prove)\nusing this:\n  X1 \\<in> partition_without elem P\n  partition_without ?elem ?P = (\\<lambda>X. X - {?elem}) ` ?P - {{}}\n\ngoal (1 subgoal):\n 1. X1 \\<noteq> {}", "by fast"], ["proof (state)\nthis:\n  X1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>X1.\n       X1 \\<in> partition_without elem P \\<Longrightarrow>\n       \\<forall>X2\\<in>partition_without elem P.\n          (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "show \"\\<forall> X2 \\<in> ?Q. X1 \\<inter> X2 \\<noteq> {} \\<longleftrightarrow> X1 = X2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X2\\<in>partition_without elem P.\n       (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X2.\n       X2 \\<in> partition_without elem P \\<Longrightarrow>\n       (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "fix X2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X2.\n       X2 \\<in> partition_without elem P \\<Longrightarrow>\n       (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "assume \"X2 \\<in> ?Q\""], ["proof (state)\nthis:\n  X2 \\<in> partition_without elem P\n\ngoal (1 subgoal):\n 1. \\<And>X2.\n       X2 \\<in> partition_without elem P \\<Longrightarrow>\n       (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "then"], ["proof (chain)\npicking this:\n  X2 \\<in> partition_without elem P", "obtain Z2 where Z2_in_P: \"Z2 \\<in> P\" and Z2_sup: \"X2 = Z2 - {elem}\""], ["proof (prove)\nusing this:\n  X2 \\<in> partition_without elem P\n\ngoal (1 subgoal):\n 1. (\\<And>Z2.\n        \\<lbrakk>Z2 \\<in> P; X2 = Z2 - {elem}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule super_class)"], ["proof (state)\nthis:\n  Z2 \\<in> P\n  X2 = Z2 - {elem}\n\ngoal (1 subgoal):\n 1. \\<And>X2.\n       X2 \\<in> partition_without elem P \\<Longrightarrow>\n       (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "have \"X1 \\<inter> X2 \\<noteq> {} \\<longrightarrow> X1 = X2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X1 \\<inter> X2 \\<noteq> {} \\<longrightarrow> X1 = X2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. X1 \\<inter> X2 \\<noteq> {} \\<Longrightarrow> X1 = X2", "assume \"X1 \\<inter> X2 \\<noteq> {}\""], ["proof (state)\nthis:\n  X1 \\<inter> X2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X1 \\<inter> X2 \\<noteq> {} \\<Longrightarrow> X1 = X2", "then"], ["proof (chain)\npicking this:\n  X1 \\<inter> X2 \\<noteq> {}", "have \"Z1 \\<inter> Z2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  X1 \\<inter> X2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Z1 \\<inter> Z2 \\<noteq> {}", "using Z1_sup Z2_sup"], ["proof (prove)\nusing this:\n  X1 \\<inter> X2 \\<noteq> {}\n  X1 = Z1 - {elem}\n  X2 = Z2 - {elem}\n\ngoal (1 subgoal):\n 1. Z1 \\<inter> Z2 \\<noteq> {}", "by fast"], ["proof (state)\nthis:\n  Z1 \\<inter> Z2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X1 \\<inter> X2 \\<noteq> {} \\<Longrightarrow> X1 = X2", "then"], ["proof (chain)\npicking this:\n  Z1 \\<inter> Z2 \\<noteq> {}", "have \"Z1 = Z2\""], ["proof (prove)\nusing this:\n  Z1 \\<inter> Z2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Z1 = Z2", "using Z1_in_P Z2_in_P assms"], ["proof (prove)\nusing this:\n  Z1 \\<inter> Z2 \\<noteq> {}\n  Z1 \\<in> P\n  Z2 \\<in> P\n  is_non_overlapping P\n\ngoal (1 subgoal):\n 1. Z1 = Z2", "unfolding is_non_overlapping_def"], ["proof (prove)\nusing this:\n  Z1 \\<inter> Z2 \\<noteq> {}\n  Z1 \\<in> P\n  Z2 \\<in> P\n  \\<forall>X\\<in>P. \\<forall>Y\\<in>P. (X \\<inter> Y \\<noteq> {}) = (X = Y)\n\ngoal (1 subgoal):\n 1. Z1 = Z2", "by fast"], ["proof (state)\nthis:\n  Z1 = Z2\n\ngoal (1 subgoal):\n 1. X1 \\<inter> X2 \\<noteq> {} \\<Longrightarrow> X1 = X2", "then"], ["proof (chain)\npicking this:\n  Z1 = Z2", "show \"X1 = X2\""], ["proof (prove)\nusing this:\n  Z1 = Z2\n\ngoal (1 subgoal):\n 1. X1 = X2", "using Z1_sup Z2_sup"], ["proof (prove)\nusing this:\n  Z1 = Z2\n  X1 = Z1 - {elem}\n  X2 = Z2 - {elem}\n\ngoal (1 subgoal):\n 1. X1 = X2", "by fast"], ["proof (state)\nthis:\n  X1 = X2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X1 \\<inter> X2 \\<noteq> {} \\<longrightarrow> X1 = X2\n\ngoal (1 subgoal):\n 1. \\<And>X2.\n       X2 \\<in> partition_without elem P \\<Longrightarrow>\n       (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "moreover"], ["proof (state)\nthis:\n  X1 \\<inter> X2 \\<noteq> {} \\<longrightarrow> X1 = X2\n\ngoal (1 subgoal):\n 1. \\<And>X2.\n       X2 \\<in> partition_without elem P \\<Longrightarrow>\n       (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "have \"X1 = X2 \\<longrightarrow> X1 \\<inter> X2 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X1 = X2 \\<longrightarrow> X1 \\<inter> X2 \\<noteq> {}", "using X1_non_empty"], ["proof (prove)\nusing this:\n  X1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X1 = X2 \\<longrightarrow> X1 \\<inter> X2 \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  X1 = X2 \\<longrightarrow> X1 \\<inter> X2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>X2.\n       X2 \\<in> partition_without elem P \\<Longrightarrow>\n       (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "ultimately"], ["proof (chain)\npicking this:\n  X1 \\<inter> X2 \\<noteq> {} \\<longrightarrow> X1 = X2\n  X1 = X2 \\<longrightarrow> X1 \\<inter> X2 \\<noteq> {}", "show \"(X1 \\<inter> X2 \\<noteq> {}) \\<longleftrightarrow> X1 = X2\""], ["proof (prove)\nusing this:\n  X1 \\<inter> X2 \\<noteq> {} \\<longrightarrow> X1 = X2\n  X1 = X2 \\<longrightarrow> X1 \\<inter> X2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "by blast"], ["proof (state)\nthis:\n  (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>X2\\<in>partition_without elem P.\n     (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>X1\\<in>partition_without elem P.\n     \\<forall>X2\\<in>partition_without elem P.\n        (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)\n\ngoal (1 subgoal):\n 1. is_non_overlapping (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  \\<forall>X1\\<in>partition_without elem P.\n     \\<forall>X2\\<in>partition_without elem P.\n        (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>X1\\<in>partition_without elem P.\n     \\<forall>X2\\<in>partition_without elem P.\n        (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)\n\ngoal (1 subgoal):\n 1. is_non_overlapping (partition_without elem P)", "unfolding is_non_overlapping_def"], ["proof (prove)\nusing this:\n  \\<forall>X1\\<in>partition_without elem P.\n     \\<forall>X2\\<in>partition_without elem P.\n        (X1 \\<inter> X2 \\<noteq> {}) = (X1 = X2)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>partition_without elem P.\n       \\<forall>Y\\<in>partition_without elem P.\n          (X \\<inter> Y \\<noteq> {}) = (X = Y)", "."], ["proof (state)\nthis:\n  is_non_overlapping (partition_without elem P)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{term \"coarser_partitions_with elem\"} is the ``inverse'' of \n  @{term \"partition_without elem\"}.\\<close>"], ["", "lemma coarser_partitions_inv_without:\n  fixes elem::'a\n    and P::\"'a set set\"\n  assumes non_overlapping: \"is_non_overlapping P\"\n      and elem: \"elem \\<in> \\<Union> P\" \n  shows \"P \\<in> coarser_partitions_with elem (partition_without elem P)\"\n    (is \"P \\<in> coarser_partitions_with elem ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "let ?remove_elem = \"\\<lambda>X . X - {elem}\""], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "(* function that removes elem out of a set *)"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "obtain Y (* the equivalence class of elem *)\n    where elem_eq_class: \"elem \\<in> Y\" and elem_eq_class': \"Y \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>elem \\<in> Y; Y \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using elem"], ["proof (prove)\nusing this:\n  elem \\<in> \\<Union> P\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>elem \\<in> Y; Y \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  elem \\<in> Y\n  Y \\<in> P\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "let ?elem_neq_classes = \"P - {Y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "(* those equivalence classes of which elem is not a member *)"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "have P_wrt_elem: \"P = ?elem_neq_classes \\<union> {Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = P - {Y} \\<union> {Y}", "using elem_eq_class'"], ["proof (prove)\nusing this:\n  Y \\<in> P\n\ngoal (1 subgoal):\n 1. P = P - {Y} \\<union> {Y}", "by blast"], ["proof (state)\nthis:\n  P = P - {Y} \\<union> {Y}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "let ?elem_eq = \"Y - {elem}\""], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "(* other elements equivalent to elem *)"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "have Y_elem_eq: \"?remove_elem ` {Y} = {?elem_eq}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>X. X - {elem}) ` {Y} = {Y - {elem}}", "by fast"], ["proof (state)\nthis:\n  (\\<lambda>X. X - {elem}) ` {Y} = {Y - {elem}}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "(* those classes,of which elem is not a member, form a partition *)"], ["proof (state)\nthis:\n  (\\<lambda>X. X - {elem}) ` {Y} = {Y - {elem}}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "have elem_neq_classes_part: \"is_non_overlapping ?elem_neq_classes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_non_overlapping (P - {Y})", "using subset_is_non_overlapping non_overlapping"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P \\<subseteq> ?Q; is_non_overlapping ?Q\\<rbrakk>\n  \\<Longrightarrow> is_non_overlapping ?P\n  is_non_overlapping P\n\ngoal (1 subgoal):\n 1. is_non_overlapping (P - {Y})", "by blast"], ["proof (state)\nthis:\n  is_non_overlapping (P - {Y})\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "have elem_eq_wrt_P: \"?elem_eq \\<in> ?remove_elem ` P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y - {elem} \\<in> (\\<lambda>X. X - {elem}) ` P", "using elem_eq_class'"], ["proof (prove)\nusing this:\n  Y \\<in> P\n\ngoal (1 subgoal):\n 1. Y - {elem} \\<in> (\\<lambda>X. X - {elem}) ` P", "by blast"], ["proof (state)\nthis:\n  Y - {elem} \\<in> (\\<lambda>X. X - {elem}) ` P\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "{"], ["proof (state)\nthis:\n  Y - {elem} \\<in> (\\<lambda>X. X - {elem}) ` P\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "(* consider a class W, of which elem is not a member *)"], ["proof (state)\nthis:\n  Y - {elem} \\<in> (\\<lambda>X. X - {elem}) ` P\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "fix W"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "assume W_eq_class: \"W \\<in> ?elem_neq_classes\""], ["proof (state)\nthis:\n  W \\<in> P - {Y}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  W \\<in> P - {Y}", "have \"elem \\<notin> W\""], ["proof (prove)\nusing this:\n  W \\<in> P - {Y}\n\ngoal (1 subgoal):\n 1. elem \\<notin> W", "using elem_eq_class elem_eq_class' non_overlapping is_non_overlapping_def"], ["proof (prove)\nusing this:\n  W \\<in> P - {Y}\n  elem \\<in> Y\n  Y \\<in> P\n  is_non_overlapping P\n  is_non_overlapping ?P =\n  (\\<forall>X\\<in>?P.\n      \\<forall>Y\\<in>?P. (X \\<inter> Y \\<noteq> {}) = (X = Y))\n\ngoal (1 subgoal):\n 1. elem \\<notin> W", "by fast"], ["proof (state)\nthis:\n  elem \\<notin> W\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  elem \\<notin> W", "have \"?remove_elem W = W\""], ["proof (prove)\nusing this:\n  elem \\<notin> W\n\ngoal (1 subgoal):\n 1. W - {elem} = W", "by simp"], ["proof (state)\nthis:\n  W - {elem} = W\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "}"], ["proof (state)\nthis:\n  ?W2 \\<in> P - {Y} \\<Longrightarrow> ?W2 - {elem} = ?W2\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  ?W2 \\<in> P - {Y} \\<Longrightarrow> ?W2 - {elem} = ?W2", "have elem_neq_classes_id: \"?remove_elem ` ?elem_neq_classes = ?elem_neq_classes\""], ["proof (prove)\nusing this:\n  ?W2 \\<in> P - {Y} \\<Longrightarrow> ?W2 - {elem} = ?W2\n\ngoal (1 subgoal):\n 1. (\\<lambda>X. X - {elem}) ` (P - {Y}) = P - {Y}", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>X. X - {elem}) ` (P - {Y}) = P - {Y}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "have Q_unfolded: \"?Q = ?remove_elem ` P - {{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_without elem P = (\\<lambda>X. X - {elem}) ` P - {{}}", "unfolding partition_without_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>X. X - {elem}) ` P - {{}} =\n    (\\<lambda>X. X - {elem}) ` P - {{}}", "using image_Collect_mem"], ["proof (prove)\nusing this:\n  {?f x |x. x \\<in> ?S} = ?f ` ?S\n\ngoal (1 subgoal):\n 1. (\\<lambda>X. X - {elem}) ` P - {{}} =\n    (\\<lambda>X. X - {elem}) ` P - {{}}", "by blast"], ["proof (state)\nthis:\n  partition_without elem P = (\\<lambda>X. X - {elem}) ` P - {{}}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "also"], ["proof (state)\nthis:\n  partition_without elem P = (\\<lambda>X. X - {elem}) ` P - {{}}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "have \"\\<dots> = ?remove_elem ` (?elem_neq_classes \\<union> {Y}) - {{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>X. X - {elem}) ` P - {{}} =\n    (\\<lambda>X. X - {elem}) ` (P - {Y} \\<union> {Y}) - {{}}", "using P_wrt_elem"], ["proof (prove)\nusing this:\n  P = P - {Y} \\<union> {Y}\n\ngoal (1 subgoal):\n 1. (\\<lambda>X. X - {elem}) ` P - {{}} =\n    (\\<lambda>X. X - {elem}) ` (P - {Y} \\<union> {Y}) - {{}}", "by presburger"], ["proof (state)\nthis:\n  (\\<lambda>X. X - {elem}) ` P - {{}} =\n  (\\<lambda>X. X - {elem}) ` (P - {Y} \\<union> {Y}) - {{}}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "also"], ["proof (state)\nthis:\n  (\\<lambda>X. X - {elem}) ` P - {{}} =\n  (\\<lambda>X. X - {elem}) ` (P - {Y} \\<union> {Y}) - {{}}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "have \"\\<dots> = ?elem_neq_classes \\<union> {?elem_eq} - {{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>X. X - {elem}) ` (P - {Y} \\<union> {Y}) - {{}} =\n    P - {Y} \\<union> {Y - {elem}} - {{}}", "using Y_elem_eq elem_neq_classes_id image_Un"], ["proof (prove)\nusing this:\n  (\\<lambda>X. X - {elem}) ` {Y} = {Y - {elem}}\n  (\\<lambda>X. X - {elem}) ` (P - {Y}) = P - {Y}\n  ?f ` (?A \\<union> ?B) = ?f ` ?A \\<union> ?f ` ?B\n\ngoal (1 subgoal):\n 1. (\\<lambda>X. X - {elem}) ` (P - {Y} \\<union> {Y}) - {{}} =\n    P - {Y} \\<union> {Y - {elem}} - {{}}", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>X. X - {elem}) ` (P - {Y} \\<union> {Y}) - {{}} =\n  P - {Y} \\<union> {Y - {elem}} - {{}}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "finally"], ["proof (chain)\npicking this:\n  partition_without elem P = P - {Y} \\<union> {Y - {elem}} - {{}}", "have Q_wrt_elem: \"?Q = ?elem_neq_classes \\<union> {?elem_eq} - {{}}\""], ["proof (prove)\nusing this:\n  partition_without elem P = P - {Y} \\<union> {Y - {elem}} - {{}}\n\ngoal (1 subgoal):\n 1. partition_without elem P = P - {Y} \\<union> {Y - {elem}} - {{}}", "."], ["proof (state)\nthis:\n  partition_without elem P = P - {Y} \\<union> {Y - {elem}} - {{}}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "have \"?elem_eq = {} \\<or> ?elem_eq \\<notin> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y - {elem} = {} \\<or> Y - {elem} \\<notin> P", "using elem_eq_class elem_eq_class' non_overlapping Diff_Int_distrib2 Diff_iff empty_Diff insert_iff"], ["proof (prove)\nusing this:\n  elem \\<in> Y\n  Y \\<in> P\n  is_non_overlapping P\n  (?A - ?B) \\<inter> ?C = ?A \\<inter> ?C - ?B \\<inter> ?C\n  (?c \\<in> ?A - ?B) = (?c \\<in> ?A \\<and> ?c \\<notin> ?B)\n  {} - ?A = {}\n  (?a \\<in> insert ?b ?A) = (?a = ?b \\<or> ?a \\<in> ?A)\n\ngoal (1 subgoal):\n 1. Y - {elem} = {} \\<or> Y - {elem} \\<notin> P", "unfolding is_non_overlapping_def"], ["proof (prove)\nusing this:\n  elem \\<in> Y\n  Y \\<in> P\n  \\<forall>X\\<in>P. \\<forall>Y\\<in>P. (X \\<inter> Y \\<noteq> {}) = (X = Y)\n  (?A - ?B) \\<inter> ?C = ?A \\<inter> ?C - ?B \\<inter> ?C\n  (?c \\<in> ?A - ?B) = (?c \\<in> ?A \\<and> ?c \\<notin> ?B)\n  {} - ?A = {}\n  (?a \\<in> insert ?b ?A) = (?a = ?b \\<or> ?a \\<in> ?A)\n\ngoal (1 subgoal):\n 1. Y - {elem} = {} \\<or> Y - {elem} \\<notin> P", "by metis"], ["proof (state)\nthis:\n  Y - {elem} = {} \\<or> Y - {elem} \\<notin> P\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  Y - {elem} = {} \\<or> Y - {elem} \\<notin> P", "have \"?elem_eq \\<notin> P\""], ["proof (prove)\nusing this:\n  Y - {elem} = {} \\<or> Y - {elem} \\<notin> P\n\ngoal (1 subgoal):\n 1. Y - {elem} \\<notin> P", "using non_overlapping no_empty_in_non_overlapping"], ["proof (prove)\nusing this:\n  Y - {elem} = {} \\<or> Y - {elem} \\<notin> P\n  is_non_overlapping P\n  is_non_overlapping ?p \\<Longrightarrow> {} \\<notin> ?p\n\ngoal (1 subgoal):\n 1. Y - {elem} \\<notin> P", "by metis"], ["proof (state)\nthis:\n  Y - {elem} \\<notin> P\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  Y - {elem} \\<notin> P", "have elem_neq_classes: \"?elem_neq_classes - {?elem_eq} = ?elem_neq_classes\""], ["proof (prove)\nusing this:\n  Y - {elem} \\<notin> P\n\ngoal (1 subgoal):\n 1. P - {Y} - {Y - {elem}} = P - {Y}", "by fastforce"], ["proof (state)\nthis:\n  P - {Y} - {Y - {elem}} = P - {Y}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "assume \"?elem_eq \\<notin> ?Q\""], ["proof (state)\nthis:\n  Y - {elem} \\<notin> partition_without elem P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "(* the class of elem is not a member of ?Q = partition_without elem P *)"], ["proof (state)\nthis:\n  Y - {elem} \\<notin> partition_without elem P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  Y - {elem} \\<notin> partition_without elem P", "have \"?elem_eq \\<in> {{}}\""], ["proof (prove)\nusing this:\n  Y - {elem} \\<notin> partition_without elem P\n\ngoal (1 subgoal):\n 1. Y - {elem} \\<in> {{}}", "using elem_eq_wrt_P Q_unfolded"], ["proof (prove)\nusing this:\n  Y - {elem} \\<notin> partition_without elem P\n  Y - {elem} \\<in> (\\<lambda>X. X - {elem}) ` P\n  partition_without elem P = (\\<lambda>X. X - {elem}) ` P - {{}}\n\ngoal (1 subgoal):\n 1. Y - {elem} \\<in> {{}}", "by (metis DiffI)"], ["proof (state)\nthis:\n  Y - {elem} \\<in> {{}}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  Y - {elem} \\<in> {{}}", "have Y_singleton: \"Y = {elem}\""], ["proof (prove)\nusing this:\n  Y - {elem} \\<in> {{}}\n\ngoal (1 subgoal):\n 1. Y = {elem}", "using elem_eq_class"], ["proof (prove)\nusing this:\n  Y - {elem} \\<in> {{}}\n  elem \\<in> Y\n\ngoal (1 subgoal):\n 1. Y = {elem}", "by fast"], ["proof (state)\nthis:\n  Y = {elem}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  Y = {elem}", "have \"?Q = ?elem_neq_classes - {{}}\""], ["proof (prove)\nusing this:\n  Y = {elem}\n\ngoal (1 subgoal):\n 1. partition_without elem P = P - {Y} - {{}}", "using Q_wrt_elem"], ["proof (prove)\nusing this:\n  Y = {elem}\n  partition_without elem P = P - {Y} \\<union> {Y - {elem}} - {{}}\n\ngoal (1 subgoal):\n 1. partition_without elem P = P - {Y} - {{}}", "by force"], ["proof (state)\nthis:\n  partition_without elem P = P - {Y} - {{}}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  partition_without elem P = P - {Y} - {{}}", "have \"?Q = ?elem_neq_classes\""], ["proof (prove)\nusing this:\n  partition_without elem P = P - {Y} - {{}}\n\ngoal (1 subgoal):\n 1. partition_without elem P = P - {Y}", "using no_empty_in_non_overlapping elem_neq_classes_part"], ["proof (prove)\nusing this:\n  partition_without elem P = P - {Y} - {{}}\n  is_non_overlapping ?p \\<Longrightarrow> {} \\<notin> ?p\n  is_non_overlapping (P - {Y})\n\ngoal (1 subgoal):\n 1. partition_without elem P = P - {Y}", "by blast"], ["proof (state)\nthis:\n  partition_without elem P = P - {Y}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  partition_without elem P = P - {Y}", "have \"insert {elem} ?Q = P\""], ["proof (prove)\nusing this:\n  partition_without elem P = P - {Y}\n\ngoal (1 subgoal):\n 1. insert {elem} (partition_without elem P) = P", "using Y_singleton elem_eq_class'"], ["proof (prove)\nusing this:\n  partition_without elem P = P - {Y}\n  Y = {elem}\n  Y \\<in> P\n\ngoal (1 subgoal):\n 1. insert {elem} (partition_without elem P) = P", "by fast"], ["proof (state)\nthis:\n  insert {elem} (partition_without elem P) = P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  insert {elem} (partition_without elem P) = P", "show ?thesis"], ["proof (prove)\nusing this:\n  insert {elem} (partition_without elem P) = P\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "unfolding coarser_partitions_with_def"], ["proof (prove)\nusing this:\n  insert {elem} (partition_without elem P) = P\n\ngoal (1 subgoal):\n 1. P \\<in> insert (insert {elem} (partition_without elem P))\n             (insert_into_member elem (partition_without elem P) `\n              partition_without elem P)", "by auto"], ["proof (state)\nthis:\n  P \\<in> coarser_partitions_with elem (partition_without elem P)\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "assume True: \"\\<not> ?elem_eq \\<notin> ?Q\""], ["proof (state)\nthis:\n  \\<not> Y - {elem} \\<notin> partition_without elem P\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "hence Y': \"?elem_neq_classes \\<union> {?elem_eq} - {{}} = ?elem_neq_classes \\<union> {?elem_eq}\""], ["proof (prove)\nusing this:\n  \\<not> Y - {elem} \\<notin> partition_without elem P\n\ngoal (1 subgoal):\n 1. P - {Y} \\<union> {Y - {elem}} - {{}} = P - {Y} \\<union> {Y - {elem}}", "using no_empty_in_non_overlapping non_overlapping non_overlapping_without_is_non_overlapping"], ["proof (prove)\nusing this:\n  \\<not> Y - {elem} \\<notin> partition_without elem P\n  is_non_overlapping ?p \\<Longrightarrow> {} \\<notin> ?p\n  is_non_overlapping P\n  is_non_overlapping ?P \\<Longrightarrow>\n  is_non_overlapping (partition_without ?elem ?P)\n\ngoal (1 subgoal):\n 1. P - {Y} \\<union> {Y - {elem}} - {{}} = P - {Y} \\<union> {Y - {elem}}", "by force"], ["proof (state)\nthis:\n  P - {Y} \\<union> {Y - {elem}} - {{}} = P - {Y} \\<union> {Y - {elem}}\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "have \"insert_into_member elem ({?elem_eq} \\<union> ?elem_neq_classes) ?elem_eq = insert (?elem_eq \\<union> {elem}) (({?elem_eq} \\<union> ?elem_neq_classes) - {?elem_eq})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_into_member elem ({Y - {elem}} \\<union> (P - {Y})) (Y - {elem}) =\n    insert (Y - {elem} \\<union> {elem})\n     ({Y - {elem}} \\<union> (P - {Y}) - {Y - {elem}})", "unfolding insert_into_member_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Y - {elem} \\<union> {elem})\n     ({Y - {elem}} \\<union> (P - {Y}) - {Y - {elem}}) =\n    insert (Y - {elem} \\<union> {elem})\n     ({Y - {elem}} \\<union> (P - {Y}) - {Y - {elem}})", ".."], ["proof (state)\nthis:\n  insert_into_member elem ({Y - {elem}} \\<union> (P - {Y})) (Y - {elem}) =\n  insert (Y - {elem} \\<union> {elem})\n   ({Y - {elem}} \\<union> (P - {Y}) - {Y - {elem}})\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "also"], ["proof (state)\nthis:\n  insert_into_member elem ({Y - {elem}} \\<union> (P - {Y})) (Y - {elem}) =\n  insert (Y - {elem} \\<union> {elem})\n   ({Y - {elem}} \\<union> (P - {Y}) - {Y - {elem}})\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "have \"\\<dots> = ({} \\<union> ?elem_neq_classes) \\<union> {?elem_eq \\<union> {elem}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Y - {elem} \\<union> {elem})\n     ({Y - {elem}} \\<union> (P - {Y}) - {Y - {elem}}) =\n    {} \\<union> (P - {Y}) \\<union> {Y - {elem} \\<union> {elem}}", "using elem_neq_classes"], ["proof (prove)\nusing this:\n  P - {Y} - {Y - {elem}} = P - {Y}\n\ngoal (1 subgoal):\n 1. insert (Y - {elem} \\<union> {elem})\n     ({Y - {elem}} \\<union> (P - {Y}) - {Y - {elem}}) =\n    {} \\<union> (P - {Y}) \\<union> {Y - {elem} \\<union> {elem}}", "by force"], ["proof (state)\nthis:\n  insert (Y - {elem} \\<union> {elem})\n   ({Y - {elem}} \\<union> (P - {Y}) - {Y - {elem}}) =\n  {} \\<union> (P - {Y}) \\<union> {Y - {elem} \\<union> {elem}}\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "also"], ["proof (state)\nthis:\n  insert (Y - {elem} \\<union> {elem})\n   ({Y - {elem}} \\<union> (P - {Y}) - {Y - {elem}}) =\n  {} \\<union> (P - {Y}) \\<union> {Y - {elem} \\<union> {elem}}\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "have \"\\<dots> = ?elem_neq_classes \\<union> {Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<union> (P - {Y}) \\<union> {Y - {elem} \\<union> {elem}} =\n    P - {Y} \\<union> {Y}", "using elem_eq_class"], ["proof (prove)\nusing this:\n  elem \\<in> Y\n\ngoal (1 subgoal):\n 1. {} \\<union> (P - {Y}) \\<union> {Y - {elem} \\<union> {elem}} =\n    P - {Y} \\<union> {Y}", "by blast"], ["proof (state)\nthis:\n  {} \\<union> (P - {Y}) \\<union> {Y - {elem} \\<union> {elem}} =\n  P - {Y} \\<union> {Y}\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "finally"], ["proof (chain)\npicking this:\n  insert_into_member elem ({Y - {elem}} \\<union> (P - {Y})) (Y - {elem}) =\n  P - {Y} \\<union> {Y}", "have \"insert_into_member elem ({?elem_eq} \\<union> ?elem_neq_classes) ?elem_eq = ?elem_neq_classes \\<union> {Y}\""], ["proof (prove)\nusing this:\n  insert_into_member elem ({Y - {elem}} \\<union> (P - {Y})) (Y - {elem}) =\n  P - {Y} \\<union> {Y}\n\ngoal (1 subgoal):\n 1. insert_into_member elem ({Y - {elem}} \\<union> (P - {Y})) (Y - {elem}) =\n    P - {Y} \\<union> {Y}", "."], ["proof (state)\nthis:\n  insert_into_member elem ({Y - {elem}} \\<union> (P - {Y})) (Y - {elem}) =\n  P - {Y} \\<union> {Y}\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  insert_into_member elem ({Y - {elem}} \\<union> (P - {Y})) (Y - {elem}) =\n  P - {Y} \\<union> {Y}", "have \"?elem_neq_classes \\<union> {Y} = insert_into_member elem ?Q ?elem_eq\""], ["proof (prove)\nusing this:\n  insert_into_member elem ({Y - {elem}} \\<union> (P - {Y})) (Y - {elem}) =\n  P - {Y} \\<union> {Y}\n\ngoal (1 subgoal):\n 1. P - {Y} \\<union> {Y} =\n    insert_into_member elem (partition_without elem P) (Y - {elem})", "using Q_wrt_elem Y' partition_without_def"], ["proof (prove)\nusing this:\n  insert_into_member elem ({Y - {elem}} \\<union> (P - {Y})) (Y - {elem}) =\n  P - {Y} \\<union> {Y}\n  partition_without elem P = P - {Y} \\<union> {Y - {elem}} - {{}}\n  P - {Y} \\<union> {Y - {elem}} - {{}} = P - {Y} \\<union> {Y - {elem}}\n  partition_without ?elem ?P = (\\<lambda>X. X - {?elem}) ` ?P - {{}}\n\ngoal (1 subgoal):\n 1. P - {Y} \\<union> {Y} =\n    insert_into_member elem (partition_without elem P) (Y - {elem})", "by force"], ["proof (state)\nthis:\n  P - {Y} \\<union> {Y} =\n  insert_into_member elem (partition_without elem P) (Y - {elem})\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  P - {Y} \\<union> {Y} =\n  insert_into_member elem (partition_without elem P) (Y - {elem})", "have \"{Y} \\<union> ?elem_neq_classes \\<in> insert_into_member elem ?Q ` ?Q\""], ["proof (prove)\nusing this:\n  P - {Y} \\<union> {Y} =\n  insert_into_member elem (partition_without elem P) (Y - {elem})\n\ngoal (1 subgoal):\n 1. {Y} \\<union> (P - {Y})\n    \\<in> insert_into_member elem (partition_without elem P) `\n          partition_without elem P", "using True"], ["proof (prove)\nusing this:\n  P - {Y} \\<union> {Y} =\n  insert_into_member elem (partition_without elem P) (Y - {elem})\n  \\<not> Y - {elem} \\<notin> partition_without elem P\n\ngoal (1 subgoal):\n 1. {Y} \\<union> (P - {Y})\n    \\<in> insert_into_member elem (partition_without elem P) `\n          partition_without elem P", "by blast"], ["proof (state)\nthis:\n  {Y} \\<union> (P - {Y})\n  \\<in> insert_into_member elem (partition_without elem P) `\n        partition_without elem P\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  {Y} \\<union> (P - {Y})\n  \\<in> insert_into_member elem (partition_without elem P) `\n        partition_without elem P", "have \"{Y} \\<union> ?elem_neq_classes \\<in> coarser_partitions_with elem ?Q\""], ["proof (prove)\nusing this:\n  {Y} \\<union> (P - {Y})\n  \\<in> insert_into_member elem (partition_without elem P) `\n        partition_without elem P\n\ngoal (1 subgoal):\n 1. {Y} \\<union> (P - {Y})\n    \\<in> coarser_partitions_with elem (partition_without elem P)", "unfolding coarser_partitions_with_def"], ["proof (prove)\nusing this:\n  {Y} \\<union> (P - {Y})\n  \\<in> insert_into_member elem (partition_without elem P) `\n        partition_without elem P\n\ngoal (1 subgoal):\n 1. {Y} \\<union> (P - {Y})\n    \\<in> insert (insert {elem} (partition_without elem P))\n           (insert_into_member elem (partition_without elem P) `\n            partition_without elem P)", "by simp"], ["proof (state)\nthis:\n  {Y} \\<union> (P - {Y})\n  \\<in> coarser_partitions_with elem (partition_without elem P)\n\ngoal (1 subgoal):\n 1. \\<not> Y - {elem} \\<notin> partition_without elem P \\<Longrightarrow>\n    P \\<in> coarser_partitions_with elem (partition_without elem P)", "then"], ["proof (chain)\npicking this:\n  {Y} \\<union> (P - {Y})\n  \\<in> coarser_partitions_with elem (partition_without elem P)", "show ?thesis"], ["proof (prove)\nusing this:\n  {Y} \\<union> (P - {Y})\n  \\<in> coarser_partitions_with elem (partition_without elem P)\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "using P_wrt_elem"], ["proof (prove)\nusing this:\n  {Y} \\<union> (P - {Y})\n  \\<in> coarser_partitions_with elem (partition_without elem P)\n  P = P - {Y} \\<union> {Y}\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with elem (partition_without elem P)", "by simp"], ["proof (state)\nthis:\n  P \\<in> coarser_partitions_with elem (partition_without elem P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<in> coarser_partitions_with elem (partition_without elem P)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Given a set @{term Ps} of partitions, this is intended to compute the set of all coarser\n  partitions (given an extension element) of all partitions in @{term Ps}.\\<close>"], ["", "definition all_coarser_partitions_with :: \" 'a \\<Rightarrow> 'a set set set \\<Rightarrow> 'a set set set\"\n   where \"all_coarser_partitions_with elem Ps = \\<Union> (coarser_partitions_with elem ` Ps)\""], ["", "text \\<open>the list variant of @{const all_coarser_partitions_with}\\<close>"], ["", "definition all_coarser_partitions_with_list :: \" 'a \\<Rightarrow> 'a set list list \\<Rightarrow> 'a set list list\"\n  where \"all_coarser_partitions_with_list elem Ps = \n         concat (map (coarser_partitions_with_list elem) Ps)\""], ["", "text \\<open>@{const all_coarser_partitions_with_list} and @{const all_coarser_partitions_with} are equivalent.\\<close>"], ["", "lemma all_coarser_partitions_with_list_equivalence:\n  fixes elem::'a\n    and Ps::\"'a set list list\"\n  assumes distinct: \"\\<forall> P \\<in> set Ps . distinct P\"\n  shows \"set (map set (all_coarser_partitions_with_list elem Ps)) = all_coarser_partitions_with elem (set (map set Ps))\"\n    (is \"?list_expr = ?set_expr\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "have \"?list_expr = set (map set (concat (map (coarser_partitions_with_list elem) Ps)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    set (map set (concat (map (coarser_partitions_with_list elem) Ps)))", "unfolding all_coarser_partitions_with_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (concat (map (coarser_partitions_with_list elem) Ps))) =\n    set (map set (concat (map (coarser_partitions_with_list elem) Ps)))", ".."], ["proof (state)\nthis:\n  set (map set (all_coarser_partitions_with_list elem Ps)) =\n  set (map set (concat (map (coarser_partitions_with_list elem) Ps)))\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "also"], ["proof (state)\nthis:\n  set (map set (all_coarser_partitions_with_list elem Ps)) =\n  set (map set (concat (map (coarser_partitions_with_list elem) Ps)))\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "have \"\\<dots> = set ` (\\<Union> x \\<in> (coarser_partitions_with_list elem) ` (set Ps) . set x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (concat (map (coarser_partitions_with_list elem) Ps))) =\n    set ` \\<Union> (set ` coarser_partitions_with_list elem ` set Ps)", "by simp"], ["proof (state)\nthis:\n  set (map set (concat (map (coarser_partitions_with_list elem) Ps))) =\n  set ` \\<Union> (set ` coarser_partitions_with_list elem ` set Ps)\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "also"], ["proof (state)\nthis:\n  set (map set (concat (map (coarser_partitions_with_list elem) Ps))) =\n  set ` \\<Union> (set ` coarser_partitions_with_list elem ` set Ps)\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "have \"\\<dots> = set ` (\\<Union> x \\<in> { coarser_partitions_with_list elem P | P . P \\<in> set Ps } . set x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ` \\<Union> (set ` coarser_partitions_with_list elem ` set Ps) =\n    set `\n    \\<Union>\n     (set ` {coarser_partitions_with_list elem P |P. P \\<in> set Ps})", "by (simp add: image_Collect_mem)"], ["proof (state)\nthis:\n  set ` \\<Union> (set ` coarser_partitions_with_list elem ` set Ps) =\n  set `\n  \\<Union> (set ` {coarser_partitions_with_list elem P |P. P \\<in> set Ps})\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "also"], ["proof (state)\nthis:\n  set ` \\<Union> (set ` coarser_partitions_with_list elem ` set Ps) =\n  set `\n  \\<Union> (set ` {coarser_partitions_with_list elem P |P. P \\<in> set Ps})\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "have \"\\<dots> = \\<Union> { set (map set (coarser_partitions_with_list elem P)) | P . P \\<in> set Ps }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set `\n    \\<Union>\n     (set ` {coarser_partitions_with_list elem P |P. P \\<in> set Ps}) =\n    \\<Union>\n     {set (map set (coarser_partitions_with_list elem P)) |P.\n      P \\<in> set Ps}", "by auto"], ["proof (state)\nthis:\n  set `\n  \\<Union>\n   (set ` {coarser_partitions_with_list elem P |P. P \\<in> set Ps}) =\n  \\<Union>\n   {set (map set (coarser_partitions_with_list elem P)) |P. P \\<in> set Ps}\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "also"], ["proof (state)\nthis:\n  set `\n  \\<Union>\n   (set ` {coarser_partitions_with_list elem P |P. P \\<in> set Ps}) =\n  \\<Union>\n   {set (map set (coarser_partitions_with_list elem P)) |P. P \\<in> set Ps}\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "have \"\\<dots> = \\<Union> { coarser_partitions_with elem (set P) | P . P \\<in> set Ps }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {set (map set (coarser_partitions_with_list elem P)) |P.\n      P \\<in> set Ps} =\n    \\<Union> {coarser_partitions_with elem (set P) |P. P \\<in> set Ps}", "using distinct coarser_partitions_with_list_equivalence"], ["proof (prove)\nusing this:\n  \\<forall>P\\<in>set Ps. distinct P\n  distinct ?P \\<Longrightarrow>\n  set (map set (coarser_partitions_with_list ?new_el ?P)) =\n  coarser_partitions_with ?new_el (set ?P)\n\ngoal (1 subgoal):\n 1. \\<Union>\n     {set (map set (coarser_partitions_with_list elem P)) |P.\n      P \\<in> set Ps} =\n    \\<Union> {coarser_partitions_with elem (set P) |P. P \\<in> set Ps}", "by fast"], ["proof (state)\nthis:\n  \\<Union>\n   {set (map set (coarser_partitions_with_list elem P)) |P.\n    P \\<in> set Ps} =\n  \\<Union> {coarser_partitions_with elem (set P) |P. P \\<in> set Ps}\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "also"], ["proof (state)\nthis:\n  \\<Union>\n   {set (map set (coarser_partitions_with_list elem P)) |P.\n    P \\<in> set Ps} =\n  \\<Union> {coarser_partitions_with elem (set P) |P. P \\<in> set Ps}\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "have \"\\<dots> = \\<Union> (coarser_partitions_with elem ` (set ` (set Ps)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {coarser_partitions_with elem (set P) |P. P \\<in> set Ps} =\n    \\<Union> (coarser_partitions_with elem ` set ` set Ps)", "by (simp add: image_Collect_mem)"], ["proof (state)\nthis:\n  \\<Union> {coarser_partitions_with elem (set P) |P. P \\<in> set Ps} =\n  \\<Union> (coarser_partitions_with elem ` set ` set Ps)\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "also"], ["proof (state)\nthis:\n  \\<Union> {coarser_partitions_with elem (set P) |P. P \\<in> set Ps} =\n  \\<Union> (coarser_partitions_with elem ` set ` set Ps)\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "have \"\\<dots> = \\<Union> (coarser_partitions_with elem ` (set (map set Ps)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (coarser_partitions_with elem ` set ` set Ps) =\n    \\<Union> (coarser_partitions_with elem ` set (map set Ps))", "by simp"], ["proof (state)\nthis:\n  \\<Union> (coarser_partitions_with elem ` set ` set Ps) =\n  \\<Union> (coarser_partitions_with elem ` set (map set Ps))\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "also"], ["proof (state)\nthis:\n  \\<Union> (coarser_partitions_with elem ` set ` set Ps) =\n  \\<Union> (coarser_partitions_with elem ` set (map set Ps))\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "have \"\\<dots> = ?set_expr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (coarser_partitions_with elem ` set (map set Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "unfolding all_coarser_partitions_with_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (coarser_partitions_with elem ` set (map set Ps)) =\n    \\<Union> (coarser_partitions_with elem ` set (map set Ps))", ".."], ["proof (state)\nthis:\n  \\<Union> (coarser_partitions_with elem ` set (map set Ps)) =\n  all_coarser_partitions_with elem (set (map set Ps))\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "finally"], ["proof (chain)\npicking this:\n  set (map set (all_coarser_partitions_with_list elem Ps)) =\n  all_coarser_partitions_with elem (set (map set Ps))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (map set (all_coarser_partitions_with_list elem Ps)) =\n  all_coarser_partitions_with elem (set (map set Ps))\n\ngoal (1 subgoal):\n 1. set (map set (all_coarser_partitions_with_list elem Ps)) =\n    all_coarser_partitions_with elem (set (map set Ps))", "."], ["proof (state)\nthis:\n  set (map set (all_coarser_partitions_with_list elem Ps)) =\n  all_coarser_partitions_with elem (set (map set Ps))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>all partitions of a set (given as list) in form of a set\\<close>"], ["", "fun all_partitions_set :: \"'a list \\<Rightarrow> 'a set set set\"\n  where \n   \"all_partitions_set [] = {{}}\" |\n   \"all_partitions_set (e # X) = all_coarser_partitions_with e (all_partitions_set X)\""], ["", "text \\<open>all partitions of a set (given as list) in form of a list\\<close>"], ["", "fun all_partitions_list :: \"'a list \\<Rightarrow> 'a set list list\"\n  where \n   \"all_partitions_list [] = [[]]\" |\n   \"all_partitions_list (e # X) = all_coarser_partitions_with_list e (all_partitions_list X)\""], ["", "text \\<open>A list of partitions coarser than a given partition in list representation (constructed\n  with @{const coarser_partitions_with} is distinct under certain conditions.\\<close>"], ["", "lemma coarser_partitions_with_list_distinct:\n  fixes ps\n  assumes ps_coarser: \"ps \\<in> set (coarser_partitions_with_list x Q)\"\n      and distinct: \"distinct Q\"\n      and partition: \"is_non_overlapping (set Q)\"\n      and new: \"{x} \\<notin> set Q\"\n  shows \"distinct ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ps", "have \"set (coarser_partitions_with_list x Q) = insert ({x} # Q) (set (map (insert_into_member_list x Q) Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (coarser_partitions_with_list x Q) =\n    insert ({x} # Q) (set (map (insert_into_member_list x Q) Q))", "unfolding coarser_partitions_with_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (({x} # Q) # map (insert_into_member_list x Q) Q) =\n    insert ({x} # Q) (set (map (insert_into_member_list x Q) Q))", "by simp"], ["proof (state)\nthis:\n  set (coarser_partitions_with_list x Q) =\n  insert ({x} # Q) (set (map (insert_into_member_list x Q) Q))\n\ngoal (1 subgoal):\n 1. distinct ps", "with ps_coarser"], ["proof (chain)\npicking this:\n  ps \\<in> set (coarser_partitions_with_list x Q)\n  set (coarser_partitions_with_list x Q) =\n  insert ({x} # Q) (set (map (insert_into_member_list x Q) Q))", "have \"ps \\<in> insert ({x} # Q) (set (map ((insert_into_member_list x Q)) Q))\""], ["proof (prove)\nusing this:\n  ps \\<in> set (coarser_partitions_with_list x Q)\n  set (coarser_partitions_with_list x Q) =\n  insert ({x} # Q) (set (map (insert_into_member_list x Q) Q))\n\ngoal (1 subgoal):\n 1. ps \\<in> insert ({x} # Q) (set (map (insert_into_member_list x Q) Q))", "by blast"], ["proof (state)\nthis:\n  ps \\<in> insert ({x} # Q) (set (map (insert_into_member_list x Q) Q))\n\ngoal (1 subgoal):\n 1. distinct ps", "then"], ["proof (chain)\npicking this:\n  ps \\<in> insert ({x} # Q) (set (map (insert_into_member_list x Q) Q))", "show ?thesis"], ["proof (prove)\nusing this:\n  ps \\<in> insert ({x} # Q) (set (map (insert_into_member_list x Q) Q))\n\ngoal (1 subgoal):\n 1. distinct ps", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ps = {x} # Q \\<Longrightarrow> distinct ps\n 2. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "assume \"ps = {x} # Q\""], ["proof (state)\nthis:\n  ps = {x} # Q\n\ngoal (2 subgoals):\n 1. ps = {x} # Q \\<Longrightarrow> distinct ps\n 2. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "with distinct and new"], ["proof (chain)\npicking this:\n  distinct Q\n  {x} \\<notin> set Q\n  ps = {x} # Q", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct Q\n  {x} \\<notin> set Q\n  ps = {x} # Q\n\ngoal (1 subgoal):\n 1. distinct ps", "by simp"], ["proof (state)\nthis:\n  distinct ps\n\ngoal (1 subgoal):\n 1. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "assume \"ps \\<in> set (map (insert_into_member_list x Q) Q)\""], ["proof (state)\nthis:\n  ps \\<in> set (map (insert_into_member_list x Q) Q)\n\ngoal (1 subgoal):\n 1. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "then"], ["proof (chain)\npicking this:\n  ps \\<in> set (map (insert_into_member_list x Q) Q)", "obtain X where X_in_Q: \"X \\<in> set Q\" and ps_insert: \"ps = insert_into_member_list x Q X\""], ["proof (prove)\nusing this:\n  ps \\<in> set (map (insert_into_member_list x Q) Q)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> set Q; ps = insert_into_member_list x Q X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X \\<in> set Q\n  ps = insert_into_member_list x Q X\n\ngoal (1 subgoal):\n 1. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "from ps_insert"], ["proof (chain)\npicking this:\n  ps = insert_into_member_list x Q X", "have \"ps = (X \\<union> {x}) # (remove1 X Q)\""], ["proof (prove)\nusing this:\n  ps = insert_into_member_list x Q X\n\ngoal (1 subgoal):\n 1. ps = (X \\<union> {x}) # remove1 X Q", "unfolding insert_into_member_list_def"], ["proof (prove)\nusing this:\n  ps = (X \\<union> {x}) # remove1 X Q\n\ngoal (1 subgoal):\n 1. ps = (X \\<union> {x}) # remove1 X Q", "."], ["proof (state)\nthis:\n  ps = (X \\<union> {x}) # remove1 X Q\n\ngoal (1 subgoal):\n 1. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "also"], ["proof (state)\nthis:\n  ps = (X \\<union> {x}) # remove1 X Q\n\ngoal (1 subgoal):\n 1. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "have \"\\<dots> = (X \\<union> {x}) # (removeAll X Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<union> {x}) # remove1 X Q = (X \\<union> {x}) # removeAll X Q", "using distinct"], ["proof (prove)\nusing this:\n  distinct Q\n\ngoal (1 subgoal):\n 1. (X \\<union> {x}) # remove1 X Q = (X \\<union> {x}) # removeAll X Q", "by (metis distinct_remove1_removeAll)"], ["proof (state)\nthis:\n  (X \\<union> {x}) # remove1 X Q = (X \\<union> {x}) # removeAll X Q\n\ngoal (1 subgoal):\n 1. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "finally"], ["proof (chain)\npicking this:\n  ps = (X \\<union> {x}) # removeAll X Q", "have ps_list: \"ps = (X \\<union> {x}) # (removeAll X Q)\""], ["proof (prove)\nusing this:\n  ps = (X \\<union> {x}) # removeAll X Q\n\ngoal (1 subgoal):\n 1. ps = (X \\<union> {x}) # removeAll X Q", "."], ["proof (state)\nthis:\n  ps = (X \\<union> {x}) # removeAll X Q\n\ngoal (1 subgoal):\n 1. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "have distinct_tl: \"X \\<union> {x} \\<notin> set (removeAll X Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<union> {x} \\<notin> set (removeAll X Q)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<union> {x} \\<in> set (removeAll X Q) \\<Longrightarrow> False", "from partition"], ["proof (chain)\npicking this:\n  is_non_overlapping (set Q)", "have partition': \"\\<forall>x\\<in>set Q. \\<forall>y\\<in>set Q. (x \\<inter> y \\<noteq> {}) = (x = y)\""], ["proof (prove)\nusing this:\n  is_non_overlapping (set Q)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set Q.\n       \\<forall>y\\<in>set Q. (x \\<inter> y \\<noteq> {}) = (x = y)", "unfolding is_non_overlapping_def"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>set Q.\n     \\<forall>Y\\<in>set Q. (X \\<inter> Y \\<noteq> {}) = (X = Y)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set Q.\n       \\<forall>y\\<in>set Q. (x \\<inter> y \\<noteq> {}) = (x = y)", "."], ["proof (state)\nthis:\n  \\<forall>x\\<in>set Q.\n     \\<forall>y\\<in>set Q. (x \\<inter> y \\<noteq> {}) = (x = y)\n\ngoal (1 subgoal):\n 1. X \\<union> {x} \\<in> set (removeAll X Q) \\<Longrightarrow> False", "assume \"X \\<union> {x} \\<in> set (removeAll X Q)\""], ["proof (state)\nthis:\n  X \\<union> {x} \\<in> set (removeAll X Q)\n\ngoal (1 subgoal):\n 1. X \\<union> {x} \\<in> set (removeAll X Q) \\<Longrightarrow> False", "with X_in_Q partition"], ["proof (chain)\npicking this:\n  X \\<in> set Q\n  is_non_overlapping (set Q)\n  X \\<union> {x} \\<in> set (removeAll X Q)", "show False"], ["proof (prove)\nusing this:\n  X \\<in> set Q\n  is_non_overlapping (set Q)\n  X \\<union> {x} \\<in> set (removeAll X Q)\n\ngoal (1 subgoal):\n 1. False", "by (metis partition' inf_sup_absorb member_remove no_empty_in_non_overlapping remove_code(1))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X \\<union> {x} \\<notin> set (removeAll X Q)\n\ngoal (1 subgoal):\n 1. ps \\<in> set (map (insert_into_member_list x Q) Q) \\<Longrightarrow>\n    distinct ps", "with ps_list distinct"], ["proof (chain)\npicking this:\n  ps = (X \\<union> {x}) # removeAll X Q\n  distinct Q\n  X \\<union> {x} \\<notin> set (removeAll X Q)", "show ?thesis"], ["proof (prove)\nusing this:\n  ps = (X \\<union> {x}) # removeAll X Q\n  distinct Q\n  X \\<union> {x} \\<notin> set (removeAll X Q)\n\ngoal (1 subgoal):\n 1. distinct ps", "by (metis (full_types) distinct.simps(2) distinct_removeAll)"], ["proof (state)\nthis:\n  distinct ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct ps\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The classical definition @{const all_partitions} and the algorithmic (constructive) definition @{const all_partitions_list} are equivalent.\\<close>"], ["", "lemma all_partitions_equivalence':\n  fixes xs::\"'a list\"\n  shows \"distinct xs \\<Longrightarrow> \n         ((set (map set (all_partitions_list xs)) = \n          all_partitions (set xs)) \\<and> (\\<forall> ps \\<in> set (all_partitions_list xs) . distinct ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow>\n    set (map set (all_partitions_list xs)) = all_partitions (set xs) \\<and>\n    (\\<forall>ps\\<in>set (all_partitions_list xs). distinct ps)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    set (map set (all_partitions_list [])) = all_partitions (set []) \\<and>\n    Ball (set (all_partitions_list [])) distinct\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "case Nil"], ["proof (state)\nthis:\n  distinct []\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    set (map set (all_partitions_list [])) = all_partitions (set []) \\<and>\n    Ball (set (all_partitions_list [])) distinct\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "have \"set (map set (all_partitions_list [])) = all_partitions (set [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (all_partitions_list [])) = all_partitions (set [])", "unfolding List.set_simps(1) emptyset_part_emptyset3"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (all_partitions_list [])) = {{}}", "by simp"], ["proof (state)\nthis:\n  set (map set (all_partitions_list [])) = all_partitions (set [])\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    set (map set (all_partitions_list [])) = all_partitions (set []) \\<and>\n    Ball (set (all_partitions_list [])) distinct\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "(* Sledgehammer no longer seems to find this, maybe after we have added the \"distinct\" part to the theorem statement. *)"], ["proof (state)\nthis:\n  set (map set (all_partitions_list [])) = all_partitions (set [])\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    set (map set (all_partitions_list [])) = all_partitions (set []) \\<and>\n    Ball (set (all_partitions_list [])) distinct\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "moreover"], ["proof (state)\nthis:\n  set (map set (all_partitions_list [])) = all_partitions (set [])\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    set (map set (all_partitions_list [])) = all_partitions (set []) \\<and>\n    Ball (set (all_partitions_list [])) distinct\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "have \"\\<forall> ps \\<in> set (all_partitions_list []) . distinct ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps\\<in>set (all_partitions_list []). distinct ps", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>ps\\<in>set (all_partitions_list []). distinct ps\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    set (map set (all_partitions_list [])) = all_partitions (set []) \\<and>\n    Ball (set (all_partitions_list [])) distinct\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "ultimately"], ["proof (chain)\npicking this:\n  set (map set (all_partitions_list [])) = all_partitions (set [])\n  \\<forall>ps\\<in>set (all_partitions_list []). distinct ps", "show ?case"], ["proof (prove)\nusing this:\n  set (map set (all_partitions_list [])) = all_partitions (set [])\n  \\<forall>ps\\<in>set (all_partitions_list []). distinct ps\n\ngoal (1 subgoal):\n 1. set (map set (all_partitions_list [])) = all_partitions (set []) \\<and>\n    (\\<forall>a\\<in>set (all_partitions_list []). distinct a)", ".."], ["proof (state)\nthis:\n  set (map set (all_partitions_list [])) = all_partitions (set []) \\<and>\n  (\\<forall>a\\<in>set (all_partitions_list []). distinct a)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct xs \\<Longrightarrow>\n  set (map set (all_partitions_list xs)) = all_partitions (set xs) \\<and>\n  (\\<forall>a\\<in>set (all_partitions_list xs). distinct a)\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "from Cons.prems Cons.hyps"], ["proof (chain)\npicking this:\n  distinct (x # xs)\n  distinct xs \\<Longrightarrow>\n  set (map set (all_partitions_list xs)) = all_partitions (set xs) \\<and>\n  (\\<forall>a\\<in>set (all_partitions_list xs). distinct a)", "have hyp_equiv: \"set (map set (all_partitions_list xs)) = all_partitions (set xs)\""], ["proof (prove)\nusing this:\n  distinct (x # xs)\n  distinct xs \\<Longrightarrow>\n  set (map set (all_partitions_list xs)) = all_partitions (set xs) \\<and>\n  (\\<forall>a\\<in>set (all_partitions_list xs). distinct a)\n\ngoal (1 subgoal):\n 1. set (map set (all_partitions_list xs)) = all_partitions (set xs)", "by simp"], ["proof (state)\nthis:\n  set (map set (all_partitions_list xs)) = all_partitions (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "from Cons.prems Cons.hyps"], ["proof (chain)\npicking this:\n  distinct (x # xs)\n  distinct xs \\<Longrightarrow>\n  set (map set (all_partitions_list xs)) = all_partitions (set xs) \\<and>\n  (\\<forall>a\\<in>set (all_partitions_list xs). distinct a)", "have hyp_distinct: \"\\<forall> ps \\<in> set (all_partitions_list xs) . distinct ps\""], ["proof (prove)\nusing this:\n  distinct (x # xs)\n  distinct xs \\<Longrightarrow>\n  set (map set (all_partitions_list xs)) = all_partitions (set xs) \\<and>\n  (\\<forall>a\\<in>set (all_partitions_list xs). distinct a)\n\ngoal (1 subgoal):\n 1. \\<forall>ps\\<in>set (all_partitions_list xs). distinct ps", "by simp"], ["proof (state)\nthis:\n  \\<forall>ps\\<in>set (all_partitions_list xs). distinct ps\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "have distinct_xs: \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "using Cons.prems"], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. distinct xs", "by simp"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "have x_notin_xs: \"x \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs", "using Cons.prems"], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs", "by simp"], ["proof (state)\nthis:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "have \"set (map set (all_partitions_list (x # xs))) = all_partitions (set (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (all_partitions_list (x # xs))) =\n    all_partitions (set (x # xs))", "proof (rule equalitySubsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "(* -- {* case set \\<rightarrow> list *} *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "fix P::\"'a set set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "(* a partition *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "let ?P_without_x = \"partition_without x P\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "have P_partitions_exc_x: \"\\<Union> ?P_without_x = \\<Union> P - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (partition_without x P) = \\<Union> P - {x}", "using partition_without_covers"], ["proof (prove)\nusing this:\n  \\<Union> (partition_without ?elem ?P) = \\<Union> ?P - {?elem}\n\ngoal (1 subgoal):\n 1. \\<Union> (partition_without x P) = \\<Union> P - {x}", "."], ["proof (state)\nthis:\n  \\<Union> (partition_without x P) = \\<Union> P - {x}\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "assume \"P \\<in> all_partitions (set (x # xs))\""], ["proof (state)\nthis:\n  P \\<in> all_partitions (set (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "then"], ["proof (chain)\npicking this:\n  P \\<in> all_partitions (set (x # xs))", "have is_partition_of: \"P partitions (set (x # xs))\""], ["proof (prove)\nusing this:\n  P \\<in> all_partitions (set (x # xs))\n\ngoal (1 subgoal):\n 1. P partitions set (x # xs)", "unfolding all_partitions_def"], ["proof (prove)\nusing this:\n  P \\<in> {P. P partitions set (x # xs)}\n\ngoal (1 subgoal):\n 1. P partitions set (x # xs)", ".."], ["proof (state)\nthis:\n  P partitions set (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "then"], ["proof (chain)\npicking this:\n  P partitions set (x # xs)", "have is_non_overlapping: \"is_non_overlapping P\""], ["proof (prove)\nusing this:\n  P partitions set (x # xs)\n\ngoal (1 subgoal):\n 1. is_non_overlapping P", "unfolding is_partition_of_def"], ["proof (prove)\nusing this:\n  \\<Union> P = set (x # xs) \\<and> is_non_overlapping P\n\ngoal (1 subgoal):\n 1. is_non_overlapping P", "by simp"], ["proof (state)\nthis:\n  is_non_overlapping P\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "from is_partition_of"], ["proof (chain)\npicking this:\n  P partitions set (x # xs)", "have P_covers: \"\\<Union> P = set (x # xs)\""], ["proof (prove)\nusing this:\n  P partitions set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<Union> P = set (x # xs)", "unfolding is_partition_of_def"], ["proof (prove)\nusing this:\n  \\<Union> P = set (x # xs) \\<and> is_non_overlapping P\n\ngoal (1 subgoal):\n 1. \\<Union> P = set (x # xs)", "by simp"], ["proof (state)\nthis:\n  \\<Union> P = set (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "have \"?P_without_x partitions (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_without x P partitions set xs", "unfolding is_partition_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (partition_without x P) = set xs \\<and>\n    is_non_overlapping (partition_without x P)", "using is_non_overlapping non_overlapping_without_is_non_overlapping partition_without_covers P_covers x_notin_xs"], ["proof (prove)\nusing this:\n  is_non_overlapping P\n  is_non_overlapping ?P \\<Longrightarrow>\n  is_non_overlapping (partition_without ?elem ?P)\n  \\<Union> (partition_without ?elem ?P) = \\<Union> ?P - {?elem}\n  \\<Union> P = set (x # xs)\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<Union> (partition_without x P) = set xs \\<and>\n    is_non_overlapping (partition_without x P)", "by (metis Diff_insert_absorb List.set_simps(2))"], ["proof (state)\nthis:\n  partition_without x P partitions set xs\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "with hyp_equiv"], ["proof (chain)\npicking this:\n  set (map set (all_partitions_list xs)) = all_partitions (set xs)\n  partition_without x P partitions set xs", "have p_list: \"?P_without_x \\<in> set (map set (all_partitions_list xs))\""], ["proof (prove)\nusing this:\n  set (map set (all_partitions_list xs)) = all_partitions (set xs)\n  partition_without x P partitions set xs\n\ngoal (1 subgoal):\n 1. partition_without x P \\<in> set (map set (all_partitions_list xs))", "unfolding all_partitions_def"], ["proof (prove)\nusing this:\n  set (map set (all_partitions_list xs)) = {P. P partitions set xs}\n  partition_without x P partitions set xs\n\ngoal (1 subgoal):\n 1. partition_without x P \\<in> set (map set (all_partitions_list xs))", "by fast"], ["proof (state)\nthis:\n  partition_without x P \\<in> set (map set (all_partitions_list xs))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "have \"P \\<in> coarser_partitions_with x ?P_without_x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with x (partition_without x P)", "using coarser_partitions_inv_without is_non_overlapping P_covers"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_non_overlapping ?P; ?elem \\<in> \\<Union> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P \\<in> coarser_partitions_with ?elem\n                              (partition_without ?elem ?P)\n  is_non_overlapping P\n  \\<Union> P = set (x # xs)\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with x (partition_without x P)", "by (metis List.set_simps(2) insertI1)"], ["proof (state)\nthis:\n  P \\<in> coarser_partitions_with x (partition_without x P)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "then"], ["proof (chain)\npicking this:\n  P \\<in> coarser_partitions_with x (partition_without x P)", "have \"P \\<in> \\<Union> (coarser_partitions_with x ` set (map set (all_partitions_list xs)))\""], ["proof (prove)\nusing this:\n  P \\<in> coarser_partitions_with x (partition_without x P)\n\ngoal (1 subgoal):\n 1. P \\<in> \\<Union>\n             (coarser_partitions_with x `\n              set (map set (all_partitions_list xs)))", "using p_list"], ["proof (prove)\nusing this:\n  P \\<in> coarser_partitions_with x (partition_without x P)\n  partition_without x P \\<in> set (map set (all_partitions_list xs))\n\ngoal (1 subgoal):\n 1. P \\<in> \\<Union>\n             (coarser_partitions_with x `\n              set (map set (all_partitions_list xs)))", "by blast"], ["proof (state)\nthis:\n  P \\<in> \\<Union>\n           (coarser_partitions_with x `\n            set (map set (all_partitions_list xs)))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "then"], ["proof (chain)\npicking this:\n  P \\<in> \\<Union>\n           (coarser_partitions_with x `\n            set (map set (all_partitions_list xs)))", "have \"P \\<in> all_coarser_partitions_with x (set (map set (all_partitions_list xs)))\""], ["proof (prove)\nusing this:\n  P \\<in> \\<Union>\n           (coarser_partitions_with x `\n            set (map set (all_partitions_list xs)))\n\ngoal (1 subgoal):\n 1. P \\<in> all_coarser_partitions_with x\n             (set (map set (all_partitions_list xs)))", "unfolding all_coarser_partitions_with_def"], ["proof (prove)\nusing this:\n  P \\<in> \\<Union>\n           (coarser_partitions_with x `\n            set (map set (all_partitions_list xs)))\n\ngoal (1 subgoal):\n 1. P \\<in> \\<Union>\n             (coarser_partitions_with x `\n              set (map set (all_partitions_list xs)))", "by fast"], ["proof (state)\nthis:\n  P \\<in> all_coarser_partitions_with x\n           (set (map set (all_partitions_list xs)))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))\n 2. \\<And>xa.\n       xa \\<in> all_partitions (set (x # xs)) \\<Longrightarrow>\n       xa \\<in> set (map set (all_partitions_list (x # xs)))", "then"], ["proof (chain)\npicking this:\n  P \\<in> all_coarser_partitions_with x\n           (set (map set (all_partitions_list xs)))", "show \"P \\<in> set (map set (all_partitions_list (x # xs)))\""], ["proof (prove)\nusing this:\n  P \\<in> all_coarser_partitions_with x\n           (set (map set (all_partitions_list xs)))\n\ngoal (1 subgoal):\n 1. P \\<in> set (map set (all_partitions_list (x # xs)))", "using all_coarser_partitions_with_list_equivalence hyp_distinct"], ["proof (prove)\nusing this:\n  P \\<in> all_coarser_partitions_with x\n           (set (map set (all_partitions_list xs)))\n  \\<forall>P\\<in>set ?Ps. distinct P \\<Longrightarrow>\n  set (map set (all_coarser_partitions_with_list ?elem ?Ps)) =\n  all_coarser_partitions_with ?elem (set (map set ?Ps))\n  \\<forall>ps\\<in>set (all_partitions_list xs). distinct ps\n\ngoal (1 subgoal):\n 1. P \\<in> set (map set (all_partitions_list (x # xs)))", "by (metis all_partitions_list.simps(2))"], ["proof (state)\nthis:\n  P \\<in> set (map set (all_partitions_list (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "(* -- {* case list \\<rightarrow> set *} *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "fix P::\"'a set set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "(* a partition *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "assume P: \"P \\<in> set (map set (all_partitions_list (x # xs)))\""], ["proof (state)\nthis:\n  P \\<in> set (map set (all_partitions_list (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "have \"set (map set (all_partitions_list (x # xs))) = set (map set (all_coarser_partitions_with_list x (all_partitions_list xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (all_partitions_list (x # xs))) =\n    set (map set\n          (all_coarser_partitions_with_list x (all_partitions_list xs)))", "by simp"], ["proof (state)\nthis:\n  set (map set (all_partitions_list (x # xs))) =\n  set (map set\n        (all_coarser_partitions_with_list x (all_partitions_list xs)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "also"], ["proof (state)\nthis:\n  set (map set (all_partitions_list (x # xs))) =\n  set (map set\n        (all_coarser_partitions_with_list x (all_partitions_list xs)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "have \"\\<dots> = all_coarser_partitions_with x (set (map set (all_partitions_list xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set\n          (all_coarser_partitions_with_list x (all_partitions_list xs))) =\n    all_coarser_partitions_with x (set (map set (all_partitions_list xs)))", "using distinct_xs hyp_distinct all_coarser_partitions_with_list_equivalence"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>ps\\<in>set (all_partitions_list xs). distinct ps\n  \\<forall>P\\<in>set ?Ps. distinct P \\<Longrightarrow>\n  set (map set (all_coarser_partitions_with_list ?elem ?Ps)) =\n  all_coarser_partitions_with ?elem (set (map set ?Ps))\n\ngoal (1 subgoal):\n 1. set (map set\n          (all_coarser_partitions_with_list x (all_partitions_list xs))) =\n    all_coarser_partitions_with x (set (map set (all_partitions_list xs)))", "by fast"], ["proof (state)\nthis:\n  set (map set\n        (all_coarser_partitions_with_list x (all_partitions_list xs))) =\n  all_coarser_partitions_with x (set (map set (all_partitions_list xs)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "also"], ["proof (state)\nthis:\n  set (map set\n        (all_coarser_partitions_with_list x (all_partitions_list xs))) =\n  all_coarser_partitions_with x (set (map set (all_partitions_list xs)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "have \"\\<dots> = all_coarser_partitions_with x (all_partitions (set xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_coarser_partitions_with x (set (map set (all_partitions_list xs))) =\n    all_coarser_partitions_with x (all_partitions (set xs))", "using distinct_xs hyp_equiv"], ["proof (prove)\nusing this:\n  distinct xs\n  set (map set (all_partitions_list xs)) = all_partitions (set xs)\n\ngoal (1 subgoal):\n 1. all_coarser_partitions_with x (set (map set (all_partitions_list xs))) =\n    all_coarser_partitions_with x (all_partitions (set xs))", "by auto"], ["proof (state)\nthis:\n  all_coarser_partitions_with x (set (map set (all_partitions_list xs))) =\n  all_coarser_partitions_with x (all_partitions (set xs))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "finally"], ["proof (chain)\npicking this:\n  set (map set (all_partitions_list (x # xs))) =\n  all_coarser_partitions_with x (all_partitions (set xs))", "have P_set: \"set (map set (all_partitions_list (x # xs))) = all_coarser_partitions_with x (all_partitions (set xs))\""], ["proof (prove)\nusing this:\n  set (map set (all_partitions_list (x # xs))) =\n  all_coarser_partitions_with x (all_partitions (set xs))\n\ngoal (1 subgoal):\n 1. set (map set (all_partitions_list (x # xs))) =\n    all_coarser_partitions_with x (all_partitions (set xs))", "."], ["proof (state)\nthis:\n  set (map set (all_partitions_list (x # xs))) =\n  all_coarser_partitions_with x (all_partitions (set xs))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "with P"], ["proof (chain)\npicking this:\n  P \\<in> set (map set (all_partitions_list (x # xs)))\n  set (map set (all_partitions_list (x # xs))) =\n  all_coarser_partitions_with x (all_partitions (set xs))", "have \"P \\<in> all_coarser_partitions_with x (all_partitions (set xs))\""], ["proof (prove)\nusing this:\n  P \\<in> set (map set (all_partitions_list (x # xs)))\n  set (map set (all_partitions_list (x # xs))) =\n  all_coarser_partitions_with x (all_partitions (set xs))\n\ngoal (1 subgoal):\n 1. P \\<in> all_coarser_partitions_with x (all_partitions (set xs))", "by fast"], ["proof (state)\nthis:\n  P \\<in> all_coarser_partitions_with x (all_partitions (set xs))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "then"], ["proof (chain)\npicking this:\n  P \\<in> all_coarser_partitions_with x (all_partitions (set xs))", "have \"P \\<in> \\<Union> (coarser_partitions_with x ` (all_partitions (set xs)))\""], ["proof (prove)\nusing this:\n  P \\<in> all_coarser_partitions_with x (all_partitions (set xs))\n\ngoal (1 subgoal):\n 1. P \\<in> \\<Union> (coarser_partitions_with x ` all_partitions (set xs))", "unfolding all_coarser_partitions_with_def"], ["proof (prove)\nusing this:\n  P \\<in> \\<Union> (coarser_partitions_with x ` all_partitions (set xs))\n\ngoal (1 subgoal):\n 1. P \\<in> \\<Union> (coarser_partitions_with x ` all_partitions (set xs))", "."], ["proof (state)\nthis:\n  P \\<in> \\<Union> (coarser_partitions_with x ` all_partitions (set xs))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "then"], ["proof (chain)\npicking this:\n  P \\<in> \\<Union> (coarser_partitions_with x ` all_partitions (set xs))", "obtain Y\n      where P_in_Y: \"P \\<in> Y\"\n        and Y_coarser: \"Y \\<in> coarser_partitions_with x ` (all_partitions (set xs))\""], ["proof (prove)\nusing this:\n  P \\<in> \\<Union> (coarser_partitions_with x ` all_partitions (set xs))\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>P \\<in> Y;\n         Y \\<in> coarser_partitions_with x `\n                 all_partitions (set xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  P \\<in> Y\n  Y \\<in> coarser_partitions_with x ` all_partitions (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "from Y_coarser"], ["proof (chain)\npicking this:\n  Y \\<in> coarser_partitions_with x ` all_partitions (set xs)", "obtain Q\n      where Q_part_xs: \"Q \\<in> all_partitions (set xs)\"\n        and Y_coarser': \"Y = coarser_partitions_with x Q\""], ["proof (prove)\nusing this:\n  Y \\<in> coarser_partitions_with x ` all_partitions (set xs)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>Q \\<in> all_partitions (set xs);\n         Y = coarser_partitions_with x Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  Q \\<in> all_partitions (set xs)\n  Y = coarser_partitions_with x Q\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "from P_in_Y Y_coarser'"], ["proof (chain)\npicking this:\n  P \\<in> Y\n  Y = coarser_partitions_with x Q", "have P_wrt_Q: \"P \\<in> coarser_partitions_with x Q\""], ["proof (prove)\nusing this:\n  P \\<in> Y\n  Y = coarser_partitions_with x Q\n\ngoal (1 subgoal):\n 1. P \\<in> coarser_partitions_with x Q", "by fast"], ["proof (state)\nthis:\n  P \\<in> coarser_partitions_with x Q\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "then"], ["proof (chain)\npicking this:\n  P \\<in> coarser_partitions_with x Q", "have \"Q \\<in> all_partitions (set xs)\""], ["proof (prove)\nusing this:\n  P \\<in> coarser_partitions_with x Q\n\ngoal (1 subgoal):\n 1. Q \\<in> all_partitions (set xs)", "using Q_part_xs"], ["proof (prove)\nusing this:\n  P \\<in> coarser_partitions_with x Q\n  Q \\<in> all_partitions (set xs)\n\ngoal (1 subgoal):\n 1. Q \\<in> all_partitions (set xs)", "by simp"], ["proof (state)\nthis:\n  Q \\<in> all_partitions (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "then"], ["proof (chain)\npicking this:\n  Q \\<in> all_partitions (set xs)", "have \"Q partitions (set xs)\""], ["proof (prove)\nusing this:\n  Q \\<in> all_partitions (set xs)\n\ngoal (1 subgoal):\n 1. Q partitions set xs", "unfolding all_partitions_def"], ["proof (prove)\nusing this:\n  Q \\<in> {P. P partitions set xs}\n\ngoal (1 subgoal):\n 1. Q partitions set xs", ".."], ["proof (state)\nthis:\n  Q partitions set xs\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "then"], ["proof (chain)\npicking this:\n  Q partitions set xs", "have \"is_non_overlapping Q\" and Q_covers: \"\\<Union> Q = set xs\""], ["proof (prove)\nusing this:\n  Q partitions set xs\n\ngoal (1 subgoal):\n 1. is_non_overlapping Q &&& \\<Union> Q = set xs", "unfolding is_partition_of_def"], ["proof (prove)\nusing this:\n  \\<Union> Q = set xs \\<and> is_non_overlapping Q\n\ngoal (1 subgoal):\n 1. is_non_overlapping Q &&& \\<Union> Q = set xs", "by simp_all"], ["proof (state)\nthis:\n  is_non_overlapping Q\n  \\<Union> Q = set xs\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "then"], ["proof (chain)\npicking this:\n  is_non_overlapping Q\n  \\<Union> Q = set xs", "have P_partition: \"is_non_overlapping P\""], ["proof (prove)\nusing this:\n  is_non_overlapping Q\n  \\<Union> Q = set xs\n\ngoal (1 subgoal):\n 1. is_non_overlapping P", "using non_overlapping_extension3 P_wrt_Q x_notin_xs"], ["proof (prove)\nusing this:\n  is_non_overlapping Q\n  \\<Union> Q = set xs\n  \\<lbrakk>is_non_overlapping ?P; ?elem \\<notin> \\<Union> ?P;\n   ?Q \\<in> coarser_partitions_with ?elem ?P\\<rbrakk>\n  \\<Longrightarrow> is_non_overlapping ?Q\n  P \\<in> coarser_partitions_with x Q\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. is_non_overlapping P", "by fast"], ["proof (state)\nthis:\n  is_non_overlapping P\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "have \"\\<Union> P = set xs \\<union> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> P = set xs \\<union> {x}", "using Q_covers P_in_Y Y_coarser' coarser_partitions_covers"], ["proof (prove)\nusing this:\n  \\<Union> Q = set xs\n  P \\<in> Y\n  Y = coarser_partitions_with x Q\n  ?Q \\<in> coarser_partitions_with ?elem ?P \\<Longrightarrow>\n  \\<Union> ?Q = insert ?elem (\\<Union> ?P)\n\ngoal (1 subgoal):\n 1. \\<Union> P = set xs \\<union> {x}", "by fast"], ["proof (state)\nthis:\n  \\<Union> P = set xs \\<union> {x}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "then"], ["proof (chain)\npicking this:\n  \\<Union> P = set xs \\<union> {x}", "have \"\\<Union> P = set (x # xs)\""], ["proof (prove)\nusing this:\n  \\<Union> P = set xs \\<union> {x}\n\ngoal (1 subgoal):\n 1. \\<Union> P = set (x # xs)", "using x_notin_xs P_wrt_Q Q_covers"], ["proof (prove)\nusing this:\n  \\<Union> P = set xs \\<union> {x}\n  x \\<notin> set xs\n  P \\<in> coarser_partitions_with x Q\n  \\<Union> Q = set xs\n\ngoal (1 subgoal):\n 1. \\<Union> P = set (x # xs)", "by (metis List.set_simps(2) insert_is_Un sup_commute)"], ["proof (state)\nthis:\n  \\<Union> P = set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "then"], ["proof (chain)\npicking this:\n  \\<Union> P = set (x # xs)", "have \"P partitions (set (x # xs))\""], ["proof (prove)\nusing this:\n  \\<Union> P = set (x # xs)\n\ngoal (1 subgoal):\n 1. P partitions set (x # xs)", "using P_partition"], ["proof (prove)\nusing this:\n  \\<Union> P = set (x # xs)\n  is_non_overlapping P\n\ngoal (1 subgoal):\n 1. P partitions set (x # xs)", "unfolding is_partition_of_def"], ["proof (prove)\nusing this:\n  \\<Union> P = set (x # xs)\n  is_non_overlapping P\n\ngoal (1 subgoal):\n 1. \\<Union> P = set (x # xs) \\<and> is_non_overlapping P", "by blast"], ["proof (state)\nthis:\n  P partitions set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (map set\n                      (all_partitions_list (x # xs))) \\<Longrightarrow>\n       xa \\<in> all_partitions (set (x # xs))", "then"], ["proof (chain)\npicking this:\n  P partitions set (x # xs)", "show \"P \\<in> all_partitions (set (x # xs))\""], ["proof (prove)\nusing this:\n  P partitions set (x # xs)\n\ngoal (1 subgoal):\n 1. P \\<in> all_partitions (set (x # xs))", "unfolding all_partitions_def"], ["proof (prove)\nusing this:\n  P partitions set (x # xs)\n\ngoal (1 subgoal):\n 1. P \\<in> {P. P partitions set (x # xs)}", ".."], ["proof (state)\nthis:\n  P \\<in> all_partitions (set (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (map set (all_partitions_list (x # xs))) =\n  all_partitions (set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "moreover"], ["proof (state)\nthis:\n  set (map set (all_partitions_list (x # xs))) =\n  all_partitions (set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "have \"\\<forall> ps \\<in> set (all_partitions_list (x # xs)) . distinct ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps\\<in>set (all_partitions_list (x # xs)). distinct ps", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "fix ps::\"'a set list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "assume ps_part: \"ps \\<in> set (all_partitions_list (x # xs))\""], ["proof (state)\nthis:\n  ps \\<in> set (all_partitions_list (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "have \"set (all_partitions_list (x # xs)) = set (all_coarser_partitions_with_list x (all_partitions_list xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (all_partitions_list (x # xs)) =\n    set (all_coarser_partitions_with_list x (all_partitions_list xs))", "by simp"], ["proof (state)\nthis:\n  set (all_partitions_list (x # xs)) =\n  set (all_coarser_partitions_with_list x (all_partitions_list xs))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "also"], ["proof (state)\nthis:\n  set (all_partitions_list (x # xs)) =\n  set (all_coarser_partitions_with_list x (all_partitions_list xs))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "have \"\\<dots> = set (concat (map (coarser_partitions_with_list x) (all_partitions_list xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (all_coarser_partitions_with_list x (all_partitions_list xs)) =\n    set (concat\n          (map (coarser_partitions_with_list x) (all_partitions_list xs)))", "unfolding all_coarser_partitions_with_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (coarser_partitions_with_list x) (all_partitions_list xs))) =\n    set (concat\n          (map (coarser_partitions_with_list x) (all_partitions_list xs)))", ".."], ["proof (state)\nthis:\n  set (all_coarser_partitions_with_list x (all_partitions_list xs)) =\n  set (concat\n        (map (coarser_partitions_with_list x) (all_partitions_list xs)))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "also"], ["proof (state)\nthis:\n  set (all_coarser_partitions_with_list x (all_partitions_list xs)) =\n  set (concat\n        (map (coarser_partitions_with_list x) (all_partitions_list xs)))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "have \"\\<dots> = \\<Union> ((set \\<circ> (coarser_partitions_with_list x)) ` (set (all_partitions_list xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (coarser_partitions_with_list x) (all_partitions_list xs))) =\n    \\<Union>\n     ((set \\<circ> coarser_partitions_with_list x) `\n      set (all_partitions_list xs))", "by simp"], ["proof (state)\nthis:\n  set (concat\n        (map (coarser_partitions_with_list x) (all_partitions_list xs))) =\n  \\<Union>\n   ((set \\<circ> coarser_partitions_with_list x) `\n    set (all_partitions_list xs))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "finally"], ["proof (chain)\npicking this:\n  set (all_partitions_list (x # xs)) =\n  \\<Union>\n   ((set \\<circ> coarser_partitions_with_list x) `\n    set (all_partitions_list xs))", "have all_parts_unfolded: \"set (all_partitions_list (x # xs)) = \\<Union> ((set \\<circ> (coarser_partitions_with_list x)) ` (set (all_partitions_list xs)))\""], ["proof (prove)\nusing this:\n  set (all_partitions_list (x # xs)) =\n  \\<Union>\n   ((set \\<circ> coarser_partitions_with_list x) `\n    set (all_partitions_list xs))\n\ngoal (1 subgoal):\n 1. set (all_partitions_list (x # xs)) =\n    \\<Union>\n     ((set \\<circ> coarser_partitions_with_list x) `\n      set (all_partitions_list xs))", "."], ["proof (state)\nthis:\n  set (all_partitions_list (x # xs)) =\n  \\<Union>\n   ((set \\<circ> coarser_partitions_with_list x) `\n    set (all_partitions_list xs))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "(* \\<dots> = \\<Union> { set (coarser_partitions_with_list x ps) | ps . ps \\<in> set (all_partitions_list xs) }\n       (more readable, but less useful in proofs) *)"], ["proof (state)\nthis:\n  set (all_partitions_list (x # xs)) =\n  \\<Union>\n   ((set \\<circ> coarser_partitions_with_list x) `\n    set (all_partitions_list xs))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "with ps_part"], ["proof (chain)\npicking this:\n  ps \\<in> set (all_partitions_list (x # xs))\n  set (all_partitions_list (x # xs)) =\n  \\<Union>\n   ((set \\<circ> coarser_partitions_with_list x) `\n    set (all_partitions_list xs))", "obtain qs\n      where qs: \"qs \\<in> set (all_partitions_list xs)\"\n        and ps_coarser: \"ps \\<in> set (coarser_partitions_with_list x qs)\""], ["proof (prove)\nusing this:\n  ps \\<in> set (all_partitions_list (x # xs))\n  set (all_partitions_list (x # xs)) =\n  \\<Union>\n   ((set \\<circ> coarser_partitions_with_list x) `\n    set (all_partitions_list xs))\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> set (all_partitions_list xs);\n         ps \\<in> set (coarser_partitions_with_list x qs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using UnionE comp_def imageE"], ["proof (prove)\nusing this:\n  ps \\<in> set (all_partitions_list (x # xs))\n  set (all_partitions_list (x # xs)) =\n  \\<Union>\n   ((set \\<circ> coarser_partitions_with_list x) `\n    set (all_partitions_list xs))\n  \\<lbrakk>?A \\<in> \\<Union> ?C;\n   \\<And>X.\n      \\<lbrakk>?A \\<in> X; X \\<in> ?C\\<rbrakk> \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  \\<lbrakk>?b \\<in> ?f ` ?A;\n   \\<And>x.\n      \\<lbrakk>?b = ?f x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> set (all_partitions_list xs);\n         ps \\<in> set (coarser_partitions_with_list x qs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qs \\<in> set (all_partitions_list xs)\n  ps \\<in> set (coarser_partitions_with_list x qs)\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "from qs"], ["proof (chain)\npicking this:\n  qs \\<in> set (all_partitions_list xs)", "have \"set qs \\<in> set (map set (all_partitions_list (xs)))\""], ["proof (prove)\nusing this:\n  qs \\<in> set (all_partitions_list xs)\n\ngoal (1 subgoal):\n 1. set qs \\<in> set (map set (all_partitions_list xs))", "by simp"], ["proof (state)\nthis:\n  set qs \\<in> set (map set (all_partitions_list xs))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "with distinct_xs hyp_equiv"], ["proof (chain)\npicking this:\n  distinct xs\n  set (map set (all_partitions_list xs)) = all_partitions (set xs)\n  set qs \\<in> set (map set (all_partitions_list xs))", "have qs_hyp: \"set qs \\<in> all_partitions (set xs)\""], ["proof (prove)\nusing this:\n  distinct xs\n  set (map set (all_partitions_list xs)) = all_partitions (set xs)\n  set qs \\<in> set (map set (all_partitions_list xs))\n\ngoal (1 subgoal):\n 1. set qs \\<in> all_partitions (set xs)", "by fast"], ["proof (state)\nthis:\n  set qs \\<in> all_partitions (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "then"], ["proof (chain)\npicking this:\n  set qs \\<in> all_partitions (set xs)", "have qs_part: \"is_non_overlapping (set qs)\""], ["proof (prove)\nusing this:\n  set qs \\<in> all_partitions (set xs)\n\ngoal (1 subgoal):\n 1. is_non_overlapping (set qs)", "using all_partitions_def is_partition_of_def"], ["proof (prove)\nusing this:\n  set qs \\<in> all_partitions (set xs)\n  all_partitions ?A = {P. P partitions ?A}\n  ?P partitions ?A = (\\<Union> ?P = ?A \\<and> is_non_overlapping ?P)\n\ngoal (1 subgoal):\n 1. is_non_overlapping (set qs)", "by (metis mem_Collect_eq)"], ["proof (state)\nthis:\n  is_non_overlapping (set qs)\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "then"], ["proof (chain)\npicking this:\n  is_non_overlapping (set qs)", "have distinct_qs: \"distinct qs\""], ["proof (prove)\nusing this:\n  is_non_overlapping (set qs)\n\ngoal (1 subgoal):\n 1. distinct qs", "using qs distinct_xs hyp_distinct"], ["proof (prove)\nusing this:\n  is_non_overlapping (set qs)\n  qs \\<in> set (all_partitions_list xs)\n  distinct xs\n  \\<forall>ps\\<in>set (all_partitions_list xs). distinct ps\n\ngoal (1 subgoal):\n 1. distinct qs", "by fast"], ["proof (state)\nthis:\n  distinct qs\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "from Cons.prems"], ["proof (chain)\npicking this:\n  distinct (x # xs)", "have \"x \\<notin> set xs\""], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs", "by simp"], ["proof (state)\nthis:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "then"], ["proof (chain)\npicking this:\n  x \\<notin> set xs", "have new: \"{x} \\<notin> set qs\""], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. {x} \\<notin> set qs", "using qs_hyp"], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n  set qs \\<in> all_partitions (set xs)\n\ngoal (1 subgoal):\n 1. {x} \\<notin> set qs", "unfolding all_partitions_def is_partition_of_def"], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n  set qs \\<in> {P. \\<Union> P = set xs \\<and> is_non_overlapping P}\n\ngoal (1 subgoal):\n 1. {x} \\<notin> set qs", "by (metis (lifting, mono_tags) UnionI insertI1 mem_Collect_eq)"], ["proof (state)\nthis:\n  {x} \\<notin> set qs\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> set (all_partitions_list (x # xs)) \\<Longrightarrow>\n       distinct ps", "from ps_coarser distinct_qs qs_part new"], ["proof (chain)\npicking this:\n  ps \\<in> set (coarser_partitions_with_list x qs)\n  distinct qs\n  is_non_overlapping (set qs)\n  {x} \\<notin> set qs", "show \"distinct ps\""], ["proof (prove)\nusing this:\n  ps \\<in> set (coarser_partitions_with_list x qs)\n  distinct qs\n  is_non_overlapping (set qs)\n  {x} \\<notin> set qs\n\ngoal (1 subgoal):\n 1. distinct ps", "by (rule coarser_partitions_with_list_distinct)"], ["proof (state)\nthis:\n  distinct ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ps\\<in>set (all_partitions_list (x # xs)). distinct ps\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (map set (all_partitions_list xs)) =\n                all_partitions (set xs) \\<and>\n                Ball (set (all_partitions_list xs)) distinct;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (map set (all_partitions_list (a # xs))) =\n                         all_partitions (set (a # xs)) \\<and>\n                         Ball (set (all_partitions_list (a # xs))) distinct", "ultimately"], ["proof (chain)\npicking this:\n  set (map set (all_partitions_list (x # xs))) =\n  all_partitions (set (x # xs))\n  \\<forall>ps\\<in>set (all_partitions_list (x # xs)). distinct ps", "show ?case"], ["proof (prove)\nusing this:\n  set (map set (all_partitions_list (x # xs))) =\n  all_partitions (set (x # xs))\n  \\<forall>ps\\<in>set (all_partitions_list (x # xs)). distinct ps\n\ngoal (1 subgoal):\n 1. set (map set (all_partitions_list (x # xs))) =\n    all_partitions (set (x # xs)) \\<and>\n    (\\<forall>a\\<in>set (all_partitions_list (x # xs)). distinct a)", ".."], ["proof (state)\nthis:\n  set (map set (all_partitions_list (x # xs))) =\n  all_partitions (set (x # xs)) \\<and>\n  (\\<forall>a\\<in>set (all_partitions_list (x # xs)). distinct a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The classical definition @{const all_partitions} and the algorithmic (constructive) definition @{const all_partitions_list} are equivalent.  This is a front-end theorem derived from\n  @{thm all_partitions_equivalence'}; it does not make the auxiliary statement about partitions\n  being distinct lists.\\<close>"], ["", "theorem all_partitions_paper_equiv_alg:\n  fixes xs::\"'a list\"\n  shows \"distinct xs \\<Longrightarrow> set (map set (all_partitions_list xs)) = all_partitions (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow>\n    set (map set (all_partitions_list xs)) = all_partitions (set xs)", "using all_partitions_equivalence'"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow>\n  set (map set (all_partitions_list ?xs)) = all_partitions (set ?xs) \\<and>\n  (\\<forall>ps\\<in>set (all_partitions_list ?xs). distinct ps)\n\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow>\n    set (map set (all_partitions_list xs)) = all_partitions (set xs)", "by blast"], ["", "text \\<open>The function that we will be using in practice to compute all partitions of a set,\n  a set-oriented front-end to @{const all_partitions_list}\\<close>"], ["", "definition all_partitions_alg :: \"'a::linorder set \\<Rightarrow> 'a set list list\"\n  where \"all_partitions_alg X = all_partitions_list (sorted_list_of_set X)\""], ["", "end"]]}