{"file_name": "/home/qj213/afp-2021-10-22/thys/Vickrey_Clarke_Groves/RelationProperties.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Vickrey_Clarke_Groves", "problem_names": ["lemma injflip: \"inj_on flip A\"", "lemma lm01: \"card P = card (P^-1)\"", "lemma cardinalityOneTheElemIdentity: \"(card X = 1) = (X={the_elem X})\"", "lemma lm02: \"trivial X = (X={} \\<or> card X=1)\"", "lemma lm03: \"trivial P = trivial (P^-1)\"", "lemma restrictedRange: \"Range (P||X) = P``X\"", "lemma doubleRestriction:  \"((P || X) || Y) = (P || (X \\<inter> Y))\"", "lemma restrictedDomain: \"Domain (R||X) = Domain R \\<inter> X\"", "lemma subrel_runiq: \n  assumes \"runiq Q\" \"P \\<subseteq> Q\" \n  shows \"runiq P\"", "lemma rightUniqueInjectiveOnFirstImplication: \n  assumes \"runiq P\" \n  shows \"inj_on fst P\"", "lemma runiq_alt: \"runiq R \\<longleftrightarrow> (\\<forall> x . trivial (R `` {x}))\"", "lemma runiq_wrt_eval_rel: \"runiq R = (\\<forall>x . R `` {x} \\<subseteq> {R ,, x})\"", "lemma rightUniquePair: \n  assumes \"runiq f\" \n  assumes \"(x,y)\\<in>f\" \n  shows \"y=f,,x\"", "lemma runiq_basic: \"runiq R \\<longleftrightarrow> (\\<forall> x y y' . (x, y) \\<in> R \\<and> (x, y') \\<in> R \\<longrightarrow> y = y')\"", "lemma rightUniqueFunctionAfterInverse: \n  assumes \"runiq f\" \n  shows \"f``(f^-1``Y) \\<subseteq> Y\"", "lemma lm04: \n  assumes \"runiq f\" \"y1 \\<in> Range f\" \n  shows \"(f^-1 `` {y1} \\<inter> f^-1 `` {y2} \\<noteq> {}) = (f^-1``{y1}=f^-1``{y2})\"", "lemma converse_Image: \n  assumes runiq: \"runiq R\"\n      and runiq_conv: \"runiq (R^-1)\"\n  shows \"(R^-1) `` R `` X \\<subseteq> X\"", "lemma lm05: \n  assumes \"inj_on fst P\" \n  shows \"runiq P\"", "lemma rightUniqueInjectiveOnFirst: \"(runiq P) = (inj_on fst P)\"", "lemma disj_Un_runiq: \n  assumes \"runiq P\" \"runiq Q\" \"(Domain P) \\<inter> (Domain Q) = {}\" \n  shows \"runiq (P \\<union> Q)\"", "lemma runiq_paste1: \n  assumes \"runiq Q\" \"runiq (P outside Domain Q)\" \n  shows \"runiq (P +* Q)\"", "lemma rightUniqueRestrictedGraph: \"runiq {(x,f x)| x. P x}\"", "lemma rightUniqueSetCardinality: \n  assumes \"x \\<in> Domain R\" \"runiq R\" \n  shows \"card (R``{x})=1\"", "lemma Image_runiq_eq_eval: \n  assumes \"x \\<in> Domain R\" \"runiq R\" \n  shows \"R `` {x} = {R ,, x}\"", "lemma lm06: \n  assumes \"trivial f\" \n  shows \"runiq f\"", "lemma runiq_emptyrel: \"runiq {}\"", "lemma runiq_wrt_ex1:\n  \"runiq R \\<longleftrightarrow> (\\<forall> a \\<in> Domain R . \\<exists>! b . (a, b) \\<in> R)\"", "lemma eval_runiq_rel:\n  assumes domain: \"x \\<in> Domain R\"\n      and runiq: \"runiq R\" \n  shows \"(x, R,,x) \\<in> R\"", "lemma eval_runiq_in_Range:\n  assumes \"runiq R\"\n      and \"a \\<in> Domain R\"\n  shows \"R ,, a \\<in> Range R\"", "lemma converse_Image_singleton_Domain:\n  assumes runiq: \"runiq R\"\n      and runiq_conv: \"runiq (R\\<inverse>)\"\n      and domain: \"x \\<in> Domain R\"\n  shows \"R\\<inverse> `` R `` {x} = {x}\"", "lemma disj_Domain_imp_disj_Image: \n  assumes \"Domain R \\<inter> X \\<inter> Y = {}\" \n  assumes \"runiq R\"\n      and \"runiq (R\\<inverse>)\"\n  shows \"(R `` X) \\<inter> (R `` Y) = {}\"", "lemma runiq_converse_paste_singleton: \n  assumes \"runiq (P^-1)\" \"y\\<notin>(Range P)\" \n  shows \"runiq ((P +* {(x,y)})\\<inverse>)\" \n  (is \"?u (?P^-1)\")", "lemma Image_within_domain': \n  fixes x R \n  shows \"(x \\<in> Domain R) = (R `` {x} \\<noteq> {})\""], "translations": [["", "lemma injflip: \"inj_on flip A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on flip A", "by (metis flip_flip inj_on_def)"], ["", "lemma lm01: \"card P = card (P^-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card P = card (P\\<inverse>)", "using card_image flip_conv injflip"], ["proof (prove)\nusing this:\n  inj_on ?f ?A \\<Longrightarrow> card (?f ` ?A) = card ?A\n  flip ` ?R = ?R\\<inverse>\n  inj_on flip ?A\n\ngoal (1 subgoal):\n 1. card P = card (P\\<inverse>)", "by metis"], ["", "lemma cardinalityOneTheElemIdentity: \"(card X = 1) = (X={the_elem X})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card X = 1) = (X = {the_elem X})", "by (metis One_nat_def card_Suc_eq card.empty empty_iff the_elem_eq)"], ["", "lemma lm02: \"trivial X = (X={} \\<or> card X=1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trivial X = (X = {} \\<or> card X = 1)", "using cardinalityOneTheElemIdentity order_refl subset_singletonD trivial_def trivial_empty"], ["proof (prove)\nusing this:\n  (card ?X = 1) = (?X = {the_elem ?X})\n  ?x \\<le> ?x\n  ?A \\<subseteq> {?x} \\<Longrightarrow> ?A = {} \\<or> ?A = {?x}\n  trivial ?x = (?x \\<subseteq> {the_elem ?x})\n  trivial {}\n\ngoal (1 subgoal):\n 1. trivial X = (X = {} \\<or> card X = 1)", "by (metis(no_types))"], ["", "lemma lm03: \"trivial P = trivial (P^-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trivial P = trivial (P\\<inverse>)", "using trivial_def subset_singletonD  subset_refl subset_insertI cardinalityOneTheElemIdentity converse_inject\n        converse_empty lm01"], ["proof (prove)\nusing this:\n  trivial ?x = (?x \\<subseteq> {the_elem ?x})\n  ?A \\<subseteq> {?x} \\<Longrightarrow> ?A = {} \\<or> ?A = {?x}\n  ?A \\<subseteq> ?A\n  ?B \\<subseteq> insert ?a ?B\n  (card ?X = 1) = (?X = {the_elem ?X})\n  (?r\\<inverse> = ?s\\<inverse>) = (?r = ?s)\n  {}\\<inverse> = {}\n  card ?P = card (?P\\<inverse>)\n\ngoal (1 subgoal):\n 1. trivial P = trivial (P\\<inverse>)", "by metis"], ["", "(* The range of P restricted to X is equal to the image of X through P *)"], ["", "lemma restrictedRange: \"Range (P||X) = P``X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (P || X) = P `` X", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (X \\<times> Range P \\<inter> P) = P `` X", "by blast"], ["", "lemma doubleRestriction:  \"((P || X) || Y) = (P || (X \\<inter> Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P || X) || Y = P || (X \\<inter> Y)", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<times> Range (X \\<times> Range P \\<inter> P) \\<inter>\n    (X \\<times> Range P \\<inter> P) =\n    (X \\<inter> Y) \\<times> Range P \\<inter> P", "by fast"], ["", "lemma restrictedDomain: \"Domain (R||X) = Domain R \\<inter> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (R || X) = Domain R \\<inter> X", "using restrict_def"], ["proof (prove)\nusing this:\n  ?R || ?X = ?X \\<times> Range ?R \\<inter> ?R\n\ngoal (1 subgoal):\n 1. Domain (R || X) = Domain R \\<inter> X", "by fastforce"], ["", "text \\<open>A subrelation of a right-unique relation is right-unique.\\<close>"], ["", "lemma subrel_runiq: \n  assumes \"runiq Q\" \"P \\<subseteq> Q\" \n  shows \"runiq P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq P", "using assms runiq_def"], ["proof (prove)\nusing this:\n  runiq Q\n  P \\<subseteq> Q\n  runiq ?R = (\\<forall>X. trivial X \\<longrightarrow> trivial (?R `` X))\n\ngoal (1 subgoal):\n 1. runiq P", "by (metis Image_mono subsetI trivial_subset)"], ["", "lemma rightUniqueInjectiveOnFirstImplication: \n  assumes \"runiq P\" \n  shows \"inj_on fst P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fst P", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>P.\n       \\<forall>y\\<in>P. fst x = fst y \\<longrightarrow> x = y", "using assms runiq_def trivial_def trivial_imp_no_distinct \n        the_elem_eq surjective_pairing subsetI Image_singleton_iff"], ["proof (prove)\nusing this:\n  runiq P\n  runiq ?R = (\\<forall>X. trivial X \\<longrightarrow> trivial (?R `` X))\n  trivial ?x = (?x \\<subseteq> {the_elem ?x})\n  \\<lbrakk>trivial ?X; ?x \\<in> ?X; ?y \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  the_elem {?x} = ?x\n  ?t = (fst ?t, snd ?t)\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B) \\<Longrightarrow>\n  ?A \\<subseteq> ?B\n  (?b \\<in> ?r `` {?a}) = ((?a, ?b) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>P.\n       \\<forall>y\\<in>P. fst x = fst y \\<longrightarrow> x = y", "by (metis(no_types))"], ["", "text \\<open>alternative characterization of right-uniqueness: the image of a singleton set is\n   @{const trivial}, i.e.\\ an empty or a singleton set.\\<close>"], ["", "lemma runiq_alt: \"runiq R \\<longleftrightarrow> (\\<forall> x . trivial (R `` {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq R = (\\<forall>x. trivial (R `` {x}))", "unfolding runiq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>X. trivial X \\<longrightarrow> trivial (R `` X)) =\n    (\\<forall>x. trivial (R `` {x}))", "by (metis Image_empty2 trivial_empty_or_singleton trivial_singleton)"], ["", "text \\<open>an alternative definition of right-uniqueness in terms of @{const eval_rel}\\<close>"], ["", "(* Note that R `` {x} is the image of {x} under R and R ,, x gives you an element y such that R x y. Because of right-uniqueness in this case the element is determined, otherwise it may be undetermined *)"], ["", "lemma runiq_wrt_eval_rel: \"runiq R = (\\<forall>x . R `` {x} \\<subseteq> {R ,, x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq R = (\\<forall>x. R `` {x} \\<subseteq> {R ,, x})", "by (metis eval_rel.simps runiq_alt trivial_def)"], ["", "lemma rightUniquePair: \n  assumes \"runiq f\" \n  assumes \"(x,y)\\<in>f\" \n  shows \"y=f,,x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = f ,, x", "using assms runiq_wrt_eval_rel subset_singletonD Image_singleton_iff equals0D singletonE"], ["proof (prove)\nusing this:\n  runiq f\n  (x, y) \\<in> f\n  runiq ?R = (\\<forall>x. ?R `` {x} \\<subseteq> {?R ,, x})\n  ?A \\<subseteq> {?x} \\<Longrightarrow> ?A = {} \\<or> ?A = {?x}\n  (?b \\<in> ?r `` {?a}) = ((?a, ?b) \\<in> ?r)\n  ?A = {} \\<Longrightarrow> ?a \\<notin> ?A\n  \\<lbrakk>?b \\<in> {?a}; ?b = ?a \\<Longrightarrow> PROP ?W\\<rbrakk>\n  \\<Longrightarrow> PROP ?W\n\ngoal (1 subgoal):\n 1. y = f ,, x", "by fast"], ["", "lemma runiq_basic: \"runiq R \\<longleftrightarrow> (\\<forall> x y y' . (x, y) \\<in> R \\<and> (x, y') \\<in> R \\<longrightarrow> y = y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq R =\n    (\\<forall>x y y'.\n        (x, y) \\<in> R \\<and> (x, y') \\<in> R \\<longrightarrow> y = y')", "unfolding runiq_alt trivial_same"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. \\<forall>x1\\<in>R `` {x}. Ball (R `` {x}) ((=) x1)) =\n    (\\<forall>x y y'.\n        (x, y) \\<in> R \\<and> (x, y') \\<in> R \\<longrightarrow> y = y')", "by blast"], ["", "lemma rightUniqueFunctionAfterInverse: \n  assumes \"runiq f\" \n  shows \"f``(f^-1``Y) \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f `` f\\<inverse> `` Y \\<subseteq> Y", "using assms runiq_basic ImageE converse_iff subsetI"], ["proof (prove)\nusing this:\n  runiq f\n  runiq ?R =\n  (\\<forall>x y y'.\n      (x, y) \\<in> ?R \\<and> (x, y') \\<in> ?R \\<longrightarrow> y = y')\n  \\<lbrakk>?b \\<in> ?r `` ?A;\n   \\<And>x.\n      \\<lbrakk>(x, ?b) \\<in> ?r; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  ((?a, ?b) \\<in> ?r\\<inverse>) = ((?b, ?a) \\<in> ?r)\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<in> ?B) \\<Longrightarrow>\n  ?A \\<subseteq> ?B\n\ngoal (1 subgoal):\n 1. f `` f\\<inverse> `` Y \\<subseteq> Y", "by (metis(no_types))"], ["", "lemma lm04: \n  assumes \"runiq f\" \"y1 \\<in> Range f\" \n  shows \"(f^-1 `` {y1} \\<inter> f^-1 `` {y2} \\<noteq> {}) = (f^-1``{y1}=f^-1``{y2})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f\\<inverse> `` {y1} \\<inter> f\\<inverse> `` {y2} \\<noteq> {}) =\n    (f\\<inverse> `` {y1} = f\\<inverse> `` {y2})", "using assms rightUniqueFunctionAfterInverse"], ["proof (prove)\nusing this:\n  runiq f\n  y1 \\<in> Range f\n  runiq ?f \\<Longrightarrow> ?f `` ?f\\<inverse> `` ?Y \\<subseteq> ?Y\n\ngoal (1 subgoal):\n 1. (f\\<inverse> `` {y1} \\<inter> f\\<inverse> `` {y2} \\<noteq> {}) =\n    (f\\<inverse> `` {y1} = f\\<inverse> `` {y2})", "by fast"], ["", "lemma converse_Image: \n  assumes runiq: \"runiq R\"\n      and runiq_conv: \"runiq (R^-1)\"\n  shows \"(R^-1) `` R `` X \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<inverse> `` R `` X \\<subseteq> X", "using assms"], ["proof (prove)\nusing this:\n  runiq R\n  runiq (R\\<inverse>)\n\ngoal (1 subgoal):\n 1. R\\<inverse> `` R `` X \\<subseteq> X", "by (metis converse_converse rightUniqueFunctionAfterInverse)"], ["", "lemma lm05: \n  assumes \"inj_on fst P\" \n  shows \"runiq P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq P", "unfolding runiq_basic"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y y'.\n       (x, y) \\<in> P \\<and> (x, y') \\<in> P \\<longrightarrow> y = y'", "using assms fst_conv inj_on_def old.prod.inject"], ["proof (prove)\nusing this:\n  inj_on fst P\n  fst (?x1.0, ?x2.0) = ?x1.0\n  inj_on ?f ?A =\n  (\\<forall>x\\<in>?A.\n      \\<forall>y\\<in>?A. ?f x = ?f y \\<longrightarrow> x = y)\n  ((?a, ?b) = (?a', ?b')) = (?a = ?a' \\<and> ?b = ?b')\n\ngoal (1 subgoal):\n 1. \\<forall>x y y'.\n       (x, y) \\<in> P \\<and> (x, y') \\<in> P \\<longrightarrow> y = y'", "by (metis(no_types))"], ["", "(* Another characterization of runiq, relating the set theoretical expression P to the injectivity of the function fst applied to P *)"], ["", "lemma rightUniqueInjectiveOnFirst: \"(runiq P) = (inj_on fst P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq P = inj_on fst P", "using rightUniqueInjectiveOnFirstImplication lm05"], ["proof (prove)\nusing this:\n  runiq ?P \\<Longrightarrow> inj_on fst ?P\n  inj_on fst ?P \\<Longrightarrow> runiq ?P\n\ngoal (1 subgoal):\n 1. runiq P = inj_on fst P", "by blast"], ["", "lemma disj_Un_runiq: \n  assumes \"runiq P\" \"runiq Q\" \"(Domain P) \\<inter> (Domain Q) = {}\" \n  shows \"runiq (P \\<union> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq (P \\<union> Q)", "using assms rightUniqueInjectiveOnFirst fst_eq_Domain injection_union"], ["proof (prove)\nusing this:\n  runiq P\n  runiq Q\n  Domain P \\<inter> Domain Q = {}\n  runiq ?P = inj_on fst ?P\n  fst ` ?R = Domain ?R\n  \\<lbrakk>inj_on ?f ?A; inj_on ?f ?B;\n   ?f ` ?A \\<inter> ?f ` ?B = {}\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f (?A \\<union> ?B)\n\ngoal (1 subgoal):\n 1. runiq (P \\<union> Q)", "by metis"], ["", "lemma runiq_paste1: \n  assumes \"runiq Q\" \"runiq (P outside Domain Q)\" \n  shows \"runiq (P +* Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq (P +* Q)", "unfolding paste_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq (P outside Domain Q \\<union> Q)", "using assms disj_Un_runiq Diff_disjoint Un_commute outside_reduces_domain"], ["proof (prove)\nusing this:\n  runiq Q\n  runiq (P outside Domain Q)\n  \\<lbrakk>runiq ?P; runiq ?Q; Domain ?P \\<inter> Domain ?Q = {}\\<rbrakk>\n  \\<Longrightarrow> runiq (?P \\<union> ?Q)\n  ?A \\<inter> (?B - ?A) = {}\n  ?A \\<union> ?B = ?B \\<union> ?A\n  Domain (?P outside ?X) = Domain ?P - ?X\n\ngoal (1 subgoal):\n 1. runiq (P outside Domain Q \\<union> Q)", "by (metis (poly_guards_query))"], ["", "corollary runiq_paste2: \n  assumes \"runiq Q\" \"runiq P\" \n  shows \"runiq (P +* Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq (P +* Q)", "using assms runiq_paste1 subrel_runiq Diff_subset Outside_def"], ["proof (prove)\nusing this:\n  runiq Q\n  runiq P\n  \\<lbrakk>runiq ?Q; runiq (?P outside Domain ?Q)\\<rbrakk>\n  \\<Longrightarrow> runiq (?P +* ?Q)\n  \\<lbrakk>runiq ?Q; ?P \\<subseteq> ?Q\\<rbrakk> \\<Longrightarrow> runiq ?P\n  ?A - ?B \\<subseteq> ?A\n  ?R outside ?X = ?R - ?X \\<times> Range ?R\n\ngoal (1 subgoal):\n 1. runiq (P +* Q)", "by (metis)"], ["", "(* Let f be a function, then its graph {(x, f x)} and all its restrictions such that P x for arbitrary P are right-unique. *)"], ["", "lemma rightUniqueRestrictedGraph: \"runiq {(x,f x)| x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq {(x, f x) |x. P x}", "unfolding runiq_basic"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y y'.\n       (x, y) \\<in> {(x, f x) |x. P x} \\<and>\n       (x, y') \\<in> {(x, f x) |x. P x} \\<longrightarrow>\n       y = y'", "by fast"], ["", "lemma rightUniqueSetCardinality: \n  assumes \"x \\<in> Domain R\" \"runiq R\" \n  shows \"card (R``{x})=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (R `` {x}) = 1", "using assms  lm02 DomainE Image_singleton_iff empty_iff"], ["proof (prove)\nusing this:\n  x \\<in> Domain R\n  runiq R\n  trivial ?X = (?X = {} \\<or> card ?X = 1)\n  \\<lbrakk>?a \\<in> Domain ?r;\n   \\<And>b. (?a, b) \\<in> ?r \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (?b \\<in> ?r `` {?a}) = ((?a, ?b) \\<in> ?r)\n  (?c \\<in> {}) = False\n\ngoal (1 subgoal):\n 1. card (R `` {x}) = 1", "by (metis runiq_alt)"], ["", "text \\<open>The image of a singleton set under a right-unique relation is a singleton set.\\<close>"], ["", "lemma Image_runiq_eq_eval: \n  assumes \"x \\<in> Domain R\" \"runiq R\" \n  shows \"R `` {x} = {R ,, x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` {x} = {R ,, x}", "using assms rightUniqueSetCardinality"], ["proof (prove)\nusing this:\n  x \\<in> Domain R\n  runiq R\n  \\<lbrakk>?x \\<in> Domain ?R; runiq ?R\\<rbrakk>\n  \\<Longrightarrow> card (?R `` {?x}) = 1\n\ngoal (1 subgoal):\n 1. R `` {x} = {R ,, x}", "by (metis eval_rel.simps cardinalityOneTheElemIdentity)"], ["", "lemma lm06: \n  assumes \"trivial f\" \n  shows \"runiq f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq f", "using assms trivial_subset_non_empty runiq_basic snd_conv"], ["proof (prove)\nusing this:\n  trivial f\n  \\<lbrakk>trivial ?t; ?t \\<inter> ?X \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?t \\<subseteq> ?X\n  runiq ?R =\n  (\\<forall>x y y'.\n      (x, y) \\<in> ?R \\<and> (x, y') \\<in> ?R \\<longrightarrow> y = y')\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. runiq f", "by fastforce"], ["", "text \\<open>A singleton relation is right-unique.\\<close>"], ["", "corollary runiq_singleton_rel: \"runiq {(x, y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq {(x, y)}", "using trivial_singleton lm06"], ["proof (prove)\nusing this:\n  trivial {?x}\n  trivial ?f \\<Longrightarrow> runiq ?f\n\ngoal (1 subgoal):\n 1. runiq {(x, y)}", "by fast"], ["", "text \\<open>The empty relation is right-unique\\<close>"], ["", "lemma runiq_emptyrel: \"runiq {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq {}", "using trivial_empty lm06"], ["proof (prove)\nusing this:\n  trivial {}\n  trivial ?f \\<Longrightarrow> runiq ?f\n\ngoal (1 subgoal):\n 1. runiq {}", "by blast"], ["", "(* characterization of right-uniqueness with  \\<exists>! *)"], ["", "lemma runiq_wrt_ex1:\n  \"runiq R \\<longleftrightarrow> (\\<forall> a \\<in> Domain R . \\<exists>! b . (a, b) \\<in> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq R = (\\<forall>a\\<in>Domain R. \\<exists>!b. (a, b) \\<in> R)", "using runiq_basic"], ["proof (prove)\nusing this:\n  runiq ?R =\n  (\\<forall>x y y'.\n      (x, y) \\<in> ?R \\<and> (x, y') \\<in> ?R \\<longrightarrow> y = y')\n\ngoal (1 subgoal):\n 1. runiq R = (\\<forall>a\\<in>Domain R. \\<exists>!b. (a, b) \\<in> R)", "by (metis Domain.DomainI Domain.cases)"], ["", "text \\<open>alternative characterization of the fact that, if a relation @{term R} is right-unique,\n  its evaluation @{term \"R,,x\"} on some argument @{term x} in its domain, occurs in @{term R}'s\n  range. Note that we need runiq R in order to get a definite value for @{term \"R,,x\"}\\<close>"], ["", "lemma eval_runiq_rel:\n  assumes domain: \"x \\<in> Domain R\"\n      and runiq: \"runiq R\" \n  shows \"(x, R,,x) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, R ,, x) \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Domain R\n  runiq R\n\ngoal (1 subgoal):\n 1. (x, R ,, x) \\<in> R", "by (metis rightUniquePair runiq_wrt_ex1)"], ["", "text \\<open>Evaluating a right-unique relation as a function on the relation's domain yields an\n  element from its range.\\<close>"], ["", "lemma eval_runiq_in_Range:\n  assumes \"runiq R\"\n      and \"a \\<in> Domain R\"\n  shows \"R ,, a \\<in> Range R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R ,, a \\<in> Range R", "using assms"], ["proof (prove)\nusing this:\n  runiq R\n  a \\<in> Domain R\n\ngoal (1 subgoal):\n 1. R ,, a \\<in> Range R", "by (metis Range_iff eval_runiq_rel)"], ["", "subsection \\<open>Converse\\<close>"], ["", "text \\<open>The inverse image of the image of a singleton set under some relation is the same\n  singleton set, if both the relation and its converse are right-unique and the singleton set\n  is in the relation's domain.\\<close>"], ["", "lemma converse_Image_singleton_Domain:\n  assumes runiq: \"runiq R\"\n      and runiq_conv: \"runiq (R\\<inverse>)\"\n      and domain: \"x \\<in> Domain R\"\n  shows \"R\\<inverse> `` R `` {x} = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<inverse> `` R `` {x} = {x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R\\<inverse> `` R `` {x} = {x}", "have sup: \"{x} \\<subseteq> R\\<inverse> `` R `` {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} \\<subseteq> R\\<inverse> `` R `` {x}", "using domain"], ["proof (prove)\nusing this:\n  x \\<in> Domain R\n\ngoal (1 subgoal):\n 1. {x} \\<subseteq> R\\<inverse> `` R `` {x}", "by fast"], ["proof (state)\nthis:\n  {x} \\<subseteq> R\\<inverse> `` R `` {x}\n\ngoal (1 subgoal):\n 1. R\\<inverse> `` R `` {x} = {x}", "have \"trivial (R `` {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trivial (R `` {x})", "using runiq domain"], ["proof (prove)\nusing this:\n  runiq R\n  x \\<in> Domain R\n\ngoal (1 subgoal):\n 1. trivial (R `` {x})", "by (metis runiq_def trivial_singleton)"], ["proof (state)\nthis:\n  trivial (R `` {x})\n\ngoal (1 subgoal):\n 1. R\\<inverse> `` R `` {x} = {x}", "then"], ["proof (chain)\npicking this:\n  trivial (R `` {x})", "have \"trivial (R\\<inverse> `` R `` {x})\""], ["proof (prove)\nusing this:\n  trivial (R `` {x})\n\ngoal (1 subgoal):\n 1. trivial (R\\<inverse> `` R `` {x})", "using assms runiq_def"], ["proof (prove)\nusing this:\n  trivial (R `` {x})\n  runiq R\n  runiq (R\\<inverse>)\n  x \\<in> Domain R\n  runiq ?R = (\\<forall>X. trivial X \\<longrightarrow> trivial (?R `` X))\n\ngoal (1 subgoal):\n 1. trivial (R\\<inverse> `` R `` {x})", "by blast"], ["proof (state)\nthis:\n  trivial (R\\<inverse> `` R `` {x})\n\ngoal (1 subgoal):\n 1. R\\<inverse> `` R `` {x} = {x}", "then"], ["proof (chain)\npicking this:\n  trivial (R\\<inverse> `` R `` {x})", "show ?thesis"], ["proof (prove)\nusing this:\n  trivial (R\\<inverse> `` R `` {x})\n\ngoal (1 subgoal):\n 1. R\\<inverse> `` R `` {x} = {x}", "using sup"], ["proof (prove)\nusing this:\n  trivial (R\\<inverse> `` R `` {x})\n  {x} \\<subseteq> R\\<inverse> `` R `` {x}\n\ngoal (1 subgoal):\n 1. R\\<inverse> `` R `` {x} = {x}", "by (metis singleton_sub_trivial_uniq subset_antisym trivial_def)"], ["proof (state)\nthis:\n  R\\<inverse> `` R `` {x} = {x}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The images of two disjoint sets under an injective function are disjoint.\\<close>"], ["", "lemma disj_Domain_imp_disj_Image: \n  assumes \"Domain R \\<inter> X \\<inter> Y = {}\" \n  assumes \"runiq R\"\n      and \"runiq (R\\<inverse>)\"\n  shows \"(R `` X) \\<inter> (R `` Y) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` X \\<inter> R `` Y = {}", "using assms"], ["proof (prove)\nusing this:\n  Domain R \\<inter> X \\<inter> Y = {}\n  runiq R\n  runiq (R\\<inverse>)\n\ngoal (1 subgoal):\n 1. R `` X \\<inter> R `` Y = {}", "unfolding runiq_basic"], ["proof (prove)\nusing this:\n  Domain R \\<inter> X \\<inter> Y = {}\n  \\<forall>x y y'.\n     (x, y) \\<in> R \\<and> (x, y') \\<in> R \\<longrightarrow> y = y'\n  \\<forall>x y y'.\n     (x, y) \\<in> R\\<inverse> \\<and>\n     (x, y') \\<in> R\\<inverse> \\<longrightarrow>\n     y = y'\n\ngoal (1 subgoal):\n 1. R `` X \\<inter> R `` Y = {}", "by blast"], ["", "lemma runiq_converse_paste_singleton: \n  assumes \"runiq (P^-1)\" \"y\\<notin>(Range P)\" \n  shows \"runiq ((P +* {(x,y)})\\<inverse>)\" \n  (is \"?u (?P^-1)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. runiq ((P +* {(x, y)})\\<inverse>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. runiq ((P +* {(x, y)})\\<inverse>)", "have \"(?P) \\<subseteq> P \\<union> {(x,y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P +* {(x, y)} \\<subseteq> P \\<union> {(x, y)}", "using assms"], ["proof (prove)\nusing this:\n  runiq (P\\<inverse>)\n  y \\<notin> Range P\n\ngoal (1 subgoal):\n 1. P +* {(x, y)} \\<subseteq> P \\<union> {(x, y)}", "by (metis paste_sub_Un)"], ["proof (state)\nthis:\n  P +* {(x, y)} \\<subseteq> P \\<union> {(x, y)}\n\ngoal (1 subgoal):\n 1. runiq ((P +* {(x, y)})\\<inverse>)", "then"], ["proof (chain)\npicking this:\n  P +* {(x, y)} \\<subseteq> P \\<union> {(x, y)}", "have \"?P^-1 \\<subseteq> P^-1 \\<union> ({(x,y)}^-1)\""], ["proof (prove)\nusing this:\n  P +* {(x, y)} \\<subseteq> P \\<union> {(x, y)}\n\ngoal (1 subgoal):\n 1. (P +* {(x, y)})\\<inverse>\n    \\<subseteq> P\\<inverse> \\<union> {(x, y)}\\<inverse>", "by blast"], ["proof (state)\nthis:\n  (P +* {(x, y)})\\<inverse>\n  \\<subseteq> P\\<inverse> \\<union> {(x, y)}\\<inverse>\n\ngoal (1 subgoal):\n 1. runiq ((P +* {(x, y)})\\<inverse>)", "moreover"], ["proof (state)\nthis:\n  (P +* {(x, y)})\\<inverse>\n  \\<subseteq> P\\<inverse> \\<union> {(x, y)}\\<inverse>\n\ngoal (1 subgoal):\n 1. runiq ((P +* {(x, y)})\\<inverse>)", "have \"... = P^-1 \\<union> {(y,x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<inverse> \\<union> {(x, y)}\\<inverse> = P\\<inverse> \\<union> {(y, x)}", "by fast"], ["proof (state)\nthis:\n  P\\<inverse> \\<union> {(x, y)}\\<inverse> = P\\<inverse> \\<union> {(y, x)}\n\ngoal (1 subgoal):\n 1. runiq ((P +* {(x, y)})\\<inverse>)", "moreover"], ["proof (state)\nthis:\n  P\\<inverse> \\<union> {(x, y)}\\<inverse> = P\\<inverse> \\<union> {(y, x)}\n\ngoal (1 subgoal):\n 1. runiq ((P +* {(x, y)})\\<inverse>)", "have \"Domain (P^-1) \\<inter> Domain {(y,x)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain (P\\<inverse>) \\<inter> Domain {(y, x)} = {}", "using assms(2)"], ["proof (prove)\nusing this:\n  y \\<notin> Range P\n\ngoal (1 subgoal):\n 1. Domain (P\\<inverse>) \\<inter> Domain {(y, x)} = {}", "by auto"], ["proof (state)\nthis:\n  Domain (P\\<inverse>) \\<inter> Domain {(y, x)} = {}\n\ngoal (1 subgoal):\n 1. runiq ((P +* {(x, y)})\\<inverse>)", "ultimately"], ["proof (chain)\npicking this:\n  (P +* {(x, y)})\\<inverse>\n  \\<subseteq> P\\<inverse> \\<union> {(x, y)}\\<inverse>\n  P\\<inverse> \\<union> {(x, y)}\\<inverse> = P\\<inverse> \\<union> {(y, x)}\n  Domain (P\\<inverse>) \\<inter> Domain {(y, x)} = {}", "moreover"], ["proof (chain)\npicking this:\n  (P +* {(x, y)})\\<inverse>\n  \\<subseteq> P\\<inverse> \\<union> {(x, y)}\\<inverse>\n  P\\<inverse> \\<union> {(x, y)}\\<inverse> = P\\<inverse> \\<union> {(y, x)}\n  Domain (P\\<inverse>) \\<inter> Domain {(y, x)} = {}", "have \"?u (P^-1 \\<union> {(y,x)})\""], ["proof (prove)\nusing this:\n  (P +* {(x, y)})\\<inverse>\n  \\<subseteq> P\\<inverse> \\<union> {(x, y)}\\<inverse>\n  P\\<inverse> \\<union> {(x, y)}\\<inverse> = P\\<inverse> \\<union> {(y, x)}\n  Domain (P\\<inverse>) \\<inter> Domain {(y, x)} = {}\n\ngoal (1 subgoal):\n 1. runiq (P\\<inverse> \\<union> {(y, x)})", "using assms(1)"], ["proof (prove)\nusing this:\n  (P +* {(x, y)})\\<inverse>\n  \\<subseteq> P\\<inverse> \\<union> {(x, y)}\\<inverse>\n  P\\<inverse> \\<union> {(x, y)}\\<inverse> = P\\<inverse> \\<union> {(y, x)}\n  Domain (P\\<inverse>) \\<inter> Domain {(y, x)} = {}\n  runiq (P\\<inverse>)\n\ngoal (1 subgoal):\n 1. runiq (P\\<inverse> \\<union> {(y, x)})", "by (metis disj_Un_runiq runiq_singleton_rel)"], ["proof (state)\nthis:\n  runiq (P\\<inverse> \\<union> {(y, x)})\n\ngoal (1 subgoal):\n 1. runiq ((P +* {(x, y)})\\<inverse>)", "ultimately"], ["proof (chain)\npicking this:\n  (P +* {(x, y)})\\<inverse>\n  \\<subseteq> P\\<inverse> \\<union> {(x, y)}\\<inverse>\n  P\\<inverse> \\<union> {(x, y)}\\<inverse> = P\\<inverse> \\<union> {(y, x)}\n  Domain (P\\<inverse>) \\<inter> Domain {(y, x)} = {}\n  runiq (P\\<inverse> \\<union> {(y, x)})", "show ?thesis"], ["proof (prove)\nusing this:\n  (P +* {(x, y)})\\<inverse>\n  \\<subseteq> P\\<inverse> \\<union> {(x, y)}\\<inverse>\n  P\\<inverse> \\<union> {(x, y)}\\<inverse> = P\\<inverse> \\<union> {(y, x)}\n  Domain (P\\<inverse>) \\<inter> Domain {(y, x)} = {}\n  runiq (P\\<inverse> \\<union> {(y, x)})\n\ngoal (1 subgoal):\n 1. runiq ((P +* {(x, y)})\\<inverse>)", "by (metis subrel_runiq)"], ["proof (state)\nthis:\n  runiq ((P +* {(x, y)})\\<inverse>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Injectivity\\<close>"], ["", "text \\<open>The following is a classical definition of the set of all injective functions from @{term X} to @{term Y}.\\<close>"], ["", "definition injections :: \"'a set \\<Rightarrow> 'b set \\<Rightarrow> ('a \\<times> 'b) set set\"\n  where \"injections X Y = {R . Domain R = X \\<and> Range R \\<subseteq> Y \\<and> runiq R \\<and> runiq (R\\<inverse>)}\""], ["", "text \\<open>The following definition is a constructive (computational) characterization of the set of all injections X Y, represented by a list. That is, we define the list of all injective functions (represented as relations) from one set (represented as a list) to another set. We formally prove the equivalence of the constructive and the classical definition in Universes.thy.\\<close>"], ["", "fun injections_alg (* :: \"'a list \\<Rightarrow> 'b::linorder set \\<Rightarrow> ('a \\<times> 'b) set list\" *)\n  where \"injections_alg [] Y = [{}]\" |\n        \"injections_alg (x # xs) Y = concat [ [ R +* {(x,y)} . y \\<leftarrow> sorted_list_of_set (Y - Range R) ]\n       . R \\<leftarrow> injections_alg xs Y ]\""], ["", "(* We need this as a list in order to be able to iterate over it.  It would be easy to provide \n   an alternative of type ('a \\<times> 'b) set set, by using \\<Union> and set comprehension. *)"], ["", "lemma Image_within_domain': \n  fixes x R \n  shows \"(x \\<in> Domain R) = (R `` {x} \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> Domain R) = (R `` {x} \\<noteq> {})", "by blast"], ["", "end"]]}