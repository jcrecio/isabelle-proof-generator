{"file_name": "/home/qj213/afp-2021-10-22/thys/Abstract_Completeness/Abstract_Completeness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Abstract_Completeness", "problem_names": ["lemma ftree_no_ipath: \"tfinite t \\<Longrightarrow> \\<not> ipath t steps\"", "lemma Konig: \"\\<not> tfinite t \\<Longrightarrow> ipath t (konig t)\"", "lemma countable_R: \"countable R\"", "lemma NE_R: \"R \\<noteq> {}\"", "lemma pickEff: \"enabled r s \\<Longrightarrow> eff r s (pickEff r s)\"", "lemma wf_ipath_epath:\n  assumes \"wf t\" \"ipath t steps\"\n  shows \"epath steps\"", "lemma fair_stl: \"fair rs \\<Longrightarrow> fair (stl rs)\"", "lemma sdrop_fair: \"fair rs \\<Longrightarrow> fair (sdrop m rs)\"", "lemma sset_fenum: \"sset fenum = R\"", "lemma fair_fenum: \"fair fenum\"", "lemma mkTree_unfold[code]: \"mkTree rs s =\n  (case trim rs s of SCons r s' \\<Rightarrow> Node (s, r) (fimage (mkTree s') (pickEff r s)))\"", "lemma trim_alt:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\"\n  shows \"trim rs s = sdrop (minWait rs s) rs\"", "lemma minWait_ex:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\"\n  shows \"\\<exists> n. enabled (shd (sdrop n rs)) s\"", "lemma assumes \"s \\<in> S\" and \"fair rs\"\n  shows trim_in_R: \"shd (trim rs s) \\<in> R\"\n  and trim_enabled: \"enabled (shd (trim rs s)) s\"\n  and trim_fair: \"fair (trim rs s)\"", "lemma minWait_least: \"\\<lbrakk>enabled (shd (sdrop n rs)) s\\<rbrakk> \\<Longrightarrow> minWait rs s \\<le> n\"", "lemma in_cont_mkTree:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\" and t': \"t' |\\<in>| cont (mkTree rs s)\"\n  shows \"\\<exists> sl' s'. s' \\<in> S \\<and> eff (shd (trim rs s)) s sl' \\<and>\n                 s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'\"", "lemma ipath_mkTree_sdrop:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\" and i: \"ipath (mkTree rs s) steps\"\n  shows \"\\<exists> n s'. s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop m steps)\"", "lemma wf_mkTree:\n  assumes s: \"s \\<in> S\" and \"fair rs\"\n  shows \"wf (mkTree rs s)\"", "lemma pos: \"\\<lbrakk>fair rs; r \\<in> R\\<rbrakk> \\<Longrightarrow> shd (sdrop (pos rs r) rs) = r\"", "lemma pos_least: \"shd (sdrop n rs) = r \\<Longrightarrow> pos rs r \\<le> n\"", "lemma minWait_le_pos: \"\\<lbrakk>fair rs; r \\<in> R; enabled r s\\<rbrakk> \\<Longrightarrow> minWait rs s \\<le> pos rs r\"", "lemma stake_pos_minWait:\n  assumes rs: \"fair rs\" and m: \"minWait rs s < pos rs r\" and r: \"r \\<in> R\" and s: \"s \\<in> S\"\n  shows \"pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)\"", "lemma ipath_mkTree_ev:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\"\n  and i: \"ipath (mkTree rs s) steps\" and r: \"r \\<in> R\"\n  and alw: \"alw (holds (enabledAtStep r)) steps\"\n  shows \"ev (holds (takenAtStep r)) steps\"", "lemma per_alw:\n  assumes p: \"per r\" and e: \"epath steps \\<and> fst (shd steps) \\<in> S\"\n  shows \"alw (holds (enabledAtStep r) impl\n    (holds (takenAtStep r) or nxt (holds (enabledAtStep r)))) steps\"", "lemma ipath_mkTree_saturated:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\"\n  and i: \"ipath (mkTree rs s) steps\" and r: \"r \\<in> R\"\n  shows \"saturated r steps\"", "theorem ipath_mkTree_Saturated:\n  assumes \"s \\<in> S\" and \"fair rs\" and \"ipath (mkTree rs s) steps\"\n  shows \"Saturated steps\"", "theorem epath_completeness_Saturated:\n  assumes \"s \\<in> S\"\n  shows\n  \"(\\<exists> t. fst (root t) = s \\<and> wf t \\<and> tfinite t) \\<or>\n   (\\<exists> steps. fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)\" (is \"?A \\<or> ?B\")", "lemma enabled_eff': \"enabled r s \\<longleftrightarrow> eff' r s \\<noteq> None\"", "lemma pickEff_the[code]: \"pickEff r s = the (eff' r s)\"", "lemmas [code_unfold] = trim_def enabled_eff' pickEff_the"], "translations": [["", "lemma ftree_no_ipath: \"tfinite t \\<Longrightarrow> \\<not> ipath t steps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfinite t \\<Longrightarrow> \\<not> ipath t steps", "by (induct t arbitrary: steps rule: tfinite.induct) (auto elim: ipath.cases)"], ["", "(*>*)"], ["", "primcorec konig where\n  \"shd (konig t) = root t\"\n| \"stl (konig t) = konig (SOME t'. t' |\\<in>| cont t \\<and> \\<not> tfinite t')\""], ["", "lemma Konig: \"\\<not> tfinite t \\<Longrightarrow> ipath t (konig t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> tfinite t \\<Longrightarrow> ipath t (konig t)", "by (coinduction arbitrary: t) (metis (lifting) tfinite.simps konig.simps someI_ex)"], ["", "section\\<open>Rule Systems\\<close>"], ["", "(*<*)(* A step consists of a pair (s,r) such that the rule r is taken in state s. *)(*>*)"], ["", "type_synonym ('state, 'rule) step = \"'state \\<times> 'rule\""], ["", "(*<*)(* A derivation tree is a tree of steps: *)(*>*)"], ["", "type_synonym ('state, 'rule) dtree = \"('state, 'rule) step tree\""], ["", "locale RuleSystem_Defs =\nfixes eff :: \"'rule \\<Rightarrow> 'state \\<Rightarrow> 'state fset \\<Rightarrow> bool\"\n(* The countable set of rules is initially provided as a stream: *)\nand rules :: \"'rule stream\"\nbegin"], ["", "abbreviation \"R \\<equiv> sset rules\""], ["", "lemma countable_R: \"countable R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable R", "by (metis countableI_type countable_image sset_range)"], ["", "lemma NE_R: \"R \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<noteq> {}", "by (metis UNIV_witness all_not_in_conv empty_is_image sset_range)"], ["", "definition \"enabled r s \\<equiv> \\<exists> sl. eff r s sl\""], ["", "definition \"pickEff r s \\<equiv> if enabled r s then (SOME sl. eff r s sl) else the None\""], ["", "lemma pickEff: \"enabled r s \\<Longrightarrow> eff r s (pickEff r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled r s \\<Longrightarrow> eff r s (pickEff r s)", "by (metis enabled_def pickEff_def tfl_some)"], ["", "abbreviation \"effStep step \\<equiv> eff (snd step) (fst step)\""], ["", "abbreviation \"enabledAtStep r step \\<equiv> enabled r (fst step)\""], ["", "abbreviation \"takenAtStep r step \\<equiv> snd step = r\""], ["", "text \\<open>Saturation is a very strong notion of fairness:\n  If a rule is enabled at some point, it will eventually be taken.\\<close>"], ["", "definition \"saturated r \\<equiv> alw (holds (enabledAtStep r) impl ev (holds (takenAtStep r)))\""], ["", "definition \"Saturated steps \\<equiv> \\<forall> r \\<in> R. saturated r steps\""], ["", "(*<*)(* Well-formed derivation trees *)(*>*)"], ["", "coinductive wf where\n  wf: \"\\<lbrakk>snd (root t) \\<in> R; effStep (root t) (fimage (fst o root) (cont t));\n    \\<And>t'. t' |\\<in>| cont t \\<Longrightarrow> wf t'\\<rbrakk> \\<Longrightarrow> wf t\""], ["", "(*<*)(* Escape paths *)(*>*)"], ["", "coinductive epath where\n  epath: \"\\<lbrakk>snd (shd steps) \\<in> R; fst (shd (stl steps)) |\\<in>| sl; effStep (shd steps) sl;\n    epath (stl steps)\\<rbrakk> \\<Longrightarrow> epath steps\""], ["", "lemma wf_ipath_epath:\n  assumes \"wf t\" \"ipath t steps\"\n  shows \"epath steps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epath steps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. epath steps", "have *: \"\\<And>t st. ipath t st \\<Longrightarrow> root t = shd st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t st. ipath t st \\<Longrightarrow> tree.root t = shd st", "by (auto elim: ipath.cases)"], ["proof (state)\nthis:\n  ipath ?t1 ?st1 \\<Longrightarrow> tree.root ?t1 = shd ?st1\n\ngoal (1 subgoal):\n 1. epath steps", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. epath steps", "using assms"], ["proof (prove)\nusing this:\n  local.wf t\n  ipath t steps\n\ngoal (1 subgoal):\n 1. epath steps", "proof (coinduction arbitrary: t steps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t steps.\n       \\<lbrakk>local.wf t; ipath t steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stepsa sl.\n                            steps = stepsa \\<and>\n                            snd (shd stepsa) \\<in> R \\<and>\n                            fst (shd (stl stepsa)) |\\<in>| sl \\<and>\n                            effStep (shd stepsa) sl \\<and>\n                            ((\\<exists>t steps.\n                                 stl stepsa = steps \\<and>\n                                 local.wf t \\<and> ipath t steps) \\<or>\n                             epath (stl stepsa))", "case epath"], ["proof (state)\nthis:\n  local.wf t\n  ipath t steps\n\ngoal (1 subgoal):\n 1. \\<And>t steps.\n       \\<lbrakk>local.wf t; ipath t steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stepsa sl.\n                            steps = stepsa \\<and>\n                            snd (shd stepsa) \\<in> R \\<and>\n                            fst (shd (stl stepsa)) |\\<in>| sl \\<and>\n                            effStep (shd stepsa) sl \\<and>\n                            ((\\<exists>t steps.\n                                 stl stepsa = steps \\<and>\n                                 local.wf t \\<and> ipath t steps) \\<or>\n                             epath (stl stepsa))", "then"], ["proof (chain)\npicking this:\n  local.wf t\n  ipath t steps", "show ?case"], ["proof (prove)\nusing this:\n  local.wf t\n  ipath t steps\n\ngoal (1 subgoal):\n 1. \\<exists>steps sl.\n       steps = steps \\<and>\n       snd (shd steps) \\<in> R \\<and>\n       fst (shd (stl steps)) |\\<in>| sl \\<and>\n       effStep (shd steps) sl \\<and>\n       ((\\<exists>t stepsa.\n            stl steps = stepsa \\<and>\n            local.wf t \\<and> ipath t stepsa) \\<or>\n        epath (stl steps))", "by (cases rule: wf.cases[case_product ipath.cases]) (metis * o_apply fimageI)"], ["proof (state)\nthis:\n  \\<exists>steps sl.\n     steps = steps \\<and>\n     snd (shd steps) \\<in> R \\<and>\n     fst (shd (stl steps)) |\\<in>| sl \\<and>\n     effStep (shd steps) sl \\<and>\n     ((\\<exists>t stepsa.\n          stl steps = stepsa \\<and> local.wf t \\<and> ipath t stepsa) \\<or>\n      epath (stl steps))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  epath steps\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"fair rs \\<equiv> sset rs \\<subseteq> R \\<and> (\\<forall> r \\<in> R. alw (ev (holds ((=) r))) rs)\""], ["", "lemma fair_stl: \"fair rs \\<Longrightarrow> fair (stl rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair rs \\<Longrightarrow> fair (stl rs)", "unfolding fair_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sset rs \\<subseteq> R \\<and>\n    (\\<forall>r\\<in>R. alw (ev (holds ((=) r))) rs) \\<Longrightarrow>\n    sset (stl rs) \\<subseteq> R \\<and>\n    (\\<forall>r\\<in>R. alw (ev (holds ((=) r))) (stl rs))", "by (metis alw.simps subsetD stl_sset subsetI)"], ["", "lemma sdrop_fair: \"fair rs \\<Longrightarrow> fair (sdrop m rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair rs \\<Longrightarrow> fair (sdrop m rs)", "using alw_sdrop"], ["proof (prove)\nusing this:\n  alw ?\\<phi> ?xs \\<Longrightarrow> alw ?\\<phi> (sdrop ?n ?xs)\n\ngoal (1 subgoal):\n 1. fair rs \\<Longrightarrow> fair (sdrop m rs)", "unfolding fair_def"], ["proof (prove)\nusing this:\n  alw ?\\<phi> ?xs \\<Longrightarrow> alw ?\\<phi> (sdrop ?n ?xs)\n\ngoal (1 subgoal):\n 1. sset rs \\<subseteq> R \\<and>\n    (\\<forall>r\\<in>R. alw (ev (holds ((=) r))) rs) \\<Longrightarrow>\n    sset (sdrop m rs) \\<subseteq> R \\<and>\n    (\\<forall>r\\<in>R. alw (ev (holds ((=) r))) (sdrop m rs))", "by (metis alw.coinduct alw_nxt fair_def fair_stl)"], ["", "section\\<open>A Fair Enumeration of the Rules\\<close>"], ["", "(*<*)(* The fair enumeration of rules *)(*>*)"], ["", "definition \"fenum \\<equiv> flat (smap (\\<lambda>n. stake n rules) (fromN 1))\""], ["", "lemma sset_fenum: \"sset fenum = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset fenum = R", "unfolding fenum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (flat (smap (\\<lambda>n. stake n rules) (fromN 1))) = R", "by (subst sset_flat)\n   (auto simp: stream.set_map in_set_conv_nth sset_range[of rules],\n     metis atLeast_Suc_greaterThan greaterThan_0 lessI range_eqI stake_nth)"], ["", "lemma fair_fenum: \"fair fenum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair fenum", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fair fenum", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. fair fenum", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. fair fenum", "assume \"r \\<in> R\""], ["proof (state)\nthis:\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. fair fenum", "then"], ["proof (chain)\npicking this:\n  r \\<in> R", "obtain m where r: \"r = rules !! m\""], ["proof (prove)\nusing this:\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>m. r = rules !! m \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sset_range"], ["proof (prove)\nusing this:\n  r \\<in> range ((!!) rules)\n\ngoal (1 subgoal):\n 1. (\\<And>m. r = rules !! m \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r = rules !! m\n\ngoal (1 subgoal):\n 1. fair fenum", "{"], ["proof (state)\nthis:\n  r = rules !! m\n\ngoal (1 subgoal):\n 1. fair fenum", "fix n :: nat and rs"], ["proof (state)\ngoal (1 subgoal):\n 1. fair fenum", "let ?fenum = \"\\<lambda>n. flat (smap (\\<lambda>n. stake n rules) (fromN n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. fair fenum", "assume \"n > 0\""], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. fair fenum", "hence \"alw (ev (holds ((=) r))) (rs @- ?fenum n)\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. alw (ev (holds ((=) r)))\n     (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)))", "proof (coinduction arbitrary: n rs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n rs.\n       0 < n \\<Longrightarrow>\n       \\<exists>xs.\n          rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)) =\n          xs \\<and>\n          ev (holds ((=) r)) xs \\<and>\n          ((\\<exists>n rs.\n               stl xs =\n               rs @-\n               flat (smap (\\<lambda>n. stake n rules) (fromN n)) \\<and>\n               0 < n) \\<or>\n           alw (ev (holds ((=) r))) (stl xs))", "case alw"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>n rs.\n       0 < n \\<Longrightarrow>\n       \\<exists>xs.\n          rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)) =\n          xs \\<and>\n          ev (holds ((=) r)) xs \\<and>\n          ((\\<exists>n rs.\n               stl xs =\n               rs @-\n               flat (smap (\\<lambda>n. stake n rules) (fromN n)) \\<and>\n               0 < n) \\<or>\n           alw (ev (holds ((=) r))) (stl xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)) = xs \\<and>\n       ev (holds ((=) r)) xs \\<and>\n       ((\\<exists>n rs.\n            stl xs =\n            rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)) \\<and>\n            0 < n) \\<or>\n        alw (ev (holds ((=) r))) (stl xs))", "proof (rule exI[of _ \"rs @- ?fenum n\"], safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. ev (holds ((=) r))\n     (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)))\n 2. \\<not> alw (ev (holds ((=) r)))\n            (stl (rs @-\n                  flat\n                   (smap (\\<lambda>n. stake n rules)\n                     (fromN n)))) \\<Longrightarrow>\n    \\<exists>n rs.\n       stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n       rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)) \\<and>\n       0 < n", "show \"\\<exists>n' rs'. stl (rs @- ?fenum n) = rs' @- ?fenum n' \\<and> n' > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n' rs'.\n       stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n       rs' @- flat (smap (\\<lambda>n. stake n rules) (fromN n')) \\<and>\n       0 < n'", "proof(cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    \\<exists>n' rs'.\n       stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n       rs' @- flat (smap (\\<lambda>n. stake n rules) (fromN n')) \\<and>\n       0 < n'\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       \\<exists>n' rs'.\n          stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n          rs' @- flat (smap (\\<lambda>n. stake n rules) (fromN n')) \\<and>\n          0 < n'", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    \\<exists>n' rs'.\n       stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n       rs' @- flat (smap (\\<lambda>n. stake n rules) (fromN n')) \\<and>\n       0 < n'\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       \\<exists>n' rs'.\n          stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n          rs' @- flat (smap (\\<lambda>n. stake n rules) (fromN n')) \\<and>\n          0 < n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. \\<exists>n' rs'.\n       stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n       rs' @- flat (smap (\\<lambda>n. stake n rules) (fromN n')) \\<and>\n       0 < n'", "unfolding alw"], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. \\<exists>n' rs'.\n       stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n       rs' @- flat (smap (\\<lambda>n. stake n rules) (fromN n')) \\<and>\n       0 < n'", "by (intro exI) auto"], ["proof (state)\nthis:\n  \\<exists>n' rs'.\n     stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n     rs' @- flat (smap (\\<lambda>n. stake n rules) (fromN n')) \\<and>\n     0 < n'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       \\<exists>n' rs'.\n          stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n          rs' @- flat (smap (\\<lambda>n. stake n rules) (fromN n')) \\<and>\n          0 < n'", "qed (auto simp: alw intro: exI[of _ n])"], ["proof (state)\nthis:\n  \\<exists>n' rs'.\n     stl (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))) =\n     rs' @- flat (smap (\\<lambda>n. stake n rules) (fromN n')) \\<and>\n     0 < n'\n\ngoal (1 subgoal):\n 1. ev (holds ((=) r))\n     (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ev (holds ((=) r))\n     (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)))", "show \"ev (holds ((=) r)) (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (holds ((=) r))\n     (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)))", "using alw r"], ["proof (prove)\nusing this:\n  0 < n\n  r = rules !! m\n\ngoal (1 subgoal):\n 1. ev (holds ((=) r))\n     (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)))", "unfolding ev_holds_sset"], ["proof (prove)\nusing this:\n  0 < n\n  r = rules !! m\n\ngoal (1 subgoal):\n 1. Bex (sset (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n))))\n     ((=) r)", "by (cases \"m < n\") (force simp: stream.set_map in_set_conv_nth)+"], ["proof (state)\nthis:\n  ev (holds ((=) r))\n   (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)) = xs \\<and>\n     ev (holds ((=) r)) xs \\<and>\n     ((\\<exists>n rs.\n          stl xs =\n          rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)) \\<and>\n          0 < n) \\<or>\n      alw (ev (holds ((=) r))) (stl xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  alw (ev (holds ((=) r)))\n   (rs @- flat (smap (\\<lambda>n. stake n rules) (fromN n)))\n\ngoal (1 subgoal):\n 1. fair fenum", "}"], ["proof (state)\nthis:\n  0 < ?n3 \\<Longrightarrow>\n  alw (ev (holds ((=) r)))\n   (?rs3 @- flat (smap (\\<lambda>n. stake n rules) (fromN ?n3)))\n\ngoal (1 subgoal):\n 1. fair fenum", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?r9 \\<in> R; 0 < ?n6\\<rbrakk>\n  \\<Longrightarrow> alw (ev (holds ((=) ?r9)))\n                     (?rs6 @-\n                      flat (smap (\\<lambda>n. stake n rules) (fromN ?n6)))\n\ngoal (1 subgoal):\n 1. fair fenum", "thus \"fair fenum\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?r9 \\<in> R; 0 < ?n6\\<rbrakk>\n  \\<Longrightarrow> alw (ev (holds ((=) ?r9)))\n                     (?rs6 @-\n                      flat (smap (\\<lambda>n. stake n rules) (fromN ?n6)))\n\ngoal (1 subgoal):\n 1. fair fenum", "unfolding fair_def sset_fenum"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r9 \\<in> R; 0 < ?n6\\<rbrakk>\n  \\<Longrightarrow> alw (ev (holds ((=) ?r9)))\n                     (?rs6 @-\n                      flat (smap (\\<lambda>n. stake n rules) (fromN ?n6)))\n\ngoal (1 subgoal):\n 1. R \\<subseteq> R \\<and>\n    (\\<forall>r\\<in>R. alw (ev (holds ((=) r))) fenum)", "by (metis fenum_def alw_shift le_less zero_less_one)"], ["proof (state)\nthis:\n  fair fenum\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"trim rs s = sdrop_while (\\<lambda>r. Not (enabled r s)) rs\""], ["", "(*<*)(* The fair tree associated to a stream of rules and a state *)(*>*)"], ["", "primcorec mkTree where\n  \"root (mkTree rs s) = (s, (shd (trim rs s)))\"\n| \"cont (mkTree rs s) = fimage (mkTree (stl (trim rs s))) (pickEff (shd (trim rs s)) s)\""], ["", "(*<*)(* More efficient code equation for mkTree *)(*>*)"], ["", "lemma mkTree_unfold[code]: \"mkTree rs s =\n  (case trim rs s of SCons r s' \\<Rightarrow> Node (s, r) (fimage (mkTree s') (pickEff r s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkTree rs s =\n    (case trim rs s of\n     r ## s' \\<Rightarrow> Node (s, r) (mkTree s' |`| pickEff r s))", "by (subst mkTree.ctr) (simp split: stream.splits)"], ["", "end"], ["", "locale RuleSystem = RuleSystem_Defs eff rules\nfor eff :: \"'rule \\<Rightarrow> 'state \\<Rightarrow> 'state fset \\<Rightarrow> bool\" and rules :: \"'rule stream\" +\nfixes S :: \"'state set\"\nassumes eff_S: \"\\<And> s r sl s'. \\<lbrakk>s \\<in> S; r \\<in> R; eff r s sl; s' |\\<in>| sl\\<rbrakk> \\<Longrightarrow> s' \\<in> S\"\nand enabled_R: \"\\<And> s. s \\<in> S \\<Longrightarrow> \\<exists> r \\<in> R. \\<exists> sl. eff r s sl\"\nbegin"], ["", "(*<*)(* The minimum waiting time in a stream for the enabled rules in a given state: *)(*>*)"], ["", "definition \"minWait rs s \\<equiv> LEAST n. enabled (shd (sdrop n rs)) s\""], ["", "lemma trim_alt:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\"\n  shows \"trim rs s = sdrop (minWait rs s) rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trim rs s = sdrop (minWait rs s) rs", "proof (unfold trim_def minWait_def sdrop_simps, rule sdrop_while_sdrop_LEAST[unfolded o_def])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. enabled (rs !! n) s", "from enabled_R[OF s]"], ["proof (chain)\npicking this:\n  \\<exists>r\\<in>R. \\<exists>sl. eff r s sl", "obtain r sl where r: \"r \\<in> R\" and sl: \"eff r s sl\""], ["proof (prove)\nusing this:\n  \\<exists>r\\<in>R. \\<exists>sl. eff r s sl\n\ngoal (1 subgoal):\n 1. (\\<And>r sl.\n        \\<lbrakk>r \\<in> R; eff r s sl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r \\<in> R\n  eff r s sl\n\ngoal (1 subgoal):\n 1. \\<exists>n. enabled (rs !! n) s", "from bspec[OF conjunct2[OF rs[unfolded fair_def]] r]"], ["proof (chain)\npicking this:\n  alw (ev (holds ((=) r))) rs", "obtain m where \"r = rs !! m\""], ["proof (prove)\nusing this:\n  alw (ev (holds ((=) r))) rs\n\ngoal (1 subgoal):\n 1. (\\<And>m. r = rs !! m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by atomize_elim (erule alw.cases, auto simp only: ev_holds_sset sset_range)"], ["proof (state)\nthis:\n  r = rs !! m\n\ngoal (1 subgoal):\n 1. \\<exists>n. enabled (rs !! n) s", "with r sl"], ["proof (chain)\npicking this:\n  r \\<in> R\n  eff r s sl\n  r = rs !! m", "show \"\\<exists>n. enabled (rs !! n) s\""], ["proof (prove)\nusing this:\n  r \\<in> R\n  eff r s sl\n  r = rs !! m\n\ngoal (1 subgoal):\n 1. \\<exists>n. enabled (rs !! n) s", "unfolding enabled_def"], ["proof (prove)\nusing this:\n  r \\<in> R\n  eff r s sl\n  r = rs !! m\n\ngoal (1 subgoal):\n 1. \\<exists>n sl. eff (rs !! n) s sl", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. enabled (rs !! n) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minWait_ex:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\"\n  shows \"\\<exists> n. enabled (shd (sdrop n rs)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. enabled (shd (sdrop n rs)) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. enabled (shd (sdrop n rs)) s", "obtain r where r: \"r \\<in> R\" and e: \"enabled r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r \\<in> R; enabled r s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using enabled_R s"], ["proof (prove)\nusing this:\n  ?s \\<in> S \\<Longrightarrow> \\<exists>r\\<in>R. \\<exists>sl. eff r ?s sl\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r \\<in> R; enabled r s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding enabled_def"], ["proof (prove)\nusing this:\n  ?s \\<in> S \\<Longrightarrow> \\<exists>r\\<in>R. \\<exists>sl. eff r ?s sl\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r \\<in> R; \\<exists>sl. eff r s sl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r \\<in> R\n  enabled r s\n\ngoal (1 subgoal):\n 1. \\<exists>n. enabled (shd (sdrop n rs)) s", "then"], ["proof (chain)\npicking this:\n  r \\<in> R\n  enabled r s", "obtain n where \"shd (sdrop n rs) = r\""], ["proof (prove)\nusing this:\n  r \\<in> R\n  enabled r s\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        shd (sdrop n rs) = r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sdrop_fair[OF rs]"], ["proof (prove)\nusing this:\n  r \\<in> R\n  enabled r s\n  fair (sdrop ?m rs)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        shd (sdrop n rs) = r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) alw_nxt holds.simps sdrop.simps(1) fair_def sdrop_wait)"], ["proof (state)\nthis:\n  shd (sdrop n rs) = r\n\ngoal (1 subgoal):\n 1. \\<exists>n. enabled (shd (sdrop n rs)) s", "thus ?thesis"], ["proof (prove)\nusing this:\n  shd (sdrop n rs) = r\n\ngoal (1 subgoal):\n 1. \\<exists>n. enabled (shd (sdrop n rs)) s", "using r e"], ["proof (prove)\nusing this:\n  shd (sdrop n rs) = r\n  r \\<in> R\n  enabled r s\n\ngoal (1 subgoal):\n 1. \\<exists>n. enabled (shd (sdrop n rs)) s", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. enabled (shd (sdrop n rs)) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes \"s \\<in> S\" and \"fair rs\"\n  shows trim_in_R: \"shd (trim rs s) \\<in> R\"\n  and trim_enabled: \"enabled (shd (trim rs s)) s\"\n  and trim_fair: \"fair (trim rs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (trim rs s) \\<in> R &&&\n    enabled (shd (trim rs s)) s &&& fair (trim rs s)", "unfolding trim_alt[OF assms] minWait_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (sdrop (LEAST n. enabled (shd (sdrop n rs)) s) rs) \\<in> R &&&\n    enabled (shd (sdrop (LEAST n. enabled (shd (sdrop n rs)) s) rs)) s &&&\n    fair (sdrop (LEAST n. enabled (shd (sdrop n rs)) s) rs)", "using LeastI_ex[OF minWait_ex[OF assms]] sdrop_fair[OF assms(2)]\n    conjunct1[OF assms(2)[unfolded fair_def]]"], ["proof (prove)\nusing this:\n  enabled (shd (sdrop (LEAST n. enabled (shd (sdrop n rs)) s) rs)) s\n  fair (sdrop ?m rs)\n  sset rs \\<subseteq> R\n\ngoal (1 subgoal):\n 1. shd (sdrop (LEAST n. enabled (shd (sdrop n rs)) s) rs) \\<in> R &&&\n    enabled (shd (sdrop (LEAST n. enabled (shd (sdrop n rs)) s) rs)) s &&&\n    fair (sdrop (LEAST n. enabled (shd (sdrop n rs)) s) rs)", "by simp_all (metis subsetD snth_sset)"], ["", "lemma minWait_least: \"\\<lbrakk>enabled (shd (sdrop n rs)) s\\<rbrakk> \\<Longrightarrow> minWait rs s \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled (shd (sdrop n rs)) s \\<Longrightarrow> minWait rs s \\<le> n", "unfolding minWait_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled (shd (sdrop n rs)) s \\<Longrightarrow>\n    (LEAST n. enabled (shd (sdrop n rs)) s) \\<le> n", "by (intro Least_le conjI)"], ["", "lemma in_cont_mkTree:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\" and t': \"t' |\\<in>| cont (mkTree rs s)\"\n  shows \"\\<exists> sl' s'. s' \\<in> S \\<and> eff (shd (trim rs s)) s sl' \\<and>\n                 s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "define sl' where \"sl' = pickEff (shd (trim rs s)) s\""], ["proof (state)\nthis:\n  sl' = pickEff (shd (trim rs s)) s\n\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "obtain s' where s': \"s' |\\<in>| sl'\" and \"t' = mkTree (stl (trim rs s)) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' |\\<in>| sl'; t' = mkTree (stl (trim rs s)) s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using t'"], ["proof (prove)\nusing this:\n  t' |\\<in>| cont (mkTree rs s)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' |\\<in>| sl'; t' = mkTree (stl (trim rs s)) s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sl'_def"], ["proof (prove)\nusing this:\n  t' |\\<in>| cont (mkTree rs s)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' |\\<in>| pickEff (shd (trim rs s)) s;\n         t' = mkTree (stl (trim rs s)) s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s' |\\<in>| sl'\n  t' = mkTree (stl (trim rs s)) s'\n\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "moreover"], ["proof (state)\nthis:\n  s' |\\<in>| sl'\n  t' = mkTree (stl (trim rs s)) s'\n\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "have 1: \"enabled (shd (trim rs s)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled (shd (trim rs s)) s", "using trim_enabled[OF s rs]"], ["proof (prove)\nusing this:\n  enabled (shd (trim rs s)) s\n\ngoal (1 subgoal):\n 1. enabled (shd (trim rs s)) s", "."], ["proof (state)\nthis:\n  enabled (shd (trim rs s)) s\n\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "moreover"], ["proof (state)\nthis:\n  enabled (shd (trim rs s)) s\n\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "with trim_in_R pickEff eff_S s rs s'[unfolded sl'_def]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?s \\<in> S; fair ?rs\\<rbrakk>\n  \\<Longrightarrow> shd (trim ?rs ?s) \\<in> R\n  enabled ?r ?s \\<Longrightarrow> eff ?r ?s (pickEff ?r ?s)\n  \\<lbrakk>?s \\<in> S; ?r \\<in> R; eff ?r ?s ?sl; ?s' |\\<in>| ?sl\\<rbrakk>\n  \\<Longrightarrow> ?s' \\<in> S\n  s \\<in> S\n  fair rs\n  s' |\\<in>| pickEff (shd (trim rs s)) s\n  enabled (shd (trim rs s)) s", "have \"s' \\<in> S\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?s \\<in> S; fair ?rs\\<rbrakk>\n  \\<Longrightarrow> shd (trim ?rs ?s) \\<in> R\n  enabled ?r ?s \\<Longrightarrow> eff ?r ?s (pickEff ?r ?s)\n  \\<lbrakk>?s \\<in> S; ?r \\<in> R; eff ?r ?s ?sl; ?s' |\\<in>| ?sl\\<rbrakk>\n  \\<Longrightarrow> ?s' \\<in> S\n  s \\<in> S\n  fair rs\n  s' |\\<in>| pickEff (shd (trim rs s)) s\n  enabled (shd (trim rs s)) s\n\ngoal (1 subgoal):\n 1. s' \\<in> S", "by blast"], ["proof (state)\nthis:\n  s' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "ultimately"], ["proof (chain)\npicking this:\n  s' |\\<in>| sl'\n  t' = mkTree (stl (trim rs s)) s'\n  enabled (shd (trim rs s)) s\n  s' \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  s' |\\<in>| sl'\n  t' = mkTree (stl (trim rs s)) s'\n  enabled (shd (trim rs s)) s\n  s' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "unfolding sl'_def"], ["proof (prove)\nusing this:\n  s' |\\<in>| pickEff (shd (trim rs s)) s\n  t' = mkTree (stl (trim rs s)) s'\n  enabled (shd (trim rs s)) s\n  s' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "using pickEff"], ["proof (prove)\nusing this:\n  s' |\\<in>| pickEff (shd (trim rs s)) s\n  t' = mkTree (stl (trim rs s)) s'\n  enabled (shd (trim rs s)) s\n  s' \\<in> S\n  enabled ?r ?s \\<Longrightarrow> eff ?r ?s (pickEff ?r ?s)\n\ngoal (1 subgoal):\n 1. \\<exists>sl' s'.\n       s' \\<in> S \\<and>\n       eff (shd (trim rs s)) s sl' \\<and>\n       s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'", "by blast"], ["proof (state)\nthis:\n  \\<exists>sl' s'.\n     s' \\<in> S \\<and>\n     eff (shd (trim rs s)) s sl' \\<and>\n     s' |\\<in>| sl' \\<and> t' = mkTree (stl (trim rs s)) s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipath_mkTree_sdrop:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\" and i: \"ipath (mkTree rs s) steps\"\n  shows \"\\<exists> n s'. s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop m steps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n s'.\n       s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop m steps)", "using s rs i"], ["proof (prove)\nusing this:\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps\n\ngoal (1 subgoal):\n 1. \\<exists>n s'.\n       s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop m steps)", "proof (induct m arbitrary: steps rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>steps rs.\n       \\<lbrakk>s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s') (sdrop 0 steps)\n 2. \\<And>m steps rs.\n       \\<lbrakk>\\<And>steps rs.\n                   \\<lbrakk>s \\<in> S; fair rs;\n                    ipath (mkTree rs s) steps\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>n s'.\n  s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop m steps);\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s')\n                             (sdrop (Suc m) steps)", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<in> S; fair ?rs1; ipath (mkTree ?rs1 s) ?steps1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n s'.\n                       s' \\<in> S \\<and>\n                       ipath (mkTree (sdrop n ?rs1) s') (sdrop m ?steps1)\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps\n\ngoal (2 subgoals):\n 1. \\<And>steps rs.\n       \\<lbrakk>s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s') (sdrop 0 steps)\n 2. \\<And>m steps rs.\n       \\<lbrakk>\\<And>steps rs.\n                   \\<lbrakk>s \\<in> S; fair rs;\n                    ipath (mkTree rs s) steps\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>n s'.\n  s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop m steps);\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s')\n                             (sdrop (Suc m) steps)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>s \\<in> S; fair ?rs1; ipath (mkTree ?rs1 s) ?steps1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n s'.\n                       s' \\<in> S \\<and>\n                       ipath (mkTree (sdrop n ?rs1) s') (sdrop m ?steps1)\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps", "obtain n s' where s': \"s' \\<in> S\"\n    and ip: \"ipath (mkTree (sdrop n rs) s') (sdrop m steps)\" (is \"ipath ?t _\")"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<in> S; fair ?rs1; ipath (mkTree ?rs1 s) ?steps1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n s'.\n                       s' \\<in> S \\<and>\n                       ipath (mkTree (sdrop n ?rs1) s') (sdrop m ?steps1)\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps\n\ngoal (1 subgoal):\n 1. (\\<And>s' n.\n        \\<lbrakk>s' \\<in> S;\n         ipath (mkTree (sdrop n rs) s') (sdrop m steps)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s' \\<in> S\n  ipath (mkTree (sdrop n rs) s') (sdrop m steps)\n\ngoal (2 subgoals):\n 1. \\<And>steps rs.\n       \\<lbrakk>s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s') (sdrop 0 steps)\n 2. \\<And>m steps rs.\n       \\<lbrakk>\\<And>steps rs.\n                   \\<lbrakk>s \\<in> S; fair rs;\n                    ipath (mkTree rs s) steps\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>n s'.\n  s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop m steps);\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s')\n                             (sdrop (Suc m) steps)", "from ip"], ["proof (chain)\npicking this:\n  ipath (mkTree (sdrop n rs) s') (sdrop m steps)", "obtain t' where r: \"root ?t = shd (sdrop m steps)\" and t': \"t' |\\<in>| cont ?t\"\n    and i: \"ipath t' (sdrop (Suc m) steps)\""], ["proof (prove)\nusing this:\n  ipath (mkTree (sdrop n rs) s') (sdrop m steps)\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>tree.root (mkTree (sdrop n rs) s') = shd (sdrop m steps);\n         t' |\\<in>| cont (mkTree (sdrop n rs) s');\n         ipath t' (sdrop (Suc m) steps)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases, simp)"], ["proof (state)\nthis:\n  tree.root (mkTree (sdrop n rs) s') = shd (sdrop m steps)\n  t' |\\<in>| cont (mkTree (sdrop n rs) s')\n  ipath t' (sdrop (Suc m) steps)\n\ngoal (2 subgoals):\n 1. \\<And>steps rs.\n       \\<lbrakk>s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s') (sdrop 0 steps)\n 2. \\<And>m steps rs.\n       \\<lbrakk>\\<And>steps rs.\n                   \\<lbrakk>s \\<in> S; fair rs;\n                    ipath (mkTree rs s) steps\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>n s'.\n  s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop m steps);\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s')\n                             (sdrop (Suc m) steps)", "from in_cont_mkTree[OF s' sdrop_fair[OF Suc.prems(2)] t']"], ["proof (chain)\npicking this:\n  \\<exists>sl' s'a.\n     s'a \\<in> S \\<and>\n     eff (shd (trim (sdrop n rs) s')) s' sl' \\<and>\n     s'a |\\<in>| sl' \\<and> t' = mkTree (stl (trim (sdrop n rs) s')) s'a", "obtain sl'' s'' where\n    e: \"eff (shd (trim (sdrop n rs) s')) s' sl''\" and\n    s'': \"s'' |\\<in>| sl''\" and t'_def: \"t' = mkTree (stl (trim (sdrop n rs) s')) s''\""], ["proof (prove)\nusing this:\n  \\<exists>sl' s'a.\n     s'a \\<in> S \\<and>\n     eff (shd (trim (sdrop n rs) s')) s' sl' \\<and>\n     s'a |\\<in>| sl' \\<and> t' = mkTree (stl (trim (sdrop n rs) s')) s'a\n\ngoal (1 subgoal):\n 1. (\\<And>sl'' s''.\n        \\<lbrakk>eff (shd (trim (sdrop n rs) s')) s' sl''; s'' |\\<in>| sl'';\n         t' = mkTree (stl (trim (sdrop n rs) s')) s''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  eff (shd (trim (sdrop n rs) s')) s' sl''\n  s'' |\\<in>| sl''\n  t' = mkTree (stl (trim (sdrop n rs) s')) s''\n\ngoal (2 subgoals):\n 1. \\<And>steps rs.\n       \\<lbrakk>s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s') (sdrop 0 steps)\n 2. \\<And>m steps rs.\n       \\<lbrakk>\\<And>steps rs.\n                   \\<lbrakk>s \\<in> S; fair rs;\n                    ipath (mkTree rs s) steps\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>n s'.\n  s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop m steps);\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s')\n                             (sdrop (Suc m) steps)", "have \"shd (trim (sdrop n rs) s') \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (trim (sdrop n rs) s') \\<in> R", "by (metis sdrop_fair Suc.prems(2) trim_in_R s')"], ["proof (state)\nthis:\n  shd (trim (sdrop n rs) s') \\<in> R\n\ngoal (2 subgoals):\n 1. \\<And>steps rs.\n       \\<lbrakk>s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s') (sdrop 0 steps)\n 2. \\<And>m steps rs.\n       \\<lbrakk>\\<And>steps rs.\n                   \\<lbrakk>s \\<in> S; fair rs;\n                    ipath (mkTree rs s) steps\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>n s'.\n  s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop m steps);\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s')\n                             (sdrop (Suc m) steps)", "thus ?case"], ["proof (prove)\nusing this:\n  shd (trim (sdrop n rs) s') \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>n s'.\n       s' \\<in> S \\<and>\n       ipath (mkTree (sdrop n rs) s') (sdrop (Suc m) steps)", "using i s'' e s'"], ["proof (prove)\nusing this:\n  shd (trim (sdrop n rs) s') \\<in> R\n  ipath t' (sdrop (Suc m) steps)\n  s'' |\\<in>| sl''\n  eff (shd (trim (sdrop n rs) s')) s' sl''\n  s' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>n s'.\n       s' \\<in> S \\<and>\n       ipath (mkTree (sdrop n rs) s') (sdrop (Suc m) steps)", "unfolding sdrop_stl t'_def sdrop_add add.commute[of n]\n    trim_alt[OF s' sdrop_fair[OF Suc.prems(2)]]"], ["proof (prove)\nusing this:\n  shd (sdrop (minWait (sdrop n rs) s' + n) rs) \\<in> R\n  ipath (mkTree (stl (sdrop (minWait (sdrop n rs) s' + n) rs)) s'')\n   (sdrop (Suc m) steps)\n  s'' |\\<in>| sl''\n  eff (shd (sdrop (minWait (sdrop n rs) s' + n) rs)) s' sl''\n  s' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>n s'.\n       s' \\<in> S \\<and>\n       ipath (mkTree (sdrop n rs) s') (sdrop (Suc m) steps)", "by (intro exI[of _ \"minWait (sdrop n rs) s' + Suc n\"] exI[of _ s'']) (simp add: eff_S)"], ["proof (state)\nthis:\n  \\<exists>n s'.\n     s' \\<in> S \\<and> ipath (mkTree (sdrop n rs) s') (sdrop (Suc m) steps)\n\ngoal (1 subgoal):\n 1. \\<And>steps rs.\n       \\<lbrakk>s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n s'.\n                            s' \\<in> S \\<and>\n                            ipath (mkTree (sdrop n rs) s') (sdrop 0 steps)", "qed (auto intro!: exI[of _ 0] exI[of _ s])"], ["", "lemma wf_mkTree:\n  assumes s: \"s \\<in> S\" and \"fair rs\"\n  shows \"wf (mkTree rs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf (mkTree rs s)", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> S\n  fair rs\n\ngoal (1 subgoal):\n 1. local.wf (mkTree rs s)", "proof (coinduction arbitrary: rs s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs s.\n       \\<lbrakk>s \\<in> S; fair rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            mkTree rs s = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>rs s.\n                                    x = mkTree rs s \\<and>\n                                    s \\<in> S \\<and> fair rs) \\<or>\n                                local.wf x)", "case (wf rs s)"], ["proof (state)\nthis:\n  s \\<in> S\n  fair rs\n\ngoal (1 subgoal):\n 1. \\<And>rs s.\n       \\<lbrakk>s \\<in> S; fair rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            mkTree rs s = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>rs s.\n                                    x = mkTree rs s \\<and>\n                                    s \\<in> S \\<and> fair rs) \\<or>\n                                local.wf x)", "let ?t = \"mkTree rs s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs s.\n       \\<lbrakk>s \\<in> S; fair rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            mkTree rs s = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>rs s.\n                                    x = mkTree rs s \\<and>\n                                    s \\<in> S \\<and> fair rs) \\<or>\n                                local.wf x)", "have \"snd (root ?t) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (tree.root (mkTree rs s)) \\<in> R", "using trim_in_R[OF wf]"], ["proof (prove)\nusing this:\n  shd (trim rs s) \\<in> R\n\ngoal (1 subgoal):\n 1. snd (tree.root (mkTree rs s)) \\<in> R", "by simp"], ["proof (state)\nthis:\n  snd (tree.root (mkTree rs s)) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>rs s.\n       \\<lbrakk>s \\<in> S; fair rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            mkTree rs s = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>rs s.\n                                    x = mkTree rs s \\<and>\n                                    s \\<in> S \\<and> fair rs) \\<or>\n                                local.wf x)", "moreover"], ["proof (state)\nthis:\n  snd (tree.root (mkTree rs s)) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>rs s.\n       \\<lbrakk>s \\<in> S; fair rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            mkTree rs s = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>rs s.\n                                    x = mkTree rs s \\<and>\n                                    s \\<in> S \\<and> fair rs) \\<or>\n                                local.wf x)", "have \"fst \\<circ> root \\<circ> mkTree (stl (trim rs s)) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst \\<circ> tree.root \\<circ> mkTree (stl (trim rs s)) = id", "by auto"], ["proof (state)\nthis:\n  fst \\<circ> tree.root \\<circ> mkTree (stl (trim rs s)) = id\n\ngoal (1 subgoal):\n 1. \\<And>rs s.\n       \\<lbrakk>s \\<in> S; fair rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            mkTree rs s = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>rs s.\n                                    x = mkTree rs s \\<and>\n                                    s \\<in> S \\<and> fair rs) \\<or>\n                                local.wf x)", "hence \"effStep (root ?t) (fimage (fst \\<circ> root) (cont ?t))\""], ["proof (prove)\nusing this:\n  fst \\<circ> tree.root \\<circ> mkTree (stl (trim rs s)) = id\n\ngoal (1 subgoal):\n 1. effStep (tree.root (mkTree rs s))\n     ((fst \\<circ> tree.root) |`| cont (mkTree rs s))", "using trim_enabled[OF wf]"], ["proof (prove)\nusing this:\n  fst \\<circ> tree.root \\<circ> mkTree (stl (trim rs s)) = id\n  enabled (shd (trim rs s)) s\n\ngoal (1 subgoal):\n 1. effStep (tree.root (mkTree rs s))\n     ((fst \\<circ> tree.root) |`| cont (mkTree rs s))", "by (simp add: pickEff)"], ["proof (state)\nthis:\n  effStep (tree.root (mkTree rs s))\n   ((fst \\<circ> tree.root) |`| cont (mkTree rs s))\n\ngoal (1 subgoal):\n 1. \\<And>rs s.\n       \\<lbrakk>s \\<in> S; fair rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            mkTree rs s = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>rs s.\n                                    x = mkTree rs s \\<and>\n                                    s \\<in> S \\<and> fair rs) \\<or>\n                                local.wf x)", "ultimately"], ["proof (chain)\npicking this:\n  snd (tree.root (mkTree rs s)) \\<in> R\n  effStep (tree.root (mkTree rs s))\n   ((fst \\<circ> tree.root) |`| cont (mkTree rs s))", "show ?case"], ["proof (prove)\nusing this:\n  snd (tree.root (mkTree rs s)) \\<in> R\n  effStep (tree.root (mkTree rs s))\n   ((fst \\<circ> tree.root) |`| cont (mkTree rs s))\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       mkTree rs s = t \\<and>\n       snd (tree.root t) \\<in> R \\<and>\n       effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont t \\<longrightarrow>\n           (\\<exists>rs s.\n               x = mkTree rs s \\<and> s \\<in> S \\<and> fair rs) \\<or>\n           local.wf x)", "using fair_stl[OF trim_fair[OF wf]] in_cont_mkTree[OF wf]"], ["proof (prove)\nusing this:\n  snd (tree.root (mkTree rs s)) \\<in> R\n  effStep (tree.root (mkTree rs s))\n   ((fst \\<circ> tree.root) |`| cont (mkTree rs s))\n  fair (stl (trim rs s))\n  ?t' |\\<in>| cont (mkTree rs s) \\<Longrightarrow>\n  \\<exists>sl' s'.\n     s' \\<in> S \\<and>\n     eff (shd (trim rs s)) s sl' \\<and>\n     s' |\\<in>| sl' \\<and> ?t' = mkTree (stl (trim rs s)) s'\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       mkTree rs s = t \\<and>\n       snd (tree.root t) \\<in> R \\<and>\n       effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont t \\<longrightarrow>\n           (\\<exists>rs s.\n               x = mkTree rs s \\<and> s \\<in> S \\<and> fair rs) \\<or>\n           local.wf x)", "by (auto intro!: exI[of _ \"stl (trim rs s)\"])"], ["proof (state)\nthis:\n  \\<exists>t.\n     mkTree rs s = t \\<and>\n     snd (tree.root t) \\<in> R \\<and>\n     effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t) \\<and>\n     (\\<forall>x.\n         x |\\<in>| cont t \\<longrightarrow>\n         (\\<exists>rs s.\n             x = mkTree rs s \\<and> s \\<in> S \\<and> fair rs) \\<or>\n         local.wf x)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)(* The position of a rule in a rule stream *)(*>*)"], ["", "definition \"pos rs r \\<equiv> LEAST n. shd (sdrop n rs) = r\""], ["", "lemma pos: \"\\<lbrakk>fair rs; r \\<in> R\\<rbrakk> \\<Longrightarrow> shd (sdrop (pos rs r) rs) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fair rs; r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> shd (sdrop (pos rs r) rs) = r", "unfolding pos_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fair rs; r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> shd (sdrop (LEAST n. shd (sdrop n rs) = r) rs) = r", "by (rule LeastI_ex) (metis (full_types) alw.cases fair_def holds.simps sdrop_wait)"], ["", "lemma pos_least: \"shd (sdrop n rs) = r \\<Longrightarrow> pos rs r \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (sdrop n rs) = r \\<Longrightarrow> pos rs r \\<le> n", "unfolding pos_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (sdrop n rs) = r \\<Longrightarrow>\n    (LEAST n. shd (sdrop n rs) = r) \\<le> n", "by (metis (full_types) Least_le)"], ["", "lemma minWait_le_pos: \"\\<lbrakk>fair rs; r \\<in> R; enabled r s\\<rbrakk> \\<Longrightarrow> minWait rs s \\<le> pos rs r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fair rs; r \\<in> R; enabled r s\\<rbrakk>\n    \\<Longrightarrow> minWait rs s \\<le> pos rs r", "by (auto simp del: sdrop_simps intro: minWait_least simp: pos)"], ["", "lemma stake_pos_minWait:\n  assumes rs: \"fair rs\" and m: \"minWait rs s < pos rs r\" and r: \"r \\<in> R\" and s: \"s \\<in> S\"\n  shows \"pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)", "have \"pos rs r - Suc (minWait rs s) + minWait rs s = pos rs r - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos rs r - Suc (minWait rs s) + minWait rs s = pos rs r - Suc 0", "using m"], ["proof (prove)\nusing this:\n  minWait rs s < pos rs r\n\ngoal (1 subgoal):\n 1. pos rs r - Suc (minWait rs s) + minWait rs s = pos rs r - Suc 0", "by auto"], ["proof (state)\nthis:\n  pos rs r - Suc (minWait rs s) + minWait rs s = pos rs r - Suc 0\n\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)", "moreover"], ["proof (state)\nthis:\n  pos rs r - Suc (minWait rs s) + minWait rs s = pos rs r - Suc 0\n\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)", "have \"shd (stl (sdrop (pos rs r - Suc 0) rs)) = shd (sdrop (pos rs r) rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd (stl (sdrop (pos rs r - Suc 0) rs)) = shd (sdrop (pos rs r) rs)", "by (metis Suc_pred gr_implies_not0 m neq0_conv sdrop.simps(2) sdrop_stl)"], ["proof (state)\nthis:\n  shd (stl (sdrop (pos rs r - Suc 0) rs)) = shd (sdrop (pos rs r) rs)\n\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)", "ultimately"], ["proof (chain)\npicking this:\n  pos rs r - Suc (minWait rs s) + minWait rs s = pos rs r - Suc 0\n  shd (stl (sdrop (pos rs r - Suc 0) rs)) = shd (sdrop (pos rs r) rs)", "have \"pos (stl (trim rs s)) r \\<le> pos rs r - Suc (minWait rs s)\""], ["proof (prove)\nusing this:\n  pos rs r - Suc (minWait rs s) + minWait rs s = pos rs r - Suc 0\n  shd (stl (sdrop (pos rs r - Suc 0) rs)) = shd (sdrop (pos rs r) rs)\n\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r \\<le> pos rs r - Suc (minWait rs s)", "using pos[OF rs r]"], ["proof (prove)\nusing this:\n  pos rs r - Suc (minWait rs s) + minWait rs s = pos rs r - Suc 0\n  shd (stl (sdrop (pos rs r - Suc 0) rs)) = shd (sdrop (pos rs r) rs)\n  shd (sdrop (pos rs r) rs) = r\n\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r \\<le> pos rs r - Suc (minWait rs s)", "by (auto simp: add.commute trim_alt[OF s rs] intro: pos_least)"], ["proof (state)\nthis:\n  pos (stl (trim rs s)) r \\<le> pos rs r - Suc (minWait rs s)\n\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)", "moreover"], ["proof (state)\nthis:\n  pos (stl (trim rs s)) r \\<le> pos rs r - Suc (minWait rs s)\n\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)", "have \"pos rs r \\<le> pos (stl (trim rs s)) r + Suc (minWait rs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos rs r \\<le> pos (stl (trim rs s)) r + Suc (minWait rs s)", "using pos[OF sdrop_fair[OF fair_stl[OF rs]] r, of \"minWait rs s\"]"], ["proof (prove)\nusing this:\n  shd (sdrop (pos (sdrop (minWait rs s) (stl rs)) r)\n        (sdrop (minWait rs s) (stl rs))) =\n  r\n\ngoal (1 subgoal):\n 1. pos rs r \\<le> pos (stl (trim rs s)) r + Suc (minWait rs s)", "by (auto simp: trim_alt[OF s rs] add.commute intro: pos_least)"], ["proof (state)\nthis:\n  pos rs r \\<le> pos (stl (trim rs s)) r + Suc (minWait rs s)\n\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)", "hence \"pos rs r - Suc (minWait rs s) \\<le> pos (stl (trim rs s)) r\""], ["proof (prove)\nusing this:\n  pos rs r \\<le> pos (stl (trim rs s)) r + Suc (minWait rs s)\n\ngoal (1 subgoal):\n 1. pos rs r - Suc (minWait rs s) \\<le> pos (stl (trim rs s)) r", "by linarith"], ["proof (state)\nthis:\n  pos rs r - Suc (minWait rs s) \\<le> pos (stl (trim rs s)) r\n\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)", "ultimately"], ["proof (chain)\npicking this:\n  pos (stl (trim rs s)) r \\<le> pos rs r - Suc (minWait rs s)\n  pos rs r - Suc (minWait rs s) \\<le> pos (stl (trim rs s)) r", "show ?thesis"], ["proof (prove)\nusing this:\n  pos (stl (trim rs s)) r \\<le> pos rs r - Suc (minWait rs s)\n  pos rs r - Suc (minWait rs s) \\<le> pos (stl (trim rs s)) r\n\ngoal (1 subgoal):\n 1. pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)", "by simp"], ["proof (state)\nthis:\n  pos (stl (trim rs s)) r = pos rs r - Suc (minWait rs s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipath_mkTree_ev:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\"\n  and i: \"ipath (mkTree rs s) steps\" and r: \"r \\<in> R\"\n  and alw: \"alw (holds (enabledAtStep r)) steps\"\n  shows \"ev (holds (takenAtStep r)) steps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (holds (\\<lambda>step. snd step = r)) steps", "using s rs i alw"], ["proof (prove)\nusing this:\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps\n  alw (holds (enabledAtStep r)) steps\n\ngoal (1 subgoal):\n 1. ev (holds (\\<lambda>step. snd step = r)) steps", "proof (induction \"pos rs r\" arbitrary: rs s steps rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs s steps.\n       \\<lbrakk>\\<And>rsa s steps.\n                   \\<lbrakk>pos rsa r < pos rs r; s \\<in> S; fair rsa;\n                    ipath (mkTree rsa s) steps;\n                    alw (holds (enabledAtStep r)) steps\\<rbrakk>\n                   \\<Longrightarrow> ev\n(holds (\\<lambda>step. snd step = r)) steps;\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps;\n        alw (holds (enabledAtStep r)) steps\\<rbrakk>\n       \\<Longrightarrow> ev (holds (\\<lambda>step. snd step = r)) steps", "case (less rs s steps)"], ["proof (state)\nthis:\n  \\<lbrakk>pos ?rs1 r < pos rs r; ?s1 \\<in> S; fair ?rs1;\n   ipath (mkTree ?rs1 ?s1) ?steps1;\n   alw (holds (enabledAtStep r)) ?steps1\\<rbrakk>\n  \\<Longrightarrow> ev (holds (\\<lambda>step. snd step = r)) ?steps1\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps\n  alw (holds (enabledAtStep r)) steps\n\ngoal (1 subgoal):\n 1. \\<And>rs s steps.\n       \\<lbrakk>\\<And>rsa s steps.\n                   \\<lbrakk>pos rsa r < pos rs r; s \\<in> S; fair rsa;\n                    ipath (mkTree rsa s) steps;\n                    alw (holds (enabledAtStep r)) steps\\<rbrakk>\n                   \\<Longrightarrow> ev\n(holds (\\<lambda>step. snd step = r)) steps;\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps;\n        alw (holds (enabledAtStep r)) steps\\<rbrakk>\n       \\<Longrightarrow> ev (holds (\\<lambda>step. snd step = r)) steps", "note s = \\<open>s \\<in> S\\<close> and trim_def' = trim_alt[OF s \\<open>fair rs\\<close>]"], ["proof (state)\nthis:\n  s \\<in> S\n  trim rs s = sdrop (minWait rs s) rs\n\ngoal (1 subgoal):\n 1. \\<And>rs s steps.\n       \\<lbrakk>\\<And>rsa s steps.\n                   \\<lbrakk>pos rsa r < pos rs r; s \\<in> S; fair rsa;\n                    ipath (mkTree rsa s) steps;\n                    alw (holds (enabledAtStep r)) steps\\<rbrakk>\n                   \\<Longrightarrow> ev\n(holds (\\<lambda>step. snd step = r)) steps;\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps;\n        alw (holds (enabledAtStep r)) steps\\<rbrakk>\n       \\<Longrightarrow> ev (holds (\\<lambda>step. snd step = r)) steps", "let ?t = \"mkTree rs s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs s steps.\n       \\<lbrakk>\\<And>rsa s steps.\n                   \\<lbrakk>pos rsa r < pos rs r; s \\<in> S; fair rsa;\n                    ipath (mkTree rsa s) steps;\n                    alw (holds (enabledAtStep r)) steps\\<rbrakk>\n                   \\<Longrightarrow> ev\n(holds (\\<lambda>step. snd step = r)) steps;\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps;\n        alw (holds (enabledAtStep r)) steps\\<rbrakk>\n       \\<Longrightarrow> ev (holds (\\<lambda>step. snd step = r)) steps", "from less(4,3) s in_cont_mkTree"], ["proof (chain)\npicking this:\n  ipath (mkTree rs s) steps\n  fair rs\n  s \\<in> S\n  \\<lbrakk>?s \\<in> S; fair ?rs; ?t' |\\<in>| cont (mkTree ?rs ?s)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sl' s'.\n                       s' \\<in> S \\<and>\n                       eff (shd (trim ?rs ?s)) ?s sl' \\<and>\n                       s' |\\<in>| sl' \\<and>\n                       ?t' = mkTree (stl (trim ?rs ?s)) s'", "obtain t' :: \"('state, 'rule) step tree\" and s' where\n    rt: \"root ?t = shd steps\" and i: \"ipath (mkTree (stl (trim rs s)) s') (stl steps)\" and\n    s': \"s' \\<in> S\""], ["proof (prove)\nusing this:\n  ipath (mkTree rs s) steps\n  fair rs\n  s \\<in> S\n  \\<lbrakk>?s \\<in> S; fair ?rs; ?t' |\\<in>| cont (mkTree ?rs ?s)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sl' s'.\n                       s' \\<in> S \\<and>\n                       eff (shd (trim ?rs ?s)) ?s sl' \\<and>\n                       s' |\\<in>| sl' \\<and>\n                       ?t' = mkTree (stl (trim ?rs ?s)) s'\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>tree.root (mkTree rs s) = shd steps;\n         ipath (mkTree (stl (trim rs s)) s') (stl steps);\n         s' \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases fast"], ["proof (state)\nthis:\n  tree.root (mkTree rs s) = shd steps\n  ipath (mkTree (stl (trim rs s)) s') (stl steps)\n  s' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>rs s steps.\n       \\<lbrakk>\\<And>rsa s steps.\n                   \\<lbrakk>pos rsa r < pos rs r; s \\<in> S; fair rsa;\n                    ipath (mkTree rsa s) steps;\n                    alw (holds (enabledAtStep r)) steps\\<rbrakk>\n                   \\<Longrightarrow> ev\n(holds (\\<lambda>step. snd step = r)) steps;\n        s \\<in> S; fair rs; ipath (mkTree rs s) steps;\n        alw (holds (enabledAtStep r)) steps\\<rbrakk>\n       \\<Longrightarrow> ev (holds (\\<lambda>step. snd step = r)) steps", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (holds (\\<lambda>step. snd step = r)) steps", "proof(cases \"pos rs r = minWait rs s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pos rs r = minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps\n 2. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "case True"], ["proof (state)\nthis:\n  pos rs r = minWait rs s\n\ngoal (2 subgoals):\n 1. pos rs r = minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps\n 2. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "with pos[OF less.prems(2) r] rt[symmetric]"], ["proof (chain)\npicking this:\n  shd (sdrop (pos rs r) rs) = r\n  shd steps = tree.root (mkTree rs s)\n  pos rs r = minWait rs s", "show ?thesis"], ["proof (prove)\nusing this:\n  shd (sdrop (pos rs r) rs) = r\n  shd steps = tree.root (mkTree rs s)\n  pos rs r = minWait rs s\n\ngoal (1 subgoal):\n 1. ev (holds (\\<lambda>step. snd step = r)) steps", "by (auto simp: trim_def' ev.base)"], ["proof (state)\nthis:\n  ev (holds (\\<lambda>step. snd step = r)) steps\n\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "case False"], ["proof (state)\nthis:\n  pos rs r \\<noteq> minWait rs s\n\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "have e: \"enabled r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled r s", "using less.prems(4) rt"], ["proof (prove)\nusing this:\n  alw (holds (enabledAtStep r)) steps\n  tree.root (mkTree rs s) = shd steps\n\ngoal (1 subgoal):\n 1. enabled r s", "by (subst (asm) alw_nxt, cases steps) auto"], ["proof (state)\nthis:\n  enabled r s\n\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "with False r less.prems(2)"], ["proof (chain)\npicking this:\n  pos rs r \\<noteq> minWait rs s\n  r \\<in> R\n  fair rs\n  enabled r s", "have 2: \"minWait rs s < pos rs r\""], ["proof (prove)\nusing this:\n  pos rs r \\<noteq> minWait rs s\n  r \\<in> R\n  fair rs\n  enabled r s\n\ngoal (1 subgoal):\n 1. minWait rs s < pos rs r", "using minWait_le_pos"], ["proof (prove)\nusing this:\n  pos rs r \\<noteq> minWait rs s\n  r \\<in> R\n  fair rs\n  enabled r s\n  \\<lbrakk>fair ?rs; ?r \\<in> R; enabled ?r ?s\\<rbrakk>\n  \\<Longrightarrow> minWait ?rs ?s \\<le> pos ?rs ?r\n\ngoal (1 subgoal):\n 1. minWait rs s < pos rs r", "by force"], ["proof (state)\nthis:\n  minWait rs s < pos rs r\n\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "let ?m1 = \"pos rs r - Suc (minWait rs s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "have \"Suc ?m1 \\<le> pos rs r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (pos rs r - Suc (minWait rs s)) \\<le> pos rs r", "using 2"], ["proof (prove)\nusing this:\n  minWait rs s < pos rs r\n\ngoal (1 subgoal):\n 1. Suc (pos rs r - Suc (minWait rs s)) \\<le> pos rs r", "by auto"], ["proof (state)\nthis:\n  Suc (pos rs r - Suc (minWait rs s)) \\<le> pos rs r\n\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "moreover"], ["proof (state)\nthis:\n  Suc (pos rs r - Suc (minWait rs s)) \\<le> pos rs r\n\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "have \"?m1 = pos (stl (trim rs s)) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos rs r - Suc (minWait rs s) = pos (stl (trim rs s)) r", "using e \\<open>fair rs\\<close> 2 r s"], ["proof (prove)\nusing this:\n  enabled r s\n  fair rs\n  minWait rs s < pos rs r\n  r \\<in> R\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. pos rs r - Suc (minWait rs s) = pos (stl (trim rs s)) r", "by (auto intro: stake_pos_minWait[symmetric])"], ["proof (state)\nthis:\n  pos rs r - Suc (minWait rs s) = pos (stl (trim rs s)) r\n\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "moreover"], ["proof (state)\nthis:\n  pos rs r - Suc (minWait rs s) = pos (stl (trim rs s)) r\n\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "have \"fair (stl (trim rs s))\" \"alw (holds (enabledAtStep r)) (stl steps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fair (stl (trim rs s)) &&& alw (holds (enabledAtStep r)) (stl steps)", "using less.prems"], ["proof (prove)\nusing this:\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps\n  alw (holds (enabledAtStep r)) steps\n\ngoal (1 subgoal):\n 1. fair (stl (trim rs s)) &&& alw (holds (enabledAtStep r)) (stl steps)", "by (metis fair_stl trim_fair, metis alw.simps)"], ["proof (state)\nthis:\n  fair (stl (trim rs s))\n  alw (holds (enabledAtStep r)) (stl steps)\n\ngoal (1 subgoal):\n 1. pos rs r \\<noteq> minWait rs s \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "ultimately"], ["proof (chain)\npicking this:\n  Suc (pos rs r - Suc (minWait rs s)) \\<le> pos rs r\n  pos rs r - Suc (minWait rs s) = pos (stl (trim rs s)) r\n  fair (stl (trim rs s))\n  alw (holds (enabledAtStep r)) (stl steps)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Suc (pos rs r - Suc (minWait rs s)) \\<le> pos rs r\n  pos rs r - Suc (minWait rs s) = pos (stl (trim rs s)) r\n  fair (stl (trim rs s))\n  alw (holds (enabledAtStep r)) (stl steps)\n\ngoal (1 subgoal):\n 1. ev (holds (\\<lambda>step. snd step = r)) steps", "by (auto intro: ev.step[OF less.hyps[OF _ s' _ i]])"], ["proof (state)\nthis:\n  ev (holds (\\<lambda>step. snd step = r)) steps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ev (holds (\\<lambda>step. snd step = r)) steps\n\ngoal:\nNo subgoals!", "qed"], ["", "section\\<open>Persistent rules\\<close>"], ["", "definition\n  \"per r \\<equiv>\n    \\<forall>s r1 sl' s'. s \\<in> S \\<and> enabled r s \\<and> r1 \\<in> R - {r} \\<and> eff r1 s sl' \\<and> s' |\\<in>| sl' \\<longrightarrow> enabled r s'\""], ["", "lemma per_alw:\n  assumes p: \"per r\" and e: \"epath steps \\<and> fst (shd steps) \\<in> S\"\n  shows \"alw (holds (enabledAtStep r) impl\n    (holds (takenAtStep r) or nxt (holds (enabledAtStep r)))) steps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs.\n            holds (enabledAtStep r) xs \\<longrightarrow>\n            holds (\\<lambda>step. snd step = r) xs \\<or>\n            nxt (holds (enabledAtStep r)) xs)\n     steps", "using e"], ["proof (prove)\nusing this:\n  epath steps \\<and> fst (shd steps) \\<in> S\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs.\n            holds (enabledAtStep r) xs \\<longrightarrow>\n            holds (\\<lambda>step. snd step = r) xs \\<or>\n            nxt (holds (enabledAtStep r)) xs)\n     steps", "proof coinduct"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "case (alw steps)"], ["proof (state)\nthis:\n  epath steps \\<and> fst (shd steps) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "moreover"], ["proof (state)\nthis:\n  epath steps \\<and> fst (shd steps) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "{"], ["proof (state)\nthis:\n  epath steps \\<and> fst (shd steps) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "let ?s = \"fst (shd steps)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "let ?r1 = \"snd (shd steps)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "let ?s' = \"fst (shd (stl steps))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "assume \"?s \\<in> S\" and \"enabled r ?s\" and \"?r1 \\<noteq> r\""], ["proof (state)\nthis:\n  fst (shd steps) \\<in> S\n  enabledAtStep r (shd steps)\n  snd (shd steps) \\<noteq> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "moreover"], ["proof (state)\nthis:\n  fst (shd steps) \\<in> S\n  enabledAtStep r (shd steps)\n  snd (shd steps) \\<noteq> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "have \"?r1 \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (shd steps) \\<in> R", "using alw"], ["proof (prove)\nusing this:\n  epath steps \\<and> fst (shd steps) \\<in> S\n\ngoal (1 subgoal):\n 1. snd (shd steps) \\<in> R", "by (auto elim: epath.cases)"], ["proof (state)\nthis:\n  snd (shd steps) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "moreover"], ["proof (state)\nthis:\n  snd (shd steps) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "obtain sl' where \"eff ?r1 ?s sl' \\<and> ?s' |\\<in>| sl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sl'.\n        effStep (shd steps) sl' \\<and>\n        fst (shd (stl steps)) |\\<in>| sl' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using alw"], ["proof (prove)\nusing this:\n  epath steps \\<and> fst (shd steps) \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>sl'.\n        effStep (shd steps) sl' \\<and>\n        fst (shd (stl steps)) |\\<in>| sl' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: epath.cases)"], ["proof (state)\nthis:\n  effStep (shd steps) sl' \\<and> fst (shd (stl steps)) |\\<in>| sl'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "ultimately"], ["proof (chain)\npicking this:\n  fst (shd steps) \\<in> S\n  enabledAtStep r (shd steps)\n  snd (shd steps) \\<noteq> r\n  snd (shd steps) \\<in> R\n  effStep (shd steps) sl' \\<and> fst (shd (stl steps)) |\\<in>| sl'", "have \"enabled r ?s'\""], ["proof (prove)\nusing this:\n  fst (shd steps) \\<in> S\n  enabledAtStep r (shd steps)\n  snd (shd steps) \\<noteq> r\n  snd (shd steps) \\<in> R\n  effStep (shd steps) sl' \\<and> fst (shd (stl steps)) |\\<in>| sl'\n\ngoal (1 subgoal):\n 1. enabledAtStep r (shd (stl steps))", "using p"], ["proof (prove)\nusing this:\n  fst (shd steps) \\<in> S\n  enabledAtStep r (shd steps)\n  snd (shd steps) \\<noteq> r\n  snd (shd steps) \\<in> R\n  effStep (shd steps) sl' \\<and> fst (shd (stl steps)) |\\<in>| sl'\n  per r\n\ngoal (1 subgoal):\n 1. enabledAtStep r (shd (stl steps))", "unfolding per_def"], ["proof (prove)\nusing this:\n  fst (shd steps) \\<in> S\n  enabledAtStep r (shd steps)\n  snd (shd steps) \\<noteq> r\n  snd (shd steps) \\<in> R\n  effStep (shd steps) sl' \\<and> fst (shd (stl steps)) |\\<in>| sl'\n  \\<forall>s r1 sl' s'.\n     s \\<in> S \\<and>\n     enabled r s \\<and>\n     r1 \\<in> R - {r} \\<and>\n     eff r1 s sl' \\<and> s' |\\<in>| sl' \\<longrightarrow>\n     enabled r s'\n\ngoal (1 subgoal):\n 1. enabledAtStep r (shd (stl steps))", "by blast"], ["proof (state)\nthis:\n  enabledAtStep r (shd (stl steps))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>fst (shd steps) \\<in> S; enabledAtStep r (shd steps);\n   snd (shd steps) \\<noteq> r\\<rbrakk>\n  \\<Longrightarrow> enabledAtStep r (shd (stl steps))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       epath x \\<and> fst (shd x) \\<in> S \\<Longrightarrow>\n       \\<exists>xs.\n          x = xs \\<and>\n          (holds (enabledAtStep r) xs \\<longrightarrow>\n           holds (\\<lambda>step. snd step = r) xs \\<or>\n           nxt (holds (enabledAtStep r)) xs) \\<and>\n          (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n           alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   holds (\\<lambda>step. snd step = r) xs \\<or>\n                   nxt (holds (enabledAtStep r)) xs)\n            (stl xs))", "ultimately"], ["proof (chain)\npicking this:\n  epath steps \\<and> fst (shd steps) \\<in> S\n  \\<lbrakk>fst (shd steps) \\<in> S; enabledAtStep r (shd steps);\n   snd (shd steps) \\<noteq> r\\<rbrakk>\n  \\<Longrightarrow> enabledAtStep r (shd (stl steps))", "show ?case"], ["proof (prove)\nusing this:\n  epath steps \\<and> fst (shd steps) \\<in> S\n  \\<lbrakk>fst (shd steps) \\<in> S; enabledAtStep r (shd steps);\n   snd (shd steps) \\<noteq> r\\<rbrakk>\n  \\<Longrightarrow> enabledAtStep r (shd (stl steps))\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       steps = xs \\<and>\n       (holds (enabledAtStep r) xs \\<longrightarrow>\n        holds (\\<lambda>step. snd step = r) xs \\<or>\n        nxt (holds (enabledAtStep r)) xs) \\<and>\n       (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n        alw (\\<lambda>xs.\n                holds (enabledAtStep r) xs \\<longrightarrow>\n                holds (\\<lambda>step. snd step = r) xs \\<or>\n                nxt (holds (enabledAtStep r)) xs)\n         (stl xs))", "by (auto intro: eff_S elim: epath.cases)"], ["proof (state)\nthis:\n  \\<exists>xs.\n     steps = xs \\<and>\n     (holds (enabledAtStep r) xs \\<longrightarrow>\n      holds (\\<lambda>step. snd step = r) xs \\<or>\n      nxt (holds (enabledAtStep r)) xs) \\<and>\n     (epath (stl xs) \\<and> fst (shd (stl xs)) \\<in> S \\<or>\n      alw (\\<lambda>xs.\n              holds (enabledAtStep r) xs \\<longrightarrow>\n              holds (\\<lambda>step. snd step = r) xs \\<or>\n              nxt (holds (enabledAtStep r)) xs)\n       (stl xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>context RuleSystem\\<close>"], ["", "(*<*) (* Rule-persistent rule system *) (*>*)"], ["", "locale PersistentRuleSystem = RuleSystem eff rules S\nfor eff :: \"'rule \\<Rightarrow> 'state \\<Rightarrow> 'state fset \\<Rightarrow> bool\" and rules :: \"'rule stream\" and S +\nassumes per: \"\\<And> r. r \\<in> R \\<Longrightarrow> per r\"\nbegin"], ["", "lemma ipath_mkTree_saturated:\n  assumes s: \"s \\<in> S\" and rs: \"fair rs\"\n  and i: \"ipath (mkTree rs s) steps\" and r: \"r \\<in> R\"\n  shows \"saturated r steps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated r steps", "unfolding saturated_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs.\n            holds (enabledAtStep r) xs \\<longrightarrow>\n            ev (holds (\\<lambda>step. snd step = r)) xs)\n     steps", "using s rs i"], ["proof (prove)\nusing this:\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs.\n            holds (enabledAtStep r) xs \\<longrightarrow>\n            ev (holds (\\<lambda>step. snd step = r)) xs)\n     steps", "proof (coinduction arbitrary: rs s steps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs s steps.\n       \\<lbrakk>s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            steps = xs \\<and>\n                            (holds (enabledAtStep r) xs \\<longrightarrow>\n                             ev (holds (\\<lambda>step. snd step = r))\n                              xs) \\<and>\n                            ((\\<exists>rs s steps.\n                                 stl xs = steps \\<and>\n                                 s \\<in> S \\<and>\n                                 fair rs \\<and>\n                                 ipath (mkTree rs s) steps) \\<or>\n                             alw (\\<lambda>xs.\n                                     holds (enabledAtStep r)\nxs \\<longrightarrow>\n                                     ev\n(holds (\\<lambda>step. snd step = r)) xs)\n                              (stl xs))", "case (alw rs s steps)"], ["proof (state)\nthis:\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps\n\ngoal (1 subgoal):\n 1. \\<And>rs s steps.\n       \\<lbrakk>s \\<in> S; fair rs; ipath (mkTree rs s) steps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            steps = xs \\<and>\n                            (holds (enabledAtStep r) xs \\<longrightarrow>\n                             ev (holds (\\<lambda>step. snd step = r))\n                              xs) \\<and>\n                            ((\\<exists>rs s steps.\n                                 stl xs = steps \\<and>\n                                 s \\<in> S \\<and>\n                                 fair rs \\<and>\n                                 ipath (mkTree rs s) steps) \\<or>\n                             alw (\\<lambda>xs.\n                                     holds (enabledAtStep r)\nxs \\<longrightarrow>\n                                     ev\n(holds (\\<lambda>step. snd step = r)) xs)\n                              (stl xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       steps = xs \\<and>\n       (holds (enabledAtStep r) xs \\<longrightarrow>\n        ev (holds (\\<lambda>step. snd step = r)) xs) \\<and>\n       ((\\<exists>rs s steps.\n            stl xs = steps \\<and>\n            s \\<in> S \\<and> fair rs \\<and> ipath (mkTree rs s) steps) \\<or>\n        alw (\\<lambda>xs.\n                holds (enabledAtStep r) xs \\<longrightarrow>\n                ev (holds (\\<lambda>step. snd step = r)) xs)\n         (stl xs))", "proof (intro exI[of _ steps], safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. holds (enabledAtStep r) steps \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps\n 2. \\<not> alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   ev (holds (\\<lambda>step. snd step = r)) xs)\n            (stl steps) \\<Longrightarrow>\n    \\<exists>rs s steps.\n       stl steps = steps \\<and>\n       s \\<in> S \\<and> fair rs \\<and> ipath (mkTree rs s) steps", "assume \"holds (enabledAtStep r) steps\""], ["proof (state)\nthis:\n  holds (enabledAtStep r) steps\n\ngoal (2 subgoals):\n 1. holds (enabledAtStep r) steps \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps\n 2. \\<not> alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   ev (holds (\\<lambda>step. snd step = r)) xs)\n            (stl steps) \\<Longrightarrow>\n    \\<exists>rs s steps.\n       stl steps = steps \\<and>\n       s \\<in> S \\<and> fair rs \\<and> ipath (mkTree rs s) steps", "hence \"alw (holds (enabledAtStep r)) steps \\<or> ev (holds (takenAtStep r)) steps\""], ["proof (prove)\nusing this:\n  holds (enabledAtStep r) steps\n\ngoal (1 subgoal):\n 1. alw (holds (enabledAtStep r)) steps \\<or>\n    ev (holds (\\<lambda>step. snd step = r)) steps", "by (rule variance[OF _ per_alw[OF per[OF r]]])\n        (metis wf_ipath_epath wf_mkTree alw mkTree.simps(1) ipath.simps fst_conv)"], ["proof (state)\nthis:\n  alw (holds (enabledAtStep r)) steps \\<or>\n  ev (holds (\\<lambda>step. snd step = r)) steps\n\ngoal (2 subgoals):\n 1. holds (enabledAtStep r) steps \\<Longrightarrow>\n    ev (holds (\\<lambda>step. snd step = r)) steps\n 2. \\<not> alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   ev (holds (\\<lambda>step. snd step = r)) xs)\n            (stl steps) \\<Longrightarrow>\n    \\<exists>rs s steps.\n       stl steps = steps \\<and>\n       s \\<in> S \\<and> fair rs \\<and> ipath (mkTree rs s) steps", "thus \"ev (holds (takenAtStep r)) steps\""], ["proof (prove)\nusing this:\n  alw (holds (enabledAtStep r)) steps \\<or>\n  ev (holds (\\<lambda>step. snd step = r)) steps\n\ngoal (1 subgoal):\n 1. ev (holds (\\<lambda>step. snd step = r)) steps", "by (metis ipath_mkTree_ev[OF alw r])"], ["proof (state)\nthis:\n  ev (holds (\\<lambda>step. snd step = r)) steps\n\ngoal (1 subgoal):\n 1. \\<not> alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   ev (holds (\\<lambda>step. snd step = r)) xs)\n            (stl steps) \\<Longrightarrow>\n    \\<exists>rs s steps.\n       stl steps = steps \\<and>\n       s \\<in> S \\<and> fair rs \\<and> ipath (mkTree rs s) steps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> alw (\\<lambda>xs.\n                   holds (enabledAtStep r) xs \\<longrightarrow>\n                   ev (holds (\\<lambda>step. snd step = r)) xs)\n            (stl steps) \\<Longrightarrow>\n    \\<exists>rs s steps.\n       stl steps = steps \\<and>\n       s \\<in> S \\<and> fair rs \\<and> ipath (mkTree rs s) steps", "from alw"], ["proof (chain)\npicking this:\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps", "show \"\\<exists>rs' s' steps'.\n      stl steps = steps' \\<and> s' \\<in> S \\<and> fair rs' \\<and> ipath (mkTree rs' s') steps'\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps\n\ngoal (1 subgoal):\n 1. \\<exists>rs' s' steps'.\n       stl steps = steps' \\<and>\n       s' \\<in> S \\<and> fair rs' \\<and> ipath (mkTree rs' s') steps'", "using ipath_mkTree_sdrop[where m=1, simplified] trim_in_R sdrop_fair"], ["proof (prove)\nusing this:\n  s \\<in> S\n  fair rs\n  ipath (mkTree rs s) steps\n  \\<lbrakk>?s \\<in> S; fair ?rs; ipath (mkTree ?rs ?s) ?steps\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n s'.\n                       s' \\<in> S \\<and>\n                       ipath (mkTree (sdrop n ?rs) s') (stl ?steps)\n  \\<lbrakk>?s \\<in> S; fair ?rs\\<rbrakk>\n  \\<Longrightarrow> shd (trim ?rs ?s) \\<in> R\n  fair ?rs \\<Longrightarrow> fair (sdrop ?m ?rs)\n\ngoal (1 subgoal):\n 1. \\<exists>rs' s' steps'.\n       stl steps = steps' \\<and>\n       s' \\<in> S \\<and> fair rs' \\<and> ipath (mkTree rs' s') steps'", "by fast"], ["proof (state)\nthis:\n  \\<exists>rs' s' steps'.\n     stl steps = steps' \\<and>\n     s' \\<in> S \\<and> fair rs' \\<and> ipath (mkTree rs' s') steps'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     steps = xs \\<and>\n     (holds (enabledAtStep r) xs \\<longrightarrow>\n      ev (holds (\\<lambda>step. snd step = r)) xs) \\<and>\n     ((\\<exists>rs s steps.\n          stl xs = steps \\<and>\n          s \\<in> S \\<and> fair rs \\<and> ipath (mkTree rs s) steps) \\<or>\n      alw (\\<lambda>xs.\n              holds (enabledAtStep r) xs \\<longrightarrow>\n              ev (holds (\\<lambda>step. snd step = r)) xs)\n       (stl xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ipath_mkTree_Saturated:\n  assumes \"s \\<in> S\" and \"fair rs\" and \"ipath (mkTree rs s) steps\"\n  shows \"Saturated steps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Saturated steps", "unfolding Saturated_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>R. saturated r steps", "using ipath_mkTree_saturated[OF assms]"], ["proof (prove)\nusing this:\n  ?r \\<in> R \\<Longrightarrow> saturated ?r steps\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>R. saturated r steps", "by blast"], ["", "theorem epath_completeness_Saturated:\n  assumes \"s \\<in> S\"\n  shows\n  \"(\\<exists> t. fst (root t) = s \\<and> wf t \\<and> tfinite t) \\<or>\n   (\\<exists> steps. fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)\" (is \"?A \\<or> ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n    (\\<exists>steps.\n        fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n    (\\<exists>steps.\n        fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n    (\\<exists>steps.\n        fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)", "assume \"\\<not> ?A\""], ["proof (state)\nthis:\n  \\<nexists>t. fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t\n\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n    (\\<exists>steps.\n        fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)", "with assms"], ["proof (chain)\npicking this:\n  s \\<in> S\n  \\<nexists>t. fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t", "have \"\\<not> tfinite (mkTree fenum s)\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  \\<nexists>t. fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (mkTree fenum s)", "using wf_mkTree fair_fenum"], ["proof (prove)\nusing this:\n  s \\<in> S\n  \\<nexists>t. fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t\n  \\<lbrakk>?s \\<in> S; fair ?rs\\<rbrakk>\n  \\<Longrightarrow> local.wf (mkTree ?rs ?s)\n  fair fenum\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (mkTree fenum s)", "by auto"], ["proof (state)\nthis:\n  \\<not> tfinite (mkTree fenum s)\n\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n    (\\<exists>steps.\n        fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)", "then"], ["proof (chain)\npicking this:\n  \\<not> tfinite (mkTree fenum s)", "obtain steps where \"ipath (mkTree fenum s) steps\""], ["proof (prove)\nusing this:\n  \\<not> tfinite (mkTree fenum s)\n\ngoal (1 subgoal):\n 1. (\\<And>steps.\n        ipath (mkTree fenum s) steps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Konig"], ["proof (prove)\nusing this:\n  \\<not> tfinite (mkTree fenum s)\n  \\<not> tfinite ?t \\<Longrightarrow> ipath ?t (konig ?t)\n\ngoal (1 subgoal):\n 1. (\\<And>steps.\n        ipath (mkTree fenum s) steps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ipath (mkTree fenum s) steps\n\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n    (\\<exists>steps.\n        fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)", "with assms"], ["proof (chain)\npicking this:\n  s \\<in> S\n  ipath (mkTree fenum s) steps", "have \"fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  ipath (mkTree fenum s) steps\n\ngoal (1 subgoal):\n 1. fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps", "by (metis wf_ipath_epath ipath.simps ipath_mkTree_Saturated\n        wf_mkTree fair_fenum mkTree.simps(1) fst_conv)"], ["proof (state)\nthis:\n  fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps\n\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n    (\\<exists>steps.\n        fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)", "hence ?B"], ["proof (prove)\nusing this:\n  fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps\n\ngoal (1 subgoal):\n 1. \\<exists>steps.\n       fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps", "by blast"], ["proof (state)\nthis:\n  \\<exists>steps.\n     fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps\n\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n    (\\<exists>steps.\n        fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)", "}"], ["proof (state)\nthis:\n  \\<nexists>t.\n     fst (tree.root t) = s \\<and>\n     local.wf t \\<and> tfinite t \\<Longrightarrow>\n  \\<exists>steps.\n     fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps\n\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n    (\\<exists>steps.\n        fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>t.\n     fst (tree.root t) = s \\<and>\n     local.wf t \\<and> tfinite t \\<Longrightarrow>\n  \\<exists>steps.\n     fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps\n\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n    (\\<exists>steps.\n        fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>t.\n      fst (tree.root t) = s \\<and> local.wf t \\<and> tfinite t) \\<or>\n  (\\<exists>steps.\n      fst (shd steps) = s \\<and> epath steps \\<and> Saturated steps)\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>context PersistentRuleSystem\\<close>"], ["", "section\\<open>Code generation\\<close>"], ["", "(* Here we assume a deterministic effect eff': *)"], ["", "locale RuleSystem_Code =\nfixes eff' :: \"'rule \\<Rightarrow> 'state \\<Rightarrow> 'state fset option\"\nand rules :: \"'rule stream\" \\<comment> \\<open>countably many rules\\<close>\nbegin"], ["", "definition \"eff r s sl \\<equiv> eff' r s = Some sl\""], ["", "end"], ["", "(* context RuleSystem_Code *)"], ["", "definition [code del]: \"effG eff' r s sl \\<equiv> RuleSystem_Code.eff eff' r s sl\""], ["", "sublocale RuleSystem_Code < RuleSystem_Defs\n  where eff = \"effG eff'\" and rules = rules"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context RuleSystem_Code\nbegin"], ["", "lemma enabled_eff': \"enabled r s \\<longleftrightarrow> eff' r s \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled r s = (eff' r s \\<noteq> None)", "unfolding enabled_def effG_def eff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>sl. eff' r s = Some sl) = (eff' r s \\<noteq> None)", "by auto"], ["", "lemma pickEff_the[code]: \"pickEff r s = the (eff' r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pickEff r s = the (eff' r s)", "unfolding pickEff_def enabled_def effG_def eff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>sl. eff' r s = Some sl then SOME sl. eff' r s = Some sl\n     else the None) =\n    the (eff' r s)", "by auto"], ["", "lemmas [code_unfold] = trim_def enabled_eff' pickEff_the"], ["", "(*<*)"], ["", "end"], ["", "(* context RuleSystem_Code *)\n(*>*)"], ["", "setup Locale_Code.open_block"], ["", "interpretation i: RuleSystem_Code eff' rules for eff' and rules"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare [[lc_delete \"RuleSystem_Defs.mkTree (effG ?eff')\"]]"], ["", "declare [[lc_delete RuleSystem_Defs.trim]]"], ["", "declare [[lc_delete RuleSystem_Defs.enabled]]"], ["", "declare [[lc_delete RuleSystem_Defs.pickEff]]"], ["", "declare [[lc_add \"RuleSystem_Defs.mkTree (effG ?eff')\" i.mkTree_unfold]]"], ["", "setup Locale_Code.close_block"], ["", "code_printing\n  constant the \\<rightharpoonup> (Haskell) \"fromJust\"\n| constant Option.is_none \\<rightharpoonup> (Haskell) \"isNothing\""], ["", "export_code mkTree_effG_uu in Haskell module_name Tree"], ["", "(*file \".\"*)\n\n(*<*)"], ["", "end"], ["", "(*>*)"]]}