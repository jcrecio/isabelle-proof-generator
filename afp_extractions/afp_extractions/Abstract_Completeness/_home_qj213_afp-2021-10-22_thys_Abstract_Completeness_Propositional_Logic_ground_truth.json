{"file_name": "/home/qj213/afp-2021-10-22/thys/Abstract_Completeness/Propositional_Logic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Abstract_Completeness", "problem_names": ["lemma max_depth_0: \"max_depth \\<phi> = 0 = (\\<exists>n. \\<phi> = Atom n)\"", "lemma max_depth_Suc: \"max_depth \\<phi> = Suc n = ((\\<exists>\\<psi>. \\<phi> = Neg \\<psi> \\<and> max_depth \\<psi> = n) \\<or>\n  (\\<exists>\\<psi>1 \\<psi>2. \\<phi> = Conj \\<psi>1 \\<psi>2 \\<and> max (max_depth \\<psi>1) (max_depth \\<psi>2) = n))\"", "lemma extendLevel_step:\n  \"\\<lbrakk>sset belowN = {\\<phi>. max_depth \\<phi> < n};\n    sset N = {\\<phi>. max_depth \\<phi> = n}; st = (belowN, N)\\<rbrakk> \\<Longrightarrow>\n  \\<exists>belowNext Next. extendLevel st = (belowNext, Next) \\<and>\n     sset belowNext = {\\<phi>. max_depth \\<phi> < Suc n} \\<and> sset Next = {\\<phi>. max_depth \\<phi> = Suc n}\"", "lemma sset_atoms: \"sset atoms = {\\<phi>. max_depth \\<phi> < 1}\"", "lemma sset_depth1: \"sset depth1 = {\\<phi>. max_depth \\<phi> = 1}\"", "lemma extendLevel_Nsteps:\n  \"\\<lbrakk>sset belowN = {\\<phi>. max_depth \\<phi> < n}; sset N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk> \\<Longrightarrow>\n  \\<exists>belowNext Next. (extendLevel ^^ m) (belowN, N) = (belowNext, Next) \\<and>\n     sset belowNext = {\\<phi>. max_depth \\<phi> < n + m} \\<and> sset Next = {\\<phi>. max_depth \\<phi> = n + m}\"", "lemma fmlas_UNIV: \"sset fmlas = (UNIV :: fmla set)\"", "lemma rules_UNIV: \"sset rules = (UNIV :: rule set)\"", "lemma [code]: \"Stream.smember x (y ## s) = (x = y \\<or> Stream.smember x s)\""], "translations": [["", "lemma max_depth_0: \"max_depth \\<phi> = 0 = (\\<exists>n. \\<phi> = Atom n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (max_depth \\<phi> = 0) = (\\<exists>n. \\<phi> = Atom n)", "by (cases \\<phi>) auto"], ["", "lemma max_depth_Suc: \"max_depth \\<phi> = Suc n = ((\\<exists>\\<psi>. \\<phi> = Neg \\<psi> \\<and> max_depth \\<psi> = n) \\<or>\n  (\\<exists>\\<psi>1 \\<psi>2. \\<phi> = Conj \\<psi>1 \\<psi>2 \\<and> max (max_depth \\<psi>1) (max_depth \\<psi>2) = n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (max_depth \\<phi> = Suc n) =\n    ((\\<exists>\\<psi>.\n         \\<phi> = Neg \\<psi> \\<and> max_depth \\<psi> = n) \\<or>\n     (\\<exists>\\<psi>1 \\<psi>2.\n         \\<phi> = Conj \\<psi>1 \\<psi>2 \\<and>\n         max (max_depth \\<psi>1) (max_depth \\<psi>2) = n))", "by (cases \\<phi>) auto"], ["", "abbreviation \"atoms \\<equiv> smap Atom nats\""], ["", "abbreviation \"depth1 \\<equiv>\n  sinterleave (smap Neg atoms) (smap (case_prod Conj) (sproduct atoms atoms))\""], ["", "abbreviation \"sinterleaves \\<equiv> fold sinterleave\""], ["", "fun extendLevel where \"extendLevel (belowN, N) =\n  (let Next = sinterleaves\n    (map (smap (case_prod Conj)) [sproduct belowN N, sproduct N belowN, sproduct N N])\n    (smap Neg N)\n  in (sinterleave belowN N, Next))\""], ["", "lemma extendLevel_step:\n  \"\\<lbrakk>sset belowN = {\\<phi>. max_depth \\<phi> < n};\n    sset N = {\\<phi>. max_depth \\<phi> = n}; st = (belowN, N)\\<rbrakk> \\<Longrightarrow>\n  \\<exists>belowNext Next. extendLevel st = (belowNext, Next) \\<and>\n     sset belowNext = {\\<phi>. max_depth \\<phi> < Suc n} \\<and> sset Next = {\\<phi>. max_depth \\<phi> = Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n     i.R N = {\\<phi>. max_depth \\<phi> = n}; st = (belowN, N)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>belowNext Next.\n                         extendLevel st = (belowNext, Next) \\<and>\n                         i.R belowNext =\n                         {\\<phi>. max_depth \\<phi> < Suc n} \\<and>\n                         i.R Next = {\\<phi>. max_depth \\<phi> = Suc n}", "by (auto simp: sset_sinterleave sset_sproduct stream.set_map\n    image_iff max_depth_Suc)"], ["", "lemma sset_atoms: \"sset atoms = {\\<phi>. max_depth \\<phi> < 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.R atoms = {\\<phi>. max_depth \\<phi> < 1}", "by (auto simp: stream.set_map max_depth_0)"], ["", "lemma sset_depth1: \"sset depth1 = {\\<phi>. max_depth \\<phi> = 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.R depth1 = {\\<phi>. max_depth \\<phi> = 1}", "by (auto simp: sset_sinterleave sset_sproduct stream.set_map\n    max_depth_Suc max_depth_0 max_def image_iff)"], ["", "lemma extendLevel_Nsteps:\n  \"\\<lbrakk>sset belowN = {\\<phi>. max_depth \\<phi> < n}; sset N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk> \\<Longrightarrow>\n  \\<exists>belowNext Next. (extendLevel ^^ m) (belowN, N) = (belowNext, Next) \\<and>\n     sset belowNext = {\\<phi>. max_depth \\<phi> < n + m} \\<and> sset Next = {\\<phi>. max_depth \\<phi> = n + m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n     i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>belowNext Next.\n                         (extendLevel ^^ m) (belowN, N) =\n                         (belowNext, Next) \\<and>\n                         i.R belowNext =\n                         {\\<phi>. max_depth \\<phi> < n + m} \\<and>\n                         i.R Next = {\\<phi>. max_depth \\<phi> = n + m}", "proof (induction m arbitrary: belowN N n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>belowN N n.\n       \\<lbrakk>i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n        i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>belowNext Next.\n                            (extendLevel ^^ 0) (belowN, N) =\n                            (belowNext, Next) \\<and>\n                            i.R belowNext =\n                            {\\<phi>. max_depth \\<phi> < n + 0} \\<and>\n                            i.R Next = {\\<phi>. max_depth \\<phi> = n + 0}\n 2. \\<And>m belowN N n.\n       \\<lbrakk>\\<And>belowN N n.\n                   \\<lbrakk>i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n                    i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>belowNext Next.\n  (extendLevel ^^ m) (belowN, N) = (belowNext, Next) \\<and>\n  i.R belowNext = {\\<phi>. max_depth \\<phi> < n + m} \\<and>\n  i.R Next = {\\<phi>. max_depth \\<phi> = n + m};\n        i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n        i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>belowNext Next.\n                            (extendLevel ^^ Suc m) (belowN, N) =\n                            (belowNext, Next) \\<and>\n                            i.R belowNext =\n                            {\\<phi>. max_depth \\<phi> < n + Suc m} \\<and>\n                            i.R Next =\n                            {\\<phi>. max_depth \\<phi> = n + Suc m}", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>i.R ?belowN = {\\<phi>. max_depth \\<phi> < ?n};\n   i.R ?N = {\\<phi>. max_depth \\<phi> = ?n}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>belowNext Next.\n                       (extendLevel ^^ m) (?belowN, ?N) =\n                       (belowNext, Next) \\<and>\n                       i.R belowNext =\n                       {\\<phi>. max_depth \\<phi> < ?n + m} \\<and>\n                       i.R Next = {\\<phi>. max_depth \\<phi> = ?n + m}\n  i.R belowN = {\\<phi>. max_depth \\<phi> < n}\n  i.R N = {\\<phi>. max_depth \\<phi> = n}\n\ngoal (2 subgoals):\n 1. \\<And>belowN N n.\n       \\<lbrakk>i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n        i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>belowNext Next.\n                            (extendLevel ^^ 0) (belowN, N) =\n                            (belowNext, Next) \\<and>\n                            i.R belowNext =\n                            {\\<phi>. max_depth \\<phi> < n + 0} \\<and>\n                            i.R Next = {\\<phi>. max_depth \\<phi> = n + 0}\n 2. \\<And>m belowN N n.\n       \\<lbrakk>\\<And>belowN N n.\n                   \\<lbrakk>i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n                    i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>belowNext Next.\n  (extendLevel ^^ m) (belowN, N) = (belowNext, Next) \\<and>\n  i.R belowNext = {\\<phi>. max_depth \\<phi> < n + m} \\<and>\n  i.R Next = {\\<phi>. max_depth \\<phi> = n + m};\n        i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n        i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>belowNext Next.\n                            (extendLevel ^^ Suc m) (belowN, N) =\n                            (belowNext, Next) \\<and>\n                            i.R belowNext =\n                            {\\<phi>. max_depth \\<phi> < n + Suc m} \\<and>\n                            i.R Next =\n                            {\\<phi>. max_depth \\<phi> = n + Suc m}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i.R ?belowN = {\\<phi>. max_depth \\<phi> < ?n};\n   i.R ?N = {\\<phi>. max_depth \\<phi> = ?n}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>belowNext Next.\n                       (extendLevel ^^ m) (?belowN, ?N) =\n                       (belowNext, Next) \\<and>\n                       i.R belowNext =\n                       {\\<phi>. max_depth \\<phi> < ?n + m} \\<and>\n                       i.R Next = {\\<phi>. max_depth \\<phi> = ?n + m}\n  i.R belowN = {\\<phi>. max_depth \\<phi> < n}\n  i.R N = {\\<phi>. max_depth \\<phi> = n}", "obtain belowNext Next where \"(extendLevel ^^ m) (belowN, N) = (belowNext, Next)\"\n    \"sset belowNext = {\\<phi>. max_depth \\<phi> < n + m}\" \"sset Next = {\\<phi>. max_depth \\<phi> = n + m}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i.R ?belowN = {\\<phi>. max_depth \\<phi> < ?n};\n   i.R ?N = {\\<phi>. max_depth \\<phi> = ?n}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>belowNext Next.\n                       (extendLevel ^^ m) (?belowN, ?N) =\n                       (belowNext, Next) \\<and>\n                       i.R belowNext =\n                       {\\<phi>. max_depth \\<phi> < ?n + m} \\<and>\n                       i.R Next = {\\<phi>. max_depth \\<phi> = ?n + m}\n  i.R belowN = {\\<phi>. max_depth \\<phi> < n}\n  i.R N = {\\<phi>. max_depth \\<phi> = n}\n\ngoal (1 subgoal):\n 1. (\\<And>belowNext Next.\n        \\<lbrakk>(extendLevel ^^ m) (belowN, N) = (belowNext, Next);\n         i.R belowNext = {\\<phi>. max_depth \\<phi> < n + m};\n         i.R Next = {\\<phi>. max_depth \\<phi> = n + m}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (extendLevel ^^ m) (belowN, N) = (belowNext, Next)\n  i.R belowNext = {\\<phi>. max_depth \\<phi> < n + m}\n  i.R Next = {\\<phi>. max_depth \\<phi> = n + m}\n\ngoal (2 subgoals):\n 1. \\<And>belowN N n.\n       \\<lbrakk>i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n        i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>belowNext Next.\n                            (extendLevel ^^ 0) (belowN, N) =\n                            (belowNext, Next) \\<and>\n                            i.R belowNext =\n                            {\\<phi>. max_depth \\<phi> < n + 0} \\<and>\n                            i.R Next = {\\<phi>. max_depth \\<phi> = n + 0}\n 2. \\<And>m belowN N n.\n       \\<lbrakk>\\<And>belowN N n.\n                   \\<lbrakk>i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n                    i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>belowNext Next.\n  (extendLevel ^^ m) (belowN, N) = (belowNext, Next) \\<and>\n  i.R belowNext = {\\<phi>. max_depth \\<phi> < n + m} \\<and>\n  i.R Next = {\\<phi>. max_depth \\<phi> = n + m};\n        i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n        i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>belowNext Next.\n                            (extendLevel ^^ Suc m) (belowN, N) =\n                            (belowNext, Next) \\<and>\n                            i.R belowNext =\n                            {\\<phi>. max_depth \\<phi> < n + Suc m} \\<and>\n                            i.R Next =\n                            {\\<phi>. max_depth \\<phi> = n + Suc m}", "thus ?case"], ["proof (prove)\nusing this:\n  (extendLevel ^^ m) (belowN, N) = (belowNext, Next)\n  i.R belowNext = {\\<phi>. max_depth \\<phi> < n + m}\n  i.R Next = {\\<phi>. max_depth \\<phi> = n + m}\n\ngoal (1 subgoal):\n 1. \\<exists>belowNext Next.\n       (extendLevel ^^ Suc m) (belowN, N) = (belowNext, Next) \\<and>\n       i.R belowNext = {\\<phi>. max_depth \\<phi> < n + Suc m} \\<and>\n       i.R Next = {\\<phi>. max_depth \\<phi> = n + Suc m}", "unfolding funpow.simps o_apply add_Suc_right"], ["proof (prove)\nusing this:\n  (extendLevel ^^ m) (belowN, N) = (belowNext, Next)\n  i.R belowNext = {\\<phi>. max_depth \\<phi> < n + m}\n  i.R Next = {\\<phi>. max_depth \\<phi> = n + m}\n\ngoal (1 subgoal):\n 1. \\<exists>belowNext Next.\n       extendLevel ((extendLevel ^^ m) (belowN, N)) =\n       (belowNext, Next) \\<and>\n       i.R belowNext = {\\<phi>. max_depth \\<phi> < Suc (n + m)} \\<and>\n       i.R Next = {\\<phi>. max_depth \\<phi> = Suc (n + m)}", "by (intro extendLevel_step[of belowNext _ Next])"], ["proof (state)\nthis:\n  \\<exists>belowNext Next.\n     (extendLevel ^^ Suc m) (belowN, N) = (belowNext, Next) \\<and>\n     i.R belowNext = {\\<phi>. max_depth \\<phi> < n + Suc m} \\<and>\n     i.R Next = {\\<phi>. max_depth \\<phi> = n + Suc m}\n\ngoal (1 subgoal):\n 1. \\<And>belowN N n.\n       \\<lbrakk>i.R belowN = {\\<phi>. max_depth \\<phi> < n};\n        i.R N = {\\<phi>. max_depth \\<phi> = n}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>belowNext Next.\n                            (extendLevel ^^ 0) (belowN, N) =\n                            (belowNext, Next) \\<and>\n                            i.R belowNext =\n                            {\\<phi>. max_depth \\<phi> < n + 0} \\<and>\n                            i.R Next = {\\<phi>. max_depth \\<phi> = n + 0}", "qed simp"], ["", "corollary extendLevel:\n  \"\\<exists>belowNext Next. (extendLevel ^^ m) (atoms, depth1) = (belowNext, Next) \\<and>\n     sset belowNext = {\\<phi>. max_depth \\<phi> < 1 + m} \\<and> sset Next = {\\<phi>. max_depth \\<phi> = 1 + m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>belowNext Next.\n       (extendLevel ^^ m) (atoms, depth1) = (belowNext, Next) \\<and>\n       i.R belowNext = {\\<phi>. max_depth \\<phi> < 1 + m} \\<and>\n       i.R Next = {\\<phi>. max_depth \\<phi> = 1 + m}", "by (rule extendLevel_Nsteps) (auto simp: sset_atoms sset_depth1)"], ["", "definition \"fmlas = sinterleave atoms (smerge (smap snd (siterate extendLevel (atoms, depth1))))\""], ["", "lemma fmlas_UNIV: \"sset fmlas = (UNIV :: fmla set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.R fmlas = UNIV", "proof (intro equalityI subsetI UNIV_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> x \\<in> i.R fmlas", "fix \\<phi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> x \\<in> i.R fmlas", "show \"\\<phi> \\<in> sset fmlas\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> i.R fmlas", "proof (cases \"max_depth \\<phi>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. max_depth \\<phi> = 0 \\<Longrightarrow> \\<phi> \\<in> i.R fmlas\n 2. \\<And>nat.\n       max_depth \\<phi> = Suc nat \\<Longrightarrow> \\<phi> \\<in> i.R fmlas", "case 0"], ["proof (state)\nthis:\n  max_depth \\<phi> = 0\n\ngoal (2 subgoals):\n 1. max_depth \\<phi> = 0 \\<Longrightarrow> \\<phi> \\<in> i.R fmlas\n 2. \\<And>nat.\n       max_depth \\<phi> = Suc nat \\<Longrightarrow> \\<phi> \\<in> i.R fmlas", "thus ?thesis"], ["proof (prove)\nusing this:\n  max_depth \\<phi> = 0\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> i.R fmlas", "unfolding fmlas_def sset_sinterleave stream.set_map"], ["proof (prove)\nusing this:\n  max_depth \\<phi> = 0\n\ngoal (1 subgoal):\n 1. \\<phi>\n    \\<in> Atom ` i.R nats \\<union>\n          i.R (smerge (smap snd (siterate extendLevel (atoms, depth1))))", "by (intro UnI1) (auto simp: max_depth_0)"], ["proof (state)\nthis:\n  \\<phi> \\<in> i.R fmlas\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       max_depth \\<phi> = Suc nat \\<Longrightarrow> \\<phi> \\<in> i.R fmlas", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       max_depth \\<phi> = Suc nat \\<Longrightarrow> \\<phi> \\<in> i.R fmlas", "case (Suc m)"], ["proof (state)\nthis:\n  max_depth \\<phi> = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       max_depth \\<phi> = Suc nat \\<Longrightarrow> \\<phi> \\<in> i.R fmlas", "thus ?thesis"], ["proof (prove)\nusing this:\n  max_depth \\<phi> = Suc m\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> i.R fmlas", "using extendLevel[of m]"], ["proof (prove)\nusing this:\n  max_depth \\<phi> = Suc m\n  \\<exists>belowNext Next.\n     (extendLevel ^^ m) (atoms, depth1) = (belowNext, Next) \\<and>\n     i.R belowNext = {\\<phi>. max_depth \\<phi> < 1 + m} \\<and>\n     i.R Next = {\\<phi>. max_depth \\<phi> = 1 + m}\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> i.R fmlas", "unfolding fmlas_def sset_smerge sset_siterate sset_sinterleave stream.set_map"], ["proof (prove)\nusing this:\n  max_depth \\<phi> = Suc m\n  \\<exists>belowNext Next.\n     (extendLevel ^^ m) (atoms, depth1) = (belowNext, Next) \\<and>\n     i.R belowNext = {\\<phi>. max_depth \\<phi> < 1 + m} \\<and>\n     i.R Next = {\\<phi>. max_depth \\<phi> = 1 + m}\n\ngoal (1 subgoal):\n 1. \\<phi>\n    \\<in> Atom ` {(Suc ^^ n) 0 |n. True} \\<union>\n          \\<Union>\n           (i.R ` snd ` {(extendLevel ^^ n) (atoms, depth1) |n. True})", "by (intro UnI2) (auto, metis (mono_tags) mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<phi> \\<in> i.R fmlas\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> \\<in> i.R fmlas\n\ngoal:\nNo subgoals!", "qed"], ["", "datatype rule = Idle | Ax nat | NegL fmla | NegR fmla | ConjL fmla fmla | ConjR fmla fmla"], ["", "abbreviation \"mkRules f \\<equiv> smap f fmlas\""], ["", "abbreviation \"mkRulePairs f \\<equiv> smap (case_prod f) (sproduct fmlas fmlas)\""], ["", "definition rules where\n  \"rules = Idle ## \n     sinterleaves [mkRules NegL, mkRules NegR, mkRulePairs ConjL, mkRulePairs ConjR]\n     (smap Ax nats)\""], ["", "lemma rules_UNIV: \"sset rules = (UNIV :: rule set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.R rules = UNIV", "unfolding rules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i.R (Idle ##\n         sinterleaves\n          [mkRules NegL, mkRules NegR, mkRulePairs ConjL, mkRulePairs ConjR]\n          (smap Ax nats)) =\n    UNIV", "by (auto simp: sset_sinterleave sset_sproduct stream.set_map\n    fmlas_UNIV image_iff) (metis rule.exhaust)"], ["", "type_synonym state = \"fmla fset * fmla fset\""], ["", "fun eff' :: \"rule \\<Rightarrow> state \\<Rightarrow> state fset option\" where\n  \"eff' Idle (\\<Gamma>, \\<Delta>) = Some {|(\\<Gamma>, \\<Delta>)|}\"\n| \"eff' (Ax n) (\\<Gamma>, \\<Delta>) =\n    (if Atom n |\\<in>| \\<Gamma> \\<and> Atom n |\\<in>| \\<Delta> then Some {||} else None)\"\n| \"eff' (NegL \\<phi>) (\\<Gamma>, \\<Delta>) =\n    (if Neg \\<phi> |\\<in>| \\<Gamma> then Some {|(\\<Gamma> |-| {| Neg \\<phi> |}, finsert \\<phi> \\<Delta>)|} else None)\"\n| \"eff' (NegR \\<phi>) (\\<Gamma>, \\<Delta>) =\n    (if Neg \\<phi> |\\<in>| \\<Delta> then Some {|(finsert \\<phi> \\<Gamma>, \\<Delta> |-| {| Neg \\<phi> |})|} else None)\"\n| \"eff' (ConjL \\<phi> \\<psi>) (\\<Gamma>, \\<Delta>) =\n    (if Conj \\<phi> \\<psi> |\\<in>| \\<Gamma>\n    then Some {|(finsert \\<phi> (finsert \\<psi> (\\<Gamma> |-| {| Conj \\<phi> \\<psi> |})), \\<Delta>)|}\n    else None)\"\n| \"eff' (ConjR \\<phi> \\<psi>) (\\<Gamma>, \\<Delta>) =\n    (if Conj \\<phi> \\<psi> |\\<in>| \\<Delta>\n    then Some {|(\\<Gamma>, finsert \\<phi> (\\<Delta> |-| {| Conj \\<phi> \\<psi> |})), (\\<Gamma>, finsert \\<psi> (\\<Delta> |-| {| Conj \\<phi> \\<psi> |}))|}\n    else None)\""], ["", "abbreviation \"Disj \\<phi> \\<psi> \\<equiv> Neg (Conj (Neg \\<phi>) (Neg \\<psi>))\""], ["", "abbreviation \"Imp \\<phi> \\<psi> \\<equiv> Disj (Neg \\<phi>) \\<psi>\""], ["", "abbreviation \"Iff \\<phi> \\<psi> \\<equiv> Conj (Imp \\<phi> \\<psi>) (Imp \\<psi> \\<phi>)\""], ["", "definition \"thm1 \\<equiv> ({|Conj (Atom 0) (Neg (Atom 0))|}, {||})\""], ["", "declare Stream.smember_code [code del]"], ["", "lemma [code]: \"Stream.smember x (y ## s) = (x = y \\<or> Stream.smember x s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Stream.smember x (y ## s) = (x = y \\<or> Stream.smember x s)", "unfolding Stream.smember_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> i.R (y ## s)) = (x = y \\<or> x \\<in> i.R s)", "by auto"], ["", "interpretation RuleSystem \"\\<lambda>r s ss. eff' r s = Some ss\" rules UNIV"], ["proof (prove)\ngoal (1 subgoal):\n 1. RuleSystem (\\<lambda>r s ss. eff' r s = Some ss) rules UNIV", "by unfold_locales (auto simp: rules_UNIV intro: exI[of _ Idle])"], ["", "interpretation PersistentRuleSystem \"\\<lambda>r s ss. eff' r s = Some ss\" rules UNIV"], ["proof (prove)\ngoal (1 subgoal):\n 1. PersistentRuleSystem (\\<lambda>r s ss. eff' r s = Some ss) rules UNIV", "proof (unfold_locales, unfold enabled_def per_def rules_UNIV, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r a b r1 sl' aa ba sl.\n       \\<lbrakk>eff' r (a, b) = Some sl; r1 \\<noteq> r;\n        eff' r1 (a, b) = Some sl'; (aa, ba) |\\<in>| sl'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl. eff' r (aa, ba) = Some sl", "fix r \\<Gamma> \\<Delta> ss r' \\<Gamma>' \\<Delta>' ss'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r a b r1 sl' aa ba sl.\n       \\<lbrakk>eff' r (a, b) = Some sl; r1 \\<noteq> r;\n        eff' r1 (a, b) = Some sl'; (aa, ba) |\\<in>| sl'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl. eff' r (aa, ba) = Some sl", "assume \"r' \\<noteq> r\" \"eff' r (\\<Gamma>, \\<Delta>) = Some ss\" \"eff' r' (\\<Gamma>, \\<Delta>) = Some ss'\" \"(\\<Gamma>', \\<Delta>') |\\<in>| ss'\""], ["proof (state)\nthis:\n  r' \\<noteq> r\n  eff' r (\\<Gamma>, \\<Delta>) = Some ss\n  eff' r' (\\<Gamma>, \\<Delta>) = Some ss'\n  (\\<Gamma>', \\<Delta>') |\\<in>| ss'\n\ngoal (1 subgoal):\n 1. \\<And>r a b r1 sl' aa ba sl.\n       \\<lbrakk>eff' r (a, b) = Some sl; r1 \\<noteq> r;\n        eff' r1 (a, b) = Some sl'; (aa, ba) |\\<in>| sl'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl. eff' r (aa, ba) = Some sl", "then"], ["proof (chain)\npicking this:\n  r' \\<noteq> r\n  eff' r (\\<Gamma>, \\<Delta>) = Some ss\n  eff' r' (\\<Gamma>, \\<Delta>) = Some ss'\n  (\\<Gamma>', \\<Delta>') |\\<in>| ss'", "show \"\\<exists>sl. eff' r (\\<Gamma>', \\<Delta>') = Some sl\""], ["proof (prove)\nusing this:\n  r' \\<noteq> r\n  eff' r (\\<Gamma>, \\<Delta>) = Some ss\n  eff' r' (\\<Gamma>, \\<Delta>) = Some ss'\n  (\\<Gamma>', \\<Delta>') |\\<in>| ss'\n\ngoal (1 subgoal):\n 1. \\<exists>sl. eff' r (\\<Gamma>', \\<Delta>') = Some sl", "by (cases r r' rule: rule.exhaust[case_product rule.exhaust]) (auto split: if_splits)"], ["proof (state)\nthis:\n  \\<exists>sl. eff' r (\\<Gamma>', \\<Delta>') = Some sl\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"rho \\<equiv> i.fenum rules\""], ["", "definition \"propTree \\<equiv> i.mkTree eff' rho\""], ["", "export_code propTree thm1 in Haskell module_name PropInstance"], ["", "(* file \".\" *)\n\n(*<*)"], ["", "end"], ["", "(*>*)"]]}