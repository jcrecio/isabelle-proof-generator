{"file_name": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow/EdmondsKarp_Algo.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow", "problem_names": ["lemma find_shortest_augmenting_refine[refine]: \n  \"(f',f)\\<in>Id \\<Longrightarrow> find_shortest_augmenting_spec f' \\<le> \\<Down>(\\<langle>Id\\<rangle>option_rel) (find_augmenting_spec f)\"", "lemma edka_partial_refine[refine]: \"edka_partial \\<le> \\<Down>Id fofu\"", "lemma edka_wf_rel_wf[simp, intro!]: \"wf edka_wf_rel\"", "theorem edka_refine[refine]: \"edka \\<le> \\<Down>Id edka_partial\"", "lemma ekMeasure_upper_bound: \n  \"ek_analysis_defs.ekMeasure (residualGraph c (\\<lambda>_. 0)) s t \n   < 2 * card V * card E + card V\"", "lemma edka_complexity_refine: \"edka_complexity \\<le> \\<Down>Id edka\"", "theorem \"edka_complexity \\<le> (spec f. isMaxFlow f)\""], "translations": [["", "lemma find_shortest_augmenting_refine[refine]: \n  \"(f',f)\\<in>Id \\<Longrightarrow> find_shortest_augmenting_spec f' \\<le> \\<Down>(\\<langle>Id\\<rangle>option_rel) (find_augmenting_spec f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f', f) \\<in> Id \\<Longrightarrow>\n    find_shortest_augmenting_spec f'\n    \\<le> \\<Down> (\\<langle>Id\\<rangle>option_rel) (find_augmenting_spec f)", "unfolding find_shortest_augmenting_spec_def find_augmenting_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f', f) \\<in> Id \\<Longrightarrow>\n    assert (NFlow c s t f') \\<bind>\n    (\\<lambda>_. select p. Graph.isShortestPath (cf_of f') s p t)\n    \\<le> \\<Down> (\\<langle>Id\\<rangle>option_rel)\n           (assert (NFlow c s t f) \\<bind>\n            (\\<lambda>_. select p. NPreflow.isAugmentingPath c s t f p))", "apply (refine_vcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(f', f) \\<in> Id; NFlow c s t f\\<rbrakk>\n    \\<Longrightarrow> NFlow c s t f'\n 2. \\<lbrakk>(f', f) \\<in> Id; NFlow c s t f; NFlow c s t f'\\<rbrakk>\n    \\<Longrightarrow> RELATES Id\n 3. \\<And>x'.\n       \\<lbrakk>(f', f) \\<in> Id; NFlow c s t f; NFlow c s t f';\n        NPreflow.isAugmentingPath c s t f x'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. Graph.isShortestPath (cf_of f') s x t\n 4. \\<And>x.\n       \\<lbrakk>(f', f) \\<in> Id; NFlow c s t f; NFlow c s t f';\n        Graph.isShortestPath (cf_of f') s x t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            (x, x') \\<in> Id \\<and>\n                            NPreflow.isAugmentingPath c s t f x'", "apply (auto \n    simp: NFlow.shortest_is_augmenting RELATESI\n    dest: NFlow.augmenting_path_imp_shortest)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Next, we specify the Edmonds-Karp algorithm. \n  Our first specification still uses partial correctness, \n  termination will be proved afterwards. \\<close>"], ["", "definition \"edka_partial \\<equiv> do {\n  let f = (\\<lambda>_. 0);\n\n  (f,_) \\<leftarrow> while\\<^bsup>fofu_invar\\<^esup>\n    (\\<lambda>(f,brk). \\<not>brk) \n    (\\<lambda>(f,_). do {\n      p \\<leftarrow> find_shortest_augmenting_spec f;\n      case p of \n        None \\<Rightarrow> return (f,True)\n      | Some p \\<Rightarrow> do {\n          assert (p\\<noteq>[]);\n          assert (NPreflow.isAugmentingPath c s t f p);\n          assert (Graph.isShortestPath (residualGraph c f) s p t);\n          let f = NFlow.augment_with_path c f p;\n          assert (NFlow c s t f);\n          return (f, False)\n        }  \n    })\n    (f,False);\n  assert (NFlow c s t f);\n  return f \n}\""], ["", "lemma edka_partial_refine[refine]: \"edka_partial \\<le> \\<Down>Id fofu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edka_partial \\<le> \\<Down> Id fofu", "unfolding edka_partial_def fofu_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let f = \\<lambda>_. 0::'capacity\n     in while\\<^bsup>fofu_invar\\<^esup> (\\<lambda>(f, brk). \\<not> brk)\n         (\\<lambda>(f, uu_).\n             find_shortest_augmenting_spec f \\<bind>\n             (\\<lambda>p.\n                 case p of None \\<Rightarrow> return (f, True)\n                 | Some p \\<Rightarrow>\n                     assert (p \\<noteq> []) \\<bind>\n                     (\\<lambda>_.\n                         assert\n                          (NPreflow.isAugmentingPath c s t f p) \\<bind>\n                         (\\<lambda>_.\n                             assert\n                              (Graph.isShortestPath (cf_of f) s p t) \\<bind>\n                             (\\<lambda>_.\n                                 let f = NFlow.augment_with_path c f p\n                                 in assert (NFlow c s t f) \\<bind>\n                                    (\\<lambda>_. return (f, False)))))))\n         (f, False) \\<bind>\n        (\\<lambda>(f, uu_).\n            assert (NFlow c s t f) \\<bind> (\\<lambda>_. return f)))\n    \\<le> \\<Down> Id\n           (let f\\<^sub>0 = \\<lambda>_. 0::'capacity\n            in while\\<^bsup>fofu_invar\\<^esup>\n                (\\<lambda>(f, brk). \\<not> brk)\n                (\\<lambda>(f, uu_).\n                    find_augmenting_spec f \\<bind>\n                    (\\<lambda>p.\n                        case p of None \\<Rightarrow> return (f, True)\n                        | Some p \\<Rightarrow>\n                            assert (p \\<noteq> []) \\<bind>\n                            (\\<lambda>_.\n                                assert\n                                 (NPreflow.isAugmentingPath c s t f\n                                   p) \\<bind>\n                                (\\<lambda>_.\n                                    let f = NFlow.augment_with_path c f p\n                                    in assert (NFlow c s t f) \\<bind>\n (\\<lambda>_. return (f, False))))))\n                (f\\<^sub>0, False) \\<bind>\n               (\\<lambda>(f, uu_).\n                   assert (NFlow c s t f) \\<bind> (\\<lambda>_. return f)))", "apply (refine_rcg bind_refine')"], ["proof (prove)\ngoal (14 subgoals):\n 1. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>_. 0::'capacity, False), \\<lambda>_. 0::'capacity, False)\n    \\<in> ?R'1\n 2. \\<And>x x' x1 x2.\n       \\<lbrakk>(x, x') \\<in> ?R'1; fofu_invar x'; x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t x1\n 3. \\<And>x x' x1 x2 p.\n       \\<lbrakk>(x, x') \\<in> ?R'1; fofu_invar x'; x = (x1, x2); x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> NPreflow.isAugmentingPath c s t x1 p\n 4. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'1; fofu_invar x; fofu_invar x';\n        x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 5. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> Id\n 6. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> \\<langle>Id\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_augmenting_spec x1)\\<rbrakk>\n       \\<Longrightarrow> (p, pa)\n                         \\<in> \\<langle>?Ra43 x x' x1 x2 x1a x2a p\n   pa\\<rangle>option_rel\n 7. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> \\<langle>Id\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_augmenting_spec x1); p = None; pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True) \\<in> ?R'1\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> \\<langle>Id\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_augmenting_spec x1); p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra43 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        NPreflow.isAugmentingPath c s t x1 x'a\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> \\<langle>Id\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_augmenting_spec x1); p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra43 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        NPreflow.isAugmentingPath c s t x1 x'a; xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> NPreflow.isAugmentingPath c s t x1a xa\n 10. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n        \\<lbrakk>(x, x') \\<in> ?R'1;\n         case x of (f, brk) \\<Rightarrow> \\<not> brk;\n         case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n         fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n         (p, pa) \\<in> \\<langle>Id\\<rangle>option_rel;\n         inres (find_shortest_augmenting_spec x1a) p;\n         inres (find_augmenting_spec x1) pa;\n         nofail (find_shortest_augmenting_spec x1a);\n         nofail (find_augmenting_spec x1); p = Some xa; pa = Some x'a;\n         (xa, x'a) \\<in> ?Ra43 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n         NPreflow.isAugmentingPath c s t x1 x'a; xa \\<noteq> [];\n         NPreflow.isAugmentingPath c s t x1a xa\\<rbrakk>\n        \\<Longrightarrow> Graph.isShortestPath (cf_of x1a) s xa t\nA total of 14 subgoals...", "apply (refine_dref_type)"], ["proof (prove)\ngoal (14 subgoals):\n 1. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>_. 0::'capacity, False), \\<lambda>_. 0::'capacity, False)\n    \\<in> Id \\<times>\\<^sub>r bool_rel\n 2. \\<And>x x' x1 x2.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t x1\n 3. \\<And>x x' x1 x2 p.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2); x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> NPreflow.isAugmentingPath c s t x1 p\n 4. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x;\n        fofu_invar x'; x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 5. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> Id\n 6. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> \\<langle>Id\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_augmenting_spec x1)\\<rbrakk>\n       \\<Longrightarrow> (p, pa)\n                         \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n           nat_rel\\<rangle>list_rel\\<rangle>option_rel\n 7. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> \\<langle>Id\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_augmenting_spec x1); p = None; pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> \\<langle>Id\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_augmenting_spec x1); p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> \\<langle>Id\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_augmenting_spec x1); p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> NPreflow.isAugmentingPath c s t x1a xa\n 10. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n        \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n         case x of (f, brk) \\<Rightarrow> \\<not> brk;\n         case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n         fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n         (p, pa) \\<in> \\<langle>Id\\<rangle>option_rel;\n         inres (find_shortest_augmenting_spec x1a) p;\n         inres (find_augmenting_spec x1) pa;\n         nofail (find_shortest_augmenting_spec x1a);\n         nofail (find_augmenting_spec x1); p = Some xa; pa = Some x'a;\n         (xa, x'a)\n         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n         x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n         xa \\<noteq> []; NPreflow.isAugmentingPath c s t x1a xa\\<rbrakk>\n        \\<Longrightarrow> Graph.isShortestPath (cf_of x1a) s xa t\nA total of 14 subgoals...", "apply (vc_solve simp: find_shortest_augmenting_spec_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "subsubsection \\<open>Total Correctness\\<close>"], ["", "context Network begin"], ["", "text \\<open>We specify the total correct version of Edmonds-Karp algorithm.\\<close>"], ["", "definition \"edka \\<equiv> do {\n  let f = (\\<lambda>_. 0);\n\n  (f,_) \\<leftarrow> while\\<^sub>T\\<^bsup>fofu_invar\\<^esup>\n    (\\<lambda>(f,brk). \\<not>brk) \n    (\\<lambda>(f,_). do {\n      p \\<leftarrow> find_shortest_augmenting_spec f;\n      case p of \n        None \\<Rightarrow> return (f,True)\n      | Some p \\<Rightarrow> do {\n          assert (p\\<noteq>[]);\n          assert (NPreflow.isAugmentingPath c s t f p);\n          assert (Graph.isShortestPath (residualGraph c f) s p t);\n          let f = NFlow.augment_with_path c f p;\n          assert (NFlow c s t f);\n          return (f, False)\n        }  \n    })\n    (f,False);\n  assert (NFlow c s t f);\n  return f \n}\""], ["", "text \\<open>Based on the measure function, it is easy to obtain a well-founded \n  relation that proves termination of the loop in the Edmonds-Karp algorithm:\\<close>"], ["", "definition \"edka_wf_rel \\<equiv> inv_image \n  (less_than_bool <*lex*> measure (\\<lambda>cf. ek_analysis_defs.ekMeasure cf s t))\n  (\\<lambda>(f,brk). (\\<not>brk,residualGraph c f))\""], ["", "lemma edka_wf_rel_wf[simp, intro!]: \"wf edka_wf_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf edka_wf_rel", "unfolding edka_wf_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image\n         (less_than_bool <*lex*>\n          measure (\\<lambda>cf. ek_analysis_defs.ekMeasure cf s t))\n         (\\<lambda>(f, brk). (\\<not> brk, cf_of f)))", "by auto"], ["", "text \\<open>The following theorem states that the total correct \n  version of Edmonds-Karp algorithm refines the partial correct one.\\<close>"], ["", "theorem edka_refine[refine]: \"edka \\<le> \\<Down>Id edka_partial\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edka \\<le> \\<Down> Id edka_partial", "unfolding edka_def edka_partial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let f = \\<lambda>_. 0::'capacity\n     in while\\<^sub>T\\<^bsup>fofu_invar\\<^esup>\n         (\\<lambda>(f, brk). \\<not> brk)\n         (\\<lambda>(f, uu_).\n             find_shortest_augmenting_spec f \\<bind>\n             (\\<lambda>p.\n                 case p of None \\<Rightarrow> return (f, True)\n                 | Some p \\<Rightarrow>\n                     assert (p \\<noteq> []) \\<bind>\n                     (\\<lambda>_.\n                         assert\n                          (NPreflow.isAugmentingPath c s t f p) \\<bind>\n                         (\\<lambda>_.\n                             assert\n                              (Graph.isShortestPath (cf_of f) s p t) \\<bind>\n                             (\\<lambda>_.\n                                 let f = NFlow.augment_with_path c f p\n                                 in assert (NFlow c s t f) \\<bind>\n                                    (\\<lambda>_. return (f, False)))))))\n         (f, False) \\<bind>\n        (\\<lambda>(f, uu_).\n            assert (NFlow c s t f) \\<bind> (\\<lambda>_. return f)))\n    \\<le> \\<Down> Id\n           (let f = \\<lambda>_. 0::'capacity\n            in while\\<^bsup>fofu_invar\\<^esup>\n                (\\<lambda>(f, brk). \\<not> brk)\n                (\\<lambda>(f, uu_).\n                    find_shortest_augmenting_spec f \\<bind>\n                    (\\<lambda>p.\n                        case p of None \\<Rightarrow> return (f, True)\n                        | Some p \\<Rightarrow>\n                            assert (p \\<noteq> []) \\<bind>\n                            (\\<lambda>_.\n                                assert\n                                 (NPreflow.isAugmentingPath c s t f\n                                   p) \\<bind>\n                                (\\<lambda>_.\n                                    assert\n                                     (Graph.isShortestPath (cf_of f) s p\n t) \\<bind>\n                                    (\\<lambda>_.\n  let f = NFlow.augment_with_path c f p\n  in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False)))))))\n                (f, False) \\<bind>\n               (\\<lambda>(f, uu_).\n                   assert (NFlow c s t f) \\<bind> (\\<lambda>_. return f)))", "apply (refine_rcg bind_refine' \n    WHILEIT_refine_WHILEI[where V=edka_wf_rel])"], ["proof (prove)\ngoal (16 subgoals):\n 1. wf edka_wf_rel\n 2. \\<And>sa x1 x2.\n       \\<lbrakk>fofu_invar sa; case sa of (f, brk) \\<Rightarrow> \\<not> brk;\n        (case sa of\n         (f, uu_) \\<Rightarrow>\n           find_shortest_augmenting_spec f \\<bind>\n           (\\<lambda>p.\n               case p of None \\<Rightarrow> return (f, True)\n               | Some p \\<Rightarrow>\n                   assert (p \\<noteq> []) \\<bind>\n                   (\\<lambda>_.\n                       assert (NPreflow.isAugmentingPath c s t f p) \\<bind>\n                       (\\<lambda>_.\n                           assert\n                            (Graph.isShortestPath (cf_of f) s p t) \\<bind>\n                           (\\<lambda>_.\n                               let f = NFlow.augment_with_path c f p\n                               in assert (NFlow c s t f) \\<bind>\n                                  (\\<lambda>_. return (f, False)))))))\n        \\<le> SPEC fofu_invar;\n        sa = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec x1 \\<bind>\n                         (\\<lambda>p.\n                             case p of None \\<Rightarrow> return (x1, True)\n                             | Some p \\<Rightarrow>\n                                 assert (p \\<noteq> []) \\<bind>\n                                 (\\<lambda>_.\n                                     assert\n(NPreflow.isAugmentingPath c s t x1 p) \\<bind>\n                                     (\\<lambda>_.\n   assert (Graph.isShortestPath (cf_of x1) s p t) \\<bind>\n   (\\<lambda>_.\n       let f = NFlow.augment_with_path c x1 p\n       in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False))))))\n                         \\<le> (spec s'. (s', sa) \\<in> edka_wf_rel)\n 3. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>_. 0::'capacity, False), \\<lambda>_. 0::'capacity, False)\n    \\<in> ?R'1\n 4. \\<And>x x' x1 x2.\n       \\<lbrakk>(x, x') \\<in> ?R'1; fofu_invar x'; x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t x1\n 5. \\<And>x x' x1 x2 p.\n       \\<lbrakk>(x, x') \\<in> ?R'1; fofu_invar x'; x = (x1, x2); x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> NPreflow.isAugmentingPath c s t x1 p\n 6. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'1; fofu_invar x; fofu_invar x';\n        x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 7. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec x1a\n                         \\<le> \\<Down> (?R'48 x x' x1 x2 x1a x2a)\n                                (find_shortest_augmenting_spec x1)\n 8. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> ?R'48 x x' x1 x2 x1a x2a;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1)\\<rbrakk>\n       \\<Longrightarrow> (p, pa)\n                         \\<in> \\<langle>?Ra49 x x' x1 x2 x1a x2a p\n   pa\\<rangle>option_rel\n 9. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> ?R'48 x x' x1 x2 x1a x2a;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = None;\n        pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True) \\<in> ?R'1\n 10. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n        \\<lbrakk>(x, x') \\<in> ?R'1;\n         case x of (f, brk) \\<Rightarrow> \\<not> brk;\n         case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n         fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n         (p, pa) \\<in> ?R'48 x x' x1 x2 x1a x2a;\n         inres (find_shortest_augmenting_spec x1a) p;\n         inres (find_shortest_augmenting_spec x1) pa;\n         nofail (find_shortest_augmenting_spec x1a);\n         nofail (find_shortest_augmenting_spec x1); p = Some xa;\n         pa = Some x'a; (xa, x'a) \\<in> ?Ra49 x x' x1 x2 x1a x2a p pa;\n         x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n         Graph.isShortestPath (cf_of x1) s x'a t\\<rbrakk>\n        \\<Longrightarrow> xa \\<noteq> []\nA total of 16 subgoals...", "apply (refine_dref_type)"], ["proof (prove)\ngoal (15 subgoals):\n 1. wf edka_wf_rel\n 2. \\<And>sa x1 x2.\n       \\<lbrakk>fofu_invar sa; case sa of (f, brk) \\<Rightarrow> \\<not> brk;\n        (case sa of\n         (f, uu_) \\<Rightarrow>\n           find_shortest_augmenting_spec f \\<bind>\n           (\\<lambda>p.\n               case p of None \\<Rightarrow> return (f, True)\n               | Some p \\<Rightarrow>\n                   assert (p \\<noteq> []) \\<bind>\n                   (\\<lambda>_.\n                       assert (NPreflow.isAugmentingPath c s t f p) \\<bind>\n                       (\\<lambda>_.\n                           assert\n                            (Graph.isShortestPath (cf_of f) s p t) \\<bind>\n                           (\\<lambda>_.\n                               let f = NFlow.augment_with_path c f p\n                               in assert (NFlow c s t f) \\<bind>\n                                  (\\<lambda>_. return (f, False)))))))\n        \\<le> SPEC fofu_invar;\n        sa = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec x1 \\<bind>\n                         (\\<lambda>p.\n                             case p of None \\<Rightarrow> return (x1, True)\n                             | Some p \\<Rightarrow>\n                                 assert (p \\<noteq> []) \\<bind>\n                                 (\\<lambda>_.\n                                     assert\n(NPreflow.isAugmentingPath c s t x1 p) \\<bind>\n                                     (\\<lambda>_.\n   assert (Graph.isShortestPath (cf_of x1) s p t) \\<bind>\n   (\\<lambda>_.\n       let f = NFlow.augment_with_path c x1 p\n       in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False))))))\n                         \\<le> (spec s'. (s', sa) \\<in> edka_wf_rel)\n 3. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>_. 0::'capacity, False), \\<lambda>_. 0::'capacity, False)\n    \\<in> Id \\<times>\\<^sub>r bool_rel\n 4. \\<And>x x' x1 x2.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t x1\n 5. \\<And>x x' x1 x2 p.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2); x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> NPreflow.isAugmentingPath c s t x1 p\n 6. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x;\n        fofu_invar x'; x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 7. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec x1a\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n             nat_rel\\<rangle>list_rel\\<rangle>option_rel)\n                                (find_shortest_augmenting_spec x1)\n 8. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = None;\n        pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = Some xa;\n        pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 10. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n        \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n         case x of (f, brk) \\<Rightarrow> \\<not> brk;\n         case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n         fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n         (p, pa)\n         \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                 nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n         inres (find_shortest_augmenting_spec x1a) p;\n         inres (find_shortest_augmenting_spec x1) pa;\n         nofail (find_shortest_augmenting_spec x1a);\n         nofail (find_shortest_augmenting_spec x1); p = Some xa;\n         pa = Some x'a;\n         (xa, x'a)\n         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n         x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n         Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> NPreflow.isAugmentingPath c s t x1a xa\nA total of 15 subgoals...", "apply (simp; fail)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>sa x1 x2.\n       \\<lbrakk>fofu_invar sa; case sa of (f, brk) \\<Rightarrow> \\<not> brk;\n        (case sa of\n         (f, uu_) \\<Rightarrow>\n           find_shortest_augmenting_spec f \\<bind>\n           (\\<lambda>p.\n               case p of None \\<Rightarrow> return (f, True)\n               | Some p \\<Rightarrow>\n                   assert (p \\<noteq> []) \\<bind>\n                   (\\<lambda>_.\n                       assert (NPreflow.isAugmentingPath c s t f p) \\<bind>\n                       (\\<lambda>_.\n                           assert\n                            (Graph.isShortestPath (cf_of f) s p t) \\<bind>\n                           (\\<lambda>_.\n                               let f = NFlow.augment_with_path c f p\n                               in assert (NFlow c s t f) \\<bind>\n                                  (\\<lambda>_. return (f, False)))))))\n        \\<le> SPEC fofu_invar;\n        sa = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec x1 \\<bind>\n                         (\\<lambda>p.\n                             case p of None \\<Rightarrow> return (x1, True)\n                             | Some p \\<Rightarrow>\n                                 assert (p \\<noteq> []) \\<bind>\n                                 (\\<lambda>_.\n                                     assert\n(NPreflow.isAugmentingPath c s t x1 p) \\<bind>\n                                     (\\<lambda>_.\n   assert (Graph.isShortestPath (cf_of x1) s p t) \\<bind>\n   (\\<lambda>_.\n       let f = NFlow.augment_with_path c x1 p\n       in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False))))))\n                         \\<le> (spec s'. (s', sa) \\<in> edka_wf_rel)\n 2. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>_. 0::'capacity, False), \\<lambda>_. 0::'capacity, False)\n    \\<in> Id \\<times>\\<^sub>r bool_rel\n 3. \\<And>x x' x1 x2.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t x1\n 4. \\<And>x x' x1 x2 p.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2); x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> NPreflow.isAugmentingPath c s t x1 p\n 5. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x;\n        fofu_invar x'; x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 6. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec x1a\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n             nat_rel\\<rangle>list_rel\\<rangle>option_rel)\n                                (find_shortest_augmenting_spec x1)\n 7. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = None;\n        pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = Some xa;\n        pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = Some xa;\n        pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> NPreflow.isAugmentingPath c s t x1a xa\n 10. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n        \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n         case x of (f, brk) \\<Rightarrow> \\<not> brk;\n         case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n         fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n         (p, pa)\n         \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                 nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n         inres (find_shortest_augmenting_spec x1a) p;\n         inres (find_shortest_augmenting_spec x1) pa;\n         nofail (find_shortest_augmenting_spec x1a);\n         nofail (find_shortest_augmenting_spec x1); p = Some xa;\n         pa = Some x'a;\n         (xa, x'a)\n         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n         x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n         Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> [];\n         NPreflow.isAugmentingPath c s t x1a xa\\<rbrakk>\n        \\<Longrightarrow> Graph.isShortestPath (cf_of x1a) s xa t\nA total of 14 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fofu_invar sa_; case sa_ of (f, brk) \\<Rightarrow> \\<not> brk;\n     (case sa_ of\n      (f, uu_) \\<Rightarrow>\n        find_shortest_augmenting_spec f \\<bind>\n        (\\<lambda>p.\n            case p of None \\<Rightarrow> return (f, True)\n            | Some p \\<Rightarrow>\n                assert (p \\<noteq> []) \\<bind>\n                (\\<lambda>_.\n                    assert (NPreflow.isAugmentingPath c s t f p) \\<bind>\n                    (\\<lambda>_.\n                        assert\n                         (Graph.isShortestPath (cf_of f) s p t) \\<bind>\n                        (\\<lambda>_.\n                            let f = NFlow.augment_with_path c f p\n                            in assert (NFlow c s t f) \\<bind>\n                               (\\<lambda>_. return (f, False)))))))\n     \\<le> SPEC fofu_invar;\n     sa_ = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> find_shortest_augmenting_spec x1_ \\<bind>\n                      (\\<lambda>p.\n                          case p of None \\<Rightarrow> return (x1_, True)\n                          | Some p \\<Rightarrow>\n                              assert (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  assert\n                                   (NPreflow.isAugmentingPath c s t x1_\n                                     p) \\<bind>\n                                  (\\<lambda>_.\nassert (Graph.isShortestPath (cf_of x1_) s p t) \\<bind>\n(\\<lambda>_.\n    let f = NFlow.augment_with_path c x1_ p\n    in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False))))))\n                      \\<le> (spec s'. (s', sa_) \\<in> edka_wf_rel)", "txt \\<open>Unfortunately, the verification condition for introducing \n      the variant requires a bit of manual massaging to be solved:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fofu_invar sa_; case sa_ of (f, brk) \\<Rightarrow> \\<not> brk;\n     (case sa_ of\n      (f, uu_) \\<Rightarrow>\n        find_shortest_augmenting_spec f \\<bind>\n        (\\<lambda>p.\n            case p of None \\<Rightarrow> return (f, True)\n            | Some p \\<Rightarrow>\n                assert (p \\<noteq> []) \\<bind>\n                (\\<lambda>_.\n                    assert (NPreflow.isAugmentingPath c s t f p) \\<bind>\n                    (\\<lambda>_.\n                        assert\n                         (Graph.isShortestPath (cf_of f) s p t) \\<bind>\n                        (\\<lambda>_.\n                            let f = NFlow.augment_with_path c f p\n                            in assert (NFlow c s t f) \\<bind>\n                               (\\<lambda>_. return (f, False)))))))\n     \\<le> SPEC fofu_invar;\n     sa_ = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> find_shortest_augmenting_spec x1_ \\<bind>\n                      (\\<lambda>p.\n                          case p of None \\<Rightarrow> return (x1_, True)\n                          | Some p \\<Rightarrow>\n                              assert (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  assert\n                                   (NPreflow.isAugmentingPath c s t x1_\n                                     p) \\<bind>\n                                  (\\<lambda>_.\nassert (Graph.isShortestPath (cf_of x1_) s p t) \\<bind>\n(\\<lambda>_.\n    let f = NFlow.augment_with_path c x1_ p\n    in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False))))))\n                      \\<le> (spec s'. (s', sa_) \\<in> edka_wf_rel)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NFlow c s t x1_; \\<not> x2_;\n     find_shortest_augmenting_spec x1_ \\<bind>\n     case_option (return (x1_, True))\n      (\\<lambda>p.\n          assert (p \\<noteq> []) \\<bind>\n          (\\<lambda>_.\n              assert (NPreflow.isAugmentingPath c s t x1_ p) \\<bind>\n              (\\<lambda>_.\n                  assert (Graph.isShortestPath (cf_of x1_) s p t) \\<bind>\n                  (\\<lambda>_.\n                      let f = NFlow.augment_with_path c x1_ p\n                      in assert (NFlow c s t f) \\<bind>\n                         (\\<lambda>_. return (f, False))))))\n     \\<le> SPEC fofu_invar;\n     sa_ = (x1_, False)\\<rbrakk>\n    \\<Longrightarrow> find_shortest_augmenting_spec x1_ \\<bind>\n                      (\\<lambda>p.\n                          case p of None \\<Rightarrow> return (x1_, True)\n                          | Some p \\<Rightarrow>\n                              assert (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  assert\n                                   (NPreflow.isAugmentingPath c s t x1_\n                                     p) \\<bind>\n                                  (\\<lambda>_.\nassert (Graph.isShortestPath (cf_of x1_) s p t) \\<bind>\n(\\<lambda>_.\n    let f = NFlow.augment_with_path c x1_ p\n    in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False))))))\n                      \\<le> (spec s'. (s', x1_, False) \\<in> edka_wf_rel)", "apply (erule bind_sim_select_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>NFlow c s t x1_; \\<not> x2_; sa_ = (x1_, False);\n        nofail (find_shortest_augmenting_spec x1_);\n        inres (find_shortest_augmenting_spec x1_) x;\n        (case x of None \\<Rightarrow> return (x1_, True)\n         | Some p \\<Rightarrow>\n             assert (p \\<noteq> []) \\<bind>\n             (\\<lambda>_.\n                 assert (NPreflow.isAugmentingPath c s t x1_ p) \\<bind>\n                 (\\<lambda>_.\n                     assert (Graph.isShortestPath (cf_of x1_) s p t) \\<bind>\n                     (\\<lambda>_.\n                         let f = NFlow.augment_with_path c x1_ p\n                         in assert (NFlow c s t f) \\<bind>\n                            (\\<lambda>_. return (f, False))))))\n        \\<le> SPEC fofu_invar\\<rbrakk>\n       \\<Longrightarrow> (case x of None \\<Rightarrow> return (x1_, True)\n                          | Some p \\<Rightarrow>\n                              assert (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  assert\n                                   (NPreflow.isAugmentingPath c s t x1_\n                                     p) \\<bind>\n                                  (\\<lambda>_.\nassert (Graph.isShortestPath (cf_of x1_) s p t) \\<bind>\n(\\<lambda>_.\n    let f = NFlow.augment_with_path c x1_ p\n    in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False))))))\n                         \\<le> (spec s'. (s', x1_, False) \\<in> edka_wf_rel)", "apply (auto split: option.split \n      simp: NFlow.augment_with_path_def\n      simp: assert_bind_spec_conv Let_def\n      simp: find_shortest_augmenting_spec_def\n      simp: edka_wf_rel_def NFlow.shortest_path_decr_ek_measure\n    ; fail) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (13 subgoals):\n 1. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>_. 0::'capacity, False), \\<lambda>_. 0::'capacity, False)\n    \\<in> Id \\<times>\\<^sub>r bool_rel\n 2. \\<And>x x' x1 x2.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t x1\n 3. \\<And>x x' x1 x2 p.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2); x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> NPreflow.isAugmentingPath c s t x1 p\n 4. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x;\n        fofu_invar x'; x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 5. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec x1a\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n             nat_rel\\<rangle>list_rel\\<rangle>option_rel)\n                                (find_shortest_augmenting_spec x1)\n 6. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = None;\n        pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 7. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = Some xa;\n        pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = Some xa;\n        pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> NPreflow.isAugmentingPath c s t x1a xa\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = Some xa;\n        pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> [];\n        NPreflow.isAugmentingPath c s t x1a xa\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath (cf_of x1a) s xa t\n 10. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n        \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n         case x of (f, brk) \\<Rightarrow> \\<not> brk;\n         case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n         fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n         (p, pa)\n         \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                 nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n         inres (find_shortest_augmenting_spec x1a) p;\n         inres (find_shortest_augmenting_spec x1) pa;\n         nofail (find_shortest_augmenting_spec x1a);\n         nofail (find_shortest_augmenting_spec x1); p = Some xa;\n         pa = Some x'a;\n         (xa, x'a)\n         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n         x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n         Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> [];\n         NPreflow.isAugmentingPath c s t x1a xa;\n         Graph.isShortestPath (cf_of x1a) s xa t;\n         NFlow c s t (NFlow.augment_with_path c x1 x'a)\\<rbrakk>\n        \\<Longrightarrow> NFlow c s t (NFlow.augment_with_path c x1a xa)\nA total of 13 subgoals...", "txt \\<open>The other VCs are straightforward\\<close>"], ["proof (prove)\ngoal (13 subgoals):\n 1. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>_. 0::'capacity, False), \\<lambda>_. 0::'capacity, False)\n    \\<in> Id \\<times>\\<^sub>r bool_rel\n 2. \\<And>x x' x1 x2.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t x1\n 3. \\<And>x x' x1 x2 p.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2); x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> NPreflow.isAugmentingPath c s t x1 p\n 4. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x;\n        fofu_invar x'; x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 5. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec x1a\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n             nat_rel\\<rangle>list_rel\\<rangle>option_rel)\n                                (find_shortest_augmenting_spec x1)\n 6. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = None;\n        pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 7. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = Some xa;\n        pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = Some xa;\n        pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> NPreflow.isAugmentingPath c s t x1a xa\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n        fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        inres (find_shortest_augmenting_spec x1a) p;\n        inres (find_shortest_augmenting_spec x1) pa;\n        nofail (find_shortest_augmenting_spec x1a);\n        nofail (find_shortest_augmenting_spec x1); p = Some xa;\n        pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> [];\n        NPreflow.isAugmentingPath c s t x1a xa\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath (cf_of x1a) s xa t\n 10. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n        \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n         case x of (f, brk) \\<Rightarrow> \\<not> brk;\n         case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x;\n         fofu_invar x'; x' = (x1, x2); x = (x1a, x2a);\n         (p, pa)\n         \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                 nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n         inres (find_shortest_augmenting_spec x1a) p;\n         inres (find_shortest_augmenting_spec x1) pa;\n         nofail (find_shortest_augmenting_spec x1a);\n         nofail (find_shortest_augmenting_spec x1); p = Some xa;\n         pa = Some x'a;\n         (xa, x'a)\n         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n         x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n         Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> [];\n         NPreflow.isAugmentingPath c s t x1a xa;\n         Graph.isShortestPath (cf_of x1a) s xa t;\n         NFlow c s t (NFlow.augment_with_path c x1 x'a)\\<rbrakk>\n        \\<Longrightarrow> NFlow c s t (NFlow.augment_with_path c x1a xa)\nA total of 13 subgoals...", "apply (vc_solve)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Complexity Analysis\\<close>"], ["", "text \\<open>For the complexity analysis, we additionally show that the measure\n  function is bounded by $O(VE)$. Note that our absolute bound is not as \n  precise as possible, but clearly $O(VE)$.\\<close>"], ["", "(* TODO: #edgesSp even bound by |E|, as either e or swap e lays on shortest path! *)"], ["", "lemma ekMeasure_upper_bound: \n  \"ek_analysis_defs.ekMeasure (residualGraph c (\\<lambda>_. 0)) s t \n   < 2 * card V * card E + card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ek_analysis_defs.ekMeasure (cf_of (\\<lambda>_. 0::'capacity)) s t\n    < 2 * card V * card E + card V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ek_analysis_defs.ekMeasure (cf_of (\\<lambda>_. 0::'capacity)) s t\n    < 2 * card V * card E + card V", "interpret NFlow c s t \"(\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t (\\<lambda>_. 0::'capacity)", "by unfold_locales (auto simp: s_node t_node cap_non_negative)"], ["proof (state)\ngoal (1 subgoal):\n 1. ek_analysis_defs.ekMeasure cf s t < 2 * card V * card E + card V", "interpret ek: ek_analysis cf"], ["proof (prove)\ngoal (1 subgoal):\n 1. ek_analysis cf", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. ek.ekMeasure < 2 * card V * card E + card V", "have cardV_positive: \"card V > 0\" and cardE_positive: \"card E > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card V &&& 0 < card E", "using card_0_eq[OF finite_V] V_not_empty"], ["proof (prove)\nusing this:\n  (card V = 0) = (V = {})\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < card V &&& 0 < card E", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card E", "using card_0_eq[OF finite_E] E_not_empty"], ["proof (prove)\nusing this:\n  (card E = 0) = (E = {})\n  E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < card E", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < card V\n  0 < card E\n\ngoal (1 subgoal):\n 1. ek.ekMeasure < 2 * card V * card E + card V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ek.ekMeasure < 2 * card V * card E + card V", "proof (cases \"cf.connected s t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V\n 2. \\<not> cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "case False"], ["proof (state)\nthis:\n  \\<not> cf.connected s t\n\ngoal (2 subgoals):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V\n 2. \\<not> cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "hence \"ek.ekMeasure = 0\""], ["proof (prove)\nusing this:\n  \\<not> cf.connected s t\n\ngoal (1 subgoal):\n 1. ek.ekMeasure = 0", "by (auto simp: ek.ekMeasure_def)"], ["proof (state)\nthis:\n  ek.ekMeasure = 0\n\ngoal (2 subgoals):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V\n 2. \\<not> cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "with cardV_positive cardE_positive"], ["proof (chain)\npicking this:\n  0 < card V\n  0 < card E\n  ek.ekMeasure = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < card V\n  0 < card E\n  ek.ekMeasure = 0\n\ngoal (1 subgoal):\n 1. ek.ekMeasure < 2 * card V * card E + card V", "by auto"], ["proof (state)\nthis:\n  ek.ekMeasure < 2 * card V * card E + card V\n\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "case True"], ["proof (state)\nthis:\n  cf.connected s t\n\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "have \"cf.min_dist s t > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < cf.min_dist s t", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 0 < cf.min_dist s t \\<Longrightarrow> False", "apply (auto simp: Graph.min_dist_z_iff True s_not_t[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < cf.min_dist s t\n\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "have \"cf = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf = c", "unfolding residualGraph_def E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(u, v).\n        if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'capacity)}\n        then c (u, v) - (0::'capacity)\n        else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'capacity)}\n             then 0::'capacity else (0::'capacity)) =\n    c", "by auto"], ["proof (state)\nthis:\n  cf = c\n\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "hence \"ek.uE = E\\<union>E\\<inverse>\""], ["proof (prove)\nusing this:\n  cf = c\n\ngoal (1 subgoal):\n 1. ek.uE = E \\<union> E\\<inverse>", "unfolding ek.uE_def"], ["proof (prove)\nusing this:\n  cf = c\n\ngoal (1 subgoal):\n 1. cf.E \\<union> cf.E\\<inverse> = E \\<union> E\\<inverse>", "by simp"], ["proof (state)\nthis:\n  ek.uE = E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "from True"], ["proof (chain)\npicking this:\n  cf.connected s t", "have \"ek.ekMeasure \n      = (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + (card (ek.spEdges))\""], ["proof (prove)\nusing this:\n  cf.connected s t\n\ngoal (1 subgoal):\n 1. ek.ekMeasure =\n    (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges", "unfolding ek.ekMeasure_def"], ["proof (prove)\nusing this:\n  cf.connected s t\n\ngoal (1 subgoal):\n 1. (if cf.connected s t\n     then (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges\n     else 0) =\n    (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges", "by simp"], ["proof (state)\nthis:\n  ek.ekMeasure =\n  (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges\n\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "also"], ["proof (state)\nthis:\n  ek.ekMeasure =\n  (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges\n\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "from \n      mlex_bound[of \"card cf.V - cf.min_dist s t\" \"card V\", \n                 OF _ ek.card_spEdges_less]"], ["proof (chain)\npicking this:\n  card cf.V - cf.min_dist s t < card V \\<Longrightarrow>\n  (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges\n  < card V * (card ek.uE + 1)", "have \"\\<dots> < card V * (card ek.uE+1)\""], ["proof (prove)\nusing this:\n  card cf.V - cf.min_dist s t < card V \\<Longrightarrow>\n  (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges\n  < card V * (card ek.uE + 1)\n\ngoal (1 subgoal):\n 1. (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges\n    < card V * (card ek.uE + 1)", "using \\<open>cf.min_dist s t > 0\\<close> \\<open>card V > 0\\<close>"], ["proof (prove)\nusing this:\n  card cf.V - cf.min_dist s t < card V \\<Longrightarrow>\n  (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges\n  < card V * (card ek.uE + 1)\n  0 < cf.min_dist s t\n  0 < card V\n\ngoal (1 subgoal):\n 1. (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges\n    < card V * (card ek.uE + 1)", "by (auto simp: resV_netV)"], ["proof (state)\nthis:\n  (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges\n  < card V * (card ek.uE + 1)\n\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "also"], ["proof (state)\nthis:\n  (card cf.V - cf.min_dist s t) * (card ek.uE + 1) + card ek.spEdges\n  < card V * (card ek.uE + 1)\n\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "have \"card ek.uE \\<le> 2*card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ek.uE \\<le> 2 * card E", "unfolding \\<open>ek.uE = E\\<union>E\\<inverse>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (E \\<union> E\\<inverse>) \\<le> 2 * card E", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. card (E \\<union> E\\<inverse>) \\<le> ?y\n 2. ?y \\<le> 2 * card E", "apply (rule card_Un_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card E + card (E\\<inverse>) \\<le> 2 * card E", "by auto"], ["proof (state)\nthis:\n  card ek.uE \\<le> 2 * card E\n\ngoal (1 subgoal):\n 1. cf.connected s t \\<Longrightarrow>\n    ek.ekMeasure < 2 * card V * card E + card V", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      card V * (x + 1) \\<le> card V * (y + 1)) \\<Longrightarrow>\n  ek.ekMeasure < card V * (2 * card E + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      card V * (x + 1) \\<le> card V * (y + 1)) \\<Longrightarrow>\n  ek.ekMeasure < card V * (2 * card E + 1)\n\ngoal (1 subgoal):\n 1. ek.ekMeasure < 2 * card V * card E + card V", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  ek.ekMeasure < 2 * card V * card E + card V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ek.ekMeasure < 2 * card V * card E + card V\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, we present a version of the Edmonds-Karp algorithm \n  which is instrumented with a loop counter, and asserts that\n  there are less than $2|V||E|+|V| = O(|V||E|)$ iterations.\n\n  Note that we only count the non-breaking loop iterations.\n  \\<close>"], ["", "text \\<open>The refinement is achieved by a refinement relation, coupling the \n  instrumented loop state with the uninstrumented one\\<close>"], ["", "definition \"edkac_rel \\<equiv> {((f,brk,itc), (f,brk)) | f brk itc.\n    itc + ek_analysis_defs.ekMeasure (residualGraph c f) s t \n  < 2 * card V * card E + card V\n}\""], ["", "definition \"edka_complexity \\<equiv> do {\n  let f = (\\<lambda>_. 0);\n\n  (f,_,itc) \\<leftarrow> while\\<^sub>T \n    (\\<lambda>(f,brk,_). \\<not>brk) \n    (\\<lambda>(f,_,itc). do {\n      p \\<leftarrow> find_shortest_augmenting_spec f;\n      case p of \n        None \\<Rightarrow> return (f,True,itc)\n      | Some p \\<Rightarrow> do {\n          let f = NFlow.augment_with_path c f p;\n          return (f, False,itc + 1)\n        }  \n    })\n    (f,False,0);\n  assert (itc < 2 * card V * card E + card V);\n  return f \n}\""], ["", "lemma edka_complexity_refine: \"edka_complexity \\<le> \\<Down>Id edka\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edka_complexity \\<le> \\<Down> Id edka", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. edka_complexity \\<le> \\<Down> Id edka", "have [refine_dref_RELATES]: \n    \"RELATES edkac_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES edkac_rel", "by (auto simp: RELATES_def)"], ["proof (state)\nthis:\n  RELATES edkac_rel\n\ngoal (1 subgoal):\n 1. edka_complexity \\<le> \\<Down> Id edka", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. edka_complexity \\<le> \\<Down> Id edka", "unfolding edka_complexity_def edka_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let f = \\<lambda>_. 0::'capacity\n     in while\\<^sub>T (\\<lambda>(f, brk, uu_). \\<not> brk)\n         (\\<lambda>(f, uu_, itc).\n             find_shortest_augmenting_spec f \\<bind>\n             (\\<lambda>p.\n                 case p of None \\<Rightarrow> return (f, True, itc)\n                 | Some p \\<Rightarrow>\n                     let f = NFlow.augment_with_path c f p\n                     in return (f, False, itc + 1)))\n         (f, False, 0) \\<bind>\n        (\\<lambda>(f, uu_, itc).\n            assert (itc < 2 * card V * card E + card V) \\<bind>\n            (\\<lambda>_. return f)))\n    \\<le> \\<Down> Id\n           (let f = \\<lambda>_. 0::'capacity\n            in while\\<^sub>T\\<^bsup>fofu_invar\\<^esup>\n                (\\<lambda>(f, brk). \\<not> brk)\n                (\\<lambda>(f, uu_).\n                    find_shortest_augmenting_spec f \\<bind>\n                    (\\<lambda>p.\n                        case p of None \\<Rightarrow> return (f, True)\n                        | Some p \\<Rightarrow>\n                            assert (p \\<noteq> []) \\<bind>\n                            (\\<lambda>_.\n                                assert\n                                 (NPreflow.isAugmentingPath c s t f\n                                   p) \\<bind>\n                                (\\<lambda>_.\n                                    assert\n                                     (Graph.isShortestPath (cf_of f) s p\n t) \\<bind>\n                                    (\\<lambda>_.\n  let f = NFlow.augment_with_path c f p\n  in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False)))))))\n                (f, False) \\<bind>\n               (\\<lambda>(f, uu_).\n                   assert (NFlow c s t f) \\<bind> (\\<lambda>_. return f)))", "apply (refine_rcg)"], ["proof (prove)\ngoal (8 subgoals):\n 1. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>_. 0::'capacity, False, 0), \\<lambda>_. 0::'capacity, False)\n    \\<in> ?R'1\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(x, x') \\<in> ?R'1; fofu_invar x'; x2 = (x1a, x2a);\n        x = (x1, x2); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x1a) = (\\<not> x2b)\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk, uu_) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x2a = (x1b, x2b); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec x1a\n                         \\<le> \\<Down> (?R'63 x x' x1 x2 x1a x2a x1b x2b)\n                                (find_shortest_augmenting_spec x1)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk, uu_) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x2a = (x1b, x2b); x = (x1a, x2a);\n        (p, pa) \\<in> ?R'63 x x' x1 x2 x1a x2a x1b x2b\\<rbrakk>\n       \\<Longrightarrow> (p, pa)\n                         \\<in> \\<langle>?Ra64 x x' x1 x2 x1a x2a x1b x2b p\n   pa\\<rangle>option_rel\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk, uu_) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x2a = (x1b, x2b); x = (x1a, x2a);\n        (p, pa) \\<in> ?R'63 x x' x1 x2 x1a x2a x1b x2b; p = None;\n        pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True, x2b), x1, True) \\<in> ?R'1\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (f, brk, uu_) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x2a = (x1b, x2b); x = (x1a, x2a);\n        (p, pa) \\<in> ?R'63 x x' x1 x2 x1a x2a x1b x2b; p = Some xa;\n        pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra64 x x' x1 x2 x1a x2a x1b x2b p pa;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a)\\<rbrakk>\n       \\<Longrightarrow> ((NFlow.augment_with_path c x1a xa, False,\n                           x2b + 1),\n                          NFlow.augment_with_path c x1 x'a, False)\n                         \\<in> ?R'1\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(x, x') \\<in> ?R'1; x' = (x1, x2); x2a = (x1b, x2b);\n        x = (x1a, x2a); NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> x2b < 2 * card V * card E + card V\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(x, x') \\<in> ?R'1; x' = (x1, x2); x2a = (x1b, x2b);\n        x = (x1a, x2a); NFlow c s t x1;\n        x2b < 2 * card V * card E + card V\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> Id", "apply (refine_dref_type)"], ["proof (prove)\ngoal (7 subgoals):\n 1. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>_. 0::'capacity, False, 0), \\<lambda>_. 0::'capacity, False)\n    \\<in> edkac_rel\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(x, x') \\<in> edkac_rel; fofu_invar x'; x2 = (x1a, x2a);\n        x = (x1, x2); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x1a) = (\\<not> x2b)\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(x, x') \\<in> edkac_rel;\n        case x of (f, brk, uu_) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x2a = (x1b, x2b); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec x1a\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n             nat_rel\\<rangle>list_rel\\<rangle>option_rel)\n                                (find_shortest_augmenting_spec x1)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b p pa.\n       \\<lbrakk>(x, x') \\<in> edkac_rel;\n        case x of (f, brk, uu_) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x2a = (x1b, x2b); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = None; pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True, x2b), x1, True) \\<in> edkac_rel\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> edkac_rel;\n        case x of (f, brk, uu_) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x2a = (x1b, x2b); x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a)\\<rbrakk>\n       \\<Longrightarrow> ((NFlow.augment_with_path c x1a xa, False,\n                           x2b + 1),\n                          NFlow.augment_with_path c x1 x'a, False)\n                         \\<in> edkac_rel\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(x, x') \\<in> edkac_rel; x' = (x1, x2); x2a = (x1b, x2b);\n        x = (x1a, x2a); NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> x2b < 2 * card V * card E + card V\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(x, x') \\<in> edkac_rel; x' = (x1, x2); x2a = (x1b, x2b);\n        x = (x1a, x2a); NFlow c s t x1;\n        x2b < 2 * card V * card E + card V\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> Id", "apply (vc_solve simp: edkac_rel_def \"NFlow.augment_with_path_def\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. NFlow c s t (\\<lambda>_. 0::'capacity) \\<Longrightarrow>\n    ek_analysis_defs.ekMeasure (cf_of (\\<lambda>_. 0::'capacity)) s t\n    < 2 * card V * card E + card V\n 2. \\<And>x1 x2 x1b x2b x'a.\n       \\<lbrakk>\\<not> x1b; NFlow c s t x1; x'a \\<noteq> [];\n        NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        NFlow c s t (NFlow.augment c x1 (NPreflow.augmentingFlow c x1 x'a));\n        \\<not> x2;\n        x2b + ek_analysis_defs.ekMeasure (cf_of x1) s t\n        < 2 * card V * card E + card V\\<rbrakk>\n       \\<Longrightarrow> Suc (x2b +\n                              ek_analysis_defs.ekMeasure\n                               (cf_of\n                                 (NFlow.augment c x1\n                                   (NPreflow.augmentingFlow c x1 x'a)))\n                               s t)\n                         < 2 * card V * card E + card V", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t (\\<lambda>_. 0::'capacity) \\<Longrightarrow>\n    ek_analysis_defs.ekMeasure (cf_of (\\<lambda>_. 0::'capacity)) s t\n    < 2 * card V * card E + card V", "using ekMeasure_upper_bound"], ["proof (prove)\nusing this:\n  ek_analysis_defs.ekMeasure (cf_of (\\<lambda>_. 0::'capacity)) s t\n  < 2 * card V * card E + card V\n\ngoal (1 subgoal):\n 1. NFlow c s t (\\<lambda>_. 0::'capacity) \\<Longrightarrow>\n    ek_analysis_defs.ekMeasure (cf_of (\\<lambda>_. 0::'capacity)) s t\n    < 2 * card V * card E + card V", "by auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1b x2b x'a.\n       \\<lbrakk>\\<not> x1b; NFlow c s t x1; x'a \\<noteq> [];\n        NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        NFlow c s t (NFlow.augment c x1 (NPreflow.augmentingFlow c x1 x'a));\n        \\<not> x2;\n        x2b + ek_analysis_defs.ekMeasure (cf_of x1) s t\n        < 2 * card V * card E + card V\\<rbrakk>\n       \\<Longrightarrow> Suc (x2b +\n                              ek_analysis_defs.ekMeasure\n                               (cf_of\n                                 (NFlow.augment c x1\n                                   (NPreflow.augmentingFlow c x1 x'a)))\n                               s t)\n                         < 2 * card V * card E + card V", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> x1b_; NFlow c s t x1_; x'a_ \\<noteq> [];\n     NPreflow.isAugmentingPath c s t x1_ x'a_;\n     Graph.isShortestPath (cf_of x1_) s x'a_ t;\n     NFlow c s t (NFlow.augment c x1_ (NPreflow.augmentingFlow c x1_ x'a_));\n     \\<not> x2_;\n     x2b_ + ek_analysis_defs.ekMeasure (cf_of x1_) s t\n     < 2 * card V * card E + card V\\<rbrakk>\n    \\<Longrightarrow> Suc (x2b_ +\n                           ek_analysis_defs.ekMeasure\n                            (cf_of\n                              (NFlow.augment c x1_\n                                (NPreflow.augmentingFlow c x1_ x'a_)))\n                            s t)\n                      < 2 * card V * card E + card V", "by (drule (1) NFlow.shortest_path_decr_ek_measure; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  edka_complexity \\<le> \\<Down> Id edka\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We show that this algorithm never fails, and computes a maximum flow.\\<close>"], ["", "theorem \"edka_complexity \\<le> (spec f. isMaxFlow f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edka_complexity \\<le> SPEC isMaxFlow", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. edka_complexity \\<le> SPEC isMaxFlow", "note edka_complexity_refine"], ["proof (state)\nthis:\n  edka_complexity \\<le> \\<Down> Id edka\n\ngoal (1 subgoal):\n 1. edka_complexity \\<le> SPEC isMaxFlow", "also"], ["proof (state)\nthis:\n  edka_complexity \\<le> \\<Down> Id edka\n\ngoal (1 subgoal):\n 1. edka_complexity \\<le> SPEC isMaxFlow", "note edka_refine"], ["proof (state)\nthis:\n  edka \\<le> \\<Down> Id edka_partial\n\ngoal (1 subgoal):\n 1. edka_complexity \\<le> SPEC isMaxFlow", "also"], ["proof (state)\nthis:\n  edka \\<le> \\<Down> Id edka_partial\n\ngoal (1 subgoal):\n 1. edka_complexity \\<le> SPEC isMaxFlow", "note edka_partial_refine"], ["proof (state)\nthis:\n  edka_partial \\<le> \\<Down> Id fofu\n\ngoal (1 subgoal):\n 1. edka_complexity \\<le> SPEC isMaxFlow", "also"], ["proof (state)\nthis:\n  edka_partial \\<le> \\<Down> Id fofu\n\ngoal (1 subgoal):\n 1. edka_complexity \\<le> SPEC isMaxFlow", "note fofu_partial_correct"], ["proof (state)\nthis:\n  fofu \\<le> SPEC isMaxFlow\n\ngoal (1 subgoal):\n 1. edka_complexity \\<le> SPEC isMaxFlow", "finally"], ["proof (chain)\npicking this:\n  edka_complexity \\<le> SPEC isMaxFlow", "show ?thesis"], ["proof (prove)\nusing this:\n  edka_complexity \\<le> SPEC isMaxFlow\n\ngoal (1 subgoal):\n 1. edka_complexity \\<le> SPEC isMaxFlow", "."], ["proof (state)\nthis:\n  edka_complexity \\<le> SPEC isMaxFlow\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "end \\<comment> \\<open>Theory\\<close>"]]}