{"file_name": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow/Edka_Checked_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow", "problem_names": ["lemma insert_stat_outer_c: \"m = stat_outer_c \\<then> m\"", "lemma insert_stat_inner_c: \"m = stat_inner_c \\<then> m\"", "lemma network_is_impl: \"Network c s t \\<Longrightarrow> Network_Impl c s t\"", "theorem edmonds_karp_correct:\n  \"<emp> edmonds_karp el s t <\\<lambda>\n      None \\<Rightarrow> \\<up>(\\<not>ln_invar el \\<or> \\<not>Network (ln_\\<alpha> el) s t)\n    | Some (c,am,N,fi) \\<Rightarrow> \n      \\<exists>\\<^sub>Af. Network_Impl.is_rflow c s t N f fi \n      * \\<up>(ln_\\<alpha> el = c \\<and> Graph.is_adj_map c am\n        \\<and> Network.isMaxFlow c s t f\n        \\<and> ln_invar el \\<and> Network c s t \\<and> Graph.V c \\<subseteq> {0..<N})\n  >\\<^sub>t\"", "theorem\n  fixes el defines \"c \\<equiv> ln_\\<alpha> el\"\n  shows \n    \"<emp> \n      edmonds_karp el s t \n    <\\<lambda> None \\<Rightarrow> \\<up>(\\<not>ln_invar el \\<or> \\<not>Network c s t)\n     | Some (_,_,N,cf) \\<Rightarrow> \n         \\<up>(ln_invar el \\<and> Network c s t \\<and> Graph.V c \\<subseteq> {0..<N})\n       * (\\<exists>\\<^sub>Af. is_rflow c s t N f cf * \\<up>(Network.isMaxFlow c s t f))\n    >\\<^sub>t\"", "lemma (in Network) am_s_is_incoming:\n  assumes \"is_adj_map am\"\n  shows \"E``{s} = set (am s)\"", "lemma val_by_adj_map:\n    assumes \"is_adj_map am\"\n    shows \"f.val = (\\<Sum>v\\<in>set (am s). c (s,v) - cf (s,v))\"", "lemma (in RGraph) compute_flow_val_correct:\n    assumes \"is_adj_map am\"\n    shows \"compute_flow_val am cf \\<le> (spec v. v = f.val)\"", "lemma (in RGraph) compute_flow_val2_correct:\n    assumes \"is_adj_map am\"\n    shows \"compute_flow_val2 am cf \\<le> (spec v. v = f.val)\"", "lemma [sepref_import_param]: \"(c,PR_CONST get_cap) \\<in> Id\\<times>\\<^sub>rId \\<rightarrow> Id\"", "lemma [def_pat_rules]: \n    \"Network.get_cap$c \\<equiv> UNPROTECT get_cap\"", "lemma [sepref_import_param]: \"(get_am,get_am) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>list_rel\"", "lemma compute_flow_val_imp_correct_aux: \n  assumes VN: \"Graph.V c \\<subseteq> {0..<N}\"\n  assumes ABS_PS: \"is_adj_map am\"\n  assumes RG: \"RGraph c s t cf\"\n  shows \"\n    <asmtx_assn N id_assn cf cfi> \n      compute_flow_val_imp c s N am cfi\n    <\\<lambda>v. asmtx_assn N id_assn cf cfi * \\<up>(v = Flow.val c s (flow_of_cf cf))>\\<^sub>t\"", "lemma compute_flow_val_imp_correct: \n  assumes VN: \"Graph.V c \\<subseteq> {0..<N}\"\n  assumes ABS_PS: \"Graph.is_adj_map c am\"\n  shows \"\n    <is_rflow N f cfi> \n      compute_flow_val_imp c s N am cfi\n    <\\<lambda>v. is_rflow N f cfi * \\<up>(v = Flow.val c s f)>\\<^sub>t\"", "theorem edmonds_karp_val_correct:\n  \"<emp> edmonds_karp_val el s t <\\<lambda>\n    None \\<Rightarrow> \\<up>(\\<not>ln_invar el \\<or> \\<not>Network (ln_\\<alpha> el) s t)\n  | Some v \\<Rightarrow> \\<up>(\\<exists>f N. \n          ln_invar el \\<and> Network (ln_\\<alpha> el) s t \n        \\<and> Graph.V (ln_\\<alpha> el) \\<subseteq> {0..<N}\n        \\<and> Network.isMaxFlow (ln_\\<alpha> el) s t f\n        \\<and> v = Flow.val (ln_\\<alpha> el) s f)  \n        >\\<^sub>t\""], "translations": [["", "lemma insert_stat_outer_c: \"m = stat_outer_c \\<then> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = stat_outer_c \\<bind> (\\<lambda>_. m)", "unfolding stat_outer_c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m = return () \\<bind> (\\<lambda>_. m)", "by simp"], ["", "definition stat_inner_c :: \"unit Heap\" where \"stat_inner_c = return ()\""], ["", "lemma insert_stat_inner_c: \"m = stat_inner_c \\<then> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = stat_inner_c \\<bind> (\\<lambda>_. m)", "unfolding stat_inner_c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m = return () \\<bind> (\\<lambda>_. m)", "by simp"], ["", "code_printing\n  code_module stat \\<rightharpoonup> (SML) \\<open>\n    structure stat = struct\n      val outer_c = ref 0;\n      fun outer_c_incr () = (outer_c := !outer_c + 1; ())\n      val inner_c = ref 0;\n      fun inner_c_incr () = (inner_c := !inner_c + 1; ())\n    end\n    \\<close>\n| constant stat_outer_c \\<rightharpoonup> (SML) \"stat.outer'_c'_incr\"  \n| constant stat_inner_c \\<rightharpoonup> (SML) \"stat.inner'_c'_incr\""], ["", "schematic_goal [code]: \"edka_imp_run_0 s t N f brk = ?foo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edka_imp_run_0 s t N f brk = ?foo", "apply (subst edka_imp_run.code)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if case brk of (a1, x) \\<Rightarrow> \\<not> x\n     then (case brk of\n           (a1, a2) \\<Rightarrow>\n             bfsi' N s t f a1 \\<bind>\n             case_option (return (a1, True))\n              (\\<lambda>x'b.\n                  resCap_imp N a1 x'b \\<bind>\n                  (\\<lambda>x'c.\n                      augment_imp N a1 x'b x'c \\<bind>\n                      (\\<lambda>x'd. return (x'd, False))))) \\<bind>\n          edka_imp_run_0 s t N f\n     else return brk) =\n    ?foo", "apply (rewrite in \"\\<hole>\" insert_stat_outer_c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. stat_outer_c \\<bind>\n    (\\<lambda>_.\n        if case brk of (a1, x) \\<Rightarrow> \\<not> x\n        then (case brk of\n              (a1, a2) \\<Rightarrow>\n                bfsi' N s t f a1 \\<bind>\n                case_option (return (a1, True))\n                 (\\<lambda>x'b.\n                     resCap_imp N a1 x'b \\<bind>\n                     (\\<lambda>x'c.\n                         augment_imp N a1 x'b x'c \\<bind>\n                         (\\<lambda>x'd. return (x'd, False))))) \\<bind>\n             edka_imp_run_0 s t N f\n        else return brk) =\n    ?foo", "by (rule refl)"], ["", "thm bfs_impl.code"], ["", "schematic_goal [code]: \"bfs_impl_0 succ_impl ci ti x = ?foo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bfs_impl_0 succ_impl ci ti x = ?foo", "apply (subst bfs_impl.code)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if case x of\n        (a1, a1a, a1b, a1c, a2c) \\<Rightarrow>\n          a1 = False \\<and> \\<not> is_Nil a1b\n     then (case x of\n           (a1, a1a, a1b, a1c, a2c) \\<Rightarrow>\n             let x'b = hd a1b; x'c = glist_delete (=) x'b a1b\n             in succ_impl ci x'b \\<bind>\n                (\\<lambda>x'e.\n                    imp_nfoldli x'e\n                     (\\<lambda>(a1d, a1e, a2e). return (\\<not> a1d))\n                     (\\<lambda>xg (a1d, a1e, a2e).\n                         iam.contains_key xg a1e \\<bind>\n                         (\\<lambda>x'h.\n                             if x'h then return (a1d, a1e, a2e)\n                             else Array_Map_Impl.iam_update xg x'b\n                                   a1e \\<bind>\n                                  (\\<lambda>x'i.\nreturn (xg = ti, x'i, xg # a2e))))\n                     (False, a1a, a1c) \\<bind>\n                    (\\<lambda>(a1d, a1e, a2e).\n                        return\n                         (if a1d then (a1d, a1e, x'c, a2e, a2c + 1)\n                          else if is_Nil x'c\n                               then (a1d, a1e, a2e, [], a2c + 1)\n                               else (a1d, a1e, x'c, a2e, a2c))))) \\<bind>\n          bfs_impl_0 succ_impl ci ti\n     else return x) =\n    ?foo", "apply (rewrite in \"imp_nfoldli _ _ \\<hole> _\" insert_stat_inner_c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if case x of\n        (a1, a1a, a1b, a1c, a2c) \\<Rightarrow>\n          a1 = False \\<and> \\<not> is_Nil a1b\n     then (case x of\n           (a1, a1a, a1b, a1c, a2c) \\<Rightarrow>\n             let x'b = hd a1b; x'c = glist_delete (=) x'b a1b\n             in succ_impl ci x'b \\<bind>\n                (\\<lambda>x'e.\n                    imp_nfoldli x'e\n                     (\\<lambda>(a1d, a1e, a2e). return (\\<not> a1d))\n                     (\\<lambda>xg (a1d, a1e, a2e).\n                         stat_inner_c \\<bind>\n                         (\\<lambda>_.\n                             iam.contains_key xg a1e \\<bind>\n                             (\\<lambda>x'h.\n                                 if x'h then return (a1d, a1e, a2e)\n                                 else Array_Map_Impl.iam_update xg x'b\n a1e \\<bind>\n(\\<lambda>x'i. return (xg = ti, x'i, xg # a2e)))))\n                     (False, a1a, a1c) \\<bind>\n                    (\\<lambda>(a1d, a1e, a2e).\n                        return\n                         (if a1d then (a1d, a1e, x'c, a2e, a2c + 1)\n                          else if is_Nil x'c\n                               then (a1d, a1e, a2e, [], a2c + 1)\n                               else (a1d, a1e, x'c, a2e, a2c))))) \\<bind>\n          bfs_impl_0 succ_impl ci ti\n     else return x) =\n    ?foo", "by (rule refl)"], ["", "subsection \\<open>Combined Algorithm\\<close>"], ["", "definition \"edmonds_karp el s t \\<equiv> do {\n  case prepareNet el s t of\n    None \\<Rightarrow> return None\n  | Some (c,am,N) \\<Rightarrow> do {\n      f \\<leftarrow> edka_imp c s t N am ;\n      return (Some (c,am,N,f))\n  }\n}\""], ["", "export_code edmonds_karp checking SML"], ["", "lemma network_is_impl: \"Network c s t \\<Longrightarrow> Network_Impl c s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network c s t \\<Longrightarrow> Network_Impl c s t", "by intro_locales"], ["", "theorem edmonds_karp_correct:\n  \"<emp> edmonds_karp el s t <\\<lambda>\n      None \\<Rightarrow> \\<up>(\\<not>ln_invar el \\<or> \\<not>Network (ln_\\<alpha> el) s t)\n    | Some (c,am,N,fi) \\<Rightarrow> \n      \\<exists>\\<^sub>Af. Network_Impl.is_rflow c s t N f fi \n      * \\<up>(ln_\\<alpha> el = c \\<and> Graph.is_adj_map c am\n        \\<and> Network.isMaxFlow c s t f\n        \\<and> ln_invar el \\<and> Network c s t \\<and> Graph.V c \\<subseteq> {0..<N})\n  >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> edmonds_karp el s\n           t <\\<lambda>r.\n                 case r of\n                 None \\<Rightarrow>\n                   \\<up>\n                    (\\<not> ln_invar el \\<or>\n                     \\<not> Network (ln_\\<alpha> el) s t)\n                 | Some (c, am, N, fi) \\<Rightarrow>\n                     \\<exists>\\<^sub>Af.\n                        Network_Impl.is_rflow c s t N f fi *\n                        \\<up>\n                         (ln_\\<alpha> el = c \\<and>\n                          Graph.is_adj_map c am \\<and>\n                          Network.isMaxFlow c s t f \\<and>\n                          ln_invar el \\<and>\n                          Network c s t \\<and>\n                          Graph.V c \\<subseteq> {0..<N})>\\<^sub>t", "unfolding edmonds_karp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> case prepareNet el s t of None \\<Rightarrow> return None\n          | Some (c, am, N) \\<Rightarrow>\n              edka_imp c s t N am \\<bind>\n              (\\<lambda>f.\n                  return\n                   (Some\n                     (c, am, N,\n                      f))) <\\<lambda>r.\n                               case r of\n                               None \\<Rightarrow>\n                                 \\<up>\n                                  (\\<not> ln_invar el \\<or>\n                                   \\<not> Network (ln_\\<alpha> el) s t)\n                               | Some (c, am, N, fi) \\<Rightarrow>\n                                   \\<exists>\\<^sub>Af.\nNetwork_Impl.is_rflow c s t N f fi *\n\\<up>\n (ln_\\<alpha> el = c \\<and>\n  Graph.is_adj_map c am \\<and>\n  Network.isMaxFlow c s t f \\<and>\n  ln_invar el \\<and>\n  Network c s t \\<and> Graph.V c \\<subseteq> {0..<N})>\\<^sub>t", "using prepareNet_correct[of el s t]"], ["proof (prove)\nusing this:\n  case prepareNet el s t of\n  None \\<Rightarrow>\n    \\<not> ln_invar el \\<or> \\<not> Network (ln_\\<alpha> el) s t\n  | Some (c, adjmap, N) \\<Rightarrow>\n      (el, c) \\<in> ln_rel \\<and>\n      Network c s t \\<and>\n      Graph.is_adj_map c adjmap \\<and> Graph.V c \\<subseteq> {0..<N}\n\ngoal (1 subgoal):\n 1. <emp> case prepareNet el s t of None \\<Rightarrow> return None\n          | Some (c, am, N) \\<Rightarrow>\n              edka_imp c s t N am \\<bind>\n              (\\<lambda>f.\n                  return\n                   (Some\n                     (c, am, N,\n                      f))) <\\<lambda>r.\n                               case r of\n                               None \\<Rightarrow>\n                                 \\<up>\n                                  (\\<not> ln_invar el \\<or>\n                                   \\<not> Network (ln_\\<alpha> el) s t)\n                               | Some (c, am, N, fi) \\<Rightarrow>\n                                   \\<exists>\\<^sub>Af.\nNetwork_Impl.is_rflow c s t N f fi *\n\\<up>\n (ln_\\<alpha> el = c \\<and>\n  Graph.is_adj_map c am \\<and>\n  Network.isMaxFlow c s t f \\<and>\n  ln_invar el \\<and>\n  Network c s t \\<and> Graph.V c \\<subseteq> {0..<N})>\\<^sub>t", "by (sep_auto \n    split: option.splits \n    heap: Network_Impl.edka_imp_correct \n    simp: ln_rel_def br_def network_is_impl)"], ["", "context\nbegin"], ["", "private"], ["", "definition \"is_rflow \\<equiv> Network_Impl.is_rflow\""], ["", "text_raw \\<open>\\DefineSnippet{edmonds_karp_correct}{\\<close>"], ["", "theorem\n  fixes el defines \"c \\<equiv> ln_\\<alpha> el\"\n  shows \n    \"<emp> \n      edmonds_karp el s t \n    <\\<lambda> None \\<Rightarrow> \\<up>(\\<not>ln_invar el \\<or> \\<not>Network c s t)\n     | Some (_,_,N,cf) \\<Rightarrow> \n         \\<up>(ln_invar el \\<and> Network c s t \\<and> Graph.V c \\<subseteq> {0..<N})\n       * (\\<exists>\\<^sub>Af. is_rflow c s t N f cf * \\<up>(Network.isMaxFlow c s t f))\n    >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> edmonds_karp el s\n           t <\\<lambda>r.\n                 case r of\n                 None \\<Rightarrow>\n                   \\<up> (\\<not> ln_invar el \\<or> \\<not> Network c s t)\n                 | Some (x, xa, N, cf) \\<Rightarrow>\n                     \\<up>\n                      (ln_invar el \\<and>\n                       Network c s t \\<and> Graph.V c \\<subseteq> {0..<N}) *\n                     (\\<exists>\\<^sub>Af.\n                         is_rflow c s t N f cf *\n                         \\<up> (Network.isMaxFlow c s t f))>\\<^sub>t", "text_raw \\<open>}%EndSnippet\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> edmonds_karp el s\n           t <\\<lambda>r.\n                 case r of\n                 None \\<Rightarrow>\n                   \\<up> (\\<not> ln_invar el \\<or> \\<not> Network c s t)\n                 | Some (x, xa, N, cf) \\<Rightarrow>\n                     \\<up>\n                      (ln_invar el \\<and>\n                       Network c s t \\<and> Graph.V c \\<subseteq> {0..<N}) *\n                     (\\<exists>\\<^sub>Af.\n                         is_rflow c s t N f cf *\n                         \\<up> (Network.isMaxFlow c s t f))>\\<^sub>t", "unfolding c_def is_rflow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> edmonds_karp el s\n           t <\\<lambda>r.\n                 case r of\n                 None \\<Rightarrow>\n                   \\<up>\n                    (\\<not> ln_invar el \\<or>\n                     \\<not> Network (ln_\\<alpha> el) s t)\n                 | Some (x, xa, N, cf) \\<Rightarrow>\n                     \\<up>\n                      (ln_invar el \\<and>\n                       Network (ln_\\<alpha> el) s t \\<and>\n                       Graph.V (ln_\\<alpha> el) \\<subseteq> {0..<N}) *\n                     (\\<exists>\\<^sub>Af.\n                         Network_Impl.is_rflow (ln_\\<alpha> el) s t N f cf *\n                         \\<up>\n                          (Network.isMaxFlow (ln_\\<alpha> el) s t\n                            f))>\\<^sub>t", "by (sep_auto heap: edmonds_karp_correct[of el s t] split: option.split)"], ["", "end"], ["", "subsection \\<open>Usage Example: Computing Maxflow Value \\<close>"], ["", "text \\<open>We implement a function to compute the value of the maximum flow.\\<close>"], ["", "lemma (in Network) am_s_is_incoming:\n  assumes \"is_adj_map am\"\n  shows \"E``{s} = set (am s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {s} = set (am s)", "using assms no_incoming_s"], ["proof (prove)\nusing this:\n  is_adj_map am\n  \\<forall>u. (u, s) \\<notin> E\n\ngoal (1 subgoal):\n 1. E `` {s} = set (am s)", "unfolding is_adj_map_def"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     distinct (am u) \\<and>\n     set (am u) = E `` {u} \\<union> E\\<inverse> `` {u}\n  \\<forall>u. (u, s) \\<notin> E\n\ngoal (1 subgoal):\n 1. E `` {s} = set (am s)", "by auto"], ["", "context RGraph begin"], ["", "lemma val_by_adj_map:\n    assumes \"is_adj_map am\"\n    shows \"f.val = (\\<Sum>v\\<in>set (am s). c (s,v) - cf (s,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))", "have \"f.val = (\\<Sum>v\\<in>E``{s}. c (s,v) - cf (s,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>E `` {s}. c (s, v) - cf (s, v))", "unfolding f.val_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing s) = (\\<Sum>v\\<in>E `` {s}. c (s, v) - cf (s, v))", "by (simp add: sum_outgoing_pointwise f_def flow_of_cf_def)"], ["proof (state)\nthis:\n  f.val = (\\<Sum>v\\<in>E `` {s}. c (s, v) - cf (s, v))\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))", "also"], ["proof (state)\nthis:\n  f.val = (\\<Sum>v\\<in>E `` {s}. c (s, v) - cf (s, v))\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))", "have \"\\<dots> = (\\<Sum>v\\<in>set (am s). c (s,v) - cf (s,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>E `` {s}. c (s, v) - cf (s, v)) =\n    (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))", "by (simp add: am_s_is_incoming[OF assms])"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>E `` {s}. c (s, v) - cf (s, v)) =\n  (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))", "finally"], ["proof (chain)\npicking this:\n  f.val = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))", "show ?thesis"], ["proof (prove)\nusing this:\n  f.val = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))", "."], ["proof (state)\nthis:\n  f.val = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context Network \nbegin"], ["", "definition \"get_cap e \\<equiv> c e\""], ["", "definition (in -) get_am :: \"(node \\<Rightarrow> node list) \\<Rightarrow> node \\<Rightarrow> node list\" \n    where \"get_am am v \\<equiv> am v\""], ["", "definition \"compute_flow_val am cf \\<equiv> do {\n      let succs = get_am am s;\n      sum_impl \n      (\\<lambda>v. do {\n        let csv = get_cap (s,v);\n        cfsv \\<leftarrow> cf_get cf (s,v);\n        return (csv - cfsv)\n      }) (set succs)\n    }\""], ["", "lemma (in RGraph) compute_flow_val_correct:\n    assumes \"is_adj_map am\"\n    shows \"compute_flow_val am cf \\<le> (spec v. v = f.val)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_flow_val am cf \\<le> (spec v. v = f.val)", "unfolding val_by_adj_map[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_flow_val am cf\n    \\<le> (spec v. v = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v)))", "unfolding compute_flow_val_def cf_get_def get_cap_def get_am_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let succs = am s\n     in sum_impl\n         (\\<lambda>v.\n             let csv = c (s, v)\n             in assert\n                 (case (s, v) of\n                  (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V) \\<bind>\n                (\\<lambda>_. return (cf (s, v))) \\<bind>\n                (\\<lambda>cfsv. return (csv - cfsv)))\n         (set succs))\n    \\<le> (spec v. v = (\\<Sum>v\\<in>set (am s). c (s, v) - cf (s, v)))", "apply (refine_vcg sum_impl_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (set (am s))\n 2. \\<And>x x1 x2.\n       \\<lbrakk>x \\<in> set (am s); (s, x) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> V\n 3. \\<And>x x1 x2.\n       \\<lbrakk>x \\<in> set (am s); (s, x) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> V\n 4. \\<And>x.\n       \\<lbrakk>x \\<in> set (am s);\n        case (s, x) of\n        (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> c (s, x) - cf (s, x) = c (s, x) - cf (s, x)", "apply (vc_solve simp: s_node)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (am s) \\<Longrightarrow> x \\<in> V", "unfolding am_s_is_incoming[symmetric, OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> E `` {s} \\<Longrightarrow> x \\<in> V", "by (auto simp: V_def)"], ["", "text \\<open>For technical reasons (poor foreach-support of Sepref tool), \n    we have to add another refinement step: \\<close>"], ["", "definition \"compute_flow_val2 am cf \\<equiv> (do {\n    let succs = get_am am s;\n    nfoldli succs (\\<lambda>_. True)\n     (\\<lambda>x a. do {\n           b \\<leftarrow> do {\n               let csv = get_cap (s, x);\n               cfsv \\<leftarrow> cf_get cf (s, x);\n               return (csv - cfsv)\n             };\n           return (a + b)\n         })\n     0\n  })\""], ["", "lemma (in RGraph) compute_flow_val2_correct:\n    assumes \"is_adj_map am\"\n    shows \"compute_flow_val2 am cf \\<le> (spec v. v = f.val)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_flow_val2 am cf \\<le> (spec v. v = f.val)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. compute_flow_val2 am cf \\<le> (spec v. v = f.val)", "have [refine_dref_RELATES]: \"RELATES (\\<langle>Id\\<rangle>list_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES (\\<langle>Id\\<rangle>list_set_rel)", "by (simp add: RELATES_def)"], ["proof (state)\nthis:\n  RELATES (\\<langle>Id\\<rangle>list_set_rel)\n\ngoal (1 subgoal):\n 1. compute_flow_val2 am cf \\<le> (spec v. v = f.val)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_flow_val2 am cf \\<le> (spec v. v = f.val)", "apply (rule order_trans[OF _ compute_flow_val_correct[OF assms]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_flow_val2 am cf \\<le> compute_flow_val am cf", "unfolding compute_flow_val2_def compute_flow_val_def sum_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let succs = get_am am s\n     in nfoldli succs (\\<lambda>_. True)\n         (\\<lambda>x a.\n             (let csv = get_cap (s, x)\n              in cf_get cf (s, x) \\<bind>\n                 (\\<lambda>cfsv. return (csv - cfsv))) \\<bind>\n             (\\<lambda>b. return (a + b)))\n         (0::'a))\n    \\<le> (let succs = get_am am s\n           in foreach (set succs)\n               (\\<lambda>x a.\n                   (let csv = get_cap (s, x)\n                    in cf_get cf (s, x) \\<bind>\n                       (\\<lambda>cfsv. return (csv - cfsv))) \\<bind>\n                   (\\<lambda>b. return (a + b)))\n               (0::'a))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let succs = get_am am s\n     in nfoldli succs (\\<lambda>_. True)\n         (\\<lambda>x a.\n             (let csv = get_cap (s, x)\n              in cf_get cf (s, x) \\<bind>\n                 (\\<lambda>cfsv. return (csv - cfsv))) \\<bind>\n             (\\<lambda>b. return (a + b)))\n         (0::'a))\n    \\<le> \\<Down> Id\n           (let succs = get_am am s\n            in foreach (set succs)\n                (\\<lambda>x a.\n                    (let csv = get_cap (s, x)\n                     in cf_get cf (s, x) \\<bind>\n                        (\\<lambda>cfsv. return (csv - cfsv))) \\<bind>\n                    (\\<lambda>b. return (a + b)))\n                (0::'a))", "apply (refine_rcg LFO_refine bind_refine')"], ["proof (prove)\ngoal (5 subgoals):\n 1. (get_am am s, set (get_am am s)) \\<in> \\<langle>?A7\\<rangle>list_set_rel\n 2. \\<And>x xi sa si.\n       \\<lbrakk>(xi, x) \\<in> ?A7; (si, sa) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> cf_get cf (s, xi)\n                         \\<le> \\<Down> (?R'10 x xi sa si) (cf_get cf (s, x))\n 3. \\<And>x xi sa si cfsv cfsva.\n       \\<lbrakk>(xi, x) \\<in> ?A7; (si, sa) \\<in> Id;\n        (cfsv, cfsva) \\<in> ?R'10 x xi sa si;\n        inres (cf_get cf (s, xi)) cfsv; inres (cf_get cf (s, x)) cfsva;\n        nofail (cf_get cf (s, xi)); nofail (cf_get cf (s, x))\\<rbrakk>\n       \\<Longrightarrow> (get_cap (s, xi) - cfsv, get_cap (s, x) - cfsva)\n                         \\<in> ?R'8 x xi sa si\n 4. \\<And>x xi sa si b ba.\n       \\<lbrakk>(xi, x) \\<in> ?A7; (si, sa) \\<in> Id;\n        (b, ba) \\<in> ?R'8 x xi sa si;\n        inres\n         (let csv = get_cap (s, xi)\n          in cf_get cf (s, xi) \\<bind> (\\<lambda>cfsv. return (csv - cfsv)))\n         b;\n        inres\n         (let csv = get_cap (s, x)\n          in cf_get cf (s, x) \\<bind> (\\<lambda>cfsv. return (csv - cfsv)))\n         ba;\n        nofail\n         (let csv = get_cap (s, xi)\n          in cf_get cf (s, xi) \\<bind>\n             (\\<lambda>cfsv. return (csv - cfsv)));\n        nofail\n         (let csv = get_cap (s, x)\n          in cf_get cf (s, x) \\<bind>\n             (\\<lambda>cfsv. return (csv - cfsv)))\\<rbrakk>\n       \\<Longrightarrow> (si + b, sa + ba) \\<in> Id\n 5. (0::'a, 0::'a) \\<in> Id", "apply refine_dref_type"], ["proof (prove)\ngoal (5 subgoals):\n 1. (get_am am s, set (get_am am s))\n    \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 2. \\<And>x xi sa si.\n       \\<lbrakk>(xi, x) \\<in> nat_rel; (si, sa) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> cf_get cf (s, xi)\n                         \\<le> \\<Down> Id (cf_get cf (s, x))\n 3. \\<And>x xi sa si cfsv cfsva.\n       \\<lbrakk>(xi, x) \\<in> nat_rel; (si, sa) \\<in> Id;\n        (cfsv, cfsva) \\<in> Id; inres (cf_get cf (s, xi)) cfsv;\n        inres (cf_get cf (s, x)) cfsva; nofail (cf_get cf (s, xi));\n        nofail (cf_get cf (s, x))\\<rbrakk>\n       \\<Longrightarrow> (get_cap (s, xi) - cfsv, get_cap (s, x) - cfsva)\n                         \\<in> Id\n 4. \\<And>x xi sa si b ba.\n       \\<lbrakk>(xi, x) \\<in> nat_rel; (si, sa) \\<in> Id; (b, ba) \\<in> Id;\n        inres\n         (let csv = get_cap (s, xi)\n          in cf_get cf (s, xi) \\<bind> (\\<lambda>cfsv. return (csv - cfsv)))\n         b;\n        inres\n         (let csv = get_cap (s, x)\n          in cf_get cf (s, x) \\<bind> (\\<lambda>cfsv. return (csv - cfsv)))\n         ba;\n        nofail\n         (let csv = get_cap (s, xi)\n          in cf_get cf (s, xi) \\<bind>\n             (\\<lambda>cfsv. return (csv - cfsv)));\n        nofail\n         (let csv = get_cap (s, x)\n          in cf_get cf (s, x) \\<bind>\n             (\\<lambda>cfsv. return (csv - cfsv)))\\<rbrakk>\n       \\<Longrightarrow> (si + b, sa + ba) \\<in> Id\n 5. (0::'a, 0::'a) \\<in> Id", "apply vc_solve"], ["proof (prove)\ngoal (1 subgoal):\n 1. (get_am am s, set (get_am am s))\n    \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "using assms"], ["proof (prove)\nusing this:\n  is_adj_map am\n\ngoal (1 subgoal):\n 1. (get_am am s, set (get_am am s))\n    \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "by (auto \n          simp: list_set_rel_def br_def get_am_def is_adj_map_def \n          simp: refine_pw_simps)"], ["proof (state)\nthis:\n  compute_flow_val2 am cf \\<le> (spec v. v = f.val)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context Edka_Impl begin"], ["", "term is_am"], ["", "lemma [sepref_import_param]: \"(c,PR_CONST get_cap) \\<in> Id\\<times>\\<^sub>rId \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, PR_CONST get_cap)\n    \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> int_rel", "by (auto simp: get_cap_def)"], ["", "lemma [def_pat_rules]: \n    \"Network.get_cap$c \\<equiv> UNPROTECT get_cap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.get_cap $ c \\<equiv> UNPROTECT get_cap", "by simp"], ["", "sepref_register \n    \"PR_CONST get_cap\" :: \"node\\<times>node \\<Rightarrow> capacity_impl\""], ["", "lemma [sepref_import_param]: \"(get_am,get_am) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (get_am, get_am)\n    \\<in> Id \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_rel", "by (auto simp: get_am_def intro!: ext)"], ["", "schematic_goal compute_flow_val_imp:\n    fixes am :: \"node \\<Rightarrow> node list\" and cf :: \"capacity_impl graph\"\n    notes [id_rules] = \n      itypeI[Pure.of am \"TYPE(node \\<Rightarrow> node list)\"]\n      itypeI[Pure.of cf \"TYPE(capacity_impl i_mtx)\"]\n    notes [sepref_import_param] = IdI[of N] IdI[of am]\n    shows \"hn_refine \n      (hn_ctxt (asmtx_assn N id_assn) cf cfi)\n      (?c::?'d Heap) ?\\<Gamma> ?R (compute_flow_val2 am cf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (asmtx_assn N int_assn) cf cfi) ?c ?\\<Gamma> ?R\n     (compute_flow_val2 am cf)", "unfolding compute_flow_val2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (asmtx_assn N int_assn) cf cfi) ?c ?\\<Gamma> ?R\n     (let succs = get_am am s\n      in nfoldli succs (\\<lambda>_. True)\n          (\\<lambda>x a.\n              (let csv = get_cap (s, x)\n               in cf_get cf (s, x) \\<bind>\n                  (\\<lambda>cfsv. return (csv - cfsv))) \\<bind>\n              (\\<lambda>b. return (a + b)))\n          0)", "using [[id_debug, goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (asmtx_assn N int_assn) cf cfi) ?c ?\\<Gamma> ?R\n     (let succs = get_am am s\n      in nfoldli succs (\\<lambda>_. True)\n          (\\<lambda>x a.\n              (let csv = get_cap (s, x)\n               in cf_get cf (s, x) \\<bind>\n                  (\\<lambda>cfsv. return (csv - cfsv))) \\<bind>\n              (\\<lambda>b. return (a + b)))\n          0)", "by sepref"], ["", "concrete_definition (in -) compute_flow_val_imp for c s N am cfi\n    uses Edka_Impl.compute_flow_val_imp"], ["", "prepare_code_thms (in -) compute_flow_val_imp_def"], ["", "end"], ["", "context Network_Impl begin"], ["", "lemma compute_flow_val_imp_correct_aux: \n  assumes VN: \"Graph.V c \\<subseteq> {0..<N}\"\n  assumes ABS_PS: \"is_adj_map am\"\n  assumes RG: \"RGraph c s t cf\"\n  shows \"\n    <asmtx_assn N id_assn cf cfi> \n      compute_flow_val_imp c s N am cfi\n    <\\<lambda>v. asmtx_assn N id_assn cf cfi * \\<up>(v = Flow.val c s (flow_of_cf cf))>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <asmtx_assn N int_assn cf\n      cfi> compute_flow_val_imp c s N am\n            cfi <\\<lambda>r.\n                    asmtx_assn N int_assn cf cfi *\n                    \\<up> (r = Flow.val c s (flow_of_cf cf))>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <asmtx_assn N int_assn cf\n      cfi> compute_flow_val_imp c s N am\n            cfi <\\<lambda>r.\n                    asmtx_assn N int_assn cf cfi *\n                    \\<up> (r = Flow.val c s (flow_of_cf cf))>\\<^sub>t", "interpret rg: RGraph c s t cf"], ["proof (prove)\ngoal (1 subgoal):\n 1. RGraph c s t cf", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. <asmtx_assn N int_assn cf\n      cfi> compute_flow_val_imp c s N am\n            cfi <\\<lambda>r.\n                    asmtx_assn N int_assn cf cfi *\n                    \\<up> (r = Flow.val c s (flow_of_cf cf))>\\<^sub>t", "have EI: \"Edka_Impl c s t N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Edka_Impl c s t N", "by unfold_locales fact"], ["proof (state)\nthis:\n  Edka_Impl c s t N\n\ngoal (1 subgoal):\n 1. <asmtx_assn N int_assn cf\n      cfi> compute_flow_val_imp c s N am\n            cfi <\\<lambda>r.\n                    asmtx_assn N int_assn cf cfi *\n                    \\<up> (r = Flow.val c s (flow_of_cf cf))>\\<^sub>t", "from hn_refine_ref[OF \n      rg.compute_flow_val2_correct[OF ABS_PS] \n      compute_flow_val_imp.refine[OF EI], of cfi]"], ["proof (chain)\npicking this:\n  hn_refine (hn_ctxt (asmtx_assn N int_assn) cf cfi)\n   (compute_flow_val_imp c s N am cfi)\n   (hn_ctxt (asmtx_assn N int_assn) cf cfi) int_assn (spec v. v = rg.f.val)", "show ?thesis"], ["proof (prove)\nusing this:\n  hn_refine (hn_ctxt (asmtx_assn N int_assn) cf cfi)\n   (compute_flow_val_imp c s N am cfi)\n   (hn_ctxt (asmtx_assn N int_assn) cf cfi) int_assn (spec v. v = rg.f.val)\n\ngoal (1 subgoal):\n 1. <asmtx_assn N int_assn cf\n      cfi> compute_flow_val_imp c s N am\n            cfi <\\<lambda>r.\n                    asmtx_assn N int_assn cf cfi *\n                    \\<up> (r = Flow.val c s (flow_of_cf cf))>\\<^sub>t", "apply (simp add: hn_ctxt_def pure_def hn_refine_def rg.f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) cf cfi>\n    compute_flow_val_imp c s N am cfi\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Ax.\n           asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) cf cfi * true *\n           \\<up>\n            (r = x \\<and>\n             x = Flow.val c s (flow_of_cf cf))> \\<Longrightarrow>\n    <asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) cf cfi>\n    compute_flow_val_imp c s N am cfi\n    <\\<lambda>r.\n        asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) cf cfi * true *\n        \\<up> (r = Flow.val c s (flow_of_cf cf))>", "apply (erule cons_post_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>\\<^sub>Axa.\n          asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) cf cfi * true *\n          \\<up>\n           (x = xa \\<and>\n            xa = Flow.val c s (flow_of_cf cf)) \\<Longrightarrow>\\<^sub>A\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) cf cfi * true *\n       \\<up> (x = Flow.val c s (flow_of_cf cf))", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <asmtx_assn N int_assn cf\n    cfi> compute_flow_val_imp c s N am\n          cfi <\\<lambda>r.\n                  asmtx_assn N int_assn cf cfi *\n                  \\<up> (r = Flow.val c s (flow_of_cf cf))>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compute_flow_val_imp_correct: \n  assumes VN: \"Graph.V c \\<subseteq> {0..<N}\"\n  assumes ABS_PS: \"Graph.is_adj_map c am\"\n  shows \"\n    <is_rflow N f cfi> \n      compute_flow_val_imp c s N am cfi\n    <\\<lambda>v. is_rflow N f cfi * \\<up>(v = Flow.val c s f)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_rflow N f\n      cfi> compute_flow_val_imp c s N am\n            cfi <\\<lambda>r.\n                    is_rflow N f cfi * \\<up> (r = Flow.val c s f)>\\<^sub>t", "apply (rule hoare_triple_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> is_rflow N f cfi \\<Longrightarrow>\n       <is_rflow N f\n         cfi> compute_flow_val_imp c s N am\n               cfi <\\<lambda>r.\n                       is_rflow N f cfi *\n                       \\<up> (r = Flow.val c s f)>\\<^sub>t", "apply (clarsimp simp: is_rflow_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b cf.\n       \\<lbrakk>(a, b) \\<Turnstile> asmtx_assn N int_assn cf cfi;\n        RGraph c s t cf; f = flow_of_cf cf\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Acfa.\n                             asmtx_assn N int_assn cfa cfi *\n                             \\<up>\n                              (RGraph c s t cfa \\<and>\n                               flow_of_cf cf = flow_of_cf cfa)>\n                         compute_flow_val_imp c s N am cfi\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Acfa.\n                                asmtx_assn N int_assn cfa cfi * true *\n                                \\<up>\n                                 (RGraph c s t cfa \\<and>\n                                  flow_of_cf cf = flow_of_cf cfa \\<and>\n                                  r = Flow.val c s (flow_of_cf cf))>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b cf cfa.\n       \\<lbrakk>(a, b) \\<Turnstile> asmtx_assn N int_assn cf cfi;\n        RGraph c s t cf; f = flow_of_cf cfa;\n        RGraph c s t cfa \\<and> flow_of_cf cf = flow_of_cf cfa\\<rbrakk>\n       \\<Longrightarrow> <asmtx_assn N int_assn cfa cfi>\n                         compute_flow_val_imp c s N am cfi\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Acf.\n                                asmtx_assn N int_assn cf cfi * true *\n                                \\<up>\n                                 (RGraph c s t cf \\<and>\n                                  flow_of_cf cfa = flow_of_cf cf \\<and>\n                                  r = Flow.val c s (flow_of_cf cfa))>", "apply (rule cons_rule[OF _ _ compute_flow_val_imp_correct_aux[where cfi=cfi]])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b cf cfa.\n       \\<lbrakk>(a, b) \\<Turnstile> asmtx_assn N int_assn cf cfi;\n        RGraph c s t cf; f = flow_of_cf cfa;\n        RGraph c s t cfa \\<and> flow_of_cf cf = flow_of_cf cfa\\<rbrakk>\n       \\<Longrightarrow> asmtx_assn N int_assn cfa\n                          cfi \\<Longrightarrow>\\<^sub>A\n                         asmtx_assn N int_assn (?cf10 a b cf cfa) cfi\n 2. \\<And>a b cf cfa x.\n       \\<lbrakk>(a, b) \\<Turnstile> asmtx_assn N int_assn cf cfi;\n        RGraph c s t cf; f = flow_of_cf cfa;\n        RGraph c s t cfa \\<and> flow_of_cf cf = flow_of_cf cfa\\<rbrakk>\n       \\<Longrightarrow> asmtx_assn N int_assn (?cf10 a b cf cfa) cfi *\n                         \\<up>\n                          (x =\n                           Flow.val c s (flow_of_cf (?cf10 a b cf cfa))) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Acf.\n                            asmtx_assn N int_assn cf cfi * true *\n                            \\<up>\n                             (RGraph c s t cf \\<and>\n                              flow_of_cf cfa = flow_of_cf cf \\<and>\n                              x = Flow.val c s (flow_of_cf cfa))\n 3. \\<And>a b cf cfa.\n       \\<lbrakk>(a, b) \\<Turnstile> asmtx_assn N int_assn cf cfi;\n        RGraph c s t cf; f = flow_of_cf cfa;\n        RGraph c s t cfa \\<and> flow_of_cf cf = flow_of_cf cfa\\<rbrakk>\n       \\<Longrightarrow> V \\<subseteq> {0..<N}\n 4. \\<And>a b cf cfa.\n       \\<lbrakk>(a, b) \\<Turnstile> asmtx_assn N int_assn cf cfi;\n        RGraph c s t cf; f = flow_of_cf cfa;\n        RGraph c s t cfa \\<and> flow_of_cf cf = flow_of_cf cfa\\<rbrakk>\n       \\<Longrightarrow> is_adj_map am\n 5. \\<And>a b cf cfa.\n       \\<lbrakk>(a, b) \\<Turnstile> asmtx_assn N int_assn cf cfi;\n        RGraph c s t cf; f = flow_of_cf cfa;\n        RGraph c s t cfa \\<and> flow_of_cf cf = flow_of_cf cfa\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t (?cf10 a b cf cfa)", "apply (sep_auto simp: VN ABS_PS)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition \"edmonds_karp_val el s t \\<equiv> do {\n  r \\<leftarrow> edmonds_karp el s t;\n  case r of\n    None \\<Rightarrow> return None\n  | Some (c,am,N,cfi) \\<Rightarrow> do {\n      v \\<leftarrow> compute_flow_val_imp c s N am cfi;\n      return (Some v)\n    } \n}\""], ["", "theorem edmonds_karp_val_correct:\n  \"<emp> edmonds_karp_val el s t <\\<lambda>\n    None \\<Rightarrow> \\<up>(\\<not>ln_invar el \\<or> \\<not>Network (ln_\\<alpha> el) s t)\n  | Some v \\<Rightarrow> \\<up>(\\<exists>f N. \n          ln_invar el \\<and> Network (ln_\\<alpha> el) s t \n        \\<and> Graph.V (ln_\\<alpha> el) \\<subseteq> {0..<N}\n        \\<and> Network.isMaxFlow (ln_\\<alpha> el) s t f\n        \\<and> v = Flow.val (ln_\\<alpha> el) s f)  \n        >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> edmonds_karp_val el s\n           t <\\<lambda>r.\n                 case r of\n                 None \\<Rightarrow>\n                   \\<up>\n                    (\\<not> ln_invar el \\<or>\n                     \\<not> Network (ln_\\<alpha> el) s t)\n                 | Some v \\<Rightarrow>\n                     \\<up>\n                      (\\<exists>f N.\n                          ln_invar el \\<and>\n                          Network (ln_\\<alpha> el) s t \\<and>\n                          Graph.V (ln_\\<alpha> el)\n                          \\<subseteq> {0..<N} \\<and>\n                          Network.isMaxFlow (ln_\\<alpha> el) s t f \\<and>\n                          v = Flow.val (ln_\\<alpha> el) s f)>\\<^sub>t", "unfolding edmonds_karp_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> edmonds_karp el s t \\<bind>\n          (\\<lambda>r.\n              case r of None \\<Rightarrow> return None\n              | Some (c, am, N, cfi) \\<Rightarrow>\n                  compute_flow_val_imp c s N am cfi \\<bind>\n                  (\\<lambda>v.\n                      return\n                       (Some\n                         v))) <\\<lambda>r.\n                                  case r of\n                                  None \\<Rightarrow>\n                                    \\<up>\n                                     (\\<not> ln_invar el \\<or>\n\\<not> Network (ln_\\<alpha> el) s t)\n                                  | Some v \\<Rightarrow>\n\\<up>\n (\\<exists>f N.\n     ln_invar el \\<and>\n     Network (ln_\\<alpha> el) s t \\<and>\n     Graph.V (ln_\\<alpha> el) \\<subseteq> {0..<N} \\<and>\n     Network.isMaxFlow (ln_\\<alpha> el) s t f \\<and>\n     v = Flow.val (ln_\\<alpha> el) s f)>\\<^sub>t", "by (sep_auto \n    intro: network_is_impl\n    heap: edmonds_karp_correct Network_Impl.compute_flow_val_imp_correct)"], ["", "end"]]}