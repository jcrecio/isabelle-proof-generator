{"file_name": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow/EdmondsKarp_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow", "problem_names": ["lemma cfi_rel_alt: \"cfi_rel = {(cf,f). cf = residualGraph c f \\<and> NFlow c s t f}\"", "lemma residualGraph_zero_flow: \"residualGraph c (\\<lambda>_. 0) = c\"", "lemma flow_of_c: \"flow_of_cf c = (\\<lambda>_. 0)\"", "lemma (in NFlow) resCap_cf_refine: \"resCap_cf cf p = resCap p\"", "lemma (in NFlow) augment_cf_refine_aux: (* For snippet *)\n      assumes AUG: \"isAugmentingPath p\"\n      shows \"residualGraph c (augment (augmentingFlow p)) (u,v) = (\n        if (u,v)\\<in>set p then (residualGraph c f (u,v) - resCap p)\n        else if (v,u)\\<in>set p then (residualGraph c f (u,v) + resCap p)\n        else residualGraph c f (u,v))\"", "lemma augment_cf_refine:\n      assumes R: \"(cf,f)\\<in>cfi_rel\"\n      assumes AUG: \"NPreflow.isAugmentingPath c s t f p\"\n      shows \"(Graph.augment_cf cf (set p) (resCap_cf cf p), \n          NFlow.augment_with_path c f p) \\<in> cfi_rel\"", "lemma (in RGraph) find_shortest_augmenting_spec_cf_refine: \n       \"find_shortest_augmenting_spec_cf cf \n      \\<le> find_shortest_augmenting_spec (flow_of_cf cf)\"", "lemma edka2_refine: \"edka2 \\<le> \\<Down>Id edka\"", "lemma (in RGraph) resCap_cf_impl_refine:   \n      assumes AUG: \"cf.isSimplePath s p t\"\n      shows \"resCap_cf_impl cf p \\<le> SPEC (\\<lambda>r. r = resCap_cf cf p)\"", "lemma (in Graph) augment_cf_inductive:\n      fixes e cap\n      defines \"c' \\<equiv> augment_edge e cap\"\n      assumes P: \"isSimplePath s (e#p) t\"\n      shows \"augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap\"\n      and \"\\<exists>s'. Graph.isSimplePath c' s' p t\"", "lemma augment_edge_impl_refine: \n      assumes \"valid_edge e\" \"\\<forall>u. e\\<noteq>(u,u)\"\n      shows \"augment_edge_impl cf e cap \n          \\<le> (spec r. r = Graph.augment_edge cf e cap)\"", "lemma augment_cf_impl_simps[simp]: \n      \"augment_cf_impl cf [] x = return cf\"\n      \"augment_cf_impl cf (e#p) x = do { \n        cf \\<leftarrow> augment_edge_impl cf e x; \n        augment_cf_impl cf p x}\"", "lemma augment_cf_impl_aux:    \n      assumes \"\\<forall>e\\<in>set p. valid_edge e\"\n      assumes \"\\<exists>s. Graph.isSimplePath cf s p t\"\n      shows \"augment_cf_impl cf p x \\<le> RETURN (Graph.augment_cf cf (set p) x)\"", "lemma (in RGraph) augment_cf_impl_refine:     \n      assumes \"Graph.isSimplePath cf s p t\"\n      shows \"augment_cf_impl cf p x \\<le> RETURN (Graph.augment_cf cf (set p) x)\"", "lemma edka3_refine: \"edka3 \\<le> \\<Down>Id edka2\"", "lemma bfs_refines_shortest_augmenting_spec: \n      \"Graph.bfs cf s t \\<le> find_shortest_augmenting_spec_cf cf\"", "lemma edka4_refine: \"edka4 \\<le> \\<Down>Id edka3\"", "lemma (in RGraph) rg_succ_ref1: \"\\<lbrakk>is_adj_map am\\<rbrakk> \n      \\<Longrightarrow> (rg_succ am cf u, Graph.E cf``{u}) \\<in> \\<langle>Id\\<rangle>list_set_rel\"", "lemma monadic_filter_rev_aux_rule:\n      assumes \"\\<And>x. x\\<in>set l \\<Longrightarrow> P x \\<le> SPEC (\\<lambda>r. r=Q x)\"\n      shows \"monadic_filter_rev_aux a P l \\<le> SPEC (\\<lambda>r. r=filter_rev_aux a Q l)\"", "lemma monadic_filter_rev_rule:\n      assumes \"\\<And>x. x\\<in>set l \\<Longrightarrow> P x \\<le> (spec r. r=Q x)\"\n      shows \"monadic_filter_rev P l \\<le> (spec r. r=filter_rev Q l)\"", "lemma (in RGraph) rg_succ_ref2: \n      assumes PS: \"is_adj_map am\" and V: \"u\\<in>V\"\n      shows \"rg_succ2 am cf u \\<le> return (rg_succ am cf u)\"", "lemma (in RGraph) rg_succ_ref:\n      assumes A: \"is_adj_map am\"\n      assumes B: \"u\\<in>V\"\n      shows \"rg_succ2 am cf u \\<le> SPEC (\\<lambda>l. (l,cf.E``{u}) \\<in> \\<langle>Id\\<rangle>list_set_rel)\"", "lemma edka5_refine: \"\\<lbrakk>is_adj_map am\\<rbrakk> \\<Longrightarrow> edka5 am \\<le> \\<Down>Id edka4\"", "lemma this_loc: \"Edka_Impl c s t N\"", "lemma E_ss: \"E \\<subseteq> {0..<N}\\<times>{0..<N}\"", "lemma mtx_nonzero_iff[simp]: \"mtx_nonzero c = E\"", "lemma mtx_nonzeroN: \"mtx_nonzero c \\<subseteq> {0..<N}\\<times>{0..<N}\"", "lemma [simp]: \"v\\<in>V \\<Longrightarrow> v<N\"", "lemmas [id_rules] = \n      itypeI[Pure.of N \"TYPE(nat)\"]  \n      itypeI[Pure.of s \"TYPE(node)\"]  \n      itypeI[Pure.of t \"TYPE(node)\"]  \n      itypeI[Pure.of c \"TYPE(capacity_impl graph)\"]", "lemmas [sepref_import_param] = \n      IdI[of N]\n      IdI[of s]\n      IdI[of t]", "lemma [sepref_fr_rules]: \"(uncurry0 (return c),uncurry0 (return c))\\<in>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure (nat_rel\\<times>\\<^sub>rnat_rel \\<rightarrow> int_rel)\"", "lemma is_am_precise[safe_constraint_rules]: \"precise (is_am)\"", "lemma [def_pat_rules]: \"Network.ps_get_op$c \\<equiv> UNPROTECT ps_get_op\"", "lemma ps_get_op_refine[sepref_fr_rules]: \n      \"(uncurry ps_get_imp, uncurry (PR_CONST ps_get_op)) \n        \\<in> is_am\\<^sup>k *\\<^sub>a (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn (pure Id)\"", "lemma is_pred_succ_no_node: \"\\<lbrakk>is_adj_map a; u\\<notin>V\\<rbrakk> \\<Longrightarrow> a u = []\"", "lemma [sepref_fr_rules]: \"(Array.make N, PR_CONST init_ps) \n      \\<in> (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a is_am\"", "lemma [def_pat_rules]: \"Network.init_ps$c \\<equiv> UNPROTECT init_ps\"", "lemma [def_pat_rules]: \"Network.cf_get$c \\<equiv> UNPROTECT cf_get\"", "lemma [def_pat_rules]: \"Network.cf_set$c \\<equiv> UNPROTECT cf_set\"", "lemmas [sepref_fr_rules] = cf_get_impl.refine", "lemmas [sepref_opt_simps] = cf_get_impl_def", "lemmas [sepref_fr_rules] = cf_set_impl.refine", "lemmas [sepref_opt_simps] = cf_set_impl_def", "lemmas [sepref_fr_rules] = init_cf_impl.refine[OF this_loc]", "lemma amtx_cnv: \"amtx_assn N M id_assn = IICF_Array_Matrix.is_amtx N M\"", "lemma [def_pat_rules]: \"Network.init_cf$c \\<equiv> UNPROTECT init_cf\"", "lemma is_rflow_precise[safe_constraint_rules]: \"precise (is_rflow N)\"", "lemma [sepref_fr_rules]: \n      \"(\\<lambda>cfi. return cfi, PR_CONST compute_rflow) \\<in> (asmtx_assn N id_assn)\\<^sup>d \\<rightarrow>\\<^sub>a is_rflow N\"", "lemma [def_pat_rules]: \n      \"Network.compute_rflow$c$s$t \\<equiv> UNPROTECT compute_rflow\"", "lemma succ_imp_refine[sepref_fr_rules]: \n      \"(uncurry2 (succ_imp N), uncurry2 (PR_CONST rg_succ2)) \n        \\<in> is_am\\<^sup>k *\\<^sub>a (asmtx_assn N id_assn)\\<^sup>k *\\<^sub>a (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn (pure Id)\"", "lemma [def_pat_rules]: \"Network.rg_succ2$c \\<equiv> UNPROTECT rg_succ2\"", "lemma [sepref_import_param]: \"(min,min)\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\"", "lemma resCap_impl_refine[sepref_fr_rules]: \n      \"(uncurry (resCap_imp N), uncurry (PR_CONST resCap_cf_impl)) \n        \\<in> (asmtx_assn N id_assn)\\<^sup>k *\\<^sub>a (is_path)\\<^sup>k \\<rightarrow>\\<^sub>a (pure Id)\"", "lemma [def_pat_rules]: \n      \"Network.resCap_cf_impl$c \\<equiv> UNPROTECT resCap_cf_impl\"", "lemma augment_impl_refine[sepref_fr_rules]: \n      \"(uncurry2 (augment_imp N), uncurry2 (PR_CONST augment_cf_impl)) \n        \\<in> (asmtx_assn N id_assn)\\<^sup>d *\\<^sub>a (is_path)\\<^sup>k *\\<^sub>a (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N id_assn\"", "lemma [def_pat_rules]: \n      \"Network.augment_cf_impl$c \\<equiv> UNPROTECT augment_cf_impl\"", "lemma [sepref_fr_rules]: \n      \"(uncurry (bfsi' N s t),uncurry (PR_CONST bfs2_op)) \n        \\<in> is_am\\<^sup>k *\\<^sub>a (asmtx_assn N id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn is_path\"", "lemma [def_pat_rules]: \"Network.bfs2_op$c$s$t \\<equiv> UNPROTECT bfs2_op\"", "lemma edka_imp_tabulate_refine[sepref_fr_rules]: \n      \"(edka_imp_tabulate c N, PR_CONST edka5_tabulate) \n      \\<in> (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn (asmtx_assn N id_assn) is_am\"", "lemma [def_pat_rules]: \n      \"Network.edka5_tabulate$c \\<equiv> UNPROTECT edka5_tabulate\"", "lemma edka_imp_run_refine[sepref_fr_rules]: \n      \"(uncurry (edka_imp_run s t N), uncurry (PR_CONST edka5_run)) \n        \\<in> (asmtx_assn N id_assn)\\<^sup>d *\\<^sub>a (is_am)\\<^sup>k \\<rightarrow>\\<^sub>a is_rflow N\"", "lemma [def_pat_rules]: \n      \"Network.edka5_run$c$s$t \\<equiv> UNPROTECT edka5_run\"", "lemmas edka_imp_refine = edka_imp.refine[OF this_loc]", "theorem edka_imp_correct: \n      assumes VN: \"Graph.V c \\<subseteq> {0..<N}\"\n      assumes ABS_PS: \"is_adj_map am\"\n      shows \"\n        <emp> \n          edka_imp c s t N am \n        <\\<lambda>fi. \\<exists>\\<^sub>Af. is_rflow N f fi * \\<up>(isMaxFlow f)>\\<^sub>t\""], "translations": [["", "lemma cfi_rel_alt: \"cfi_rel = {(cf,f). cf = residualGraph c f \\<and> NFlow c s t f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfi_rel = {(cf, f). cf = cf_of f \\<and> NFlow c s t f}", "unfolding cfi_rel_def br_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(ca, a). a = flow_of_cf ca \\<and> RGraph c s t ca} =\n    {(cf, f). cf = cf_of f \\<and> NFlow c s t f}", "by (auto \n          simp: NFlow.is_RGraph RGraph.is_NFlow \n          simp: RPreGraph.rg_fo_inv[OF RGraph.this_loc_rpg]\n          simp: NPreflow.fo_rg_inv[OF NFlow.axioms(1)])"], ["", "text \\<open>Initially, the residual graph for the zero flow equals the original network\\<close>"], ["", "lemma residualGraph_zero_flow: \"residualGraph c (\\<lambda>_. 0) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_of (\\<lambda>_. 0::'capacity) = c", "unfolding residualGraph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(u, v).\n        if (u, v) \\<in> E then c (u, v) - (0::'capacity)\n        else if (v, u) \\<in> E then 0::'capacity else (0::'capacity)) =\n    c", "by (auto intro!: ext)"], ["", "lemma flow_of_c: \"flow_of_cf c = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_of_cf c = (\\<lambda>_. 0::'capacity)", "by (auto simp add: flow_of_cf_def[abs_def])"], ["", "text \\<open>The residual capacity is naturally defined on residual graphs\\<close>"], ["", "definition \"resCap_cf cf p \\<equiv> Min {cf e | e. e\\<in>set p}\""], ["", "lemma (in NFlow) resCap_cf_refine: \"resCap_cf cf p = resCap p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resCap_cf cf p = resCap p", "unfolding resCap_cf_def resCap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {cf e |e. e \\<in> set p} = Min {cf e |e. e \\<in> set p}", ".."], ["", "text \\<open>Augmentation can be done by @{const Graph.augment_cf}.\\<close>"], ["", "lemma (in NFlow) augment_cf_refine_aux: (* For snippet *)\n      assumes AUG: \"isAugmentingPath p\"\n      shows \"residualGraph c (augment (augmentingFlow p)) (u,v) = (\n        if (u,v)\\<in>set p then (residualGraph c f (u,v) - resCap p)\n        else if (v,u)\\<in>set p then (residualGraph c f (u,v) + resCap p)\n        else residualGraph c f (u,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_of (augment (augmentingFlow p)) (u, v) =\n    (if (u, v) \\<in> set p then cf (u, v) - resCap p\n     else if (v, u) \\<in> set p then cf (u, v) + resCap p else cf (u, v))", "using augment_alt[OF AUG]"], ["proof (prove)\nusing this:\n  cf_of (augment (augmentingFlow p)) = cf.augment_cf (set p) (resCap p)\n\ngoal (1 subgoal):\n 1. cf_of (augment (augmentingFlow p)) (u, v) =\n    (if (u, v) \\<in> set p then cf (u, v) - resCap p\n     else if (v, u) \\<in> set p then cf (u, v) + resCap p else cf (u, v))", "by (auto simp: Graph.augment_cf_def)"], ["", "lemma augment_cf_refine:\n      assumes R: \"(cf,f)\\<in>cfi_rel\"\n      assumes AUG: \"NPreflow.isAugmentingPath c s t f p\"\n      shows \"(Graph.augment_cf cf (set p) (resCap_cf cf p), \n          NFlow.augment_with_path c f p) \\<in> cfi_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Graph.augment_cf cf (set p) (resCap_cf cf p),\n     NFlow.augment_with_path c f p)\n    \\<in> cfi_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Graph.augment_cf cf (set p) (resCap_cf cf p),\n     NFlow.augment_with_path c f p)\n    \\<in> cfi_rel", "from R"], ["proof (chain)\npicking this:\n  (cf, f) \\<in> cfi_rel", "have [simp]: \"cf = residualGraph c f\" and \"NFlow c s t f\""], ["proof (prove)\nusing this:\n  (cf, f) \\<in> cfi_rel\n\ngoal (1 subgoal):\n 1. cf = cf_of f &&& NFlow c s t f", "by (auto simp: cfi_rel_alt br_def)"], ["proof (state)\nthis:\n  cf = cf_of f\n  NFlow c s t f\n\ngoal (1 subgoal):\n 1. (Graph.augment_cf cf (set p) (resCap_cf cf p),\n     NFlow.augment_with_path c f p)\n    \\<in> cfi_rel", "then"], ["proof (chain)\npicking this:\n  cf = cf_of f\n  NFlow c s t f", "interpret f: NFlow c s t f"], ["proof (prove)\nusing this:\n  cf = cf_of f\n  NFlow c s t f\n\ngoal (1 subgoal):\n 1. NFlow c s t f", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. (Graph.augment_cf cf (set p) (resCap_cf cf p), f.augment_with_path p)\n    \\<in> cfi_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Graph.augment_cf cf (set p) (resCap_cf cf p), f.augment_with_path p)\n    \\<in> cfi_rel", "unfolding f.augment_with_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Graph.augment_cf cf (set p) (resCap_cf cf p),\n     f.augment (f.augmentingFlow p))\n    \\<in> cfi_rel", "proof (simp add: cfi_rel_alt; safe intro!: ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       f.cf.augment_cf (set p) (resCap_cf f.cf p) (a, b) =\n       cf_of (f.augment (f.augmentingFlow p)) (a, b)\n 2. NFlow c s t (f.augment (f.augmentingFlow p))", "fix u v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       f.cf.augment_cf (set p) (resCap_cf f.cf p) (a, b) =\n       cf_of (f.augment (f.augmentingFlow p)) (a, b)\n 2. NFlow c s t (f.augment (f.augmentingFlow p))", "show \"Graph.augment_cf f.cf (set p) (resCap_cf f.cf p) (u,v) \n              = residualGraph c (f.augment (f.augmentingFlow p)) (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f.cf.augment_cf (set p) (resCap_cf f.cf p) (u, v) =\n    cf_of (f.augment (f.augmentingFlow p)) (u, v)", "unfolding f.augment_cf_refine_aux[OF AUG]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f.cf.augment_cf (set p) (resCap_cf f.cf p) (u, v) =\n    (if (u, v) \\<in> set p then f.cf (u, v) - f.resCap p\n     else if (v, u) \\<in> set p then f.cf (u, v) + f.resCap p\n          else f.cf (u, v))", "unfolding f.cf.augment_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (u, v) \\<in> set p then f.cf (u, v) - resCap_cf f.cf p\n     else if prod.swap (u, v) \\<in> set p\n          then f.cf (u, v) + resCap_cf f.cf p else f.cf (u, v)) =\n    (if (u, v) \\<in> set p then f.cf (u, v) - f.resCap p\n     else if (v, u) \\<in> set p then f.cf (u, v) + f.resCap p\n          else f.cf (u, v))", "by (auto simp: f.resCap_cf_refine)"], ["proof (state)\nthis:\n  f.cf.augment_cf (set p) (resCap_cf f.cf p) (u, v) =\n  cf_of (f.augment (f.augmentingFlow p)) (u, v)\n\ngoal (1 subgoal):\n 1. NFlow c s t (f.augment (f.augmentingFlow p))", "qed (rule f.augment_pres_nflow[OF AUG])"], ["proof (state)\nthis:\n  (Graph.augment_cf cf (set p) (resCap_cf cf p), f.augment_with_path p)\n  \\<in> cfi_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We rephrase the specification of shortest augmenting path to\n      take a residual graph as parameter\\<close>"], ["", "(* TODO: This actually rephrases the spec to make it look more similar to \n      what BFS does later. This rephrasing does not belong here, but where we \n      implement it with BFS. *)"], ["", "definition \"find_shortest_augmenting_spec_cf cf \\<equiv> \n      assert (RGraph c s t cf) \\<then>\n      SPEC (\\<lambda>\n        None \\<Rightarrow> \\<not>Graph.connected cf s t \n      | Some p \\<Rightarrow> Graph.isShortestPath cf s p t)\""], ["", "lemma (in RGraph) find_shortest_augmenting_spec_cf_refine: \n       \"find_shortest_augmenting_spec_cf cf \n      \\<le> find_shortest_augmenting_spec (flow_of_cf cf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_shortest_augmenting_spec_cf cf\n    \\<le> find_shortest_augmenting_spec (flow_of_cf cf)", "unfolding f_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_shortest_augmenting_spec_cf cf\n    \\<le> find_shortest_augmenting_spec f", "unfolding find_shortest_augmenting_spec_cf_def \n        and find_shortest_augmenting_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (RGraph c s t cf) \\<bind>\n    (\\<lambda>_.\n        spec x.\n           case x of None \\<Rightarrow> \\<not> cf.connected s t\n           | Some p \\<Rightarrow> cf.isShortestPath s p t)\n    \\<le> assert (NFlow c s t f) \\<bind>\n          (\\<lambda>_. select p. f.cf.isShortestPath s p t)", "by (auto \n        simp: pw_le_iff refine_pw_simps \n        simp: this_loc rg_is_cf\n        simp: f.isAugmentingPath_def Graph.connected_def Graph.isSimplePath_def \n        dest: cf.shortestPath_is_path\n        split: option.split)"], ["", "text \\<open>This leads to the following refined algorithm\\<close>"], ["", "definition \"edka2 \\<equiv> do {\n      let cf = c;\n\n      (cf,_) \\<leftarrow> while\\<^sub>T \n        (\\<lambda>(cf,brk). \\<not>brk) \n        (\\<lambda>(cf,_). do {\n          assert (RGraph c s t cf);\n          p \\<leftarrow> find_shortest_augmenting_spec_cf cf;\n          case p of \n            None \\<Rightarrow> return (cf,True)\n          | Some p \\<Rightarrow> do {\n              assert (p\\<noteq>[]);\n              assert (Graph.isShortestPath cf s p t);\n              let cf = Graph.augment_cf cf (set p) (resCap_cf cf p);\n              assert (RGraph c s t cf);\n              return (cf, False)\n            }  \n        })\n        (cf,False);\n      assert (RGraph c s t cf);\n      let f = flow_of_cf cf;  \n      return f\n    }\""], ["", "lemma edka2_refine: \"edka2 \\<le> \\<Down>Id edka\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edka2 \\<le> \\<Down> Id edka", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. edka2 \\<le> \\<Down> Id edka", "have [refine_dref_RELATES]: \"RELATES cfi_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES cfi_rel", "by (simp add: RELATES_def)"], ["proof (state)\nthis:\n  RELATES cfi_rel\n\ngoal (1 subgoal):\n 1. edka2 \\<le> \\<Down> Id edka", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. edka2 \\<le> \\<Down> Id edka", "unfolding edka2_def edka_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let cf = c\n     in while\\<^sub>T (\\<lambda>(cf, brk). \\<not> brk)\n         (\\<lambda>(cf, uu_).\n             assert (RGraph c s t cf) \\<bind>\n             (\\<lambda>_.\n                 find_shortest_augmenting_spec_cf cf \\<bind>\n                 (\\<lambda>p.\n                     case p of None \\<Rightarrow> return (cf, True)\n                     | Some p \\<Rightarrow>\n                         assert (p \\<noteq> []) \\<bind>\n                         (\\<lambda>_.\n                             assert (Graph.isShortestPath cf s p t) \\<bind>\n                             (\\<lambda>_.\n                                 let cf =\n Graph.augment_cf cf (set p) (resCap_cf cf p)\n                                 in assert (RGraph c s t cf) \\<bind>\n                                    (\\<lambda>_. return (cf, False)))))))\n         (cf, False) \\<bind>\n        (\\<lambda>(cf, uu_).\n            assert (RGraph c s t cf) \\<bind>\n            (\\<lambda>_. Let (flow_of_cf cf) return)))\n    \\<le> \\<Down> Id\n           (let f = \\<lambda>_. 0::'capacity\n            in while\\<^sub>T\\<^bsup>fofu_invar\\<^esup>\n                (\\<lambda>(f, brk). \\<not> brk)\n                (\\<lambda>(f, uu_).\n                    find_shortest_augmenting_spec f \\<bind>\n                    (\\<lambda>p.\n                        case p of None \\<Rightarrow> return (f, True)\n                        | Some p \\<Rightarrow>\n                            assert (p \\<noteq> []) \\<bind>\n                            (\\<lambda>_.\n                                assert\n                                 (NPreflow.isAugmentingPath c s t f\n                                   p) \\<bind>\n                                (\\<lambda>_.\n                                    assert\n                                     (Graph.isShortestPath (cf_of f) s p\n t) \\<bind>\n                                    (\\<lambda>_.\n  let f = NFlow.augment_with_path c f p\n  in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False)))))))\n                (f, False) \\<bind>\n               (\\<lambda>(f, uu_).\n                   assert (NFlow c s t f) \\<bind> (\\<lambda>_. return f)))", "(*apply (rewrite in \"let f' = NFlow.augmentingFlow c _ _ in _\" Let_def)\n        apply (rewrite in \"let f = flow_of_cf _ in _\" Let_def)*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let cf = c\n     in while\\<^sub>T (\\<lambda>(cf, brk). \\<not> brk)\n         (\\<lambda>(cf, uu_).\n             assert (RGraph c s t cf) \\<bind>\n             (\\<lambda>_.\n                 find_shortest_augmenting_spec_cf cf \\<bind>\n                 (\\<lambda>p.\n                     case p of None \\<Rightarrow> return (cf, True)\n                     | Some p \\<Rightarrow>\n                         assert (p \\<noteq> []) \\<bind>\n                         (\\<lambda>_.\n                             assert (Graph.isShortestPath cf s p t) \\<bind>\n                             (\\<lambda>_.\n                                 let cf =\n Graph.augment_cf cf (set p) (resCap_cf cf p)\n                                 in assert (RGraph c s t cf) \\<bind>\n                                    (\\<lambda>_. return (cf, False)))))))\n         (cf, False) \\<bind>\n        (\\<lambda>(cf, uu_).\n            assert (RGraph c s t cf) \\<bind>\n            (\\<lambda>_. Let (flow_of_cf cf) return)))\n    \\<le> \\<Down> Id\n           (let f = \\<lambda>_. 0::'capacity\n            in while\\<^sub>T\\<^bsup>fofu_invar\\<^esup>\n                (\\<lambda>(f, brk). \\<not> brk)\n                (\\<lambda>(f, uu_).\n                    find_shortest_augmenting_spec f \\<bind>\n                    (\\<lambda>p.\n                        case p of None \\<Rightarrow> return (f, True)\n                        | Some p \\<Rightarrow>\n                            assert (p \\<noteq> []) \\<bind>\n                            (\\<lambda>_.\n                                assert\n                                 (NPreflow.isAugmentingPath c s t f\n                                   p) \\<bind>\n                                (\\<lambda>_.\n                                    assert\n                                     (Graph.isShortestPath (cf_of f) s p\n t) \\<bind>\n                                    (\\<lambda>_.\n  let f = NFlow.augment_with_path c f p\n  in assert (NFlow c s t f) \\<bind> (\\<lambda>_. return (f, False)))))))\n                (f, False) \\<bind>\n               (\\<lambda>(f, uu_).\n                   assert (NFlow c s t f) \\<bind> (\\<lambda>_. return f)))", "apply (refine_rcg)"], ["proof (prove)\ngoal (12 subgoals):\n 1. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((c, False), \\<lambda>_. 0::'capacity, False) \\<in> ?R'1\n 2. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'1; fofu_invar x'; x = (x1, x2);\n        x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 3. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 4. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec_cf x1a\n                         \\<le> \\<Down> (?R'32 x x' x1 x2 x1a x2a)\n                                (find_shortest_augmenting_spec x1)\n 5. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n        (p, pa) \\<in> ?R'32 x x' x1 x2 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> (p, pa)\n                         \\<in> \\<langle>?Ra33 x x' x1 x2 x1a x2a p\n   pa\\<rangle>option_rel\n 6. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n        (p, pa) \\<in> ?R'32 x x' x1 x2 x1a x2a; p = None; pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True) \\<in> ?R'1\n 7. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n        (p, pa) \\<in> ?R'32 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra33 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n        (p, pa) \\<in> ?R'32 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra33 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s xa t\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n        (p, pa) \\<in> ?R'32 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra33 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> [];\n        Graph.isShortestPath x1a s xa t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a)\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t\n                          (Graph.augment_cf x1a (set xa) (resCap_cf x1a xa))\n 10. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n        \\<lbrakk>(x, x') \\<in> ?R'1;\n         case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n         case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n         x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n         (p, pa) \\<in> ?R'32 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n         (xa, x'a) \\<in> ?Ra33 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n         NPreflow.isAugmentingPath c s t x1 x'a;\n         Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> [];\n         Graph.isShortestPath x1a s xa t;\n         NFlow c s t (NFlow.augment_with_path c x1 x'a);\n         RGraph c s t\n          (Graph.augment_cf x1a (set xa) (resCap_cf x1a xa))\\<rbrakk>\n        \\<Longrightarrow> ((Graph.augment_cf x1a (set xa)\n                             (resCap_cf x1a xa),\n                            False),\n                           NFlow.augment_with_path c x1 x'a, False)\n                          \\<in> ?R'1\nA total of 12 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (11 subgoals):\n 1. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((c, False), \\<lambda>_. 0::'capacity, False)\n    \\<in> cfi_rel \\<times>\\<^sub>r bool_rel\n 2. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> cfi_rel \\<times>\\<^sub>r bool_rel;\n        fofu_invar x'; x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 3. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> cfi_rel \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 4. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> cfi_rel \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec_cf x1a\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n             nat_rel\\<rangle>list_rel\\<rangle>option_rel)\n                                (find_shortest_augmenting_spec x1)\n 5. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> cfi_rel \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = None; pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True)\n                         \\<in> cfi_rel \\<times>\\<^sub>r bool_rel\n 6. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> cfi_rel \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 7. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> cfi_rel \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s xa t\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> cfi_rel \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> [];\n        Graph.isShortestPath x1a s xa t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a)\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t\n                          (Graph.augment_cf x1a (set xa) (resCap_cf x1a xa))\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> cfi_rel \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (f, brk) \\<Rightarrow> \\<not> brk; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; xa \\<noteq> [];\n        Graph.isShortestPath x1a s xa t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        RGraph c s t\n         (Graph.augment_cf x1a (set xa) (resCap_cf x1a xa))\\<rbrakk>\n       \\<Longrightarrow> ((Graph.augment_cf x1a (set xa) (resCap_cf x1a xa),\n                           False),\n                          NFlow.augment_with_path c x1 x'a, False)\n                         \\<in> cfi_rel \\<times>\\<^sub>r bool_rel\n 10. \\<And>x x' x1 x2 x1a x2a.\n        \\<lbrakk>(x, x') \\<in> cfi_rel \\<times>\\<^sub>r bool_rel;\n         x' = (x1, x2); x = (x1a, x2a); NFlow c s t x1\\<rbrakk>\n        \\<Longrightarrow> RGraph c s t x1a\nA total of 11 subgoals...", "apply vc_solve\n\n        \\<comment> \\<open>Solve some left-over verification conditions one by one\\<close>"], ["proof (prove)\ngoal (8 subgoals):\n 1. NFlow c s t (\\<lambda>_. 0::'capacity) \\<Longrightarrow>\n    (c, \\<lambda>_. 0::'capacity) \\<in> cfi_rel\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; (x1a, x1) \\<in> cfi_rel;\n        \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec_cf x1a\n                         \\<le> find_shortest_augmenting_spec x1\n 4. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; (x1a, x1) \\<in> cfi_rel;\n        \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s x'a t\n 5. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t\n                          (Graph.augment_cf x1a (set x'a)\n                            (resCap_cf x1a x'a))\n 6. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        RGraph c s t (Graph.augment_cf x1a (set x'a) (resCap_cf x1a x'a));\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> (Graph.augment_cf x1a (set x'a)\n                           (resCap_cf x1a x'a),\n                          NFlow.augment_with_path c x1 x'a)\n                         \\<in> cfi_rel\n 7. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 8. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf x1a = x1", "apply (drule NFlow.is_RGraph; \n            auto simp: cfi_rel_def br_def residualGraph_zero_flow flow_of_c; \n            fail)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; (x1a, x1) \\<in> cfi_rel;\n        \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec_cf x1a\n                         \\<le> find_shortest_augmenting_spec x1\n 3. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; (x1a, x1) \\<in> cfi_rel;\n        \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s x'a t\n 4. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t\n                          (Graph.augment_cf x1a (set x'a)\n                            (resCap_cf x1a x'a))\n 5. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        RGraph c s t (Graph.augment_cf x1a (set x'a) (resCap_cf x1a x'a));\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> (Graph.augment_cf x1a (set x'a)\n                           (resCap_cf x1a x'a),\n                          NFlow.augment_with_path c x1 x'a)\n                         \\<in> cfi_rel\n 6. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 7. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf x1a = x1", "apply (auto simp: cfi_rel_def br_def; fail)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec_cf x1a\n                         \\<le> find_shortest_augmenting_spec x1\n 2. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; (x1a, x1) \\<in> cfi_rel;\n        \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s x'a t\n 3. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t\n                          (Graph.augment_cf x1a (set x'a)\n                            (resCap_cf x1a x'a))\n 4. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        RGraph c s t (Graph.augment_cf x1a (set x'a) (resCap_cf x1a x'a));\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> (Graph.augment_cf x1a (set x'a)\n                           (resCap_cf x1a x'a),\n                          NFlow.augment_with_path c x1 x'a)\n                         \\<in> cfi_rel\n 5. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 6. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf x1a = x1", "using RGraph.find_shortest_augmenting_spec_cf_refine"], ["proof (prove)\nusing this:\n  RGraph ?c ?s ?t ?cf \\<Longrightarrow>\n  Network.find_shortest_augmenting_spec_cf ?c ?s ?t ?cf\n  \\<le> Network.find_shortest_augmenting_spec ?c ?s ?t\n         (Network.flow_of_cf ?c ?cf)\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec_cf x1a\n                         \\<le> find_shortest_augmenting_spec x1\n 2. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; (x1a, x1) \\<in> cfi_rel;\n        \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s x'a t\n 3. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t\n                          (Graph.augment_cf x1a (set x'a)\n                            (resCap_cf x1a x'a))\n 4. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        RGraph c s t (Graph.augment_cf x1a (set x'a) (resCap_cf x1a x'a));\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> (Graph.augment_cf x1a (set x'a)\n                           (resCap_cf x1a x'a),\n                          NFlow.augment_with_path c x1 x'a)\n                         \\<in> cfi_rel\n 5. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 6. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf x1a = x1", "apply (auto simp: cfi_rel_def br_def; fail)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t; (x1a, x1) \\<in> cfi_rel;\n        \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s x'a t\n 2. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t\n                          (Graph.augment_cf x1a (set x'a)\n                            (resCap_cf x1a x'a))\n 3. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        RGraph c s t (Graph.augment_cf x1a (set x'a) (resCap_cf x1a x'a));\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> (Graph.augment_cf x1a (set x'a)\n                           (resCap_cf x1a x'a),\n                          NFlow.augment_with_path c x1 x'a)\n                         \\<in> cfi_rel\n 4. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 5. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf x1a = x1", "apply (auto simp: cfi_rel_def br_def simp: RPreGraph.rg_fo_inv[OF RGraph.this_loc_rpg]; fail)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t\n                          (Graph.augment_cf x1a (set x'a)\n                            (resCap_cf x1a x'a))\n 2. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        RGraph c s t (Graph.augment_cf x1a (set x'a) (resCap_cf x1a x'a));\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> (Graph.augment_cf x1a (set x'a)\n                           (resCap_cf x1a x'a),\n                          NFlow.augment_with_path c x1 x'a)\n                         \\<in> cfi_rel\n 3. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 4. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf x1a = x1", "apply (drule (1) augment_cf_refine; simp add: cfi_rel_def br_def; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x1a x2a x'a.\n       \\<lbrakk>\\<not> x2; NFlow c s t x1; RGraph c s t x1a;\n        x'a \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'a;\n        Graph.isShortestPath (cf_of x1) s x'a t;\n        Graph.isShortestPath x1a s x'a t;\n        NFlow c s t (NFlow.augment_with_path c x1 x'a);\n        RGraph c s t (Graph.augment_cf x1a (set x'a) (resCap_cf x1a x'a));\n        (x1a, x1) \\<in> cfi_rel; \\<not> x2a\\<rbrakk>\n       \\<Longrightarrow> (Graph.augment_cf x1a (set x'a)\n                           (resCap_cf x1a x'a),\n                          NFlow.augment_with_path c x1 x'a)\n                         \\<in> cfi_rel\n 2. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 3. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf x1a = x1", "apply (simp add: augment_cf_refine; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 2. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf x1a = x1", "apply (auto simp: cfi_rel_def br_def; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>(x1a, x1) \\<in> cfi_rel; NFlow c s t x1;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf x1a = x1", "apply (auto simp: cfi_rel_def br_def; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  edka2 \\<le> \\<Down> Id edka\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Implementation of Bottleneck Computation and Augmentation\\<close>"], ["", "text \\<open>We will access the capacities in the residual graph\n      only by a get-operation, which asserts that the edges are valid\\<close>"], ["", "abbreviation (input) valid_edge :: \"edge \\<Rightarrow> bool\" where\n      \"valid_edge \\<equiv> \\<lambda>(u,v). u\\<in>V \\<and> v\\<in>V\""], ["", "definition cf_get \n      :: \"'capacity graph \\<Rightarrow> edge \\<Rightarrow> 'capacity nres\" \n      where \"cf_get cf e \\<equiv> ASSERT (valid_edge e) \\<then> RETURN (cf e)\""], ["", "definition cf_set \n      :: \"'capacity graph \\<Rightarrow> edge \\<Rightarrow> 'capacity \\<Rightarrow> 'capacity graph nres\"\n      where \"cf_set cf e cap \\<equiv> ASSERT (valid_edge e) \\<then> RETURN (cf(e:=cap))\""], ["", "definition resCap_cf_impl :: \"'capacity graph \\<Rightarrow> path \\<Rightarrow> 'capacity nres\" \n    where \"resCap_cf_impl cf p \\<equiv> \n      case p of\n        [] \\<Rightarrow> RETURN (0::'capacity)\n      | (e#p) \\<Rightarrow> do {\n          cap \\<leftarrow> cf_get cf e;\n          ASSERT (distinct p);\n          nfoldli \n            p (\\<lambda>_. True)\n            (\\<lambda>e cap. do {\n              cape \\<leftarrow> cf_get cf e;\n              RETURN (min cape cap)\n            }) \n            cap\n        }\""], ["", "lemma (in RGraph) resCap_cf_impl_refine:   \n      assumes AUG: \"cf.isSimplePath s p t\"\n      shows \"resCap_cf_impl cf p \\<le> SPEC (\\<lambda>r. r = resCap_cf cf p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "(* TODO: Can we exploit Min.set_eq_fold *)"], ["proof (state)\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "note [simp del] = Min_insert"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min (insert ?x ?A) = min ?x (Min ?A)\n\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "note [simp] = Min_insert[symmetric]"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> min ?x (Min ?A) = Min (insert ?x ?A)\n\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "from AUG[THEN cf.isSPath_distinct]"], ["proof (chain)\npicking this:\n  distinct p", "have \"distinct p\""], ["proof (prove)\nusing this:\n  distinct p\n\ngoal (1 subgoal):\n 1. distinct p", "."], ["proof (state)\nthis:\n  distinct p\n\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "moreover"], ["proof (state)\nthis:\n  distinct p\n\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "from AUG cf.isPath_edgeset"], ["proof (chain)\npicking this:\n  cf.isSimplePath s p t\n  \\<lbrakk>cf.isPath ?u ?p ?v; ?e \\<in> set ?p\\<rbrakk>\n  \\<Longrightarrow> ?e \\<in> cf.E", "have \"set p \\<subseteq> cf.E\""], ["proof (prove)\nusing this:\n  cf.isSimplePath s p t\n  \\<lbrakk>cf.isPath ?u ?p ?v; ?e \\<in> set ?p\\<rbrakk>\n  \\<Longrightarrow> ?e \\<in> cf.E\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> cf.E", "by (auto simp: cf.isSimplePath_def)"], ["proof (state)\nthis:\n  set p \\<subseteq> cf.E\n\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "hence \"set p \\<subseteq> Collect valid_edge\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> cf.E\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V}", "using cf.E_ss_VxV"], ["proof (prove)\nusing this:\n  set p \\<subseteq> cf.E\n  cf.E \\<subseteq> cf.V \\<times> cf.V\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V}", "by simp"], ["proof (state)\nthis:\n  set p \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V}\n\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "moreover"], ["proof (state)\nthis:\n  set p \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V}\n\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "from AUG"], ["proof (chain)\npicking this:\n  cf.isSimplePath s p t", "have \"p\\<noteq>[]\""], ["proof (prove)\nusing this:\n  cf.isSimplePath s p t\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by (auto simp: s_not_t)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []", "obtain e p' where \"p=e#p'\""], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>e p'. p = e # p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  p = e # p'\n\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "ultimately"], ["proof (chain)\npicking this:\n  distinct p\n  set p \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V}\n  p = e # p'", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct p\n  set p \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V}\n  p = e # p'\n\ngoal (1 subgoal):\n 1. resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)", "unfolding resCap_cf_impl_def resCap_cf_def cf_get_def"], ["proof (prove)\nusing this:\n  distinct p\n  set p \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V}\n  p = e # p'\n\ngoal (1 subgoal):\n 1. (case p of [] \\<Rightarrow> return (0::'a)\n     | e # p \\<Rightarrow>\n         assert\n          (case e of\n           (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V) \\<bind>\n         (\\<lambda>_. return (cf e)) \\<bind>\n         (\\<lambda>cap.\n             assert (distinct p) \\<bind>\n             (\\<lambda>_.\n                 nfoldli p (\\<lambda>_. True)\n                  (\\<lambda>e cap.\n                      assert\n                       (case e of\n                        (u, v) \\<Rightarrow>\n                          u \\<in> V \\<and> v \\<in> V) \\<bind>\n                      (\\<lambda>_. return (cf e)) \\<bind>\n                      (\\<lambda>cape. return (min cape cap)))\n                  cap)))\n    \\<le> (spec r. r = Min {cf e |e. e \\<in> set p})", "apply (simp only: list.case)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (e # p');\n     set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n     p = e # p'\\<rbrakk>\n    \\<Longrightarrow> assert\n                       (case e of\n                        (u, v) \\<Rightarrow>\n                          u \\<in> V \\<and> v \\<in> V) \\<bind>\n                      (\\<lambda>_. return (cf e)) \\<bind>\n                      (\\<lambda>cap.\n                          assert (distinct p') \\<bind>\n                          (\\<lambda>_.\n                              nfoldli p' (\\<lambda>_. True)\n                               (\\<lambda>e cap.\n                                   assert\n                                    (case e of\n                                     (u, v) \\<Rightarrow>\n u \\<in> V \\<and> v \\<in> V) \\<bind>\n                                   (\\<lambda>_. return (cf e)) \\<bind>\n                                   (\\<lambda>cape. return (min cape cap)))\n                               cap))\n                      \\<le> (spec r.\n                                r = Min {cf ea |ea. ea \\<in> set (e # p')})", "apply (refine_vcg nfoldli_rule[where \n            I = \"\\<lambda>l l' cap. \n              cap = Min (cf`insert e (set l)) \n            \\<and> set (l@l') \\<subseteq> Collect valid_edge\"])"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (e # p');\n        set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n        p = e # p'; e = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> V\n 2. \\<And>x1 x2.\n       \\<lbrakk>distinct (e # p');\n        set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n        p = e # p'; e = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> V\n 3. \\<lbrakk>distinct (e # p');\n     set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n     p = e # p';\n     case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> distinct p'\n 4. \\<lbrakk>distinct (e # p');\n     set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n     p = e # p'; case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n     distinct p'\\<rbrakk>\n    \\<Longrightarrow> cf e = Min (cf ` insert e (set []))\n 5. \\<lbrakk>distinct (e # p');\n     set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n     p = e # p'; case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n     distinct p'\\<rbrakk>\n    \\<Longrightarrow> set ([] @ p')\n                      \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V}\n 6. \\<And>x l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>distinct (e # p');\n        set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n        p = e # p';\n        case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        distinct p'; p' = l1 @ x # l2;\n        \\<sigma> = Min (cf ` insert e (set l1)) \\<and>\n        set (l1 @ x # l2) \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n        True; x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> V\n 7. \\<And>x l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>distinct (e # p');\n        set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n        p = e # p';\n        case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        distinct p'; p' = l1 @ x # l2;\n        \\<sigma> = Min (cf ` insert e (set l1)) \\<and>\n        set (l1 @ x # l2) \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n        True; x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> V\n 8. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>distinct (e # p');\n        set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n        p = e # p';\n        case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        distinct p'; p' = l1 @ x # l2;\n        \\<sigma> = Min (cf ` insert e (set l1)) \\<and>\n        set (l1 @ x # l2) \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n        True;\n        case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> min (cf x) \\<sigma> =\n                         Min (cf ` insert e (set (l1 @ [x])))\n 9. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>distinct (e # p');\n        set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n        p = e # p';\n        case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        distinct p'; p' = l1 @ x # l2;\n        \\<sigma> = Min (cf ` insert e (set l1)) \\<and>\n        set (l1 @ x # l2) \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n        True;\n        case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> set ((l1 @ [x]) @ l2)\n                         \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V}\n 10. \\<And>l1 l2 \\<sigma>.\n        \\<lbrakk>distinct (e # p');\n         set (e # p') \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n         p = e # p';\n         case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n         distinct p'; p' = l1 @ l2;\n         \\<sigma> = Min (cf ` insert e (set l1)) \\<and>\n         set (l1 @ l2) \\<subseteq> {(u, v). u \\<in> V \\<and> v \\<in> V};\n         \\<not> True\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> = Min {cf ea |ea. ea \\<in> set (e # p')}\nA total of 11 subgoals...", "apply (auto intro!: arg_cong[where f=Min])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  resCap_cf_impl cf p \\<le> (spec r. r = resCap_cf cf p)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition (in Graph) \n      \"augment_edge e cap \\<equiv> (c(\n                  e := c e - cap, \n        prod.swap e := c (prod.swap e) + cap))\""], ["", "(* TODO: This would be much simpler to prove if we had a characterization \n      of simple-path only depending on p. *)"], ["", "lemma (in Graph) augment_cf_inductive:\n      fixes e cap\n      defines \"c' \\<equiv> augment_edge e cap\"\n      assumes P: \"isSimplePath s (e#p) t\"\n      shows \"augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap\"\n      and \"\\<exists>s'. Graph.isSimplePath c' s' p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap &&&\n    \\<exists>s'. Graph.isSimplePath c' s' p t", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap\n 2. \\<exists>s'. Graph.isSimplePath c' s' p t", "obtain u v where [simp]: \"e=(u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v. e = (u, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e)"], ["proof (state)\nthis:\n  e = (u, v)\n\ngoal (2 subgoals):\n 1. augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap\n 2. \\<exists>s'. Graph.isSimplePath c' s' p t", "from isSPath_no_selfloop[OF P]"], ["proof (chain)\npicking this:\n  (?u1.0, ?u1.0) \\<notin> set (e # p)", "have [simp]: \"\\<And>u. (u,u)\\<notin>set p\" \"u\\<noteq>v\""], ["proof (prove)\nusing this:\n  (?u1.0, ?u1.0) \\<notin> set (e # p)\n\ngoal (1 subgoal):\n 1. (\\<And>u. (u, u) \\<notin> set p) &&& u \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  (?u1, ?u1) \\<notin> set p\n  u \\<noteq> v\n\ngoal (2 subgoals):\n 1. augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap\n 2. \\<exists>s'. Graph.isSimplePath c' s' p t", "from isSPath_nt_parallel[OF P]"], ["proof (chain)\npicking this:\n  ?e \\<in> set (e # p) \\<Longrightarrow> prod.swap ?e \\<notin> set (e # p)", "have [simp]: \"(v,u)\\<notin>set p\""], ["proof (prove)\nusing this:\n  ?e \\<in> set (e # p) \\<Longrightarrow> prod.swap ?e \\<notin> set (e # p)\n\ngoal (1 subgoal):\n 1. (v, u) \\<notin> set p", "by auto"], ["proof (state)\nthis:\n  (v, u) \\<notin> set p\n\ngoal (2 subgoals):\n 1. augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap\n 2. \\<exists>s'. Graph.isSimplePath c' s' p t", "from isSPath_distinct[OF P]"], ["proof (chain)\npicking this:\n  distinct (e # p)", "have [simp]: \"(u,v)\\<notin>set p\""], ["proof (prove)\nusing this:\n  distinct (e # p)\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> set p", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<notin> set p\n\ngoal (2 subgoals):\n 1. augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap\n 2. \\<exists>s'. Graph.isSimplePath c' s' p t", "show \"augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       augment_cf (insert e (set p)) cap x =\n       Graph.augment_cf c' (set p) cap x", "unfolding Graph.augment_cf_def c'_def Graph.augment_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (if x \\<in> insert e (set p) then c x - cap\n        else if prod.swap x \\<in> insert e (set p) then c x + cap\n             else c x) =\n       (if x \\<in> set p\n        then (c(e := c e - cap, prod.swap e := c (prod.swap e) + cap)) x -\n             cap\n        else if prod.swap x \\<in> set p\n             then (c(e := c e - cap, prod.swap e := c (prod.swap e) + cap))\n                   x +\n                  cap\n             else (c(e := c e - cap, prod.swap e := c (prod.swap e) + cap))\n                   x)", "by auto"], ["proof (state)\nthis:\n  augment_cf (insert e (set p)) cap = Graph.augment_cf c' (set p) cap\n\ngoal (1 subgoal):\n 1. \\<exists>s'. Graph.isSimplePath c' s' p t", "have \"Graph.isSimplePath c' v p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph.isSimplePath c' v p t", "unfolding Graph.isSimplePath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph.isPath c' v p t \\<and> distinct (pathVertices v p)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. Graph.isPath c' v p t\n 2. distinct (pathVertices v p)", "apply (rule transfer_path)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set p \\<inter> E \\<subseteq> Graph.E c'\n 2. isPath v p t\n 3. distinct (pathVertices v p)", "unfolding Graph.E_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. set p \\<inter> {(u, v). c (u, v) \\<noteq> (0::'capacity)}\n    \\<subseteq> {(u, v). c' (u, v) \\<noteq> (0::'capacity)}\n 2. isPath v p t\n 3. distinct (pathVertices v p)", "apply (auto simp: c'_def Graph.augment_edge_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. isPath v p t\n 2. distinct (pathVertices v p)", "using P"], ["proof (prove)\nusing this:\n  isSimplePath s (e # p) t\n\ngoal (2 subgoals):\n 1. isPath v p t\n 2. distinct (pathVertices v p)", "apply (auto simp: isSimplePath_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (pathVertices v p)", "using P"], ["proof (prove)\nusing this:\n  isSimplePath s (e # p) t\n\ngoal (1 subgoal):\n 1. distinct (pathVertices v p)", "apply (auto simp: isSimplePath_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Graph.isSimplePath c' v p t\n\ngoal (1 subgoal):\n 1. \\<exists>s'. Graph.isSimplePath c' s' p t", "thus \"\\<exists>s'. Graph.isSimplePath c' s' p t\""], ["proof (prove)\nusing this:\n  Graph.isSimplePath c' v p t\n\ngoal (1 subgoal):\n 1. \\<exists>s'. Graph.isSimplePath c' s' p t", ".."], ["proof (state)\nthis:\n  \\<exists>s'. Graph.isSimplePath c' s' p t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"augment_edge_impl cf e cap \\<equiv> do {\n      v \\<leftarrow> cf_get cf e; cf \\<leftarrow> cf_set cf e (v-cap);\n      let e = prod.swap e;\n      v \\<leftarrow> cf_get cf e; cf \\<leftarrow> cf_set cf e (v+cap);\n      RETURN cf\n    }\""], ["", "lemma augment_edge_impl_refine: \n      assumes \"valid_edge e\" \"\\<forall>u. e\\<noteq>(u,u)\"\n      shows \"augment_edge_impl cf e cap \n          \\<le> (spec r. r = Graph.augment_edge cf e cap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_edge_impl cf e cap\n    \\<le> (spec r. r = Graph.augment_edge cf e cap)", "using assms"], ["proof (prove)\nusing this:\n  case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\n  \\<forall>u. e \\<noteq> (u, u)\n\ngoal (1 subgoal):\n 1. augment_edge_impl cf e cap\n    \\<le> (spec r. r = Graph.augment_edge cf e cap)", "unfolding augment_edge_impl_def Graph.augment_edge_def"], ["proof (prove)\nusing this:\n  case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\n  \\<forall>u. e \\<noteq> (u, u)\n\ngoal (1 subgoal):\n 1. cf_get cf e \\<bind>\n    (\\<lambda>v.\n        cf_set cf e (v - cap) \\<bind>\n        (\\<lambda>cf.\n            let e = prod.swap e\n            in cf_get cf e \\<bind>\n               (\\<lambda>v. cf_set cf e (v + cap) \\<bind> return)))\n    \\<le> (spec r.\n              r = cf\n              (e := cf e - cap, prod.swap e := cf (prod.swap e) + cap))", "unfolding cf_get_def cf_set_def"], ["proof (prove)\nusing this:\n  case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\n  \\<forall>u. e \\<noteq> (u, u)\n\ngoal (1 subgoal):\n 1. assert\n     (case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V) \\<bind>\n    (\\<lambda>_. return (cf e)) \\<bind>\n    (\\<lambda>v.\n        assert\n         (case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V) \\<bind>\n        (\\<lambda>_. return (cf(e := v - cap))) \\<bind>\n        (\\<lambda>cf.\n            let e = prod.swap e\n            in assert\n                (case e of\n                 (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V) \\<bind>\n               (\\<lambda>_. return (cf e)) \\<bind>\n               (\\<lambda>v.\n                   assert\n                    (case e of\n                     (u, v) \\<Rightarrow>\n                       u \\<in> V \\<and> v \\<in> V) \\<bind>\n                   (\\<lambda>_. return (cf(e := v + cap))) \\<bind>\n                   return)))\n    \\<le> (spec r.\n              r = cf\n              (e := cf e - cap, prod.swap e := cf (prod.swap e) + cap))", "apply refine_vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        \\<forall>u. e \\<noteq> (u, u);\n        case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        prod.swap e = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> V\n 2. \\<And>x1 x2.\n       \\<lbrakk>case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        \\<forall>u. e \\<noteq> (u, u);\n        case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        prod.swap e = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> V\n 3. \\<lbrakk>case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n     \\<forall>u. e \\<noteq> (u, u);\n     case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n     case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n     case prod.swap e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n     case prod.swap e of\n     (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> cf(e := cf e - cap,\n                         prod.swap e :=\n                           (cf(e := cf e - cap)) (prod.swap e) + cap) =\n                      cf(e := cf e - cap,\n                         prod.swap e := cf (prod.swap e) + cap)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition augment_cf_impl \n      :: \"'capacity graph \\<Rightarrow> path \\<Rightarrow> 'capacity \\<Rightarrow> 'capacity graph nres\" \n      where\n      \"augment_cf_impl cf p x \\<equiv> do {\n        (rec\\<^sub>T D. \\<lambda>\n          ([],cf) \\<Rightarrow> return cf\n        | (e#p,cf) \\<Rightarrow> do {\n            cf \\<leftarrow> augment_edge_impl cf e x;\n            D (p,cf)\n          }  \n        ) (p,cf)\n      }\""], ["", "text \\<open>Deriving the corresponding recursion equations\\<close>"], ["", "lemma augment_cf_impl_simps[simp]: \n      \"augment_cf_impl cf [] x = return cf\"\n      \"augment_cf_impl cf (e#p) x = do { \n        cf \\<leftarrow> augment_edge_impl cf e x; \n        augment_cf_impl cf p x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_cf_impl cf [] x = return cf &&&\n    augment_cf_impl cf (e # p) x =\n    augment_edge_impl cf e x \\<bind> (\\<lambda>cf. augment_cf_impl cf p x)", "apply (simp add: augment_cf_impl_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (rec\\<^sub>T D.\n        (\\<lambda>xa.\n            case xa of ([], cf) \\<Rightarrow> return cf\n            | (e # p, cf) \\<Rightarrow>\n                augment_edge_impl cf e x \\<bind> (\\<lambda>cf. D (p, cf))))\n     ([], cf) =\n    return cf\n 2. augment_cf_impl cf (e # p) x =\n    augment_edge_impl cf e x \\<bind> (\\<lambda>cf. augment_cf_impl cf p x)", "apply (subst RECT_unfold, refine_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (case ([], cf) of ([], cf) \\<Rightarrow> return cf\n     | (e # p, cf) \\<Rightarrow>\n         augment_edge_impl cf e x \\<bind>\n         (\\<lambda>cf.\n             (rec\\<^sub>T D.\n                 (\\<lambda>(a, cf).\n                     case a of [] \\<Rightarrow> return cf\n                     | e # p \\<Rightarrow>\n                         augment_edge_impl cf e x \\<bind>\n                         (\\<lambda>cf. D (p, cf))))\n              (p, cf))) =\n    return cf\n 2. augment_cf_impl cf (e # p) x =\n    augment_edge_impl cf e x \\<bind> (\\<lambda>cf. augment_cf_impl cf p x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_cf_impl cf (e # p) x =\n    augment_edge_impl cf e x \\<bind> (\\<lambda>cf. augment_cf_impl cf p x)", "apply (simp add: augment_cf_impl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec\\<^sub>T D.\n        (\\<lambda>xa.\n            case xa of ([], cf) \\<Rightarrow> return cf\n            | (e # p, cf) \\<Rightarrow>\n                augment_edge_impl cf e x \\<bind> (\\<lambda>cf. D (p, cf))))\n     (e # p, cf) =\n    augment_edge_impl cf e x \\<bind>\n    (\\<lambda>cf.\n        (rec\\<^sub>T D.\n            (\\<lambda>xa.\n                case xa of ([], cf) \\<Rightarrow> return cf\n                | (e # p, cf) \\<Rightarrow>\n                    augment_edge_impl cf e x \\<bind>\n                    (\\<lambda>cf. D (p, cf))))\n         (p, cf))", "apply (subst RECT_unfold, refine_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (e # p, cf) of ([], cf) \\<Rightarrow> return cf\n     | (e # p, cf) \\<Rightarrow>\n         augment_edge_impl cf e x \\<bind>\n         (\\<lambda>cf.\n             (rec\\<^sub>T D.\n                 (\\<lambda>(a, cf).\n                     case a of [] \\<Rightarrow> return cf\n                     | e # p \\<Rightarrow>\n                         augment_edge_impl cf e x \\<bind>\n                         (\\<lambda>cf. D (p, cf))))\n              (p, cf))) =\n    augment_edge_impl cf e x \\<bind>\n    (\\<lambda>cf.\n        (rec\\<^sub>T D.\n            (\\<lambda>(a, cf).\n                case a of [] \\<Rightarrow> return cf\n                | e # p \\<Rightarrow>\n                    augment_edge_impl cf e x \\<bind>\n                    (\\<lambda>cf. D (p, cf))))\n         (p, cf))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma augment_cf_impl_aux:    \n      assumes \"\\<forall>e\\<in>set p. valid_edge e\"\n      assumes \"\\<exists>s. Graph.isSimplePath cf s p t\"\n      shows \"augment_cf_impl cf p x \\<le> RETURN (Graph.augment_cf cf (set p) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_cf_impl cf p x \\<le> return (Graph.augment_cf cf (set p) x)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set p.\n     case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\n  \\<exists>s. Graph.isSimplePath cf s p t\n\ngoal (1 subgoal):\n 1. augment_cf_impl cf p x \\<le> return (Graph.augment_cf cf (set p) x)", "apply (induction p arbitrary: cf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf.\n       \\<lbrakk>\\<forall>(u, v)\\<in>set []. u \\<in> V \\<and> v \\<in> V;\n        \\<exists>s. Graph.isSimplePath cf s [] t\\<rbrakk>\n       \\<Longrightarrow> augment_cf_impl cf [] x\n                         \\<le> return (Graph.augment_cf cf (set []) x)\n 2. \\<And>a p cf.\n       \\<lbrakk>\\<And>cf.\n                   \\<lbrakk>\\<forall>(u, v)\\<in>set p.\n                               u \\<in> V \\<and> v \\<in> V;\n                    \\<exists>s. Graph.isSimplePath cf s p t\\<rbrakk>\n                   \\<Longrightarrow> augment_cf_impl cf p x\n                                     \\<le> return\n      (Graph.augment_cf cf (set p) x);\n        \\<forall>(u, v)\\<in>set (a # p). u \\<in> V \\<and> v \\<in> V;\n        \\<exists>s. Graph.isSimplePath cf s (a # p) t\\<rbrakk>\n       \\<Longrightarrow> augment_cf_impl cf (a # p) x\n                         \\<le> return (Graph.augment_cf cf (set (a # p)) x)", "apply (simp add: Graph.augment_cf_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p cf.\n       \\<lbrakk>\\<And>cf.\n                   \\<lbrakk>\\<forall>(u, v)\\<in>set p.\n                               u \\<in> V \\<and> v \\<in> V;\n                    \\<exists>s. Graph.isSimplePath cf s p t\\<rbrakk>\n                   \\<Longrightarrow> augment_cf_impl cf p x\n                                     \\<le> return\n      (Graph.augment_cf cf (set p) x);\n        \\<forall>(u, v)\\<in>set (a # p). u \\<in> V \\<and> v \\<in> V;\n        \\<exists>s. Graph.isSimplePath cf s (a # p) t\\<rbrakk>\n       \\<Longrightarrow> augment_cf_impl cf (a # p) x\n                         \\<le> return (Graph.augment_cf cf (set (a # p)) x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b p cf s.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V\\<rbrakk>\n       \\<Longrightarrow> augment_edge_impl cf (a, b) x \\<bind>\n                         (\\<lambda>cf. augment_cf_impl cf p x)\n                         \\<le> return\n                                (Graph.augment_cf cf (insert (a, b) (set p))\n                                  x)", "apply (subst Graph.augment_cf_inductive, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b p cf s.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V\\<rbrakk>\n       \\<Longrightarrow> augment_edge_impl cf (a, b) x \\<bind>\n                         (\\<lambda>cf. augment_cf_impl cf p x)\n                         \\<le> return\n                                (Graph.augment_cf\n                                  (Graph.augment_edge cf (a, b) x) (set p)\n                                  x)", "apply (refine_vcg augment_edge_impl_refine[THEN order_trans])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b p cf s x1 x2.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V; (a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> V\n 2. \\<And>a b p cf s x1 x2.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V; (a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> V\n 3. \\<And>a b p cf s u.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<noteq> (u, u)\n 4. \\<And>a b p cf s xa.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V; xa = Graph.augment_edge cf (a, b) x\\<rbrakk>\n       \\<Longrightarrow> augment_cf_impl xa p x\n                         \\<le> SPEC\n                                ((=) (Graph.augment_cf\n (Graph.augment_edge cf (a, b) x) (set p) x))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b p cf s x1 x2.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V; (a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> V\n 2. \\<And>a b p cf s u.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<noteq> (u, u)\n 3. \\<And>a b p cf s xa.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V; xa = Graph.augment_edge cf (a, b) x\\<rbrakk>\n       \\<Longrightarrow> augment_cf_impl xa p x\n                         \\<le> SPEC\n                                ((=) (Graph.augment_cf\n (Graph.augment_edge cf (a, b) x) (set p) x))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b p cf s u.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<noteq> (u, u)\n 2. \\<And>a b p cf s xa.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V; xa = Graph.augment_edge cf (a, b) x\\<rbrakk>\n       \\<Longrightarrow> augment_cf_impl xa p x\n                         \\<le> SPEC\n                                ((=) (Graph.augment_cf\n (Graph.augment_edge cf (a, b) x) (set p) x))", "apply (auto dest: Graph.isSPath_no_selfloop) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b p cf s xa.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V; xa = Graph.augment_edge cf (a, b) x\\<rbrakk>\n       \\<Longrightarrow> augment_cf_impl xa p x\n                         \\<le> SPEC\n                                ((=) (Graph.augment_cf\n (Graph.augment_edge cf (a, b) x) (set p) x))", "apply (rule order_trans, rprems)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b p cf s xa.\n       \\<lbrakk>Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V; xa = Graph.augment_edge cf (a, b) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s. Graph.isSimplePath xa s p t\n 2. \\<And>a b p cf s xa.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V; xa = Graph.augment_edge cf (a, b) x\\<rbrakk>\n       \\<Longrightarrow> return (Graph.augment_cf xa (set p) x)\n                         \\<le> SPEC\n                                ((=) (Graph.augment_cf\n (Graph.augment_edge cf (a, b) x) (set p) x))", "apply (drule Graph.augment_cf_inductive(2)[where cap=x]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b p cf s xa.\n       \\<lbrakk>\\<And>cf.\n                   \\<exists>s. Graph.isSimplePath cf s p t \\<Longrightarrow>\n                   augment_cf_impl cf p x\n                   \\<le> return (Graph.augment_cf cf (set p) x);\n        Graph.isSimplePath cf s ((a, b) # p) t;\n        \\<forall>x\\<in>set p.\n           case x of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        a \\<in> V; b \\<in> V; xa = Graph.augment_edge cf (a, b) x\\<rbrakk>\n       \\<Longrightarrow> return (Graph.augment_cf xa (set p) x)\n                         \\<le> SPEC\n                                ((=) (Graph.augment_cf\n (Graph.augment_edge cf (a, b) x) (set p) x))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in RGraph) augment_cf_impl_refine:     \n      assumes \"Graph.isSimplePath cf s p t\"\n      shows \"augment_cf_impl cf p x \\<le> RETURN (Graph.augment_cf cf (set p) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_cf_impl cf p x \\<le> return (cf.augment_cf (set p) x)", "apply (rule augment_cf_impl_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>set p.\n       case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\n 2. \\<exists>s. cf.isSimplePath s p t", "using assms cf.E_ss_VxV"], ["proof (prove)\nusing this:\n  cf.isSimplePath s p t\n  cf.E \\<subseteq> cf.V \\<times> cf.V\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>set p.\n       case e of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\n 2. \\<exists>s. cf.isSimplePath s p t", "apply (auto simp: cf.isSimplePath_def dest!: cf.isPath_edgeset) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. cf.isSimplePath s p t", "using assms"], ["proof (prove)\nusing this:\n  cf.isSimplePath s p t\n\ngoal (1 subgoal):\n 1. \\<exists>s. cf.isSimplePath s p t", "by blast"], ["", "text \\<open>Finally, we arrive at the algorithm where augmentation is \n      implemented algorithmically: \\<close>"], ["", "definition \"edka3 \\<equiv> do {\n      let cf = c;\n\n      (cf,_) \\<leftarrow> while\\<^sub>T \n        (\\<lambda>(cf,brk). \\<not>brk) \n        (\\<lambda>(cf,_). do {\n          assert (RGraph c s t cf);\n          p \\<leftarrow> find_shortest_augmenting_spec_cf cf;\n          case p of \n            None \\<Rightarrow> return (cf,True)\n          | Some p \\<Rightarrow> do {\n              assert (p\\<noteq>[]);\n              assert (Graph.isShortestPath cf s p t);\n              bn \\<leftarrow> resCap_cf_impl cf p;\n              cf \\<leftarrow> augment_cf_impl cf p bn;\n              assert (RGraph c s t cf);\n              return (cf, False)\n            }  \n        })\n        (cf,False);\n      assert (RGraph c s t cf);\n      let f = flow_of_cf cf;  \n      return f\n    }\""], ["", "lemma edka3_refine: \"edka3 \\<le> \\<Down>Id edka2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edka3 \\<le> \\<Down> Id edka2", "unfolding edka3_def edka2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let cf = c\n     in while\\<^sub>T (\\<lambda>(cf, brk). \\<not> brk)\n         (\\<lambda>(cf, uu_).\n             assert (RGraph c s t cf) \\<bind>\n             (\\<lambda>_.\n                 find_shortest_augmenting_spec_cf cf \\<bind>\n                 (\\<lambda>p.\n                     case p of None \\<Rightarrow> return (cf, True)\n                     | Some p \\<Rightarrow>\n                         assert (p \\<noteq> []) \\<bind>\n                         (\\<lambda>_.\n                             assert (Graph.isShortestPath cf s p t) \\<bind>\n                             (\\<lambda>_.\n                                 resCap_cf_impl cf p \\<bind>\n                                 (\\<lambda>bn.\n                                     augment_cf_impl cf p bn \\<bind>\n                                     (\\<lambda>cf.\n   assert (RGraph c s t cf) \\<bind> (\\<lambda>_. return (cf, False)))))))))\n         (cf, False) \\<bind>\n        (\\<lambda>(cf, uu_).\n            assert (RGraph c s t cf) \\<bind>\n            (\\<lambda>_. Let (flow_of_cf cf) return)))\n    \\<le> \\<Down> Id\n           (let cf = c\n            in while\\<^sub>T (\\<lambda>(cf, brk). \\<not> brk)\n                (\\<lambda>(cf, uu_).\n                    assert (RGraph c s t cf) \\<bind>\n                    (\\<lambda>_.\n                        find_shortest_augmenting_spec_cf cf \\<bind>\n                        (\\<lambda>p.\n                            case p of None \\<Rightarrow> return (cf, True)\n                            | Some p \\<Rightarrow>\n                                assert (p \\<noteq> []) \\<bind>\n                                (\\<lambda>_.\n                                    assert\n                                     (Graph.isShortestPath cf s p t) \\<bind>\n                                    (\\<lambda>_.\n  let cf = Graph.augment_cf cf (set p) (resCap_cf cf p)\n  in assert (RGraph c s t cf) \\<bind> (\\<lambda>_. return (cf, False)))))))\n                (cf, False) \\<bind>\n               (\\<lambda>(cf, uu_).\n                   assert (RGraph c s t cf) \\<bind>\n                   (\\<lambda>_. Let (flow_of_cf cf) return)))", "apply (rewrite in \"let cf = Graph.augment_cf _ _ _ in _\" Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let cf = c\n     in while\\<^sub>T (\\<lambda>(cf, brk). \\<not> brk)\n         (\\<lambda>(cf, uu_).\n             assert (RGraph c s t cf) \\<bind>\n             (\\<lambda>_.\n                 find_shortest_augmenting_spec_cf cf \\<bind>\n                 (\\<lambda>p.\n                     case p of None \\<Rightarrow> return (cf, True)\n                     | Some p \\<Rightarrow>\n                         assert (p \\<noteq> []) \\<bind>\n                         (\\<lambda>_.\n                             assert (Graph.isShortestPath cf s p t) \\<bind>\n                             (\\<lambda>_.\n                                 resCap_cf_impl cf p \\<bind>\n                                 (\\<lambda>bn.\n                                     augment_cf_impl cf p bn \\<bind>\n                                     (\\<lambda>cf.\n   assert (RGraph c s t cf) \\<bind> (\\<lambda>_. return (cf, False)))))))))\n         (cf, False) \\<bind>\n        (\\<lambda>(cf, uu_).\n            assert (RGraph c s t cf) \\<bind>\n            (\\<lambda>_. Let (flow_of_cf cf) return)))\n    \\<le> \\<Down> Id\n           (let cf = c\n            in while\\<^sub>T (\\<lambda>(cf, brk). \\<not> brk)\n                (\\<lambda>(cf, uu_).\n                    assert (RGraph c s t cf) \\<bind>\n                    (\\<lambda>_.\n                        find_shortest_augmenting_spec_cf cf \\<bind>\n                        (\\<lambda>p.\n                            case p of None \\<Rightarrow> return (cf, True)\n                            | Some p \\<Rightarrow>\n                                assert (p \\<noteq> []) \\<bind>\n                                (\\<lambda>_.\n                                    assert\n                                     (Graph.isShortestPath cf s p t) \\<bind>\n                                    (\\<lambda>_.\n  assert\n   (RGraph c s t (Graph.augment_cf cf (set p) (resCap_cf cf p))) \\<bind>\n  (\\<lambda>_.\n      return (Graph.augment_cf cf (set p) (resCap_cf cf p), False)))))))\n                (cf, False) \\<bind>\n               (\\<lambda>(cf, uu_).\n                   assert (RGraph c s t cf) \\<bind>\n                   (\\<lambda>_. Let (flow_of_cf cf) return)))", "apply refine_rcg"], ["proof (prove)\ngoal (11 subgoals):\n 1. ((c, False), c, False) \\<in> ?R'4\n 2. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'4; x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 3. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'4;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 4. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'4;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec_cf x1a\n                         \\<le> \\<Down> (?R'36 x x' x1 x2 x1a x2a)\n                                (find_shortest_augmenting_spec_cf x1)\n 5. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'4;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa) \\<in> ?R'36 x x' x1 x2 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> (p, pa)\n                         \\<in> \\<langle>?Ra37 x x' x1 x2 x1a x2a p\n   pa\\<rangle>option_rel\n 6. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'4;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa) \\<in> ?R'36 x x' x1 x2 x1a x2a; p = None; pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True) \\<in> ?R'4\n 7. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'4;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa) \\<in> ?R'36 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra37 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        Graph.isShortestPath x1 s x'a t;\n        RGraph c s t\n         (Graph.augment_cf x1 (set x'a) (resCap_cf x1 x'a))\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'4;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa) \\<in> ?R'36 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra37 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        Graph.isShortestPath x1 s x'a t;\n        RGraph c s t (Graph.augment_cf x1 (set x'a) (resCap_cf x1 x'a));\n        xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s xa t\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'4;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa) \\<in> ?R'36 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra37 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        Graph.isShortestPath x1 s x'a t;\n        RGraph c s t (Graph.augment_cf x1 (set x'a) (resCap_cf x1 x'a));\n        xa \\<noteq> []; Graph.isShortestPath x1a s xa t\\<rbrakk>\n       \\<Longrightarrow> resCap_cf_impl x1a xa \\<bind>\n                         (\\<lambda>bn.\n                             augment_cf_impl x1a xa bn \\<bind>\n                             (\\<lambda>cf.\n                                 assert (RGraph c s t cf) \\<bind>\n                                 (\\<lambda>_. return (cf, False))))\n                         \\<le> (spec c.\n                                   (c, Graph.augment_cf x1 (set x'a)\n  (resCap_cf x1 x'a),\n                                    False)\n                                   \\<in> ?R'4)\n 10. \\<And>x x' x1 x2 x1a x2a.\n        \\<lbrakk>(x, x') \\<in> ?R'4; x' = (x1, x2); x = (x1a, x2a);\n         RGraph c s t x1\\<rbrakk>\n        \\<Longrightarrow> RGraph c s t x1a\nA total of 11 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (10 subgoals):\n 1. ((c, False), c, False) \\<in> Id \\<times>\\<^sub>r bool_rel\n 2. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; x = (x1, x2);\n        x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 3. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 4. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> find_shortest_augmenting_spec_cf x1a\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n             nat_rel\\<rangle>list_rel\\<rangle>option_rel)\n                                (find_shortest_augmenting_spec_cf x1)\n 5. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = None; pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 6. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; Graph.isShortestPath x1 s x'a t;\n        RGraph c s t\n         (Graph.augment_cf x1 (set x'a) (resCap_cf x1 x'a))\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 7. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; Graph.isShortestPath x1 s x'a t;\n        RGraph c s t (Graph.augment_cf x1 (set x'a) (resCap_cf x1 x'a));\n        xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s xa t\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; Graph.isShortestPath x1 s x'a t;\n        RGraph c s t (Graph.augment_cf x1 (set x'a) (resCap_cf x1 x'a));\n        xa \\<noteq> []; Graph.isShortestPath x1a s xa t\\<rbrakk>\n       \\<Longrightarrow> resCap_cf_impl x1a xa \\<bind>\n                         (\\<lambda>bn.\n                             augment_cf_impl x1a xa bn \\<bind>\n                             (\\<lambda>cf.\n                                 assert (RGraph c s t cf) \\<bind>\n                                 (\\<lambda>_. return (cf, False))))\n                         \\<le> (spec c.\n                                   (c, Graph.augment_cf x1 (set x'a)\n  (resCap_cf x1 x'a),\n                                    False)\n                                   \\<in> Id \\<times>\\<^sub>r bool_rel)\n 9. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 10. \\<And>x x' x1 x2 x1a x2a.\n        \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; x' = (x1, x2);\n         x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a\\<rbrakk>\n        \\<Longrightarrow> (flow_of_cf x1a, flow_of_cf x1) \\<in> Id", "apply (vc_solve)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x2a x'a.\n       \\<lbrakk>\\<not> x2a; \\<not> x2; RGraph c s t x1; x'a \\<noteq> [];\n        Graph.isShortestPath x1 s x'a t;\n        RGraph c s t\n         (Graph.augment_cf x1 (set x'a) (resCap_cf x1 x'a))\\<rbrakk>\n       \\<Longrightarrow> resCap_cf_impl x1 x'a \\<bind>\n                         (\\<lambda>bn.\n                             augment_cf_impl x1 x'a bn \\<bind>\n                             (\\<lambda>cf.\n                                 assert (RGraph c s t cf) \\<bind>\n                                 (\\<lambda>_. return (cf, False))))\n                         \\<le> RES {(Graph.augment_cf x1 (set x'a)\n(resCap_cf x1 x'a),\n                                     False)}", "apply (drule Graph.shortestPath_is_simple)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x2a x'a.\n       \\<lbrakk>\\<not> x2a; \\<not> x2; RGraph c s t x1; x'a \\<noteq> [];\n        RGraph c s t (Graph.augment_cf x1 (set x'a) (resCap_cf x1 x'a));\n        Graph.isSimplePath x1 s x'a t\\<rbrakk>\n       \\<Longrightarrow> resCap_cf_impl x1 x'a \\<bind>\n                         (\\<lambda>bn.\n                             augment_cf_impl x1 x'a bn \\<bind>\n                             (\\<lambda>cf.\n                                 assert (RGraph c s t cf) \\<bind>\n                                 (\\<lambda>_. return (cf, False))))\n                         \\<le> RES {(Graph.augment_cf x1 (set x'a)\n(resCap_cf x1 x'a),\n                                     False)}", "apply (frule (1) RGraph.resCap_cf_impl_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x2a x'a.\n       \\<lbrakk>\\<not> x2a; \\<not> x2; RGraph c s t x1; x'a \\<noteq> [];\n        RGraph c s t (Graph.augment_cf x1 (set x'a) (resCap_cf x1 x'a));\n        Graph.isSimplePath x1 s x'a t;\n        resCap_cf_impl x1 x'a \\<le> (spec r. r = resCap_cf x1 x'a)\\<rbrakk>\n       \\<Longrightarrow> resCap_cf_impl x1 x'a \\<bind>\n                         (\\<lambda>bn.\n                             augment_cf_impl x1 x'a bn \\<bind>\n                             (\\<lambda>cf.\n                                 assert (RGraph c s t cf) \\<bind>\n                                 (\\<lambda>_. return (cf, False))))\n                         \\<le> RES {(Graph.augment_cf x1 (set x'a)\n(resCap_cf x1 x'a),\n                                     False)}", "apply (frule (1) RGraph.augment_cf_impl_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x2a x'a.\n       \\<lbrakk>\\<not> x2a; \\<not> x2; RGraph c s t x1; x'a \\<noteq> [];\n        RGraph c s t (Graph.augment_cf x1 (set x'a) (resCap_cf x1 x'a));\n        Graph.isSimplePath x1 s x'a t;\n        resCap_cf_impl x1 x'a \\<le> (spec r. r = resCap_cf x1 x'a);\n        augment_cf_impl x1 x'a (?x97 x1 x2 x2a x'a)\n        \\<le> return\n               (Graph.augment_cf x1 (set x'a) (?x97 x1 x2 x2a x'a))\\<rbrakk>\n       \\<Longrightarrow> resCap_cf_impl x1 x'a \\<bind>\n                         (\\<lambda>bn.\n                             augment_cf_impl x1 x'a bn \\<bind>\n                             (\\<lambda>cf.\n                                 assert (RGraph c s t cf) \\<bind>\n                                 (\\<lambda>_. return (cf, False))))\n                         \\<le> RES {(Graph.augment_cf x1 (set x'a)\n(resCap_cf x1 x'a),\n                                     False)}", "apply (auto simp: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Refinement to use BFS\\<close>"], ["", "text \\<open>We refine the Edmonds-Karp algorithm to use breadth first search (BFS)\\<close>"], ["", "definition \"edka4 \\<equiv> do {\n      let cf = c;\n\n      (cf,_) \\<leftarrow> while\\<^sub>T \n        (\\<lambda>(cf,brk). \\<not>brk) \n        (\\<lambda>(cf,_). do {\n          assert (RGraph c s t cf);\n          p \\<leftarrow> Graph.bfs cf s t;\n          case p of \n            None \\<Rightarrow> return (cf,True)\n          | Some p \\<Rightarrow> do {\n              assert (p\\<noteq>[]);\n              assert (Graph.isShortestPath cf s p t);\n              bn \\<leftarrow> resCap_cf_impl cf p;\n              cf \\<leftarrow> augment_cf_impl cf p bn;\n              assert (RGraph c s t cf);\n              return (cf, False)\n            }  \n        })\n        (cf,False);\n      assert (RGraph c s t cf);\n      let f = flow_of_cf cf;  \n      return f\n    }\""], ["", "text \\<open>A shortest path can be obtained by BFS\\<close>"], ["", "lemma bfs_refines_shortest_augmenting_spec: \n      \"Graph.bfs cf s t \\<le> find_shortest_augmenting_spec_cf cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph.bfs cf s t \\<le> find_shortest_augmenting_spec_cf cf", "unfolding find_shortest_augmenting_spec_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph.bfs cf s t\n    \\<le> assert (RGraph c s t cf) \\<bind>\n          (\\<lambda>_.\n              spec x.\n                 case x of None \\<Rightarrow> \\<not> Graph.connected cf s t\n                 | Some p \\<Rightarrow> Graph.isShortestPath cf s p t)", "apply (rule le_ASSERTI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RGraph c s t cf \\<Longrightarrow>\n    Graph.bfs cf s t\n    \\<le> (spec x.\n              case x of None \\<Rightarrow> \\<not> Graph.connected cf s t\n              | Some p \\<Rightarrow> Graph.isShortestPath cf s p t)", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. RGraph c s t cf \\<Longrightarrow> Graph.bfs cf s t \\<le> ?y2\n 2. RGraph c s t cf \\<Longrightarrow>\n    ?y2\n    \\<le> (spec x.\n              case x of None \\<Rightarrow> \\<not> Graph.connected cf s t\n              | Some p \\<Rightarrow> Graph.isShortestPath cf s p t)", "apply (rule Graph.bfs_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. RGraph c s t cf \\<Longrightarrow> s \\<in> Graph.V cf\n 2. RGraph c s t cf \\<Longrightarrow> finite (Graph.V cf)\n 3. RGraph c s t cf \\<Longrightarrow>\n    (spec x.\n        case x of None \\<Rightarrow> \\<not> Graph.connected cf s t\n        | Some p \\<Rightarrow> Graph.isShortestPath cf s p t)\n    \\<le> (spec x.\n              case x of None \\<Rightarrow> \\<not> Graph.connected cf s t\n              | Some p \\<Rightarrow> Graph.isShortestPath cf s p t)", "apply (simp add: RPreGraph.resV_netV[OF RGraph.this_loc_rpg] s_node)"], ["proof (prove)\ngoal (2 subgoals):\n 1. RGraph c s t cf \\<Longrightarrow> finite (Graph.V cf)\n 2. RGraph c s t cf \\<Longrightarrow>\n    (spec x.\n        case x of None \\<Rightarrow> \\<not> Graph.connected cf s t\n        | Some p \\<Rightarrow> Graph.isShortestPath cf s p t)\n    \\<le> (spec x.\n              case x of None \\<Rightarrow> \\<not> Graph.connected cf s t\n              | Some p \\<Rightarrow> Graph.isShortestPath cf s p t)", "apply (simp add: RPreGraph.resV_netV[OF RGraph.this_loc_rpg])"], ["proof (prove)\ngoal (1 subgoal):\n 1. RGraph c s t cf \\<Longrightarrow>\n    (spec x.\n        case x of None \\<Rightarrow> \\<not> Graph.connected cf s t\n        | Some p \\<Rightarrow> Graph.isShortestPath cf s p t)\n    \\<le> (spec x.\n              case x of None \\<Rightarrow> \\<not> Graph.connected cf s t\n              | Some p \\<Rightarrow> Graph.isShortestPath cf s p t)", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma edka4_refine: \"edka4 \\<le> \\<Down>Id edka3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edka4 \\<le> \\<Down> Id edka3", "unfolding edka4_def edka3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let cf = c\n     in while\\<^sub>T (\\<lambda>(cf, brk). \\<not> brk)\n         (\\<lambda>(cf, uu_).\n             assert (RGraph c s t cf) \\<bind>\n             (\\<lambda>_.\n                 Graph.bfs cf s t \\<bind>\n                 (\\<lambda>p.\n                     case p of None \\<Rightarrow> return (cf, True)\n                     | Some p \\<Rightarrow>\n                         assert (p \\<noteq> []) \\<bind>\n                         (\\<lambda>_.\n                             assert (Graph.isShortestPath cf s p t) \\<bind>\n                             (\\<lambda>_.\n                                 resCap_cf_impl cf p \\<bind>\n                                 (\\<lambda>bn.\n                                     augment_cf_impl cf p bn \\<bind>\n                                     (\\<lambda>cf.\n   assert (RGraph c s t cf) \\<bind> (\\<lambda>_. return (cf, False)))))))))\n         (cf, False) \\<bind>\n        (\\<lambda>(cf, uu_).\n            assert (RGraph c s t cf) \\<bind>\n            (\\<lambda>_. Let (flow_of_cf cf) return)))\n    \\<le> \\<Down> Id\n           (let cf = c\n            in while\\<^sub>T (\\<lambda>(cf, brk). \\<not> brk)\n                (\\<lambda>(cf, uu_).\n                    assert (RGraph c s t cf) \\<bind>\n                    (\\<lambda>_.\n                        find_shortest_augmenting_spec_cf cf \\<bind>\n                        (\\<lambda>p.\n                            case p of None \\<Rightarrow> return (cf, True)\n                            | Some p \\<Rightarrow>\n                                assert (p \\<noteq> []) \\<bind>\n                                (\\<lambda>_.\n                                    assert\n                                     (Graph.isShortestPath cf s p t) \\<bind>\n                                    (\\<lambda>_.\n  resCap_cf_impl cf p \\<bind>\n  (\\<lambda>bn.\n      augment_cf_impl cf p bn \\<bind>\n      (\\<lambda>cf.\n          assert (RGraph c s t cf) \\<bind>\n          (\\<lambda>_. return (cf, False)))))))))\n                (cf, False) \\<bind>\n               (\\<lambda>(cf, uu_).\n                   assert (RGraph c s t cf) \\<bind>\n                   (\\<lambda>_. Let (flow_of_cf cf) return)))", "apply refine_rcg"], ["proof (prove)\ngoal (14 subgoals):\n 1. ((c, False), c, False) \\<in> ?R'1\n 2. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'1; x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 3. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 4. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> Graph.bfs x1a s t\n                         \\<le> \\<Down> (?R'33 x x' x1 x2 x1a x2a)\n                                (find_shortest_augmenting_spec_cf x1)\n 5. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa) \\<in> ?R'33 x x' x1 x2 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> (p, pa)\n                         \\<in> \\<langle>?Ra34 x x' x1 x2 x1a x2a p\n   pa\\<rangle>option_rel\n 6. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa) \\<in> ?R'33 x x' x1 x2 x1a x2a; p = None; pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True) \\<in> ?R'1\n 7. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa) \\<in> ?R'33 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra34 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        Graph.isShortestPath x1 s x'a t\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa) \\<in> ?R'33 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra34 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        Graph.isShortestPath x1 s x'a t; xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s xa t\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'1;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa) \\<in> ?R'33 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n        (xa, x'a) \\<in> ?Ra34 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n        Graph.isShortestPath x1 s x'a t; xa \\<noteq> [];\n        Graph.isShortestPath x1a s xa t\\<rbrakk>\n       \\<Longrightarrow> resCap_cf_impl x1a xa\n                         \\<le> \\<Down>\n                                (?R'40 x x' x1 x2 x1a x2a p pa xa x'a)\n                                (resCap_cf_impl x1 x'a)\n 10. \\<And>x x' x1 x2 x1a x2a p pa xa x'a bn bna.\n        \\<lbrakk>(x, x') \\<in> ?R'1;\n         case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n         case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n         x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n         (p, pa) \\<in> ?R'33 x x' x1 x2 x1a x2a; p = Some xa; pa = Some x'a;\n         (xa, x'a) \\<in> ?Ra34 x x' x1 x2 x1a x2a p pa; x'a \\<noteq> [];\n         Graph.isShortestPath x1 s x'a t; xa \\<noteq> [];\n         Graph.isShortestPath x1a s xa t;\n         (bn, bna) \\<in> ?R'40 x x' x1 x2 x1a x2a p pa xa x'a\\<rbrakk>\n        \\<Longrightarrow> augment_cf_impl x1a xa bn\n                          \\<le> \\<Down>\n                                 (?R'41 x x' x1 x2 x1a x2a p pa xa x'a bn\n                                   bna)\n                                 (augment_cf_impl x1 x'a bna)\nA total of 14 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (13 subgoals):\n 1. ((c, False), c, False) \\<in> Id \\<times>\\<^sub>r bool_rel\n 2. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; x = (x1, x2);\n        x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 3. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1a\n 4. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> Graph.bfs x1a s t\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n             nat_rel\\<rangle>list_rel\\<rangle>option_rel)\n                                (find_shortest_augmenting_spec_cf x1)\n 5. \\<And>x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = None; pa = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 6. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; Graph.isShortestPath x1 s x'a t\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 7. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; Graph.isShortestPath x1 s x'a t;\n        xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1a s xa t\n 8. \\<And>x x' x1 x2 x1a x2a p pa xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; Graph.isShortestPath x1 s x'a t; xa \\<noteq> [];\n        Graph.isShortestPath x1a s xa t\\<rbrakk>\n       \\<Longrightarrow> resCap_cf_impl x1a xa\n                         \\<le> \\<Down> Id (resCap_cf_impl x1 x'a)\n 9. \\<And>x x' x1 x2 x1a x2a p pa xa x'a bn bna.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n        case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n        x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n        (p, pa)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        p = Some xa; pa = Some x'a;\n        (xa, x'a)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'a \\<noteq> []; Graph.isShortestPath x1 s x'a t; xa \\<noteq> [];\n        Graph.isShortestPath x1a s xa t; (bn, bna) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> augment_cf_impl x1a xa bn\n                         \\<le> \\<Down> Id (augment_cf_impl x1 x'a bna)\n 10. \\<And>x x' x1 x2 x1a x2a p pa xa x'a bn bna cf cfa.\n        \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n         case x of (cf, brk) \\<Rightarrow> \\<not> brk;\n         case x' of (cf, brk) \\<Rightarrow> \\<not> brk; x' = (x1, x2);\n         x = (x1a, x2a); RGraph c s t x1; RGraph c s t x1a;\n         (p, pa)\n         \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                 nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n         p = Some xa; pa = Some x'a;\n         (xa, x'a)\n         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n         x'a \\<noteq> []; Graph.isShortestPath x1 s x'a t; xa \\<noteq> [];\n         Graph.isShortestPath x1a s xa t; (bn, bna) \\<in> Id;\n         (cf, cfa) \\<in> Id; RGraph c s t cfa\\<rbrakk>\n        \\<Longrightarrow> RGraph c s t cf\nA total of 13 subgoals...", "apply (vc_solve simp: bfs_refines_shortest_augmenting_spec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Implementing the Successor Function for BFS\\<close>"], ["", "text \\<open>We implement the successor function in two steps.\n      The first step shows how to obtain the successor function by\n      filtering the list of adjacent nodes. This step contains the idea   \n      of the implementation. The second step is purely technical, and makes \n      explicit the recursion of the filter function as a recursion combinator\n      in the monad. This is required for the Sepref tool.\n      \\<close>"], ["", "text \\<open>Note: We use @{term filter_rev} here, as it is tail-recursive, \n      and we are not interested in the order of successors.\\<close>"], ["", "definition \"rg_succ am cf u \\<equiv>  \n      filter_rev (\\<lambda>v. cf (u,v) > 0) (am u)\""], ["", "lemma (in RGraph) rg_succ_ref1: \"\\<lbrakk>is_adj_map am\\<rbrakk> \n      \\<Longrightarrow> (rg_succ am cf u, Graph.E cf``{u}) \\<in> \\<langle>Id\\<rangle>list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_adj_map am \\<Longrightarrow>\n    (rg_succ am cf u, cf.E `` {u})\n    \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "unfolding Graph.E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_adj_map am \\<Longrightarrow>\n    (rg_succ am cf u, {(u, v). cf (u, v) \\<noteq> (0::'a)} `` {u})\n    \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "apply (clarsimp simp: list_set_rel_def br_def rg_succ_def filter_rev_alt; \n        intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_adj_map am \\<Longrightarrow>\n    {v. cf (u, v) \\<noteq> (0::'a)} =\n    {x \\<in> set (am u). (0::'a) < cf (u, x)}\n 2. is_adj_map am \\<Longrightarrow>\n    distinct (filter (\\<lambda>v. (0::'a) < cf (u, v)) (rev (am u)))", "using cfE_ss_invE resE_nonNegative"], ["proof (prove)\nusing this:\n  cf.E \\<subseteq> E \\<union> E\\<inverse>\n  (0::'a) \\<le> cf ?e\n\ngoal (2 subgoals):\n 1. is_adj_map am \\<Longrightarrow>\n    {v. cf (u, v) \\<noteq> (0::'a)} =\n    {x \\<in> set (am u). (0::'a) < cf (u, x)}\n 2. is_adj_map am \\<Longrightarrow>\n    distinct (filter (\\<lambda>v. (0::'a) < cf (u, v)) (rev (am u)))", "apply (auto \n        simp: is_adj_map_def less_le Graph.E_def \n        simp del: cf.zero_cap_simp zero_cap_simp) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_adj_map am \\<Longrightarrow>\n    distinct (filter (\\<lambda>v. (0::'a) < cf (u, v)) (rev (am u)))", "apply (auto simp: is_adj_map_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition ps_get_op :: \"_ \\<Rightarrow> node \\<Rightarrow> node list nres\" \n      where \"ps_get_op am u \\<equiv> assert (u\\<in>V) \\<then> return (am u)\""], ["", "definition monadic_filter_rev_aux \n      :: \"'a list \\<Rightarrow> ('a \\<Rightarrow> bool nres) \\<Rightarrow> 'a list \\<Rightarrow> 'a list nres\"\n    where\n      \"monadic_filter_rev_aux a P l \\<equiv> (rec\\<^sub>T D. (\\<lambda>(l,a). case l of\n        [] \\<Rightarrow> return a \n      | (v#l) \\<Rightarrow> do {\n          c \\<leftarrow> P v;\n          let a = (if c then v#a else a);\n          D (l,a)\n        }\n      )) (l,a)\""], ["", "lemma monadic_filter_rev_aux_rule:\n      assumes \"\\<And>x. x\\<in>set l \\<Longrightarrow> P x \\<le> SPEC (\\<lambda>r. r=Q x)\"\n      shows \"monadic_filter_rev_aux a P l \\<le> SPEC (\\<lambda>r. r=filter_rev_aux a Q l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_filter_rev_aux a P l \\<le> (spec r. r = filter_rev_aux a Q l)", "using assms"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set l \\<Longrightarrow> P ?x1 \\<le> (spec r. r = Q ?x1)\n\ngoal (1 subgoal):\n 1. monadic_filter_rev_aux a P l \\<le> (spec r. r = filter_rev_aux a Q l)", "apply (induction l arbitrary: a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       (\\<And>x.\n           x \\<in> set [] \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n       monadic_filter_rev_aux a P []\n       \\<le> (spec r. r = filter_rev_aux a Q [])\n 2. \\<And>a l aa.\n       \\<lbrakk>\\<And>a.\n                   (\\<And>x.\n                       x \\<in> set l \\<Longrightarrow>\n                       P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n                   monadic_filter_rev_aux a P l\n                   \\<le> (spec r. r = filter_rev_aux a Q l);\n        \\<And>x.\n           x \\<in> set (a # l) \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)\\<rbrakk>\n       \\<Longrightarrow> monadic_filter_rev_aux aa P (a # l)\n                         \\<le> (spec r. r = filter_rev_aux aa Q (a # l))", "apply (unfold monadic_filter_rev_aux_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       (\\<And>x.\n           x \\<in> set [] \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n       (rec\\<^sub>T D.\n           (\\<lambda>(l, a).\n               case l of [] \\<Rightarrow> return a\n               | v # l \\<Rightarrow>\n                   P v \\<bind>\n                   (\\<lambda>c.\n                       let a = if c then v # a else a in D (l, a))))\n        ([], a)\n       \\<le> (spec r. r = filter_rev_aux a Q [])\n 2. \\<And>a l aa.\n       \\<lbrakk>\\<And>a.\n                   (\\<And>x.\n                       x \\<in> set l \\<Longrightarrow>\n                       P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n                   monadic_filter_rev_aux a P l\n                   \\<le> (spec r. r = filter_rev_aux a Q l);\n        \\<And>x.\n           x \\<in> set (a # l) \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)\\<rbrakk>\n       \\<Longrightarrow> monadic_filter_rev_aux aa P (a # l)\n                         \\<le> (spec r. r = filter_rev_aux aa Q (a # l))", "apply (subst RECT_unfold, refine_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       (\\<And>x.\n           x \\<in> set [] \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n       (case ([], a) of ([], a) \\<Rightarrow> return a\n        | (v # la, a) \\<Rightarrow>\n            P v \\<bind>\n            (\\<lambda>c.\n                let a = if c then v # a else a\n                in (rec\\<^sub>T D.\n                       (\\<lambda>(l, a).\n                           case l of [] \\<Rightarrow> return a\n                           | v # l \\<Rightarrow>\n                               P v \\<bind>\n                               (\\<lambda>c.\n                                   let a = if c then v # a else a\n                                   in D (l, a))))\n                    (la, a)))\n       \\<le> (spec r. r = filter_rev_aux a Q [])\n 2. \\<And>a l aa.\n       \\<lbrakk>\\<And>a.\n                   (\\<And>x.\n                       x \\<in> set l \\<Longrightarrow>\n                       P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n                   monadic_filter_rev_aux a P l\n                   \\<le> (spec r. r = filter_rev_aux a Q l);\n        \\<And>x.\n           x \\<in> set (a # l) \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)\\<rbrakk>\n       \\<Longrightarrow> monadic_filter_rev_aux aa P (a # l)\n                         \\<le> (spec r. r = filter_rev_aux aa Q (a # l))", "apply (fold monadic_filter_rev_aux_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       (\\<And>x.\n           x \\<in> set [] \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n       (case ([], a) of ([], a) \\<Rightarrow> return a\n        | (v # la, a) \\<Rightarrow>\n            P v \\<bind>\n            (\\<lambda>c.\n                let a = if c then v # a else a\n                in monadic_filter_rev_aux a P la))\n       \\<le> (spec r. r = filter_rev_aux a Q [])\n 2. \\<And>a l aa.\n       \\<lbrakk>\\<And>a.\n                   (\\<And>x.\n                       x \\<in> set l \\<Longrightarrow>\n                       P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n                   monadic_filter_rev_aux a P l\n                   \\<le> (spec r. r = filter_rev_aux a Q l);\n        \\<And>x.\n           x \\<in> set (a # l) \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)\\<rbrakk>\n       \\<Longrightarrow> monadic_filter_rev_aux aa P (a # l)\n                         \\<le> (spec r. r = filter_rev_aux aa Q (a # l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l aa.\n       \\<lbrakk>\\<And>a.\n                   (\\<And>x.\n                       x \\<in> set l \\<Longrightarrow>\n                       P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n                   monadic_filter_rev_aux a P l\n                   \\<le> (spec r. r = filter_rev_aux a Q l);\n        \\<And>x.\n           x \\<in> set (a # l) \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)\\<rbrakk>\n       \\<Longrightarrow> monadic_filter_rev_aux aa P (a # l)\n                         \\<le> (spec r. r = filter_rev_aux aa Q (a # l))", "apply (unfold monadic_filter_rev_aux_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l aa.\n       \\<lbrakk>\\<And>a.\n                   (\\<And>x.\n                       x \\<in> set l \\<Longrightarrow>\n                       P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n                   (rec\\<^sub>T D.\n                       (\\<lambda>(l, a).\n                           case l of [] \\<Rightarrow> return a\n                           | v # l \\<Rightarrow>\n                               P v \\<bind>\n                               (\\<lambda>c.\n                                   let a = if c then v # a else a\n                                   in D (l, a))))\n                    (l, a)\n                   \\<le> (spec r. r = filter_rev_aux a Q l);\n        \\<And>x.\n           x \\<in> set (a # l) \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)\\<rbrakk>\n       \\<Longrightarrow> (rec\\<^sub>T D.\n                             (\\<lambda>(l, a).\n                                 case l of [] \\<Rightarrow> return a\n                                 | v # l \\<Rightarrow>\n                                     P v \\<bind>\n                                     (\\<lambda>c.\n   let a = if c then v # a else a in D (l, a))))\n                          (a # l, aa)\n                         \\<le> (spec r. r = filter_rev_aux aa Q (a # l))", "apply (subst RECT_unfold, refine_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l aa.\n       \\<lbrakk>\\<And>a.\n                   (\\<And>x.\n                       x \\<in> set l \\<Longrightarrow>\n                       P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n                   (rec\\<^sub>T D.\n                       (\\<lambda>(l, a).\n                           case l of [] \\<Rightarrow> return a\n                           | v # l \\<Rightarrow>\n                               P v \\<bind>\n                               (\\<lambda>c.\n                                   let a = if c then v # a else a\n                                   in D (l, a))))\n                    (l, a)\n                   \\<le> (spec r. r = filter_rev_aux a Q l);\n        \\<And>x.\n           x \\<in> set (a # l) \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)\\<rbrakk>\n       \\<Longrightarrow> (case (a # l, aa) of ([], a) \\<Rightarrow> return a\n                          | (v # la, a) \\<Rightarrow>\n                              P v \\<bind>\n                              (\\<lambda>c.\n                                  let a = if c then v # a else a\n                                  in (rec\\<^sub>T D.\n   (\\<lambda>(l, a).\n       case l of [] \\<Rightarrow> return a\n       | v # l \\<Rightarrow>\n           P v \\<bind>\n           (\\<lambda>c. let a = if c then v # a else a in D (l, a))))\n(la, a)))\n                         \\<le> (spec r. r = filter_rev_aux aa Q (a # l))", "apply (fold monadic_filter_rev_aux_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l aa.\n       \\<lbrakk>\\<And>a.\n                   (\\<And>x.\n                       x \\<in> set l \\<Longrightarrow>\n                       P x \\<le> (spec r. r = Q x)) \\<Longrightarrow>\n                   monadic_filter_rev_aux a P l\n                   \\<le> (spec r. r = filter_rev_aux a Q l);\n        \\<And>x.\n           x \\<in> set (a # l) \\<Longrightarrow>\n           P x \\<le> (spec r. r = Q x)\\<rbrakk>\n       \\<Longrightarrow> (case (a # l, aa) of ([], a) \\<Rightarrow> return a\n                          | (v # la, a) \\<Rightarrow>\n                              P v \\<bind>\n                              (\\<lambda>c.\n                                  let a = if c then v # a else a\n                                  in monadic_filter_rev_aux a P la))\n                         \\<le> (spec r. r = filter_rev_aux aa Q (a # l))", "apply (auto simp: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"monadic_filter_rev = monadic_filter_rev_aux []\""], ["", "lemma monadic_filter_rev_rule:\n      assumes \"\\<And>x. x\\<in>set l \\<Longrightarrow> P x \\<le> (spec r. r=Q x)\"\n      shows \"monadic_filter_rev P l \\<le> (spec r. r=filter_rev Q l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_filter_rev P l \\<le> (spec r. r = filter_rev Q l)", "using monadic_filter_rev_aux_rule[where a=\"[]\"] assms"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set ?l \\<Longrightarrow>\n      ?P x \\<le> (spec r. r = ?Q x)) \\<Longrightarrow>\n  monadic_filter_rev_aux [] ?P ?l\n  \\<le> (spec r. r = filter_rev_aux [] ?Q ?l)\n  ?x1 \\<in> set l \\<Longrightarrow> P ?x1 \\<le> (spec r. r = Q ?x1)\n\ngoal (1 subgoal):\n 1. monadic_filter_rev P l \\<le> (spec r. r = filter_rev Q l)", "by (auto simp: monadic_filter_rev_def filter_rev_def)"], ["", "definition \"rg_succ2 am cf u \\<equiv> do {\n      l \\<leftarrow> ps_get_op am u;\n      monadic_filter_rev (\\<lambda>v. do {\n        x \\<leftarrow> cf_get cf (u,v);\n        return (x>0)\n      }) l\n    }\""], ["", "lemma (in RGraph) rg_succ_ref2: \n      assumes PS: \"is_adj_map am\" and V: \"u\\<in>V\"\n      shows \"rg_succ2 am cf u \\<le> return (rg_succ am cf u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rg_succ2 am cf u \\<le> return (rg_succ am cf u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rg_succ2 am cf u \\<le> return (rg_succ am cf u)", "have \"\\<forall>v\\<in>set (am u). valid_edge (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (am u).\n       case (u, v) of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V", "using PS V"], ["proof (prove)\nusing this:\n  is_adj_map am\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (am u).\n       case (u, v) of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V", "by (auto simp: is_adj_map_def Graph.V_def)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (am u).\n     case (u, v) of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\n\ngoal (1 subgoal):\n 1. rg_succ2 am cf u \\<le> return (rg_succ am cf u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (am u).\n     case (u, v) of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\n\ngoal (1 subgoal):\n 1. rg_succ2 am cf u \\<le> return (rg_succ am cf u)", "unfolding rg_succ2_def rg_succ_def ps_get_op_def cf_get_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set (am u).\n     case (u, v) of (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\n\ngoal (1 subgoal):\n 1. assert (u \\<in> V) \\<bind> (\\<lambda>_. return (am u)) \\<bind>\n    monadic_filter_rev\n     (\\<lambda>v.\n         assert\n          (case (u, v) of\n           (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V) \\<bind>\n         (\\<lambda>_. return (cf (u, v))) \\<bind>\n         (\\<lambda>x. return ((0::'a) < x)))\n    \\<le> return (filter_rev (\\<lambda>v. (0::'a) < cf (u, v)) (am u))", "apply (refine_vcg monadic_filter_rev_rule[\n            where Q=\"(\\<lambda>v. 0 < cf (u, v))\", THEN order_trans])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<forall>v\\<in>set (am u).\n       case (u, v) of\n       (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V \\<Longrightarrow>\n    u \\<in> V\n 2. \\<And>x x1 x2.\n       \\<lbrakk>\\<forall>v\\<in>set (am u).\n                   case (u, v) of\n                   (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        u \\<in> V; x \\<in> set (am u); (u, x) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> V\n 3. \\<And>x x1 x2.\n       \\<lbrakk>\\<forall>v\\<in>set (am u).\n                   case (u, v) of\n                   (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        u \\<in> V; x \\<in> set (am u); (u, x) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 \\<in> V\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>v\\<in>set (am u).\n                   case (u, v) of\n                   (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        u \\<in> V; x \\<in> set (am u);\n        case (u, x) of\n        (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> ((0::'a) < cf (u, x)) = ((0::'a) < cf (u, x))\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>v\\<in>set (am u).\n                   case (u, v) of\n                   (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V;\n        u \\<in> V;\n        x = filter_rev (\\<lambda>v. (0::'a) < cf (u, v)) (am u)\\<rbrakk>\n       \\<Longrightarrow> filter_rev (\\<lambda>v. (0::'a) < cf (u, v))\n                          (am u) =\n                         x", "by (vc_solve simp: V)"], ["proof (state)\nthis:\n  rg_succ2 am cf u \\<le> return (rg_succ am cf u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in RGraph) rg_succ_ref:\n      assumes A: \"is_adj_map am\"\n      assumes B: \"u\\<in>V\"\n      shows \"rg_succ2 am cf u \\<le> SPEC (\\<lambda>l. (l,cf.E``{u}) \\<in> \\<langle>Id\\<rangle>list_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rg_succ2 am cf u\n    \\<le> (spec l.\n              (l, cf.E `` {u}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel)", "using rg_succ_ref1[OF A, of u] rg_succ_ref2[OF A B]"], ["proof (prove)\nusing this:\n  (rg_succ am cf u, cf.E `` {u}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n  rg_succ2 am cf u \\<le> return (rg_succ am cf u)\n\ngoal (1 subgoal):\n 1. rg_succ2 am cf u\n    \\<le> (spec l.\n              (l, cf.E `` {u}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "subsection \\<open>Adding Tabulation of Input\\<close>"], ["", "text \\<open>\n      Next, we add functions that will be refined to tabulate the input of \n      the algorithm, i.e., the network's capacity matrix and adjacency map,\n      into efficient representations. \n      The capacity matrix is tabulated to give the initial residual graph,\n      and the adjacency map is tabulated for faster access.\n\n      Note, on the abstract level, the tabulation functions are just identity,\n      and merely serve as marker constants for implementation.\n      \\<close>"], ["", "definition init_cf :: \"'capacity graph nres\" \n      \\<comment> \\<open>Initialization of residual graph from network\\<close>\n      where \"init_cf \\<equiv> RETURN c\""], ["", "definition init_ps :: \"(node \\<Rightarrow> node list) \\<Rightarrow> _\" \n      \\<comment> \\<open>Initialization of adjacency map\\<close>\n      where \"init_ps am \\<equiv> ASSERT (is_adj_map am) \\<then> RETURN am\""], ["", "definition compute_rflow :: \"'capacity graph \\<Rightarrow> 'capacity flow nres\" \n      \\<comment> \\<open>Extraction of result flow from residual graph\\<close>\n      where\n      \"compute_rflow cf \\<equiv> ASSERT (RGraph c s t cf) \\<then> RETURN (flow_of_cf cf)\""], ["", "definition \"bfs2_op am cf \\<equiv> Graph.bfs2 cf (rg_succ2 am cf) s t\""], ["", "text \\<open>We split the algorithm into a tabulation function, and the \n      running of the actual algorithm:\\<close>"], ["", "definition \"edka5_tabulate am \\<equiv> do {\n      cf \\<leftarrow> init_cf;\n      am \\<leftarrow> init_ps am;\n      return (cf,am)\n    }\""], ["", "definition \"edka5_run cf am \\<equiv> do {\n      (cf,_) \\<leftarrow> while\\<^sub>T \n        (\\<lambda>(cf,brk). \\<not>brk) \n        (\\<lambda>(cf,_). do {\n          assert (RGraph c s t cf);\n          p \\<leftarrow> bfs2_op am cf;\n          case p of \n            None \\<Rightarrow> return (cf,True)\n          | Some p \\<Rightarrow> do {\n              assert (p\\<noteq>[]);\n              assert (Graph.isShortestPath cf s p t);\n              bn \\<leftarrow> resCap_cf_impl cf p;\n              cf \\<leftarrow> augment_cf_impl cf p bn;\n              assert (RGraph c s t cf);\n              return (cf, False)\n            }  \n        })\n        (cf,False);\n      f \\<leftarrow> compute_rflow cf;  \n      return f\n    }\""], ["", "definition \"edka5 am \\<equiv> do {\n      (cf,am) \\<leftarrow> edka5_tabulate am;\n      edka5_run cf am\n    }\""], ["", "lemma edka5_refine: \"\\<lbrakk>is_adj_map am\\<rbrakk> \\<Longrightarrow> edka5 am \\<le> \\<Down>Id edka4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_adj_map am \\<Longrightarrow> edka5 am \\<le> \\<Down> Id edka4", "unfolding edka5_def edka5_tabulate_def edka5_run_def\n        edka4_def init_cf_def compute_rflow_def\n        init_ps_def Let_def nres_monad_laws bfs2_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_adj_map am \\<Longrightarrow>\n    assert (is_adj_map am) \\<bind>\n    (\\<lambda>x.\n        case (c, am) of\n        (cf, am) \\<Rightarrow>\n          while\\<^sub>T (\\<lambda>(cf, y). \\<not> y)\n           (\\<lambda>(cf, uu_).\n               assert (RGraph c s t cf) \\<bind>\n               (\\<lambda>_.\n                   Graph.bfs2 cf (rg_succ2 am cf) s t \\<bind>\n                   case_option (return (cf, True))\n                    (\\<lambda>p.\n                        assert (p \\<noteq> []) \\<bind>\n                        (\\<lambda>_.\n                            assert (Graph.isShortestPath cf s p t) \\<bind>\n                            (\\<lambda>_.\n                                resCap_cf_impl cf p \\<bind>\n                                (\\<lambda>bn.\n                                    augment_cf_impl cf p bn \\<bind>\n                                    (\\<lambda>cf.\n  assert (RGraph c s t cf) \\<bind> (\\<lambda>_. return (cf, False)))))))))\n           (cf, False) \\<bind>\n          (\\<lambda>(cf, uu_).\n              assert (RGraph c s t cf) \\<bind>\n              (\\<lambda>_. return (flow_of_cf cf))))\n    \\<le> \\<Down> Id\n           (while\\<^sub>T (\\<lambda>(cf, y). \\<not> y)\n             (\\<lambda>(cf, uu_).\n                 assert (RGraph c s t cf) \\<bind>\n                 (\\<lambda>_.\n                     Graph.bfs cf s t \\<bind>\n                     case_option (return (cf, True))\n                      (\\<lambda>p.\n                          assert (p \\<noteq> []) \\<bind>\n                          (\\<lambda>_.\n                              assert (Graph.isShortestPath cf s p t) \\<bind>\n                              (\\<lambda>_.\n                                  resCap_cf_impl cf p \\<bind>\n                                  (\\<lambda>bn.\naugment_cf_impl cf p bn \\<bind>\n(\\<lambda>cf.\n    assert (RGraph c s t cf) \\<bind> (\\<lambda>_. return (cf, False)))))))))\n             (c, False) \\<bind>\n            (\\<lambda>(cf, uu_).\n                assert (RGraph c s t cf) \\<bind>\n                (\\<lambda>_. return (flow_of_cf cf))))", "apply refine_rcg"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> ((x1, False), c, False) \\<in> ?R'8 x1 x2\n 2. \\<And>x1 x2 x x' x1a x2a x1b x2b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> ?R'8 x1 x2; x = (x1a, x2a); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2a) = (\\<not> x2b)\n 3. \\<And>x1 x2 x x' x1a x2a x1b x2b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> ?R'8 x1 x2; case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1b\n 4. \\<And>x1 x2 x x' x1a x2a x1b x2b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> ?R'8 x1 x2; case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b\\<rbrakk>\n       \\<Longrightarrow> Graph.bfs2 x1b (rg_succ2 x2 x1b) s t\n                         \\<le> \\<Down> (?R'40 x1 x2 x x' x1a x2a x1b x2b)\n                                (Graph.bfs x1a s t)\n 5. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> ?R'8 x1 x2; case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n        (xa, x'a) \\<in> ?R'40 x1 x2 x x' x1a x2a x1b x2b\\<rbrakk>\n       \\<Longrightarrow> (xa, x'a)\n                         \\<in> \\<langle>?Ra41 x1 x2 x x' x1a x2a x1b x2b xa\n   x'a\\<rangle>option_rel\n 6. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> ?R'8 x1 x2; case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n        (xa, x'a) \\<in> ?R'40 x1 x2 x x' x1a x2a x1b x2b; xa = None;\n        x'a = None\\<rbrakk>\n       \\<Longrightarrow> ((x1b, True), x1a, True) \\<in> ?R'8 x1 x2\n 7. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a xb x'b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> ?R'8 x1 x2; case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n        (xa, x'a) \\<in> ?R'40 x1 x2 x x' x1a x2a x1b x2b; xa = Some xb;\n        x'a = Some x'b;\n        (xb, x'b) \\<in> ?Ra41 x1 x2 x x' x1a x2a x1b x2b xa x'a;\n        x'b \\<noteq> []; Graph.isShortestPath x1a s x'b t\\<rbrakk>\n       \\<Longrightarrow> xb \\<noteq> []\n 8. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a xb x'b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> ?R'8 x1 x2; case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n        (xa, x'a) \\<in> ?R'40 x1 x2 x x' x1a x2a x1b x2b; xa = Some xb;\n        x'a = Some x'b;\n        (xb, x'b) \\<in> ?Ra41 x1 x2 x x' x1a x2a x1b x2b xa x'a;\n        x'b \\<noteq> []; Graph.isShortestPath x1a s x'b t;\n        xb \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1b s xb t\n 9. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a xb x'b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> ?R'8 x1 x2; case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n        (xa, x'a) \\<in> ?R'40 x1 x2 x x' x1a x2a x1b x2b; xa = Some xb;\n        x'a = Some x'b;\n        (xb, x'b) \\<in> ?Ra41 x1 x2 x x' x1a x2a x1b x2b xa x'a;\n        x'b \\<noteq> []; Graph.isShortestPath x1a s x'b t; xb \\<noteq> [];\n        Graph.isShortestPath x1b s xb t\\<rbrakk>\n       \\<Longrightarrow> resCap_cf_impl x1b xb\n                         \\<le> \\<Down>\n                                (?R'47 x1 x2 x x' x1a x2a x1b x2b xa x'a xb\n                                  x'b)\n                                (resCap_cf_impl x1a x'b)\n 10. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a xb x'b bn bna.\n        \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n         (x, x') \\<in> ?R'8 x1 x2; case x of (cf, x) \\<Rightarrow> \\<not> x;\n         case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n         x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n         (xa, x'a) \\<in> ?R'40 x1 x2 x x' x1a x2a x1b x2b; xa = Some xb;\n         x'a = Some x'b;\n         (xb, x'b) \\<in> ?Ra41 x1 x2 x x' x1a x2a x1b x2b xa x'a;\n         x'b \\<noteq> []; Graph.isShortestPath x1a s x'b t; xb \\<noteq> [];\n         Graph.isShortestPath x1b s xb t;\n         (bn, bna)\n         \\<in> ?R'47 x1 x2 x x' x1a x2a x1b x2b xa x'a xb x'b\\<rbrakk>\n        \\<Longrightarrow> augment_cf_impl x1b xb bn\n                          \\<le> \\<Down>\n                                 (?R'48 x1 x2 x x' x1a x2a x1b x2b xa x'a xb\n                                   x'b bn bna)\n                                 (augment_cf_impl x1a x'b bna)\nA total of 14 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> ((x1, False), c, False)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 2. \\<And>x1 x2 x x' x1a x2a x1b x2b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; x = (x1a, x2a);\n        x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2a) = (\\<not> x2b)\n 3. \\<And>x1 x2 x x' x1a x2a x1b x2b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> RGraph c s t x1b\n 4. \\<And>x1 x2 x x' x1a x2a x1b x2b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b\\<rbrakk>\n       \\<Longrightarrow> Graph.bfs2 x1b (rg_succ2 x2 x1b) s t\n                         \\<le> \\<Down>\n                                (\\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n             nat_rel\\<rangle>list_rel\\<rangle>option_rel)\n                                (Graph.bfs x1a s t)\n 5. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n        (xa, x'a)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        xa = None; x'a = None\\<rbrakk>\n       \\<Longrightarrow> ((x1b, True), x1a, True)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 6. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a xb x'b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n        (xa, x'a)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        xa = Some xb; x'a = Some x'b;\n        (xb, x'b)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'b \\<noteq> []; Graph.isShortestPath x1a s x'b t\\<rbrakk>\n       \\<Longrightarrow> xb \\<noteq> []\n 7. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a xb x'b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n        (xa, x'a)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        xa = Some xb; x'a = Some x'b;\n        (xb, x'b)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'b \\<noteq> []; Graph.isShortestPath x1a s x'b t;\n        xb \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Graph.isShortestPath x1b s xb t\n 8. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a xb x'b.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n        (xa, x'a)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        xa = Some xb; x'a = Some x'b;\n        (xb, x'b)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'b \\<noteq> []; Graph.isShortestPath x1a s x'b t; xb \\<noteq> [];\n        Graph.isShortestPath x1b s xb t\\<rbrakk>\n       \\<Longrightarrow> resCap_cf_impl x1b xb\n                         \\<le> \\<Down> Id (resCap_cf_impl x1a x'b)\n 9. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a xb x'b bn bna.\n       \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n        (x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (cf, x) \\<Rightarrow> \\<not> x;\n        case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n        x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n        (xa, x'a)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        xa = Some xb; x'a = Some x'b;\n        (xb, x'b)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'b \\<noteq> []; Graph.isShortestPath x1a s x'b t; xb \\<noteq> [];\n        Graph.isShortestPath x1b s xb t; (bn, bna) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> augment_cf_impl x1b xb bn\n                         \\<le> \\<Down> Id (augment_cf_impl x1a x'b bna)\n 10. \\<And>x1 x2 x x' x1a x2a x1b x2b xa x'a xb x'b bn bna cf cfa.\n        \\<lbrakk>is_adj_map am; is_adj_map am; (c, am) = (x1, x2);\n         (x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n         case x of (cf, x) \\<Rightarrow> \\<not> x;\n         case x' of (cf, x) \\<Rightarrow> \\<not> x; x' = (x1a, x2a);\n         x = (x1b, x2b); RGraph c s t x1a; RGraph c s t x1b;\n         (xa, x'a)\n         \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                 nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n         xa = Some xb; x'a = Some x'b;\n         (xb, x'b)\n         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n         x'b \\<noteq> []; Graph.isShortestPath x1a s x'b t; xb \\<noteq> [];\n         Graph.isShortestPath x1b s xb t; (bn, bna) \\<in> Id;\n         (cf, cfa) \\<in> Id; RGraph c s t cfa\\<rbrakk>\n        \\<Longrightarrow> RGraph c s t cf\nA total of 13 subgoals...", "apply (vc_solve simp: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x2b.\n       \\<lbrakk>is_adj_map am; \\<not> x2b; \\<not> x2a;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> Graph.bfs2 x1a (rg_succ2 am x1a) s t\n                         \\<le> Graph.bfs x1a s t", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x2b.\n       \\<lbrakk>is_adj_map am; \\<not> x2b; \\<not> x2a;\n        RGraph c s t x1a\\<rbrakk>\n       \\<Longrightarrow> Graph.bfs2 x1a (rg_succ2 am x1a) s t\n                         \\<le> \\<Down> Id (Graph.bfs x1a s t)", "apply (rule Graph.bfs2_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x2b ui u.\n       \\<lbrakk>is_adj_map am; \\<not> x2b; \\<not> x2a; RGraph c s t x1a;\n        (ui, u) \\<in> nat_rel; u \\<in> Graph.V x1a\\<rbrakk>\n       \\<Longrightarrow> rg_succ2 am x1a ui\n                         \\<le> (spec l.\n                                   (l, Graph.E x1a `` {u})\n                                   \\<in> \\<langle>nat_rel\\<rangle>list_set_rel)", "apply (simp add: RPreGraph.resV_netV[OF RGraph.this_loc_rpg])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x2b ui u.\n       \\<lbrakk>is_adj_map am; \\<not> x2b; \\<not> x2a; RGraph c s t x1a;\n        ui = u; u \\<in> V\\<rbrakk>\n       \\<Longrightarrow> rg_succ2 am x1a u\n                         \\<le> (spec l.\n                                   (l, Graph.E x1a `` {u})\n                                   \\<in> \\<langle>nat_rel\\<rangle>list_set_rel)", "apply (simp add: RGraph.rg_succ_ref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Imperative Implementation\\<close>"], ["", "text \\<open>In this section we provide an efficient imperative implementation,\n    using the Sepref tool. It is mostly technical, setting up the mappings\n    from abstract to concrete data structures, and then refining the algorithm,\n    function by function.  \n    \\<close>"], ["", "text \\<open>\n    This is also the point where we have to choose the implementation of \n    capacities. Up to here, they have been a polymorphic type with a\n    typeclass constraint of being a linearly ordered integral domain.\n    Here, we switch to @{typ [source] capacity_impl} (@{typ capacity_impl}).\n    \\<close>"], ["", "locale Network_Impl = Network c s t for c :: \"capacity_impl graph\" and s t"], ["", "text \\<open>Moreover, we assume that the nodes are natural numbers less \n    than some number @{term N}, which will become an additional parameter \n    of our algorithm. \\<close>"], ["", "locale Edka_Impl = Network_Impl +\n    fixes N :: nat\n    assumes V_ss: \"V\\<subseteq>{0..<N}\"\n  begin"], ["", "lemma this_loc: \"Edka_Impl c s t N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Edka_Impl c s t N", "by unfold_locales"], ["", "lemma E_ss: \"E \\<subseteq> {0..<N}\\<times>{0..<N}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<subseteq> {0..<N} \\<times> {0..<N}", "using E_ss_VxV V_ss"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n  V \\<subseteq> {0..<N}\n\ngoal (1 subgoal):\n 1. E \\<subseteq> {0..<N} \\<times> {0..<N}", "by auto"], ["", "lemma mtx_nonzero_iff[simp]: \"mtx_nonzero c = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_nonzero c = E", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_nonzero c = {(u, v). c (u, v) \\<noteq> 0}", "by (auto simp: mtx_nonzero_def)"], ["", "lemma mtx_nonzeroN: \"mtx_nonzero c \\<subseteq> {0..<N}\\<times>{0..<N}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_nonzero c \\<subseteq> {0..<N} \\<times> {0..<N}", "using E_ss"], ["proof (prove)\nusing this:\n  E \\<subseteq> {0..<N} \\<times> {0..<N}\n\ngoal (1 subgoal):\n 1. mtx_nonzero c \\<subseteq> {0..<N} \\<times> {0..<N}", "by simp"], ["", "lemma [simp]: \"v\\<in>V \\<Longrightarrow> v<N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V \\<Longrightarrow> v < N", "using V_ss"], ["proof (prove)\nusing this:\n  V \\<subseteq> {0..<N}\n\ngoal (1 subgoal):\n 1. v \\<in> V \\<Longrightarrow> v < N", "by auto"], ["", "text \\<open>Declare some variables to Sepref. \\<close>"], ["", "lemmas [id_rules] = \n      itypeI[Pure.of N \"TYPE(nat)\"]  \n      itypeI[Pure.of s \"TYPE(node)\"]  \n      itypeI[Pure.of t \"TYPE(node)\"]  \n      itypeI[Pure.of c \"TYPE(capacity_impl graph)\"]"], ["", "text \\<open>Instruct Sepref to not refine these parameters. This is expressed\n      by using identity as refinement relation.\\<close>"], ["", "lemmas [sepref_import_param] = \n      IdI[of N]\n      IdI[of s]\n      IdI[of t]"], ["", "(*IdI[of c]*)"], ["", "lemma [sepref_fr_rules]: \"(uncurry0 (return c),uncurry0 (return c))\\<in>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure (nat_rel\\<times>\\<^sub>rnat_rel \\<rightarrow> int_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return c), uncurry0 (return c))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure\n             (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> int_rel)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit); nofail (return c)\\<rbrakk>\n       \\<Longrightarrow> <emp> return\n                                c <\\<lambda>r.\nemp *\n(\\<exists>\\<^sub>Ax.\n    \\<up>\n     ((r, x) \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> int_rel) *\n    \\<up> (return x \\<le> return c))>\\<^sub>t", "by sep_auto"], ["", "subsubsection \\<open>Implementation of Adjacency Map by Array\\<close>"], ["", "definition \"is_am am psi \n      \\<equiv> \\<exists>\\<^sub>Al. psi \\<mapsto>\\<^sub>a l \n          * \\<up>(length l = N \\<and> (\\<forall>i<N. l!i = am i) \n              \\<and> (\\<forall>i\\<ge>N. am i = []))\""], ["", "lemma is_am_precise[safe_constraint_rules]: \"precise (is_am)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_am", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_am a p * F \\<and>\\<^sub>A is_am a' p * F' \\<Longrightarrow>\n       a = a'", "unfolding is_am_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l *\n           \\<up>\n            (length l = N \\<and>\n             (\\<forall>i<N. l ! i = a i) \\<and>\n             (\\<forall>i\\<ge>N. a i = []))) *\n       F \\<and>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l *\n           \\<up>\n            (length l = N \\<and>\n             (\\<forall>i<N. l ! i = a' i) \\<and>\n             (\\<forall>i\\<ge>N. a' i = []))) *\n       F' \\<Longrightarrow>\n       a = a'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l la.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a la * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        N = length la; \\<forall>i<length la. la ! i = a i;\n        \\<forall>i\\<ge>length la. a i = []; length l = length la;\n        \\<forall>i<length la. l ! i = a' i;\n        \\<forall>i\\<ge>length la. a' i = []\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply (rename_tac l l')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l l'.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a l' * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        N = length l'; \\<forall>i<length l'. l' ! i = a i;\n        \\<forall>i\\<ge>length l'. a i = []; length l = length l';\n        \\<forall>i<length l'. l ! i = a' i;\n        \\<forall>i\\<ge>length l'. a' i = []\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply prec_extract_eqs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l l'.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a l' * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        N = length l'; \\<forall>i<length l'. l' ! i = a i;\n        \\<forall>i\\<ge>length l'. a i = []; length l = length l';\n        \\<forall>i<length l'. l ! i = a' i;\n        \\<forall>i\\<ge>length l'. a' i = []; l' = l\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l l' x.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a l' * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        N = length l'; \\<forall>i<length l'. l' ! i = a i;\n        \\<forall>i\\<ge>length l'. a i = []; length l = length l';\n        \\<forall>i<length l'. l ! i = a' i;\n        \\<forall>i\\<ge>length l'. a' i = []; l' = l\\<rbrakk>\n       \\<Longrightarrow> a x = a' x", "apply (rename_tac i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l l' i.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a l' * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        N = length l'; \\<forall>i<length l'. l' ! i = a i;\n        \\<forall>i\\<ge>length l'. a i = []; length l = length l';\n        \\<forall>i<length l'. l ! i = a' i;\n        \\<forall>i\\<ge>length l'. a' i = []; l' = l\\<rbrakk>\n       \\<Longrightarrow> a i = a' i", "apply (case_tac \"i<length l'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa b p F F' l l' i.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a l' * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        N = length l'; \\<forall>i<length l'. l' ! i = a i;\n        \\<forall>i\\<ge>length l'. a i = []; length l = length l';\n        \\<forall>i<length l'. l ! i = a' i;\n        \\<forall>i\\<ge>length l'. a' i = []; l' = l; i < length l'\\<rbrakk>\n       \\<Longrightarrow> a i = a' i\n 2. \\<And>a a' aa b p F F' l l' i.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a l' * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        N = length l'; \\<forall>i<length l'. l' ! i = a i;\n        \\<forall>i\\<ge>length l'. a i = []; length l = length l';\n        \\<forall>i<length l'. l ! i = a' i;\n        \\<forall>i\\<ge>length l'. a' i = []; l' = l;\n        \\<not> i < length l'\\<rbrakk>\n       \\<Longrightarrow> a i = a' i", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_intf i_ps is \"nat \\<Rightarrow> nat list\""], ["", "definition (in -) \"ps_get_imp psi u \\<equiv> Array.nth psi u\""], ["", "lemma [def_pat_rules]: \"Network.ps_get_op$c \\<equiv> UNPROTECT ps_get_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.ps_get_op $ c \\<equiv> UNPROTECT ps_get_op", "by simp"], ["", "sepref_register \"PR_CONST ps_get_op\" :: \"i_ps \\<Rightarrow> node \\<Rightarrow> node list nres\""], ["", "lemma ps_get_op_refine[sepref_fr_rules]: \n      \"(uncurry ps_get_imp, uncurry (PR_CONST ps_get_op)) \n        \\<in> is_am\\<^sup>k *\\<^sub>a (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn (pure Id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ps_get_imp, uncurry (PR_CONST ps_get_op))\n    \\<in> is_am\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn nat_assn", "unfolding list_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ps_get_imp, uncurry (PR_CONST ps_get_op))\n    \\<in> is_am\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure\n            (\\<langle>nat_rel\\<rangle>list_rel)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST ps_get_op a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_am a\n                           ai> ps_get_imp ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * is_am a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> \\<langle>nat_rel\\<rangle>list_rel) *\n     \\<up> (return x \\<le> PR_CONST ps_get_op a b))>\\<^sub>t", "using V_ss"], ["proof (prove)\nusing this:\n  V \\<subseteq> {0..<N}\n\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST ps_get_op a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_am a\n                           ai> ps_get_imp ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * is_am a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> \\<langle>nat_rel\\<rangle>list_rel) *\n     \\<up> (return x \\<le> PR_CONST ps_get_op a b))>\\<^sub>t", "by (sep_auto \n            simp: is_am_def pure_def ps_get_imp_def \n            simp: ps_get_op_def refine_pw_simps)"], ["", "lemma is_pred_succ_no_node: \"\\<lbrakk>is_adj_map a; u\\<notin>V\\<rbrakk> \\<Longrightarrow> a u = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_adj_map a; u \\<notin> V\\<rbrakk> \\<Longrightarrow> a u = []", "unfolding is_adj_map_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u.\n                distinct (a u) \\<and>\n                set (a u) = E `` {u} \\<union> E\\<inverse> `` {u};\n     u \\<notin> {u. \\<exists>v.\n                       (u, v) \\<in> E \\<or> (v, u) \\<in> E}\\<rbrakk>\n    \\<Longrightarrow> a u = []", "by auto"], ["", "lemma [sepref_fr_rules]: \"(Array.make N, PR_CONST init_ps) \n      \\<in> (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a is_am\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Array.make N, PR_CONST init_ps)\n    \\<in> id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_am", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        nofail (PR_CONST init_ps x)\\<rbrakk>\n       \\<Longrightarrow> <\\<up>\n                           ((xi, x)\n                            \\<in> Id)> Array.make N\n  xi <\\<lambda>r.\n         \\<up> ((xi, x) \\<in> Id) *\n         (\\<exists>\\<^sub>Axa.\n             is_am xa r *\n             \\<up> (return xa \\<le> PR_CONST init_ps x))>\\<^sub>t", "using V_ss"], ["proof (prove)\nusing this:\n  V \\<subseteq> {0..<N}\n\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        nofail (PR_CONST init_ps x)\\<rbrakk>\n       \\<Longrightarrow> <\\<up>\n                           ((xi, x)\n                            \\<in> Id)> Array.make N\n  xi <\\<lambda>r.\n         \\<up> ((xi, x) \\<in> Id) *\n         (\\<exists>\\<^sub>Axa.\n             is_am xa r *\n             \\<up> (return xa \\<le> PR_CONST init_ps x))>\\<^sub>t", "by (sep_auto simp: init_ps_def refine_pw_simps is_am_def pure_def\n        intro: is_pred_succ_no_node)"], ["", "lemma [def_pat_rules]: \"Network.init_ps$c \\<equiv> UNPROTECT init_ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.init_ps $ c \\<equiv> UNPROTECT init_ps", "by simp"], ["", "sepref_register \"PR_CONST init_ps\" :: \"(node \\<Rightarrow> node list) \\<Rightarrow> i_ps nres\""], ["", "subsubsection \\<open>Implementation of Capacity Matrix by Array\\<close>"], ["", "lemma [def_pat_rules]: \"Network.cf_get$c \\<equiv> UNPROTECT cf_get\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.cf_get $ c \\<equiv> UNPROTECT cf_get", "by simp"], ["", "lemma [def_pat_rules]: \"Network.cf_set$c \\<equiv> UNPROTECT cf_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.cf_set $ c \\<equiv> UNPROTECT cf_set", "by simp"], ["", "sepref_register \n      \"PR_CONST cf_get\" :: \"capacity_impl i_mtx \\<Rightarrow> edge \\<Rightarrow> capacity_impl nres\""], ["", "sepref_register \n      \"PR_CONST cf_set\" :: \"capacity_impl i_mtx \\<Rightarrow> edge \\<Rightarrow> capacity_impl \n        \\<Rightarrow> capacity_impl i_mtx nres\""], ["", "text \\<open>We have to link the matrix implementation, which encodes the bound, \n      to the abstract assertion of the bound\\<close>"], ["", "sepref_definition cf_get_impl is \"uncurry (PR_CONST cf_get)\" :: \"(asmtx_assn N id_assn)\\<^sup>k *\\<^sub>a (prod_assn id_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST cf_get))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n          (nat_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a int_assn", "unfolding PR_CONST_def cf_get_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>cf e.\n          assert\n           (case e of\n            (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V) \\<bind>\n          (\\<lambda>_. return (cf e))))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n          (nat_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a int_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = cf_get_impl.refine"], ["", "lemmas [sepref_opt_simps] = cf_get_impl_def"], ["", "sepref_definition cf_set_impl is \"uncurry2 (PR_CONST cf_set)\" :: \"(asmtx_assn N id_assn)\\<^sup>d *\\<^sub>a (prod_assn id_assn id_assn)\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 (PR_CONST cf_set))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a\n          (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n          int_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "unfolding PR_CONST_def cf_set_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>cf e cap.\n          assert\n           (case e of\n            (u, v) \\<Rightarrow> u \\<in> V \\<and> v \\<in> V) \\<bind>\n          (\\<lambda>_. return (cf(e := cap)))))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a\n          (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n          int_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = cf_set_impl.refine"], ["", "lemmas [sepref_opt_simps] = cf_set_impl_def"], ["", "sepref_thm init_cf_impl is \"uncurry0 (PR_CONST init_cf)\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (PR_CONST init_cf))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "unfolding PR_CONST_def init_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (return c))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "using E_ss"], ["proof (prove)\nusing this:\n  E \\<subseteq> {0..<N} \\<times> {0..<N}\n\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (return c))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "apply (rewrite op_mtx_new_def[of c, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<subseteq> {0..<N} \\<times> {0..<N} \\<Longrightarrow>\n    (uncurry0 ?f2, uncurry0 (return (op_mtx_new c)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "apply (rewrite amtx_fold_custom_new[of N N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<subseteq> {0..<N} \\<times> {0..<N} \\<Longrightarrow>\n    (uncurry0 ?f2, uncurry0 (return (op_amtx_new N N c)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "by sepref"], ["", "concrete_definition (in -) init_cf_impl uses Edka_Impl.init_cf_impl.refine_raw is \"(uncurry0 ?f,_)\\<in>_\""], ["", "prepare_code_thms (in -) init_cf_impl_def"], ["", "lemmas [sepref_fr_rules] = init_cf_impl.refine[OF this_loc]"], ["", "(* TODO: Use sepref to synthesize the get-operations! *)"], ["", "lemma amtx_cnv: \"amtx_assn N M id_assn = IICF_Array_Matrix.is_amtx N M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. amtx_assn N M id_assn = IICF_Array_Matrix.is_amtx N M", "by (simp add: amtx_assn_def)"], ["", "(*\n\n    lemma init_cf_imp_refine[sepref_fr_rules]: \n      \"(uncurry0 (mtx_new N c), uncurry0 (PR_CONST init_cf)) \n        \\<in> (pure unit_rel)\\<^sup>k \\<rightarrow>\\<^sub>a (asmtx_assn N id_assn)\"\n      unfolding asmtx_cnv\n      apply sepref_to_hoare\n      using E_ss\n      by (sep_auto simp: init_cf_def)\n    *)"], ["", "lemma [def_pat_rules]: \"Network.init_cf$c \\<equiv> UNPROTECT init_cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.init_cf $ c \\<equiv> UNPROTECT init_cf", "by simp"], ["", "sepref_register \"PR_CONST init_cf\" :: \"capacity_impl i_mtx nres\""], ["", "subsubsection \\<open>Representing Result Flow as Residual Graph\\<close>"], ["", "definition (in Network_Impl) \"is_rflow N f cfi \n      \\<equiv> \\<exists>\\<^sub>Acf. asmtx_assn N id_assn cf cfi * \\<up>(RGraph c s t cf \\<and> f = flow_of_cf cf)\""], ["", "lemma is_rflow_precise[safe_constraint_rules]: \"precise (is_rflow N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (is_rflow N)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_rflow N a p * F \\<and>\\<^sub>A\n       is_rflow N a' p * F' \\<Longrightarrow>\n       a = a'", "unfolding is_rflow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       (\\<exists>\\<^sub>Acf.\n           asmtx_assn N int_assn cf p *\n           \\<up> (RGraph c s t cf \\<and> a = flow_of_cf cf)) *\n       F \\<and>\\<^sub>A\n       (\\<exists>\\<^sub>Acf.\n           asmtx_assn N int_assn cf p *\n           \\<up> (RGraph c s t cf \\<and> a' = flow_of_cf cf)) *\n       F' \\<Longrightarrow>\n       a = a'", "apply (clarsimp simp: amtx_assn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b p F F' cf cfa.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                IICF_Array_Matrix.is_amtx N N cfa p * F \\<and>\\<^sub>A\n                IICF_Array_Matrix.is_amtx N N cf p * F';\n        RGraph c s t cfa; RGraph c s t cf\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf cfa = flow_of_cf cf", "apply prec_extract_eqs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b p F F' cf cfa.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                IICF_Array_Matrix.is_amtx N N cfa p * F \\<and>\\<^sub>A\n                IICF_Array_Matrix.is_amtx N N cf p * F';\n        RGraph c s t cfa; RGraph c s t cf; cfa = cf\\<rbrakk>\n       \\<Longrightarrow> flow_of_cf cfa = flow_of_cf cf", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_intf i_rflow is \"nat\\<times>nat \\<Rightarrow> int\""], ["", "lemma [sepref_fr_rules]: \n      \"(\\<lambda>cfi. return cfi, PR_CONST compute_rflow) \\<in> (asmtx_assn N id_assn)\\<^sup>d \\<rightarrow>\\<^sub>a is_rflow N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return, PR_CONST compute_rflow)\n    \\<in> (asmtx_assn N int_assn)\\<^sup>d \\<rightarrow>\\<^sub>a is_rflow N", "unfolding amtx_cnv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (return, PR_CONST compute_rflow)\n    \\<in> (IICF_Array_Matrix.is_amtx N\n            N)\\<^sup>d \\<rightarrow>\\<^sub>a is_rflow N", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat \\<times> nat \\<Rightarrow> int);\n        nofail (PR_CONST compute_rflow x)\\<rbrakk>\n       \\<Longrightarrow> <IICF_Array_Matrix.is_amtx N N x\n                           xi> return\n                                xi <\\<lambda>r.\n true *\n (\\<exists>\\<^sub>Axa.\n     is_rflow N xa r *\n     \\<up> (return xa \\<le> PR_CONST compute_rflow x))>\\<^sub>t", "apply (sep_auto simp: amtx_cnv compute_rflow_def is_rflow_def refine_pw_simps hn_ctxt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [def_pat_rules]: \n      \"Network.compute_rflow$c$s$t \\<equiv> UNPROTECT compute_rflow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.compute_rflow $ c $ s $ t \\<equiv> UNPROTECT compute_rflow", "by simp"], ["", "sepref_register \n      \"PR_CONST compute_rflow\" :: \"capacity_impl i_mtx \\<Rightarrow> i_rflow nres\""], ["", "subsubsection \\<open>Implementation of Functions\\<close>"], ["", "schematic_goal rg_succ2_impl:\n      fixes am :: \"node \\<Rightarrow> node list\" and cf :: \"capacity_impl graph\"\n      notes [id_rules] = \n        itypeI[Pure.of u \"TYPE(node)\"]\n        itypeI[Pure.of am \"TYPE(i_ps)\"]\n        itypeI[Pure.of cf \"TYPE(capacity_impl i_mtx)\"]\n      notes [sepref_import_param] = IdI[of N]\n      notes [sepref_fr_rules] = HOL_list_empty_hnr\n      shows \"hn_refine (hn_ctxt is_am am psi * hn_ctxt (asmtx_assn N id_assn) cf cfi * hn_val nat_rel u ui) (?c::?'c Heap) ?\\<Gamma> ?R (rg_succ2 am cf u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt is_am am psi * hn_ctxt (asmtx_assn N int_assn) cf cfi *\n      hn_val nat_rel u ui)\n     ?c ?\\<Gamma> ?R (rg_succ2 am cf u)", "unfolding rg_succ2_def APP_def monadic_filter_rev_def monadic_filter_rev_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt is_am am psi * hn_ctxt (asmtx_assn N int_assn) cf cfi *\n      hn_val nat_rel u ui)\n     ?c ?\\<Gamma> ?R\n     (ps_get_op am u \\<bind>\n      (\\<lambda>l.\n          (rec\\<^sub>T D.\n              (\\<lambda>(l, a).\n                  case l of [] \\<Rightarrow> return a\n                  | v # l \\<Rightarrow>\n                      cf_get cf (u, v) \\<bind>\n                      (\\<lambda>x. return (0 < x)) \\<bind>\n                      (\\<lambda>c.\n                          let a = if c then v # a else a in D (l, a))))\n           (l, [])))", "(* TODO: Make setting up combinators for sepref simpler, then we do not need to unfold! *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt is_am am psi * hn_ctxt (asmtx_assn N int_assn) cf cfi *\n      hn_val nat_rel u ui)\n     ?c ?\\<Gamma> ?R\n     (ps_get_op am u \\<bind>\n      (\\<lambda>l.\n          (rec\\<^sub>T D.\n              (\\<lambda>(l, a).\n                  case l of [] \\<Rightarrow> return a\n                  | v # l \\<Rightarrow>\n                      cf_get cf (u, v) \\<bind>\n                      (\\<lambda>x. return (0 < x)) \\<bind>\n                      (\\<lambda>c.\n                          let a = if c then v # a else a in D (l, a))))\n           (l, [])))", "using [[id_debug, goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt is_am am psi * hn_ctxt (asmtx_assn N int_assn) cf cfi *\n      hn_val nat_rel u ui)\n     ?c ?\\<Gamma> ?R\n     (ps_get_op am u \\<bind>\n      (\\<lambda>l.\n          (rec\\<^sub>T D.\n              (\\<lambda>(l, a).\n                  case l of [] \\<Rightarrow> return a\n                  | v # l \\<Rightarrow>\n                      cf_get cf (u, v) \\<bind>\n                      (\\<lambda>x. return (0 < x)) \\<bind>\n                      (\\<lambda>c.\n                          let a = if c then v # a else a in D (l, a))))\n           (l, [])))", "by sepref"], ["", "concrete_definition (in -) succ_imp uses Edka_Impl.rg_succ2_impl"], ["", "prepare_code_thms (in -) succ_imp_def"], ["", "lemma succ_imp_refine[sepref_fr_rules]: \n      \"(uncurry2 (succ_imp N), uncurry2 (PR_CONST rg_succ2)) \n        \\<in> is_am\\<^sup>k *\\<^sub>a (asmtx_assn N id_assn)\\<^sup>k *\\<^sub>a (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn (pure Id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (succ_imp N), uncurry2 (PR_CONST rg_succ2))\n    \\<in> is_am\\<^sup>k *\\<^sub>a (asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn nat_assn", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine\n        (fst (is_am\\<^sup>k *\\<^sub>a\n              (asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n              nat_assn\\<^sup>k)\n          a c)\n        (uncurry2 (succ_imp N) c)\n        (snd (is_am\\<^sup>k *\\<^sub>a\n              (asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n              nat_assn\\<^sup>k)\n          a c)\n        (list_assn nat_assn) (uncurry2 (PR_CONST rg_succ2) a)", "using succ_imp.refine[OF this_loc]"], ["proof (prove)\nusing this:\n  hn_refine\n   (hn_ctxt is_am ?am ?psi * hn_ctxt (asmtx_assn N int_assn) ?cf ?cfi *\n    hn_val nat_rel ?u ?ui)\n   (succ_imp N ?psi ?cfi ?ui)\n   (hn_ctxt (asmtx_assn N int_assn) ?cf ?cfi * hn_val nat_rel ?u ?ui *\n    hn_ctxt is_am ?am ?psi)\n   (list_assn nat_assn) (rg_succ2 ?am ?cf ?u)\n\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine\n        (fst (is_am\\<^sup>k *\\<^sub>a\n              (asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n              nat_assn\\<^sup>k)\n          a c)\n        (uncurry2 (succ_imp N) c)\n        (snd (is_am\\<^sup>k *\\<^sub>a\n              (asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n              nat_assn\\<^sup>k)\n          a c)\n        (list_assn nat_assn) (uncurry2 (PR_CONST rg_succ2) a)", "by (auto simp: hn_ctxt_def mult_ac split: prod.split)"], ["", "lemma [def_pat_rules]: \"Network.rg_succ2$c \\<equiv> UNPROTECT rg_succ2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.rg_succ2 $ c \\<equiv> UNPROTECT rg_succ2", "by simp"], ["", "sepref_register \n      \"PR_CONST rg_succ2\" :: \"i_ps \\<Rightarrow> capacity_impl i_mtx \\<Rightarrow> node \\<Rightarrow> node list nres\""], ["", "lemma [sepref_import_param]: \"(min,min)\\<in>Id\\<rightarrow>Id\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min, min) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id", "by simp"], ["", "abbreviation \"is_path \\<equiv> list_assn (prod_assn (pure Id) (pure Id))\""], ["", "schematic_goal resCap_imp_impl:\n      fixes am :: \"node \\<Rightarrow> node list\" and cf :: \"capacity_impl graph\" and p pi\n      notes [id_rules] = \n        itypeI[Pure.of p \"TYPE(edge list)\"]\n        itypeI[Pure.of cf \"TYPE(capacity_impl i_mtx)\"]\n      notes [sepref_import_param] = IdI[of N]\n      shows \"hn_refine \n        (hn_ctxt (asmtx_assn N id_assn) cf cfi * hn_ctxt is_path p pi) \n        (?c::?'c Heap) ?\\<Gamma> ?R \n        (resCap_cf_impl cf p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt (asmtx_assn N int_assn) cf cfi *\n      hn_ctxt (list_assn (nat_assn \\<times>\\<^sub>a nat_assn)) p pi)\n     ?c ?\\<Gamma> ?R (resCap_cf_impl cf p)", "unfolding resCap_cf_impl_def APP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt (asmtx_assn N int_assn) cf cfi *\n      hn_ctxt (list_assn (nat_assn \\<times>\\<^sub>a nat_assn)) p pi)\n     ?c ?\\<Gamma> ?R\n     (case p of [] \\<Rightarrow> return 0\n      | e # p \\<Rightarrow>\n          cf_get cf e \\<bind>\n          (\\<lambda>cap.\n              assert (distinct p) \\<bind>\n              (\\<lambda>_.\n                  nfoldli p (\\<lambda>_. True)\n                   (\\<lambda>e cap.\n                       cf_get cf e \\<bind>\n                       (\\<lambda>cape. return (min cape cap)))\n                   cap)))", "using [[id_debug, goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt (asmtx_assn N int_assn) cf cfi *\n      hn_ctxt (list_assn (nat_assn \\<times>\\<^sub>a nat_assn)) p pi)\n     ?c ?\\<Gamma> ?R\n     (case p of [] \\<Rightarrow> return 0\n      | e # p \\<Rightarrow>\n          cf_get cf e \\<bind>\n          (\\<lambda>cap.\n              assert (distinct p) \\<bind>\n              (\\<lambda>_.\n                  nfoldli p (\\<lambda>_. True)\n                   (\\<lambda>e cap.\n                       cf_get cf e \\<bind>\n                       (\\<lambda>cape. return (min cape cap)))\n                   cap)))", "by sepref"], ["", "concrete_definition (in -) resCap_imp uses Edka_Impl.resCap_imp_impl"], ["", "prepare_code_thms (in -) resCap_imp_def"], ["", "lemma resCap_impl_refine[sepref_fr_rules]: \n      \"(uncurry (resCap_imp N), uncurry (PR_CONST resCap_cf_impl)) \n        \\<in> (asmtx_assn N id_assn)\\<^sup>k *\\<^sub>a (is_path)\\<^sup>k \\<rightarrow>\\<^sub>a (pure Id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (resCap_imp N), uncurry (PR_CONST resCap_cf_impl))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n          (list_assn\n            (nat_assn \\<times>\\<^sub>a\n             nat_assn))\\<^sup>k \\<rightarrow>\\<^sub>a int_assn", "apply sepref_to_hnr"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(int i_mtx);\n        b ::\\<^sub>i TYPE((nat \\<times> nat) list)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt\n                            (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\n                            b bi *\n                           hn_ctxt (asmtx_assn N int_assn) a ai)\n                          (resCap_imp N ai bi)\n                          (hn_ctxt\n                            (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\n                            b bi *\n                           hn_ctxt (asmtx_assn N int_assn) a ai)\n                          int_assn (PR_CONST resCap_cf_impl a b)", "apply (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai h.\n       \\<lbrakk>a ::\\<^sub>i TYPE(int i_mtx);\n        b ::\\<^sub>i TYPE((nat \\<times> nat) list);\n        h \\<Turnstile>\n        hn_ctxt (list_assn (nat_assn \\<times>\\<^sub>a nat_assn)) b bi *\n        hn_ctxt (asmtx_assn N int_assn) a ai\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt\n                            (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\n                            b bi *\n                           hn_ctxt (asmtx_assn N int_assn) a ai)\n                          (resCap_imp N ai bi)\n                          (hn_ctxt\n                            (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\n                            b bi *\n                           hn_ctxt (asmtx_assn N int_assn) a ai)\n                          int_assn (PR_CONST resCap_cf_impl a b)", "apply (clarsimp \n        simp: uncurry_def list_assn_pure_conv hn_ctxt_def \n        split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai aa ba.\n       (aa, ba) \\<Turnstile>\n       id_assn b bi * asmtx_assn N int_assn a ai \\<Longrightarrow>\n       hn_refine (id_assn b bi * asmtx_assn N int_assn a ai)\n        (resCap_imp N ai bi) (id_assn b bi * asmtx_assn N int_assn a ai)\n        int_assn (resCap_cf_impl a b)", "apply (clarsimp simp: pure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ai aa ba.\n       (aa, ba) \\<Turnstile>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai \\<Longrightarrow>\n       hn_refine (asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai)\n        (resCap_imp N ai b)\n        (asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai)\n        (\\<lambda>a c. \\<up> (c = a)) (resCap_cf_impl a b)", "apply (rule hn_refine_cons[OF _ resCap_imp.refine[OF this_loc] _])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b a ai aa ba.\n       (aa, ba) \\<Turnstile>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai \\<Longrightarrow>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a\n        ai \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (asmtx_assn N int_assn) a ai *\n       hn_ctxt (list_assn (nat_assn \\<times>\\<^sub>a nat_assn)) b b\n 2. \\<And>b a ai aa ba.\n       (aa, ba) \\<Turnstile>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai \\<Longrightarrow>\n       hn_ctxt (list_assn (nat_assn \\<times>\\<^sub>a nat_assn)) b b *\n       hn_ctxt (asmtx_assn N int_assn) a ai \\<Longrightarrow>\\<^sub>t\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai\n 3. \\<And>b a ai aa ba x y.\n       (aa, ba) \\<Turnstile>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai \\<Longrightarrow>\n       int_assn x y \\<Longrightarrow>\\<^sub>t \\<up> (y = x)", "apply (simp add: list_assn_pure_conv hn_ctxt_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b a ai aa ba.\n       (aa, ba) \\<Turnstile>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai \\<Longrightarrow>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a\n        ai \\<Longrightarrow>\\<^sub>t\n       asmtx_assn N int_assn a ai * id_assn b b\n 2. \\<And>b a ai aa ba.\n       (aa, ba) \\<Turnstile>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai \\<Longrightarrow>\n       hn_ctxt (list_assn (nat_assn \\<times>\\<^sub>a nat_assn)) b b *\n       hn_ctxt (asmtx_assn N int_assn) a ai \\<Longrightarrow>\\<^sub>t\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai\n 3. \\<And>b a ai aa ba x y.\n       (aa, ba) \\<Turnstile>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai \\<Longrightarrow>\n       int_assn x y \\<Longrightarrow>\\<^sub>t \\<up> (y = x)", "apply (simp add: pure_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b a ai aa ba.\n       (aa, ba) \\<Turnstile>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai \\<Longrightarrow>\n       hn_ctxt (list_assn (nat_assn \\<times>\\<^sub>a nat_assn)) b b *\n       hn_ctxt (asmtx_assn N int_assn) a ai \\<Longrightarrow>\\<^sub>t\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai\n 2. \\<And>b a ai aa ba x y.\n       (aa, ba) \\<Turnstile>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai \\<Longrightarrow>\n       int_assn x y \\<Longrightarrow>\\<^sub>t \\<up> (y = x)", "apply (sep_auto simp add: hn_ctxt_def pure_def intro!: enttI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ai aa ba x y.\n       (aa, ba) \\<Turnstile>\n       asmtx_assn N (\\<lambda>a c. \\<up> (c = a)) a ai \\<Longrightarrow>\n       int_assn x y \\<Longrightarrow>\\<^sub>t \\<up> (y = x)", "apply (simp add: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [def_pat_rules]: \n      \"Network.resCap_cf_impl$c \\<equiv> UNPROTECT resCap_cf_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.resCap_cf_impl $ c \\<equiv> UNPROTECT resCap_cf_impl", "by simp"], ["", "sepref_register \"PR_CONST resCap_cf_impl\" \n      :: \"capacity_impl i_mtx \\<Rightarrow> path \\<Rightarrow> capacity_impl nres\""], ["", "sepref_thm augment_imp is \"uncurry2 (PR_CONST augment_cf_impl)\" :: \"((asmtx_assn N id_assn)\\<^sup>d *\\<^sub>a (is_path)\\<^sup>k *\\<^sub>a (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N id_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 (PR_CONST augment_cf_impl))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a\n          (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\\<^sup>k *\\<^sub>a\n          int_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "unfolding augment_cf_impl_def[abs_def] augment_edge_impl_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>cf p x.\n          (rec\\<^sub>T D.\n              (\\<lambda>(a, cf).\n                  case a of [] \\<Rightarrow> return cf\n                  | e # p \\<Rightarrow>\n                      cf_get cf e \\<bind>\n                      (\\<lambda>v.\n                          cf_set cf e (v - x) \\<bind>\n                          (\\<lambda>cf.\n                              let e = prod.swap e\n                              in cf_get cf e \\<bind>\n                                 (\\<lambda>v.\n                                     cf_set cf e (v + x) \\<bind>\n                                     return))) \\<bind>\n                      (\\<lambda>cf. D (p, cf))))\n           (p, cf)))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a\n          (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\\<^sup>k *\\<^sub>a\n          int_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "using [[id_debug, goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>cf p x.\n          (rec\\<^sub>T D.\n              (\\<lambda>(a, cf).\n                  case a of [] \\<Rightarrow> return cf\n                  | e # p \\<Rightarrow>\n                      cf_get cf e \\<bind>\n                      (\\<lambda>v.\n                          cf_set cf e (v - x) \\<bind>\n                          (\\<lambda>cf.\n                              let e = prod.swap e\n                              in cf_get cf e \\<bind>\n                                 (\\<lambda>v.\n                                     cf_set cf e (v + x) \\<bind>\n                                     return))) \\<bind>\n                      (\\<lambda>cf. D (p, cf))))\n           (p, cf)))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a\n          (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\\<^sup>k *\\<^sub>a\n          int_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "by sepref"], ["", "concrete_definition (in -) augment_imp uses Edka_Impl.augment_imp.refine_raw is \"(uncurry2 ?f,_)\\<in>_\""], ["", "prepare_code_thms (in -) augment_imp_def"], ["", "lemma augment_impl_refine[sepref_fr_rules]: \n      \"(uncurry2 (augment_imp N), uncurry2 (PR_CONST augment_cf_impl)) \n        \\<in> (asmtx_assn N id_assn)\\<^sup>d *\\<^sub>a (is_path)\\<^sup>k *\\<^sub>a (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (augment_imp N), uncurry2 (PR_CONST augment_cf_impl))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a\n          (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\\<^sup>k *\\<^sub>a\n          int_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "using augment_imp.refine[OF this_loc]"], ["proof (prove)\nusing this:\n  (uncurry2 (augment_imp N), uncurry2 (PR_CONST augment_cf_impl))\n  \\<in> (asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a\n        (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\\<^sup>k *\\<^sub>a\n        int_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn\n\ngoal (1 subgoal):\n 1. (uncurry2 (augment_imp N), uncurry2 (PR_CONST augment_cf_impl))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a\n          (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\\<^sup>k *\\<^sub>a\n          int_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "."], ["", "lemma [def_pat_rules]: \n      \"Network.augment_cf_impl$c \\<equiv> UNPROTECT augment_cf_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.augment_cf_impl $ c \\<equiv> UNPROTECT augment_cf_impl", "by simp"], ["", "sepref_register \"PR_CONST augment_cf_impl\" \n      :: \"capacity_impl i_mtx \\<Rightarrow> path \\<Rightarrow> capacity_impl \\<Rightarrow> capacity_impl i_mtx nres\""], ["", "sublocale bfs: Impl_Succ \n      \"snd\" \n      \"TYPE(i_ps \\<times> capacity_impl i_mtx)\" \n      \"PR_CONST (\\<lambda>(am,cf). rg_succ2 am cf)\" \n      \"prod_assn is_am (asmtx_assn N id_assn)\" \n      \"\\<lambda>(am,cf). succ_imp N am cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Impl_Succ snd (PR_CONST (\\<lambda>(x, y). rg_succ2 x y))\n     (is_am \\<times>\\<^sub>a asmtx_assn N int_assn)\n     (\\<lambda>(am, cf). succ_imp N am cf)", "unfolding APP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Impl_Succ snd (PR_CONST (\\<lambda>(x, y). rg_succ2 x y))\n     (is_am \\<times>\\<^sub>a asmtx_assn N int_assn)\n     (\\<lambda>(am, cf). succ_imp N am cf)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (\\<lambda>(am, cf). succ_imp N am cf),\n     uncurry (PR_CONST (\\<lambda>(x, y). rg_succ2 x y)))\n    \\<in> [\\<lambda>(c, u).\n              u \\<in> Graph.V\n                       (snd c)]\\<^sub>a (is_am \\<times>\\<^sub>a\n   asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n  nat_assn\\<^sup>k \\<rightarrow> list_assn nat_assn", "apply (simp add: fold_partial_uncurry)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (succ_imp N), uncurry2 rg_succ2)\n    \\<in> [\\<lambda>(c, u).\n              u \\<in> Graph.V\n                       (snd c)]\\<^sub>a (is_am \\<times>\\<^sub>a\n   asmtx_assn N int_assn,\n   is_am \\<times>\\<^sub>a asmtx_assn N int_assn) *\\<^sub>a\n  (nat_assn, nat_assn) \\<rightarrow> list_assn nat_assn", "apply (rule hfref_cons[OF succ_imp_refine[unfolded PR_CONST_def]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       case x of\n       (c, u) \\<Rightarrow> u \\<in> Graph.V (snd c) \\<Longrightarrow>\n       True\n 2. \\<And>x y.\n       fst ((is_am \\<times>\\<^sub>a asmtx_assn N int_assn,\n             is_am \\<times>\\<^sub>a asmtx_assn N int_assn) *\\<^sub>a\n            (nat_assn, nat_assn))\n        x y \\<Longrightarrow>\\<^sub>t\n       fst (is_am\\<^sup>k *\\<^sub>a\n            (asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n            nat_assn\\<^sup>k)\n        x y\n 3. \\<And>x y.\n       snd (is_am\\<^sup>k *\\<^sub>a\n            (asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n            nat_assn\\<^sup>k)\n        x y \\<Longrightarrow>\\<^sub>t\n       snd ((is_am \\<times>\\<^sub>a asmtx_assn N int_assn,\n             is_am \\<times>\\<^sub>a asmtx_assn N int_assn) *\\<^sub>a\n            (nat_assn, nat_assn))\n        x y\n 4. \\<And>x y.\n       list_assn nat_assn x y \\<Longrightarrow>\\<^sub>t\n       list_assn nat_assn x y", "by auto"], ["", "definition (in -) \"bfsi' N s t psi cfi \n      \\<equiv> bfs_impl (\\<lambda>(am, cf). succ_imp N am cf) (psi,cfi) s t\""], ["", "lemma [sepref_fr_rules]: \n      \"(uncurry (bfsi' N s t),uncurry (PR_CONST bfs2_op)) \n        \\<in> is_am\\<^sup>k *\\<^sub>a (asmtx_assn N id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn is_path\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (bfsi' N s t), uncurry (PR_CONST bfs2_op))\n    \\<in> is_am\\<^sup>k *\\<^sub>a\n          (asmtx_assn N\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn\n               (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))", "unfolding bfsi'_def[abs_def] bfs2_op_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry\n      (\\<lambda>psi cfi.\n          bfs_impl (\\<lambda>(x, y). succ_imp N x y) (psi, cfi) s t),\n     uncurry\n      (PR_CONST (\\<lambda>am cf. Graph.bfs2 cf (rg_succ2 am cf) s t)))\n    \\<in> is_am\\<^sup>k *\\<^sub>a\n          (asmtx_assn N\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn\n               (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))", "using bfs.bfs_impl_fr_rule"], ["proof (prove)\nusing this:\n  (uncurry2 (bfs_impl (\\<lambda>(am, cf). succ_imp N am cf)),\n   uncurry2 (PR_CONST bfs.op_bfs))\n  \\<in> (is_am \\<times>\\<^sub>a asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n        nat_assn\\<^sup>k *\\<^sub>a\n        nat_assn\\<^sup>d \\<rightarrow>\\<^sub>a option_assn\n          (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\n\ngoal (1 subgoal):\n 1. (uncurry\n      (\\<lambda>psi cfi.\n          bfs_impl (\\<lambda>(x, y). succ_imp N x y) (psi, cfi) s t),\n     uncurry\n      (PR_CONST (\\<lambda>am cf. Graph.bfs2 cf (rg_succ2 am cf) s t)))\n    \\<in> is_am\\<^sup>k *\\<^sub>a\n          (asmtx_assn N\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn\n               (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))", "unfolding bfs.op_bfs_def[abs_def]"], ["proof (prove)\nusing this:\n  (uncurry2 (bfs_impl (\\<lambda>(am, cf). succ_imp N am cf)),\n   uncurry2\n    (PR_CONST\n      (\\<lambda>c.\n          Graph.bfs2 (snd c) (PR_CONST (\\<lambda>(x, y). rg_succ2 x y) c))))\n  \\<in> (is_am \\<times>\\<^sub>a asmtx_assn N int_assn)\\<^sup>k *\\<^sub>a\n        nat_assn\\<^sup>k *\\<^sub>a\n        nat_assn\\<^sup>d \\<rightarrow>\\<^sub>a option_assn\n          (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))\n\ngoal (1 subgoal):\n 1. (uncurry\n      (\\<lambda>psi cfi.\n          bfs_impl (\\<lambda>(x, y). succ_imp N x y) (psi, cfi) s t),\n     uncurry\n      (PR_CONST (\\<lambda>am cf. Graph.bfs2 cf (rg_succ2 am cf) s t)))\n    \\<in> is_am\\<^sup>k *\\<^sub>a\n          (asmtx_assn N\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn\n               (list_assn (nat_assn \\<times>\\<^sub>a nat_assn))", "apply (clarsimp simp: hfref_def all_to_meta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b ba bb aa bc bd be.\n        hn_refine\n         (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n          nat_assn be bb)\n         (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n         (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n          invalid_assn nat_assn be bb)\n         (option_assn (list_assn id_assn))\n         (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n    (\\<And>a b aa ba.\n        hn_refine (is_am aa a * asmtx_assn N int_assn ba b)\n         (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) s t)\n         (is_am aa a * asmtx_assn N int_assn ba b)\n         (option_assn (list_assn id_assn))\n         (Graph.bfs2 ba (rg_succ2 aa ba) s t))", "apply (rule hn_refine_cons[rotated])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba.\n       (\\<And>a b ba bb aa bc bd be.\n           hn_refine\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             nat_assn be bb)\n            (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             invalid_assn nat_assn be bb)\n            (option_assn (list_assn id_assn))\n            (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n       hn_refine (?P'42 a b aa ba)\n        (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) s t)\n        (?Q42 a b aa ba) (?R42 a b aa ba)\n        (Graph.bfs2 ba (rg_succ2 aa ba) s t)\n 2. \\<And>a b aa ba.\n       (\\<And>a b ba bb aa bc bd be.\n           hn_refine\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             nat_assn be bb)\n            (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             invalid_assn nat_assn be bb)\n            (option_assn (list_assn id_assn))\n            (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n       ?Q42 a b aa ba \\<Longrightarrow>\\<^sub>t\n       is_am aa a * asmtx_assn N int_assn ba b\n 3. \\<And>a b aa ba x y.\n       (\\<And>a b ba bb aa bc bd be.\n           hn_refine\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             nat_assn be bb)\n            (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             invalid_assn nat_assn be bb)\n            (option_assn (list_assn id_assn))\n            (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n       ?R42 a b aa ba x y \\<Longrightarrow>\\<^sub>t\n       option_assn (list_assn id_assn) x y\n 4. \\<And>a b aa ba.\n       (\\<And>a b ba bb aa bc bd be.\n           hn_refine\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             nat_assn be bb)\n            (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             invalid_assn nat_assn be bb)\n            (option_assn (list_assn id_assn))\n            (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n       is_am aa a * asmtx_assn N int_assn ba b \\<Longrightarrow>\\<^sub>t\n       ?P'42 a b aa ba", "apply rprems"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba.\n       (\\<And>a b ba bb aa bc bd be.\n           hn_refine\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             nat_assn be bb)\n            (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             invalid_assn nat_assn be bb)\n            (option_assn (list_assn id_assn))\n            (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n       is_am aa a * asmtx_assn N int_assn ba b * nat_assn s s *\n       invalid_assn nat_assn t t \\<Longrightarrow>\\<^sub>t\n       is_am aa a * asmtx_assn N int_assn ba b\n 2. \\<And>a b aa ba x y.\n       (\\<And>a b ba bb aa bc bd be.\n           hn_refine\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             nat_assn be bb)\n            (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             invalid_assn nat_assn be bb)\n            (option_assn (list_assn id_assn))\n            (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n       option_assn (list_assn id_assn) x y \\<Longrightarrow>\\<^sub>t\n       option_assn (list_assn id_assn) x y\n 3. \\<And>a b aa ba.\n       (\\<And>a b ba bb aa bc bd be.\n           hn_refine\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             nat_assn be bb)\n            (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             invalid_assn nat_assn be bb)\n            (option_assn (list_assn id_assn))\n            (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n       is_am aa a * asmtx_assn N int_assn ba b \\<Longrightarrow>\\<^sub>t\n       is_am aa a * asmtx_assn N int_assn ba b * nat_assn s s * nat_assn t t", "apply (sep_auto simp: pure_def intro!: enttI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba x y.\n       (\\<And>a b ba bb aa bc bd be.\n           hn_refine\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             nat_assn be bb)\n            (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             invalid_assn nat_assn be bb)\n            (option_assn (list_assn id_assn))\n            (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n       option_assn (list_assn id_assn) x y \\<Longrightarrow>\\<^sub>t\n       option_assn (list_assn id_assn) x y\n 2. \\<And>a b aa ba.\n       (\\<And>a b ba bb aa bc bd be.\n           hn_refine\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             nat_assn be bb)\n            (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             invalid_assn nat_assn be bb)\n            (option_assn (list_assn id_assn))\n            (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n       is_am aa a * asmtx_assn N int_assn ba b \\<Longrightarrow>\\<^sub>t\n       is_am aa a * asmtx_assn N int_assn ba b * nat_assn s s * nat_assn t t", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       (\\<And>a b ba bb aa bc bd be.\n           hn_refine\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             nat_assn be bb)\n            (bfs_impl (\\<lambda>(x, y). succ_imp N x y) (a, b) ba bb)\n            (is_am aa a * asmtx_assn N int_assn bc b * nat_assn bd ba *\n             invalid_assn nat_assn be bb)\n            (option_assn (list_assn id_assn))\n            (Graph.bfs2 bc (rg_succ2 aa bc) bd be)) \\<Longrightarrow>\n       is_am aa a * asmtx_assn N int_assn ba b \\<Longrightarrow>\\<^sub>t\n       is_am aa a * asmtx_assn N int_assn ba b * nat_assn s s * nat_assn t t", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [def_pat_rules]: \"Network.bfs2_op$c$s$t \\<equiv> UNPROTECT bfs2_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.bfs2_op $ c $ s $ t \\<equiv> UNPROTECT bfs2_op", "by simp"], ["", "sepref_register \"PR_CONST bfs2_op\" \n      :: \"i_ps \\<Rightarrow> capacity_impl i_mtx \\<Rightarrow> path option nres\""], ["", "schematic_goal edka_imp_tabulate_impl:\n      notes [sepref_opt_simps] = heap_WHILET_def\n      fixes am :: \"node \\<Rightarrow> node list\" and cf :: \"capacity_impl graph\"\n      notes [id_rules] = \n        itypeI[Pure.of am \"TYPE(node \\<Rightarrow> node list)\"]\n      notes [sepref_import_param] = IdI[of am]\n      shows \"hn_refine (emp) (?c::?'c Heap) ?\\<Gamma> ?R (edka5_tabulate am)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma> ?R (edka5_tabulate am)", "unfolding edka5_tabulate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma> ?R\n     (init_cf \\<bind>\n      (\\<lambda>cf. init_ps am \\<bind> (\\<lambda>am. return (cf, am))))", "using [[id_debug, goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma> ?R\n     (init_cf \\<bind>\n      (\\<lambda>cf. init_ps am \\<bind> (\\<lambda>am. return (cf, am))))", "by sepref"], ["", "concrete_definition (in -) edka_imp_tabulate \n      uses Edka_Impl.edka_imp_tabulate_impl"], ["", "prepare_code_thms (in -) edka_imp_tabulate_def"], ["", "lemma edka_imp_tabulate_refine[sepref_fr_rules]: \n      \"(edka_imp_tabulate c N, PR_CONST edka5_tabulate) \n      \\<in> (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn (asmtx_assn N id_assn) is_am\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (edka_imp_tabulate c N, PR_CONST edka5_tabulate)\n    \\<in> id_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N\n           int_assn \\<times>\\<^sub>a\n          is_am", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca a.\n       True \\<Longrightarrow>\n       hn_refine (fst (id_assn\\<^sup>k) a ca) (edka_imp_tabulate c N ca)\n        (snd (id_assn\\<^sup>k) a ca)\n        (asmtx_assn N int_assn \\<times>\\<^sub>a is_am)\n        (PR_CONST edka5_tabulate a)", "apply (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca a h.\n       \\<lbrakk>True; h \\<Turnstile> fst (id_assn\\<^sup>k) a ca\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst (id_assn\\<^sup>k) a ca)\n                          (edka_imp_tabulate c N ca)\n                          (snd (id_assn\\<^sup>k) a ca)\n                          (asmtx_assn N int_assn \\<times>\\<^sub>a is_am)\n                          (PR_CONST edka5_tabulate a)", "apply (clarsimp \n        simp: uncurry_def list_assn_pure_conv hn_ctxt_def \n        split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca.\n       hn_refine (id_assn ca ca) (edka_imp_tabulate c N ca) (id_assn ca ca)\n        (asmtx_assn N int_assn \\<times>\\<^sub>a is_am) (edka5_tabulate ca)", "apply (rule hn_refine_cons[OF _ edka_imp_tabulate.refine[OF this_loc]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c. id_assn c c \\<Longrightarrow>\\<^sub>t emp\n 2. \\<And>c. emp \\<Longrightarrow>\\<^sub>t id_assn c c\n 3. \\<And>c x y.\n       (asmtx_assn N int_assn \\<times>\\<^sub>a is_am) x\n        y \\<Longrightarrow>\\<^sub>t\n       (asmtx_assn N int_assn \\<times>\\<^sub>a is_am) x y", "apply (sep_auto simp: hn_ctxt_def pure_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [def_pat_rules]: \n      \"Network.edka5_tabulate$c \\<equiv> UNPROTECT edka5_tabulate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.edka5_tabulate $ c \\<equiv> UNPROTECT edka5_tabulate", "by simp"], ["", "sepref_register \"PR_CONST edka5_tabulate\"\n      :: \"(node \\<Rightarrow> node list) \\<Rightarrow> (capacity_impl i_mtx \\<times> i_ps) nres\""], ["", "schematic_goal edka_imp_run_impl:\n      notes [sepref_opt_simps] = heap_WHILET_def\n      fixes am :: \"node \\<Rightarrow> node list\" and cf :: \"capacity_impl graph\"\n      notes [id_rules] = \n        itypeI[Pure.of cf \"TYPE(capacity_impl i_mtx)\"]\n        itypeI[Pure.of am \"TYPE(i_ps)\"]\n      shows \"hn_refine \n        (hn_ctxt (asmtx_assn N id_assn) cf cfi * hn_ctxt is_am am psi) \n        (?c::?'c Heap) ?\\<Gamma> ?R  \n        (edka5_run cf am)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt (asmtx_assn N int_assn) cf cfi * hn_ctxt is_am am psi) ?c\n     ?\\<Gamma> ?R (edka5_run cf am)", "unfolding edka5_run_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt (asmtx_assn N int_assn) cf cfi * hn_ctxt is_am am psi) ?c\n     ?\\<Gamma> ?R\n     (while\\<^sub>T (\\<lambda>(cf, brk). \\<not> brk)\n       (\\<lambda>(cf, uu_).\n           assert (RGraph c s t cf) \\<bind>\n           (\\<lambda>_.\n               bfs2_op am cf \\<bind>\n               (\\<lambda>p.\n                   case p of None \\<Rightarrow> return (cf, True)\n                   | Some p \\<Rightarrow>\n                       assert (p \\<noteq> []) \\<bind>\n                       (\\<lambda>_.\n                           assert (Graph.isShortestPath cf s p t) \\<bind>\n                           (\\<lambda>_.\n                               resCap_cf_impl cf p \\<bind>\n                               (\\<lambda>bn.\n                                   augment_cf_impl cf p bn \\<bind>\n                                   (\\<lambda>cf.\n assert (RGraph c s t cf) \\<bind> (\\<lambda>_. return (cf, False)))))))))\n       (cf, False) \\<bind>\n      (\\<lambda>(cf, uu_). compute_rflow cf \\<bind> return))", "using [[id_debug, goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt (asmtx_assn N int_assn) cf cfi * hn_ctxt is_am am psi) ?c\n     ?\\<Gamma> ?R\n     (while\\<^sub>T (\\<lambda>(cf, brk). \\<not> brk)\n       (\\<lambda>(cf, uu_).\n           assert (RGraph c s t cf) \\<bind>\n           (\\<lambda>_.\n               bfs2_op am cf \\<bind>\n               (\\<lambda>p.\n                   case p of None \\<Rightarrow> return (cf, True)\n                   | Some p \\<Rightarrow>\n                       assert (p \\<noteq> []) \\<bind>\n                       (\\<lambda>_.\n                           assert (Graph.isShortestPath cf s p t) \\<bind>\n                           (\\<lambda>_.\n                               resCap_cf_impl cf p \\<bind>\n                               (\\<lambda>bn.\n                                   augment_cf_impl cf p bn \\<bind>\n                                   (\\<lambda>cf.\n assert (RGraph c s t cf) \\<bind> (\\<lambda>_. return (cf, False)))))))))\n       (cf, False) \\<bind>\n      (\\<lambda>(cf, uu_). compute_rflow cf \\<bind> return))", "by sepref"], ["", "concrete_definition (in -) edka_imp_run uses Edka_Impl.edka_imp_run_impl"], ["", "prepare_code_thms (in -) edka_imp_run_def"], ["", "thm edka_imp_run_def"], ["", "lemma edka_imp_run_refine[sepref_fr_rules]: \n      \"(uncurry (edka_imp_run s t N), uncurry (PR_CONST edka5_run)) \n        \\<in> (asmtx_assn N id_assn)\\<^sup>d *\\<^sub>a (is_am)\\<^sup>k \\<rightarrow>\\<^sub>a is_rflow N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (edka_imp_run s t N), uncurry (PR_CONST edka5_run))\n    \\<in> (asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a\n          is_am\\<^sup>k \\<rightarrow>\\<^sub>a is_rflow N", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine\n        (fst ((asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a is_am\\<^sup>k) a c)\n        (uncurry (edka_imp_run s t N) c)\n        (snd ((asmtx_assn N int_assn)\\<^sup>d *\\<^sub>a is_am\\<^sup>k) a c)\n        (is_rflow N) (uncurry (PR_CONST edka5_run) a)", "apply (clarsimp \n        simp: uncurry_def list_assn_pure_conv hn_ctxt_def \n        split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       hn_refine (asmtx_assn N int_assn x1a x1 * is_am x2a x2)\n        (edka_imp_run s t N x1 x2)\n        (invalid_assn (asmtx_assn N int_assn) x1a x1 * is_am x2a x2)\n        (is_rflow N) (edka5_run x1a x2a)", "apply (rule hn_refine_cons[OF _ edka_imp_run.refine[OF this_loc] _])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       asmtx_assn N int_assn x1a x1 * is_am x2a x2 \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (asmtx_assn N int_assn) x1a x1 * hn_ctxt is_am x2a x2\n 2. \\<And>x1 x2 x1a x2a.\n       hn_invalid (asmtx_assn N int_assn) x1a x1 *\n       hn_ctxt is_am x2a x2 \\<Longrightarrow>\\<^sub>t\n       invalid_assn (asmtx_assn N int_assn) x1a x1 * is_am x2a x2\n 3. \\<And>x1 x2 x1a x2a x y.\n       is_rflow N x y \\<Longrightarrow>\\<^sub>t is_rflow N x y", "apply (sep_auto simp: hn_ctxt_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [def_pat_rules]: \n      \"Network.edka5_run$c$s$t \\<equiv> UNPROTECT edka5_run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Network.edka5_run $ c $ s $ t \\<equiv> UNPROTECT edka5_run", "by simp"], ["", "sepref_register \"PR_CONST edka5_run\" \n      :: \"capacity_impl i_mtx \\<Rightarrow> i_ps \\<Rightarrow> i_rflow nres\""], ["", "schematic_goal edka_imp_impl:\n      notes [sepref_opt_simps] = heap_WHILET_def\n      fixes am :: \"node \\<Rightarrow> node list\" and cf :: \"capacity_impl graph\"\n      notes [id_rules] = \n        itypeI[Pure.of am \"TYPE(node \\<Rightarrow> node list)\"]\n      notes [sepref_import_param] = IdI[of am]\n      shows \"hn_refine (emp) (?c::?'c Heap) ?\\<Gamma> ?R (edka5 am)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma> ?R (edka5 am)", "unfolding edka5_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma> ?R\n     (edka5_tabulate am \\<bind> (\\<lambda>(x, y). edka5_run x y))", "using [[id_debug, goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma> ?R\n     (edka5_tabulate am \\<bind> (\\<lambda>(x, y). edka5_run x y))", "by sepref"], ["", "concrete_definition (in -) edka_imp uses Edka_Impl.edka_imp_impl"], ["", "prepare_code_thms (in -) edka_imp_def"], ["", "lemmas edka_imp_refine = edka_imp.refine[OF this_loc]"], ["", "thm pat_rules TrueI def_pat_rules"], ["", "end"], ["", "export_code edka_imp checking SML_imp"], ["", "subsection \\<open>Correctness Theorem for Implementation\\<close>"], ["", "text \\<open>We combine all refinement steps to derive a correctness \n    theorem for the implementation\\<close>"], ["", "context Network_Impl begin"], ["", "theorem edka_imp_correct: \n      assumes VN: \"Graph.V c \\<subseteq> {0..<N}\"\n      assumes ABS_PS: \"is_adj_map am\"\n      shows \"\n        <emp> \n          edka_imp c s t N am \n        <\\<lambda>fi. \\<exists>\\<^sub>Af. is_rflow N f fi * \\<up>(isMaxFlow f)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "interpret Edka_Impl"], ["proof (prove)\ngoal (1 subgoal):\n 1. Edka_Impl c s t N", "by unfold_locales fact"], ["proof (state)\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "note edka5_refine[OF ABS_PS]"], ["proof (state)\nthis:\n  edka5 am \\<le> \\<Down> Id edka4\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "also"], ["proof (state)\nthis:\n  edka5 am \\<le> \\<Down> Id edka4\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "note edka4_refine"], ["proof (state)\nthis:\n  edka4 \\<le> \\<Down> Id edka3\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "also"], ["proof (state)\nthis:\n  edka4 \\<le> \\<Down> Id edka3\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "note edka3_refine"], ["proof (state)\nthis:\n  edka3 \\<le> \\<Down> Id edka2\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "also"], ["proof (state)\nthis:\n  edka3 \\<le> \\<Down> Id edka2\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "note edka2_refine"], ["proof (state)\nthis:\n  edka2 \\<le> \\<Down> Id edka\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "also"], ["proof (state)\nthis:\n  edka2 \\<le> \\<Down> Id edka\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "note edka_refine"], ["proof (state)\nthis:\n  edka \\<le> \\<Down> Id edka_partial\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "also"], ["proof (state)\nthis:\n  edka \\<le> \\<Down> Id edka_partial\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "note edka_partial_refine"], ["proof (state)\nthis:\n  edka_partial \\<le> \\<Down> Id fofu\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "also"], ["proof (state)\nthis:\n  edka_partial \\<le> \\<Down> Id fofu\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "note fofu_partial_correct"], ["proof (state)\nthis:\n  fofu \\<le> SPEC isMaxFlow\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "finally"], ["proof (chain)\npicking this:\n  edka5 am \\<le> SPEC isMaxFlow", "have \"edka5 am \\<le> SPEC isMaxFlow\""], ["proof (prove)\nusing this:\n  edka5 am \\<le> SPEC isMaxFlow\n\ngoal (1 subgoal):\n 1. edka5 am \\<le> SPEC isMaxFlow", "."], ["proof (state)\nthis:\n  edka5 am \\<le> SPEC isMaxFlow\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "from hn_refine_ref[OF this edka_imp_refine]"], ["proof (chain)\npicking this:\n  hn_refine emp (edka_imp c s t N am) emp (is_rflow N) (SPEC isMaxFlow)", "show ?thesis"], ["proof (prove)\nusing this:\n  hn_refine emp (edka_imp c s t N am) emp (is_rflow N) (SPEC isMaxFlow)\n\ngoal (1 subgoal):\n 1. <emp> edka_imp c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Af.\n                     is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t", "by (simp add: hn_refine_def)"], ["proof (state)\nthis:\n  <emp> edka_imp c s t N\n         am <\\<lambda>r.\n                \\<exists>\\<^sub>Af.\n                   is_rflow N f r * \\<up> (isMaxFlow f)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}