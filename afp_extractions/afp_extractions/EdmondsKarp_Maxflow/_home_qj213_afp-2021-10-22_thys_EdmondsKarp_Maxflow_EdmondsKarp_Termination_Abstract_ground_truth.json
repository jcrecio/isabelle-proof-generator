{"file_name": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow/EdmondsKarp_Termination_Abstract.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow", "problem_names": ["lemma mlex_fst_decrI:\n  fixes a a' b b' N :: nat\n  assumes \"a<a'\"\n  assumes \"b<N\" \"b'<N\"\n  shows \"a*N + b < a'*N + b'\"", "lemma (in NFlow) augmenting_path_imp_shortest: \n  \"isAugmentingPath p \\<Longrightarrow> \\<exists>p. Graph.isShortestPath cf s p t\"", "lemma (in NFlow) shortest_is_augmenting: \n  \"Graph.isShortestPath cf s p t \\<Longrightarrow> isAugmentingPath p\"", "lemma isShortestPath_flip_edge:\n  assumes \"isShortestPath s p t\" \"(u,v)\\<in>set p\"\n  assumes \"isPath s p' t\" \"(v,u)\\<in>set p'\"\n  shows \"length p' \\<ge> length p + 2\"", "lemma isShortestPath_flip_edges:\n  assumes \"Graph.E c' \\<supseteq> E - edges\" \"Graph.E c' \\<subseteq> E \\<union> (prod.swap`edges)\"\n  assumes SP: \"isShortestPath s p t\" and EDGES_SS: \"edges \\<subseteq> set p\"\n  assumes P': \"Graph.isPath c' s p' t\" \"prod.swap`edges \\<inter> set p' \\<noteq> {}\"\n  shows \"length p + 2 \\<le> length p'\"", "lemma spEdges_ss_E: \"spEdges \\<subseteq> E\"", "lemma finite_spEdges[simp, intro]: \"finite (spEdges)\"", "lemma finite_uE[simp,intro]: \"finite uE\"", "lemma E_ss_uE: \"E\\<subseteq>uE\"", "lemma card_spEdges_le:\n  shows \"card spEdges \\<le> card uE\"", "lemma card_spEdges_less:\n  shows \"card spEdges < card uE + 1\"", "lemma measure_decr:\n  assumes SV: \"s\\<in>V\"\n  assumes SP: \"isShortestPath s p t\"\n  assumes SP_EDGES: \"edges\\<subseteq>set p\"\n  assumes Ebounds: \n    \"Graph.E c' \\<supseteq> E - edges \\<union> prod.swap`edges\" \n    \"Graph.E c' \\<subseteq> E \\<union> prod.swap`edges\"\n  shows \"ek_analysis_defs.ekMeasure c' s t \\<le> ekMeasure\"\n    and \"edges - Graph.E c' \\<noteq> {} \n         \\<Longrightarrow> ek_analysis_defs.ekMeasure c' s t < ekMeasure\"", "lemma augment_cf_empty[simp]: \"augment_cf {} cap = c\"", "lemma augment_cf_ss_V: \"\\<lbrakk>edges \\<subseteq> E\\<rbrakk> \\<Longrightarrow> Graph.V (augment_cf edges cap) \\<subseteq> V\"", "lemma augment_saturate:\n  fixes edges e\n  defines \"c' \\<equiv> augment_cf edges (c e)\"\n  assumes EIE: \"e\\<in>edges\"\n  shows \"e\\<notin>Graph.E c'\"", "lemma augment_cf_split: \n  assumes \"edges1 \\<inter> edges2 = {}\" \"edges1\\<inverse> \\<inter> edges2 = {}\"\n  shows \"Graph.augment_cf c (edges1 \\<union> edges2) cap \n    = Graph.augment_cf (Graph.augment_cf c edges1 cap) edges2 cap\"", "lemma augmenting_edge_no_swap: \"isAugmentingPath p \\<Longrightarrow> set p \\<inter> (set p)\\<inverse> = {}\"", "lemma aug_flows_finite[simp, intro!]: \n  \"finite {cf e |e. e \\<in> set p}\"", "lemma aug_flows_finite'[simp, intro!]: \n  \"finite {cf (u,v) |u v. (u,v) \\<in> set p}\"", "lemma augment_alt:\n  assumes AUG: \"isAugmentingPath p\"\n  defines \"f' \\<equiv> augment (augmentingFlow p)\"\n  defines \"cf' \\<equiv> residualGraph c f'\"\n  shows \"cf' = Graph.augment_cf cf (set p) (resCap p)\"", "lemma augmenting_path_contains_resCap:\n  assumes \"isAugmentingPath p\"\n  obtains e where \"e\\<in>set p\" \"cf e = resCap p\"", "theorem shortest_path_decr_ek_measure:\n  fixes p\n  assumes SP: \"Graph.isShortestPath cf s p t\"\n  defines \"f' \\<equiv> augment (augmentingFlow p)\"\n  defines \"cf' \\<equiv> residualGraph c f'\"\n  shows \"ek_analysis_defs.ekMeasure cf' s t < ek_analysis_defs.ekMeasure cf s t\""], "translations": [["", "lemma mlex_fst_decrI:\n  fixes a a' b b' N :: nat\n  assumes \"a<a'\"\n  assumes \"b<N\" \"b'<N\"\n  shows \"a*N + b < a'*N + b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "have \"a*N + b + 1 \\<le> a*N + N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * N + b + 1 \\<le> a * N + N", "using \\<open>b<N\\<close>"], ["proof (prove)\nusing this:\n  b < N\n\ngoal (1 subgoal):\n 1. a * N + b + 1 \\<le> a * N + N", "by linarith"], ["proof (state)\nthis:\n  a * N + b + 1 \\<le> a * N + N\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "also"], ["proof (state)\nthis:\n  a * N + b + 1 \\<le> a * N + N\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "have \"\\<dots> \\<le> a'*N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * N + N \\<le> a' * N", "using \\<open>a<a'\\<close>"], ["proof (prove)\nusing this:\n  a < a'\n\ngoal (1 subgoal):\n 1. a * N + N \\<le> a' * N", "by (metis Suc_leI ab_semigroup_add_class.add.commute \n      ab_semigroup_mult_class.mult.commute mult_Suc_right mult_le_mono2)"], ["proof (state)\nthis:\n  a * N + N \\<le> a' * N\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "also"], ["proof (state)\nthis:\n  a * N + N \\<le> a' * N\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "have \"\\<dots> \\<le> a'*N + b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' * N \\<le> a' * N + b'", "by auto"], ["proof (state)\nthis:\n  a' * N \\<le> a' * N + b'\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "finally"], ["proof (chain)\npicking this:\n  a * N + b + 1 \\<le> a' * N + b'", "show ?thesis"], ["proof (prove)\nusing this:\n  a * N + b + 1 \\<le> a' * N + b'\n\ngoal (1 subgoal):\n 1. a * N + b < a' * N + b'", "by auto"], ["proof (state)\nthis:\n  a * N + b < a' * N + b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in NFlow) augmenting_path_imp_shortest: \n  \"isAugmentingPath p \\<Longrightarrow> \\<exists>p. Graph.isShortestPath cf s p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> \\<exists>p. cf.isShortestPath s p t", "using Graph.obtain_shortest_path"], ["proof (prove)\nusing this:\n  \\<lbrakk>Graph.connected ?c ?u ?v;\n   \\<And>p.\n      Graph.isShortestPath ?c ?u p ?v \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> \\<exists>p. cf.isShortestPath s p t", "unfolding isAugmentingPath_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>Graph.connected ?c ?u ?v;\n   \\<And>p.\n      Graph.isShortestPath ?c ?u p ?v \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cf.isSimplePath s p t \\<Longrightarrow>\n    \\<exists>p. cf.isShortestPath s p t", "by (fastforce simp: Graph.isSimplePath_def Graph.connected_def)"], ["", "lemma (in NFlow) shortest_is_augmenting: \n  \"Graph.isShortestPath cf s p t \\<Longrightarrow> isAugmentingPath p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf.isShortestPath s p t \\<Longrightarrow> isAugmentingPath p", "unfolding isAugmentingPath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cf.isShortestPath s p t \\<Longrightarrow> cf.isSimplePath s p t", "using Graph.shortestPath_is_simple"], ["proof (prove)\nusing this:\n  Graph.isShortestPath ?c ?s ?p ?t \\<Longrightarrow>\n  Graph.isSimplePath ?c ?s ?p ?t\n\ngoal (1 subgoal):\n 1. cf.isShortestPath s p t \\<Longrightarrow> cf.isSimplePath s p t", "by (fastforce)"], ["", "subsection \\<open>Complexity and Termination Analysis\\<close>"], ["", "text \\<open>\n  In this section, we show that the loop iterations of the Edmonds-Karp algorithm\n  are bounded by $O(VE)$.\n\n  The basic idea of the proof is, that a path that\n  takes an edge reverse to an edge on some shortest path \n  cannot be a shortest path itself.\n\n  As augmentation flips at least one edge, this yields a termination argument:\n    After augmentation, either the minimum distance between source and target\n    increases, or it remains the same, but the number of edges that lay on a\n    shortest path decreases. As the minimum distance is bounded by $V$, \n    we get termination within $O(VE)$ loop iterations.\n\\<close>"], ["", "context Graph begin"], ["", "text \\<open>\n  The basic idea is expressed in the following lemma, which, however, \n  is not general enough to be applied for the correctness proof, where\n  we flip more than one edge simultaneously.\n  \\<close>"], ["", "lemma isShortestPath_flip_edge:\n  assumes \"isShortestPath s p t\" \"(u,v)\\<in>set p\"\n  assumes \"isPath s p' t\" \"(v,u)\\<in>set p'\"\n  shows \"length p' \\<ge> length p + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "using assms"], ["proof (prove)\nusing this:\n  isShortestPath s p t\n  (u, v) \\<in> set p\n  isPath s p' t\n  (v, u) \\<in> set p'\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>isShortestPath s p t; (u, v) \\<in> set p; isPath s p' t;\n     (v, u) \\<in> set p'\\<rbrakk>\n    \\<Longrightarrow> length p + 2 \\<le> length p'", "from \\<open>isShortestPath s p t\\<close>"], ["proof (chain)\npicking this:\n  isShortestPath s p t", "have \n    MIN: \"min_dist s t = length p\" and \n      P: \"isPath s p t\" and \n     DV: \"distinct (pathVertices s p)\""], ["proof (prove)\nusing this:\n  isShortestPath s p t\n\ngoal (1 subgoal):\n 1. min_dist s t = length p &&& isPath s p t &&& distinct (pathVertices s p)", "by (auto simp: isShortestPath_alt isSimplePath_def)"], ["proof (state)\nthis:\n  min_dist s t = length p\n  isPath s p t\n  distinct (pathVertices s p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isShortestPath s p t; (u, v) \\<in> set p; isPath s p' t;\n     (v, u) \\<in> set p'\\<rbrakk>\n    \\<Longrightarrow> length p + 2 \\<le> length p'", "from \\<open>(u,v)\\<in>set p\\<close>"], ["proof (chain)\npicking this:\n  (u, v) \\<in> set p", "obtain p1 p2 where [simp]: \"p=p1@(u,v)#p2\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        p = p1 @ (u, v) # p2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  p = p1 @ (u, v) # p2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isShortestPath s p t; (u, v) \\<in> set p; isPath s p' t;\n     (v, u) \\<in> set p'\\<rbrakk>\n    \\<Longrightarrow> length p + 2 \\<le> length p'", "from P DV"], ["proof (chain)\npicking this:\n  isPath s p t\n  distinct (pathVertices s p)", "have [simp]: \"u\\<noteq>v\""], ["proof (prove)\nusing this:\n  isPath s p t\n  distinct (pathVertices s p)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by (cases p2) (auto simp add: isPath_append pathVertices_append)"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isShortestPath s p t; (u, v) \\<in> set p; isPath s p' t;\n     (v, u) \\<in> set p'\\<rbrakk>\n    \\<Longrightarrow> length p + 2 \\<le> length p'", "from P"], ["proof (chain)\npicking this:\n  isPath s p t", "have DISTS: \"dist s (length p1) u\" \"dist u 1 v\" \"dist v (length p2) t\""], ["proof (prove)\nusing this:\n  isPath s p t\n\ngoal (1 subgoal):\n 1. dist s (length p1) u &&& dist u 1 v &&& dist v (length p2) t", "by (auto simp: isPath_append dist_def intro: exI[where x=\"[(u,v)]\"])"], ["proof (state)\nthis:\n  dist s (length p1) u\n  dist u 1 v\n  dist v (length p2) t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isShortestPath s p t; (u, v) \\<in> set p; isPath s p' t;\n     (v, u) \\<in> set p'\\<rbrakk>\n    \\<Longrightarrow> length p + 2 \\<le> length p'", "from MIN"], ["proof (chain)\npicking this:\n  min_dist s t = length p", "have MIN': \"min_dist s t = length p1 + 1 + length p2\""], ["proof (prove)\nusing this:\n  min_dist s t = length p\n\ngoal (1 subgoal):\n 1. min_dist s t = length p1 + 1 + length p2", "by auto"], ["proof (state)\nthis:\n  min_dist s t = length p1 + 1 + length p2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isShortestPath s p t; (u, v) \\<in> set p; isPath s p' t;\n     (v, u) \\<in> set p'\\<rbrakk>\n    \\<Longrightarrow> length p + 2 \\<le> length p'", "from min_dist_split[OF dist_trans[OF DISTS(1,2)] DISTS(3) MIN']"], ["proof (chain)\npicking this:\n  min_dist s v = length p1 + 1\n  min_dist v t = length p2", "have\n    MDSV: \"min_dist s v = length p1 + 1\""], ["proof (prove)\nusing this:\n  min_dist s v = length p1 + 1\n  min_dist v t = length p2\n\ngoal (1 subgoal):\n 1. min_dist s v = length p1 + 1", "by simp"], ["proof (state)\nthis:\n  min_dist s v = length p1 + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isShortestPath s p t; (u, v) \\<in> set p; isPath s p' t;\n     (v, u) \\<in> set p'\\<rbrakk>\n    \\<Longrightarrow> length p + 2 \\<le> length p'", "from min_dist_split[OF DISTS(1) dist_trans[OF DISTS(2,3)]] MIN'"], ["proof (chain)\npicking this:\n  min_dist s t = length p1 + (1 + length p2) \\<Longrightarrow>\n  min_dist s u = length p1\n  min_dist s t = length p1 + (1 + length p2) \\<Longrightarrow>\n  min_dist u t = 1 + length p2\n  min_dist s t = length p1 + 1 + length p2", "have\n    MDUT: \"min_dist u t = 1 + length p2\""], ["proof (prove)\nusing this:\n  min_dist s t = length p1 + (1 + length p2) \\<Longrightarrow>\n  min_dist s u = length p1\n  min_dist s t = length p1 + (1 + length p2) \\<Longrightarrow>\n  min_dist u t = 1 + length p2\n  min_dist s t = length p1 + 1 + length p2\n\ngoal (1 subgoal):\n 1. min_dist u t = 1 + length p2", "by simp"], ["proof (state)\nthis:\n  min_dist u t = 1 + length p2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isShortestPath s p t; (u, v) \\<in> set p; isPath s p' t;\n     (v, u) \\<in> set p'\\<rbrakk>\n    \\<Longrightarrow> length p + 2 \\<le> length p'", "from \\<open>(v,u)\\<in>set p'\\<close>"], ["proof (chain)\npicking this:\n  (v, u) \\<in> set p'", "obtain p1' p2' where [simp]: \"p'=p1'@(v,u)#p2'\""], ["proof (prove)\nusing this:\n  (v, u) \\<in> set p'\n\ngoal (1 subgoal):\n 1. (\\<And>p1' p2'.\n        p' = p1' @ (v, u) # p2' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  p' = p1' @ (v, u) # p2'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isShortestPath s p t; (u, v) \\<in> set p; isPath s p' t;\n     (v, u) \\<in> set p'\\<rbrakk>\n    \\<Longrightarrow> length p + 2 \\<le> length p'", "from \\<open>isPath s p' t\\<close>"], ["proof (chain)\npicking this:\n  isPath s p' t", "have \n    DISTS': \"dist s (length p1') v\" \"dist u (length p2') t\""], ["proof (prove)\nusing this:\n  isPath s p' t\n\ngoal (1 subgoal):\n 1. dist s (length p1') v &&& dist u (length p2') t", "by (auto simp: isPath_append dist_def)"], ["proof (state)\nthis:\n  dist s (length p1') v\n  dist u (length p2') t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isShortestPath s p t; (u, v) \\<in> set p; isPath s p' t;\n     (v, u) \\<in> set p'\\<rbrakk>\n    \\<Longrightarrow> length p + 2 \\<le> length p'", "from DISTS'[THEN min_dist_minD, unfolded MDSV MDUT]"], ["proof (chain)\npicking this:\n  length p1 + 1 \\<le> length p1'\n  1 + length p2 \\<le> length p2'", "show\n    \"length p + 2 \\<le> length p'\""], ["proof (prove)\nusing this:\n  length p1 + 1 \\<le> length p1'\n  1 + length p2 \\<le> length p2'\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "by auto"], ["proof (state)\nthis:\n  length p + 2 \\<le> length p'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  To be used for the analysis of augmentation, we have to generalize the \n  lemma to simultaneous flipping of edges:\n  \\<close>"], ["", "lemma isShortestPath_flip_edges:\n  assumes \"Graph.E c' \\<supseteq> E - edges\" \"Graph.E c' \\<subseteq> E \\<union> (prod.swap`edges)\"\n  assumes SP: \"isShortestPath s p t\" and EDGES_SS: \"edges \\<subseteq> set p\"\n  assumes P': \"Graph.isPath c' s p' t\" \"prod.swap`edges \\<inter> set p' \\<noteq> {}\"\n  shows \"length p + 2 \\<le> length p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "interpret g': Graph c'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "(* TODO: The proof still contains some redundancy: A first flipped edge\n    is searched in both, the induction, and the initialization *)"], ["proof (state)\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "fix u v p1 p2'"], ["proof (state)\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "assume \"(u,v)\\<in>edges\"\n       and \"isPath s p1 v\" and \"g'.isPath u p2' t\""], ["proof (state)\nthis:\n  (u, v) \\<in> edges\n  isPath s p1 v\n  g'.isPath u p2' t\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "hence \"min_dist s t < length p1 + length p2'\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges\n  isPath s p1 v\n  g'.isPath u p2' t\n\ngoal (1 subgoal):\n 1. min_dist s t < length p1 + length p2'", "proof (induction p2' arbitrary: u v p1 rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs u v p1.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       (x, xa) \\<in> edges \\<longrightarrow>\n                       (\\<forall>xb.\n                           isPath s xb xa \\<longrightarrow>\n                           g'.isPath x ys t \\<longrightarrow>\n                           min_dist s t < length xb + length ys));\n        (u, v) \\<in> edges; isPath s p1 v; g'.isPath u xs t\\<rbrakk>\n       \\<Longrightarrow> min_dist s t < length p1 + length xs", "case (1 p2')"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length p2' \\<longrightarrow>\n     (\\<forall>x xa.\n         (x, xa) \\<in> edges \\<longrightarrow>\n         (\\<forall>xb.\n             isPath s xb xa \\<longrightarrow>\n             g'.isPath x ys t \\<longrightarrow>\n             min_dist s t < length xb + length ys))\n  (u, v) \\<in> edges\n  isPath s p1 v\n  g'.isPath u p2' t\n\ngoal (1 subgoal):\n 1. \\<And>xs u v p1.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       (x, xa) \\<in> edges \\<longrightarrow>\n                       (\\<forall>xb.\n                           isPath s xb xa \\<longrightarrow>\n                           g'.isPath x ys t \\<longrightarrow>\n                           min_dist s t < length xb + length ys));\n        (u, v) \\<in> edges; isPath s p1 v; g'.isPath u xs t\\<rbrakk>\n       \\<Longrightarrow> min_dist s t < length p1 + length xs", "note IH = \"1.IH\"[rule_format]"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ys < length p2'; (?x, ?xa) \\<in> edges; isPath s ?xb ?xa;\n   g'.isPath ?x ?ys t\\<rbrakk>\n  \\<Longrightarrow> min_dist s t < length ?xb + length ?ys\n\ngoal (1 subgoal):\n 1. \\<And>xs u v p1.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       (x, xa) \\<in> edges \\<longrightarrow>\n                       (\\<forall>xb.\n                           isPath s xb xa \\<longrightarrow>\n                           g'.isPath x ys t \\<longrightarrow>\n                           min_dist s t < length xb + length ys));\n        (u, v) \\<in> edges; isPath s p1 v; g'.isPath u xs t\\<rbrakk>\n       \\<Longrightarrow> min_dist s t < length p1 + length xs", "note P1 = \\<open>isPath s p1 v\\<close>"], ["proof (state)\nthis:\n  isPath s p1 v\n\ngoal (1 subgoal):\n 1. \\<And>xs u v p1.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       (x, xa) \\<in> edges \\<longrightarrow>\n                       (\\<forall>xb.\n                           isPath s xb xa \\<longrightarrow>\n                           g'.isPath x ys t \\<longrightarrow>\n                           min_dist s t < length xb + length ys));\n        (u, v) \\<in> edges; isPath s p1 v; g'.isPath u xs t\\<rbrakk>\n       \\<Longrightarrow> min_dist s t < length p1 + length xs", "note P2' = \\<open>g'.isPath u p2' t\\<close>"], ["proof (state)\nthis:\n  g'.isPath u p2' t\n\ngoal (1 subgoal):\n 1. \\<And>xs u v p1.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       (x, xa) \\<in> edges \\<longrightarrow>\n                       (\\<forall>xb.\n                           isPath s xb xa \\<longrightarrow>\n                           g'.isPath x ys t \\<longrightarrow>\n                           min_dist s t < length xb + length ys));\n        (u, v) \\<in> edges; isPath s p1 v; g'.isPath u xs t\\<rbrakk>\n       \\<Longrightarrow> min_dist s t < length p1 + length xs", "have \"length p1 > min_dist s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_dist s u < length p1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. min_dist s u < length p1", "from P1"], ["proof (chain)\npicking this:\n  isPath s p1 v", "have \"length p1 \\<ge> min_dist s v\""], ["proof (prove)\nusing this:\n  isPath s p1 v\n\ngoal (1 subgoal):\n 1. min_dist s v \\<le> length p1", "using min_dist_minD"], ["proof (prove)\nusing this:\n  isPath s p1 v\n  dist ?v ?d ?v' \\<Longrightarrow> min_dist ?v ?v' \\<le> ?d\n\ngoal (1 subgoal):\n 1. min_dist s v \\<le> length p1", "by (auto simp: dist_def)"], ["proof (state)\nthis:\n  min_dist s v \\<le> length p1\n\ngoal (1 subgoal):\n 1. min_dist s u < length p1", "moreover"], ["proof (state)\nthis:\n  min_dist s v \\<le> length p1\n\ngoal (1 subgoal):\n 1. min_dist s u < length p1", "from \\<open>(u,v)\\<in>edges\\<close> EDGES_SS"], ["proof (chain)\npicking this:\n  (u, v) \\<in> edges\n  edges \\<subseteq> set p", "have \"min_dist s v = Suc (min_dist s u)\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges\n  edges \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. min_dist s v = Suc (min_dist s u)", "using isShortestPath_level_edge[OF SP]"], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges\n  edges \\<subseteq> set p\n  (?u, ?v) \\<in> set p \\<Longrightarrow> connected s ?u\n  (?u, ?v) \\<in> set p \\<Longrightarrow> connected ?u ?v\n  (?u, ?v) \\<in> set p \\<Longrightarrow> connected ?v t\n  (?u, ?v) \\<in> set p \\<Longrightarrow> min_dist s ?v = min_dist s ?u + 1\n  (?u, ?v) \\<in> set p \\<Longrightarrow> min_dist ?u t = 1 + min_dist ?v t\n  (?u, ?v) \\<in> set p \\<Longrightarrow>\n  min_dist s t = min_dist s ?u + 1 + min_dist ?v t\n\ngoal (1 subgoal):\n 1. min_dist s v = Suc (min_dist s u)", "by auto"], ["proof (state)\nthis:\n  min_dist s v = Suc (min_dist s u)\n\ngoal (1 subgoal):\n 1. min_dist s u < length p1", "ultimately"], ["proof (chain)\npicking this:\n  min_dist s v \\<le> length p1\n  min_dist s v = Suc (min_dist s u)", "show ?thesis"], ["proof (prove)\nusing this:\n  min_dist s v \\<le> length p1\n  min_dist s v = Suc (min_dist s u)\n\ngoal (1 subgoal):\n 1. min_dist s u < length p1", "by auto"], ["proof (state)\nthis:\n  min_dist s u < length p1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min_dist s u < length p1\n\ngoal (1 subgoal):\n 1. \\<And>xs u v p1.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       (x, xa) \\<in> edges \\<longrightarrow>\n                       (\\<forall>xb.\n                           isPath s xb xa \\<longrightarrow>\n                           g'.isPath x ys t \\<longrightarrow>\n                           min_dist s t < length xb + length ys));\n        (u, v) \\<in> edges; isPath s p1 v; g'.isPath u xs t\\<rbrakk>\n       \\<Longrightarrow> min_dist s t < length p1 + length xs", "from isShortestPath_level_edge[OF SP] \\<open>(u,v)\\<in>edges\\<close> EDGES_SS"], ["proof (chain)\npicking this:\n  (?u, ?v) \\<in> set p \\<Longrightarrow> connected s ?u\n  (?u, ?v) \\<in> set p \\<Longrightarrow> connected ?u ?v\n  (?u, ?v) \\<in> set p \\<Longrightarrow> connected ?v t\n  (?u, ?v) \\<in> set p \\<Longrightarrow> min_dist s ?v = min_dist s ?u + 1\n  (?u, ?v) \\<in> set p \\<Longrightarrow> min_dist ?u t = 1 + min_dist ?v t\n  (?u, ?v) \\<in> set p \\<Longrightarrow>\n  min_dist s t = min_dist s ?u + 1 + min_dist ?v t\n  (u, v) \\<in> edges\n  edges \\<subseteq> set p", "have \n            \"min_dist s t = min_dist s u + min_dist u t\" \n        and \"connected s u\""], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> set p \\<Longrightarrow> connected s ?u\n  (?u, ?v) \\<in> set p \\<Longrightarrow> connected ?u ?v\n  (?u, ?v) \\<in> set p \\<Longrightarrow> connected ?v t\n  (?u, ?v) \\<in> set p \\<Longrightarrow> min_dist s ?v = min_dist s ?u + 1\n  (?u, ?v) \\<in> set p \\<Longrightarrow> min_dist ?u t = 1 + min_dist ?v t\n  (?u, ?v) \\<in> set p \\<Longrightarrow>\n  min_dist s t = min_dist s ?u + 1 + min_dist ?v t\n  (u, v) \\<in> edges\n  edges \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. min_dist s t = min_dist s u + min_dist u t &&& connected s u", "by auto"], ["proof (state)\nthis:\n  min_dist s t = min_dist s u + min_dist u t\n  connected s u\n\ngoal (1 subgoal):\n 1. \\<And>xs u v p1.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       (x, xa) \\<in> edges \\<longrightarrow>\n                       (\\<forall>xb.\n                           isPath s xb xa \\<longrightarrow>\n                           g'.isPath x ys t \\<longrightarrow>\n                           min_dist s t < length xb + length ys));\n        (u, v) \\<in> edges; isPath s p1 v; g'.isPath u xs t\\<rbrakk>\n       \\<Longrightarrow> min_dist s t < length p1 + length xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_dist s t < length p1 + length p2'", "proof (cases \"prod.swap`edges \\<inter> set p2' = {}\")\n        \\<comment> \\<open>We proceed by a case distinction whether the suffix path contains swapped edges\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. prod.swap ` edges \\<inter> set p2' = {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'\n 2. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "case True"], ["proof (state)\nthis:\n  prod.swap ` edges \\<inter> set p2' = {}\n\ngoal (2 subgoals):\n 1. prod.swap ` edges \\<inter> set p2' = {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'\n 2. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "with g'.transfer_path[OF _ P2', of c] \\<open>g'.E \\<subseteq> E \\<union> prod.swap ` edges\\<close>"], ["proof (chain)\npicking this:\n  set p2' \\<inter> g'.E \\<subseteq> E \\<Longrightarrow> isPath u p2' t\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p2' = {}", "have \"isPath u p2' t\""], ["proof (prove)\nusing this:\n  set p2' \\<inter> g'.E \\<subseteq> E \\<Longrightarrow> isPath u p2' t\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p2' = {}\n\ngoal (1 subgoal):\n 1. isPath u p2' t", "by auto"], ["proof (state)\nthis:\n  isPath u p2' t\n\ngoal (2 subgoals):\n 1. prod.swap ` edges \\<inter> set p2' = {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'\n 2. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "hence \"length p2' \\<ge> min_dist u t\""], ["proof (prove)\nusing this:\n  isPath u p2' t\n\ngoal (1 subgoal):\n 1. min_dist u t \\<le> length p2'", "using min_dist_minD"], ["proof (prove)\nusing this:\n  isPath u p2' t\n  dist ?v ?d ?v' \\<Longrightarrow> min_dist ?v ?v' \\<le> ?d\n\ngoal (1 subgoal):\n 1. min_dist u t \\<le> length p2'", "by (auto simp: dist_def)"], ["proof (state)\nthis:\n  min_dist u t \\<le> length p2'\n\ngoal (2 subgoals):\n 1. prod.swap ` edges \\<inter> set p2' = {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'\n 2. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "moreover"], ["proof (state)\nthis:\n  min_dist u t \\<le> length p2'\n\ngoal (2 subgoals):\n 1. prod.swap ` edges \\<inter> set p2' = {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'\n 2. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "note \\<open>length p1 > min_dist s u\\<close>"], ["proof (state)\nthis:\n  min_dist s u < length p1\n\ngoal (2 subgoals):\n 1. prod.swap ` edges \\<inter> set p2' = {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'\n 2. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "moreover"], ["proof (state)\nthis:\n  min_dist s u < length p1\n\ngoal (2 subgoals):\n 1. prod.swap ` edges \\<inter> set p2' = {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'\n 2. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "note \\<open>min_dist s t = min_dist s u + min_dist u t\\<close>"], ["proof (state)\nthis:\n  min_dist s t = min_dist s u + min_dist u t\n\ngoal (2 subgoals):\n 1. prod.swap ` edges \\<inter> set p2' = {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'\n 2. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "ultimately"], ["proof (chain)\npicking this:\n  min_dist u t \\<le> length p2'\n  min_dist s u < length p1\n  min_dist s t = min_dist s u + min_dist u t", "show ?thesis"], ["proof (prove)\nusing this:\n  min_dist u t \\<le> length p2'\n  min_dist s u < length p1\n  min_dist s t = min_dist s u + min_dist u t\n\ngoal (1 subgoal):\n 1. min_dist s t < length p1 + length p2'", "by auto"], ["proof (state)\nthis:\n  min_dist s t < length p1 + length p2'\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "case False\n        \\<comment> \\<open>Obtain first swapped edge on suffix path\\<close>"], ["proof (state)\nthis:\n  prod.swap ` edges \\<inter> set p2' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "obtain p21' e' p22' where [simp]: \"p2'=p21'@e'#p22'\" and \n           E_IN_EDGES: \"e'\\<in>prod.swap`edges\" and \n          P1_NO_EDGES: \"prod.swap`edges \\<inter> set p21' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p21' e' p22'.\n        \\<lbrakk>p2' = p21' @ e' # p22'; e' \\<in> prod.swap ` edges;\n         prod.swap ` edges \\<inter> set p21' = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule split_list_first_propE[of p2' \"\\<lambda>e. e\\<in>prod.swap`edges\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>p21' e' p22'.\n        \\<lbrakk>p2' = p21' @ e' # p22'; e' \\<in> prod.swap ` edges;\n         prod.swap ` edges \\<inter> set p21' = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>x\\<in>set p2'. x \\<in> prod.swap ` edges\n 2. \\<And>ys x zs.\n       \\<lbrakk>\\<And>p21' e' p22'.\n                   \\<lbrakk>p2' = p21' @ e' # p22';\n                    e' \\<in> prod.swap ` edges;\n                    prod.swap ` edges \\<inter> set p21' = {}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p2' = ys @ x # zs; x \\<in> prod.swap ` edges;\n        \\<forall>y\\<in>set ys. y \\<notin> prod.swap ` edges\\<rbrakk>\n       \\<Longrightarrow> thesis", "using \\<open>prod.swap ` edges \\<inter> set p2' \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  prod.swap ` edges \\<inter> set p2' \\<noteq> {}\n\ngoal (2 subgoals):\n 1. (\\<And>p21' e' p22'.\n        \\<lbrakk>p2' = p21' @ e' # p22'; e' \\<in> prod.swap ` edges;\n         prod.swap ` edges \\<inter> set p21' = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>x\\<in>set p2'. x \\<in> prod.swap ` edges\n 2. \\<And>ys x zs.\n       \\<lbrakk>\\<And>p21' e' p22'.\n                   \\<lbrakk>p2' = p21' @ e' # p22';\n                    e' \\<in> prod.swap ` edges;\n                    prod.swap ` edges \\<inter> set p21' = {}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p2' = ys @ x # zs; x \\<in> prod.swap ` edges;\n        \\<forall>y\\<in>set ys. y \\<notin> prod.swap ` edges\\<rbrakk>\n       \\<Longrightarrow> thesis", "by fastforce+"], ["proof (state)\nthis:\n  p2' = p21' @ e' # p22'\n  e' \\<in> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p21' = {}\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "obtain u' v' where [simp]: \"e'=(v',u')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v' u'. e' = (v', u') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e')      \n  \n        \\<comment> \\<open>Split the suffix path accordingly\\<close>"], ["proof (state)\nthis:\n  e' = (v', u')\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "from P2'"], ["proof (chain)\npicking this:\n  g'.isPath u p2' t", "have P21': \"g'.isPath u p21' v'\" and P22': \"g'.isPath u' p22' t\""], ["proof (prove)\nusing this:\n  g'.isPath u p2' t\n\ngoal (1 subgoal):\n 1. g'.isPath u p21' v' &&& g'.isPath u' p22' t", "by (auto simp: g'.isPath_append)\n        \\<comment> \\<open>As we chose the first edge, the prefix of the suffix path is also a path in the original graph\\<close>"], ["proof (state)\nthis:\n  g'.isPath u p21' v'\n  g'.isPath u' p22' t\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "from \n          g'.transfer_path[OF _ P21', of c] \n          \\<open>g'.E \\<subseteq> E \\<union> prod.swap ` edges\\<close> \n          P1_NO_EDGES"], ["proof (chain)\npicking this:\n  set p21' \\<inter> g'.E \\<subseteq> E \\<Longrightarrow> isPath u p21' v'\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p21' = {}", "have P21: \"isPath u p21' v'\""], ["proof (prove)\nusing this:\n  set p21' \\<inter> g'.E \\<subseteq> E \\<Longrightarrow> isPath u p21' v'\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p21' = {}\n\ngoal (1 subgoal):\n 1. isPath u p21' v'", "by auto"], ["proof (state)\nthis:\n  isPath u p21' v'\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "from min_dist_is_dist[OF \\<open>connected s u\\<close>]"], ["proof (chain)\npicking this:\n  dist s (min_dist s u) u", "obtain psu where \n              PSU: \"isPath s psu u\" and \n          LEN_PSU: \"length psu = min_dist s u\""], ["proof (prove)\nusing this:\n  dist s (min_dist s u) u\n\ngoal (1 subgoal):\n 1. (\\<And>psu.\n        \\<lbrakk>isPath s psu u; length psu = min_dist s u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: dist_def)"], ["proof (state)\nthis:\n  isPath s psu u\n  length psu = min_dist s u\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "from PSU P21"], ["proof (chain)\npicking this:\n  isPath s psu u\n  isPath u p21' v'", "have P1n: \"isPath s (psu@p21') v'\""], ["proof (prove)\nusing this:\n  isPath s psu u\n  isPath u p21' v'\n\ngoal (1 subgoal):\n 1. isPath s (psu @ p21') v'", "by (auto simp: isPath_append)"], ["proof (state)\nthis:\n  isPath s (psu @ p21') v'\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "from IH[OF _ _ P1n P22'] E_IN_EDGES"], ["proof (chain)\npicking this:\n  \\<lbrakk>length p22' < length p2'; (u', v') \\<in> edges\\<rbrakk>\n  \\<Longrightarrow> min_dist s t < length (psu @ p21') + length p22'\n  e' \\<in> prod.swap ` edges", "have \n          \"min_dist s t < length psu + length p21' + length p22'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length p22' < length p2'; (u', v') \\<in> edges\\<rbrakk>\n  \\<Longrightarrow> min_dist s t < length (psu @ p21') + length p22'\n  e' \\<in> prod.swap ` edges\n\ngoal (1 subgoal):\n 1. min_dist s t < length psu + length p21' + length p22'", "by auto"], ["proof (state)\nthis:\n  min_dist s t < length psu + length p21' + length p22'\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "moreover"], ["proof (state)\nthis:\n  min_dist s t < length psu + length p21' + length p22'\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "note \\<open>length p1 > min_dist s u\\<close>"], ["proof (state)\nthis:\n  min_dist s u < length p1\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p2' \\<noteq> {} \\<Longrightarrow>\n    min_dist s t < length p1 + length p2'", "ultimately"], ["proof (chain)\npicking this:\n  min_dist s t < length psu + length p21' + length p22'\n  min_dist s u < length p1", "show ?thesis"], ["proof (prove)\nusing this:\n  min_dist s t < length psu + length p21' + length p22'\n  min_dist s u < length p1\n\ngoal (1 subgoal):\n 1. min_dist s t < length p1 + length p2'", "by (auto simp: LEN_PSU)"], ["proof (state)\nthis:\n  min_dist s t < length p1 + length p2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min_dist s t < length p1 + length p2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min_dist s t < length p1 + length p2'\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?u2, ?v2) \\<in> edges; isPath s ?p1.2 ?v2;\n   g'.isPath ?u2 ?p2'2 t\\<rbrakk>\n  \\<Longrightarrow> min_dist s t < length ?p1.2 + length ?p2'2\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "note aux=this\n\n  (* TODO: This step is analogous to what we do in the False-case of the induction.\n    Can we somehow remove the redundancy? *)\n  \\<comment> \\<open>Obtain first swapped edge on path\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>(?u2, ?v2) \\<in> edges; isPath s ?p1.2 ?v2;\n   g'.isPath ?u2 ?p2'2 t\\<rbrakk>\n  \\<Longrightarrow> min_dist s t < length ?p1.2 + length ?p2'2\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "obtain p1' e p2' where [simp]: \"p'=p1'@e#p2'\" and \n    E_IN_EDGES: \"e\\<in>prod.swap`edges\" and \n    P1_NO_EDGES: \"prod.swap`edges \\<inter> set p1' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1' e p2'.\n        \\<lbrakk>p' = p1' @ e # p2'; e \\<in> prod.swap ` edges;\n         prod.swap ` edges \\<inter> set p1' = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule split_list_first_propE[of p' \"\\<lambda>e. e\\<in>prod.swap`edges\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>p1' e p2'.\n        \\<lbrakk>p' = p1' @ e # p2'; e \\<in> prod.swap ` edges;\n         prod.swap ` edges \\<inter> set p1' = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>x\\<in>set p'. x \\<in> prod.swap ` edges\n 2. \\<And>ys x zs.\n       \\<lbrakk>\\<And>p1' e p2'.\n                   \\<lbrakk>p' = p1' @ e # p2'; e \\<in> prod.swap ` edges;\n                    prod.swap ` edges \\<inter> set p1' = {}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p' = ys @ x # zs; x \\<in> prod.swap ` edges;\n        \\<forall>y\\<in>set ys. y \\<notin> prod.swap ` edges\\<rbrakk>\n       \\<Longrightarrow> thesis", "using \\<open>prod.swap ` edges \\<inter> set p' \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  prod.swap ` edges \\<inter> set p' \\<noteq> {}\n\ngoal (2 subgoals):\n 1. (\\<And>p1' e p2'.\n        \\<lbrakk>p' = p1' @ e # p2'; e \\<in> prod.swap ` edges;\n         prod.swap ` edges \\<inter> set p1' = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>x\\<in>set p'. x \\<in> prod.swap ` edges\n 2. \\<And>ys x zs.\n       \\<lbrakk>\\<And>p1' e p2'.\n                   \\<lbrakk>p' = p1' @ e # p2'; e \\<in> prod.swap ` edges;\n                    prod.swap ` edges \\<inter> set p1' = {}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p' = ys @ x # zs; x \\<in> prod.swap ` edges;\n        \\<forall>y\\<in>set ys. y \\<notin> prod.swap ` edges\\<rbrakk>\n       \\<Longrightarrow> thesis", "by fastforce+"], ["proof (state)\nthis:\n  p' = p1' @ e # p2'\n  e \\<in> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p1' = {}\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "obtain u v where [simp]: \"e=(v,u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v u. e = (v, u) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e)      \n\n  \\<comment> \\<open>Split the new path accordingly\\<close>"], ["proof (state)\nthis:\n  e = (v, u)\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "from \\<open>g'.isPath s p' t\\<close>"], ["proof (chain)\npicking this:\n  g'.isPath s p' t", "have \n    P1': \"g'.isPath s p1' v\" and \n    P2': \"g'.isPath u p2' t\""], ["proof (prove)\nusing this:\n  g'.isPath s p' t\n\ngoal (1 subgoal):\n 1. g'.isPath s p1' v &&& g'.isPath u p2' t", "by (auto simp: g'.isPath_append)\n  \\<comment> \\<open>As we chose the first edge, the prefix of the path is also a path in the original graph\\<close>"], ["proof (state)\nthis:\n  g'.isPath s p1' v\n  g'.isPath u p2' t\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "from \n    g'.transfer_path[OF _ P1', of c] \n    \\<open>g'.E \\<subseteq> E \\<union> prod.swap ` edges\\<close> \n    P1_NO_EDGES"], ["proof (chain)\npicking this:\n  set p1' \\<inter> g'.E \\<subseteq> E \\<Longrightarrow> isPath s p1' v\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p1' = {}", "have P1: \"isPath s p1' v\""], ["proof (prove)\nusing this:\n  set p1' \\<inter> g'.E \\<subseteq> E \\<Longrightarrow> isPath s p1' v\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p1' = {}\n\ngoal (1 subgoal):\n 1. isPath s p1' v", "by auto"], ["proof (state)\nthis:\n  isPath s p1' v\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "from aux[OF _ P1 P2'] E_IN_EDGES"], ["proof (chain)\npicking this:\n  (u, v) \\<in> edges \\<Longrightarrow>\n  min_dist s t < length p1' + length p2'\n  e \\<in> prod.swap ` edges", "have \"min_dist s t < length p1' + length p2'\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> edges \\<Longrightarrow>\n  min_dist s t < length p1' + length p2'\n  e \\<in> prod.swap ` edges\n\ngoal (1 subgoal):\n 1. min_dist s t < length p1' + length p2'", "by auto"], ["proof (state)\nthis:\n  min_dist s t < length p1' + length p2'\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "thus ?thesis"], ["proof (prove)\nusing this:\n  min_dist s t < length p1' + length p2'\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "using SP"], ["proof (prove)\nusing this:\n  min_dist s t < length p1' + length p2'\n  isShortestPath s p t\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "by (auto simp: isShortestPath_min_dist_def)"], ["proof (state)\nthis:\n  length p + 2 \\<le> length p'\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Graph\\<close>"], ["", "text \\<open>We outsource the more specific lemmas to their own locale, \n  to prevent name space pollution\\<close>"], ["", "locale ek_analysis_defs = Graph +\n  fixes s t :: node"], ["", "locale ek_analysis = ek_analysis_defs + Finite_Graph\nbegin"], ["", "definition (in ek_analysis_defs) \n  \"spEdges \\<equiv> {e. \\<exists>p. e\\<in>set p \\<and> isShortestPath s p t}\""], ["", "lemma spEdges_ss_E: \"spEdges \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spEdges \\<subseteq> E", "using isPath_edgeset"], ["proof (prove)\nusing this:\n  \\<lbrakk>isPath ?u ?p ?v; ?e \\<in> set ?p\\<rbrakk>\n  \\<Longrightarrow> ?e \\<in> E\n\ngoal (1 subgoal):\n 1. spEdges \\<subseteq> E", "unfolding spEdges_def isShortestPath_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>isPath ?u ?p ?v; ?e \\<in> set ?p\\<rbrakk>\n  \\<Longrightarrow> ?e \\<in> E\n\ngoal (1 subgoal):\n 1. {e. \\<exists>p.\n           e \\<in> set p \\<and>\n           isPath s p t \\<and>\n           (\\<forall>p'.\n               isPath s p' t \\<longrightarrow> length p \\<le> length p')}\n    \\<subseteq> E", "by auto"], ["", "lemma finite_spEdges[simp, intro]: \"finite (spEdges)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite spEdges", "using finite_subset[OF spEdges_ss_E]"], ["proof (prove)\nusing this:\n  finite E \\<Longrightarrow> finite spEdges\n\ngoal (1 subgoal):\n 1. finite spEdges", "by blast"], ["", "definition (in ek_analysis_defs) \"uE \\<equiv> E \\<union> E\\<inverse>\""], ["", "lemma finite_uE[simp,intro]: \"finite uE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite uE", "by (auto simp: uE_def)"], ["", "lemma E_ss_uE: \"E\\<subseteq>uE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<subseteq> uE", "by (auto simp: uE_def)"], ["", "lemma card_spEdges_le:\n  shows \"card spEdges \\<le> card uE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card spEdges \\<le> card uE", "apply (rule card_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite uE\n 2. spEdges \\<subseteq> uE", "apply (auto simp: order_trans[OF spEdges_ss_E E_ss_uE])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma card_spEdges_less:\n  shows \"card spEdges < card uE + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card spEdges < card uE + 1", "using card_spEdges_le"], ["proof (prove)\nusing this:\n  card spEdges \\<le> card uE\n\ngoal (1 subgoal):\n 1. card spEdges < card uE + 1", "by auto"], ["", "definition (in ek_analysis_defs) \"ekMeasure \\<equiv> \n  if (connected s t) then\n    (card V - min_dist s t) * (card uE + 1) + (card (spEdges))\n  else 0\""], ["", "lemma measure_decr:\n  assumes SV: \"s\\<in>V\"\n  assumes SP: \"isShortestPath s p t\"\n  assumes SP_EDGES: \"edges\\<subseteq>set p\"\n  assumes Ebounds: \n    \"Graph.E c' \\<supseteq> E - edges \\<union> prod.swap`edges\" \n    \"Graph.E c' \\<subseteq> E \\<union> prod.swap`edges\"\n  shows \"ek_analysis_defs.ekMeasure c' s t \\<le> ekMeasure\"\n    and \"edges - Graph.E c' \\<noteq> {} \n         \\<Longrightarrow> ek_analysis_defs.ekMeasure c' s t < ekMeasure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ek_analysis_defs.ekMeasure c' s t \\<le> ekMeasure &&&\n    (edges - Graph.E c' \\<noteq> {} \\<Longrightarrow>\n     ek_analysis_defs.ekMeasure c' s t < ekMeasure)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ek_analysis_defs.ekMeasure c' s t \\<le> ekMeasure\n 2. edges - Graph.E c' \\<noteq> {} \\<Longrightarrow>\n    ek_analysis_defs.ekMeasure c' s t < ekMeasure", "interpret g': ek_analysis_defs c' s t"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "interpret g': ek_analysis c' s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. ek_analysis c'", "apply intro_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Graph c'", "apply (rule g'.Finite_Graph_EI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite g'.E", "using finite_subset[OF Ebounds(2)] finite_subset[OF SP_EDGES]"], ["proof (prove)\nusing this:\n  finite (E \\<union> prod.swap ` edges) \\<Longrightarrow> finite g'.E\n  finite (set p) \\<Longrightarrow> finite edges\n\ngoal (1 subgoal):\n 1. finite g'.E", "by auto"], ["proof (state)\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "from SP_EDGES SP"], ["proof (chain)\npicking this:\n  edges \\<subseteq> set p\n  isShortestPath s p t", "have \"edges \\<subseteq> E\""], ["proof (prove)\nusing this:\n  edges \\<subseteq> set p\n  isShortestPath s p t\n\ngoal (1 subgoal):\n 1. edges \\<subseteq> E", "by (auto simp: spEdges_def isShortestPath_def dest: isPath_edgeset)"], ["proof (state)\nthis:\n  edges \\<subseteq> E\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "with Ebounds"], ["proof (chain)\npicking this:\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  edges \\<subseteq> E", "have Veq[simp]: \"Graph.V c' = V\""], ["proof (prove)\nusing this:\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  edges \\<subseteq> E\n\ngoal (1 subgoal):\n 1. g'.V = V", "by (force simp: Graph.V_def)"], ["proof (state)\nthis:\n  g'.V = V\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "from Ebounds \\<open>edges \\<subseteq> E\\<close>"], ["proof (chain)\npicking this:\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  edges \\<subseteq> E", "have uE_eq[simp]: \"g'.uE = uE\""], ["proof (prove)\nusing this:\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  edges \\<subseteq> E\n\ngoal (1 subgoal):\n 1. g'.uE = uE", "by (force simp: ek_analysis_defs.uE_def)"], ["proof (state)\nthis:\n  g'.uE = uE\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "from SP"], ["proof (chain)\npicking this:\n  isShortestPath s p t", "have LENP: \"length p = min_dist s t\""], ["proof (prove)\nusing this:\n  isShortestPath s p t\n\ngoal (1 subgoal):\n 1. length p = min_dist s t", "by (auto simp: isShortestPath_min_dist_def)"], ["proof (state)\nthis:\n  length p = min_dist s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "from SP"], ["proof (chain)\npicking this:\n  isShortestPath s p t", "have CONN: \"connected s t\""], ["proof (prove)\nusing this:\n  isShortestPath s p t\n\ngoal (1 subgoal):\n 1. connected s t", "by (auto simp: isShortestPath_def connected_def)"], ["proof (state)\nthis:\n  connected s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "{"], ["proof (state)\nthis:\n  connected s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume NCONN2: \"\\<not>g'.connected s t\""], ["proof (state)\nthis:\n  \\<not> g'.connected s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "hence \"s\\<noteq>t\""], ["proof (prove)\nusing this:\n  \\<not> g'.connected s t\n\ngoal (1 subgoal):\n 1. s \\<noteq> t", "by auto"], ["proof (state)\nthis:\n  s \\<noteq> t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "with CONN NCONN2"], ["proof (chain)\npicking this:\n  connected s t\n  \\<not> g'.connected s t\n  s \\<noteq> t", "have \"g'.ekMeasure < ekMeasure\""], ["proof (prove)\nusing this:\n  connected s t\n  \\<not> g'.connected s t\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. g'.ekMeasure < ekMeasure", "unfolding g'.ekMeasure_def ekMeasure_def"], ["proof (prove)\nusing this:\n  connected s t\n  \\<not> g'.connected s t\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. (if g'.connected s t\n     then (card g'.V - g'.min_dist s t) * (card g'.uE + 1) + card g'.spEdges\n     else 0)\n    < (if connected s t\n       then (card V - min_dist s t) * (card uE + 1) + card spEdges else 0)", "using min_dist_less_V[OF SV]"], ["proof (prove)\nusing this:\n  connected s t\n  \\<not> g'.connected s t\n  s \\<noteq> t\n  connected s ?t \\<Longrightarrow> min_dist s ?t < card V\n\ngoal (1 subgoal):\n 1. (if g'.connected s t\n     then (card g'.V - g'.min_dist s t) * (card g'.uE + 1) + card g'.spEdges\n     else 0)\n    < (if connected s t\n       then (card V - min_dist s t) * (card uE + 1) + card spEdges else 0)", "by auto"], ["proof (state)\nthis:\n  g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "}"], ["proof (state)\nthis:\n  \\<not> g'.connected s t \\<Longrightarrow> g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "moreover"], ["proof (state)\nthis:\n  \\<not> g'.connected s t \\<Longrightarrow> g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "{"], ["proof (state)\nthis:\n  \\<not> g'.connected s t \\<Longrightarrow> g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume SHORTER: \"g'.min_dist s t < min_dist s t\""], ["proof (state)\nthis:\n  g'.min_dist s t < min_dist s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume CONN2: \"g'.connected s t\"\n\n    \\<comment> \\<open>Obtain a shorter path in $g'$\\<close>"], ["proof (state)\nthis:\n  g'.connected s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "from g'.min_dist_is_dist[OF CONN2]"], ["proof (chain)\npicking this:\n  g'.dist s (g'.min_dist s t) t", "obtain p' where\n      P': \"g'.isPath s p' t\" and LENP': \"length p' = g'.min_dist s t\""], ["proof (prove)\nusing this:\n  g'.dist s (g'.min_dist s t) t\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>g'.isPath s p' t; length p' = g'.min_dist s t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: g'.dist_def)"], ["proof (state)\nthis:\n  g'.isPath s p' t\n  length p' = g'.min_dist s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "{ \\<comment> \\<open>Case: It does not use @{term \"prod.swap`edges\"}. \n        Then it is also a path in $g$, which is shorter than \n        the shortest path in $g$, yielding a contradiction.\\<close>"], ["proof (state)\nthis:\n  g'.isPath s p' t\n  length p' = g'.min_dist s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume \"prod.swap`edges \\<inter> set p' = {}\""], ["proof (state)\nthis:\n  prod.swap ` edges \\<inter> set p' = {}\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "with g'.transfer_path[OF _ P', of c] Ebounds"], ["proof (chain)\npicking this:\n  set p' \\<inter> g'.E \\<subseteq> E \\<Longrightarrow> isPath s p' t\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p' = {}", "have \"dist s (length p') t\""], ["proof (prove)\nusing this:\n  set p' \\<inter> g'.E \\<subseteq> E \\<Longrightarrow> isPath s p' t\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p' = {}\n\ngoal (1 subgoal):\n 1. dist s (length p') t", "by (auto simp: dist_def)"], ["proof (state)\nthis:\n  dist s (length p') t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "from LENP' SHORTER min_dist_minD[OF this]"], ["proof (chain)\npicking this:\n  length p' = g'.min_dist s t\n  g'.min_dist s t < min_dist s t\n  min_dist s t \\<le> length p'", "have False"], ["proof (prove)\nusing this:\n  length p' = g'.min_dist s t\n  g'.min_dist s t < min_dist s t\n  min_dist s t \\<le> length p'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "}"], ["proof (state)\nthis:\n  prod.swap ` edges \\<inter> set p' = {} \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "moreover"], ["proof (state)\nthis:\n  prod.swap ` edges \\<inter> set p' = {} \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "{\n      \\<comment> \\<open>So assume the path uses the edge @{term \"prod.swap e\"}.\\<close>"], ["proof (state)\nthis:\n  prod.swap ` edges \\<inter> set p' = {} \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume \"prod.swap`edges \\<inter> set p' \\<noteq> {}\"\n      \\<comment> \\<open>Due to auxiliary lemma, those path must be longer\\<close>"], ["proof (state)\nthis:\n  prod.swap ` edges \\<inter> set p' \\<noteq> {}\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "from isShortestPath_flip_edges[OF _ _ SP SP_EDGES P' this] Ebounds"], ["proof (chain)\npicking this:\n  \\<lbrakk>E - edges \\<subseteq> g'.E;\n   g'.E \\<subseteq> E \\<union> prod.swap ` edges\\<rbrakk>\n  \\<Longrightarrow> length p + 2 \\<le> length p'\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges", "have \"length p' > length p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>E - edges \\<subseteq> g'.E;\n   g'.E \\<subseteq> E \\<union> prod.swap ` edges\\<rbrakk>\n  \\<Longrightarrow> length p + 2 \\<le> length p'\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n\ngoal (1 subgoal):\n 1. length p < length p'", "by auto"], ["proof (state)\nthis:\n  length p < length p'\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "with SHORTER LENP LENP'"], ["proof (chain)\npicking this:\n  g'.min_dist s t < min_dist s t\n  length p = min_dist s t\n  length p' = g'.min_dist s t\n  length p < length p'", "have False"], ["proof (prove)\nusing this:\n  g'.min_dist s t < min_dist s t\n  length p = min_dist s t\n  length p' = g'.min_dist s t\n  length p < length p'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "}"], ["proof (state)\nthis:\n  prod.swap ` edges \\<inter> set p' \\<noteq> {} \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "ultimately"], ["proof (chain)\npicking this:\n  prod.swap ` edges \\<inter> set p' = {} \\<Longrightarrow> False\n  prod.swap ` edges \\<inter> set p' \\<noteq> {} \\<Longrightarrow> False", "have False"], ["proof (prove)\nusing this:\n  prod.swap ` edges \\<inter> set p' = {} \\<Longrightarrow> False\n  prod.swap ` edges \\<inter> set p' \\<noteq> {} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g'.min_dist s t < min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>g'.min_dist s t < min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "{"], ["proof (state)\nthis:\n  \\<lbrakk>g'.min_dist s t < min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume LONGER: \"g'.min_dist s t > min_dist s t\""], ["proof (state)\nthis:\n  min_dist s t < g'.min_dist s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume CONN2: \"g'.connected s t\""], ["proof (state)\nthis:\n  g'.connected s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "have \"g'.ekMeasure < ekMeasure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g'.ekMeasure < ekMeasure", "unfolding g'.ekMeasure_def ekMeasure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if g'.connected s t\n     then (card g'.V - g'.min_dist s t) * (card g'.uE + 1) + card g'.spEdges\n     else 0)\n    < (if connected s t\n       then (card V - min_dist s t) * (card uE + 1) + card spEdges else 0)", "apply (simp only: Veq uE_eq CONN CONN2 if_True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (card V - g'.min_dist s t) * (card uE + 1) + card g'.spEdges\n    < (card V - min_dist s t) * (card uE + 1) + card spEdges", "apply (rule mlex_fst_decrI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. card V - g'.min_dist s t < card V - min_dist s t\n 2. card g'.spEdges < card uE + 1\n 3. card spEdges < card uE + 1", "using card_spEdges_less g'.card_spEdges_less \n        and g'.min_dist_less_V[OF _ CONN2] SV\n        and LONGER"], ["proof (prove)\nusing this:\n  card spEdges < card uE + 1\n  card g'.spEdges < card g'.uE + 1\n  s \\<in> g'.V \\<Longrightarrow> g'.min_dist s t < card g'.V\n  s \\<in> V\n  min_dist s t < g'.min_dist s t\n\ngoal (3 subgoals):\n 1. card V - g'.min_dist s t < card V - min_dist s t\n 2. card g'.spEdges < card uE + 1\n 3. card spEdges < card uE + 1", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "}"], ["proof (state)\nthis:\n  \\<lbrakk>min_dist s t < g'.min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>min_dist s t < g'.min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "{"], ["proof (state)\nthis:\n  \\<lbrakk>min_dist s t < g'.min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume EQ: \"g'.min_dist s t = min_dist s t\""], ["proof (state)\nthis:\n  g'.min_dist s t = min_dist s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume CONN2: \"g'.connected s t\""], ["proof (state)\nthis:\n  g'.connected s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "{"], ["proof (state)\nthis:\n  g'.connected s t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "fix p'"], ["proof (state)\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume P': \"g'.isShortestPath s p' t\""], ["proof (state)\nthis:\n  g'.isShortestPath s p' t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "have \"prod.swap`edges \\<inter> set p' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p' = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p' \\<noteq> {} \\<Longrightarrow> False", "assume EIP': \"prod.swap`edges \\<inter> set p' \\<noteq> {}\""], ["proof (state)\nthis:\n  prod.swap ` edges \\<inter> set p' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p' \\<noteq> {} \\<Longrightarrow> False", "from P'"], ["proof (chain)\npicking this:\n  g'.isShortestPath s p' t", "have \n             P': \"g'.isPath s p' t\" and \n          LENP': \"length p' = g'.min_dist s t\""], ["proof (prove)\nusing this:\n  g'.isShortestPath s p' t\n\ngoal (1 subgoal):\n 1. g'.isPath s p' t &&& length p' = g'.min_dist s t", "by (auto simp: g'.isShortestPath_min_dist_def)"], ["proof (state)\nthis:\n  g'.isPath s p' t\n  length p' = g'.min_dist s t\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p' \\<noteq> {} \\<Longrightarrow> False", "from isShortestPath_flip_edges[OF _ _ SP SP_EDGES P' EIP'] Ebounds"], ["proof (chain)\npicking this:\n  \\<lbrakk>E - edges \\<subseteq> g'.E;\n   g'.E \\<subseteq> E \\<union> prod.swap ` edges\\<rbrakk>\n  \\<Longrightarrow> length p + 2 \\<le> length p'\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges", "have \"length p + 2 \\<le> length p'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>E - edges \\<subseteq> g'.E;\n   g'.E \\<subseteq> E \\<union> prod.swap ` edges\\<rbrakk>\n  \\<Longrightarrow> length p + 2 \\<le> length p'\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n\ngoal (1 subgoal):\n 1. length p + 2 \\<le> length p'", "by auto"], ["proof (state)\nthis:\n  length p + 2 \\<le> length p'\n\ngoal (1 subgoal):\n 1. prod.swap ` edges \\<inter> set p' \\<noteq> {} \\<Longrightarrow> False", "with LENP LENP' EQ"], ["proof (chain)\npicking this:\n  length p = min_dist s t\n  length p' = g'.min_dist s t\n  g'.min_dist s t = min_dist s t\n  length p + 2 \\<le> length p'", "show False"], ["proof (prove)\nusing this:\n  length p = min_dist s t\n  length p' = g'.min_dist s t\n  g'.min_dist s t = min_dist s t\n  length p + 2 \\<le> length p'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod.swap ` edges \\<inter> set p' = {}\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "with g'.transfer_path[of p' c s t] P' Ebounds"], ["proof (chain)\npicking this:\n  \\<lbrakk>set p' \\<inter> g'.E \\<subseteq> E; g'.isPath s p' t\\<rbrakk>\n  \\<Longrightarrow> isPath s p' t\n  g'.isShortestPath s p' t\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p' = {}", "have \"isShortestPath s p' t\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set p' \\<inter> g'.E \\<subseteq> E; g'.isPath s p' t\\<rbrakk>\n  \\<Longrightarrow> isPath s p' t\n  g'.isShortestPath s p' t\n  E - edges \\<union> prod.swap ` edges \\<subseteq> g'.E\n  g'.E \\<subseteq> E \\<union> prod.swap ` edges\n  prod.swap ` edges \\<inter> set p' = {}\n\ngoal (1 subgoal):\n 1. isShortestPath s p' t", "by (auto simp: Graph.isShortestPath_min_dist_def EQ)"], ["proof (state)\nthis:\n  isShortestPath s p' t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "}"], ["proof (state)\nthis:\n  g'.isShortestPath s ?p'2 t \\<Longrightarrow> isShortestPath s ?p'2 t\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "hence SS: \"g'.spEdges \\<subseteq> spEdges\""], ["proof (prove)\nusing this:\n  g'.isShortestPath s ?p'2 t \\<Longrightarrow> isShortestPath s ?p'2 t\n\ngoal (1 subgoal):\n 1. g'.spEdges \\<subseteq> spEdges", "by (auto simp: g'.spEdges_def spEdges_def)"], ["proof (state)\nthis:\n  g'.spEdges \\<subseteq> spEdges\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "{"], ["proof (state)\nthis:\n  g'.spEdges \\<subseteq> spEdges\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "assume \"edges - Graph.E c' \\<noteq> {}\""], ["proof (state)\nthis:\n  edges - g'.E \\<noteq> {}\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "with g'.spEdges_ss_E SS SP SP_EDGES"], ["proof (chain)\npicking this:\n  g'.spEdges \\<subseteq> g'.E\n  g'.spEdges \\<subseteq> spEdges\n  isShortestPath s p t\n  edges \\<subseteq> set p\n  edges - g'.E \\<noteq> {}", "have \"g'.spEdges \\<subset> spEdges\""], ["proof (prove)\nusing this:\n  g'.spEdges \\<subseteq> g'.E\n  g'.spEdges \\<subseteq> spEdges\n  isShortestPath s p t\n  edges \\<subseteq> set p\n  edges - g'.E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. g'.spEdges \\<subset> spEdges", "unfolding g'.spEdges_def spEdges_def"], ["proof (prove)\nusing this:\n  {e. \\<exists>p. e \\<in> set p \\<and> g'.isShortestPath s p t}\n  \\<subseteq> g'.E\n  {e. \\<exists>p. e \\<in> set p \\<and> g'.isShortestPath s p t}\n  \\<subseteq> {e. \\<exists>p. e \\<in> set p \\<and> isShortestPath s p t}\n  isShortestPath s p t\n  edges \\<subseteq> set p\n  edges - g'.E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {e. \\<exists>p. e \\<in> set p \\<and> g'.isShortestPath s p t}\n    \\<subset> {e. \\<exists>p. e \\<in> set p \\<and> isShortestPath s p t}", "by fastforce"], ["proof (state)\nthis:\n  g'.spEdges \\<subset> spEdges\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "hence \"g'.ekMeasure < ekMeasure\""], ["proof (prove)\nusing this:\n  g'.spEdges \\<subset> spEdges\n\ngoal (1 subgoal):\n 1. g'.ekMeasure < ekMeasure", "unfolding g'.ekMeasure_def ekMeasure_def"], ["proof (prove)\nusing this:\n  g'.spEdges \\<subset> spEdges\n\ngoal (1 subgoal):\n 1. (if g'.connected s t\n     then (card g'.V - g'.min_dist s t) * (card g'.uE + 1) + card g'.spEdges\n     else 0)\n    < (if connected s t\n       then (card V - min_dist s t) * (card uE + 1) + card spEdges else 0)", "apply (simp only: Veq uE_eq EQ CONN CONN2 if_True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. g'.spEdges \\<subset> spEdges \\<Longrightarrow>\n    (card V - min_dist s t) * (card uE + 1) + card g'.spEdges\n    < (card V - min_dist s t) * (card uE + 1) + card spEdges", "apply (rule add_strict_left_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. g'.spEdges \\<subset> spEdges \\<Longrightarrow>\n    card g'.spEdges < card spEdges", "apply (rule psubset_card_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. g'.spEdges \\<subset> spEdges \\<Longrightarrow> finite spEdges\n 2. g'.spEdges \\<subset> spEdges \\<Longrightarrow>\n    g'.spEdges \\<subset> spEdges", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. g'.spEdges \\<subset> spEdges \\<Longrightarrow>\n    g'.spEdges \\<subset> spEdges", "by simp"], ["proof (state)\nthis:\n  g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "}"], ["proof (state)\nthis:\n  edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "note G1 = this"], ["proof (state)\nthis:\n  edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "have G2: \"g'.ekMeasure \\<le> ekMeasure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g'.ekMeasure \\<le> ekMeasure", "unfolding g'.ekMeasure_def ekMeasure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if g'.connected s t\n     then (card g'.V - g'.min_dist s t) * (card g'.uE + 1) + card g'.spEdges\n     else 0)\n    \\<le> (if connected s t\n           then (card V - min_dist s t) * (card uE + 1) + card spEdges\n           else 0)", "apply (simp only: Veq uE_eq CONN CONN2 if_True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (card V - g'.min_dist s t) * (card uE + 1) + card g'.spEdges\n    \\<le> (card V - min_dist s t) * (card uE + 1) + card spEdges", "apply (rule add_mono[OF mult_right_mono])"], ["proof (prove)\ngoal (3 subgoals):\n 1. card V - g'.min_dist s t \\<le> card V - min_dist s t\n 2. 0 \\<le> card uE + 1\n 3. card g'.spEdges \\<le> card spEdges", "apply (simp add: EQ)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> card uE + 1\n 2. card g'.spEdges \\<le> card spEdges", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. card g'.spEdges \\<le> card spEdges", "apply (rule card_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite spEdges\n 2. g'.spEdges \\<subseteq> spEdges", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. g'.spEdges \\<subseteq> spEdges", "by fact"], ["proof (state)\nthis:\n  g'.ekMeasure \\<le> ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "note G1 G2"], ["proof (state)\nthis:\n  edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  g'.ekMeasure \\<le> ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t;\n   edges - g'.E \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure \\<le> ekMeasure\n\ngoal (2 subgoals):\n 1. g'.ekMeasure \\<le> ekMeasure\n 2. edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> g'.connected s t \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  \\<lbrakk>g'.min_dist s t < min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>min_dist s t < g'.min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t;\n   edges - g'.E \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure \\<le> ekMeasure", "show \n    \"g'.ekMeasure \\<le> ekMeasure\" \n    \"edges - Graph.E c' \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure\""], ["proof (prove)\nusing this:\n  \\<not> g'.connected s t \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  \\<lbrakk>g'.min_dist s t < min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>min_dist s t < g'.min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t;\n   edges - g'.E \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure \\<le> ekMeasure\n\ngoal (1 subgoal):\n 1. g'.ekMeasure \\<le> ekMeasure &&&\n    (edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure)", "using less_linear[of \"g'.min_dist s t\" \"min_dist s t\"]"], ["proof (prove)\nusing this:\n  \\<not> g'.connected s t \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  \\<lbrakk>g'.min_dist s t < min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>min_dist s t < g'.min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t;\n   edges - g'.E \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure < ekMeasure\n  \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t\\<rbrakk>\n  \\<Longrightarrow> g'.ekMeasure \\<le> ekMeasure\n  g'.min_dist s t < min_dist s t \\<or>\n  g'.min_dist s t = min_dist s t \\<or> min_dist s t < g'.min_dist s t\n\ngoal (1 subgoal):\n 1. g'.ekMeasure \\<le> ekMeasure &&&\n    (edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure)", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> g'.connected s t \\<Longrightarrow>\n             g'.ekMeasure < ekMeasure;\n     \\<lbrakk>g'.min_dist s t < min_dist s t; g'.connected s t\\<rbrakk>\n     \\<Longrightarrow> False;\n     \\<lbrakk>min_dist s t < g'.min_dist s t; g'.connected s t\\<rbrakk>\n     \\<Longrightarrow> g'.ekMeasure < ekMeasure;\n     \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t;\n      edges - g'.E \\<noteq> {}\\<rbrakk>\n     \\<Longrightarrow> g'.ekMeasure < ekMeasure;\n     \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t\\<rbrakk>\n     \\<Longrightarrow> g'.ekMeasure \\<le> ekMeasure;\n     g'.min_dist s t < min_dist s t \\<or>\n     g'.min_dist s t = min_dist s t \\<or>\n     min_dist s t < g'.min_dist s t\\<rbrakk>\n    \\<Longrightarrow> g'.ekMeasure \\<le> ekMeasure\n 2. \\<lbrakk>edges - g'.E \\<noteq> {};\n     \\<not> g'.connected s t \\<Longrightarrow> g'.ekMeasure < ekMeasure;\n     \\<lbrakk>g'.min_dist s t < min_dist s t; g'.connected s t\\<rbrakk>\n     \\<Longrightarrow> False;\n     \\<lbrakk>min_dist s t < g'.min_dist s t; g'.connected s t\\<rbrakk>\n     \\<Longrightarrow> g'.ekMeasure < ekMeasure;\n     \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t;\n      edges - g'.E \\<noteq> {}\\<rbrakk>\n     \\<Longrightarrow> g'.ekMeasure < ekMeasure;\n     \\<lbrakk>g'.min_dist s t = min_dist s t; g'.connected s t\\<rbrakk>\n     \\<Longrightarrow> g'.ekMeasure \\<le> ekMeasure;\n     g'.min_dist s t < min_dist s t \\<or>\n     g'.min_dist s t = min_dist s t \\<or>\n     min_dist s t < g'.min_dist s t\\<rbrakk>\n    \\<Longrightarrow> g'.ekMeasure < ekMeasure", "apply (fastforce)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  g'.ekMeasure \\<le> ekMeasure\n  edges - g'.E \\<noteq> {} \\<Longrightarrow> g'.ekMeasure < ekMeasure\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Analysis locale\\<close>"], ["", "text \\<open>As a first step to the analysis setup, we characterize\n  the effect of augmentation on the residual graph\n  \\<close>"], ["", "context Graph\nbegin"], ["", "definition \"augment_cf edges cap \\<equiv> \\<lambda>e. \n  if e\\<in>edges then c e - cap \n  else if prod.swap e\\<in>edges then c e + cap\n  else c e\""], ["", "lemma augment_cf_empty[simp]: \"augment_cf {} cap = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_cf {} cap = c", "by (auto simp: augment_cf_def)"], ["", "lemma augment_cf_ss_V: \"\\<lbrakk>edges \\<subseteq> E\\<rbrakk> \\<Longrightarrow> Graph.V (augment_cf edges cap) \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges \\<subseteq> E \\<Longrightarrow>\n    Graph.V (augment_cf edges cap) \\<subseteq> V", "unfolding Graph.E_def Graph.V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges\n    \\<subseteq> {(u, v). c (u, v) \\<noteq> (0::'capacity)} \\<Longrightarrow>\n    {u. \\<exists>v.\n           (u, v)\n           \\<in> {(u, v).\n                  augment_cf edges cap (u, v) \\<noteq> (0::'capacity)} \\<or>\n           (v, u)\n           \\<in> {(u, v).\n                  augment_cf edges cap (u, v) \\<noteq> (0::'capacity)}}\n    \\<subseteq> {u. \\<exists>v.\n                       (u, v)\n                       \\<in> {(u, v).\n                              c (u, v) \\<noteq> (0::'capacity)} \\<or>\n                       (v, u)\n                       \\<in> {(u, v). c (u, v) \\<noteq> (0::'capacity)}}", "by (auto simp add: augment_cf_def) []"], ["", "lemma augment_saturate:\n  fixes edges e\n  defines \"c' \\<equiv> augment_cf edges (c e)\"\n  assumes EIE: \"e\\<in>edges\"\n  shows \"e\\<notin>Graph.E c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> Graph.E c'", "using EIE"], ["proof (prove)\nusing this:\n  e \\<in> edges\n\ngoal (1 subgoal):\n 1. e \\<notin> Graph.E c'", "unfolding c'_def augment_cf_def"], ["proof (prove)\nusing this:\n  e \\<in> edges\n\ngoal (1 subgoal):\n 1. e \\<notin> Graph.E\n                (\\<lambda>ea.\n                    if ea \\<in> edges then c ea - c e\n                    else if prod.swap ea \\<in> edges then c ea + c e\n                         else c ea)", "by (auto simp: Graph.E_def)"], ["", "lemma augment_cf_split: \n  assumes \"edges1 \\<inter> edges2 = {}\" \"edges1\\<inverse> \\<inter> edges2 = {}\"\n  shows \"Graph.augment_cf c (edges1 \\<union> edges2) cap \n    = Graph.augment_cf (Graph.augment_cf c edges1 cap) edges2 cap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_cf (edges1 \\<union> edges2) cap =\n    Graph.augment_cf (augment_cf edges1 cap) edges2 cap", "using assms"], ["proof (prove)\nusing this:\n  edges1 \\<inter> edges2 = {}\n  edges1\\<inverse> \\<inter> edges2 = {}\n\ngoal (1 subgoal):\n 1. augment_cf (edges1 \\<union> edges2) cap =\n    Graph.augment_cf (augment_cf edges1 cap) edges2 cap", "by (fastforce simp: Graph.augment_cf_def intro!: ext)"], ["", "end \\<comment> \\<open>Graph\\<close>"], ["", "context NFlow begin"], ["", "lemma augmenting_edge_no_swap: \"isAugmentingPath p \\<Longrightarrow> set p \\<inter> (set p)\\<inverse> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow>\n    set p \\<inter> (set p)\\<inverse> = {}", "using cf.isSPath_nt_parallel_pf"], ["proof (prove)\nusing this:\n  cf.isSimplePath ?s ?p ?t \\<Longrightarrow>\n  set ?p \\<inter> (set ?p)\\<inverse> = {}\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow>\n    set p \\<inter> (set p)\\<inverse> = {}", "by (auto simp: isAugmentingPath_def)"], ["", "lemma aug_flows_finite[simp, intro!]: \n  \"finite {cf e |e. e \\<in> set p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {cf e |e. e \\<in> set p}", "apply (rule finite_subset[where B=\"cf`set p\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {cf e |e. e \\<in> set p} \\<subseteq> cf ` set p\n 2. finite (cf ` set p)", "by auto"], ["", "lemma aug_flows_finite'[simp, intro!]: \n  \"finite {cf (u,v) |u v. (u,v) \\<in> set p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {cf (u, v) |u v. (u, v) \\<in> set p}", "apply (rule finite_subset[where B=\"cf`set p\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {cf (u, v) |u v. (u, v) \\<in> set p} \\<subseteq> cf ` set p\n 2. finite (cf ` set p)", "by auto"], ["", "lemma augment_alt:\n  assumes AUG: \"isAugmentingPath p\"\n  defines \"f' \\<equiv> augment (augmentingFlow p)\"\n  defines \"cf' \\<equiv> residualGraph c f'\"\n  shows \"cf' = Graph.augment_cf cf (set p) (resCap p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "assume \"(u,v)\\<in>set p\""], ["proof (state)\nthis:\n  (u, v) \\<in> set p\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "hence \"resCap p \\<le> cf (u,v)\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> set p\n\ngoal (1 subgoal):\n 1. resCap p \\<le> cf (u, v)", "unfolding resCap_def"], ["proof (prove)\nusing this:\n  (u, v) \\<in> set p\n\ngoal (1 subgoal):\n 1. Min {cf e |e. e \\<in> set p} \\<le> cf (u, v)", "by (auto intro: Min_le)"], ["proof (state)\nthis:\n  resCap p \\<le> cf (u, v)\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "}"], ["proof (state)\nthis:\n  (?u2, ?v2) \\<in> set p \\<Longrightarrow> resCap p \\<le> cf (?u2, ?v2)\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "note bn_smallerI = this"], ["proof (state)\nthis:\n  (?u2, ?v2) \\<in> set p \\<Longrightarrow> resCap p \\<le> cf (?u2, ?v2)\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "{"], ["proof (state)\nthis:\n  (?u2, ?v2) \\<in> set p \\<Longrightarrow> resCap p \\<le> cf (?u2, ?v2)\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "assume \"(u,v)\\<in>set p\""], ["proof (state)\nthis:\n  (u, v) \\<in> set p\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "hence \"(u,v)\\<in>cf.E\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> set p\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E", "using AUG cf.isPath_edgeset"], ["proof (prove)\nusing this:\n  (u, v) \\<in> set p\n  isAugmentingPath p\n  \\<lbrakk>cf.isPath ?u ?p ?v; ?e \\<in> set ?p\\<rbrakk>\n  \\<Longrightarrow> ?e \\<in> cf.E\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E", "by (auto simp: isAugmentingPath_def cf.isSimplePath_def)"], ["proof (state)\nthis:\n  (u, v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "hence \"(u,v)\\<in>E \\<or> (v,u)\\<in>E\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<or> (v, u) \\<in> E", "using cfE_ss_invE"], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n  cf.E \\<subseteq> E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<or> (v, u) \\<in> E", "by (auto)"], ["proof (state)\nthis:\n  (u, v) \\<in> E \\<or> (v, u) \\<in> E\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "}"], ["proof (state)\nthis:\n  (?u2, ?v2) \\<in> set p \\<Longrightarrow>\n  (?u2, ?v2) \\<in> E \\<or> (?v2, ?u2) \\<in> E\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "note edge_or_swap = this"], ["proof (state)\nthis:\n  (?u2, ?v2) \\<in> set p \\<Longrightarrow>\n  (?u2, ?v2) \\<in> E \\<or> (?v2, ?u2) \\<in> E\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. cf' x = cf.augment_cf (set p) (resCap p) x", "unfolding cf.augment_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cf' x =\n       (if x \\<in> set p then cf x - resCap p\n        else if prod.swap x \\<in> set p then cf x + resCap p else cf x)", "using augmenting_edge_no_swap[OF AUG]"], ["proof (prove)\nusing this:\n  set p \\<inter> (set p)\\<inverse> = {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cf' x =\n       (if x \\<in> set p then cf x - resCap p\n        else if prod.swap x \\<in> set p then cf x + resCap p else cf x)", "apply (auto \n      simp: augment_def augmentingFlow_def cf'_def f'_def residualGraph_def\n      split: prod.splits\n      dest: edge_or_swap \n      )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cf' = cf.augment_cf (set p) (resCap p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma augmenting_path_contains_resCap:\n  assumes \"isAugmentingPath p\"\n  obtains e where \"e\\<in>set p\" \"cf e = resCap p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set p; cf e = resCap p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set p; cf e = resCap p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  isAugmentingPath p", "have \"p\\<noteq>[]\""], ["proof (prove)\nusing this:\n  isAugmentingPath p\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by (auto simp: isAugmentingPath_def s_not_t)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set p; cf e = resCap p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"{cf e | e. e \\<in> set p} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. {cf e |e. e \\<in> set p} \\<noteq> {}", "by (cases p) auto"], ["proof (state)\nthis:\n  {cf e |e. e \\<in> set p} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set p; cf e = resCap p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with Min_in[OF aug_flows_finite this, folded resCap_def]"], ["proof (chain)\npicking this:\n  resCap p \\<in> {cf e |e. e \\<in> set p}\n  {cf e |e. e \\<in> set p} \\<noteq> {}", "obtain e where \"e\\<in>set p\" \"cf e = resCap p\""], ["proof (prove)\nusing this:\n  resCap p \\<in> {cf e |e. e \\<in> set p}\n  {cf e |e. e \\<in> set p} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set p; cf e = resCap p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e \\<in> set p\n  cf e = resCap p\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set p; cf e = resCap p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  e \\<in> set p\n  cf e = resCap p\n\ngoal (1 subgoal):\n 1. thesis", "by (blast intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, we show the main theorem used for termination and complexity \n  analysis: Augmentation with a shortest path decreases the measure function.\\<close>"], ["", "theorem shortest_path_decr_ek_measure:\n  fixes p\n  assumes SP: \"Graph.isShortestPath cf s p t\"\n  defines \"f' \\<equiv> augment (augmentingFlow p)\"\n  defines \"cf' \\<equiv> residualGraph c f'\"\n  shows \"ek_analysis_defs.ekMeasure cf' s t < ek_analysis_defs.ekMeasure cf s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ek_analysis_defs.ekMeasure cf' s t < ek_analysis_defs.ekMeasure cf s t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ek_analysis_defs.ekMeasure cf' s t < ek_analysis_defs.ekMeasure cf s t", "interpret cf: ek_analysis cf"], ["proof (prove)\ngoal (1 subgoal):\n 1. ek_analysis cf", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. ek_analysis_defs.ekMeasure cf' s t < cf.ekMeasure", "interpret cf': ek_analysis_defs cf'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "from SP"], ["proof (chain)\npicking this:\n  cf.isShortestPath s p t", "have AUG: \"isAugmentingPath p\""], ["proof (prove)\nusing this:\n  cf.isShortestPath s p t\n\ngoal (1 subgoal):\n 1. isAugmentingPath p", "unfolding isAugmentingPath_def cf.isShortestPath_alt"], ["proof (prove)\nusing this:\n  cf.isSimplePath s p t \\<and> length p = cf.min_dist s t\n\ngoal (1 subgoal):\n 1. cf.isSimplePath s p t", "by simp"], ["proof (state)\nthis:\n  isAugmentingPath p\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "note BNGZ = resCap_gzero[OF AUG]"], ["proof (state)\nthis:\n  (0::'capacity) < resCap p\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "have cf'_alt: \"cf' = cf.augment_cf (set p) (resCap p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "using augment_alt[OF AUG]"], ["proof (prove)\nusing this:\n  cf_of (augment (augmentingFlow p)) = cf.augment_cf (set p) (resCap p)\n\ngoal (1 subgoal):\n 1. cf' = cf.augment_cf (set p) (resCap p)", "unfolding cf'_def f'_def"], ["proof (prove)\nusing this:\n  cf_of (augment (augmentingFlow p)) = cf.augment_cf (set p) (resCap p)\n\ngoal (1 subgoal):\n 1. cf_of (augment (augmentingFlow p)) = cf.augment_cf (set p) (resCap p)", "by simp"], ["proof (state)\nthis:\n  cf' = cf.augment_cf (set p) (resCap p)\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "obtain e where\n    EIP: \"e\\<in>set p\" and EBN: \"cf e = resCap p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set p; cf e = resCap p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule augmenting_path_contains_resCap[OF AUG]) auto"], ["proof (state)\nthis:\n  e \\<in> set p\n  cf e = resCap p\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "have ENIE': \"e\\<notin>cf'.E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> cf'.E", "using cf.augment_saturate[OF EIP] EBN"], ["proof (prove)\nusing this:\n  e \\<notin> Graph.E (cf.augment_cf (set p) (cf e))\n  cf e = resCap p\n\ngoal (1 subgoal):\n 1. e \\<notin> cf'.E", "by (simp add: cf'_alt)"], ["proof (state)\nthis:\n  e \\<notin> cf'.E\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "{"], ["proof (state)\nthis:\n  e \\<notin> cf'.E\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "have \"cf e + resCap p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf e + resCap p \\<noteq> (0::'capacity)", "using resE_nonNegative[of e] BNGZ"], ["proof (prove)\nusing this:\n  (0::'capacity) \\<le> cf e\n  (0::'capacity) < resCap p\n\ngoal (1 subgoal):\n 1. cf e + resCap p \\<noteq> (0::'capacity)", "by auto"], ["proof (state)\nthis:\n  cf e + resCap p \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "}"], ["proof (state)\nthis:\n  cf ?ea2 + resCap p \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "note [simp] = this"], ["proof (state)\nthis:\n  cf ?ea2 + resCap p \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "{"], ["proof (state)\nthis:\n  cf ?ea2 + resCap p \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "assume \"e\\<in>set p\""], ["proof (state)\nthis:\n  e \\<in> set p\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "hence \"e \\<in> cf.E\""], ["proof (prove)\nusing this:\n  e \\<in> set p\n\ngoal (1 subgoal):\n 1. e \\<in> cf.E", "using cf.shortestPath_is_path[OF SP] cf.isPath_edgeset"], ["proof (prove)\nusing this:\n  e \\<in> set p\n  cf.isPath s p t\n  \\<lbrakk>cf.isPath ?u ?p ?v; ?e \\<in> set ?p\\<rbrakk>\n  \\<Longrightarrow> ?e \\<in> cf.E\n\ngoal (1 subgoal):\n 1. e \\<in> cf.E", "by blast"], ["proof (state)\nthis:\n  e \\<in> cf.E\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "hence \"cf e > 0 \\<and> cf e \\<noteq> 0\""], ["proof (prove)\nusing this:\n  e \\<in> cf.E\n\ngoal (1 subgoal):\n 1. (0::'capacity) < cf e \\<and> cf e \\<noteq> (0::'capacity)", "using resE_positive[of e]"], ["proof (prove)\nusing this:\n  e \\<in> cf.E\n  e \\<in> cf.E \\<Longrightarrow> (0::'capacity) < cf e\n\ngoal (1 subgoal):\n 1. (0::'capacity) < cf e \\<and> cf e \\<noteq> (0::'capacity)", "by auto"], ["proof (state)\nthis:\n  (0::'capacity) < cf e \\<and> cf e \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "}"], ["proof (state)\nthis:\n  ?ea2 \\<in> set p \\<Longrightarrow>\n  (0::'capacity) < cf ?ea2 \\<and> cf ?ea2 \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "note [simp] = this"], ["proof (state)\nthis:\n  ?ea2 \\<in> set p \\<Longrightarrow>\n  (0::'capacity) < cf ?ea2 \\<and> cf ?ea2 \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cf'.ekMeasure < cf.ekMeasure", "apply (rule cf.measure_decr(2))"], ["proof (prove)\ngoal (6 subgoals):\n 1. s \\<in> cf.V\n 2. cf.isShortestPath s ?p t\n 3. ?edges \\<subseteq> set ?p\n 4. cf.E - ?edges \\<union> prod.swap ` ?edges \\<subseteq> cf'.E\n 5. cf'.E \\<subseteq> cf.E \\<union> prod.swap ` ?edges\n 6. ?edges - cf'.E \\<noteq> {}", "apply (simp_all add: s_node)"], ["proof (prove)\ngoal (5 subgoals):\n 1. cf.isShortestPath s ?p t\n 2. ?edges \\<subseteq> set ?p\n 3. cf.E - ?edges \\<subseteq> cf'.E \\<and>\n    prod.swap ` ?edges \\<subseteq> cf'.E\n 4. cf'.E \\<subseteq> cf.E \\<union> prod.swap ` ?edges\n 5. \\<not> ?edges \\<subseteq> cf'.E", "apply (rule SP)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?edges \\<subseteq> set p\n 2. cf.E - ?edges \\<subseteq> cf'.E \\<and>\n    prod.swap ` ?edges \\<subseteq> cf'.E\n 3. cf'.E \\<subseteq> cf.E \\<union> prod.swap ` ?edges\n 4. \\<not> ?edges \\<subseteq> cf'.E", "apply (rule order_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. cf.E - set p \\<subseteq> cf'.E \\<and>\n    prod.swap ` set p \\<subseteq> cf'.E\n 2. cf'.E \\<subseteq> cf.E \\<union> prod.swap ` set p\n 3. \\<not> set p \\<subseteq> cf'.E", "apply (rule conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. cf.E - set p \\<subseteq> cf'.E\n 2. prod.swap ` set p \\<subseteq> cf'.E\n 3. cf'.E \\<subseteq> cf.E \\<union> prod.swap ` set p\n 4. \\<not> set p \\<subseteq> cf'.E", "apply (unfold Graph.E_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. {(u, v). cf (u, v) \\<noteq> (0::'capacity)} - set p\n    \\<subseteq> {(u, v). cf' (u, v) \\<noteq> (0::'capacity)}\n 2. prod.swap ` set p \\<subseteq> cf'.E\n 3. cf'.E \\<subseteq> cf.E \\<union> prod.swap ` set p\n 4. \\<not> set p \\<subseteq> cf'.E", "apply (auto simp: cf'_alt cf.augment_cf_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. prod.swap ` set p \\<subseteq> cf'.E\n 2. cf'.E \\<subseteq> cf.E \\<union> prod.swap ` set p\n 3. \\<not> set p \\<subseteq> cf'.E", "using augmenting_edge_no_swap[OF AUG]"], ["proof (prove)\nusing this:\n  set p \\<inter> (set p)\\<inverse> = {}\n\ngoal (3 subgoals):\n 1. prod.swap ` set p \\<subseteq> cf'.E\n 2. cf'.E \\<subseteq> cf.E \\<union> prod.swap ` set p\n 3. \\<not> set p \\<subseteq> cf'.E", "apply (fastforce \n        simp: cf'_alt cf.augment_cf_def Graph.E_def \n        simp del: cf.zero_cap_simp) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. cf'.E \\<subseteq> cf.E \\<union> prod.swap ` set p\n 2. \\<not> set p \\<subseteq> cf'.E", "apply (unfold Graph.E_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. {(u, v). cf' (u, v) \\<noteq> (0::'capacity)}\n    \\<subseteq> {(u, v). cf (u, v) \\<noteq> (0::'capacity)} \\<union>\n                prod.swap ` set p\n 2. \\<not> set p \\<subseteq> cf'.E", "apply (auto simp: cf'_alt cf.augment_cf_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> set p \\<subseteq> cf'.E", "using EIP ENIE'"], ["proof (prove)\nusing this:\n  e \\<in> set p\n  e \\<notin> cf'.E\n\ngoal (1 subgoal):\n 1. \\<not> set p \\<subseteq> cf'.E", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cf'.ekMeasure < cf.ekMeasure\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Network with flow\\<close>"], ["", "end"]]}