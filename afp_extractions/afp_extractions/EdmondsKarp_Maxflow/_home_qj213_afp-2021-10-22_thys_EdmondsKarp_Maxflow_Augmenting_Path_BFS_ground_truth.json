{"file_name": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow/Augmenting_Path_BFS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow", "problem_names": ["lemma Vd_disj: \"\\<And>d d'. d\\<noteq>d' \\<Longrightarrow> Vd d \\<inter> Vd d' = {}\"", "lemma src_Vd0[simp]: \"Vd 0 = {src}\"", "lemma in_Vd_conv: \"v\\<in>Vd d \\<longleftrightarrow> connected src v \\<and> ndist v = d\"", "lemma Vd_succ: \n      assumes \"u\\<in>Vd d\"  \n      assumes \"(u,v)\\<in>E\"\n      assumes \"\\<forall>i\\<le>d. v\\<notin>Vd i\"\n      shows \"v\\<in>Vd (Suc d)\"", "lemma FIN_E[simp, intro!]: \"finite E\"", "lemma FIN_succ[simp, intro!]: \"finite (E``{u})\"", "lemma (in nf_invar') ndist_C[simp]: \"\\<lbrakk>v\\<in>C\\<rbrakk> \\<Longrightarrow> ndist v = d\"", "lemma (in nf_invar) CVdI: \"\\<lbrakk>u\\<in>C\\<rbrakk> \\<Longrightarrow> u\\<in>Vd d\"", "lemma (in nf_invar) inPREDD: \n    \"\\<lbrakk>PRED v = Some u\\<rbrakk> \\<Longrightarrow> v\\<in>N \\<or> (\\<exists>i\\<le>d. v\\<in>Vd i)\"", "lemma (in nf_invar') C_ss_VIS: \"\\<lbrakk>v\\<in>C\\<rbrakk> \\<Longrightarrow> v\\<in>dom PRED\"", "lemma (in nf_invar) invar_succ_step:\n    assumes \"v\\<in>C\"\n    assumes \"dst \\<notin> E``{v} - dom PRED\"\n    shows \"nf_invar' c src dst \n      (map_mmupd PRED (E``{v} - dom PRED) v) \n      (C-{v}) \n      (N \\<union> (E``{v} - dom PRED)) \n      d\"", "lemma invar_init: \"\\<lbrakk>src\\<noteq>dst; src\\<in>V; finite V\\<rbrakk> \n    \\<Longrightarrow> nf_invar c src dst [src \\<mapsto> src] {src} {} 0\"", "lemma (in nf_invar) invar_exit:\n    assumes \"dst\\<in>C\"\n    shows \"f_invar c src dst PRED d\"", "lemma (in nf_invar) invar_C_ss_V: \"u\\<in>C \\<Longrightarrow> u\\<in>V\"", "lemma (in nf_invar) invar_N_ss_Vis: \"u\\<in>N \\<Longrightarrow> \\<exists>v. PRED u = Some v\"", "lemma (in pre_bfs_invar) Vdsucinter_conv[simp]: \n    \"Vd (Suc d) \\<inter> E `` Vd d = Vd (Suc d)\"", "lemma (in nf_invar') invar_shift:\n    assumes [simp]: \"C={}\"\n    shows \"nf_invar c src dst PRED N {} (Suc d)\"", "lemma (in nf_invar') invar_restore:\n    assumes [simp]: \"C\\<noteq>{}\"\n    shows \"nf_invar c src dst PRED C N d\"", "lemma (in f_invar) invar_found:\n    shows \"bfs_spec src dst (Some (d,PRED))\"", "lemma (in nf_invar) invar_not_found:\n    assumes [simp]: \"C={}\"\n    shows \"bfs_spec src dst None\"", "lemma map_le_mp: \"\\<lbrakk>m\\<subseteq>\\<^sub>mm'; m k = Some v\\<rbrakk> \\<Longrightarrow> m' k = Some v\"", "lemma (in nf_invar) dst_notin_Vdd[intro, simp]: \"i\\<le>d \\<Longrightarrow> dst\\<notin>Vd i\"", "lemma (in nf_invar) invar_exit':\n    assumes \"u\\<in>C\" \"(u,dst) \\<in> E\" \"dst \\<in> dom PRED'\"\n    assumes SS1: \"PRED \\<subseteq>\\<^sub>m PRED'\" \n      and SS2: \"PRED' \\<subseteq>\\<^sub>m map_mmupd PRED (E``{u} - dom PRED) u\"\n    shows \"f_invar c src dst PRED' (Suc d)\"", "lemma outer_loop_rel_wf: \n    assumes \"finite V\"\n    shows \"wf (outer_loop_rel src)\"", "lemma (in nf_invar) C_ne_max_dist:\n    assumes \"C\\<noteq>{}\"\n    shows \"d \\<le> max_dist src\"", "lemma (in nf_invar) Vd_ss_V: \"Vd d \\<subseteq> V\"", "lemma (in nf_invar) finite_C[simp, intro!]: \"finite C\"", "lemma (in nf_invar) finite_succ: \"finite (E``{u})\"", "theorem pre_bfs_correct: \n    assumes [simp]: \"src\\<in>V\" \"src\\<noteq>dst\"       \n    assumes [simp]: \"finite V\"\n    shows \"pre_bfs src dst \\<le> SPEC (bfs_spec src dst)\"", "theorem \n    assumes \"src\\<in>V\" \"src\\<noteq>dst\" \"finite V\"\n    shows \"bfs_core src dst \\<le> (spec p. bfs_spec src dst p)\"", "lemma extract_rpath_correct:\n      assumes \"dst\\<in>dom PRED\"\n      shows \"extract_rpath src dst PRED \n        \\<le> SPEC (\\<lambda>p. isSimplePath src p dst \\<and> length p = ndist dst)\"", "lemma bfs_correct:\n      assumes \"src\\<in>V\" \"finite V\" \n      shows \"bfs src dst \n        \\<le> SPEC (\\<lambda>\n          None \\<Rightarrow> \\<not>connected src dst \n        | Some p \\<Rightarrow> isShortestPath src p dst)\"", "theorem\n      assumes \"src\\<in>V\" \n      shows \"bfs src dst \\<le> (spec p. case p of \n          None \\<Rightarrow> \\<not>connected src dst \n        | Some p \\<Rightarrow> isShortestPath src p dst)\"", "lemma inner_loop_refine[refine]: \n    (*assumes NSS: \"N \\<subseteq> dom PRED\"*)\n    assumes [simp]: \"finite succ\"\n    assumes [simplified, simp]: \n      \"(succi,succ)\\<in>Id\" \"(ui,u)\\<in>Id\" \"(PREDi,PRED)\\<in>Id\" \"(Ni,N)\\<in>Id\"\n    shows \"inner_loop dst succi ui PREDi Ni \n      \\<le> \\<Down>Id (add_succ_spec dst succ u PRED N)\"", "lemma inner_loop2_refine:\n    assumes SR: \"(succl,succ)\\<in>\\<langle>Id\\<rangle>list_set_rel\"\n    shows \"inner_loop2 dst succl u PRED N \\<le> \\<Down>Id (inner_loop dst succ u PRED N)\"", "lemma inner_loop2_correct:\n    assumes \"(succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel\"\n    (*assumes \"N \\<subseteq> dom PRED\"*)\n    assumes [simplified, simp]: \n      \"(dsti,dst)\\<in>Id\" \"(ui, u) \\<in> Id\" \"(PREDi, PRED) \\<in> Id\" \"(Ni, N) \\<in> Id\"\n    shows \"inner_loop2 dsti succl ui PREDi Ni \n      \\<le> \\<Down> Id (add_succ_spec dst succ u PRED N)\"", "lemma pre_bfs2_refine: \n        assumes succ_impl: \"\\<And>ui u. \\<lbrakk>(ui,u)\\<in>Id; u\\<in>V\\<rbrakk> \n          \\<Longrightarrow> succ ui \\<le> SPEC (\\<lambda>l. (l,E``{u}) \\<in> \\<langle>Id\\<rangle>list_set_rel)\"\n        shows \"pre_bfs2 src dst \\<le>\\<Down>Id (pre_bfs src dst)\"", "lemma bfs2_refine:\n      assumes succ_impl: \"\\<And>ui u. \\<lbrakk>(ui,u)\\<in>Id; u\\<in>V\\<rbrakk> \n        \\<Longrightarrow> succ ui \\<le> SPEC (\\<lambda>l. (l,E``{u}) \\<in> \\<langle>Id\\<rangle>list_set_rel)\"\n      shows \"bfs2 succ src dst \\<le> \\<Down>Id (bfs src dst)\"", "lemma bfs2_refine_succ: \n    assumes [refine]: \"\\<And>ui u. \\<lbrakk>(ui,u)\\<in>Id; u\\<in>Graph.V c\\<rbrakk> \n      \\<Longrightarrow> succi ui \\<le> \\<Down>Id (succ u)\"\n    assumes [simplified, simp]: \"(si,s)\\<in>Id\" \"(ti,t)\\<in>Id\" \"(ci,c)\\<in>Id\"\n    shows \"Graph.bfs2 ci succi si ti \\<le> \\<Down>Id (Graph.bfs2 c succ s t)\"", "lemma pat_op_dfs[pat_rules]: \n      \"Graph.bfs2$(absG$c)$(succ$c)$s$t \\<equiv> UNPROTECT op_bfs$c$s$t\"", "lemmas [sepref_fr_rules] = init_state_impl.refine[OF this_loc,to_hfref]", "lemmas bfs_impl_fr_rule = bfs_impl.refine[OF this_loc,to_hfref]"], "translations": [["", "lemma Vd_disj: \"\\<And>d d'. d\\<noteq>d' \\<Longrightarrow> Vd d \\<inter> Vd d' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d d'. d \\<noteq> d' \\<Longrightarrow> Vd d \\<inter> Vd d' = {}", "by (auto simp: Vd_def)"], ["", "lemma src_Vd0[simp]: \"Vd 0 = {src}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vd 0 = {src}", "by (auto simp: Vd_def)"], ["", "lemma in_Vd_conv: \"v\\<in>Vd d \\<longleftrightarrow> connected src v \\<and> ndist v = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> Vd d) = (local.connected src v \\<and> ndist v = d)", "by (auto simp: Vd_def)"], ["", "lemma Vd_succ: \n      assumes \"u\\<in>Vd d\"  \n      assumes \"(u,v)\\<in>E\"\n      assumes \"\\<forall>i\\<le>d. v\\<notin>Vd i\"\n      shows \"v\\<in>Vd (Suc d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> Vd (Suc d)", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> Vd d\n  (u, v) \\<in> E\n  \\<forall>i\\<le>d. v \\<notin> Vd i\n\ngoal (1 subgoal):\n 1. v \\<in> Vd (Suc d)", "by (metis connected_append_edge in_Vd_conv le_SucE min_dist_succ)"], ["", "end"], ["", "locale valid_PRED = pre_bfs_invar +\n    fixes PRED :: \"node \\<rightharpoonup> node\"\n    assumes SRC_IN_V[simp]: \"src\\<in>V\"\n    assumes FIN_V[simp, intro!]: \"finite V\"\n    assumes PRED_src[simp]: \"PRED src = Some src\"\n    assumes PRED_dist: \"\\<lbrakk>v\\<noteq>src; PRED v = Some u\\<rbrakk> \\<Longrightarrow> ndist v = Suc (ndist u)\"\n    assumes PRED_E: \"\\<lbrakk>v\\<noteq>src; PRED v = Some u\\<rbrakk> \\<Longrightarrow> (u,v)\\<in>E\"\n    assumes PRED_closed: \"\\<lbrakk> PRED v = Some u \\<rbrakk> \\<Longrightarrow> u\\<in>dom PRED\"\n  begin"], ["", "lemma FIN_E[simp, intro!]: \"finite E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E", "using E_ss_VxV"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. finite E", "by simp"], ["", "lemma FIN_succ[simp, intro!]: \"finite (E``{u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (E `` {u})", "by (auto intro: finite_Image)"], ["", "end"], ["", "locale nf_invar' = valid_PRED c src dst PRED for c src dst \n    and PRED :: \"node \\<rightharpoonup> node\"\n    and C N :: \"node set\"\n    and d :: nat \n    +\n    assumes VIS_eq: \"dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u\\<in>Vd i}\"\n    assumes C_ss: \"C \\<subseteq> Vd d\"\n    assumes N_eq: \"N = Vd (d+1) \\<inter> E``(Vd d - C)\"\n      \n    assumes dst_ne_VIS: \"dst \\<notin> dom PRED\""], ["", "locale nf_invar = nf_invar' +   \n    assumes empty_assm: \"C={} \\<Longrightarrow> N={}\""], ["", "locale f_invar = valid_PRED c src dst PRED for c src dst \n    and PRED :: \"node \\<rightharpoonup> node\"\n    and d :: nat   \n    + \n    assumes dst_found: \"dst \\<in> dom PRED \\<inter> Vd d\""], ["", "context Graph begin"], ["", "abbreviation \"outer_loop_invar src dst \\<equiv> \\<lambda>(f,PRED,C,N,d). \n      (f \\<longrightarrow> f_invar c src dst PRED d) \\<and>\n      (\\<not>f \\<longrightarrow> nf_invar c src dst PRED C N d)\n\n      \""], ["", "abbreviation \"assn1 src dst \\<equiv> \\<lambda>(f,PRED,C,N,d). \n      \\<not>f \\<and> nf_invar' c src dst PRED C N d\""], ["", "definition \"add_succ_spec dst succ v PRED N \\<equiv> ASSERT (N \\<subseteq> dom PRED) \\<then> \n    SPEC (\\<lambda>(f,PRED',N').\n      case f of\n        False \\<Rightarrow> dst \\<notin> succ - dom PRED \n          \\<and> PRED' = map_mmupd PRED (succ - dom PRED) v \n          \\<and> N' = N \\<union> (succ - dom PRED)\n      | True \\<Rightarrow> dst \\<in> succ - dom PRED \n        \\<and> PRED \\<subseteq>\\<^sub>m PRED' \n        \\<and> PRED' \\<subseteq>\\<^sub>m map_mmupd PRED (succ - dom PRED) v \n        \\<and> dst\\<in>dom PRED'\n  )\""], ["", "definition pre_bfs :: \"node \\<Rightarrow> node \\<Rightarrow> (nat \\<times> (node\\<rightharpoonup>node)) option nres\"\n    where \"pre_bfs src dst \\<equiv> do {\n    (f,PRED,_,_,d) \\<leftarrow> WHILEIT (outer_loop_invar src dst) \n      (\\<lambda>(f,PRED,C,N,d). f=False \\<and> C\\<noteq>{})\n      (\\<lambda>(f,PRED,C,N,d). do {\n        v \\<leftarrow> SPEC (\\<lambda>v. v\\<in>C); let C = C-{v};\n        ASSERT (v\\<in>V);\n        let succ = (E``{v});\n        ASSERT (finite succ);\n        (f,PRED,N) \\<leftarrow> add_succ_spec dst succ v PRED N;\n        if f then\n          RETURN (f,PRED,C,N,d+1)\n        else do {\n          ASSERT (assn1 src dst (f,PRED,C,N,d));\n          if (C={}) then do {\n            let C=N; \n            let N={}; \n            let d=d+1;\n            RETURN (f,PRED,C,N,d)\n          } else RETURN (f,PRED,C,N,d)\n        }  \n      })\n      (False,[src\\<mapsto>src],{src},{},0::nat);\n    if f then RETURN (Some (d, PRED)) else RETURN None\n    }\""], ["", "subsection \"Correctness Proof\""], ["", "lemma (in nf_invar') ndist_C[simp]: \"\\<lbrakk>v\\<in>C\\<rbrakk> \\<Longrightarrow> ndist v = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> C \\<Longrightarrow> ndist v = d", "using C_ss"], ["proof (prove)\nusing this:\n  C \\<subseteq> Vd d\n\ngoal (1 subgoal):\n 1. v \\<in> C \\<Longrightarrow> ndist v = d", "by (auto simp: Vd_def)"], ["", "lemma (in nf_invar) CVdI: \"\\<lbrakk>u\\<in>C\\<rbrakk> \\<Longrightarrow> u\\<in>Vd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> C \\<Longrightarrow> u \\<in> Vd d", "using C_ss"], ["proof (prove)\nusing this:\n  C \\<subseteq> Vd d\n\ngoal (1 subgoal):\n 1. u \\<in> C \\<Longrightarrow> u \\<in> Vd d", "by (auto)"], ["", "lemma (in nf_invar) inPREDD: \n    \"\\<lbrakk>PRED v = Some u\\<rbrakk> \\<Longrightarrow> v\\<in>N \\<or> (\\<exists>i\\<le>d. v\\<in>Vd i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRED v = Some u \\<Longrightarrow>\n    v \\<in> N \\<or> (\\<exists>i\\<le>d. v \\<in> Vd i)", "using VIS_eq"], ["proof (prove)\nusing this:\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n\ngoal (1 subgoal):\n 1. PRED v = Some u \\<Longrightarrow>\n    v \\<in> N \\<or> (\\<exists>i\\<le>d. v \\<in> Vd i)", "by (auto)"], ["", "lemma (in nf_invar') C_ss_VIS: \"\\<lbrakk>v\\<in>C\\<rbrakk> \\<Longrightarrow> v\\<in>dom PRED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> C \\<Longrightarrow> v \\<in> dom PRED", "using C_ss VIS_eq"], ["proof (prove)\nusing this:\n  C \\<subseteq> Vd d\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n\ngoal (1 subgoal):\n 1. v \\<in> C \\<Longrightarrow> v \\<in> dom PRED", "by blast"], ["", "lemma (in nf_invar) invar_succ_step:\n    assumes \"v\\<in>C\"\n    assumes \"dst \\<notin> E``{v} - dom PRED\"\n    shows \"nf_invar' c src dst \n      (map_mmupd PRED (E``{v} - dom PRED) v) \n      (C-{v}) \n      (N \\<union> (E``{v} - dom PRED)) \n      d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_invar' c src dst (map_mmupd PRED (E `` {v} - dom PRED) v) (C - {v})\n     (N \\<union> (E `` {v} - dom PRED)) d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nf_invar' c src dst (map_mmupd PRED (E `` {v} - dom PRED) v) (C - {v})\n     (N \\<union> (E `` {v} - dom PRED)) d", "from C_ss_VIS[OF \\<open>v\\<in>C\\<close>] dst_ne_VIS"], ["proof (chain)\npicking this:\n  v \\<in> dom PRED\n  dst \\<notin> dom PRED", "have \"v\\<noteq>dst\""], ["proof (prove)\nusing this:\n  v \\<in> dom PRED\n  dst \\<notin> dom PRED\n\ngoal (1 subgoal):\n 1. v \\<noteq> dst", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> dst\n\ngoal (1 subgoal):\n 1. nf_invar' c src dst (map_mmupd PRED (E `` {v} - dom PRED) v) (C - {v})\n     (N \\<union> (E `` {v} - dom PRED)) d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_invar' c src dst (map_mmupd PRED (E `` {v} - dom PRED) v) (C - {v})\n     (N \\<union> (E `` {v} - dom PRED)) d", "using \\<open>v\\<in>C\\<close> \\<open>v\\<noteq>dst\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> C\n  v \\<noteq> dst\n\ngoal (1 subgoal):\n 1. nf_invar' c src dst (map_mmupd PRED (E `` {v} - dom PRED) v) (C - {v})\n     (N \\<union> (E `` {v} - dom PRED)) d", "apply unfold_locales"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> src \\<in> V\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk> \\<Longrightarrow> finite V\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> map_mmupd PRED (E `` {v} - dom PRED) v src = Some src\n 4. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> ndist va = Suc (ndist u)\n 5. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 6. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 7. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 8. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 9. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 10. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n     \\<Longrightarrow> dst\n                       \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk> \\<Longrightarrow> finite V\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> map_mmupd PRED (E `` {v} - dom PRED) v src = Some src\n 3. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> ndist va = Suc (ndist u)\n 4. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 5. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 6. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 7. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 8. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 9. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> map_mmupd PRED (E `` {v} - dom PRED) v src = Some src\n 2. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> ndist va = Suc (ndist u)\n 3. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 4. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 6. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 7. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 8. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (auto simp: map_mmupd_def) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> ndist va = Suc (ndist u)\n 2. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 3. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 4. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 6. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 7. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (erule map_mmupdE)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        va \\<notin> E `` {v} - dom PRED; PRED va = Some u\\<rbrakk>\n       \\<Longrightarrow> ndist va = Suc (ndist u)\n 2. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        va \\<in> E `` {v} - dom PRED; u = v\\<rbrakk>\n       \\<Longrightarrow> ndist va = Suc (ndist u)\n 3. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 4. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 6. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 7. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 8. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "using PRED_dist"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<noteq> src; PRED ?v = Some ?u\\<rbrakk>\n  \\<Longrightarrow> ndist ?v = Suc (ndist ?u)\n\ngoal (8 subgoals):\n 1. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        va \\<notin> E `` {v} - dom PRED; PRED va = Some u\\<rbrakk>\n       \\<Longrightarrow> ndist va = Suc (ndist u)\n 2. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        va \\<in> E `` {v} - dom PRED; u = v\\<rbrakk>\n       \\<Longrightarrow> ndist va = Suc (ndist u)\n 3. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 4. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 6. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 7. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 8. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply blast"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        va \\<in> E `` {v} - dom PRED; u = v\\<rbrakk>\n       \\<Longrightarrow> ndist va = Suc (ndist u)\n 2. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 3. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 4. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 6. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 7. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (unfold VIS_eq) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        va \\<in> E `` {v} -\n                 (N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i});\n        u = v\\<rbrakk>\n       \\<Longrightarrow> ndist va = Suc (ndist u)\n 2. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 3. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 4. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 6. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 7. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply clarify"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>va u x.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src; (v, va) \\<in> E;\n        ndist va \\<noteq> Suc (ndist v); va \\<notin> N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>d. va \\<in> Vd i\n 2. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 3. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 4. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 6. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 7. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (metis CVdI Vd_succ in_Vd_conv)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 2. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 4. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 6. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "using PRED_E"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<noteq> src; PRED ?v = Some ?u\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> E\n\ngoal (6 subgoals):\n 1. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; va \\<noteq> src;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, va) \\<in> E\n 2. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 4. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 6. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (auto elim!: map_mmupdE) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 4. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "using PRED_closed"], ["proof (prove)\nusing this:\n  PRED ?v = Some ?u \\<Longrightarrow> ?u \\<in> dom PRED\n\ngoal (5 subgoals):\n 1. \\<And>va u.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst;\n        map_mmupd PRED (E `` {v} - dom PRED) v va = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom (map_mmupd PRED (E `` {v} - dom PRED)\n v)\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 4. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 5. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (auto elim!: map_mmupdE dest: C_ss_VIS) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 4. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "using VIS_eq"], ["proof (prove)\nusing this:\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dom (map_mmupd PRED (E `` {v} - dom PRED) v) =\n                      N \\<union> (E `` {v} - dom PRED) \\<union>\n                      {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 4. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "using C_ss"], ["proof (prove)\nusing this:\n  C \\<subseteq> Vd d\n\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> C - {v} \\<subseteq> Vd d\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> N \\<union> (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (unfold N_eq) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> Vd (d + 1) \\<inter> E `` (Vd d - C) \\<union>\n                      (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (frule CVdI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst; v \\<in> Vd d\\<rbrakk>\n    \\<Longrightarrow> Vd (d + 1) \\<inter> E `` (Vd d - C) \\<union>\n                      (E `` {v} - dom PRED) =\n                      Vd (d + 1) \\<inter> E `` (Vd d - (C - {v}))\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (auto) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; v \\<in> Vd d; (v, x) \\<in> E;\n        PRED x = None\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Vd (Suc d)\n 2. \\<And>x y.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; x \\<in> Vd (Suc d);\n        (v, x) \\<in> E; v \\<in> Vd d; PRED x = Some y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> E `` (Vd d - C)\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (erule (1) Vd_succ)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; (v, x) \\<in> E;\n        PRED x = None\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<le>d. x \\<notin> Vd i\n 2. \\<And>x y.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; x \\<in> Vd (Suc d);\n        (v, x) \\<in> E; v \\<in> Vd d; PRED x = Some y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> E `` (Vd d - C)\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "using VIS_eq"], ["proof (prove)\nusing this:\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; (v, x) \\<in> E;\n        PRED x = None\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<le>d. x \\<notin> Vd i\n 2. \\<And>x y.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; x \\<in> Vd (Suc d);\n        (v, x) \\<in> E; v \\<in> Vd d; PRED x = Some y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> E `` (Vd d - C)\n 3. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>v \\<in> C; v \\<noteq> dst; x \\<in> Vd (Suc d);\n        (v, x) \\<in> E; v \\<in> Vd d; PRED x = Some y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> E `` (Vd d - C)\n 2. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply (auto dest!: inPREDD simp: N_eq in_Vd_conv) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "using dst_ne_VIS assms(2)"], ["proof (prove)\nusing this:\n  dst \\<notin> dom PRED\n  dst \\<notin> E `` {v} - dom PRED\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> C; v \\<noteq> dst\\<rbrakk>\n    \\<Longrightarrow> dst\n                      \\<notin> dom (map_mmupd PRED (E `` {v} - dom PRED) v)", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nf_invar' c src dst (map_mmupd PRED (E `` {v} - dom PRED) v) (C - {v})\n   (N \\<union> (E `` {v} - dom PRED)) d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_init: \"\\<lbrakk>src\\<noteq>dst; src\\<in>V; finite V\\<rbrakk> \n    \\<Longrightarrow> nf_invar c src dst [src \\<mapsto> src] {src} {} 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V\\<rbrakk>\n    \\<Longrightarrow> nf_invar c src dst [src \\<mapsto> src] {src} {} 0", "apply unfold_locales"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V\\<rbrakk>\n    \\<Longrightarrow> src \\<in> V\n 2. \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V\\<rbrakk>\n    \\<Longrightarrow> finite V\n 3. \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V\\<rbrakk>\n    \\<Longrightarrow> [src \\<mapsto> src] src = Some src\n 4. \\<And>v u.\n       \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V; v \\<noteq> src;\n        [src \\<mapsto> src] v = Some u\\<rbrakk>\n       \\<Longrightarrow> min_dist src v = Suc (min_dist src u)\n 5. \\<And>v u.\n       \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V; v \\<noteq> src;\n        [src \\<mapsto> src] v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 6. \\<And>v u.\n       \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V;\n        [src \\<mapsto> src] v = Some u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> dom [src \\<mapsto> src]\n 7. \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V\\<rbrakk>\n    \\<Longrightarrow> dom [src \\<mapsto> src] =\n                      {} \\<union>\n                      {u. \\<exists>i\\<le>0.\n                             u \\<in> pre_bfs_invar.Vd c src i}\n 8. \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V\\<rbrakk>\n    \\<Longrightarrow> {src} \\<subseteq> pre_bfs_invar.Vd c src 0\n 9. \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V\\<rbrakk>\n    \\<Longrightarrow> {} =\n                      pre_bfs_invar.Vd c src (0 + 1) \\<inter>\n                      E `` (pre_bfs_invar.Vd c src 0 - {src})\n 10. \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V\\<rbrakk>\n     \\<Longrightarrow> dst \\<notin> dom [src \\<mapsto> src]\nA total of 11 subgoals...", "apply (auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v u.\n       \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V;\n        (if v = src then Some src else None) = Some u\\<rbrakk>\n       \\<Longrightarrow> u = src\n 2. \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V\\<rbrakk>\n    \\<Longrightarrow> src \\<in> pre_bfs_invar.Vd c src 0\n 3. \\<And>x.\n       \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V;\n        x \\<in> pre_bfs_invar.Vd c src 0\\<rbrakk>\n       \\<Longrightarrow> x = src\n 4. \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V\\<rbrakk>\n    \\<Longrightarrow> src \\<in> pre_bfs_invar.Vd c src 0\n 5. \\<And>x xa.\n       \\<lbrakk>src \\<noteq> dst; src \\<in> V; finite V;\n        x \\<in> pre_bfs_invar.Vd c src (Suc 0); (xa, x) \\<in> E;\n        xa \\<in> pre_bfs_invar.Vd c src 0\\<rbrakk>\n       \\<Longrightarrow> xa = src", "apply (auto simp: pre_bfs_invar.Vd_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in nf_invar) invar_exit:\n    assumes \"dst\\<in>C\"\n    shows \"f_invar c src dst PRED d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_invar c src dst PRED d", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. dst \\<in> dom PRED \\<inter> Vd d", "using assms VIS_eq C_ss"], ["proof (prove)\nusing this:\n  dst \\<in> C\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n  C \\<subseteq> Vd d\n\ngoal (1 subgoal):\n 1. dst \\<in> dom PRED \\<inter> Vd d", "by auto"], ["", "lemma (in nf_invar) invar_C_ss_V: \"u\\<in>C \\<Longrightarrow> u\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> C \\<Longrightarrow> u \\<in> V", "apply (drule CVdI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> Vd d \\<Longrightarrow> u \\<in> V", "apply (auto simp: in_Vd_conv connected_inV_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in nf_invar) invar_N_ss_Vis: \"u\\<in>N \\<Longrightarrow> \\<exists>v. PRED u = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> N \\<Longrightarrow> \\<exists>v. PRED u = Some v", "using VIS_eq"], ["proof (prove)\nusing this:\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n\ngoal (1 subgoal):\n 1. u \\<in> N \\<Longrightarrow> \\<exists>v. PRED u = Some v", "by auto"], ["", "lemma (in pre_bfs_invar) Vdsucinter_conv[simp]: \n    \"Vd (Suc d) \\<inter> E `` Vd d = Vd (Suc d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vd (Suc d) \\<inter> E `` Vd d = Vd (Suc d)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Vd (Suc d) \\<Longrightarrow> x \\<in> E `` Vd d", "by (metis Image_iff in_Vd_conv min_dist_suc)"], ["", "lemma (in nf_invar') invar_shift:\n    assumes [simp]: \"C={}\"\n    shows \"nf_invar c src dst PRED N {} (Suc d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_invar c src dst PRED N {} (Suc d)", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. dom PRED = {} \\<union> {u. \\<exists>i\\<le>Suc d. u \\<in> Vd i}\n 2. N \\<subseteq> Vd (Suc d)\n 3. {} = Vd (Suc d + 1) \\<inter> E `` (Vd (Suc d) - N)\n 4. dst \\<notin> dom PRED\n 5. N = {} \\<Longrightarrow> {} = {}", "apply vc_solve"], ["proof (prove)\ngoal (4 subgoals):\n 1. dom PRED = {u. \\<exists>i\\<le>Suc d. u \\<in> Vd i}\n 2. \\<And>x. x \\<in> N \\<Longrightarrow> x \\<in> Vd (Suc d)\n 3. {} = Vd (Suc (Suc d)) \\<inter> E `` (Vd (Suc d) - N)\n 4. \\<And>y. PRED dst = Some y \\<Longrightarrow> False", "using VIS_eq N_eq[simplified]"], ["proof (prove)\nusing this:\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n  N = Vd (Suc d)\n\ngoal (4 subgoals):\n 1. dom PRED = {u. \\<exists>i\\<le>Suc d. u \\<in> Vd i}\n 2. \\<And>x. x \\<in> N \\<Longrightarrow> x \\<in> Vd (Suc d)\n 3. {} = Vd (Suc (Suc d)) \\<inter> E `` (Vd (Suc d) - N)\n 4. \\<And>y. PRED dst = Some y \\<Longrightarrow> False", "apply (auto simp add: le_Suc_eq) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> N \\<Longrightarrow> x \\<in> Vd (Suc d)\n 2. {} = Vd (Suc (Suc d)) \\<inter> E `` (Vd (Suc d) - N)\n 3. \\<And>y. PRED dst = Some y \\<Longrightarrow> False", "using N_eq"], ["proof (prove)\nusing this:\n  N = Vd (d + 1) \\<inter> E `` (Vd d - C)\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> N \\<Longrightarrow> x \\<in> Vd (Suc d)\n 2. {} = Vd (Suc (Suc d)) \\<inter> E `` (Vd (Suc d) - N)\n 3. \\<And>y. PRED dst = Some y \\<Longrightarrow> False", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. {} = Vd (Suc (Suc d)) \\<inter> E `` (Vd (Suc d) - N)\n 2. \\<And>y. PRED dst = Some y \\<Longrightarrow> False", "using N_eq[simplified]"], ["proof (prove)\nusing this:\n  N = Vd (Suc d)\n\ngoal (2 subgoals):\n 1. {} = Vd (Suc (Suc d)) \\<inter> E `` (Vd (Suc d) - N)\n 2. \\<And>y. PRED dst = Some y \\<Longrightarrow> False", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. PRED dst = Some y \\<Longrightarrow> False", "using dst_ne_VIS"], ["proof (prove)\nusing this:\n  dst \\<notin> dom PRED\n\ngoal (1 subgoal):\n 1. \\<And>y. PRED dst = Some y \\<Longrightarrow> False", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in nf_invar') invar_restore:\n    assumes [simp]: \"C\\<noteq>{}\"\n    shows \"nf_invar c src dst PRED C N d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nf_invar c src dst PRED C N d", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. C = {} \\<Longrightarrow> N = {}", "by auto"], ["", "definition \"bfs_spec src dst r \\<equiv> (\n    case r of None \\<Rightarrow> \\<not> connected src dst\n            | Some (d,PRED) \\<Rightarrow> connected src dst \n                \\<and> min_dist src dst = d \n                \\<and> valid_PRED c src PRED \n                \\<and> dst\\<in>dom PRED)\""], ["", "lemma (in f_invar) invar_found:\n    shows \"bfs_spec src dst (Some (d,PRED))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bfs_spec src dst (Some (d, PRED))", "unfolding bfs_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case Some (d, PRED) of None \\<Rightarrow> \\<not> local.connected src dst\n    | Some (d, PRED) \\<Rightarrow>\n        local.connected src dst \\<and>\n        ndist dst = d \\<and> valid_PRED c src PRED \\<and> dst \\<in> dom PRED", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.connected src dst \\<and>\n    ndist dst = d \\<and> valid_PRED c src PRED \\<and> dst \\<in> dom PRED", "using dst_found"], ["proof (prove)\nusing this:\n  dst \\<in> dom PRED \\<inter> Vd d\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<and>\n    ndist dst = d \\<and> valid_PRED c src PRED \\<and> dst \\<in> dom PRED", "apply (auto simp: in_Vd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>PRED dst = Some y; local.connected src dst;\n        d = ndist dst\\<rbrakk>\n       \\<Longrightarrow> valid_PRED c src PRED", "by unfold_locales"], ["", "lemma (in nf_invar) invar_not_found:\n    assumes [simp]: \"C={}\"\n    shows \"bfs_spec src dst None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bfs_spec src dst None", "unfolding bfs_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case None of None \\<Rightarrow> \\<not> local.connected src dst\n    | Some (d, PRED) \\<Rightarrow>\n        local.connected src dst \\<and>\n        ndist dst = d \\<and> valid_PRED c src PRED \\<and> dst \\<in> dom PRED", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> local.connected src dst", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "have [simp]: \"N={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = {}", "using empty_assm"], ["proof (prove)\nusing this:\n  C = {} \\<Longrightarrow> N = {}\n\ngoal (1 subgoal):\n 1. N = {}", "by simp"], ["proof (state)\nthis:\n  N = {}\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "assume C: \"connected src dst\""], ["proof (state)\nthis:\n  local.connected src dst\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  local.connected src dst", "obtain d' where dstd': \"dst \\<in> Vd d'\""], ["proof (prove)\nusing this:\n  local.connected src dst\n\ngoal (1 subgoal):\n 1. (\\<And>d'. dst \\<in> Vd d' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_Vd_conv)"], ["proof (state)\nthis:\n  dst \\<in> Vd d'\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "txt \\<open>We make a case-distinction whether \\<open>d'\\<le>d\\<close>:\\<close>"], ["proof (state)\nthis:\n  dst \\<in> Vd d'\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "have \"d'\\<le>d \\<or> Suc d \\<le> d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d' \\<le> d \\<or> Suc d \\<le> d'", "by auto"], ["proof (state)\nthis:\n  d' \\<le> d \\<or> Suc d \\<le> d'\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  d' \\<le> d \\<or> Suc d \\<le> d'\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  d' \\<le> d \\<or> Suc d \\<le> d'\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "assume \"d'\\<le>d\""], ["proof (state)\nthis:\n  d' \\<le> d\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "with VIS_eq dstd'"], ["proof (chain)\npicking this:\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n  dst \\<in> Vd d'\n  d' \\<le> d", "have \"dst \\<in> dom PRED\""], ["proof (prove)\nusing this:\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n  dst \\<in> Vd d'\n  d' \\<le> d\n\ngoal (1 subgoal):\n 1. dst \\<in> dom PRED", "by auto"], ["proof (state)\nthis:\n  dst \\<in> dom PRED\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "with dst_ne_VIS"], ["proof (chain)\npicking this:\n  dst \\<notin> dom PRED\n  dst \\<in> dom PRED", "have False"], ["proof (prove)\nusing this:\n  dst \\<notin> dom PRED\n  dst \\<in> dom PRED\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  d' \\<le> d \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  d' \\<le> d \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  d' \\<le> d \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "assume \"Suc d \\<le> d'\""], ["proof (state)\nthis:\n  Suc d \\<le> d'\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "txt \\<open>In the case \\<open>d+1 \\<le> d'\\<close>, we also obtain a node\n        that has a shortest path of length \\<open>d+1\\<close>:\\<close>"], ["proof (state)\nthis:\n  Suc d \\<le> d'\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "with min_dist_le[OF C] dstd'"], ["proof (chain)\npicking this:\n  ?d' \\<le> ndist dst \\<Longrightarrow>\n  \\<exists>v'. local.connected src v' \\<and> ndist v' = ?d'\n  dst \\<in> Vd d'\n  Suc d \\<le> d'", "obtain v' where \"v' \\<in> Vd (Suc d)\""], ["proof (prove)\nusing this:\n  ?d' \\<le> ndist dst \\<Longrightarrow>\n  \\<exists>v'. local.connected src v' \\<and> ndist v' = ?d'\n  dst \\<in> Vd d'\n  Suc d \\<le> d'\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        v' \\<in> Vd (Suc d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_Vd_conv)"], ["proof (state)\nthis:\n  v' \\<in> Vd (Suc d)\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "txt \\<open>However, the invariant states that such nodes are either in\n        \\<open>N\\<close> or are successors of \\<open>C\\<close>. As \\<open>N\\<close> \n        and \\<open>C\\<close> are both empty, we again get a contradiction.\\<close>"], ["proof (state)\nthis:\n  v' \\<in> Vd (Suc d)\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "with N_eq"], ["proof (chain)\npicking this:\n  N = Vd (d + 1) \\<inter> E `` (Vd d - C)\n  v' \\<in> Vd (Suc d)", "have False"], ["proof (prove)\nusing this:\n  N = Vd (d + 1) \\<inter> E `` (Vd d - C)\n  v' \\<in> Vd (Suc d)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  Suc d \\<le> d' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. local.connected src dst \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  d' \\<le> d \\<or> Suc d \\<le> d'\n  d' \\<le> d \\<Longrightarrow> False\n  Suc d \\<le> d' \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  d' \\<le> d \\<or> Suc d \\<le> d'\n  d' \\<le> d \\<Longrightarrow> False\n  Suc d \\<le> d' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_le_mp: \"\\<lbrakk>m\\<subseteq>\\<^sub>mm'; m k = Some v\\<rbrakk> \\<Longrightarrow> m' k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<subseteq>\\<^sub>m m'; m k = Some v\\<rbrakk>\n    \\<Longrightarrow> m' k = Some v", "by (force simp: map_le_def)"], ["", "lemma (in nf_invar) dst_notin_Vdd[intro, simp]: \"i\\<le>d \\<Longrightarrow> dst\\<notin>Vd i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> d \\<Longrightarrow> dst \\<notin> Vd i", "using VIS_eq dst_ne_VIS"], ["proof (prove)\nusing this:\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n  dst \\<notin> dom PRED\n\ngoal (1 subgoal):\n 1. i \\<le> d \\<Longrightarrow> dst \\<notin> Vd i", "by auto"], ["", "lemma (in nf_invar) invar_exit':\n    assumes \"u\\<in>C\" \"(u,dst) \\<in> E\" \"dst \\<in> dom PRED'\"\n    assumes SS1: \"PRED \\<subseteq>\\<^sub>m PRED'\" \n      and SS2: \"PRED' \\<subseteq>\\<^sub>m map_mmupd PRED (E``{u} - dom PRED) u\"\n    shows \"f_invar c src dst PRED' (Suc d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_invar c src dst PRED' (Suc d)", "apply unfold_locales"], ["proof (prove)\ngoal (7 subgoals):\n 1. src \\<in> V\n 2. finite V\n 3. PRED' src = Some src\n 4. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist u)\n 5. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 6. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 7. dst \\<in> dom PRED' \\<inter> Vd (Suc d)", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. PRED' src = Some src\n 2. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist u)\n 3. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 4. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 5. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "using map_le_mp[OF SS1 PRED_src]"], ["proof (prove)\nusing this:\n  PRED' src = Some src\n\ngoal (5 subgoals):\n 1. PRED' src = Some src\n 2. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist u)\n 3. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 4. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 5. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist u)\n 2. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 3. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 4. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply (drule map_le_mp[OF SS2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<noteq> src;\n        map_mmupd PRED (E `` {u} - dom PRED) u v = Some ua\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist ua)\n 2. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 3. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 4. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply (erule map_mmupdE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<noteq> src; v \\<notin> E `` {u} - dom PRED;\n        PRED v = Some ua\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist ua)\n 2. \\<And>v ua.\n       \\<lbrakk>v \\<noteq> src; v \\<in> E `` {u} - dom PRED; ua = u\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist ua)\n 3. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 4. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 5. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "using PRED_dist"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<noteq> src; PRED ?v = Some ?u\\<rbrakk>\n  \\<Longrightarrow> ndist ?v = Suc (ndist ?u)\n\ngoal (5 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<noteq> src; v \\<notin> E `` {u} - dom PRED;\n        PRED v = Some ua\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist ua)\n 2. \\<And>v ua.\n       \\<lbrakk>v \\<noteq> src; v \\<in> E `` {u} - dom PRED; ua = u\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist ua)\n 3. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 4. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 5. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply auto []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<noteq> src; v \\<in> E `` {u} - dom PRED; ua = u\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist ua)\n 2. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 3. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 4. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply (unfold VIS_eq) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<noteq> src;\n        v \\<in> E `` {u} - (N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i});\n        ua = u\\<rbrakk>\n       \\<Longrightarrow> ndist v = Suc (ndist ua)\n 2. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 3. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 4. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply clarify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v ua x.\n       \\<lbrakk>v \\<noteq> src; (u, v) \\<in> E;\n        ndist v \\<noteq> Suc (ndist u); v \\<notin> N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>d. v \\<in> Vd i\n 2. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 3. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 4. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "using \\<open>u\\<in>C\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> C\n\ngoal (4 subgoals):\n 1. \\<And>v ua x.\n       \\<lbrakk>v \\<noteq> src; (u, v) \\<in> E;\n        ndist v \\<noteq> Suc (ndist u); v \\<notin> N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>d. v \\<in> Vd i\n 2. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 3. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 4. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply (metis CVdI Vd_succ in_Vd_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v u.\n       \\<lbrakk>v \\<noteq> src; PRED' v = Some u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 2. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 3. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply (drule map_le_mp[OF SS2])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<noteq> src;\n        map_mmupd PRED (E `` {u} - dom PRED) u v = Some ua\\<rbrakk>\n       \\<Longrightarrow> (ua, v) \\<in> E\n 2. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 3. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "using PRED_E"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<noteq> src; PRED ?v = Some ?u\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> E\n\ngoal (3 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<noteq> src;\n        map_mmupd PRED (E `` {u} - dom PRED) u v = Some ua\\<rbrakk>\n       \\<Longrightarrow> (ua, v) \\<in> E\n 2. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 3. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply (auto elim!: map_mmupdE) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v u. PRED' v = Some u \\<Longrightarrow> u \\<in> dom PRED'\n 2. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply (drule map_le_mp[OF SS2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v ua.\n       map_mmupd PRED (E `` {u} - dom PRED) u v = Some ua \\<Longrightarrow>\n       ua \\<in> dom PRED'\n 2. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply (erule map_mmupdE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<notin> E `` {u} - dom PRED; PRED v = Some ua\\<rbrakk>\n       \\<Longrightarrow> ua \\<in> dom PRED'\n 2. \\<And>v ua.\n       \\<lbrakk>v \\<in> E `` {u} - dom PRED; ua = u\\<rbrakk>\n       \\<Longrightarrow> ua \\<in> dom PRED'\n 3. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "using map_le_implies_dom_le[OF SS1]"], ["proof (prove)\nusing this:\n  dom PRED \\<subseteq> dom PRED'\n\ngoal (3 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<notin> E `` {u} - dom PRED; PRED v = Some ua\\<rbrakk>\n       \\<Longrightarrow> ua \\<in> dom PRED'\n 2. \\<And>v ua.\n       \\<lbrakk>v \\<in> E `` {u} - dom PRED; ua = u\\<rbrakk>\n       \\<Longrightarrow> ua \\<in> dom PRED'\n 3. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "using PRED_closed"], ["proof (prove)\nusing this:\n  dom PRED \\<subseteq> dom PRED'\n  PRED ?v = Some ?u \\<Longrightarrow> ?u \\<in> dom PRED\n\ngoal (3 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<notin> E `` {u} - dom PRED; PRED v = Some ua\\<rbrakk>\n       \\<Longrightarrow> ua \\<in> dom PRED'\n 2. \\<And>v ua.\n       \\<lbrakk>v \\<in> E `` {u} - dom PRED; ua = u\\<rbrakk>\n       \\<Longrightarrow> ua \\<in> dom PRED'\n 3. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply (blast) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<in> E `` {u} - dom PRED; ua = u\\<rbrakk>\n       \\<Longrightarrow> ua \\<in> dom PRED'\n 2. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "using C_ss_VIS[OF \\<open>u\\<in>C\\<close>] map_le_implies_dom_le[OF SS1]"], ["proof (prove)\nusing this:\n  u \\<in> dom PRED\n  dom PRED \\<subseteq> dom PRED'\n\ngoal (2 subgoals):\n 1. \\<And>v ua.\n       \\<lbrakk>v \\<in> E `` {u} - dom PRED; ua = u\\<rbrakk>\n       \\<Longrightarrow> ua \\<in> dom PRED'\n 2. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "using \\<open>dst \\<in> dom PRED'\\<close>"], ["proof (prove)\nusing this:\n  dst \\<in> dom PRED'\n\ngoal (1 subgoal):\n 1. dst \\<in> dom PRED' \\<and> dst \\<in> Vd (Suc d)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. dst \\<in> dom PRED' \\<Longrightarrow> dst \\<in> Vd (Suc d)", "using \\<open>u\\<in>C\\<close> CVdI[OF \\<open>u\\<in>C\\<close>] \\<open>(u,dst)\\<in>E\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> C\n  u \\<in> Vd d\n  (u, dst) \\<in> E\n\ngoal (1 subgoal):\n 1. dst \\<in> dom PRED' \\<Longrightarrow> dst \\<in> Vd (Suc d)", "apply (auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>u \\<in> C; u \\<in> Vd d; (u, dst) \\<in> E;\n        PRED' dst = Some y\\<rbrakk>\n       \\<Longrightarrow> dst \\<in> Vd (Suc d)", "apply (erule (1) Vd_succ)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>u \\<in> C; (u, dst) \\<in> E; PRED' dst = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<le>d. dst \\<notin> Vd i", "using VIS_eq"], ["proof (prove)\nusing this:\n  dom PRED = N \\<union> {u. \\<exists>i\\<le>d. u \\<in> Vd i}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>u \\<in> C; (u, dst) \\<in> E; PRED' dst = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<le>d. dst \\<notin> Vd i", "apply (auto) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"max_dist src \\<equiv> Max (min_dist src`V)\""], ["", "definition \"outer_loop_rel src \\<equiv> \n    inv_image (\n        less_than_bool \n        <*lex*> greater_bounded (max_dist src + 1) \n        <*lex*> finite_psubset) \n      (\\<lambda>(f,PRED,C,N,d). (\\<not>f,d,C))\""], ["", "lemma outer_loop_rel_wf: \n    assumes \"finite V\"\n    shows \"wf (outer_loop_rel src)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (outer_loop_rel src)", "using assms"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. wf (outer_loop_rel src)", "unfolding outer_loop_rel_def"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. wf (inv_image\n         (less_than_bool <*lex*>\n          greater_bounded (max_dist src + 1) <*lex*> finite_psubset)\n         (\\<lambda>(f, PRED, C, N, d). (\\<not> f, d, C)))", "by auto"], ["", "lemma (in nf_invar) C_ne_max_dist:\n    assumes \"C\\<noteq>{}\"\n    shows \"d \\<le> max_dist src\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> max_dist src", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<le> max_dist src", "from assms"], ["proof (chain)\npicking this:\n  C \\<noteq> {}", "obtain u where \"u\\<in>C\""], ["proof (prove)\nusing this:\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u. u \\<in> C \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> C\n\ngoal (1 subgoal):\n 1. d \\<le> max_dist src", "with C_ss"], ["proof (chain)\npicking this:\n  C \\<subseteq> Vd d\n  u \\<in> C", "have \"u\\<in>Vd d\""], ["proof (prove)\nusing this:\n  C \\<subseteq> Vd d\n  u \\<in> C\n\ngoal (1 subgoal):\n 1. u \\<in> Vd d", "by auto"], ["proof (state)\nthis:\n  u \\<in> Vd d\n\ngoal (1 subgoal):\n 1. d \\<le> max_dist src", "hence \"min_dist src u = d\" \"u\\<in>V\""], ["proof (prove)\nusing this:\n  u \\<in> Vd d\n\ngoal (1 subgoal):\n 1. ndist u = d &&& u \\<in> V", "by (auto simp: in_Vd_conv connected_inV_iff)"], ["proof (state)\nthis:\n  ndist u = d\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. d \\<le> max_dist src", "thus \"d\\<le>max_dist src\""], ["proof (prove)\nusing this:\n  ndist u = d\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. d \\<le> max_dist src", "unfolding max_dist_def"], ["proof (prove)\nusing this:\n  ndist u = d\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. d \\<le> Max (ndist ` V)", "by auto"], ["proof (state)\nthis:\n  d \\<le> max_dist src\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in nf_invar) Vd_ss_V: \"Vd d \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vd d \\<subseteq> V", "by (auto simp: Vd_def connected_inV_iff)"], ["", "lemma (in nf_invar) finite_C[simp, intro!]: \"finite C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite C", "using C_ss FIN_V Vd_ss_V"], ["proof (prove)\nusing this:\n  C \\<subseteq> Vd d\n  finite V\n  Vd d \\<subseteq> V\n\ngoal (1 subgoal):\n 1. finite C", "by (blast intro: finite_subset)"], ["", "lemma (in nf_invar) finite_succ: \"finite (E``{u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (E `` {u})", "by auto"], ["", "theorem pre_bfs_correct: \n    assumes [simp]: \"src\\<in>V\" \"src\\<noteq>dst\"       \n    assumes [simp]: \"finite V\"\n    shows \"pre_bfs src dst \\<le> SPEC (bfs_spec src dst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_bfs src dst \\<le> SPEC (bfs_spec src dst)", "unfolding pre_bfs_def add_succ_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sub>T\\<^bsup>outer_loop_invar src dst\\<^esup>\n     (\\<lambda>(f, PRED, C, N, d). f = False \\<and> C \\<noteq> {})\n     (\\<lambda>(f, PRED, C, N, d).\n         (spec v. v \\<in> C) \\<bind>\n         (\\<lambda>v.\n             let C = C - {v}\n             in assert (v \\<in> V) \\<bind>\n                (\\<lambda>_.\n                    let succ = E `` {v}\n                    in assert (finite succ) \\<bind>\n                       (\\<lambda>_.\n                           assert (N \\<subseteq> dom PRED) \\<bind>\n                           (\\<lambda>_.\n                               SPEC\n                                (\\<lambda>(f, PRED', N').\n                                    case f of\n                                    True \\<Rightarrow>\ndst \\<in> succ - dom PRED \\<and>\nPRED \\<subseteq>\\<^sub>m PRED' \\<and>\nPRED' \\<subseteq>\\<^sub>m map_mmupd PRED (succ - dom PRED) v \\<and>\ndst \\<in> dom PRED'\n                                    | False \\<Rightarrow>\n  dst \\<notin> succ - dom PRED \\<and>\n  PRED' = map_mmupd PRED (succ - dom PRED) v \\<and>\n  N' = N \\<union> (succ - dom PRED))) \\<bind>\n                           (\\<lambda>(f, PRED, N).\n                               if f then return (f, PRED, C, N, d + 1)\n                               else assert\n                                     (assn1 src dst\n (f, PRED, C, N, d)) \\<bind>\n                                    (\\<lambda>_.\n  if C = {} then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n  else return (f, PRED, C, N, d)))))))\n     (False, [src \\<mapsto> src], {src}, {}, 0) \\<bind>\n    (\\<lambda>(f, PRED, uu_, uu_, d).\n        if f then return (Some (d, PRED)) else return None)\n    \\<le> SPEC (bfs_spec src dst)", "apply (intro refine_vcg)"], ["proof (prove)\ngoal (11 subgoals):\n 1. wf ?R1\n 2. outer_loop_invar src dst (False, [src \\<mapsto> src], {src}, {}, 0)\n 3. \\<And>s a b aa ba ab bb ac bc x.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc);\n        x \\<in> ab\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 4. \\<And>s a b aa ba ab bb ac bc x.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> finite (E `` {x})\n 5. \\<And>s a b aa ba ab bb ac bc x.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> ac \\<subseteq> dom aa\n 6. \\<And>s a b aa ba ab bb ac bc x xa ad bd ae be.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V; finite (E `` {x}); ac \\<subseteq> dom aa;\n        case xa of\n        (True, PRED', N') \\<Rightarrow>\n          dst \\<in> E `` {x} - dom aa \\<and>\n          aa \\<subseteq>\\<^sub>m PRED' \\<and>\n          PRED' \\<subseteq>\\<^sub>m\n          map_mmupd aa (E `` {x} - dom aa) x \\<and>\n          dst \\<in> dom PRED'\n        | (False, PRED', N') \\<Rightarrow>\n            dst \\<notin> E `` {x} - dom aa \\<and>\n            PRED' = map_mmupd aa (E `` {x} - dom aa) x \\<and>\n            N' = ac \\<union> (E `` {x} - dom aa);\n        xa = (ad, bd); bd = (ae, be); ad\\<rbrakk>\n       \\<Longrightarrow> outer_loop_invar src dst\n                          (ad, ae, ab - {x}, be, bc + 1) \\<and>\n                         ((ad, ae, ab - {x}, be, bc + 1), s) \\<in> ?R1\n 7. \\<And>s a b aa ba ab bb ac bc x xa ad bd ae be.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V; finite (E `` {x}); ac \\<subseteq> dom aa;\n        case xa of\n        (True, PRED', N') \\<Rightarrow>\n          dst \\<in> E `` {x} - dom aa \\<and>\n          aa \\<subseteq>\\<^sub>m PRED' \\<and>\n          PRED' \\<subseteq>\\<^sub>m\n          map_mmupd aa (E `` {x} - dom aa) x \\<and>\n          dst \\<in> dom PRED'\n        | (False, PRED', N') \\<Rightarrow>\n            dst \\<notin> E `` {x} - dom aa \\<and>\n            PRED' = map_mmupd aa (E `` {x} - dom aa) x \\<and>\n            N' = ac \\<union> (E `` {x} - dom aa);\n        xa = (ad, bd); bd = (ae, be); \\<not> ad\\<rbrakk>\n       \\<Longrightarrow> assn1 src dst (ad, ae, ab - {x}, be, bc)\n 8. \\<And>s a b aa ba ab bb ac bc x xa ad bd ae be.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V; finite (E `` {x}); ac \\<subseteq> dom aa;\n        case xa of\n        (True, PRED', N') \\<Rightarrow>\n          dst \\<in> E `` {x} - dom aa \\<and>\n          aa \\<subseteq>\\<^sub>m PRED' \\<and>\n          PRED' \\<subseteq>\\<^sub>m\n          map_mmupd aa (E `` {x} - dom aa) x \\<and>\n          dst \\<in> dom PRED'\n        | (False, PRED', N') \\<Rightarrow>\n            dst \\<notin> E `` {x} - dom aa \\<and>\n            PRED' = map_mmupd aa (E `` {x} - dom aa) x \\<and>\n            N' = ac \\<union> (E `` {x} - dom aa);\n        xa = (ad, bd); bd = (ae, be); \\<not> ad;\n        assn1 src dst (ad, ae, ab - {x}, be, bc); ab - {x} = {}\\<rbrakk>\n       \\<Longrightarrow> outer_loop_invar src dst\n                          (ad, ae, be, {}, bc + 1) \\<and>\n                         ((ad, ae, be, {}, bc + 1), s) \\<in> ?R1\n 9. \\<And>s a b aa ba ab bb ac bc x xa ad bd ae be.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V; finite (E `` {x}); ac \\<subseteq> dom aa;\n        case xa of\n        (True, PRED', N') \\<Rightarrow>\n          dst \\<in> E `` {x} - dom aa \\<and>\n          aa \\<subseteq>\\<^sub>m PRED' \\<and>\n          PRED' \\<subseteq>\\<^sub>m\n          map_mmupd aa (E `` {x} - dom aa) x \\<and>\n          dst \\<in> dom PRED'\n        | (False, PRED', N') \\<Rightarrow>\n            dst \\<notin> E `` {x} - dom aa \\<and>\n            PRED' = map_mmupd aa (E `` {x} - dom aa) x \\<and>\n            N' = ac \\<union> (E `` {x} - dom aa);\n        xa = (ad, bd); bd = (ae, be); \\<not> ad;\n        assn1 src dst (ad, ae, ab - {x}, be, bc);\n        ab - {x} \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> outer_loop_invar src dst\n                          (ad, ae, ab - {x}, be, bc) \\<and>\n                         ((ad, ae, ab - {x}, be, bc), s) \\<in> ?R1\n 10. \\<And>s a b aa ba ab bb ac bc.\n        \\<lbrakk>outer_loop_invar src dst s;\n         \\<not> (case s of\n                 (f, PRED, C, N, d) \\<Rightarrow>\n                   f = False \\<and> C \\<noteq> {});\n         s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); a\\<rbrakk>\n        \\<Longrightarrow> bfs_spec src dst (Some (bc, aa))\nA total of 11 subgoals...", "apply (rule outer_loop_rel_wf[where src=src])"], ["proof (prove)\ngoal (11 subgoals):\n 1. finite V\n 2. outer_loop_invar src dst (False, [src \\<mapsto> src], {src}, {}, 0)\n 3. \\<And>s a b aa ba ab bb ac bc x.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc);\n        x \\<in> ab\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 4. \\<And>s a b aa ba ab bb ac bc x.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> finite (E `` {x})\n 5. \\<And>s a b aa ba ab bb ac bc x.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> ac \\<subseteq> dom aa\n 6. \\<And>s a b aa ba ab bb ac bc x xa ad bd ae be.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V; finite (E `` {x}); ac \\<subseteq> dom aa;\n        case xa of\n        (True, PRED', N') \\<Rightarrow>\n          dst \\<in> E `` {x} - dom aa \\<and>\n          aa \\<subseteq>\\<^sub>m PRED' \\<and>\n          PRED' \\<subseteq>\\<^sub>m\n          map_mmupd aa (E `` {x} - dom aa) x \\<and>\n          dst \\<in> dom PRED'\n        | (False, PRED', N') \\<Rightarrow>\n            dst \\<notin> E `` {x} - dom aa \\<and>\n            PRED' = map_mmupd aa (E `` {x} - dom aa) x \\<and>\n            N' = ac \\<union> (E `` {x} - dom aa);\n        xa = (ad, bd); bd = (ae, be); ad\\<rbrakk>\n       \\<Longrightarrow> outer_loop_invar src dst\n                          (ad, ae, ab - {x}, be, bc + 1) \\<and>\n                         ((ad, ae, ab - {x}, be, bc + 1), s)\n                         \\<in> outer_loop_rel src\n 7. \\<And>s a b aa ba ab bb ac bc x xa ad bd ae be.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V; finite (E `` {x}); ac \\<subseteq> dom aa;\n        case xa of\n        (True, PRED', N') \\<Rightarrow>\n          dst \\<in> E `` {x} - dom aa \\<and>\n          aa \\<subseteq>\\<^sub>m PRED' \\<and>\n          PRED' \\<subseteq>\\<^sub>m\n          map_mmupd aa (E `` {x} - dom aa) x \\<and>\n          dst \\<in> dom PRED'\n        | (False, PRED', N') \\<Rightarrow>\n            dst \\<notin> E `` {x} - dom aa \\<and>\n            PRED' = map_mmupd aa (E `` {x} - dom aa) x \\<and>\n            N' = ac \\<union> (E `` {x} - dom aa);\n        xa = (ad, bd); bd = (ae, be); \\<not> ad\\<rbrakk>\n       \\<Longrightarrow> assn1 src dst (ad, ae, ab - {x}, be, bc)\n 8. \\<And>s a b aa ba ab bb ac bc x xa ad bd ae be.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V; finite (E `` {x}); ac \\<subseteq> dom aa;\n        case xa of\n        (True, PRED', N') \\<Rightarrow>\n          dst \\<in> E `` {x} - dom aa \\<and>\n          aa \\<subseteq>\\<^sub>m PRED' \\<and>\n          PRED' \\<subseteq>\\<^sub>m\n          map_mmupd aa (E `` {x} - dom aa) x \\<and>\n          dst \\<in> dom PRED'\n        | (False, PRED', N') \\<Rightarrow>\n            dst \\<notin> E `` {x} - dom aa \\<and>\n            PRED' = map_mmupd aa (E `` {x} - dom aa) x \\<and>\n            N' = ac \\<union> (E `` {x} - dom aa);\n        xa = (ad, bd); bd = (ae, be); \\<not> ad;\n        assn1 src dst (ad, ae, ab - {x}, be, bc); ab - {x} = {}\\<rbrakk>\n       \\<Longrightarrow> outer_loop_invar src dst\n                          (ad, ae, be, {}, bc + 1) \\<and>\n                         ((ad, ae, be, {}, bc + 1), s)\n                         \\<in> outer_loop_rel src\n 9. \\<And>s a b aa ba ab bb ac bc x xa ad bd ae be.\n       \\<lbrakk>outer_loop_invar src dst s;\n        case s of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); x \\<in> ab;\n        x \\<in> V; finite (E `` {x}); ac \\<subseteq> dom aa;\n        case xa of\n        (True, PRED', N') \\<Rightarrow>\n          dst \\<in> E `` {x} - dom aa \\<and>\n          aa \\<subseteq>\\<^sub>m PRED' \\<and>\n          PRED' \\<subseteq>\\<^sub>m\n          map_mmupd aa (E `` {x} - dom aa) x \\<and>\n          dst \\<in> dom PRED'\n        | (False, PRED', N') \\<Rightarrow>\n            dst \\<notin> E `` {x} - dom aa \\<and>\n            PRED' = map_mmupd aa (E `` {x} - dom aa) x \\<and>\n            N' = ac \\<union> (E `` {x} - dom aa);\n        xa = (ad, bd); bd = (ae, be); \\<not> ad;\n        assn1 src dst (ad, ae, ab - {x}, be, bc);\n        ab - {x} \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> outer_loop_invar src dst\n                          (ad, ae, ab - {x}, be, bc) \\<and>\n                         ((ad, ae, ab - {x}, be, bc), s)\n                         \\<in> outer_loop_rel src\n 10. \\<And>s a b aa ba ab bb ac bc.\n        \\<lbrakk>outer_loop_invar src dst s;\n         \\<not> (case s of\n                 (f, PRED, C, N, d) \\<Rightarrow>\n                   f = False \\<and> C \\<noteq> {});\n         s = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc); a\\<rbrakk>\n        \\<Longrightarrow> bfs_spec src dst (Some (bc, aa))\nA total of 11 subgoals...", "apply (vc_solve simp:\n      invar_init \n      nf_invar.invar_exit' \n      nf_invar.invar_C_ss_V \n      nf_invar.invar_succ_step\n      nf_invar'.invar_shift\n      nf_invar'.invar_restore        \n      f_invar.invar_found\n      nf_invar.invar_not_found\n      nf_invar.invar_N_ss_Vis\n      nf_invar.finite_succ\n      )"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ad aaa aba aca bca x ada aea bea y.\n       \\<lbrakk>nf_invar c src dst aaa aba aca bca; x \\<in> aba;\n        aca \\<subseteq> dom aaa; ada; \\<not> ad; aba \\<noteq> {};\n        (x, dst) \\<in> E;\n        ((True, aea, aba - {x}, bea, Suc bca), False, aaa, aba, aca, bca)\n        \\<notin> outer_loop_rel src;\n        aaa \\<subseteq>\\<^sub>m aea;\n        aea \\<subseteq>\\<^sub>m map_mmupd aaa (E `` {x} - dom aaa) x;\n        aea dst = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. aaa dst = Some y\n 2. \\<And>ad aaa aba aca bca x ada.\n       \\<lbrakk>nf_invar c src dst aaa aba aca bca; x \\<in> aba;\n        aca \\<subseteq> dom aaa;\n        (x, dst) \\<in> E \\<longrightarrow> dst \\<in> dom aaa; \\<not> ada;\n        nf_invar' c src dst (map_mmupd aaa (E `` {x} - dom aaa) x) {}\n         (aca \\<union> (E `` {x} - dom aaa)) bca;\n        aba \\<subseteq> {x}; \\<not> ad; aba \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((False, map_mmupd aaa (E `` {x} - dom aaa) x,\n                           aca \\<union> (E `` {x} - dom aaa), {}, Suc bca),\n                          False, aaa, aba, aca, bca)\n                         \\<in> outer_loop_rel src\n 3. \\<And>ad aaa aba aca bca x ada xa.\n       \\<lbrakk>nf_invar c src dst aaa aba aca bca; x \\<in> aba;\n        aca \\<subseteq> dom aaa;\n        (x, dst) \\<in> E \\<longrightarrow> dst \\<in> dom aaa; \\<not> ada;\n        ((False, map_mmupd aaa (E `` {x} - dom aaa) x, aba - {x},\n          aca \\<union> (E `` {x} - dom aaa), bca),\n         False, aaa, aba, aca, bca)\n        \\<notin> outer_loop_rel src;\n        xa \\<in> aba; \\<not> ad; aba \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> xa = x", "apply (vc_solve \n      simp: remove_subset outer_loop_rel_def \n      simp: nf_invar.C_ne_max_dist nf_invar.finite_C)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Presentation for Paper *)"], ["", "definition bfs_core :: \"node \\<Rightarrow> node \\<Rightarrow> (nat \\<times> (node\\<rightharpoonup>node)) option nres\"\n    where \"bfs_core src dst \\<equiv> do {\n    (f,P,_,_,d) \\<leftarrow> while\\<^sub>T (\\<lambda>(f,P,C,N,d). f=False \\<and> C\\<noteq>{})\n      (\\<lambda>(f,P,C,N,d). do {\n        v \\<leftarrow> spec v. v\\<in>C; let C = C-{v};\n        let succ = (E``{v});\n        (f,P,N) \\<leftarrow> add_succ_spec dst succ v P N;\n        if f then\n          return (f,P,C,N,d+1)\n        else do {\n          if (C={}) then do {\n            let C=N; let N={}; let d=d+1;\n            return (f,P,C,N,d)\n          } else return (f,P,C,N,d)\n        }  \n      })\n      (False,[src\\<mapsto>src],{src},{},0::nat);\n    if f then return (Some (d, P)) else return None\n    }\""], ["", "theorem \n    assumes \"src\\<in>V\" \"src\\<noteq>dst\" \"finite V\"\n    shows \"bfs_core src dst \\<le> (spec p. bfs_spec src dst p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bfs_core src dst \\<le> (spec p. bfs_spec src dst p)", "apply (rule order_trans[OF _ pre_bfs_correct])"], ["proof (prove)\ngoal (4 subgoals):\n 1. bfs_core src dst \\<le> pre_bfs src dst\n 2. src \\<in> V\n 3. src \\<noteq> dst\n 4. finite V", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. bfs_core src dst \\<le> \\<Down> Id (pre_bfs src dst)\n 2. src \\<in> V\n 3. src \\<noteq> dst\n 4. finite V", "unfolding bfs_core_def pre_bfs_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. while\\<^sub>T (\\<lambda>(f, P, C, N, d). f = False \\<and> C \\<noteq> {})\n     (\\<lambda>(f, P, C, N, d).\n         (spec v. v \\<in> C) \\<bind>\n         (\\<lambda>v.\n             let C = C - {v}; succ = E `` {v}\n             in add_succ_spec dst succ v P N \\<bind>\n                (\\<lambda>(f, P, N).\n                    if f then return (f, P, C, N, d + 1)\n                    else if C = {}\n                         then let C = N; N = {}; d = d + 1\n                              in return (f, P, C, N, d)\n                         else return (f, P, C, N, d))))\n     (False, [src \\<mapsto> src], {src}, {}, 0) \\<bind>\n    (\\<lambda>(f, P, uu_, uu_, d).\n        if f then return (Some (d, P)) else return None)\n    \\<le> \\<Down> Id\n           (while\\<^sub>T\\<^bsup>outer_loop_invar src dst\\<^esup>\n             (\\<lambda>(f, PRED, C, N, d). f = False \\<and> C \\<noteq> {})\n             (\\<lambda>(f, PRED, C, N, d).\n                 (spec v. v \\<in> C) \\<bind>\n                 (\\<lambda>v.\n                     let C = C - {v}\n                     in assert (v \\<in> V) \\<bind>\n                        (\\<lambda>_.\n                            let succ = E `` {v}\n                            in assert (finite succ) \\<bind>\n                               (\\<lambda>_.\n                                   add_succ_spec dst succ v PRED N \\<bind>\n                                   (\\<lambda>(f, PRED, N).\n if f then return (f, PRED, C, N, d + 1)\n else assert (assn1 src dst (f, PRED, C, N, d)) \\<bind>\n      (\\<lambda>_.\n          if C = {}\n          then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n          else return (f, PRED, C, N, d)))))))\n             (False, [src \\<mapsto> src], {src}, {}, 0) \\<bind>\n            (\\<lambda>(f, PRED, uu_, uu_, d).\n                if f then return (Some (d, PRED)) else return None))\n 2. src \\<in> V\n 3. src \\<noteq> dst\n 4. finite V", "apply refine_rcg"], ["proof (prove)\ngoal (14 subgoals):\n 1. outer_loop_invar src dst\n     (False, [src \\<mapsto> src], {src}, {}, 0) \\<Longrightarrow>\n    ((False, [src \\<mapsto> src], {src}, {}, 0), False, [src \\<mapsto> src],\n     {src}, {}, 0)\n    \\<in> ?R'9\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x') \\<in> ?R'9; outer_loop_invar src dst x';\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x' = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (x1 = False \\<and> x1b \\<noteq> {}) =\n                         (x1d = False \\<and> x1f \\<noteq> {})\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x') \\<in> ?R'9;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (spec v. v \\<in> x1f) \\<le> (spec v. v \\<in> x1b)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x') \\<in> ?R'9;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va})\\<rbrakk>\n       \\<Longrightarrow> add_succ_spec dst (E `` {v}) v x1e x1g\n                         \\<le> \\<Down>\n                                (?R'417 x x' x1 x2 x1a x2a x1b x2b x1c x2c\n                                  x1d x2d x1e x2e x1f x2f x1g x2g v va)\n                                (add_succ_spec dst (E `` {va}) va x1a x1c)\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n x2n\n       x1o x2o.\n       \\<lbrakk>(x, x') \\<in> ?R'9;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va});\n        (xa, x'a)\n        \\<in> ?R'417 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n               x2f x1g x2g v va;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2n = (x1o, x2o); xa = (x1n, x2n)\\<rbrakk>\n       \\<Longrightarrow> x1n = x1h\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n x2n\n       x1o x2o.\n       \\<lbrakk>(x, x') \\<in> ?R'9;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va});\n        (xa, x'a)\n        \\<in> ?R'417 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n               x2f x1g x2g v va;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2n = (x1o, x2o); xa = (x1n, x2n); x1n;\n        x1h\\<rbrakk>\n       \\<Longrightarrow> ((x1n, x1o, x1f - {v}, x2o, x2g + 1), x1h, x1i,\n                          x1b - {va}, x2i, x2c + 1)\n                         \\<in> ?R'9\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n x2n\n       x1o x2o.\n       \\<lbrakk>(x, x') \\<in> ?R'9;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va});\n        (xa, x'a)\n        \\<in> ?R'417 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n               x2f x1g x2g v va;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2n = (x1o, x2o); xa = (x1n, x2n); \\<not> x1n;\n        \\<not> x1h;\n        \\<not> x1j \\<and> nf_invar' c src dst x1k x1l x1m x2m\\<rbrakk>\n       \\<Longrightarrow> (x1f - {v} = {}) = (x1b - {va} = {})\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n x2n\n       x1o x2o.\n       \\<lbrakk>(x, x') \\<in> ?R'9;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va});\n        (xa, x'a)\n        \\<in> ?R'417 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n               x2f x1g x2g v va;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2n = (x1o, x2o); xa = (x1n, x2n); \\<not> x1n;\n        \\<not> x1h; \\<not> x1j \\<and> nf_invar' c src dst x1k x1l x1m x2m;\n        x1f - {v} = {}; x1b - {va} = {}\\<rbrakk>\n       \\<Longrightarrow> ((x1n, x1o, x2o, {}, x2g + 1), x1h, x1i, x2i, {},\n                          x2c + 1)\n                         \\<in> ?R'9\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n x2n\n       x1o x2o.\n       \\<lbrakk>(x, x') \\<in> ?R'9;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va});\n        (xa, x'a)\n        \\<in> ?R'417 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n               x2f x1g x2g v va;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2n = (x1o, x2o); xa = (x1n, x2n); \\<not> x1n;\n        \\<not> x1h; \\<not> x1j \\<and> nf_invar' c src dst x1k x1l x1m x2m;\n        x1f - {v} \\<noteq> {}; x1b - {va} \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((x1n, x1o, x1f - {v}, x2o, x2g), x1h, x1i,\n                          x1b - {va}, x2i, x2c)\n                         \\<in> ?R'9\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n        x2g.\n        \\<lbrakk>(x, x') \\<in> ?R'9; x2b = (x1c, x2c); x2a = (x1b, x2b);\n         x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n         x2d = (x1e, x2e); x = (x1d, x2d)\\<rbrakk>\n        \\<Longrightarrow> x1d = x1\nA total of 14 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (14 subgoals):\n 1. outer_loop_invar src dst\n     (False, [src \\<mapsto> src], {src}, {}, 0) \\<Longrightarrow>\n    ((False, [src \\<mapsto> src], {src}, {}, 0), False, [src \\<mapsto> src],\n     {src}, {}, 0)\n    \\<in> bool_rel \\<times>\\<^sub>r\n          Id \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x' = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (x1 = False \\<and> x1b \\<noteq> {}) =\n                         (x1d = False \\<and> x1f \\<noteq> {})\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (spec v. v \\<in> x1f) \\<le> (spec v. v \\<in> x1b)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va})\\<rbrakk>\n       \\<Longrightarrow> add_succ_spec dst (E `` {v}) v x1e x1g\n                         \\<le> \\<Down>\n                                (bool_rel \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 \\<langle>nat_rel\\<rangle>set_rel)\n                                (add_succ_spec dst (E `` {va}) va x1a x1c)\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n x2n\n       x1o x2o.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va});\n        (xa, x'a)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>set_rel;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2n = (x1o, x2o); xa = (x1n, x2n)\\<rbrakk>\n       \\<Longrightarrow> x1n = x1h\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n x2n\n       x1o x2o.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va});\n        (xa, x'a)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>set_rel;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2n = (x1o, x2o); xa = (x1n, x2n); x1n;\n        x1h\\<rbrakk>\n       \\<Longrightarrow> ((x1n, x1o, x1f - {v}, x2o, x2g + 1), x1h, x1i,\n                          x1b - {va}, x2i, x2c + 1)\n                         \\<in> bool_rel \\<times>\\<^sub>r\n                               Id \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                               nat_rel\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n x2n\n       x1o x2o.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va});\n        (xa, x'a)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>set_rel;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2n = (x1o, x2o); xa = (x1n, x2n); \\<not> x1n;\n        \\<not> x1h;\n        \\<not> x1j \\<and> nf_invar' c src dst x1k x1l x1m x2m\\<rbrakk>\n       \\<Longrightarrow> (x1f - {v} = {}) = (x1b - {va} = {})\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n x2n\n       x1o x2o.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va});\n        (xa, x'a)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>set_rel;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2n = (x1o, x2o); xa = (x1n, x2n); \\<not> x1n;\n        \\<not> x1h; \\<not> x1j \\<and> nf_invar' c src dst x1k x1l x1m x2m;\n        x1f - {v} = {}; x1b - {va} = {}\\<rbrakk>\n       \\<Longrightarrow> ((x1n, x1o, x2o, {}, x2g + 1), x1h, x1i, x2i, {},\n                          x2c + 1)\n                         \\<in> bool_rel \\<times>\\<^sub>r\n                               Id \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                               nat_rel\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n x2n\n       x1o x2o.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, P, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        v \\<in> {v. v \\<in> x1f}; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        finite (E `` {va});\n        (xa, x'a)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>set_rel;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2n = (x1o, x2o); xa = (x1n, x2n); \\<not> x1n;\n        \\<not> x1h; \\<not> x1j \\<and> nf_invar' c src dst x1k x1l x1m x2m;\n        x1f - {v} \\<noteq> {}; x1b - {va} \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((x1n, x1o, x1f - {v}, x2o, x2g), x1h, x1i,\n                          x1b - {va}, x2i, x2c)\n                         \\<in> bool_rel \\<times>\\<^sub>r\n                               Id \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                               nat_rel\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n        x2g.\n        \\<lbrakk>(x, x')\n                 \\<in> bool_rel \\<times>\\<^sub>r\n                       Id \\<times>\\<^sub>r\n                       \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                       \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                       nat_rel;\n         x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n         x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n         x = (x1d, x2d)\\<rbrakk>\n        \\<Longrightarrow> x1d = x1\nA total of 14 subgoals...", "apply (vc_solve simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Extraction of Result Path\\<close>"], ["", "definition \"extract_rpath src dst PRED \\<equiv> do {\n      (_,p) \\<leftarrow> WHILEIT\n        (\\<lambda>(v,p). \n          v\\<in>dom PRED \n        \\<and> isPath v p dst\n        \\<and> distinct (pathVertices v p)\n        \\<and> (\\<forall>v'\\<in>set (pathVertices v p). \n            pre_bfs_invar.ndist c src v \\<le> pre_bfs_invar.ndist c src v')\n        \\<and> pre_bfs_invar.ndist c src v + length p \n          = pre_bfs_invar.ndist c src dst)\n        (\\<lambda>(v,p). v\\<noteq>src) (\\<lambda>(v,p). do {\n        ASSERT (v\\<in>dom PRED);\n        let u=the (PRED v);\n        let p = (u,v)#p;\n        let v=u;\n        RETURN (v,p)\n      }) (dst,[]);\n      RETURN p\n    }\""], ["", "end"], ["", "context valid_PRED begin"], ["", "lemma extract_rpath_correct:\n      assumes \"dst\\<in>dom PRED\"\n      shows \"extract_rpath src dst PRED \n        \\<le> SPEC (\\<lambda>p. isSimplePath src p dst \\<and> length p = ndist dst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_rpath src dst PRED\n    \\<le> (spec p. isSimplePath src p dst \\<and> length p = ndist dst)", "using assms"], ["proof (prove)\nusing this:\n  dst \\<in> dom PRED\n\ngoal (1 subgoal):\n 1. extract_rpath src dst PRED\n    \\<le> (spec p. isSimplePath src p dst \\<and> length p = ndist dst)", "unfolding extract_rpath_def isSimplePath_def"], ["proof (prove)\nusing this:\n  dst \\<in> dom PRED\n\ngoal (1 subgoal):\n 1. while\\<^sub>T\\<^bsup>\\<lambda>(v, p).\n                            v \\<in> dom PRED \\<and>\n                            isPath v p dst \\<and>\n                            distinct (pathVertices v p) \\<and>\n                            (\\<forall>v'\\<in>set (pathVertices v p).\n                                ndist v \\<le> ndist v') \\<and>\n                            ndist v + length p = ndist dst\\<^esup>\n     (\\<lambda>(v, p). v \\<noteq> src)\n     (\\<lambda>(v, p).\n         assert (v \\<in> dom PRED) \\<bind>\n         (\\<lambda>_.\n             let u = the (PRED v); p = (u, v) # p; v = u in return (v, p)))\n     (dst, []) \\<bind>\n    (\\<lambda>(uu_, p). return p)\n    \\<le> (spec p.\n              (isPath src p dst \\<and> distinct (pathVertices src p)) \\<and>\n              length p = ndist dst)", "apply (refine_vcg wf_measure[where f=\"\\<lambda>(d,_). ndist d\"])"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>dst \\<in> dom PRED; (dst, []) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> dom PRED\n 2. \\<And>x1 x2.\n       \\<lbrakk>dst \\<in> dom PRED; (dst, []) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPath x1 x2 dst\n 3. \\<And>x1 x2.\n       \\<lbrakk>dst \\<in> dom PRED; (dst, []) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices x1 x2)\n 4. \\<And>x1 x2.\n       \\<lbrakk>dst \\<in> dom PRED; (dst, []) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set (pathVertices x1 x2).\n                            ndist x1 \\<le> ndist v'\n 5. \\<And>x1 x2.\n       \\<lbrakk>dst \\<in> dom PRED; (dst, []) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> ndist x1 + length x2 = ndist dst\n 6. \\<And>s a b.\n       \\<lbrakk>dst \\<in> dom PRED;\n        case s of\n        (v, p) \\<Rightarrow>\n          v \\<in> dom PRED \\<and>\n          isPath v p dst \\<and>\n          distinct (pathVertices v p) \\<and>\n          (\\<forall>v'\\<in>set (pathVertices v p).\n              ndist v \\<le> ndist v') \\<and>\n          ndist v + length p = ndist dst;\n        case s of (v, p) \\<Rightarrow> v \\<noteq> src; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> dom PRED\n 7. \\<And>s a b x1 x2.\n       \\<lbrakk>dst \\<in> dom PRED;\n        case s of\n        (v, p) \\<Rightarrow>\n          v \\<in> dom PRED \\<and>\n          isPath v p dst \\<and>\n          distinct (pathVertices v p) \\<and>\n          (\\<forall>v'\\<in>set (pathVertices v p).\n              ndist v \\<le> ndist v') \\<and>\n          ndist v + length p = ndist dst;\n        case s of (v, p) \\<Rightarrow> v \\<noteq> src; s = (a, b);\n        a \\<in> dom PRED;\n        (the (PRED a), (the (PRED a), a) # b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> dom PRED\n 8. \\<And>s a b x1 x2.\n       \\<lbrakk>dst \\<in> dom PRED;\n        case s of\n        (v, p) \\<Rightarrow>\n          v \\<in> dom PRED \\<and>\n          isPath v p dst \\<and>\n          distinct (pathVertices v p) \\<and>\n          (\\<forall>v'\\<in>set (pathVertices v p).\n              ndist v \\<le> ndist v') \\<and>\n          ndist v + length p = ndist dst;\n        case s of (v, p) \\<Rightarrow> v \\<noteq> src; s = (a, b);\n        a \\<in> dom PRED;\n        (the (PRED a), (the (PRED a), a) # b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> isPath x1 x2 dst\n 9. \\<And>s a b x1 x2.\n       \\<lbrakk>dst \\<in> dom PRED;\n        case s of\n        (v, p) \\<Rightarrow>\n          v \\<in> dom PRED \\<and>\n          isPath v p dst \\<and>\n          distinct (pathVertices v p) \\<and>\n          (\\<forall>v'\\<in>set (pathVertices v p).\n              ndist v \\<le> ndist v') \\<and>\n          ndist v + length p = ndist dst;\n        case s of (v, p) \\<Rightarrow> v \\<noteq> src; s = (a, b);\n        a \\<in> dom PRED;\n        (the (PRED a), (the (PRED a), a) # b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices x1 x2)\n 10. \\<And>s a b x1 x2.\n        \\<lbrakk>dst \\<in> dom PRED;\n         case s of\n         (v, p) \\<Rightarrow>\n           v \\<in> dom PRED \\<and>\n           isPath v p dst \\<and>\n           distinct (pathVertices v p) \\<and>\n           (\\<forall>v'\\<in>set (pathVertices v p).\n               ndist v \\<le> ndist v') \\<and>\n           ndist v + length p = ndist dst;\n         case s of (v, p) \\<Rightarrow> v \\<noteq> src; s = (a, b);\n         a \\<in> dom PRED;\n         (the (PRED a), (the (PRED a), a) # b) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>v'\\<in>set (pathVertices x1 x2).\n                             ndist x1 \\<le> ndist v'\nA total of 15 subgoals...", "apply (vc_solve simp: PRED_closed[THEN domD] PRED_E PRED_dist)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba y ya.\n       \\<lbrakk>aa \\<noteq> src; PRED dst = Some y; PRED aa = Some ya;\n        isPath aa ba dst; distinct (pathVertices aa ba);\n        \\<forall>v'\\<in>set (pathVertices aa ba).\n           Suc (ndist ya) \\<le> ndist v';\n        Suc (ndist ya + length ba) = ndist dst;\n        ya \\<in> set (pathVertices aa ba)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba v' y ya.\n       \\<lbrakk>aa \\<noteq> src; v' \\<in> set (pathVertices aa ba);\n        PRED dst = Some y; PRED aa = Some ya; isPath aa ba dst;\n        distinct (pathVertices aa ba);\n        \\<forall>v'\\<in>set (pathVertices aa ba).\n           Suc (ndist ya) \\<le> ndist v';\n        Suc (ndist ya + length ba) = ndist dst\\<rbrakk>\n       \\<Longrightarrow> ndist ya \\<le> ndist v'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context Graph begin"], ["", "definition \"bfs src dst \\<equiv> do {\n      if src=dst then RETURN (Some [])\n      else do {\n        br \\<leftarrow> pre_bfs src dst;\n        case br of\n          None \\<Rightarrow> RETURN None\n        | Some (d,PRED) \\<Rightarrow> do {\n            p \\<leftarrow> extract_rpath src dst PRED;\n            RETURN (Some p)\n          }  \n      }    \n    }\""], ["", "lemma bfs_correct:\n      assumes \"src\\<in>V\" \"finite V\" \n      shows \"bfs src dst \n        \\<le> SPEC (\\<lambda>\n          None \\<Rightarrow> \\<not>connected src dst \n        | Some p \\<Rightarrow> isShortestPath src p dst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bfs src dst\n    \\<le> (spec x.\n              case x of None \\<Rightarrow> \\<not> local.connected src dst\n              | Some p \\<Rightarrow> isShortestPath src p dst)", "unfolding bfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if src = dst then return (Some [])\n     else pre_bfs src dst \\<bind>\n          (\\<lambda>br.\n              case br of None \\<Rightarrow> return None\n              | Some (d, PRED) \\<Rightarrow>\n                  extract_rpath src dst PRED \\<bind>\n                  (\\<lambda>p. return (Some p))))\n    \\<le> (spec x.\n              case x of None \\<Rightarrow> \\<not> local.connected src dst\n              | Some p \\<Rightarrow> isShortestPath src p dst)", "apply (refine_vcg\n        pre_bfs_correct[THEN order_trans]\n        valid_PRED.extract_rpath_correct[THEN order_trans]\n        )"], ["proof (prove)\ngoal (7 subgoals):\n 1. src = dst \\<Longrightarrow>\n    case Some [] of None \\<Rightarrow> \\<not> local.connected src dst\n    | Some p \\<Rightarrow> isShortestPath src p dst\n 2. src \\<noteq> dst \\<Longrightarrow> src \\<in> V\n 3. src \\<noteq> dst \\<Longrightarrow> finite V\n 4. \\<And>x.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = None\\<rbrakk>\n       \\<Longrightarrow> case None of\n                         None \\<Rightarrow> \\<not> local.connected src dst\n                         | Some p \\<Rightarrow> isShortestPath src p dst\n 5. \\<And>x xa a b.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> valid_PRED c src b\n 6. \\<And>x xa a b.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> dst \\<in> dom b\n 7. \\<And>x xa a b xb.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b);\n        isSimplePath src xb dst \\<and> length xb = min_dist src dst\\<rbrakk>\n       \\<Longrightarrow> case Some xb of\n                         None \\<Rightarrow> \\<not> local.connected src dst\n                         | Some p \\<Rightarrow> isShortestPath src p dst", "using assms"], ["proof (prove)\nusing this:\n  src \\<in> V\n  finite V\n\ngoal (7 subgoals):\n 1. src = dst \\<Longrightarrow>\n    case Some [] of None \\<Rightarrow> \\<not> local.connected src dst\n    | Some p \\<Rightarrow> isShortestPath src p dst\n 2. src \\<noteq> dst \\<Longrightarrow> src \\<in> V\n 3. src \\<noteq> dst \\<Longrightarrow> finite V\n 4. \\<And>x.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = None\\<rbrakk>\n       \\<Longrightarrow> case None of\n                         None \\<Rightarrow> \\<not> local.connected src dst\n                         | Some p \\<Rightarrow> isShortestPath src p dst\n 5. \\<And>x xa a b.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> valid_PRED c src b\n 6. \\<And>x xa a b.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> dst \\<in> dom b\n 7. \\<And>x xa a b xb.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b);\n        isSimplePath src xb dst \\<and> length xb = min_dist src dst\\<rbrakk>\n       \\<Longrightarrow> case Some xb of\n                         None \\<Rightarrow> \\<not> local.connected src dst\n                         | Some p \\<Rightarrow> isShortestPath src p dst", "apply (vc_solve \n        simp: bfs_spec_def isShortestPath_min_dist_def isSimplePath_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(* Snippet for paper *)"], ["", "context Finite_Graph begin"], ["", "interpretation Refine_Monadic_Syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "theorem\n      assumes \"src\\<in>V\" \n      shows \"bfs src dst \\<le> (spec p. case p of \n          None \\<Rightarrow> \\<not>connected src dst \n        | Some p \\<Rightarrow> isShortestPath src p dst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bfs src dst\n    \\<le> (spec p.\n              case p of None \\<Rightarrow> \\<not> local.connected src dst\n              | Some p \\<Rightarrow> isShortestPath src p dst)", "unfolding bfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if src = dst then return (Some [])\n     else pre_bfs src dst \\<bind>\n          (\\<lambda>br.\n              case br of None \\<Rightarrow> return None\n              | Some (d, PRED) \\<Rightarrow>\n                  extract_rpath src dst PRED \\<bind>\n                  (\\<lambda>p. return (Some p))))\n    \\<le> (spec p.\n              case p of None \\<Rightarrow> \\<not> local.connected src dst\n              | Some p \\<Rightarrow> isShortestPath src p dst)", "apply (refine_vcg\n        pre_bfs_correct[THEN order_trans]\n        valid_PRED.extract_rpath_correct[THEN order_trans]\n        )"], ["proof (prove)\ngoal (7 subgoals):\n 1. src = dst \\<Longrightarrow>\n    case Some [] of None \\<Rightarrow> \\<not> local.connected src dst\n    | Some p \\<Rightarrow> isShortestPath src p dst\n 2. src \\<noteq> dst \\<Longrightarrow> src \\<in> V\n 3. src \\<noteq> dst \\<Longrightarrow> finite V\n 4. \\<And>x.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = None\\<rbrakk>\n       \\<Longrightarrow> case None of\n                         None \\<Rightarrow> \\<not> local.connected src dst\n                         | Some p \\<Rightarrow> isShortestPath src p dst\n 5. \\<And>x xa a b.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> valid_PRED c src b\n 6. \\<And>x xa a b.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> dst \\<in> dom b\n 7. \\<And>x xa a b xb.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b);\n        isSimplePath src xb dst \\<and> length xb = min_dist src dst\\<rbrakk>\n       \\<Longrightarrow> case Some xb of\n                         None \\<Rightarrow> \\<not> local.connected src dst\n                         | Some p \\<Rightarrow> isShortestPath src p dst", "using assms"], ["proof (prove)\nusing this:\n  src \\<in> V\n\ngoal (7 subgoals):\n 1. src = dst \\<Longrightarrow>\n    case Some [] of None \\<Rightarrow> \\<not> local.connected src dst\n    | Some p \\<Rightarrow> isShortestPath src p dst\n 2. src \\<noteq> dst \\<Longrightarrow> src \\<in> V\n 3. src \\<noteq> dst \\<Longrightarrow> finite V\n 4. \\<And>x.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = None\\<rbrakk>\n       \\<Longrightarrow> case None of\n                         None \\<Rightarrow> \\<not> local.connected src dst\n                         | Some p \\<Rightarrow> isShortestPath src p dst\n 5. \\<And>x xa a b.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> valid_PRED c src b\n 6. \\<And>x xa a b.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> dst \\<in> dom b\n 7. \\<And>x xa a b xb.\n       \\<lbrakk>src \\<noteq> dst; bfs_spec src dst x; x = Some xa;\n        xa = (a, b);\n        isSimplePath src xb dst \\<and> length xb = min_dist src dst\\<rbrakk>\n       \\<Longrightarrow> case Some xb of\n                         None \\<Rightarrow> \\<not> local.connected src dst\n                         | Some p \\<Rightarrow> isShortestPath src p dst", "apply (vc_solve \n        simp: bfs_spec_def isShortestPath_min_dist_def isSimplePath_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Inserting inner Loop and Successor Function\\<close>"], ["", "context Graph begin"], ["", "definition \"inner_loop dst succ u PRED N \\<equiv> FOREACHci\n    (\\<lambda>it (f,PRED',N'). \n        PRED' = map_mmupd PRED ((succ - it) - dom PRED) u \n      \\<and> N' = N \\<union> ((succ - it) - dom PRED)\n      \\<and> f = (dst\\<in>(succ - it) - dom PRED)\n    )\n    (succ)\n    (\\<lambda>(f,PRED,N). \\<not>f)\n    (\\<lambda>v (f,PRED,N). do {\n      if v\\<in>dom PRED then RETURN (f,PRED,N)\n      else do {\n        let PRED = PRED(v \\<mapsto> u);\n        ASSERT (v\\<notin>N);\n        let N = insert v N;\n        RETURN (v=dst,PRED,N)\n      }\n    }) \n    (False,PRED,N)\""], ["", "lemma inner_loop_refine[refine]: \n    (*assumes NSS: \"N \\<subseteq> dom PRED\"*)\n    assumes [simp]: \"finite succ\"\n    assumes [simplified, simp]: \n      \"(succi,succ)\\<in>Id\" \"(ui,u)\\<in>Id\" \"(PREDi,PRED)\\<in>Id\" \"(Ni,N)\\<in>Id\"\n    shows \"inner_loop dst succi ui PREDi Ni \n      \\<le> \\<Down>Id (add_succ_spec dst succ u PRED N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_loop dst succi ui PREDi Ni\n    \\<le> \\<Down> Id (add_succ_spec dst succ u PRED N)", "unfolding inner_loop_def add_succ_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C\\<^bsup>\\<lambda>it (f, PRED', N').\n                              PRED' =\n                              map_mmupd PREDi (succi - it - dom PREDi)\n                               ui \\<and>\n                              N' =\n                              Ni \\<union> (succi - it - dom PREDi) \\<and>\n                              f = (dst \\<in> succi - it - dom PREDi)\\<^esup>\n     succi (\\<lambda>(f, PRED, N). \\<not> f)\n     (\\<lambda>v (f, PRED, N).\n         if v \\<in> dom PRED then return (f, PRED, N)\n         else let PRED = PRED(v \\<mapsto> ui)\n              in assert (v \\<notin> N) \\<bind>\n                 (\\<lambda>_.\n                     let N = insert v N in return (v = dst, PRED, N)))\n     (False, PREDi, Ni)\n    \\<le> \\<Down> Id\n           (assert (N \\<subseteq> dom PRED) \\<bind>\n            (\\<lambda>_.\n                SPEC\n                 (\\<lambda>(f, PRED', N').\n                     case f of\n                     True \\<Rightarrow>\n                       dst \\<in> succ - dom PRED \\<and>\n                       PRED \\<subseteq>\\<^sub>m PRED' \\<and>\n                       PRED' \\<subseteq>\\<^sub>m\n                       map_mmupd PRED (succ - dom PRED) u \\<and>\n                       dst \\<in> dom PRED'\n                     | False \\<Rightarrow>\n                         dst \\<notin> succ - dom PRED \\<and>\n                         PRED' = map_mmupd PRED (succ - dom PRED) u \\<and>\n                         N' = N \\<union> (succ - dom PRED))))", "apply refine_vcg"], ["proof (prove)\ngoal (13 subgoals):\n 1. N \\<subseteq> dom PRED \\<Longrightarrow> finite succi\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x2 = (x1a, x2a);\n        (False, PREDi, Ni) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1a =\n                         map_mmupd PREDi (succi - succi - dom PREDi) ui\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x2 = (x1a, x2a);\n        (False, PREDi, Ni) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2a = Ni \\<union> (succi - succi - dom PREDi)\n 4. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x2 = (x1a, x2a);\n        (False, PREDi, Ni) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = (dst \\<in> succi - succi - dom PREDi)\n 5. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<in> dom aa; x2 = (x1a, x2a);\n        (a, aa, ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1a =\n                         map_mmupd PREDi (succi - (it - {x}) - dom PREDi) ui\n 6. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<in> dom aa; x2 = (x1a, x2a);\n        (a, aa, ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2a = Ni \\<union> (succi - (it - {x}) - dom PREDi)\n 7. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<in> dom aa; x2 = (x1a, x2a);\n        (a, aa, ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = (dst \\<in> succi - (it - {x}) - dom PREDi)\n 8. \\<And>x it \\<sigma> a b aa ba.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<notin> dom aa\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> ba\n 9. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<notin> dom aa; x \\<notin> ba;\n        x2 = (x1a, x2a);\n        (x = dst, aa(x \\<mapsto> ui), insert x ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1a =\n                         map_mmupd PREDi (succi - (it - {x}) - dom PREDi) ui\n 10. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n        \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n         case \\<sigma> of\n         (f, PRED', N') \\<Rightarrow>\n           PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n           N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n           f = (dst \\<in> succi - it - dom PREDi);\n         case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n         \\<sigma> = (a, b); b = (aa, ba); x \\<notin> dom aa; x \\<notin> ba;\n         x2 = (x1a, x2a);\n         (x = dst, aa(x \\<mapsto> ui), insert x ba) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> x2a = Ni \\<union> (succi - (it - {x}) - dom PREDi)\nA total of 13 subgoals...", "apply (auto simp: it_step_insert_iff; fail) +"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<notin> dom aa; x \\<notin> ba;\n        x2 = (x1a, x2a);\n        (x = dst, aa(x \\<mapsto> ui), insert x ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1a =\n                         map_mmupd PREDi (succi - (it - {x}) - dom PREDi) ui\n 2. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<notin> dom aa; x \\<notin> ba;\n        x2 = (x1a, x2a);\n        (x = dst, aa(x \\<mapsto> ui), insert x ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2a = Ni \\<union> (succi - (it - {x}) - dom PREDi)\n 3. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<notin> dom aa; x \\<notin> ba;\n        x2 = (x1a, x2a);\n        (x = dst, aa(x \\<mapsto> ui), insert x ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = (dst \\<in> succi - (it - {x}) - dom PREDi)\n 4. \\<And>\\<sigma> x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - {} - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - {} - dom PREDi) \\<and>\n          f = (dst \\<in> succi - {} - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        x2 = (x1a, x2a); \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of\n                         True \\<Rightarrow>\n                           dst \\<in> succ - dom PRED \\<and>\n                           PRED \\<subseteq>\\<^sub>m x1a \\<and>\n                           x1a \\<subseteq>\\<^sub>m\n                           map_mmupd PRED (succ - dom PRED) u \\<and>\n                           dst \\<in> dom x1a\n                         | False \\<Rightarrow>\n                             dst \\<notin> succ - dom PRED \\<and>\n                             x1a = map_mmupd PRED (succ - dom PRED) u \\<and>\n                             x2a = N \\<union> (succ - dom PRED)\n 5. \\<And>it \\<sigma> x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        \\<not> (case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f);\n        x2 = (x1a, x2a); \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of\n                         True \\<Rightarrow>\n                           dst \\<in> succ - dom PRED \\<and>\n                           PRED \\<subseteq>\\<^sub>m x1a \\<and>\n                           x1a \\<subseteq>\\<^sub>m\n                           map_mmupd PRED (succ - dom PRED) u \\<and>\n                           dst \\<in> dom x1a\n                         | False \\<Rightarrow>\n                             dst \\<notin> succ - dom PRED \\<and>\n                             x1a = map_mmupd PRED (succ - dom PRED) u \\<and>\n                             x2a = N \\<union> (succ - dom PRED)", "apply (auto simp: it_step_insert_iff fun_neq_ext_iff map_mmupd_def \n      split: if_split_asm) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<notin> dom aa; x \\<notin> ba;\n        x2 = (x1a, x2a);\n        (x = dst, aa(x \\<mapsto> ui), insert x ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2a = Ni \\<union> (succi - (it - {x}) - dom PREDi)\n 2. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<notin> dom aa; x \\<notin> ba;\n        x2 = (x1a, x2a);\n        (x = dst, aa(x \\<mapsto> ui), insert x ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = (dst \\<in> succi - (it - {x}) - dom PREDi)\n 3. \\<And>\\<sigma> x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - {} - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - {} - dom PREDi) \\<and>\n          f = (dst \\<in> succi - {} - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        x2 = (x1a, x2a); \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of\n                         True \\<Rightarrow>\n                           dst \\<in> succ - dom PRED \\<and>\n                           PRED \\<subseteq>\\<^sub>m x1a \\<and>\n                           x1a \\<subseteq>\\<^sub>m\n                           map_mmupd PRED (succ - dom PRED) u \\<and>\n                           dst \\<in> dom x1a\n                         | False \\<Rightarrow>\n                             dst \\<notin> succ - dom PRED \\<and>\n                             x1a = map_mmupd PRED (succ - dom PRED) u \\<and>\n                             x2a = N \\<union> (succ - dom PRED)\n 4. \\<And>it \\<sigma> x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        \\<not> (case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f);\n        x2 = (x1a, x2a); \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of\n                         True \\<Rightarrow>\n                           dst \\<in> succ - dom PRED \\<and>\n                           PRED \\<subseteq>\\<^sub>m x1a \\<and>\n                           x1a \\<subseteq>\\<^sub>m\n                           map_mmupd PRED (succ - dom PRED) u \\<and>\n                           dst \\<in> dom x1a\n                         | False \\<Rightarrow>\n                             dst \\<notin> succ - dom PRED \\<and>\n                             x1a = map_mmupd PRED (succ - dom PRED) u \\<and>\n                             x2a = N \\<union> (succ - dom PRED)", "apply (auto simp: it_step_insert_iff split: bool.split; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> a b aa ba x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; x \\<in> it; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        \\<sigma> = (a, b); b = (aa, ba); x \\<notin> dom aa; x \\<notin> ba;\n        x2 = (x1a, x2a);\n        (x = dst, aa(x \\<mapsto> ui), insert x ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = (dst \\<in> succi - (it - {x}) - dom PREDi)\n 2. \\<And>\\<sigma> x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - {} - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - {} - dom PREDi) \\<and>\n          f = (dst \\<in> succi - {} - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        x2 = (x1a, x2a); \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of\n                         True \\<Rightarrow>\n                           dst \\<in> succ - dom PRED \\<and>\n                           PRED \\<subseteq>\\<^sub>m x1a \\<and>\n                           x1a \\<subseteq>\\<^sub>m\n                           map_mmupd PRED (succ - dom PRED) u \\<and>\n                           dst \\<in> dom x1a\n                         | False \\<Rightarrow>\n                             dst \\<notin> succ - dom PRED \\<and>\n                             x1a = map_mmupd PRED (succ - dom PRED) u \\<and>\n                             x2a = N \\<union> (succ - dom PRED)\n 3. \\<And>it \\<sigma> x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        \\<not> (case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f);\n        x2 = (x1a, x2a); \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of\n                         True \\<Rightarrow>\n                           dst \\<in> succ - dom PRED \\<and>\n                           PRED \\<subseteq>\\<^sub>m x1a \\<and>\n                           x1a \\<subseteq>\\<^sub>m\n                           map_mmupd PRED (succ - dom PRED) u \\<and>\n                           dst \\<in> dom x1a\n                         | False \\<Rightarrow>\n                             dst \\<notin> succ - dom PRED \\<and>\n                             x1a = map_mmupd PRED (succ - dom PRED) u \\<and>\n                             x2a = N \\<union> (succ - dom PRED)", "apply (auto simp: it_step_insert_iff split: bool.split; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - {} - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - {} - dom PREDi) \\<and>\n          f = (dst \\<in> succi - {} - dom PREDi);\n        case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f;\n        x2 = (x1a, x2a); \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of\n                         True \\<Rightarrow>\n                           dst \\<in> succ - dom PRED \\<and>\n                           PRED \\<subseteq>\\<^sub>m x1a \\<and>\n                           x1a \\<subseteq>\\<^sub>m\n                           map_mmupd PRED (succ - dom PRED) u \\<and>\n                           dst \\<in> dom x1a\n                         | False \\<Rightarrow>\n                             dst \\<notin> succ - dom PRED \\<and>\n                             x1a = map_mmupd PRED (succ - dom PRED) u \\<and>\n                             x2a = N \\<union> (succ - dom PRED)\n 2. \\<And>it \\<sigma> x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        \\<not> (case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f);\n        x2 = (x1a, x2a); \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of\n                         True \\<Rightarrow>\n                           dst \\<in> succ - dom PRED \\<and>\n                           PRED \\<subseteq>\\<^sub>m x1a \\<and>\n                           x1a \\<subseteq>\\<^sub>m\n                           map_mmupd PRED (succ - dom PRED) u \\<and>\n                           dst \\<in> dom x1a\n                         | False \\<Rightarrow>\n                             dst \\<notin> succ - dom PRED \\<and>\n                             x1a = map_mmupd PRED (succ - dom PRED) u \\<and>\n                             x2a = N \\<union> (succ - dom PRED)", "apply (auto simp: it_step_insert_iff split: bool.split; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma> x1 x2 x1a x2a.\n       \\<lbrakk>N \\<subseteq> dom PRED; it \\<subseteq> succi;\n        case \\<sigma> of\n        (f, PRED', N') \\<Rightarrow>\n          PRED' = map_mmupd PREDi (succi - it - dom PREDi) ui \\<and>\n          N' = Ni \\<union> (succi - it - dom PREDi) \\<and>\n          f = (dst \\<in> succi - it - dom PREDi);\n        \\<not> (case \\<sigma> of (f, PRED, N) \\<Rightarrow> \\<not> f);\n        x2 = (x1a, x2a); \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of\n                         True \\<Rightarrow>\n                           dst \\<in> succ - dom PRED \\<and>\n                           PRED \\<subseteq>\\<^sub>m x1a \\<and>\n                           x1a \\<subseteq>\\<^sub>m\n                           map_mmupd PRED (succ - dom PRED) u \\<and>\n                           dst \\<in> dom x1a\n                         | False \\<Rightarrow>\n                             dst \\<notin> succ - dom PRED \\<and>\n                             x1a = map_mmupd PRED (succ - dom PRED) u \\<and>\n                             x2a = N \\<union> (succ - dom PRED)", "apply (auto simp: it_step_insert_iff intro: map_mmupd_update_less \n      split: bool.split; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"inner_loop2 dst succl u PRED N \\<equiv> nfoldli\n    (succl) (\\<lambda>(f,_,_). \\<not>f) (\\<lambda>v (f,PRED,N). do {\n    if PRED v \\<noteq> None then RETURN (f,PRED,N)\n    else do {\n      let PRED = PRED(v \\<mapsto> u);\n      ASSERT (v\\<notin>N);\n      let N = insert v N;\n      RETURN ((v=dst),PRED,N)\n    }\n  }) (False,PRED,N)\""], ["", "lemma inner_loop2_refine:\n    assumes SR: \"(succl,succ)\\<in>\\<langle>Id\\<rangle>list_set_rel\"\n    shows \"inner_loop2 dst succl u PRED N \\<le> \\<Down>Id (inner_loop dst succ u PRED N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_loop2 dst succl u PRED N\n    \\<le> \\<Down> Id (inner_loop dst succ u PRED N)", "using assms"], ["proof (prove)\nusing this:\n  (succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. inner_loop2 dst succl u PRED N\n    \\<le> \\<Down> Id (inner_loop dst succ u PRED N)", "unfolding inner_loop2_def inner_loop_def"], ["proof (prove)\nusing this:\n  (succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. nfoldli succl (\\<lambda>(f, uu_, uu_). \\<not> f)\n     (\\<lambda>v (f, PRED, N).\n         if PRED v \\<noteq> None then return (f, PRED, N)\n         else let PRED = PRED(v \\<mapsto> u)\n              in assert (v \\<notin> N) \\<bind>\n                 (\\<lambda>_.\n                     let N = insert v N in return (v = dst, PRED, N)))\n     (False, PRED, N)\n    \\<le> \\<Down> Id\n           (FOREACH\\<^sub>C\\<^bsup>\\<lambda>it (f, PRED', N').\nPRED' = map_mmupd PRED (succ - it - dom PRED) u \\<and>\nN' = N \\<union> (succ - it - dom PRED) \\<and>\nf = (dst \\<in> succ - it - dom PRED)\\<^esup>\n             succ (\\<lambda>(f, PRED, N). \\<not> f)\n             (\\<lambda>v (f, PRED, N).\n                 if v \\<in> dom PRED then return (f, PRED, N)\n                 else let PRED = PRED(v \\<mapsto> u)\n                      in assert (v \\<notin> N) \\<bind>\n                         (\\<lambda>_.\n                             let N = insert v N\n                             in return (v = dst, PRED, N)))\n             (False, PRED, N))", "apply (refine_rcg LFOci_refine SR)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s si x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel;\n        (si, s) \\<in> Id; x2 = (x1a, x2a); si = (x1, x2); x2b = (x1c, x2c);\n        s = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x1) = (\\<not> x1b)\n 2. \\<And>x xi s si x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel;\n        (xi, x) \\<in> Id; (si, s) \\<in> Id; x2 = (x1a, x2a); s = (x1, x2);\n        x2b = (x1c, x2c); si = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1c xi \\<noteq> None) = (x \\<in> dom x1a)\n 3. \\<And>x xi s si x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel;\n        (xi, x) \\<in> Id; (si, s) \\<in> Id; x2 = (x1a, x2a); s = (x1, x2);\n        x2b = (x1c, x2c); si = (x1b, x2b); x1c xi \\<noteq> None;\n        x \\<in> dom x1a\\<rbrakk>\n       \\<Longrightarrow> ((x1b, x1c, x2c), x1, x1a, x2a) \\<in> Id\n 4. \\<And>x xi s si x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel;\n        (xi, x) \\<in> Id; (si, s) \\<in> Id; x2 = (x1a, x2a); s = (x1, x2);\n        x2b = (x1c, x2c); si = (x1b, x2b); \\<not> x1c xi \\<noteq> None;\n        x \\<notin> dom x1a; x \\<notin> x2a\\<rbrakk>\n       \\<Longrightarrow> xi \\<notin> x2c\n 5. \\<And>x xi s si x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel;\n        (xi, x) \\<in> Id; (si, s) \\<in> Id; x2 = (x1a, x2a); s = (x1, x2);\n        x2b = (x1c, x2c); si = (x1b, x2b); \\<not> x1c xi \\<noteq> None;\n        x \\<notin> dom x1a; x \\<notin> x2a; xi \\<notin> x2c\\<rbrakk>\n       \\<Longrightarrow> ((xi = dst, x1c(xi \\<mapsto> u), insert xi x2c),\n                          x = dst, x1a(x \\<mapsto> u), insert x x2a)\n                         \\<in> Id\n 6. (succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel \\<Longrightarrow>\n    ((False, PRED, N), False, PRED, N) \\<in> Id", "apply (vc_solve)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1a.\n       (succl, succ)\n       \\<in> \\<langle>Id\\<rangle>list_set_rel \\<Longrightarrow>\n       (\\<exists>y. x1a x = Some y) = (x \\<in> dom x1a)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "thm conc_trans[OF inner_loop2_refine inner_loop_refine, no_vars]"], ["", "lemma inner_loop2_correct:\n    assumes \"(succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel\"\n    (*assumes \"N \\<subseteq> dom PRED\"*)\n    assumes [simplified, simp]: \n      \"(dsti,dst)\\<in>Id\" \"(ui, u) \\<in> Id\" \"(PREDi, PRED) \\<in> Id\" \"(Ni, N) \\<in> Id\"\n    shows \"inner_loop2 dsti succl ui PREDi Ni \n      \\<le> \\<Down> Id (add_succ_spec dst succ u PRED N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_loop2 dsti succl ui PREDi Ni\n    \\<le> \\<Down> Id (add_succ_spec dst succ u PRED N)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_loop2 dst succl u PRED N \\<le> add_succ_spec dst succ u PRED N", "apply (rule conc_trans[OF inner_loop2_refine inner_loop_refine, simplified])"], ["proof (prove)\ngoal (6 subgoals):\n 1. (succl, ?succi2) \\<in> \\<langle>Id\\<rangle>list_set_rel\n 2. finite succ\n 3. ?succi2 = succ\n 4. u = u\n 5. PRED = PRED\n 6. N = N", "using assms(1-2)"], ["proof (prove)\nusing this:\n  (succl, succ) \\<in> \\<langle>Id\\<rangle>list_set_rel\n  (dsti, dst) \\<in> Id\n\ngoal (6 subgoals):\n 1. (succl, ?succi2) \\<in> \\<langle>Id\\<rangle>list_set_rel\n 2. finite succ\n 3. ?succi2 = succ\n 4. u = u\n 5. PRED = PRED\n 6. N = N", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "type_synonym bfs_state = \"bool \\<times> (node \\<rightharpoonup> node) \\<times> node set \\<times> node set \\<times> nat\""], ["", "context\n      fixes succ :: \"node \\<Rightarrow> node list nres\"\n    begin"], ["", "definition init_state :: \"node \\<Rightarrow> bfs_state nres\"\n      where \n        \"init_state src \\<equiv> RETURN (False,[src\\<mapsto>src],{src},{},0::nat)\""], ["", "definition pre_bfs2 :: \"node \\<Rightarrow> node \\<Rightarrow> (nat \\<times> (node\\<rightharpoonup>node)) option nres\"\n        where \"pre_bfs2 src dst \\<equiv> do {\n        s \\<leftarrow> init_state src;\n        (f,PRED,_,_,d) \\<leftarrow> WHILET (\\<lambda>(f,PRED,C,N,d). f=False \\<and> C\\<noteq>{})\n          (\\<lambda>(f,PRED,C,N,d). do {\n            ASSERT (C\\<noteq>{});\n            v \\<leftarrow> op_set_pick C; let C = C-{v};\n            ASSERT (v\\<in>V);\n            sl \\<leftarrow> succ v;\n            (f,PRED,N) \\<leftarrow> inner_loop2 dst sl v PRED N;\n            if f then\n              RETURN (f,PRED,C,N,d+1)\n            else do {\n              ASSERT (assn1 src dst (f,PRED,C,N,d));\n              if (C={}) then do {\n                let C=N; \n                let N={}; \n                let d=d+1;\n                RETURN (f,PRED,C,N,d)\n              } else RETURN (f,PRED,C,N,d)\n            }  \n          })\n          s;\n        if f then RETURN (Some (d, PRED)) else RETURN None\n        }\""], ["", "lemma pre_bfs2_refine: \n        assumes succ_impl: \"\\<And>ui u. \\<lbrakk>(ui,u)\\<in>Id; u\\<in>V\\<rbrakk> \n          \\<Longrightarrow> succ ui \\<le> SPEC (\\<lambda>l. (l,E``{u}) \\<in> \\<langle>Id\\<rangle>list_set_rel)\"\n        shows \"pre_bfs2 src dst \\<le>\\<Down>Id (pre_bfs src dst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_bfs2 src dst \\<le> \\<Down> Id (pre_bfs src dst)", "unfolding pre_bfs_def pre_bfs2_def init_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. return (False, [src \\<mapsto> src], {src}, {}, 0) \\<bind>\n    (\\<lambda>s.\n        while\\<^sub>T\n         (\\<lambda>(f, PRED, C, N, d). f = False \\<and> C \\<noteq> {})\n         (\\<lambda>(f, PRED, C, N, d).\n             assert (C \\<noteq> {}) \\<bind>\n             (\\<lambda>_.\n                 IICF_Set.op_set_pick C \\<bind>\n                 (\\<lambda>v.\n                     let C = C - {v}\n                     in assert (v \\<in> V) \\<bind>\n                        (\\<lambda>_.\n                            succ v \\<bind>\n                            (\\<lambda>sl.\n                                inner_loop2 dst sl v PRED N \\<bind>\n                                (\\<lambda>(f, PRED, N).\n                                    if f then return (f, PRED, C, N, d + 1)\n                                    else assert\n    (assn1 src dst (f, PRED, C, N, d)) \\<bind>\n   (\\<lambda>_.\n       if C = {}\n       then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n       else return (f, PRED, C, N, d))))))))\n         s \\<bind>\n        (\\<lambda>(f, PRED, uu_, uu_, d).\n            if f then return (Some (d, PRED)) else return None))\n    \\<le> \\<Down> Id\n           (while\\<^sub>T\\<^bsup>outer_loop_invar src dst\\<^esup>\n             (\\<lambda>(f, PRED, C, N, d). f = False \\<and> C \\<noteq> {})\n             (\\<lambda>(f, PRED, C, N, d).\n                 (spec v. v \\<in> C) \\<bind>\n                 (\\<lambda>v.\n                     let C = C - {v}\n                     in assert (v \\<in> V) \\<bind>\n                        (\\<lambda>_.\n                            let succ = E `` {v}\n                            in assert (finite succ) \\<bind>\n                               (\\<lambda>_.\n                                   add_succ_spec dst succ v PRED N \\<bind>\n                                   (\\<lambda>(f, PRED, N).\n if f then return (f, PRED, C, N, d + 1)\n else assert (assn1 src dst (f, PRED, C, N, d)) \\<bind>\n      (\\<lambda>_.\n          if C = {}\n          then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n          else return (f, PRED, C, N, d)))))))\n             (False, [src \\<mapsto> src], {src}, {}, 0) \\<bind>\n            (\\<lambda>(f, PRED, uu_, uu_, d).\n                if f then return (Some (d, PRED)) else return None))", "apply (subst nres_monad1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. while\\<^sub>T\n     (\\<lambda>(f, PRED, C, N, d). f = False \\<and> C \\<noteq> {})\n     (\\<lambda>(f, PRED, C, N, d).\n         assert (C \\<noteq> {}) \\<bind>\n         (\\<lambda>_.\n             IICF_Set.op_set_pick C \\<bind>\n             (\\<lambda>v.\n                 let C = C - {v}\n                 in assert (v \\<in> V) \\<bind>\n                    (\\<lambda>_.\n                        succ v \\<bind>\n                        (\\<lambda>sl.\n                            inner_loop2 dst sl v PRED N \\<bind>\n                            (\\<lambda>(f, PRED, N).\n                                if f then return (f, PRED, C, N, d + 1)\n                                else assert\n(assn1 src dst (f, PRED, C, N, d)) \\<bind>\n                                     (\\<lambda>_.\n   if C = {} then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n   else return (f, PRED, C, N, d))))))))\n     (False, [src \\<mapsto> src], {src}, {}, 0) \\<bind>\n    (\\<lambda>(f, PRED, uu_, uu_, d).\n        if f then return (Some (d, PRED)) else return None)\n    \\<le> \\<Down> Id\n           (while\\<^sub>T\\<^bsup>outer_loop_invar src dst\\<^esup>\n             (\\<lambda>(f, PRED, C, N, d). f = False \\<and> C \\<noteq> {})\n             (\\<lambda>(f, PRED, C, N, d).\n                 (spec v. v \\<in> C) \\<bind>\n                 (\\<lambda>v.\n                     let C = C - {v}\n                     in assert (v \\<in> V) \\<bind>\n                        (\\<lambda>_.\n                            let succ = E `` {v}\n                            in assert (finite succ) \\<bind>\n                               (\\<lambda>_.\n                                   add_succ_spec dst succ v PRED N \\<bind>\n                                   (\\<lambda>(f, PRED, N).\n if f then return (f, PRED, C, N, d + 1)\n else assert (assn1 src dst (f, PRED, C, N, d)) \\<bind>\n      (\\<lambda>_.\n          if C = {}\n          then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n          else return (f, PRED, C, N, d)))))))\n             (False, [src \\<mapsto> src], {src}, {}, 0) \\<bind>\n            (\\<lambda>(f, PRED, uu_, uu_, d).\n                if f then return (Some (d, PRED)) else return None))", "apply (refine_rcg inner_loop2_correct succ_impl)"], ["proof (prove)\ngoal (17 subgoals):\n 1. outer_loop_invar src dst\n     (False, [src \\<mapsto> src], {src}, {}, 0) \\<Longrightarrow>\n    ((False, [src \\<mapsto> src], {src}, {}, 0), False, [src \\<mapsto> src],\n     {src}, {}, 0)\n    \\<in> ?R'\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x') \\<in> ?R'; outer_loop_invar src dst x';\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x' = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (x1 = False \\<and> x1b \\<noteq> {}) =\n                         (x1d = False \\<and> x1f \\<noteq> {})\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> x1f \\<noteq> {}\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> IICF_Set.op_set_pick x1f\n                         \\<le> (spec v. v \\<in> x1b)\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b};\n        va \\<in> V\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va sl.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        v \\<in> V; inres (succ v) sl;\n        (sl, E `` {va}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        finite (E `` {va})\\<rbrakk>\n       \\<Longrightarrow> (dst, dst) \\<in> nat_rel\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va sl.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        v \\<in> V; inres (succ v) sl;\n        (sl, E `` {va}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        finite (E `` {va})\\<rbrakk>\n       \\<Longrightarrow> (x1e, x1a) \\<in> Id\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va sl.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        v \\<in> V; inres (succ v) sl;\n        (sl, E `` {va}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        finite (E `` {va})\\<rbrakk>\n       \\<Longrightarrow> (x1g, x1c) \\<in> Id\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va sl xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n\n       x2n x1o x2o x1p x2p x1q x2q x1r x2r x1s x2s.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        v \\<in> V; inres (succ v) sl;\n        (sl, E `` {va}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        finite (E `` {va}); (xa, x'a) \\<in> Id; x2l = (x1m, x2m);\n        x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2r = (x1s, x2s); x2q = (x1r, x2r);\n        x2p = (x1q, x2q); (x1n, x1o, x1f - {v}, x2o, x2g) = (x1p, x2p);\n        x2n = (x1o, x2o); xa = (x1n, x2n)\\<rbrakk>\n       \\<Longrightarrow> x1n = x1h\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n        x2g v va sl xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m\n        x1n x2n x1o x2o x1p x2p x1q x2q x1r x2r x1s x2s.\n        \\<lbrakk>(x, x') \\<in> ?R';\n         case x of\n         (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n         case x' of\n         (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n         outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n         x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n         x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n         (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n         v \\<in> V; inres (succ v) sl;\n         (sl, E `` {va}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n         finite (E `` {va}); (xa, x'a) \\<in> Id; x2l = (x1m, x2m);\n         x2k = (x1l, x2l); x2j = (x1k, x2k);\n         (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n         x'a = (x1h, x2h); x2r = (x1s, x2s); x2q = (x1r, x2r);\n         x2p = (x1q, x2q); (x1n, x1o, x1f - {v}, x2o, x2g) = (x1p, x2p);\n         x2n = (x1o, x2o); xa = (x1n, x2n); x1n; x1h\\<rbrakk>\n        \\<Longrightarrow> ((x1n, x1o, x1f - {v}, x2o, x2g + 1), x1h, x1i,\n                           x1b - {va}, x2i, x2c + 1)\n                          \\<in> ?R'\nA total of 17 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (17 subgoals):\n 1. outer_loop_invar src dst\n     (False, [src \\<mapsto> src], {src}, {}, 0) \\<Longrightarrow>\n    ((False, [src \\<mapsto> src], {src}, {}, 0), False, [src \\<mapsto> src],\n     {src}, {}, 0)\n    \\<in> bool_rel \\<times>\\<^sub>r\n          Id \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x' = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (x1 = False \\<and> x1b \\<noteq> {}) =\n                         (x1d = False \\<and> x1f \\<noteq> {})\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> x1f \\<noteq> {}\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> IICF_Set.op_set_pick x1f\n                         \\<le> (spec v. v \\<in> x1b)\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b};\n        va \\<in> V\\<rbrakk>\n       \\<Longrightarrow> v \\<in> V\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va sl.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        v \\<in> V; inres (succ v) sl;\n        (sl, E `` {va}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        finite (E `` {va})\\<rbrakk>\n       \\<Longrightarrow> (dst, dst) \\<in> nat_rel\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va sl.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        v \\<in> V; inres (succ v) sl;\n        (sl, E `` {va}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        finite (E `` {va})\\<rbrakk>\n       \\<Longrightarrow> (x1e, x1a) \\<in> Id\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va sl.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        v \\<in> V; inres (succ v) sl;\n        (sl, E `` {va}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        finite (E `` {va})\\<rbrakk>\n       \\<Longrightarrow> (x1g, x1c) \\<in> Id\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va sl xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m x1n\n       x2n x1o x2o x1p x2p x1q x2q x1r x2r x1s x2s.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      Id \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                      nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n        v \\<in> V; inres (succ v) sl;\n        (sl, E `` {va}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        finite (E `` {va}); (xa, x'a) \\<in> Id; x2l = (x1m, x2m);\n        x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2r = (x1s, x2s); x2q = (x1r, x2r);\n        x2p = (x1q, x2q); (x1n, x1o, x1f - {v}, x2o, x2g) = (x1p, x2p);\n        x2n = (x1o, x2o); xa = (x1n, x2n)\\<rbrakk>\n       \\<Longrightarrow> x1n = x1h\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n        x2g v va sl xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l x1m x2m\n        x1n x2n x1o x2o x1p x2p x1q x2q x1r x2r x1s x2s.\n        \\<lbrakk>(x, x')\n                 \\<in> bool_rel \\<times>\\<^sub>r\n                       Id \\<times>\\<^sub>r\n                       \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                       \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                       nat_rel;\n         case x of\n         (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n         case x' of\n         (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n         outer_loop_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n         x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n         x2d = (x1e, x2e); x = (x1d, x2d); x1f \\<noteq> {};\n         (v, va) \\<in> nat_rel; va \\<in> {v. v \\<in> x1b}; va \\<in> V;\n         v \\<in> V; inres (succ v) sl;\n         (sl, E `` {va}) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n         finite (E `` {va}); (xa, x'a) \\<in> Id; x2l = (x1m, x2m);\n         x2k = (x1l, x2l); x2j = (x1k, x2k);\n         (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n         x'a = (x1h, x2h); x2r = (x1s, x2s); x2q = (x1r, x2r);\n         x2p = (x1q, x2q); (x1n, x1o, x1f - {v}, x2o, x2g) = (x1p, x2p);\n         x2n = (x1o, x2o); xa = (x1n, x2n); x1n; x1h\\<rbrakk>\n        \\<Longrightarrow> ((x1n, x1o, x1f - {v}, x2o, x2g + 1), x1h, x1i,\n                           x1b - {va}, x2i, x2c + 1)\n                          \\<in> bool_rel \\<times>\\<^sub>r\n                                Id \\<times>\\<^sub>r\n                                \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                                \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                                nat_rel\nA total of 17 subgoals...", "apply vc_solve"], ["proof (prove)\ngoal:\nNo subgoals!", "(* Takes some time *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition \"bfs2 succ src dst \\<equiv> do {\n      if src=dst then \n        RETURN (Some [])\n      else do {  \n        br \\<leftarrow> pre_bfs2 succ src dst;\n        case br of\n          None \\<Rightarrow> RETURN None\n        | Some (d,PRED) \\<Rightarrow> do {\n            p \\<leftarrow> extract_rpath src dst PRED;\n            RETURN (Some p)\n          }  \n      }    \n    }\""], ["", "lemma bfs2_refine:\n      assumes succ_impl: \"\\<And>ui u. \\<lbrakk>(ui,u)\\<in>Id; u\\<in>V\\<rbrakk> \n        \\<Longrightarrow> succ ui \\<le> SPEC (\\<lambda>l. (l,E``{u}) \\<in> \\<langle>Id\\<rangle>list_set_rel)\"\n      shows \"bfs2 succ src dst \\<le> \\<Down>Id (bfs src dst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bfs2 succ src dst \\<le> \\<Down> Id (bfs src dst)", "unfolding bfs_def bfs2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if src = dst then return (Some [])\n     else pre_bfs2 succ src dst \\<bind>\n          (\\<lambda>br.\n              case br of None \\<Rightarrow> return None\n              | Some (d, PRED) \\<Rightarrow>\n                  extract_rpath src dst PRED \\<bind>\n                  (\\<lambda>p. return (Some p))))\n    \\<le> \\<Down> Id\n           (if src = dst then return (Some [])\n            else pre_bfs src dst \\<bind>\n                 (\\<lambda>br.\n                     case br of None \\<Rightarrow> return None\n                     | Some (d, PRED) \\<Rightarrow>\n                         extract_rpath src dst PRED \\<bind>\n                         (\\<lambda>p. return (Some p))))", "apply (refine_vcg pre_bfs2_refine)"], ["proof (prove)\ngoal (5 subgoals):\n 1. (src = dst) = (src = dst)\n 2. \\<And>ui u.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst; (ui, u) \\<in> nat_rel;\n        u \\<in> V\\<rbrakk>\n       \\<Longrightarrow> succ ui\n                         \\<le> (spec l.\n                                   (l, E `` {u})\n                                   \\<in> \\<langle>nat_rel\\<rangle>list_set_rel)\n 3. \\<And>br bra.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst;\n        (br, bra) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (br, bra)\n                         \\<in> \\<langle>?Ra4 br bra\\<rangle>option_rel\n 4. \\<And>br bra x x' x1 x2 x1a x2a.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst; (br, bra) \\<in> Id;\n        br = Some x; bra = Some x'; (x, x') \\<in> ?Ra4 br bra;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> extract_rpath src dst x2a\n                         \\<le> \\<Down> (?R'20 br bra x x' x1 x2 x1a x2a)\n                                (extract_rpath src dst x2)\n 5. \\<And>br bra x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst; (br, bra) \\<in> Id;\n        br = Some x; bra = Some x'; (x, x') \\<in> ?Ra4 br bra;\n        x' = (x1, x2); x = (x1a, x2a);\n        (p, pa) \\<in> ?R'20 br bra x x' x1 x2 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> (Some p, Some pa) \\<in> Id", "apply refine_dref_type"], ["proof (prove)\ngoal (5 subgoals):\n 1. (src = dst) = (src = dst)\n 2. \\<And>ui u.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst; (ui, u) \\<in> nat_rel;\n        u \\<in> V\\<rbrakk>\n       \\<Longrightarrow> succ ui\n                         \\<le> (spec l.\n                                   (l, E `` {u})\n                                   \\<in> \\<langle>nat_rel\\<rangle>list_set_rel)\n 3. \\<And>br bra.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst;\n        (br, bra) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (br, bra)\n                         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r\n  Id\\<rangle>option_rel\n 4. \\<And>br bra x x' x1 x2 x1a x2a.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst; (br, bra) \\<in> Id;\n        br = Some x; bra = Some x';\n        (x, x') \\<in> nat_rel \\<times>\\<^sub>r Id; x' = (x1, x2);\n        x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> extract_rpath src dst x2a\n                         \\<le> \\<Down>\n                                (\\<langle>nat_rel \\<times>\\<^sub>r\n    nat_rel\\<rangle>list_rel)\n                                (extract_rpath src dst x2)\n 5. \\<And>br bra x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst; (br, bra) \\<in> Id;\n        br = Some x; bra = Some x';\n        (x, x') \\<in> nat_rel \\<times>\\<^sub>r Id; x' = (x1, x2);\n        x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r\n                       nat_rel\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (Some p, Some pa) \\<in> Id", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?ui1, ?u1) \\<in> nat_rel; ?u1 \\<in> V\\<rbrakk>\n  \\<Longrightarrow> succ ?ui1\n                    \\<le> (spec l.\n                              (l, E `` {?u1})\n                              \\<in> \\<langle>nat_rel\\<rangle>list_set_rel)\n\ngoal (5 subgoals):\n 1. (src = dst) = (src = dst)\n 2. \\<And>ui u.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst; (ui, u) \\<in> nat_rel;\n        u \\<in> V\\<rbrakk>\n       \\<Longrightarrow> succ ui\n                         \\<le> (spec l.\n                                   (l, E `` {u})\n                                   \\<in> \\<langle>nat_rel\\<rangle>list_set_rel)\n 3. \\<And>br bra.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst;\n        (br, bra) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (br, bra)\n                         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r\n  Id\\<rangle>option_rel\n 4. \\<And>br bra x x' x1 x2 x1a x2a.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst; (br, bra) \\<in> Id;\n        br = Some x; bra = Some x';\n        (x, x') \\<in> nat_rel \\<times>\\<^sub>r Id; x' = (x1, x2);\n        x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> extract_rpath src dst x2a\n                         \\<le> \\<Down>\n                                (\\<langle>nat_rel \\<times>\\<^sub>r\n    nat_rel\\<rangle>list_rel)\n                                (extract_rpath src dst x2)\n 5. \\<And>br bra x x' x1 x2 x1a x2a p pa.\n       \\<lbrakk>src \\<noteq> dst; src \\<noteq> dst; (br, bra) \\<in> Id;\n        br = Some x; bra = Some x';\n        (x, x') \\<in> nat_rel \\<times>\\<^sub>r Id; x' = (x1, x2);\n        x = (x1a, x2a);\n        (p, pa)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r\n                       nat_rel\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (Some p, Some pa) \\<in> Id", "apply (vc_solve)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma bfs2_refine_succ: \n    assumes [refine]: \"\\<And>ui u. \\<lbrakk>(ui,u)\\<in>Id; u\\<in>Graph.V c\\<rbrakk> \n      \\<Longrightarrow> succi ui \\<le> \\<Down>Id (succ u)\"\n    assumes [simplified, simp]: \"(si,s)\\<in>Id\" \"(ti,t)\\<in>Id\" \"(ci,c)\\<in>Id\"\n    shows \"Graph.bfs2 ci succi si ti \\<le> \\<Down>Id (Graph.bfs2 c succ s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph.bfs2 ci succi si ti \\<le> \\<Down> Id (Graph.bfs2 c succ s t)", "unfolding Graph.bfs2_def Graph.pre_bfs2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if si = ti then return (Some [])\n     else Graph.init_state si \\<bind>\n          (\\<lambda>s.\n              while\\<^sub>T\n               (\\<lambda>(f, PRED, C, N, d). f = False \\<and> C \\<noteq> {})\n               (\\<lambda>(f, PRED, C, N, d).\n                   assert (C \\<noteq> {}) \\<bind>\n                   (\\<lambda>_.\n                       IICF_Set.op_set_pick C \\<bind>\n                       (\\<lambda>v.\n                           let C = C - {v}\n                           in assert (v \\<in> Graph.V ci) \\<bind>\n                              (\\<lambda>_.\n                                  succi v \\<bind>\n                                  (\\<lambda>sl.\nGraph.inner_loop2 ti sl v PRED N \\<bind>\n(\\<lambda>(f, PRED, N).\n    if f then return (f, PRED, C, N, d + 1)\n    else assert\n          (case (f, PRED, C, N, d) of\n           (f, PRED, C, N, d) \\<Rightarrow>\n             \\<not> f \\<and> nf_invar' ci si ti PRED C N d) \\<bind>\n         (\\<lambda>_.\n             if C = {}\n             then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n             else return (f, PRED, C, N, d))))))))\n               s \\<bind>\n              (\\<lambda>(f, PRED, uu_, uu_, d).\n                  if f then return (Some (d, PRED))\n                  else return None)) \\<bind>\n          (\\<lambda>br.\n              case br of None \\<Rightarrow> return None\n              | Some (d, PRED) \\<Rightarrow>\n                  Graph.extract_rpath ci si ti PRED \\<bind>\n                  (\\<lambda>p. return (Some p))))\n    \\<le> \\<Down> Id\n           (if s = t then return (Some [])\n            else Graph.init_state s \\<bind>\n                 (\\<lambda>sa.\n                     while\\<^sub>T\n                      (\\<lambda>(f, PRED, C, N, d).\n                          f = False \\<and> C \\<noteq> {})\n                      (\\<lambda>(f, PRED, C, N, d).\n                          assert (C \\<noteq> {}) \\<bind>\n                          (\\<lambda>_.\n                              IICF_Set.op_set_pick C \\<bind>\n                              (\\<lambda>v.\n                                  let C = C - {v}\n                                  in assert (v \\<in> Graph.V c) \\<bind>\n                                     (\\<lambda>_.\n   succ v \\<bind>\n   (\\<lambda>sl.\n       Graph.inner_loop2 t sl v PRED N \\<bind>\n       (\\<lambda>(f, PRED, N).\n           if f then return (f, PRED, C, N, d + 1)\n           else assert\n                 (case (f, PRED, C, N, d) of\n                  (f, PRED, C, N, d) \\<Rightarrow>\n                    \\<not> f \\<and> nf_invar' c s t PRED C N d) \\<bind>\n                (\\<lambda>_.\n                    if C = {}\n                    then let C = N; N = {}; d = d + 1\n                         in return (f, PRED, C, N, d)\n                    else return (f, PRED, C, N, d))))))))\n                      sa \\<bind>\n                     (\\<lambda>(f, PRED, uu_, uu_, d).\n                         if f then return (Some (d, PRED))\n                         else return None)) \\<bind>\n                 (\\<lambda>br.\n                     case br of None \\<Rightarrow> return None\n                     | Some (d, PRED) \\<Rightarrow>\n                         Graph.extract_rpath c s t PRED \\<bind>\n                         (\\<lambda>p. return (Some p))))", "apply (refine_rcg \n      param_nfoldli[param_fo, THEN nres_relD] nres_relI fun_relI)"], ["proof (prove)\ngoal (21 subgoals):\n 1. (si = ti) = (s = t)\n 2. \\<lbrakk>si \\<noteq> ti; s \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> Graph.init_state si\n                      \\<le> \\<Down> ?R'3 (Graph.init_state s)\n 3. \\<And>sa saa.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t; (sa, saa) \\<in> ?R'3\\<rbrakk>\n       \\<Longrightarrow> (sa, saa) \\<in> ?R'4 sa saa\n 4. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t; (sa, saa) \\<in> ?R'3;\n        (x, x') \\<in> ?R'4 sa saa; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x' = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (x1 = False \\<and> x1b \\<noteq> {}) =\n                         (x1d = False \\<and> x1f \\<noteq> {})\n 5. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t; (sa, saa) \\<in> ?R'3;\n        (x, x') \\<in> ?R'4 sa saa;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> x1f \\<noteq> {}\n 6. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t; (sa, saa) \\<in> ?R'3;\n        (x, x') \\<in> ?R'4 sa saa;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> IICF_Set.op_set_pick x1f\n                         \\<le> \\<Down>\n                                (?R'408 sa saa x x' x1 x2 x1a x2a x1b x2b\n                                  x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g)\n                                (IICF_Set.op_set_pick x1b)\n 7. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g v va.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t; (sa, saa) \\<in> ?R'3;\n        (x, x') \\<in> ?R'4 sa saa;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {};\n        (v, va)\n        \\<in> ?R'408 sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e\n               x2e x1f x2f x1g x2g;\n        va \\<in> Graph.V c\\<rbrakk>\n       \\<Longrightarrow> v \\<in> Graph.V ci\n 8. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g v va.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t; (sa, saa) \\<in> ?R'3;\n        (x, x') \\<in> ?R'4 sa saa;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {};\n        (v, va)\n        \\<in> ?R'408 sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e\n               x2e x1f x2f x1g x2g;\n        va \\<in> Graph.V c; v \\<in> Graph.V ci\\<rbrakk>\n       \\<Longrightarrow> (v, va) \\<in> nat_rel\n 9. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g v va sl sla.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t; (sa, saa) \\<in> ?R'3;\n        (x, x') \\<in> ?R'4 sa saa;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {};\n        (v, va)\n        \\<in> ?R'408 sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e\n               x2e x1f x2f x1g x2g;\n        va \\<in> Graph.V c; v \\<in> Graph.V ci; (sl, sla) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> Graph.inner_loop2 ti sl v x1e x1g\n                         \\<le> \\<Down>\n                                (?R'414 sa saa x x' x1 x2 x1a x2a x1b x2b\n                                  x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g v\n                                  va sl sla)\n                                (Graph.inner_loop2 t sla va x1a x1c)\n 10. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n        x1g x2g v va sl sla xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l\n        x1m x2m x1n x2n x1o x2o x1p x2p x1q x2q x1r x2r x1s x2s.\n        \\<lbrakk>si \\<noteq> ti; s \\<noteq> t; (sa, saa) \\<in> ?R'3;\n         (x, x') \\<in> ?R'4 sa saa;\n         case x of\n         (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n         case x' of\n         (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n         x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n         x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n         x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {};\n         (v, va)\n         \\<in> ?R'408 sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e\n                x2e x1f x2f x1g x2g;\n         va \\<in> Graph.V c; v \\<in> Graph.V ci; (sl, sla) \\<in> Id;\n         (xa, x'a)\n         \\<in> ?R'414 sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e\n                x2e x1f x2f x1g x2g v va sl sla;\n         x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n         (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n         x'a = (x1h, x2h); x2r = (x1s, x2s); x2q = (x1r, x2r);\n         x2p = (x1q, x2q); (x1n, x1o, x1f - {v}, x2o, x2g) = (x1p, x2p);\n         x2n = (x1o, x2o); xa = (x1n, x2n)\\<rbrakk>\n        \\<Longrightarrow> x1n = x1h\nA total of 21 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (19 subgoals):\n 1. (si = ti) = (s = t)\n 2. \\<lbrakk>si \\<noteq> ti; s \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> Graph.init_state si\n                      \\<le> \\<Down>\n                             (bool_rel \\<times>\\<^sub>r\n                              Id \\<times>\\<^sub>r\n                              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                              nat_rel)\n                             (Graph.init_state s)\n 3. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t;\n        (sa, saa)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        (x, x')\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x' = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (x1 = False \\<and> x1b \\<noteq> {}) =\n                         (x1d = False \\<and> x1f \\<noteq> {})\n 4. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t;\n        (sa, saa)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        (x, x')\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> x1f \\<noteq> {}\n 5. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t;\n        (sa, saa)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        (x, x')\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> IICF_Set.op_set_pick x1f\n                         \\<le> \\<Down> nat_rel (IICF_Set.op_set_pick x1b)\n 6. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g v va.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t;\n        (sa, saa)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        (x, x')\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> Graph.V c\\<rbrakk>\n       \\<Longrightarrow> v \\<in> Graph.V ci\n 7. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g v va sl sla.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t;\n        (sa, saa)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        (x, x')\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> Graph.V c; v \\<in> Graph.V ci;\n        (sl, sla) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> Graph.inner_loop2 ti sl v x1e x1g\n                         \\<le> \\<Down>\n                                (bool_rel \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 \\<langle>nat_rel\\<rangle>set_rel)\n                                (Graph.inner_loop2 t sla va x1a x1c)\n 8. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g v va sl sla xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l\n       x1m x2m x1n x2n x1o x2o x1p x2p x1q x2q x1r x2r x1s x2s.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t;\n        (sa, saa)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        (x, x')\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> Graph.V c; v \\<in> Graph.V ci;\n        (sl, sla) \\<in> Id;\n        (xa, x'a)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>set_rel;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2r = (x1s, x2s); x2q = (x1r, x2r);\n        x2p = (x1q, x2q); (x1n, x1o, x1f - {v}, x2o, x2g) = (x1p, x2p);\n        x2n = (x1o, x2o); xa = (x1n, x2n)\\<rbrakk>\n       \\<Longrightarrow> x1n = x1h\n 9. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n       x1g x2g v va sl sla xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l\n       x1m x2m x1n x2n x1o x2o x1p x2p x1q x2q x1r x2r x1s x2s.\n       \\<lbrakk>si \\<noteq> ti; s \\<noteq> t;\n        (sa, saa)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        (x, x')\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n              \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        case x' of\n        (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n        x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {};\n        (v, va) \\<in> nat_rel; va \\<in> Graph.V c; v \\<in> Graph.V ci;\n        (sl, sla) \\<in> Id;\n        (xa, x'a)\n        \\<in> bool_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>set_rel;\n        x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n        (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n        x'a = (x1h, x2h); x2r = (x1s, x2s); x2q = (x1r, x2r);\n        x2p = (x1q, x2q); (x1n, x1o, x1f - {v}, x2o, x2g) = (x1p, x2p);\n        x2n = (x1o, x2o); xa = (x1n, x2n); x1n; x1h\\<rbrakk>\n       \\<Longrightarrow> ((x1n, x1o, x1f - {v}, x2o, x2g + 1), x1h, x1i,\n                          x1b - {va}, x2i, x2c + 1)\n                         \\<in> bool_rel \\<times>\\<^sub>r\n                               Id \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                               nat_rel\n 10. \\<And>sa saa x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f\n        x1g x2g v va sl sla xa x'a x1h x2h x1i x2i x1j x2j x1k x2k x1l x2l\n        x1m x2m x1n x2n x1o x2o x1p x2p x1q x2q x1r x2r x1s x2s.\n        \\<lbrakk>si \\<noteq> ti; s \\<noteq> t;\n         (sa, saa)\n         \\<in> bool_rel \\<times>\\<^sub>r\n               Id \\<times>\\<^sub>r\n               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n         (x, x')\n         \\<in> bool_rel \\<times>\\<^sub>r\n               Id \\<times>\\<^sub>r\n               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n               \\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r nat_rel;\n         case x of\n         (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n         case x' of\n         (f, PRED, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n         x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n         x2f = (x1g, x2g); x2e = (x1f, x2f); x2d = (x1e, x2e);\n         x = (x1d, x2d); x1b \\<noteq> {}; x1f \\<noteq> {};\n         (v, va) \\<in> nat_rel; va \\<in> Graph.V c; v \\<in> Graph.V ci;\n         (sl, sla) \\<in> Id;\n         (xa, x'a)\n         \\<in> bool_rel \\<times>\\<^sub>r\n               Id \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>set_rel;\n         x2l = (x1m, x2m); x2k = (x1l, x2l); x2j = (x1k, x2k);\n         (x1h, x1i, x1b - {va}, x2i, x2c) = (x1j, x2j); x2h = (x1i, x2i);\n         x'a = (x1h, x2h); x2r = (x1s, x2s); x2q = (x1r, x2r);\n         x2p = (x1q, x2q); (x1n, x1o, x1f - {v}, x2o, x2g) = (x1p, x2p);\n         x2n = (x1o, x2o); xa = (x1n, x2n); \\<not> x1n; \\<not> x1h;\n         \\<not> x1j \\<and> nf_invar' c s t x1k x1l x1m x2m\\<rbrakk>\n        \\<Longrightarrow> \\<not> x1p\nA total of 19 subgoals...", "apply vc_solve"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Imperative Implementation\\<close>"], ["", "context Impl_Succ begin"], ["", "definition op_bfs :: \"'ga \\<Rightarrow> node \\<Rightarrow> node \\<Rightarrow> path option nres\" \n      where [simp]: \"op_bfs c s t \\<equiv> Graph.bfs2 (absG c) (succ c) s t\""], ["", "lemma pat_op_dfs[pat_rules]: \n      \"Graph.bfs2$(absG$c)$(succ$c)$s$t \\<equiv> UNPROTECT op_bfs$c$s$t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph.bfs2 $ (absG $ c) $ (succ $ c) $ s $ t \\<equiv>\n    UNPROTECT op_bfs $ c $ s $ t", "by simp"], ["", "sepref_register \"PR_CONST op_bfs\" \n      :: \"'ig \\<Rightarrow> node \\<Rightarrow> node \\<Rightarrow> path option nres\""], ["", "type_synonym ibfs_state \n      = \"bool \\<times> (node,node) i_map \\<times> node set \\<times> node set \\<times> nat\""], ["", "sepref_register Graph.init_state :: \"node \\<Rightarrow> ibfs_state nres\""], ["", "schematic_goal init_state_impl:\n      fixes src :: nat\n      notes [id_rules] = \n        itypeI[Pure.of src \"TYPE(nat)\"]\n      shows \"hn_refine (hn_val nat_rel src srci) \n        (?c::?'c Heap) ?\\<Gamma>' ?R (Graph.init_state src)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val nat_rel src srci) ?c ?\\<Gamma>' ?R\n     (Graph.init_state src)", "using [[id_debug, goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val nat_rel src srci) ?c ?\\<Gamma>' ?R\n     (Graph.init_state src)", "unfolding Graph.init_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val nat_rel src srci) ?c ?\\<Gamma>' ?R\n     (return (False, [src \\<mapsto> src], {src}, {}, 0))", "apply (rewrite in \"[src\\<mapsto>src]\" iam.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val nat_rel src srci) ?c ?\\<Gamma>' ?R\n     (return (False, op_iam_empty(src \\<mapsto> src), {src}, {}, 0))", "apply (subst ls.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val nat_rel src srci) ?c ?\\<Gamma>' ?R\n     (return\n       (False, op_iam_empty(src \\<mapsto> src), insert src op_ls_empty, {},\n        0))", "apply (subst ls.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val nat_rel src srci) ?c ?\\<Gamma>' ?R\n     (return\n       (False, op_iam_empty(src \\<mapsto> src), insert src op_ls_empty,\n        op_ls_empty, 0))", "apply (rewrite in \"insert src _\" fold_set_insert_dj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val nat_rel src srci) ?c ?\\<Gamma>' ?R\n     (return\n       (False, op_iam_empty(src \\<mapsto> src),\n        op_set_insert_dj src op_ls_empty, op_ls_empty, 0))", "apply (rewrite in \"_(\\<hole>\\<mapsto>src)\" fold_COPY)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val nat_rel src srci) ?c ?\\<Gamma>' ?R\n     (return\n       (False, op_iam_empty(COPY src \\<mapsto> src),\n        op_set_insert_dj src op_ls_empty, op_ls_empty, 0))", "apply sepref"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) init_state_impl uses Impl_Succ.init_state_impl"], ["", "lemmas [sepref_fr_rules] = init_state_impl.refine[OF this_loc,to_hfref]"], ["", "schematic_goal bfs_impl:\n      (*notes [sepref_opt_simps del] = imp_nfoldli_def \n          -- \\<open>Prevent the foreach-loop to be unfolded to a fixed-point, \n              to produce more readable code for presentation purposes.\\<close>*)\n      notes [sepref_opt_simps] = heap_WHILET_def\n      fixes s t :: nat\n      notes [id_rules] = \n        itypeI[Pure.of s \"TYPE(nat)\"]\n        itypeI[Pure.of t \"TYPE(nat)\"]\n        itypeI[Pure.of c \"TYPE('ig)\"]\n        \\<comment> \\<open>Declare parameters to operation identification\\<close>\n      shows \"hn_refine (\n        hn_ctxt (isG) c ci \n      * hn_val nat_rel s si \n      * hn_val nat_rel t ti) (?c::?'c Heap) ?\\<Gamma>' ?R (PR_CONST op_bfs c s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt isG c ci * hn_val nat_rel s si * hn_val nat_rel t ti)\n     ?c ?\\<Gamma>' ?R (PR_CONST op_bfs c s t)", "unfolding op_bfs_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt isG c ci * hn_val nat_rel s si * hn_val nat_rel t ti)\n     ?c ?\\<Gamma>' ?R (Graph.bfs2 (absG c) (succ c) s t)", "unfolding Graph.bfs2_def Graph.pre_bfs2_def \n        Graph.inner_loop2_def Graph.extract_rpath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt isG c ci * hn_val nat_rel s si * hn_val nat_rel t ti)\n     ?c ?\\<Gamma>' ?R\n     (if s = t then return (Some [])\n      else Graph.init_state s \\<bind>\n           (\\<lambda>sa.\n               while\\<^sub>T\n                (\\<lambda>(f, PRED, C, N, d).\n                    f = False \\<and> C \\<noteq> {})\n                (\\<lambda>(f, PRED, C, N, d).\n                    assert (C \\<noteq> {}) \\<bind>\n                    (\\<lambda>_.\n                        IICF_Set.op_set_pick C \\<bind>\n                        (\\<lambda>v.\n                            let C = C - {v}\n                            in assert (v \\<in> Graph.V (absG c)) \\<bind>\n                               (\\<lambda>_.\n                                   succ c v \\<bind>\n                                   (\\<lambda>sl.\n nfoldli sl (\\<lambda>(f, uu_, uu_). \\<not> f)\n  (\\<lambda>va (f, PRED, N).\n      if PRED va \\<noteq> None then return (f, PRED, N)\n      else let PRED = PRED(va \\<mapsto> v)\n           in assert (va \\<notin> N) \\<bind>\n              (\\<lambda>_. let N = insert va N in return (va = t, PRED, N)))\n  (False, PRED, N) \\<bind>\n (\\<lambda>(f, PRED, N).\n     if f then return (f, PRED, C, N, d + 1)\n     else assert\n           (case (f, PRED, C, N, d) of\n            (f, PRED, C, N, d) \\<Rightarrow>\n              \\<not> f \\<and> nf_invar' (absG c) s t PRED C N d) \\<bind>\n          (\\<lambda>_.\n              if C = {}\n              then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n              else return (f, PRED, C, N, d))))))))\n                sa \\<bind>\n               (\\<lambda>(f, PRED, uu_, uu_, d).\n                   if f then return (Some (d, PRED))\n                   else return None)) \\<bind>\n           (\\<lambda>br.\n               case br of None \\<Rightarrow> return None\n               | Some (d, PRED) \\<Rightarrow>\n                   while\\<^sub>T\\<^bsup>\\<lambda>(v, p).\n     v \\<in> dom PRED \\<and>\n     Graph.isPath (absG c) v p t \\<and>\n     distinct (Graph.pathVertices v p) \\<and>\n     (\\<forall>v'\\<in>set (Graph.pathVertices v p).\n         Graph.min_dist (absG c) s v\n         \\<le> Graph.min_dist (absG c) s v') \\<and>\n     Graph.min_dist (absG c) s v + length p =\n     Graph.min_dist (absG c) s t\\<^esup>\n                    (\\<lambda>(v, p). v \\<noteq> s)\n                    (\\<lambda>(v, p).\n                        assert (v \\<in> dom PRED) \\<bind>\n                        (\\<lambda>_.\n                            let u = the (PRED v); p = (u, v) # p; v = u\n                            in return (v, p)))\n                    (t, []) \\<bind>\n                   (\\<lambda>(uu_, p). return p) \\<bind>\n                   (\\<lambda>p. return (Some p))))", "unfolding nres_monad_laws"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt isG c ci * hn_val nat_rel s si * hn_val nat_rel t ti)\n     ?c ?\\<Gamma>' ?R\n     (if s = t then return (Some [])\n      else Graph.init_state s \\<bind>\n           (\\<lambda>x.\n               while\\<^sub>T\n                (\\<lambda>(f, PRED, C, N, d).\n                    f = False \\<and> C \\<noteq> {})\n                (\\<lambda>(f, PRED, C, N, d).\n                    assert (C \\<noteq> {}) \\<bind>\n                    (\\<lambda>_.\n                        IICF_Set.op_set_pick C \\<bind>\n                        (\\<lambda>v.\n                            let C = C - {v}\n                            in assert (v \\<in> Graph.V (absG c)) \\<bind>\n                               (\\<lambda>_.\n                                   succ c v \\<bind>\n                                   (\\<lambda>sl.\n nfoldli sl (\\<lambda>(f, uu_, uu_). \\<not> f)\n  (\\<lambda>va (f, PRED, N).\n      if PRED va \\<noteq> None then return (f, PRED, N)\n      else let PRED = PRED(va \\<mapsto> v)\n           in assert (va \\<notin> N) \\<bind>\n              (\\<lambda>_. let N = insert va N in return (va = t, PRED, N)))\n  (False, PRED, N) \\<bind>\n (\\<lambda>(f, PRED, N).\n     if f then return (f, PRED, C, N, d + 1)\n     else assert\n           (case (f, PRED, C, N, d) of\n            (f, PRED, C, N, d) \\<Rightarrow>\n              \\<not> f \\<and> nf_invar' (absG c) s t PRED C N d) \\<bind>\n          (\\<lambda>_.\n              if C = {}\n              then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n              else return (f, PRED, C, N, d))))))))\n                x \\<bind>\n               (\\<lambda>x.\n                   (case x of\n                    (f, PRED, uu_, uua_, d) \\<Rightarrow>\n                      if f then return (Some (d, PRED))\n                      else return None) \\<bind>\n                   case_option (return None)\n                    (\\<lambda>(d, PRED).\n                        while\\<^sub>T\\<^bsup>\\<lambda>(v, p).\n          v \\<in> dom PRED \\<and>\n          Graph.isPath (absG c) v p t \\<and>\n          distinct (Graph.pathVertices v p) \\<and>\n          (\\<forall>v'\\<in>set (Graph.pathVertices v p).\n              Graph.min_dist (absG c) s v\n              \\<le> Graph.min_dist (absG c) s v') \\<and>\n          Graph.min_dist (absG c) s v + length p =\n          Graph.min_dist (absG c) s t\\<^esup>\n                         (\\<lambda>(v, p). v \\<noteq> s)\n                         (\\<lambda>(v, p).\n                             assert (v \\<in> dom PRED) \\<bind>\n                             (\\<lambda>_.\n                                 let u = the (PRED v); p = (u, v) # p; v = u\n                                 in return (v, p)))\n                         (t, []) \\<bind>\n                        (\\<lambda>x.\n                            (case x of\n                             (uu_, x) \\<Rightarrow> return x) \\<bind>\n                            (\\<lambda>p. return (Some p)))))))", "apply (rewrite in \"nfoldli _ _ \\<hole> _\" fold_set_insert_dj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt isG c ci * hn_val nat_rel s si * hn_val nat_rel t ti)\n     ?c ?\\<Gamma>' ?R\n     (if s = t then return (Some [])\n      else Graph.init_state s \\<bind>\n           (\\<lambda>x.\n               while\\<^sub>T\n                (\\<lambda>(f, PRED, C, N, d).\n                    f = False \\<and> C \\<noteq> {})\n                (\\<lambda>(f, PRED, C, N, d).\n                    assert (C \\<noteq> {}) \\<bind>\n                    (\\<lambda>_.\n                        IICF_Set.op_set_pick C \\<bind>\n                        (\\<lambda>v.\n                            let C = C - {v}\n                            in assert (v \\<in> Graph.V (absG c)) \\<bind>\n                               (\\<lambda>_.\n                                   succ c v \\<bind>\n                                   (\\<lambda>sl.\n nfoldli sl (\\<lambda>(f, uu_, uu_). \\<not> f)\n  (\\<lambda>va (f, PRED, N).\n      if PRED va \\<noteq> None then return (f, PRED, N)\n      else let PRED = PRED(va \\<mapsto> v)\n           in assert (va \\<notin> N) \\<bind>\n              (\\<lambda>_.\n                  let N = op_set_insert_dj va N\n                  in return (va = t, PRED, N)))\n  (False, PRED, N) \\<bind>\n (\\<lambda>(f, PRED, N).\n     if f then return (f, PRED, C, N, d + 1)\n     else assert\n           (case (f, PRED, C, N, d) of\n            (f, PRED, C, N, d) \\<Rightarrow>\n              \\<not> f \\<and> nf_invar' (absG c) s t PRED C N d) \\<bind>\n          (\\<lambda>_.\n              if C = {}\n              then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n              else return (f, PRED, C, N, d))))))))\n                x \\<bind>\n               (\\<lambda>x.\n                   (case x of\n                    (f, PRED, uu_, uua_, d) \\<Rightarrow>\n                      if f then return (Some (d, PRED))\n                      else return None) \\<bind>\n                   case_option (return None)\n                    (\\<lambda>(d, PRED).\n                        while\\<^sub>T\\<^bsup>\\<lambda>(v, p).\n          v \\<in> dom PRED \\<and>\n          Graph.isPath (absG c) v p t \\<and>\n          distinct (Graph.pathVertices v p) \\<and>\n          (\\<forall>v'\\<in>set (Graph.pathVertices v p).\n              Graph.min_dist (absG c) s v\n              \\<le> Graph.min_dist (absG c) s v') \\<and>\n          Graph.min_dist (absG c) s v + length p =\n          Graph.min_dist (absG c) s t\\<^esup>\n                         (\\<lambda>(v, p). v \\<noteq> s)\n                         (\\<lambda>(v, p).\n                             assert (v \\<in> dom PRED) \\<bind>\n                             (\\<lambda>_.\n                                 let u = the (PRED v); p = (u, v) # p; v = u\n                                 in return (v, p)))\n                         (t, []) \\<bind>\n                        (\\<lambda>x.\n                            (case x of\n                             (uu_, x) \\<Rightarrow> return x) \\<bind>\n                            (\\<lambda>p. return (Some p)))))))", "apply (subst HOL_list.fold_custom_empty)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt isG c ci * hn_val nat_rel s si * hn_val nat_rel t ti)\n     ?c ?\\<Gamma>' ?R\n     (if s = t then return (Some op_HOL_list_empty)\n      else Graph.init_state s \\<bind>\n           (\\<lambda>x.\n               while\\<^sub>T\n                (\\<lambda>(f, PRED, C, N, d).\n                    f = False \\<and> C \\<noteq> {})\n                (\\<lambda>(f, PRED, C, N, d).\n                    assert (C \\<noteq> {}) \\<bind>\n                    (\\<lambda>_.\n                        IICF_Set.op_set_pick C \\<bind>\n                        (\\<lambda>v.\n                            let C = C - {v}\n                            in assert (v \\<in> Graph.V (absG c)) \\<bind>\n                               (\\<lambda>_.\n                                   succ c v \\<bind>\n                                   (\\<lambda>sl.\n nfoldli sl (\\<lambda>(f, uu_, uu_). \\<not> f)\n  (\\<lambda>va (f, PRED, N).\n      if PRED va \\<noteq> None then return (f, PRED, N)\n      else let PRED = PRED(va \\<mapsto> v)\n           in assert (va \\<notin> N) \\<bind>\n              (\\<lambda>_.\n                  let N = op_set_insert_dj va N\n                  in return (va = t, PRED, N)))\n  (False, PRED, N) \\<bind>\n (\\<lambda>(f, PRED, N).\n     if f then return (f, PRED, C, N, d + 1)\n     else assert\n           (case (f, PRED, C, N, d) of\n            (f, PRED, C, N, d) \\<Rightarrow>\n              \\<not> f \\<and> nf_invar' (absG c) s t PRED C N d) \\<bind>\n          (\\<lambda>_.\n              if C = {}\n              then let C = N; N = {}; d = d + 1 in return (f, PRED, C, N, d)\n              else return (f, PRED, C, N, d))))))))\n                x \\<bind>\n               (\\<lambda>x.\n                   (case x of\n                    (f, PRED, uu_, uua_, d) \\<Rightarrow>\n                      if f then return (Some (d, PRED))\n                      else return None) \\<bind>\n                   case_option (return None)\n                    (\\<lambda>(d, PRED).\n                        while\\<^sub>T\\<^bsup>\\<lambda>(v, p).\n          v \\<in> dom PRED \\<and>\n          Graph.isPath (absG c) v p t \\<and>\n          distinct (Graph.pathVertices v p) \\<and>\n          (\\<forall>v'\\<in>set (Graph.pathVertices v p).\n              Graph.min_dist (absG c) s v\n              \\<le> Graph.min_dist (absG c) s v') \\<and>\n          Graph.min_dist (absG c) s v + length p =\n          Graph.min_dist (absG c) s t\\<^esup>\n                         (\\<lambda>(v, p). v \\<noteq> s)\n                         (\\<lambda>(v, p).\n                             assert (v \\<in> dom PRED) \\<bind>\n                             (\\<lambda>_.\n                                 let u = the (PRED v); p = (u, v) # p; v = u\n                                 in return (v, p)))\n                         (t, op_HOL_list_empty) \\<bind>\n                        (\\<lambda>x.\n                            (case x of\n                             (uu_, x) \\<Rightarrow> return x) \\<bind>\n                            (\\<lambda>p. return (Some p)))))))", "apply (rewrite in \"let N={} in _\" ls.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt isG c ci * hn_val nat_rel s si * hn_val nat_rel t ti)\n     ?c ?\\<Gamma>' ?R\n     (if s = t then return (Some op_HOL_list_empty)\n      else Graph.init_state s \\<bind>\n           (\\<lambda>x.\n               while\\<^sub>T\n                (\\<lambda>(f, PRED, C, N, d).\n                    f = False \\<and> C \\<noteq> {})\n                (\\<lambda>(f, PRED, C, N, d).\n                    assert (C \\<noteq> {}) \\<bind>\n                    (\\<lambda>_.\n                        IICF_Set.op_set_pick C \\<bind>\n                        (\\<lambda>v.\n                            let C = C - {v}\n                            in assert (v \\<in> Graph.V (absG c)) \\<bind>\n                               (\\<lambda>_.\n                                   succ c v \\<bind>\n                                   (\\<lambda>sl.\n nfoldli sl (\\<lambda>(f, uu_, uu_). \\<not> f)\n  (\\<lambda>va (f, PRED, N).\n      if PRED va \\<noteq> None then return (f, PRED, N)\n      else let PRED = PRED(va \\<mapsto> v)\n           in assert (va \\<notin> N) \\<bind>\n              (\\<lambda>_.\n                  let N = op_set_insert_dj va N\n                  in return (va = t, PRED, N)))\n  (False, PRED, N) \\<bind>\n (\\<lambda>(f, PRED, N).\n     if f then return (f, PRED, C, N, d + 1)\n     else assert\n           (case (f, PRED, C, N, d) of\n            (f, PRED, C, N, d) \\<Rightarrow>\n              \\<not> f \\<and> nf_invar' (absG c) s t PRED C N d) \\<bind>\n          (\\<lambda>_.\n              if C = {}\n              then let C = N; N = op_ls_empty; d = d + 1\n                   in return (f, PRED, C, N, d)\n              else return (f, PRED, C, N, d))))))))\n                x \\<bind>\n               (\\<lambda>x.\n                   (case x of\n                    (f, PRED, uu_, uua_, d) \\<Rightarrow>\n                      if f then return (Some (d, PRED))\n                      else return None) \\<bind>\n                   case_option (return None)\n                    (\\<lambda>(d, PRED).\n                        while\\<^sub>T\\<^bsup>\\<lambda>(v, p).\n          v \\<in> dom PRED \\<and>\n          Graph.isPath (absG c) v p t \\<and>\n          distinct (Graph.pathVertices v p) \\<and>\n          (\\<forall>v'\\<in>set (Graph.pathVertices v p).\n              Graph.min_dist (absG c) s v\n              \\<le> Graph.min_dist (absG c) s v') \\<and>\n          Graph.min_dist (absG c) s v + length p =\n          Graph.min_dist (absG c) s t\\<^esup>\n                         (\\<lambda>(v, p). v \\<noteq> s)\n                         (\\<lambda>(v, p).\n                             assert (v \\<in> dom PRED) \\<bind>\n                             (\\<lambda>_.\n                                 let u = the (PRED v); p = (u, v) # p; v = u\n                                 in return (v, p)))\n                         (t, op_HOL_list_empty) \\<bind>\n                        (\\<lambda>x.\n                            (case x of\n                             (uu_, x) \\<Rightarrow> return x) \\<bind>\n                            (\\<lambda>p. return (Some p)))))))", "using [[id_debug, goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt isG c ci * hn_val nat_rel s si * hn_val nat_rel t ti)\n     ?c ?\\<Gamma>' ?R\n     (if s = t then return (Some op_HOL_list_empty)\n      else Graph.init_state s \\<bind>\n           (\\<lambda>x.\n               while\\<^sub>T\n                (\\<lambda>(f, PRED, C, N, d).\n                    f = False \\<and> C \\<noteq> {})\n                (\\<lambda>(f, PRED, C, N, d).\n                    assert (C \\<noteq> {}) \\<bind>\n                    (\\<lambda>_.\n                        IICF_Set.op_set_pick C \\<bind>\n                        (\\<lambda>v.\n                            let C = C - {v}\n                            in assert (v \\<in> Graph.V (absG c)) \\<bind>\n                               (\\<lambda>_.\n                                   succ c v \\<bind>\n                                   (\\<lambda>sl.\n nfoldli sl (\\<lambda>(f, uu_, uu_). \\<not> f)\n  (\\<lambda>va (f, PRED, N).\n      if PRED va \\<noteq> None then return (f, PRED, N)\n      else let PRED = PRED(va \\<mapsto> v)\n           in assert (va \\<notin> N) \\<bind>\n              (\\<lambda>_.\n                  let N = op_set_insert_dj va N\n                  in return (va = t, PRED, N)))\n  (False, PRED, N) \\<bind>\n (\\<lambda>(f, PRED, N).\n     if f then return (f, PRED, C, N, d + 1)\n     else assert\n           (case (f, PRED, C, N, d) of\n            (f, PRED, C, N, d) \\<Rightarrow>\n              \\<not> f \\<and> nf_invar' (absG c) s t PRED C N d) \\<bind>\n          (\\<lambda>_.\n              if C = {}\n              then let C = N; N = op_ls_empty; d = d + 1\n                   in return (f, PRED, C, N, d)\n              else return (f, PRED, C, N, d))))))))\n                x \\<bind>\n               (\\<lambda>x.\n                   (case x of\n                    (f, PRED, uu_, uua_, d) \\<Rightarrow>\n                      if f then return (Some (d, PRED))\n                      else return None) \\<bind>\n                   case_option (return None)\n                    (\\<lambda>(d, PRED).\n                        while\\<^sub>T\\<^bsup>\\<lambda>(v, p).\n          v \\<in> dom PRED \\<and>\n          Graph.isPath (absG c) v p t \\<and>\n          distinct (Graph.pathVertices v p) \\<and>\n          (\\<forall>v'\\<in>set (Graph.pathVertices v p).\n              Graph.min_dist (absG c) s v\n              \\<le> Graph.min_dist (absG c) s v') \\<and>\n          Graph.min_dist (absG c) s v + length p =\n          Graph.min_dist (absG c) s t\\<^esup>\n                         (\\<lambda>(v, p). v \\<noteq> s)\n                         (\\<lambda>(v, p).\n                             assert (v \\<in> dom PRED) \\<bind>\n                             (\\<lambda>_.\n                                 let u = the (PRED v); p = (u, v) # p; v = u\n                                 in return (v, p)))\n                         (t, op_HOL_list_empty) \\<bind>\n                        (\\<lambda>x.\n                            (case x of\n                             (uu_, x) \\<Rightarrow> return x) \\<bind>\n                            (\\<lambda>p. return (Some p)))))))", "apply sepref"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) bfs_impl uses Impl_Succ.bfs_impl\n      \\<comment> \\<open>Extract generated implementation into constant\\<close>"], ["", "prepare_code_thms (in -) bfs_impl_def"], ["", "lemmas bfs_impl_fr_rule = bfs_impl.refine[OF this_loc,to_hfref]"], ["", "end"], ["", "export_code bfs_impl checking SML_imp"], ["", "end"]]}