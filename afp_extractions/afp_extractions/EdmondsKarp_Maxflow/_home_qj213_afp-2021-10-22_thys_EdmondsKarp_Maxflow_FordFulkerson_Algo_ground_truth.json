{"file_name": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow/FordFulkerson_Algo.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/EdmondsKarp_Maxflow", "problem_names": ["lemma zero_flow: \"NFlow c s t (\\<lambda>_. 0)\"", "lemma (in NFlow) augment_pres_nflow:\n  assumes AUG: \"isAugmentingPath p\"\n  shows \"NFlow c s t (augment (augmentingFlow p))\"", "lemma (in NFlow) augmenting_path_not_empty:\n  \"\\<not>isAugmentingPath []\"", "theorem fofu_partial_correct: \"fofu \\<le> (spec f. isMaxFlow f)\"", "theorem (in Network) \"ford_fulkerson_method \\<le> (spec f. isMaxFlow f)\""], "translations": [["", "lemma zero_flow: \"NFlow c s t (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t (\\<lambda>_. 0::'capacity)", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>e.\n       (0::'capacity) \\<le> (0::'capacity) \\<and> (0::'capacity) \\<le> c e\n 2. \\<forall>v\\<in>V - {s, t}.\n       (\\<Sum>e\\<in>outgoing v. (0::'capacity))\n       \\<le> (\\<Sum>e\\<in>incoming v. (0::'capacity))\n 3. \\<forall>v\\<in>V - {s, t}.\n       (\\<Sum>e\\<in>incoming v. (0::'capacity))\n       \\<le> (\\<Sum>e\\<in>outgoing v. (0::'capacity))", "by (auto simp: s_node t_node cap_non_negative)"], ["", "text \\<open>Augmentation preserves the flow property\\<close>"], ["", "lemma (in NFlow) augment_pres_nflow:\n  assumes AUG: \"isAugmentingPath p\"\n  shows \"NFlow c s t (augment (augmentingFlow p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t (augment (augmentingFlow p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NFlow c s t (augment (augmentingFlow p))", "from augment_flow_presv[OF augFlow_resFlow[OF AUG]]"], ["proof (chain)\npicking this:\n  Flow c s t (augment (augmentingFlow p))", "interpret f': Flow c s t \"augment (augmentingFlow p)\""], ["proof (prove)\nusing this:\n  Flow c s t (augment (augmentingFlow p))\n\ngoal (1 subgoal):\n 1. Flow c s t (augment (augmentingFlow p))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. NFlow c s t (augment (augmentingFlow p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t (augment (augmentingFlow p))", "by intro_locales"], ["proof (state)\nthis:\n  NFlow c s t (augment (augmentingFlow p))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Augmenting paths cannot be empty\\<close>"], ["", "lemma (in NFlow) augmenting_path_not_empty:\n  \"\\<not>isAugmentingPath []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> isAugmentingPath []", "unfolding isAugmentingPath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> cf.isSimplePath s [] t", "using s_not_t"], ["proof (prove)\nusing this:\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<not> cf.isSimplePath s [] t", "by auto"], ["", "text \\<open>Finally, we can use the verification condition generator to\n  show correctness\\<close>"], ["", "theorem fofu_partial_correct: \"fofu \\<le> (spec f. isMaxFlow f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fofu \\<le> SPEC isMaxFlow", "unfolding fofu_def find_augmenting_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let f\\<^sub>0 = \\<lambda>_. 0::'capacity\n     in while\\<^bsup>fofu_invar\\<^esup> (\\<lambda>(f, brk). \\<not> brk)\n         (\\<lambda>(f, uu_).\n             assert (NFlow c s t f) \\<bind>\n             (\\<lambda>_.\n                 select p. NPreflow.isAugmentingPath c s t f p) \\<bind>\n             (\\<lambda>p.\n                 case p of None \\<Rightarrow> return (f, True)\n                 | Some p \\<Rightarrow>\n                     assert (p \\<noteq> []) \\<bind>\n                     (\\<lambda>_.\n                         assert\n                          (NPreflow.isAugmentingPath c s t f p) \\<bind>\n                         (\\<lambda>_.\n                             let f = NFlow.augment_with_path c f p\n                             in assert (NFlow c s t f) \\<bind>\n                                (\\<lambda>_. return (f, False))))))\n         (f\\<^sub>0, False) \\<bind>\n        (\\<lambda>(f, uu_).\n            assert (NFlow c s t f) \\<bind> (\\<lambda>_. return f)))\n    \\<le> SPEC isMaxFlow", "apply (refine_vcg)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>x1 x2.\n       (\\<lambda>_. 0::'capacity, False) = (x1, x2) \\<Longrightarrow>\n       NFlow c s t x1\n 2. \\<And>x1 x2 p.\n       \\<lbrakk>(\\<lambda>_. 0::'capacity, False) = (x1, x2); x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> NPreflow.isAugmentingPath c s t x1 p\n 3. \\<And>sa a b.\n       \\<lbrakk>fofu_invar sa; case sa of (f, brk) \\<Rightarrow> \\<not> brk;\n        sa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t a\n 4. \\<And>sa a b x x1 x2.\n       \\<lbrakk>fofu_invar sa; case sa of (f, brk) \\<Rightarrow> \\<not> brk;\n        sa = (a, b); NFlow c s t a; NPreflow.isAugmentingPath c s t a x;\n        Some x = None; (a, True) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t x1\n 5. \\<And>sa a b x x1 x2 p.\n       \\<lbrakk>fofu_invar sa; case sa of (f, brk) \\<Rightarrow> \\<not> brk;\n        sa = (a, b); NFlow c s t a; NPreflow.isAugmentingPath c s t a x;\n        Some x = None; (a, True) = (x1, x2); x2\\<rbrakk>\n       \\<Longrightarrow> \\<not> NPreflow.isAugmentingPath c s t x1 p\n 6. \\<And>sa a b x xa.\n       \\<lbrakk>fofu_invar sa; case sa of (f, brk) \\<Rightarrow> \\<not> brk;\n        sa = (a, b); NFlow c s t a; NPreflow.isAugmentingPath c s t a x;\n        Some x = Some xa\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 7. \\<And>sa a b x xa.\n       \\<lbrakk>fofu_invar sa; case sa of (f, brk) \\<Rightarrow> \\<not> brk;\n        sa = (a, b); NFlow c s t a; NPreflow.isAugmentingPath c s t a x;\n        Some x = Some xa; xa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> NPreflow.isAugmentingPath c s t a xa\n 8. \\<And>sa a b x xa.\n       \\<lbrakk>fofu_invar sa; case sa of (f, brk) \\<Rightarrow> \\<not> brk;\n        sa = (a, b); NFlow c s t a; NPreflow.isAugmentingPath c s t a x;\n        Some x = Some xa; xa \\<noteq> [];\n        NPreflow.isAugmentingPath c s t a xa\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t (NFlow.augment_with_path c a xa)\n 9. \\<And>sa a b x xa x1 x2.\n       \\<lbrakk>fofu_invar sa; case sa of (f, brk) \\<Rightarrow> \\<not> brk;\n        sa = (a, b); NFlow c s t a; NPreflow.isAugmentingPath c s t a x;\n        Some x = Some xa; xa \\<noteq> [];\n        NPreflow.isAugmentingPath c s t a xa;\n        NFlow c s t (NFlow.augment_with_path c a xa);\n        (NFlow.augment_with_path c a xa, False) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> NFlow c s t x1\n 10. \\<And>sa a b x xa x1 x2 p.\n        \\<lbrakk>fofu_invar sa;\n         case sa of (f, brk) \\<Rightarrow> \\<not> brk; sa = (a, b);\n         NFlow c s t a; NPreflow.isAugmentingPath c s t a x;\n         Some x = Some xa; xa \\<noteq> [];\n         NPreflow.isAugmentingPath c s t a xa;\n         NFlow c s t (NFlow.augment_with_path c a xa);\n         (NFlow.augment_with_path c a xa, False) = (x1, x2); x2\\<rbrakk>\n        \\<Longrightarrow> \\<not> NPreflow.isAugmentingPath c s t x1 p\nA total of 19 subgoals...", "apply (vc_solve simp: \n    zero_flow \n    NFlow.augment_pres_nflow \n    NFlow.augmenting_path_not_empty\n    NFlow.noAugPath_iff_maxFlow[symmetric]\n    NFlow.augment_with_path_def\n  )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Algorithm without Assertions\\<close>"], ["", "text \\<open>For presentation purposes, we extract a version of the algorithm\n  without assertions, and using a bit more concise notation\\<close>"], ["", "context begin"], ["", "private"], ["", "abbreviation (input) \"augment \n  \\<equiv> NFlow.augment_with_path\""], ["", "private"], ["", "abbreviation (input) \"is_augmenting_path f p \n  \\<equiv> NPreflow.isAugmentingPath c s t f p\""], ["", "text \\<open> {} \\<close>"], ["", "text_raw \\<open>\\DefineSnippet{ford_fulkerson_algo}{\\<close>"], ["", "definition \"ford_fulkerson_method \\<equiv> do {\n  let f\\<^sub>0 = (\\<lambda>(u,v). 0);\n\n  (f,brk) \\<leftarrow> while (\\<lambda>(f,brk). \\<not>brk) \n    (\\<lambda>(f,brk). do {\n      p \\<leftarrow> select p. is_augmenting_path f p;\n      case p of \n        None \\<Rightarrow> return (f,True)\n      | Some p \\<Rightarrow> return (augment c f p, False)\n    })\n    (f\\<^sub>0,False);\n  return f \n}\""], ["", "text_raw \\<open>}%EndSnippet\\<close>"], ["", "text \\<open> {} \\<close>"], ["", "end \\<comment> \\<open>Anonymous context\\<close>"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "text \\<open> {} \\<close>"], ["", "text_raw \\<open>\\DefineSnippet{ford_fulkerson_correct}{\\<close>"], ["", "theorem (in Network) \"ford_fulkerson_method \\<le> (spec f. isMaxFlow f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ford_fulkerson_method \\<le> SPEC isMaxFlow", "text_raw \\<open>}%EndSnippet\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ford_fulkerson_method \\<le> SPEC isMaxFlow", "text \\<open> {} \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ford_fulkerson_method \\<le> SPEC isMaxFlow", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ford_fulkerson_method \\<le> SPEC isMaxFlow", "have [simp]: \"(\\<lambda>(u,v). 0) = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(u, v). 0::'c) = (\\<lambda>_. 0::'c)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(u, v). 0::?'c1) = (\\<lambda>_. 0::?'c1)\n\ngoal (1 subgoal):\n 1. ford_fulkerson_method \\<le> SPEC isMaxFlow", "have \"ford_fulkerson_method \\<le> fofu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ford_fulkerson_method \\<le> fofu", "unfolding ford_fulkerson_method_def fofu_def Let_def find_augmenting_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. while (\\<lambda>(f, y). \\<not> y)\n     (\\<lambda>(f, brk).\n         SELECT (NPreflow.isAugmentingPath c s t f) \\<bind>\n         case_option (return (f, True))\n          (\\<lambda>p. return (NFlow.augment_with_path c f p, False)))\n     (\\<lambda>(u, v). 0::'capacity, False) \\<bind>\n    (\\<lambda>(f, brk). return f)\n    \\<le> while\\<^bsup>fofu_invar\\<^esup> (\\<lambda>(f, y). \\<not> y)\n           (\\<lambda>(f, uu_).\n               assert (NFlow c s t f) \\<bind>\n               (\\<lambda>_.\n                   SELECT (NPreflow.isAugmentingPath c s t f)) \\<bind>\n               case_option (return (f, True))\n                (\\<lambda>p.\n                    assert (p \\<noteq> []) \\<bind>\n                    (\\<lambda>_.\n                        assert (NPreflow.isAugmentingPath c s t f p) \\<bind>\n                        (\\<lambda>_.\n                            assert\n                             (NFlow c s t\n                               (NFlow.augment_with_path c f p)) \\<bind>\n                            (\\<lambda>_.\n                                return\n                                 (NFlow.augment_with_path c f p, False))))))\n           (\\<lambda>_. 0::'capacity, False) \\<bind>\n          (\\<lambda>(f, uu_).\n              assert (NFlow c s t f) \\<bind> (\\<lambda>_. return f))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. while (\\<lambda>(f, y). \\<not> y)\n     (\\<lambda>(f, brk).\n         SELECT (NPreflow.isAugmentingPath c s t f) \\<bind>\n         case_option (return (f, True))\n          (\\<lambda>p. return (NFlow.augment_with_path c f p, False)))\n     (\\<lambda>(u, v). 0::'capacity, False) \\<bind>\n    (\\<lambda>(f, brk). return f)\n    \\<le> \\<Down> Id\n           (while\\<^bsup>fofu_invar\\<^esup> (\\<lambda>(f, y). \\<not> y)\n             (\\<lambda>(f, uu_).\n                 assert (NFlow c s t f) \\<bind>\n                 (\\<lambda>_.\n                     SELECT (NPreflow.isAugmentingPath c s t f)) \\<bind>\n                 case_option (return (f, True))\n                  (\\<lambda>p.\n                      assert (p \\<noteq> []) \\<bind>\n                      (\\<lambda>_.\n                          assert\n                           (NPreflow.isAugmentingPath c s t f p) \\<bind>\n                          (\\<lambda>_.\n                              assert\n                               (NFlow c s t\n                                 (NFlow.augment_with_path c f p)) \\<bind>\n                              (\\<lambda>_.\n                                  return\n                                   (NFlow.augment_with_path c f p,\n                                    False))))))\n             (\\<lambda>_. 0::'capacity, False) \\<bind>\n            (\\<lambda>(f, uu_).\n                assert (NFlow c s t f) \\<bind> (\\<lambda>_. return f)))", "apply (refine_vcg)"], ["proof (prove)\ngoal (9 subgoals):\n 1. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>(u, v). 0::'capacity, False), \\<lambda>_. 0::'capacity,\n     False)\n    \\<in> ?R'2\n 2. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'2; fofu_invar x'; x = (x1, x2);\n        x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 3. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'2; case x of (f, x) \\<Rightarrow> \\<not> x;\n        case x' of (f, x) \\<Rightarrow> \\<not> x; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> RELATES (?R34 x x' x1 x2 x1a x2a)\n 4. \\<And>x x' x1 x2 x1a x2a x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'2; case x of (f, x) \\<Rightarrow> \\<not> x;\n        case x' of (f, x) \\<Rightarrow> \\<not> x; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); NFlow c s t x1;\n        NPreflow.isAugmentingPath c s t x1 x'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. NPreflow.isAugmentingPath c s t x1a x\n 5. \\<And>x x' x1 x2 x1a x2a xa.\n       \\<lbrakk>(x, x') \\<in> ?R'2; case x of (f, x) \\<Rightarrow> \\<not> x;\n        case x' of (f, x) \\<Rightarrow> \\<not> x; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); NFlow c s t x1;\n        NPreflow.isAugmentingPath c s t x1a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'a.\n                            (xa, x'a) \\<in> ?R34 x x' x1 x2 x1a x2a \\<and>\n                            NPreflow.isAugmentingPath c s t x1 x'a\n 6. \\<And>x x' x1 x2 x1a x2a xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'2; case x of (f, x) \\<Rightarrow> \\<not> x;\n        case x' of (f, x) \\<Rightarrow> \\<not> x; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, x'a)\n        \\<in> \\<langle>?R34 x x' x1 x2 x1a x2a\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (xa, x'a)\n                         \\<in> \\<langle>?Ra35 x x' x1 x2 x1a x2a xa\n   x'a\\<rangle>option_rel\n 7. \\<And>x x' x1 x2 x1a x2a xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'2; case x of (f, x) \\<Rightarrow> \\<not> x;\n        case x' of (f, x) \\<Rightarrow> \\<not> x; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, x'a) \\<in> \\<langle>?R34 x x' x1 x2 x1a x2a\\<rangle>option_rel;\n        xa = None; x'a = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True) \\<in> ?R'2\n 8. \\<And>x x' x1 x2 x1a x2a xa x'a xb x'b.\n       \\<lbrakk>(x, x') \\<in> ?R'2; case x of (f, x) \\<Rightarrow> \\<not> x;\n        case x' of (f, x) \\<Rightarrow> \\<not> x; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, x'a) \\<in> \\<langle>?R34 x x' x1 x2 x1a x2a\\<rangle>option_rel;\n        xa = Some xb; x'a = Some x'b;\n        (xb, x'b) \\<in> ?Ra35 x x' x1 x2 x1a x2a xa x'a; x'b \\<noteq> [];\n        NPreflow.isAugmentingPath c s t x1 x'b;\n        NFlow c s t (NFlow.augment_with_path c x1 x'b)\\<rbrakk>\n       \\<Longrightarrow> ((NFlow.augment_with_path c x1a xb, False),\n                          NFlow.augment_with_path c x1 x'b, False)\n                         \\<in> ?R'2\n 9. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> ?R'2; x' = (x1, x2); x = (x1a, x2a);\n        NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> Id", "apply (refine_dref_type)"], ["proof (prove)\ngoal (7 subgoals):\n 1. fofu_invar (\\<lambda>_. 0::'capacity, False) \\<Longrightarrow>\n    ((\\<lambda>(u, v). 0::'capacity, False), \\<lambda>_. 0::'capacity,\n     False)\n    \\<in> Id \\<times>\\<^sub>r bool_rel\n 2. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; fofu_invar x';\n        x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2) = (\\<not> x2a)\n 3. \\<And>x x' x1 x2 x1a x2a x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, x) \\<Rightarrow> \\<not> x;\n        case x' of (f, x) \\<Rightarrow> \\<not> x; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); NFlow c s t x1;\n        NPreflow.isAugmentingPath c s t x1 x'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. NPreflow.isAugmentingPath c s t x1a x\n 4. \\<And>x x' x1 x2 x1a x2a xa.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, x) \\<Rightarrow> \\<not> x;\n        case x' of (f, x) \\<Rightarrow> \\<not> x; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a); NFlow c s t x1;\n        NPreflow.isAugmentingPath c s t x1a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            (xa, x')\n                            \\<in> \\<langle>nat_rel \\<times>\\<^sub>r\n     nat_rel\\<rangle>list_rel \\<and>\n                            NPreflow.isAugmentingPath c s t x1 x'\n 5. \\<And>x x' x1 x2 x1a x2a xa x'a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, x) \\<Rightarrow> \\<not> x;\n        case x' of (f, x) \\<Rightarrow> \\<not> x; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, x'a)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        xa = None; x'a = None\\<rbrakk>\n       \\<Longrightarrow> ((x1a, True), x1, True)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 6. \\<And>x x' x1 x2 x1a x2a xa x'a xb x'b.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel;\n        case x of (f, x) \\<Rightarrow> \\<not> x;\n        case x' of (f, x) \\<Rightarrow> \\<not> x; fofu_invar x';\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, x'a)\n        \\<in> \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                nat_rel\\<rangle>list_rel\\<rangle>option_rel;\n        xa = Some xb; x'a = Some x'b;\n        (xb, x'b)\n        \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel;\n        x'b \\<noteq> []; NPreflow.isAugmentingPath c s t x1 x'b;\n        NFlow c s t (NFlow.augment_with_path c x1 x'b)\\<rbrakk>\n       \\<Longrightarrow> ((NFlow.augment_with_path c x1a xb, False),\n                          NFlow.augment_with_path c x1 x'b, False)\n                         \\<in> Id \\<times>\\<^sub>r bool_rel\n 7. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r bool_rel; x' = (x1, x2);\n        x = (x1a, x2a); NFlow c s t x1\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> Id", "apply (vc_solve simp: NFlow.augment_with_path_def solve: exI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ford_fulkerson_method \\<le> fofu\n\ngoal (1 subgoal):\n 1. ford_fulkerson_method \\<le> SPEC isMaxFlow", "also"], ["proof (state)\nthis:\n  ford_fulkerson_method \\<le> fofu\n\ngoal (1 subgoal):\n 1. ford_fulkerson_method \\<le> SPEC isMaxFlow", "note fofu_partial_correct"], ["proof (state)\nthis:\n  fofu \\<le> SPEC isMaxFlow\n\ngoal (1 subgoal):\n 1. ford_fulkerson_method \\<le> SPEC isMaxFlow", "finally"], ["proof (chain)\npicking this:\n  ford_fulkerson_method \\<le> SPEC isMaxFlow", "show ?thesis"], ["proof (prove)\nusing this:\n  ford_fulkerson_method \\<le> SPEC isMaxFlow\n\ngoal (1 subgoal):\n 1. ford_fulkerson_method \\<le> SPEC isMaxFlow", "."], ["proof (state)\nthis:\n  ford_fulkerson_method \\<le> SPEC isMaxFlow\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Theory\\<close>"]]}