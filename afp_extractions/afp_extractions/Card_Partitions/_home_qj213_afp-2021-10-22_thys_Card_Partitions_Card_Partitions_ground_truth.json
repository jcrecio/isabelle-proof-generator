{"file_name": "/home/qj213/afp-2021-10-22/thys/Card_Partitions/Card_Partitions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Card_Partitions", "problem_names": ["lemma set_partition_on_insert_with_fixed_card_eq:\n  assumes \"finite A\"\n  assumes \"a \\<notin> A\"\n  shows \"{P. partition_on (insert a A) P \\<and> card P = Suc k} = (do {\n     P <- {P. partition_on A P \\<and> card P = Suc k};\n     p <- P;\n     {insert (insert a p) (P - {p})}\n  })\n  \\<union> (do {\n    P <- {P. partition_on A P \\<and> card P = k};\n    {insert {a} P}\n  })\" (is \"?S = ?T\")", "lemma injectivity_subexpr1:\n  assumes \"a \\<notin> A\"\n  assumes \"X \\<in> P \\<and> X' \\<in> P'\"\n  assumes \"insert (insert a X) (P - {X}) = insert (insert a X') (P' - {X'})\"\n  assumes \"(partition_on A P \\<and> card P = Suc k') \\<and> (partition_on A P' \\<and> card P' = Suc k')\"\n  shows \"P = P'\" and \"X = X'\"", "lemma injectivity_subexpr2:\n  assumes \"a \\<notin> A\"\n  assumes \"insert {a} P = insert {a} P'\"\n  assumes \"(partition_on A P \\<and> card P = k') \\<and> partition_on A P' \\<and> card P' = k'\"\n  shows \"P = P'\"", "theorem card_partition_on:\n  assumes \"finite A\"\n  shows \"card {P. partition_on A P \\<and> card P = k} = Stirling (card A) k\"", "theorem card_partition_on_at_most_size:\n  assumes \"finite A\"\n  shows \"card {P. partition_on A P \\<and> card P \\<le> k} = (\\<Sum>j\\<le>k. Stirling (card A) j)\"", "theorem partition_on_size1:\n  assumes \"finite A\"\n  shows \"{P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)} = {(\\<lambda>a. {a}) ` A}\"", "theorem card_partition_on_size1:\n  assumes \"finite A\"\n  shows \"card {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)} = 1\"", "lemma card_partition_on_size1_eq_1:\n  assumes \"finite A\"\n  assumes \"card A \\<le> k\"\n  shows \"card {P. partition_on A P \\<and> card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} = 1\"", "lemma card_partition_on_size1_eq_0:\n  assumes \"finite A\"\n  assumes \"k < card A\"\n  shows \"card {P. partition_on A P \\<and> card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} = 0\""], "translations": [["", "lemma set_partition_on_insert_with_fixed_card_eq:\n  assumes \"finite A\"\n  assumes \"a \\<notin> A\"\n  shows \"{P. partition_on (insert a A) P \\<and> card P = Suc k} = (do {\n     P <- {P. partition_on A P \\<and> card P = Suc k};\n     p <- P;\n     {insert (insert a p) (P - {p})}\n  })\n  \\<union> (do {\n    P <- {P. partition_on A P \\<and> card P = k};\n    {insert {a} P}\n  })\" (is \"?S = ?T\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {P. partition_on (insert a A) P \\<and> card P = Suc k} =\n    ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n    ({P. partition_on A P \\<and> card P = k} \\<bind>\n     (\\<lambda>P. {insert {a} P}))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {P. partition_on (insert a A) P \\<and> card P = Suc k}\n    \\<subseteq> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n                 (\\<lambda>P.\n                     P \\<bind>\n                     (\\<lambda>p.\n                         {insert (insert a p) (P - {p})}))) \\<union>\n                ({P. partition_on A P \\<and> card P = k} \\<bind>\n                 (\\<lambda>P. {insert {a} P}))\n 2. ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n    ({P. partition_on A P \\<and> card P = k} \\<bind>\n     (\\<lambda>P. {insert {a} P}))\n    \\<subseteq> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "show \"?S \\<subseteq> ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P. partition_on (insert a A) P \\<and> card P = Suc k}\n    \\<subseteq> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n                 (\\<lambda>P.\n                     P \\<bind>\n                     (\\<lambda>p.\n                         {insert (insert a p) (P - {p})}))) \\<union>\n                ({P. partition_on A P \\<and> card P = k} \\<bind>\n                 (\\<lambda>P. {insert {a} P}))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {P. partition_on (insert a A) P \\<and>\n                   card P = Suc k} \\<Longrightarrow>\n       x \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n                (\\<lambda>P.\n                    P \\<bind>\n                    (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n               ({P. partition_on A P \\<and> card P = k} \\<bind>\n                (\\<lambda>P. {insert {a} P}))", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {P. partition_on (insert a A) P \\<and>\n                   card P = Suc k} \\<Longrightarrow>\n       x \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n                (\\<lambda>P.\n                    P \\<bind>\n                    (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n               ({P. partition_on A P \\<and> card P = k} \\<bind>\n                (\\<lambda>P. {insert {a} P}))", "assume \"P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\""], ["proof (state)\nthis:\n  P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {P. partition_on (insert a A) P \\<and>\n                   card P = Suc k} \\<Longrightarrow>\n       x \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n                (\\<lambda>P.\n                    P \\<bind>\n                    (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n               ({P. partition_on A P \\<and> card P = k} \\<bind>\n                (\\<lambda>P. {insert {a} P}))", "from this"], ["proof (chain)\npicking this:\n  P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "have \"partition_on (insert a A) P\" and \"card P = Suc k\""], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n\ngoal (1 subgoal):\n 1. partition_on (insert a A) P &&& card P = Suc k", "by auto"], ["proof (state)\nthis:\n  partition_on (insert a A) P\n  card P = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {P. partition_on (insert a A) P \\<and>\n                   card P = Suc k} \\<Longrightarrow>\n       x \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n                (\\<lambda>P.\n                    P \\<bind>\n                    (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n               ({P. partition_on A P \\<and> card P = k} \\<bind>\n                (\\<lambda>P. {insert {a} P}))", "show \"P \\<in> ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "assume \"{a} \\<in> P\""], ["proof (state)\nthis:\n  {a} \\<in> P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "have \"partition_on A (P - {{a}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on A (P - {{a}})", "using \\<open>{a} \\<in> P\\<close> \\<open>partition_on (insert a A) P\\<close>[THEN partition_on_Diff, of \"{{a}}\"] \\<open>a \\<notin> A\\<close>"], ["proof (prove)\nusing this:\n  {a} \\<in> P\n  {{a}} \\<subseteq> P \\<Longrightarrow>\n  partition_on (insert a A - \\<Union> {{a}}) (P - {{a}})\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. partition_on A (P - {{a}})", "by auto"], ["proof (state)\nthis:\n  partition_on A (P - {{a}})\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "moreover"], ["proof (state)\nthis:\n  partition_on A (P - {{a}})\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "from \\<open>{a} \\<in> P\\<close> \\<open>card P = Suc k\\<close>"], ["proof (chain)\npicking this:\n  {a} \\<in> P\n  card P = Suc k", "have \"card (P - {{a}}) = k\""], ["proof (prove)\nusing this:\n  {a} \\<in> P\n  card P = Suc k\n\ngoal (1 subgoal):\n 1. card (P - {{a}}) = k", "by (subst card_Diff_singleton) (auto intro: card_ge_0_finite)"], ["proof (state)\nthis:\n  card (P - {{a}}) = k\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "moreover"], ["proof (state)\nthis:\n  card (P - {{a}}) = k\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "from \\<open>{a} \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  {a} \\<in> P", "have \"P = insert {a} (P - {{a}})\""], ["proof (prove)\nusing this:\n  {a} \\<in> P\n\ngoal (1 subgoal):\n 1. P = insert {a} (P - {{a}})", "by auto"], ["proof (state)\nthis:\n  P = insert {a} (P - {{a}})\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "ultimately"], ["proof (chain)\npicking this:\n  partition_on A (P - {{a}})\n  card (P - {{a}}) = k\n  P = insert {a} (P - {{a}})", "have \"P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind> (\\<lambda>P. {insert {a} P})\""], ["proof (prove)\nusing this:\n  partition_on A (P - {{a}})\n  card (P - {{a}}) = k\n  P = insert {a} (P - {{a}})\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P})", "by auto"], ["proof (state)\nthis:\n  P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n          (\\<lambda>P. {insert {a} P})\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))\n 2. \\<not> ?P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "from this"], ["proof (chain)\npicking this:\n  P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n          (\\<lambda>P. {insert {a} P})", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n          (\\<lambda>P. {insert {a} P})\n\ngoal (1 subgoal):\n 1. P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "by auto"], ["proof (state)\nthis:\n  P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n           (\\<lambda>P.\n               P \\<bind>\n               (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n          ({P. partition_on A P \\<and> card P = k} \\<bind>\n           (\\<lambda>P. {insert {a} P}))\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "assume \"{a} \\<notin> P\""], ["proof (state)\nthis:\n  {a} \\<notin> P\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "let ?p' = \"(THE X. a \\<in> X \\<and> X \\<in> P)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "let ?p = \"(THE X. a \\<in> X \\<and> X \\<in> P) - {a}\""], ["proof (state)\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "let ?P' = \"insert ?p (P - {?p'})\""], ["proof (state)\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "from \\<open>partition_on (insert a A) P\\<close>"], ["proof (chain)\npicking this:\n  partition_on (insert a A) P", "have \"a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)\""], ["proof (prove)\nusing this:\n  partition_on (insert a A) P\n\ngoal (1 subgoal):\n 1. a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)", "using partition_on_in_the_unique_part"], ["proof (prove)\nusing this:\n  partition_on (insert a A) P\n  \\<lbrakk>partition_on ?A ?P; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> (THE X. ?x \\<in> X \\<and> X \\<in> ?P)\n\ngoal (1 subgoal):\n 1. a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)", "by fastforce"], ["proof (state)\nthis:\n  a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "from \\<open>partition_on (insert a A) P\\<close>"], ["proof (chain)\npicking this:\n  partition_on (insert a A) P", "have \"(THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\""], ["proof (prove)\nusing this:\n  partition_on (insert a A) P\n\ngoal (1 subgoal):\n 1. (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P", "using partition_on_the_part_mem"], ["proof (prove)\nusing this:\n  partition_on (insert a A) P\n  \\<lbrakk>partition_on ?A ?P; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (THE X. ?x \\<in> X \\<and> X \\<in> ?P) \\<in> ?P\n\ngoal (1 subgoal):\n 1. (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P", "by fastforce"], ["proof (state)\nthis:\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "from this \\<open>partition_on (insert a A) P\\<close>"], ["proof (chain)\npicking this:\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n  partition_on (insert a A) P", "have \"(THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P\""], ["proof (prove)\nusing this:\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n  partition_on (insert a A) P\n\ngoal (1 subgoal):\n 1. (THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P", "using partition_subset_imp_notin \\<open>a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)\\<close>"], ["proof (prove)\nusing this:\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n  partition_on (insert a A) P\n  \\<lbrakk>partition_on ?A ?P; ?X \\<in> ?P; ?X' \\<subset> ?X\\<rbrakk>\n  \\<Longrightarrow> ?X' \\<notin> ?P\n  a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)\n\ngoal (1 subgoal):\n 1. (THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P", "by blast"], ["proof (state)\nthis:\n  (THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "have \"(THE X. a \\<in> X \\<and> X \\<in> P) \\<noteq> {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE X. a \\<in> X \\<and> X \\<in> P) \\<noteq> {a}", "using \\<open>(THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\\<close> \\<open>{a} \\<notin> P\\<close>"], ["proof (prove)\nusing this:\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n  {a} \\<notin> P\n\ngoal (1 subgoal):\n 1. (THE X. a \\<in> X \\<and> X \\<in> P) \\<noteq> {a}", "by auto"], ["proof (state)\nthis:\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<noteq> {a}\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "from \\<open>partition_on (insert a A) P\\<close>"], ["proof (chain)\npicking this:\n  partition_on (insert a A) P", "have \"(THE X. a \\<in> X \\<and> X \\<in> P) \\<subseteq> insert a A\""], ["proof (prove)\nusing this:\n  partition_on (insert a A) P\n\ngoal (1 subgoal):\n 1. (THE X. a \\<in> X \\<and> X \\<in> P) \\<subseteq> insert a A", "using \\<open>(THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\\<close> partition_onD1"], ["proof (prove)\nusing this:\n  partition_on (insert a A) P\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n  partition_on ?A ?P \\<Longrightarrow> ?A = \\<Union> ?P\n\ngoal (1 subgoal):\n 1. (THE X. a \\<in> X \\<and> X \\<in> P) \\<subseteq> insert a A", "by fastforce"], ["proof (state)\nthis:\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<subseteq> insert a A\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "note facts_on_the_part_of = \\<open>a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)\\<close> \\<open>(THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\\<close>\n        \\<open>(THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P\\<close> \\<open>(THE X. a \\<in> X \\<and> X \\<in> P) \\<noteq> {a}\\<close>\n        \\<open>(THE X. a \\<in> X \\<and> X \\<in> P) \\<subseteq> insert a A\\<close>"], ["proof (state)\nthis:\n  a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n  (THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<noteq> {a}\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<subseteq> insert a A\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "from \\<open>partition_on (insert a A) P\\<close> \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  partition_on (insert a A) P\n  finite A", "have \"finite P\""], ["proof (prove)\nusing this:\n  partition_on (insert a A) P\n  finite A\n\ngoal (1 subgoal):\n 1. finite P", "by (meson finite.insertI finite_elements)"], ["proof (state)\nthis:\n  finite P\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "from \\<open>partition_on (insert a A) P\\<close> \\<open>a \\<notin> A\\<close>"], ["proof (chain)\npicking this:\n  partition_on (insert a A) P\n  a \\<notin> A", "have \"partition_on (A - ?p) (P - {?p'})\""], ["proof (prove)\nusing this:\n  partition_on (insert a A) P\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. partition_on (A - ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P})", "using facts_on_the_part_of"], ["proof (prove)\nusing this:\n  partition_on (insert a A) P\n  a \\<notin> A\n  a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n  (THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<noteq> {a}\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<subseteq> insert a A\n\ngoal (1 subgoal):\n 1. partition_on (A - ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P})", "by (auto intro: partition_on_remove_singleton)"], ["proof (state)\nthis:\n  partition_on (A - ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n   (P - {THE X. a \\<in> X \\<and> X \\<in> P})\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "from this"], ["proof (chain)\npicking this:\n  partition_on (A - ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n   (P - {THE X. a \\<in> X \\<and> X \\<in> P})", "have \"partition_on A ?P'\""], ["proof (prove)\nusing this:\n  partition_on (A - ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n   (P - {THE X. a \\<in> X \\<and> X \\<in> P})\n\ngoal (1 subgoal):\n 1. partition_on A\n     (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n       (P - {THE X. a \\<in> X \\<and> X \\<in> P}))", "using facts_on_the_part_of"], ["proof (prove)\nusing this:\n  partition_on (A - ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n   (P - {THE X. a \\<in> X \\<and> X \\<in> P})\n  a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n  (THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<noteq> {a}\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<subseteq> insert a A\n\ngoal (1 subgoal):\n 1. partition_on A\n     (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n       (P - {THE X. a \\<in> X \\<and> X \\<in> P}))", "by (auto intro: partition_on_insert simp add: disjnt_iff)"], ["proof (state)\nthis:\n  partition_on A\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P}))\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "moreover"], ["proof (state)\nthis:\n  partition_on A\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P}))\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "have \"card ?P' = Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n       (P - {THE X. a \\<in> X \\<and> X \\<in> P})) =\n    Suc k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n       (P - {THE X. a \\<in> X \\<and> X \\<in> P})) =\n    Suc k", "from \\<open>card P = Suc k\\<close>"], ["proof (chain)\npicking this:\n  card P = Suc k", "have \"card (P - {THE X. a \\<in> X \\<and> X \\<in> P}) = k\""], ["proof (prove)\nusing this:\n  card P = Suc k\n\ngoal (1 subgoal):\n 1. card (P - {THE X. a \\<in> X \\<and> X \\<in> P}) = k", "using \\<open>finite P\\<close> \\<open>(THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\\<close>"], ["proof (prove)\nusing this:\n  card P = Suc k\n  finite P\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n\ngoal (1 subgoal):\n 1. card (P - {THE X. a \\<in> X \\<and> X \\<in> P}) = k", "by simp"], ["proof (state)\nthis:\n  card (P - {THE X. a \\<in> X \\<and> X \\<in> P}) = k\n\ngoal (1 subgoal):\n 1. card\n     (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n       (P - {THE X. a \\<in> X \\<and> X \\<in> P})) =\n    Suc k", "from this"], ["proof (chain)\npicking this:\n  card (P - {THE X. a \\<in> X \\<and> X \\<in> P}) = k", "show ?thesis"], ["proof (prove)\nusing this:\n  card (P - {THE X. a \\<in> X \\<and> X \\<in> P}) = k\n\ngoal (1 subgoal):\n 1. card\n     (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n       (P - {THE X. a \\<in> X \\<and> X \\<in> P})) =\n    Suc k", "using \\<open>finite P\\<close> \\<open>(THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P\\<close>"], ["proof (prove)\nusing this:\n  card (P - {THE X. a \\<in> X \\<and> X \\<in> P}) = k\n  finite P\n  (THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P\n\ngoal (1 subgoal):\n 1. card\n     (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n       (P - {THE X. a \\<in> X \\<and> X \\<in> P})) =\n    Suc k", "by (simp add: card_insert_if)"], ["proof (state)\nthis:\n  card\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P})) =\n  Suc k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P})) =\n  Suc k\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "moreover"], ["proof (state)\nthis:\n  card\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P})) =\n  Suc k\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "have \"?p \\<in> ?P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE X. a \\<in> X \\<and> X \\<in> P) - {a}\n    \\<in> insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n           (P - {THE X. a \\<in> X \\<and> X \\<in> P})", "by auto"], ["proof (state)\nthis:\n  (THE X. a \\<in> X \\<and> X \\<in> P) - {a}\n  \\<in> insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n         (P - {THE X. a \\<in> X \\<and> X \\<in> P})\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "moreover"], ["proof (state)\nthis:\n  (THE X. a \\<in> X \\<and> X \\<in> P) - {a}\n  \\<in> insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n         (P - {THE X. a \\<in> X \\<and> X \\<in> P})\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "have \"P = insert (insert a ?p) (?P' - {?p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P =\n    insert (insert a ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n     (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n       (P - {THE X. a \\<in> X \\<and> X \\<in> P}) -\n      {(THE X. a \\<in> X \\<and> X \\<in> P) - {a}})", "using facts_on_the_part_of"], ["proof (prove)\nusing this:\n  a \\<in> (THE X. a \\<in> X \\<and> X \\<in> P)\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<in> P\n  (THE X. a \\<in> X \\<and> X \\<in> P) - {a} \\<notin> P\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<noteq> {a}\n  (THE X. a \\<in> X \\<and> X \\<in> P) \\<subseteq> insert a A\n\ngoal (1 subgoal):\n 1. P =\n    insert (insert a ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n     (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n       (P - {THE X. a \\<in> X \\<and> X \\<in> P}) -\n      {(THE X. a \\<in> X \\<and> X \\<in> P) - {a}})", "by (auto simp add: insert_absorb)"], ["proof (state)\nthis:\n  P =\n  insert (insert a ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P}) -\n    {(THE X. a \\<in> X \\<and> X \\<in> P) - {a}})\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "ultimately"], ["proof (chain)\npicking this:\n  partition_on A\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P}))\n  card\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P})) =\n  Suc k\n  (THE X. a \\<in> X \\<and> X \\<in> P) - {a}\n  \\<in> insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n         (P - {THE X. a \\<in> X \\<and> X \\<in> P})\n  P =\n  insert (insert a ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P}) -\n    {(THE X. a \\<in> X \\<and> X \\<in> P) - {a}})", "have \"P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind> (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))\""], ["proof (prove)\nusing this:\n  partition_on A\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P}))\n  card\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P})) =\n  Suc k\n  (THE X. a \\<in> X \\<and> X \\<in> P) - {a}\n  \\<in> insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n         (P - {THE X. a \\<in> X \\<and> X \\<in> P})\n  P =\n  insert (insert a ((THE X. a \\<in> X \\<and> X \\<in> P) - {a}))\n   (insert ((THE X. a \\<in> X \\<and> X \\<in> P) - {a})\n     (P - {THE X. a \\<in> X \\<and> X \\<in> P}) -\n    {(THE X. a \\<in> X \\<and> X \\<in> P) - {a}})\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n            (\\<lambda>P.\n                P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))", "by auto"], ["proof (state)\nthis:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n          (\\<lambda>P.\n              P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P \\<Longrightarrow>\n    P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "then"], ["proof (chain)\npicking this:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n          (\\<lambda>P.\n              P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n          (\\<lambda>P.\n              P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))\n\ngoal (1 subgoal):\n 1. P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n             (\\<lambda>P.\n                 P \\<bind>\n                 (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n            ({P. partition_on A P \\<and> card P = k} \\<bind>\n             (\\<lambda>P. {insert {a} P}))", "by auto"], ["proof (state)\nthis:\n  P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n           (\\<lambda>P.\n               P \\<bind>\n               (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n          ({P. partition_on A P \\<and> card P = k} \\<bind>\n           (\\<lambda>P. {insert {a} P}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n           (\\<lambda>P.\n               P \\<bind>\n               (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n          ({P. partition_on A P \\<and> card P = k} \\<bind>\n           (\\<lambda>P. {insert {a} P}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {P. partition_on (insert a A) P \\<and> card P = Suc k}\n  \\<subseteq> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n               (\\<lambda>P.\n                   P \\<bind>\n                   (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n              ({P. partition_on A P \\<and> card P = k} \\<bind>\n               (\\<lambda>P. {insert {a} P}))\n\ngoal (1 subgoal):\n 1. ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n    ({P. partition_on A P \\<and> card P = k} \\<bind>\n     (\\<lambda>P. {insert {a} P}))\n    \\<subseteq> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n    ({P. partition_on A P \\<and> card P = k} \\<bind>\n     (\\<lambda>P. {insert {a} P}))\n    \\<subseteq> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "show \"?T \\<subseteq> ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n    ({P. partition_on A P \\<and> card P = k} \\<bind>\n     (\\<lambda>P. {insert {a} P}))\n    \\<subseteq> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n                (\\<lambda>P.\n                    P \\<bind>\n                    (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n               ({P. partition_on A P \\<and> card P = k} \\<bind>\n                (\\<lambda>P. {insert {a} P})) \\<Longrightarrow>\n       x \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n                (\\<lambda>P.\n                    P \\<bind>\n                    (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n               ({P. partition_on A P \\<and> card P = k} \\<bind>\n                (\\<lambda>P. {insert {a} P})) \\<Longrightarrow>\n       x \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "assume \"P \\<in> ?T\" (is \"_ \\<in> ?subexpr1 \\<union> ?subexpr2\")"], ["proof (state)\nthis:\n  P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n           (\\<lambda>P.\n               P \\<bind>\n               (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n          ({P. partition_on A P \\<and> card P = k} \\<bind>\n           (\\<lambda>P. {insert {a} P}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n                (\\<lambda>P.\n                    P \\<bind>\n                    (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n               ({P. partition_on A P \\<and> card P = k} \\<bind>\n                (\\<lambda>P. {insert {a} P})) \\<Longrightarrow>\n       x \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from this"], ["proof (chain)\npicking this:\n  P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n           (\\<lambda>P.\n               P \\<bind>\n               (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n          ({P. partition_on A P \\<and> card P = k} \\<bind>\n           (\\<lambda>P. {insert {a} P}))", "show \"P \\<in> ?S\""], ["proof (prove)\nusing this:\n  P \\<in> ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n           (\\<lambda>P.\n               P \\<bind>\n               (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n          ({P. partition_on A P \\<and> card P = k} \\<bind>\n           (\\<lambda>P. {insert {a} P}))\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n            (\\<lambda>P.\n                P \\<bind>\n                (\\<lambda>p.\n                    {insert (insert a p) (P - {p})})) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n 2. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "assume \"P \\<in> ?subexpr1\""], ["proof (state)\nthis:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n          (\\<lambda>P.\n              P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))\n\ngoal (2 subgoals):\n 1. P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n            (\\<lambda>P.\n                P \\<bind>\n                (\\<lambda>p.\n                    {insert (insert a p) (P - {p})})) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n 2. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from this"], ["proof (chain)\npicking this:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n          (\\<lambda>P.\n              P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))", "obtain p P' where \"P = insert (insert a p) (P' - {p})\"\n        and \"partition_on A P'\" and \"card P' = Suc k\" and \"p \\<in> P'\""], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n          (\\<lambda>P.\n              P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))\n\ngoal (1 subgoal):\n 1. (\\<And>p P'.\n        \\<lbrakk>P = insert (insert a p) (P' - {p}); partition_on A P';\n         card P' = Suc k; p \\<in> P'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P = insert (insert a p) (P' - {p})\n  partition_on A P'\n  card P' = Suc k\n  p \\<in> P'\n\ngoal (2 subgoals):\n 1. P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n            (\\<lambda>P.\n                P \\<bind>\n                (\\<lambda>p.\n                    {insert (insert a p) (P - {p})})) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n 2. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from \\<open>p \\<in> P'\\<close> \\<open>partition_on A P'\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> P'\n  partition_on A P'", "have \"partition_on (A - p) (P' - {p})\""], ["proof (prove)\nusing this:\n  p \\<in> P'\n  partition_on A P'\n\ngoal (1 subgoal):\n 1. partition_on (A - p) (P' - {p})", "by (simp add: partition_on_remove_singleton)"], ["proof (state)\nthis:\n  partition_on (A - p) (P' - {p})\n\ngoal (2 subgoals):\n 1. P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n            (\\<lambda>P.\n                P \\<bind>\n                (\\<lambda>p.\n                    {insert (insert a p) (P - {p})})) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n 2. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from \\<open>partition_on A P'\\<close> \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  partition_on A P'\n  finite A", "have \"finite P\""], ["proof (prove)\nusing this:\n  partition_on A P'\n  finite A\n\ngoal (1 subgoal):\n 1. finite P", "using \\<open>P = _\\<close> finite_elements"], ["proof (prove)\nusing this:\n  partition_on A P'\n  finite A\n  P = insert (insert a p) (P' - {p})\n  \\<lbrakk>finite ?A; partition_on ?A ?P\\<rbrakk>\n  \\<Longrightarrow> finite ?P\n\ngoal (1 subgoal):\n 1. finite P", "by auto"], ["proof (state)\nthis:\n  finite P\n\ngoal (2 subgoals):\n 1. P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n            (\\<lambda>P.\n                P \\<bind>\n                (\\<lambda>p.\n                    {insert (insert a p) (P - {p})})) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n 2. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from \\<open>partition_on A P'\\<close> \\<open>a \\<notin> A\\<close>"], ["proof (chain)\npicking this:\n  partition_on A P'\n  a \\<notin> A", "have \"insert a p \\<notin> P' - {p}\""], ["proof (prove)\nusing this:\n  partition_on A P'\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. insert a p \\<notin> P' - {p}", "using partition_onD1"], ["proof (prove)\nusing this:\n  partition_on A P'\n  a \\<notin> A\n  partition_on ?A ?P \\<Longrightarrow> ?A = \\<Union> ?P\n\ngoal (1 subgoal):\n 1. insert a p \\<notin> P' - {p}", "by fastforce"], ["proof (state)\nthis:\n  insert a p \\<notin> P' - {p}\n\ngoal (2 subgoals):\n 1. P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n            (\\<lambda>P.\n                P \\<bind>\n                (\\<lambda>p.\n                    {insert (insert a p) (P - {p})})) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n 2. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from \\<open>P = _\\<close> this \\<open>card P' = Suc k\\<close> \\<open>finite P\\<close> \\<open>p \\<in> P'\\<close>"], ["proof (chain)\npicking this:\n  P = insert (insert a p) (P' - {p})\n  insert a p \\<notin> P' - {p}\n  card P' = Suc k\n  finite P\n  p \\<in> P'", "have \"card P = Suc k\""], ["proof (prove)\nusing this:\n  P = insert (insert a p) (P' - {p})\n  insert a p \\<notin> P' - {p}\n  card P' = Suc k\n  finite P\n  p \\<in> P'\n\ngoal (1 subgoal):\n 1. card P = Suc k", "by auto"], ["proof (state)\nthis:\n  card P = Suc k\n\ngoal (2 subgoals):\n 1. P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n            (\\<lambda>P.\n                P \\<bind>\n                (\\<lambda>p.\n                    {insert (insert a p) (P - {p})})) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n 2. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "moreover"], ["proof (state)\nthis:\n  card P = Suc k\n\ngoal (2 subgoals):\n 1. P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n            (\\<lambda>P.\n                P \\<bind>\n                (\\<lambda>p.\n                    {insert (insert a p) (P - {p})})) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n 2. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "have \"partition_on (insert a A) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partition_on (insert a A) P", "using \\<open>partition_on (A - p) (P' - {p})\\<close> \\<open>a \\<notin> A\\<close> \\<open>p \\<in> P'\\<close> \\<open>partition_on A P'\\<close> \\<open>P = _\\<close>"], ["proof (prove)\nusing this:\n  partition_on (A - p) (P' - {p})\n  a \\<notin> A\n  p \\<in> P'\n  partition_on A P'\n  P = insert (insert a p) (P' - {p})\n\ngoal (1 subgoal):\n 1. partition_on (insert a A) P", "by (auto intro!: partition_on_insert dest: partition_onD1 simp add: disjnt_iff)"], ["proof (state)\nthis:\n  partition_on (insert a A) P\n\ngoal (2 subgoals):\n 1. P \\<in> {P. partition_on A P \\<and> card P = Suc k} \\<bind>\n            (\\<lambda>P.\n                P \\<bind>\n                (\\<lambda>p.\n                    {insert (insert a p) (P - {p})})) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n 2. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "ultimately"], ["proof (chain)\npicking this:\n  card P = Suc k\n  partition_on (insert a A) P", "show \"P \\<in> ?S\""], ["proof (prove)\nusing this:\n  card P = Suc k\n  partition_on (insert a A) P\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "by auto"], ["proof (state)\nthis:\n  P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "assume \"P \\<in> ?subexpr2\""], ["proof (state)\nthis:\n  P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n          (\\<lambda>P. {insert {a} P})\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from this"], ["proof (chain)\npicking this:\n  P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n          (\\<lambda>P. {insert {a} P})", "obtain P' where \"P = insert {a} P'\" and \"partition_on A P'\" and \"card P' = k\""], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n          (\\<lambda>P. {insert {a} P})\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>P = insert {a} P'; partition_on A P'; card P' = k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P = insert {a} P'\n  partition_on A P'\n  card P' = k\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from \\<open>partition_on A P'\\<close> \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  partition_on A P'\n  finite A", "have \"finite P\""], ["proof (prove)\nusing this:\n  partition_on A P'\n  finite A\n\ngoal (1 subgoal):\n 1. finite P", "using \\<open>P = insert {a} P'\\<close> finite_elements"], ["proof (prove)\nusing this:\n  partition_on A P'\n  finite A\n  P = insert {a} P'\n  \\<lbrakk>finite ?A; partition_on ?A ?P\\<rbrakk>\n  \\<Longrightarrow> finite ?P\n\ngoal (1 subgoal):\n 1. finite P", "by auto"], ["proof (state)\nthis:\n  finite P\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from \\<open>partition_on A P'\\<close> \\<open>a \\<notin> A\\<close>"], ["proof (chain)\npicking this:\n  partition_on A P'\n  a \\<notin> A", "have \"{a} \\<notin> P'\""], ["proof (prove)\nusing this:\n  partition_on A P'\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P'", "using partition_onD1"], ["proof (prove)\nusing this:\n  partition_on A P'\n  a \\<notin> A\n  partition_on ?A ?P \\<Longrightarrow> ?A = \\<Union> ?P\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P'", "by fastforce"], ["proof (state)\nthis:\n  {a} \\<notin> P'\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from \\<open>P = insert {a} P'\\<close> \\<open>card P' = k\\<close> this \\<open>finite P\\<close>"], ["proof (chain)\npicking this:\n  P = insert {a} P'\n  card P' = k\n  {a} \\<notin> P'\n  finite P", "have \"card P = Suc k\""], ["proof (prove)\nusing this:\n  P = insert {a} P'\n  card P' = k\n  {a} \\<notin> P'\n  finite P\n\ngoal (1 subgoal):\n 1. card P = Suc k", "by auto"], ["proof (state)\nthis:\n  card P = Suc k\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "moreover"], ["proof (state)\nthis:\n  card P = Suc k\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "from \\<open>partition_on A P'\\<close> \\<open>a \\<notin> A\\<close>"], ["proof (chain)\npicking this:\n  partition_on A P'\n  a \\<notin> A", "have \"partition_on (insert a A) P\""], ["proof (prove)\nusing this:\n  partition_on A P'\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. partition_on (insert a A) P", "using \\<open>P = insert {a} P'\\<close>"], ["proof (prove)\nusing this:\n  partition_on A P'\n  a \\<notin> A\n  P = insert {a} P'\n\ngoal (1 subgoal):\n 1. partition_on (insert a A) P", "by (simp add: partition_on_insert_singleton)"], ["proof (state)\nthis:\n  partition_on (insert a A) P\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> card P = k} \\<bind>\n            (\\<lambda>P. {insert {a} P}) \\<Longrightarrow>\n    P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "ultimately"], ["proof (chain)\npicking this:\n  card P = Suc k\n  partition_on (insert a A) P", "show \"P \\<in> ?S\""], ["proof (prove)\nusing this:\n  card P = Suc k\n  partition_on (insert a A) P\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}", "by auto"], ["proof (state)\nthis:\n  P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<in> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ({P. partition_on A P \\<and> card P = Suc k} \\<bind>\n   (\\<lambda>P.\n       P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n  ({P. partition_on A P \\<and> card P = k} \\<bind>\n   (\\<lambda>P. {insert {a} P}))\n  \\<subseteq> {P. partition_on (insert a A) P \\<and> card P = Suc k}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma injectivity_subexpr1:\n  assumes \"a \\<notin> A\"\n  assumes \"X \\<in> P \\<and> X' \\<in> P'\"\n  assumes \"insert (insert a X) (P - {X}) = insert (insert a X') (P' - {X'})\"\n  assumes \"(partition_on A P \\<and> card P = Suc k') \\<and> (partition_on A P' \\<and> card P' = Suc k')\"\n  shows \"P = P'\" and \"X = X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = P' &&& X = X'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. P = P'\n 2. X = X'", "from assms(1, 2, 4)"], ["proof (chain)\npicking this:\n  a \\<notin> A\n  X \\<in> P \\<and> X' \\<in> P'\n  (partition_on A P \\<and> card P = Suc k') \\<and>\n  partition_on A P' \\<and> card P' = Suc k'", "have \"a \\<notin> X\" \"a \\<notin> X'\""], ["proof (prove)\nusing this:\n  a \\<notin> A\n  X \\<in> P \\<and> X' \\<in> P'\n  (partition_on A P \\<and> card P = Suc k') \\<and>\n  partition_on A P' \\<and> card P' = Suc k'\n\ngoal (1 subgoal):\n 1. a \\<notin> X &&& a \\<notin> X'", "using partition_onD1"], ["proof (prove)\nusing this:\n  a \\<notin> A\n  X \\<in> P \\<and> X' \\<in> P'\n  (partition_on A P \\<and> card P = Suc k') \\<and>\n  partition_on A P' \\<and> card P' = Suc k'\n  partition_on ?A ?P \\<Longrightarrow> ?A = \\<Union> ?P\n\ngoal (1 subgoal):\n 1. a \\<notin> X &&& a \\<notin> X'", "by auto"], ["proof (state)\nthis:\n  a \\<notin> X\n  a \\<notin> X'\n\ngoal (2 subgoals):\n 1. P = P'\n 2. X = X'", "from assms(1, 4)"], ["proof (chain)\npicking this:\n  a \\<notin> A\n  (partition_on A P \\<and> card P = Suc k') \\<and>\n  partition_on A P' \\<and> card P' = Suc k'", "have \"insert a X \\<notin> P\" \"insert a X' \\<notin> P'\""], ["proof (prove)\nusing this:\n  a \\<notin> A\n  (partition_on A P \\<and> card P = Suc k') \\<and>\n  partition_on A P' \\<and> card P' = Suc k'\n\ngoal (1 subgoal):\n 1. insert a X \\<notin> P &&& insert a X' \\<notin> P'", "using partition_onD1"], ["proof (prove)\nusing this:\n  a \\<notin> A\n  (partition_on A P \\<and> card P = Suc k') \\<and>\n  partition_on A P' \\<and> card P' = Suc k'\n  partition_on ?A ?P \\<Longrightarrow> ?A = \\<Union> ?P\n\ngoal (1 subgoal):\n 1. insert a X \\<notin> P &&& insert a X' \\<notin> P'", "by auto"], ["proof (state)\nthis:\n  insert a X \\<notin> P\n  insert a X' \\<notin> P'\n\ngoal (2 subgoals):\n 1. P = P'\n 2. X = X'", "from assms(1, 3, 4)"], ["proof (chain)\npicking this:\n  a \\<notin> A\n  insert (insert a X) (P - {X}) = insert (insert a X') (P' - {X'})\n  (partition_on A P \\<and> card P = Suc k') \\<and>\n  partition_on A P' \\<and> card P' = Suc k'", "have \"insert a X = insert a X'\""], ["proof (prove)\nusing this:\n  a \\<notin> A\n  insert (insert a X) (P - {X}) = insert (insert a X') (P' - {X'})\n  (partition_on A P \\<and> card P = Suc k') \\<and>\n  partition_on A P' \\<and> card P' = Suc k'\n\ngoal (1 subgoal):\n 1. insert a X = insert a X'", "by (metis Diff_iff insertE insertI1 mem_simps(9) partition_onD1)"], ["proof (state)\nthis:\n  insert a X = insert a X'\n\ngoal (2 subgoals):\n 1. P = P'\n 2. X = X'", "from this \\<open>a \\<notin> X'\\<close> \\<open>a \\<notin> X\\<close>"], ["proof (chain)\npicking this:\n  insert a X = insert a X'\n  a \\<notin> X'\n  a \\<notin> X", "show \"X = X'\""], ["proof (prove)\nusing this:\n  insert a X = insert a X'\n  a \\<notin> X'\n  a \\<notin> X\n\ngoal (1 subgoal):\n 1. X = X'", "by (meson insert_ident)"], ["proof (state)\nthis:\n  X = X'\n\ngoal (1 subgoal):\n 1. P = P'", "from assms(2, 3)"], ["proof (chain)\npicking this:\n  X \\<in> P \\<and> X' \\<in> P'\n  insert (insert a X) (P - {X}) = insert (insert a X') (P' - {X'})", "show \"P = P'\""], ["proof (prove)\nusing this:\n  X \\<in> P \\<and> X' \\<in> P'\n  insert (insert a X) (P - {X}) = insert (insert a X') (P' - {X'})\n\ngoal (1 subgoal):\n 1. P = P'", "using \\<open>insert a X = insert a X'\\<close> \\<open>insert a X \\<notin> P\\<close> \\<open>insert a X' \\<notin> P'\\<close>"], ["proof (prove)\nusing this:\n  X \\<in> P \\<and> X' \\<in> P'\n  insert (insert a X) (P - {X}) = insert (insert a X') (P' - {X'})\n  insert a X = insert a X'\n  insert a X \\<notin> P\n  insert a X' \\<notin> P'\n\ngoal (1 subgoal):\n 1. P = P'", "by (metis insert_Diff insert_absorb insert_commute insert_ident)"], ["proof (state)\nthis:\n  P = P'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma injectivity_subexpr2:\n  assumes \"a \\<notin> A\"\n  assumes \"insert {a} P = insert {a} P'\"\n  assumes \"(partition_on A P \\<and> card P = k') \\<and> partition_on A P' \\<and> card P' = k'\"\n  shows \"P = P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = P'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P = P'", "from assms(1, 3)"], ["proof (chain)\npicking this:\n  a \\<notin> A\n  (partition_on A P \\<and> card P = k') \\<and>\n  partition_on A P' \\<and> card P' = k'", "have \"{a} \\<notin> P\" and \"{a} \\<notin> P'\""], ["proof (prove)\nusing this:\n  a \\<notin> A\n  (partition_on A P \\<and> card P = k') \\<and>\n  partition_on A P' \\<and> card P' = k'\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P &&& {a} \\<notin> P'", "using partition_onD1"], ["proof (prove)\nusing this:\n  a \\<notin> A\n  (partition_on A P \\<and> card P = k') \\<and>\n  partition_on A P' \\<and> card P' = k'\n  partition_on ?A ?P \\<Longrightarrow> ?A = \\<Union> ?P\n\ngoal (1 subgoal):\n 1. {a} \\<notin> P &&& {a} \\<notin> P'", "by auto"], ["proof (state)\nthis:\n  {a} \\<notin> P\n  {a} \\<notin> P'\n\ngoal (1 subgoal):\n 1. P = P'", "from \\<open>{a} \\<notin> P\\<close>"], ["proof (chain)\npicking this:\n  {a} \\<notin> P", "have \"P = insert {a} P - {{a}}\""], ["proof (prove)\nusing this:\n  {a} \\<notin> P\n\ngoal (1 subgoal):\n 1. P = insert {a} P - {{a}}", "by simp"], ["proof (state)\nthis:\n  P = insert {a} P - {{a}}\n\ngoal (1 subgoal):\n 1. P = P'", "also"], ["proof (state)\nthis:\n  P = insert {a} P - {{a}}\n\ngoal (1 subgoal):\n 1. P = P'", "from \\<open>insert {a} P = insert {a} P'\\<close>"], ["proof (chain)\npicking this:\n  insert {a} P = insert {a} P'", "have \"\\<dots> = insert {a} P' - {{a}}\""], ["proof (prove)\nusing this:\n  insert {a} P = insert {a} P'\n\ngoal (1 subgoal):\n 1. insert {a} P - {{a}} = insert {a} P' - {{a}}", "by simp"], ["proof (state)\nthis:\n  insert {a} P - {{a}} = insert {a} P' - {{a}}\n\ngoal (1 subgoal):\n 1. P = P'", "also"], ["proof (state)\nthis:\n  insert {a} P - {{a}} = insert {a} P' - {{a}}\n\ngoal (1 subgoal):\n 1. P = P'", "from \\<open>{a} \\<notin> P'\\<close>"], ["proof (chain)\npicking this:\n  {a} \\<notin> P'", "have \"\\<dots> = P'\""], ["proof (prove)\nusing this:\n  {a} \\<notin> P'\n\ngoal (1 subgoal):\n 1. insert {a} P' - {{a}} = P'", "by simp"], ["proof (state)\nthis:\n  insert {a} P' - {{a}} = P'\n\ngoal (1 subgoal):\n 1. P = P'", "finally"], ["proof (chain)\npicking this:\n  P = P'", "show ?thesis"], ["proof (prove)\nusing this:\n  P = P'\n\ngoal (1 subgoal):\n 1. P = P'", "."], ["proof (state)\nthis:\n  P = P'\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem card_partition_on:\n  assumes \"finite A\"\n  shows \"card {P. partition_on A P \\<and> card P = k} = Stirling (card A) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P = k} = Stirling (card A) k", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P = k} = Stirling (card A) k", "proof (induct A arbitrary: k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       card {P. partition_on {} P \\<and> card P = k} = Stirling (card {}) k\n 2. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           card {P. partition_on F P \\<and> card P = k} =\n           Stirling (card F) k\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert x F) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert x F)) k", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>k.\n       card {P. partition_on {} P \\<and> card P = k} = Stirling (card {}) k\n 2. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           card {P. partition_on F P \\<and> card P = k} =\n           Stirling (card F) k\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert x F) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert x F)) k", "have eq: \"{P. P = {} \\<and> card P = 0} = {{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P. P = {} \\<and> card P = 0} = {{}}", "by auto"], ["proof (state)\nthis:\n  {P. P = {} \\<and> card P = 0} = {{}}\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       card {P. partition_on {} P \\<and> card P = k} = Stirling (card {}) k\n 2. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           card {P. partition_on F P \\<and> card P = k} =\n           Stirling (card F) k\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert x F) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert x F)) k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {P. partition_on {} P \\<and> card P = k} = Stirling (card {}) k", "by (cases k) (auto simp add: partition_on_empty eq)"], ["proof (state)\nthis:\n  card {P. partition_on {} P \\<and> card P = k} = Stirling (card {}) k\n\ngoal (1 subgoal):\n 1. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           card {P. partition_on F P \\<and> card P = k} =\n           Stirling (card F) k\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert x F) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert x F)) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           card {P. partition_on F P \\<and> card P = k} =\n           Stirling (card F) k\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert x F) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert x F)) k", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  card {P. partition_on A P \\<and> card P = ?k} = Stirling (card A) ?k\n\ngoal (1 subgoal):\n 1. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           card {P. partition_on F P \\<and> card P = k} =\n           Stirling (card F) k\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert x F) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert x F)) k", "from this"], ["proof (chain)\npicking this:\n  finite A\n  a \\<notin> A\n  card {P. partition_on A P \\<and> card P = ?k} = Stirling (card A) ?k", "show ?case"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n  card {P. partition_on A P \\<and> card P = ?k} = Stirling (card A) ?k\n\ngoal (1 subgoal):\n 1. card {P. partition_on (insert a A) P \\<and> card P = k} =\n    Stirling (card (insert a A)) k", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; a \\<notin> A;\n     \\<And>k.\n        card {P. partition_on A P \\<and> card P = k} = Stirling (card A) k;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> card\n                       {P. partition_on (insert a A) P \\<and> card P = k} =\n                      Stirling (card (insert a A)) k\n 2. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; a \\<notin> A;\n     \\<And>k.\n        card {P. partition_on A P \\<and> card P = k} = Stirling (card A) k;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> card\n                       {P. partition_on (insert a A) P \\<and> card P = k} =\n                      Stirling (card (insert a A)) k\n 2. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "from insert(1)"], ["proof (chain)\npicking this:\n  finite A", "have empty: \"{P. partition_on (insert a A) P \\<and> card P = 0} = {}\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. {P. partition_on (insert a A) P \\<and> card P = 0} = {}", "unfolding partition_on_def"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. {P. (\\<Union> P = insert a A \\<and>\n         disjoint P \\<and> {} \\<notin> P) \\<and>\n        card P = 0} =\n    {}", "by (auto simp add: card_eq_0_iff finite_UnionD)"], ["proof (state)\nthis:\n  {P. partition_on (insert a A) P \\<and> card P = 0} = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; a \\<notin> A;\n     \\<And>k.\n        card {P. partition_on A P \\<and> card P = k} = Stirling (card A) k;\n     k = 0\\<rbrakk>\n    \\<Longrightarrow> card\n                       {P. partition_on (insert a A) P \\<and> card P = k} =\n                      Stirling (card (insert a A)) k\n 2. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "from 0 insert"], ["proof (chain)\npicking this:\n  k = 0\n  finite A\n  a \\<notin> A\n  card {P. partition_on A P \\<and> card P = ?k} = Stirling (card A) ?k", "show ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n  finite A\n  a \\<notin> A\n  card {P. partition_on A P \\<and> card P = ?k} = Stirling (card A) ?k\n\ngoal (1 subgoal):\n 1. card {P. partition_on (insert a A) P \\<and> card P = k} =\n    Stirling (card (insert a A)) k", "by (auto simp add: empty)"], ["proof (state)\nthis:\n  card {P. partition_on (insert a A) P \\<and> card P = k} =\n  Stirling (card (insert a A)) k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "case (Suc k')"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "let ?subexpr1 = \"do {\n      P <- {P. partition_on A P \\<and> card P = Suc k'};\n      p <- P;\n      {insert (insert a p) (P - {p})}\n    }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "let ?subexpr2 = \"do {\n      P <- {P. partition_on A P \\<and> card P = k'};\n      {insert {a} P}\n    }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "let ?expr = \"?subexpr1 \\<union> ?subexpr2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "have \"card {P. partition_on (insert a A) P \\<and> card P = k} = card ?expr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {P. partition_on (insert a A) P \\<and> card P = k} =\n    card\n     (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n       (\\<lambda>P.\n           P \\<bind>\n           (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n      ({P. partition_on A P \\<and> card P = k'} \\<bind>\n       (\\<lambda>P. {insert {a} P})))", "using \\<open>finite A\\<close> \\<open>a \\<notin> A\\<close> \\<open>k = Suc k'\\<close>"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. card {P. partition_on (insert a A) P \\<and> card P = k} =\n    card\n     (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n       (\\<lambda>P.\n           P \\<bind>\n           (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n      ({P. partition_on A P \\<and> card P = k'} \\<bind>\n       (\\<lambda>P. {insert {a} P})))", "by (simp add: set_partition_on_insert_with_fixed_card_eq)"], ["proof (state)\nthis:\n  card {P. partition_on (insert a A) P \\<and> card P = k} =\n  card\n   (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P})))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "also"], ["proof (state)\nthis:\n  card {P. partition_on (insert a A) P \\<and> card P = k} =\n  card\n   (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P})))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "have \"card ?expr = Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n       (\\<lambda>P.\n           P \\<bind>\n           (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n      ({P. partition_on A P \\<and> card P = k'} \\<bind>\n       (\\<lambda>P. {insert {a} P}))) =\n    Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n       (\\<lambda>P.\n           P \\<bind>\n           (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n      ({P. partition_on A P \\<and> card P = k'} \\<bind>\n       (\\<lambda>P. {insert {a} P}))) =\n    Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'", "have \"finite ?subexpr1 \\<and> card ?subexpr1 = Stirling (card A) (Suc k') * Suc k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "from \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  finite A", "have \"finite {P. partition_on A P \\<and> card P = Suc k'}\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite {P. partition_on A P \\<and> card P = Suc k'}", "by (simp add: finitely_many_partition_on)"], ["proof (state)\nthis:\n  finite {P. partition_on A P \\<and> card P = Suc k'}\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "moreover"], ["proof (state)\nthis:\n  finite {P. partition_on A P \\<and> card P = Suc k'}\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "have \"\\<forall>X\\<in>{P. partition_on A P \\<and> card P = Suc k'}. finite (X \\<bind> (\\<lambda>p. {insert (insert a p) (X - {p})}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{P. partition_on A P \\<and> card P = Suc k'}.\n       finite (X \\<bind> (\\<lambda>p. {insert (insert a p) (X - {p})}))", "using finite_elements \\<open>finite A\\<close> finite_bind"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; partition_on ?A ?P\\<rbrakk>\n  \\<Longrightarrow> finite ?P\n  finite A\n  \\<lbrakk>finite ?S; \\<forall>x\\<in>?S. finite (?f x)\\<rbrakk>\n  \\<Longrightarrow> finite (?S \\<bind> ?f)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{P. partition_on A P \\<and> card P = Suc k'}.\n       finite (X \\<bind> (\\<lambda>p. {insert (insert a p) (X - {p})}))", "by (metis (no_types, lifting) finite.emptyI finite_insert mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<forall>X\\<in>{P. partition_on A P \\<and> card P = Suc k'}.\n     finite (X \\<bind> (\\<lambda>p. {insert (insert a p) (X - {p})}))\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>{P. partition_on A P \\<and> card P = Suc k'}.\n     finite (X \\<bind> (\\<lambda>p. {insert (insert a p) (X - {p})}))\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "have \"disjoint_family_on (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) {P. partition_on A P \\<and> card P = Suc k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjoint_family_on\n     (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))\n     {P. partition_on A P \\<and> card P = Suc k'}", "by (injectivity_solver rule: injectivity_subexpr1(1)[OF \\<open>a \\<notin> A\\<close>])"], ["proof (state)\nthis:\n  disjoint_family_on\n   (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))\n   {P. partition_on A P \\<and> card P = Suc k'}\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "moreover"], ["proof (state)\nthis:\n  disjoint_family_on\n   (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))\n   {P. partition_on A P \\<and> card P = Suc k'}\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "have \"card (P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) = Suc k'\"\n          if \"P \\<in> {P. partition_on A P \\<and> card P = Suc k'}\" for P"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) = Suc k'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) = Suc k'", "from that \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k'}\n  finite A", "have \"finite P\""], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k'}\n  finite A\n\ngoal (1 subgoal):\n 1. finite P", "using finite_elements"], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k'}\n  finite A\n  \\<lbrakk>finite ?A; partition_on ?A ?P\\<rbrakk>\n  \\<Longrightarrow> finite ?P\n\ngoal (1 subgoal):\n 1. finite P", "by blast"], ["proof (state)\nthis:\n  finite P\n\ngoal (1 subgoal):\n 1. card (P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) = Suc k'", "moreover"], ["proof (state)\nthis:\n  finite P\n\ngoal (1 subgoal):\n 1. card (P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) = Suc k'", "have \"inj_on (\\<lambda>p. insert (insert a p) (P - {p})) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>p. insert (insert a p) (P - {p})) P", "using that injectivity_subexpr1(2)[OF \\<open>a \\<notin> A\\<close>]"], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k'}\n  \\<lbrakk>?X \\<in> ?P \\<and> ?X' \\<in> ?P';\n   insert (insert a ?X) (?P - {?X}) = insert (insert a ?X') (?P' - {?X'});\n   (partition_on A ?P \\<and> card ?P = Suc ?k') \\<and>\n   partition_on A ?P' \\<and> card ?P' = Suc ?k'\\<rbrakk>\n  \\<Longrightarrow> ?X = ?X'\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>p. insert (insert a p) (P - {p})) P", "by (simp add: inj_onI)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>p. insert (insert a p) (P - {p})) P\n\ngoal (1 subgoal):\n 1. card (P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) = Suc k'", "moreover"], ["proof (state)\nthis:\n  inj_on (\\<lambda>p. insert (insert a p) (P - {p})) P\n\ngoal (1 subgoal):\n 1. card (P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) = Suc k'", "from that"], ["proof (chain)\npicking this:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k'}", "have \"card P = Suc k'\""], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> card P = Suc k'}\n\ngoal (1 subgoal):\n 1. card P = Suc k'", "by simp"], ["proof (state)\nthis:\n  card P = Suc k'\n\ngoal (1 subgoal):\n 1. card (P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) = Suc k'", "ultimately"], ["proof (chain)\npicking this:\n  finite P\n  inj_on (\\<lambda>p. insert (insert a p) (P - {p})) P\n  card P = Suc k'", "show ?thesis"], ["proof (prove)\nusing this:\n  finite P\n  inj_on (\\<lambda>p. insert (insert a p) (P - {p})) P\n  card P = Suc k'\n\ngoal (1 subgoal):\n 1. card (P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) = Suc k'", "by (simp add: card_bind_singleton)"], ["proof (state)\nthis:\n  card (P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})) = Suc k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?P \\<in> {P. partition_on A P \\<and> card P = Suc k'} \\<Longrightarrow>\n  card (?P \\<bind> (\\<lambda>p. {insert (insert a p) (?P - {p})})) = Suc k'\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "ultimately"], ["proof (chain)\npicking this:\n  finite {P. partition_on A P \\<and> card P = Suc k'}\n  \\<forall>X\\<in>{P. partition_on A P \\<and> card P = Suc k'}.\n     finite (X \\<bind> (\\<lambda>p. {insert (insert a p) (X - {p})}))\n  disjoint_family_on\n   (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))\n   {P. partition_on A P \\<and> card P = Suc k'}\n  ?P \\<in> {P. partition_on A P \\<and> card P = Suc k'} \\<Longrightarrow>\n  card (?P \\<bind> (\\<lambda>p. {insert (insert a p) (?P - {p})})) = Suc k'", "have \"card ?subexpr1 = card {P. partition_on A P \\<and> card P = Suc k'} * Suc k'\""], ["proof (prove)\nusing this:\n  finite {P. partition_on A P \\<and> card P = Suc k'}\n  \\<forall>X\\<in>{P. partition_on A P \\<and> card P = Suc k'}.\n     finite (X \\<bind> (\\<lambda>p. {insert (insert a p) (X - {p})}))\n  disjoint_family_on\n   (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))\n   {P. partition_on A P \\<and> card P = Suc k'}\n  ?P \\<in> {P. partition_on A P \\<and> card P = Suc k'} \\<Longrightarrow>\n  card (?P \\<bind> (\\<lambda>p. {insert (insert a p) (?P - {p})})) = Suc k'\n\ngoal (1 subgoal):\n 1. card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    card {P. partition_on A P \\<and> card P = Suc k'} * Suc k'", "by (subst card_bind_constant) simp+"], ["proof (state)\nthis:\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  card {P. partition_on A P \\<and> card P = Suc k'} * Suc k'\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "from this"], ["proof (chain)\npicking this:\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  card {P. partition_on A P \\<and> card P = Suc k'} * Suc k'", "have \"card ?subexpr1 = Stirling (card A) (Suc k') * Suc k'\""], ["proof (prove)\nusing this:\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  card {P. partition_on A P \\<and> card P = Suc k'} * Suc k'\n\ngoal (1 subgoal):\n 1. card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "using insert.hyps(3)"], ["proof (prove)\nusing this:\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  card {P. partition_on A P \\<and> card P = Suc k'} * Suc k'\n  card {P. partition_on A P \\<and> card P = ?k} = Stirling (card A) ?k\n\ngoal (1 subgoal):\n 1. card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "by simp"], ["proof (state)\nthis:\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  Stirling (card A) (Suc k') * Suc k'\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "moreover"], ["proof (state)\nthis:\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  Stirling (card A) (Suc k') * Suc k'\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "have \"finite ?subexpr1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})))", "using \\<open>finite {P. partition_on A P \\<and> card P = Suc k'}\\<close>\n          \\<open>\\<forall>X\\<in>{P. partition_on A P \\<and> card P = Suc k'}. finite (X \\<bind> (\\<lambda>p. {insert (insert a p) (X - {p})}))\\<close>"], ["proof (prove)\nusing this:\n  finite {P. partition_on A P \\<and> card P = Suc k'}\n  \\<forall>X\\<in>{P. partition_on A P \\<and> card P = Suc k'}.\n     finite (X \\<bind> (\\<lambda>p. {insert (insert a p) (X - {p})}))\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})))", "by (auto intro: finite_bind)"], ["proof (state)\nthis:\n  finite\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})))\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "ultimately"], ["proof (chain)\npicking this:\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  Stirling (card A) (Suc k') * Suc k'\n  finite\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})))", "show ?thesis"], ["proof (prove)\nusing this:\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  Stirling (card A) (Suc k') * Suc k'\n  finite\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})})))\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n      (\\<lambda>P.\n          P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n    Stirling (card A) (Suc k') * Suc k'", "by blast"], ["proof (state)\nthis:\n  finite\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P.\n        P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  Stirling (card A) (Suc k') * Suc k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P.\n        P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  Stirling (card A) (Suc k') * Suc k'\n\ngoal (1 subgoal):\n 1. card\n     (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n       (\\<lambda>P.\n           P \\<bind>\n           (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n      ({P. partition_on A P \\<and> card P = k'} \\<bind>\n       (\\<lambda>P. {insert {a} P}))) =\n    Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'", "moreover"], ["proof (state)\nthis:\n  finite\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P.\n        P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  Stirling (card A) (Suc k') * Suc k'\n\ngoal (1 subgoal):\n 1. card\n     (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n       (\\<lambda>P.\n           P \\<bind>\n           (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n      ({P. partition_on A P \\<and> card P = k'} \\<bind>\n       (\\<lambda>P. {insert {a} P}))) =\n    Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'", "have \"finite ?subexpr2 \\<and> card ?subexpr2 = Stirling (card A) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "from \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  finite A", "have \"finite {P. partition_on A P \\<and> card P = k'}\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite {P. partition_on A P \\<and> card P = k'}", "by (simp add: finitely_many_partition_on)"], ["proof (state)\nthis:\n  finite {P. partition_on A P \\<and> card P = k'}\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "moreover"], ["proof (state)\nthis:\n  finite {P. partition_on A P \\<and> card P = k'}\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "have \" inj_on (insert {a}) {P. partition_on A P \\<and> card P = k'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (insert {a}) {P. partition_on A P \\<and> card P = k'}", "using injectivity_subexpr2[OF \\<open>a \\<notin> A\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert {a} ?P = insert {a} ?P';\n   (partition_on A ?P \\<and> card ?P = ?k') \\<and>\n   partition_on A ?P' \\<and> card ?P' = ?k'\\<rbrakk>\n  \\<Longrightarrow> ?P = ?P'\n\ngoal (1 subgoal):\n 1. inj_on (insert {a}) {P. partition_on A P \\<and> card P = k'}", "by (simp add: inj_on_def)"], ["proof (state)\nthis:\n  inj_on (insert {a}) {P. partition_on A P \\<and> card P = k'}\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "ultimately"], ["proof (chain)\npicking this:\n  finite {P. partition_on A P \\<and> card P = k'}\n  inj_on (insert {a}) {P. partition_on A P \\<and> card P = k'}", "have \"card ?subexpr2 = card {P. partition_on A P \\<and> card P = k'}\""], ["proof (prove)\nusing this:\n  finite {P. partition_on A P \\<and> card P = k'}\n  inj_on (insert {a}) {P. partition_on A P \\<and> card P = k'}\n\ngoal (1 subgoal):\n 1. card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    card {P. partition_on A P \\<and> card P = k'}", "by (simp add: card_bind_singleton)"], ["proof (state)\nthis:\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  card {P. partition_on A P \\<and> card P = k'}\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "also"], ["proof (state)\nthis:\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  card {P. partition_on A P \\<and> card P = k'}\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "have \"\\<dots> = Stirling (card A) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P = k'} = Stirling (card A) k'", "using insert.hyps(3)"], ["proof (prove)\nusing this:\n  card {P. partition_on A P \\<and> card P = ?k} = Stirling (card A) ?k\n\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P = k'} = Stirling (card A) k'", "."], ["proof (state)\nthis:\n  card {P. partition_on A P \\<and> card P = k'} = Stirling (card A) k'\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "finally"], ["proof (chain)\npicking this:\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'", "have \"card ?subexpr2 = Stirling (card A) k'\""], ["proof (prove)\nusing this:\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'\n\ngoal (1 subgoal):\n 1. card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "."], ["proof (state)\nthis:\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "moreover"], ["proof (state)\nthis:\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "have \"finite ?subexpr2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P}))", "by (simp add: \\<open>finite {P. partition_on A P \\<and> card P = k'}\\<close> finite_bind)"], ["proof (state)\nthis:\n  finite\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P}))\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "ultimately"], ["proof (chain)\npicking this:\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'\n  finite\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P}))", "show ?thesis"], ["proof (prove)\nusing this:\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'\n  finite\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P}))\n\ngoal (1 subgoal):\n 1. finite\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) \\<and>\n    card\n     ({P. partition_on A P \\<and> card P = k'} \\<bind>\n      (\\<lambda>P. {insert {a} P})) =\n    Stirling (card A) k'", "by blast"], ["proof (state)\nthis:\n  finite\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) \\<and>\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) \\<and>\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'\n\ngoal (1 subgoal):\n 1. card\n     (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n       (\\<lambda>P.\n           P \\<bind>\n           (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n      ({P. partition_on A P \\<and> card P = k'} \\<bind>\n       (\\<lambda>P. {insert {a} P}))) =\n    Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'", "moreover"], ["proof (state)\nthis:\n  finite\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) \\<and>\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'\n\ngoal (1 subgoal):\n 1. card\n     (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n       (\\<lambda>P.\n           P \\<bind>\n           (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n      ({P. partition_on A P \\<and> card P = k'} \\<bind>\n       (\\<lambda>P. {insert {a} P}))) =\n    Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'", "have \"?subexpr1 \\<inter> ?subexpr2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<inter>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P})) =\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<inter>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P})) =\n    {}", "have \"\\<forall>P\\<in>?subexpr1. {a} \\<notin> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P\\<in>{P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n                   (\\<lambda>P.\n                       P \\<bind>\n                       (\\<lambda>p. {insert (insert a p) (P - {p})})).\n       {a} \\<notin> P", "using insert.hyps(2)"], ["proof (prove)\nusing this:\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. \\<forall>P\\<in>{P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n                   (\\<lambda>P.\n                       P \\<bind>\n                       (\\<lambda>p. {insert (insert a p) (P - {p})})).\n       {a} \\<notin> P", "by (force elim!: partition_onE)"], ["proof (state)\nthis:\n  \\<forall>P\\<in>{P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n                 (\\<lambda>P.\n                     P \\<bind>\n                     (\\<lambda>p. {insert (insert a p) (P - {p})})).\n     {a} \\<notin> P\n\ngoal (1 subgoal):\n 1. ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<inter>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P})) =\n    {}", "moreover"], ["proof (state)\nthis:\n  \\<forall>P\\<in>{P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n                 (\\<lambda>P.\n                     P \\<bind>\n                     (\\<lambda>p. {insert (insert a p) (P - {p})})).\n     {a} \\<notin> P\n\ngoal (1 subgoal):\n 1. ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<inter>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P})) =\n    {}", "have \"\\<forall>P\\<in>?subexpr2. {a} \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P\\<in>{P. partition_on A P \\<and> card P = k'} \\<bind>\n                   (\\<lambda>P. {insert {a} P}).\n       {a} \\<in> P", "by auto"], ["proof (state)\nthis:\n  \\<forall>P\\<in>{P. partition_on A P \\<and> card P = k'} \\<bind>\n                 (\\<lambda>P. {insert {a} P}).\n     {a} \\<in> P\n\ngoal (1 subgoal):\n 1. ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<inter>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P})) =\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>P\\<in>{P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n                 (\\<lambda>P.\n                     P \\<bind>\n                     (\\<lambda>p. {insert (insert a p) (P - {p})})).\n     {a} \\<notin> P\n  \\<forall>P\\<in>{P. partition_on A P \\<and> card P = k'} \\<bind>\n                 (\\<lambda>P. {insert {a} P}).\n     {a} \\<in> P", "show \"?subexpr1 \\<inter> ?subexpr2 = {}\""], ["proof (prove)\nusing this:\n  \\<forall>P\\<in>{P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n                 (\\<lambda>P.\n                     P \\<bind>\n                     (\\<lambda>p. {insert (insert a p) (P - {p})})).\n     {a} \\<notin> P\n  \\<forall>P\\<in>{P. partition_on A P \\<and> card P = k'} \\<bind>\n                 (\\<lambda>P. {insert {a} P}).\n     {a} \\<in> P\n\ngoal (1 subgoal):\n 1. ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<inter>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P})) =\n    {}", "by blast"], ["proof (state)\nthis:\n  ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n   (\\<lambda>P.\n       P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<inter>\n  ({P. partition_on A P \\<and> card P = k'} \\<bind>\n   (\\<lambda>P. {insert {a} P})) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n   (\\<lambda>P.\n       P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<inter>\n  ({P. partition_on A P \\<and> card P = k'} \\<bind>\n   (\\<lambda>P. {insert {a} P})) =\n  {}\n\ngoal (1 subgoal):\n 1. card\n     (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n       (\\<lambda>P.\n           P \\<bind>\n           (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n      ({P. partition_on A P \\<and> card P = k'} \\<bind>\n       (\\<lambda>P. {insert {a} P}))) =\n    Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P.\n        P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  Stirling (card A) (Suc k') * Suc k'\n  finite\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) \\<and>\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'\n  ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n   (\\<lambda>P.\n       P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<inter>\n  ({P. partition_on A P \\<and> card P = k'} \\<bind>\n   (\\<lambda>P. {insert {a} P})) =\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P.\n        P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<and>\n  card\n   ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n    (\\<lambda>P. P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) =\n  Stirling (card A) (Suc k') * Suc k'\n  finite\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) \\<and>\n  card\n   ({P. partition_on A P \\<and> card P = k'} \\<bind>\n    (\\<lambda>P. {insert {a} P})) =\n  Stirling (card A) k'\n  ({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n   (\\<lambda>P.\n       P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<inter>\n  ({P. partition_on A P \\<and> card P = k'} \\<bind>\n   (\\<lambda>P. {insert {a} P})) =\n  {}\n\ngoal (1 subgoal):\n 1. card\n     (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n       (\\<lambda>P.\n           P \\<bind>\n           (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n      ({P. partition_on A P \\<and> card P = k'} \\<bind>\n       (\\<lambda>P. {insert {a} P}))) =\n    Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'", "by (simp add: card_Un_disjoint)"], ["proof (state)\nthis:\n  card\n   (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P}))) =\n  Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P}))) =\n  Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "also"], ["proof (state)\nthis:\n  card\n   (({P. partition_on A P \\<and> card P = Suc k'} \\<bind>\n     (\\<lambda>P.\n         P \\<bind> (\\<lambda>p. {insert (insert a p) (P - {p})}))) \\<union>\n    ({P. partition_on A P \\<and> card P = k'} \\<bind>\n     (\\<lambda>P. {insert {a} P}))) =\n  Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "have \"\\<dots> = Stirling (card (insert a A)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k' =\n    Stirling (card (insert a A)) k", "using insert(1, 2) \\<open>k = Suc k'\\<close>"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k' =\n    Stirling (card (insert a A)) k", "by simp"], ["proof (state)\nthis:\n  Stirling (card A) k' + Stirling (card A) (Suc k') * Suc k' =\n  Stirling (card (insert a A)) k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>finite A; a \\<notin> A;\n        \\<And>k.\n           card {P. partition_on A P \\<and> card P = k} =\n           Stirling (card A) k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> card\n                          {P. partition_on (insert a A) P \\<and>\n                              card P = k} =\n                         Stirling (card (insert a A)) k", "finally"], ["proof (chain)\npicking this:\n  card {P. partition_on (insert a A) P \\<and> card P = k} =\n  Stirling (card (insert a A)) k", "show ?thesis"], ["proof (prove)\nusing this:\n  card {P. partition_on (insert a A) P \\<and> card P = k} =\n  Stirling (card (insert a A)) k\n\ngoal (1 subgoal):\n 1. card {P. partition_on (insert a A) P \\<and> card P = k} =\n    Stirling (card (insert a A)) k", "."], ["proof (state)\nthis:\n  card {P. partition_on (insert a A) P \\<and> card P = k} =\n  Stirling (card (insert a A)) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {P. partition_on (insert a A) P \\<and> card P = k} =\n  Stirling (card (insert a A)) k\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem card_partition_on_at_most_size:\n  assumes \"finite A\"\n  shows \"card {P. partition_on A P \\<and> card P \\<le> k} = (\\<Sum>j\\<le>k. Stirling (card A) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P \\<le> k} =\n    sum (Stirling (card A)) {..k}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P \\<le> k} =\n    sum (Stirling (card A)) {..k}", "have \"card {P. partition_on A P \\<and> card P \\<le> k} = card (\\<Union>j\\<le>k. {P. partition_on A P \\<and> card P = j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P \\<le> k} =\n    card (\\<Union>j\\<le>k. {P. partition_on A P \\<and> card P = j})", "by (rule arg_cong[where f=\"card\"]) auto"], ["proof (state)\nthis:\n  card {P. partition_on A P \\<and> card P \\<le> k} =\n  card (\\<Union>j\\<le>k. {P. partition_on A P \\<and> card P = j})\n\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P \\<le> k} =\n    sum (Stirling (card A)) {..k}", "also"], ["proof (state)\nthis:\n  card {P. partition_on A P \\<and> card P \\<le> k} =\n  card (\\<Union>j\\<le>k. {P. partition_on A P \\<and> card P = j})\n\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P \\<le> k} =\n    sum (Stirling (card A)) {..k}", "have \"\\<dots> = (\\<Sum>j\\<le>k. card {P. partition_on A P \\<and> card P = j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union>j\\<le>k. {P. partition_on A P \\<and> card P = j}) =\n    (\\<Sum>j\\<le>k. card {P. partition_on A P \\<and> card P = j})", "by (subst card_UN_disjoint) (auto simp add: \\<open>finite A\\<close> finitely_many_partition_on)"], ["proof (state)\nthis:\n  card (\\<Union>j\\<le>k. {P. partition_on A P \\<and> card P = j}) =\n  (\\<Sum>j\\<le>k. card {P. partition_on A P \\<and> card P = j})\n\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P \\<le> k} =\n    sum (Stirling (card A)) {..k}", "also"], ["proof (state)\nthis:\n  card (\\<Union>j\\<le>k. {P. partition_on A P \\<and> card P = j}) =\n  (\\<Sum>j\\<le>k. card {P. partition_on A P \\<and> card P = j})\n\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P \\<le> k} =\n    sum (Stirling (card A)) {..k}", "have \"(\\<Sum>j\\<le>k. card {P. partition_on A P \\<and> card P = j}) = (\\<Sum>j\\<le>k. Stirling (card A) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>k. card {P. partition_on A P \\<and> card P = j}) =\n    sum (Stirling (card A)) {..k}", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>k. card {P. partition_on A P \\<and> card P = j}) =\n    sum (Stirling (card A)) {..k}", "by (simp add: card_partition_on)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k. card {P. partition_on A P \\<and> card P = j}) =\n  sum (Stirling (card A)) {..k}\n\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P \\<le> k} =\n    sum (Stirling (card A)) {..k}", "finally"], ["proof (chain)\npicking this:\n  card {P. partition_on A P \\<and> card P \\<le> k} =\n  sum (Stirling (card A)) {..k}", "show ?thesis"], ["proof (prove)\nusing this:\n  card {P. partition_on A P \\<and> card P \\<le> k} =\n  sum (Stirling (card A)) {..k}\n\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> card P \\<le> k} =\n    sum (Stirling (card A)) {..k}", "."], ["proof (state)\nthis:\n  card {P. partition_on A P \\<and> card P \\<le> k} =\n  sum (Stirling (card A)) {..k}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem partition_on_size1:\n  assumes \"finite A\"\n  shows \"{P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)} = {(\\<lambda>a. {a}) ` A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    {(\\<lambda>a. {a}) ` A}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n    \\<subseteq> {(\\<lambda>a. {a}) ` A}\n 2. {(\\<lambda>a. {a}) ` A}\n    \\<subseteq> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "show \"{P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)} \\<subseteq> {(\\<lambda>a. {a}) ` A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n    \\<subseteq> {(\\<lambda>a. {a}) ` A}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {P. partition_on A P \\<and>\n                   (\\<forall>X\\<in>P. card X = 1)} \\<Longrightarrow>\n       x \\<in> {(\\<lambda>a. {a}) ` A}", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {P. partition_on A P \\<and>\n                   (\\<forall>X\\<in>P. card X = 1)} \\<Longrightarrow>\n       x \\<in> {(\\<lambda>a. {a}) ` A}", "assume P: \"P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\""], ["proof (state)\nthis:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {P. partition_on A P \\<and>\n                   (\\<forall>X\\<in>P. card X = 1)} \\<Longrightarrow>\n       x \\<in> {(\\<lambda>a. {a}) ` A}", "have \"P = (\\<lambda>a. {a}) ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = (\\<lambda>a. {a}) ` A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<subseteq> (\\<lambda>a. {a}) ` A\n 2. (\\<lambda>a. {a}) ` A \\<subseteq> P", "show \"P \\<subseteq> (\\<lambda>a. {a}) ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> (\\<lambda>a. {a}) ` A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> (\\<lambda>a. {a}) ` A", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> (\\<lambda>a. {a}) ` A", "assume \"X \\<in> P\""], ["proof (state)\nthis:\n  X \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> (\\<lambda>a. {a}) ` A", "from P this"], ["proof (chain)\npicking this:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n  X \\<in> P", "obtain x where \"X = {x}\""], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n  X \\<in> P\n\ngoal (1 subgoal):\n 1. (\\<And>x. X = {x} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp add: card_Suc_eq)"], ["proof (state)\nthis:\n  X = {x}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> (\\<lambda>a. {a}) ` A", "from this \\<open>X \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  X = {x}\n  X \\<in> P", "have \"x \\<in> A\""], ["proof (prove)\nusing this:\n  X = {x}\n  X \\<in> P\n\ngoal (1 subgoal):\n 1. x \\<in> A", "using P"], ["proof (prove)\nusing this:\n  X = {x}\n  X \\<in> P\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. x \\<in> A", "unfolding partition_on_def"], ["proof (prove)\nusing this:\n  X = {x}\n  X \\<in> P\n  P \\<in> {P. (\\<Union> P = A \\<and> disjoint P \\<and> {} \\<notin> P) \\<and>\n              (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by blast"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> (\\<lambda>a. {a}) ` A", "from this \\<open>X = {x}\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> A\n  X = {x}", "show \"X \\<in>(\\<lambda>a. {a}) ` A\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  X = {x}\n\ngoal (1 subgoal):\n 1. X \\<in> (\\<lambda>a. {a}) ` A", "by auto"], ["proof (state)\nthis:\n  X \\<in> (\\<lambda>a. {a}) ` A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<subseteq> (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. {a}) ` A \\<subseteq> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>a. {a}) ` A \\<subseteq> P", "show \"(\\<lambda>a. {a}) ` A \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. {a}) ` A \\<subseteq> P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> (\\<lambda>a. {a}) ` A \\<Longrightarrow> x \\<in> P", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> (\\<lambda>a. {a}) ` A \\<Longrightarrow> x \\<in> P", "assume \"X \\<in> (\\<lambda>a. {a}) ` A\""], ["proof (state)\nthis:\n  X \\<in> (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> (\\<lambda>a. {a}) ` A \\<Longrightarrow> x \\<in> P", "from this"], ["proof (chain)\npicking this:\n  X \\<in> (\\<lambda>a. {a}) ` A", "obtain x where X: \"X = {x}\" \"x \\<in> A\""], ["proof (prove)\nusing this:\n  X \\<in> (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>X = {x}; x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X = {x}\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> (\\<lambda>a. {a}) ` A \\<Longrightarrow> x \\<in> P", "have \"\\<Union>P = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> P = A", "using P"], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. \\<Union> P = A", "unfolding partition_on_def"], ["proof (prove)\nusing this:\n  P \\<in> {P. (\\<Union> P = A \\<and> disjoint P \\<and> {} \\<notin> P) \\<and>\n              (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. \\<Union> P = A", "by blast"], ["proof (state)\nthis:\n  \\<Union> P = A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> (\\<lambda>a. {a}) ` A \\<Longrightarrow> x \\<in> P", "from this \\<open>x \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  \\<Union> P = A\n  x \\<in> A", "obtain X' where \"x \\<in> X'\" and \"X' \\<in> P\""], ["proof (prove)\nusing this:\n  \\<Union> P = A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>X'.\n        \\<lbrakk>x \\<in> X'; X' \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using UnionE"], ["proof (prove)\nusing this:\n  \\<Union> P = A\n  x \\<in> A\n  \\<lbrakk>?A \\<in> \\<Union> ?C;\n   \\<And>X.\n      \\<lbrakk>?A \\<in> X; X \\<in> ?C\\<rbrakk> \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. (\\<And>X'.\n        \\<lbrakk>x \\<in> X'; X' \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> X'\n  X' \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> (\\<lambda>a. {a}) ` A \\<Longrightarrow> x \\<in> P", "from \\<open>X' \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  X' \\<in> P", "have \"card X' = 1\""], ["proof (prove)\nusing this:\n  X' \\<in> P\n\ngoal (1 subgoal):\n 1. card X' = 1", "using P"], ["proof (prove)\nusing this:\n  X' \\<in> P\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. card X' = 1", "unfolding partition_on_def"], ["proof (prove)\nusing this:\n  X' \\<in> P\n  P \\<in> {P. (\\<Union> P = A \\<and> disjoint P \\<and> {} \\<notin> P) \\<and>\n              (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. card X' = 1", "by auto"], ["proof (state)\nthis:\n  card X' = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> (\\<lambda>a. {a}) ` A \\<Longrightarrow> x \\<in> P", "from this \\<open>x \\<in> X'\\<close>"], ["proof (chain)\npicking this:\n  card X' = 1\n  x \\<in> X'", "have \"X' = {x}\""], ["proof (prove)\nusing this:\n  card X' = 1\n  x \\<in> X'\n\ngoal (1 subgoal):\n 1. X' = {x}", "using card_1_singletonE"], ["proof (prove)\nusing this:\n  card X' = 1\n  x \\<in> X'\n  \\<lbrakk>card ?A = 1; \\<And>x. ?A = {x} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. X' = {x}", "by blast"], ["proof (state)\nthis:\n  X' = {x}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> (\\<lambda>a. {a}) ` A \\<Longrightarrow> x \\<in> P", "from this X(1) \\<open>X' \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  X' = {x}\n  X = {x}\n  X' \\<in> P", "show \"X \\<in> P\""], ["proof (prove)\nusing this:\n  X' = {x}\n  X = {x}\n  X' \\<in> P\n\ngoal (1 subgoal):\n 1. X \\<in> P", "by auto"], ["proof (state)\nthis:\n  X \\<in> P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>a. {a}) ` A \\<subseteq> P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P = (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {P. partition_on A P \\<and>\n                   (\\<forall>X\\<in>P. card X = 1)} \\<Longrightarrow>\n       x \\<in> {(\\<lambda>a. {a}) ` A}", "from this"], ["proof (chain)\npicking this:\n  P = (\\<lambda>a. {a}) ` A", "show \"P \\<in> {(\\<lambda>a. {a}) ` A}\""], ["proof (prove)\nusing this:\n  P = (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. P \\<in> {(\\<lambda>a. {a}) ` A}", "by auto"], ["proof (state)\nthis:\n  P \\<in> {(\\<lambda>a. {a}) ` A}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n  \\<subseteq> {(\\<lambda>a. {a}) ` A}\n\ngoal (1 subgoal):\n 1. {(\\<lambda>a. {a}) ` A}\n    \\<subseteq> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {(\\<lambda>a. {a}) ` A}\n    \\<subseteq> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "show \"{(\\<lambda>a. {a}) ` A} \\<subseteq> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(\\<lambda>a. {a}) ` A}\n    \\<subseteq> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(\\<lambda>a. {a}) ` A} \\<Longrightarrow>\n       x \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(\\<lambda>a. {a}) ` A} \\<Longrightarrow>\n       x \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "assume \"P \\<in> {(\\<lambda>a. {a}) ` A}\""], ["proof (state)\nthis:\n  P \\<in> {(\\<lambda>a. {a}) ` A}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(\\<lambda>a. {a}) ` A} \\<Longrightarrow>\n       x \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "from this"], ["proof (chain)\npicking this:\n  P \\<in> {(\\<lambda>a. {a}) ` A}", "have P: \"P = (\\<lambda>a. {a}) ` A\""], ["proof (prove)\nusing this:\n  P \\<in> {(\\<lambda>a. {a}) ` A}\n\ngoal (1 subgoal):\n 1. P = (\\<lambda>a. {a}) ` A", "by auto"], ["proof (state)\nthis:\n  P = (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(\\<lambda>a. {a}) ` A} \\<Longrightarrow>\n       x \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "from this"], ["proof (chain)\npicking this:\n  P = (\\<lambda>a. {a}) ` A", "have \"partition_on A P\""], ["proof (prove)\nusing this:\n  P = (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. partition_on A P", "by (auto intro: partition_onI)"], ["proof (state)\nthis:\n  partition_on A P\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(\\<lambda>a. {a}) ` A} \\<Longrightarrow>\n       x \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "from P this"], ["proof (chain)\npicking this:\n  P = (\\<lambda>a. {a}) ` A\n  partition_on A P", "show \"P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\""], ["proof (prove)\nusing this:\n  P = (\\<lambda>a. {a}) ` A\n  partition_on A P\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "by auto"], ["proof (state)\nthis:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(\\<lambda>a. {a}) ` A}\n  \\<subseteq> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem card_partition_on_size1:\n  assumes \"finite A\"\n  shows \"card {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)} = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)} = 1", "using assms partition_on_size1"], ["proof (prove)\nusing this:\n  finite A\n  finite ?A \\<Longrightarrow>\n  {P. partition_on ?A P \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  {(\\<lambda>a. {a}) ` ?A}\n\ngoal (1 subgoal):\n 1. card {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)} = 1", "by fastforce"], ["", "lemma card_partition_on_size1_eq_1:\n  assumes \"finite A\"\n  assumes \"card A \\<le> k\"\n  shows \"card {P. partition_on A P \\<and> card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "assume \"partition_on A P\" \"\\<forall>X\\<in>P. card X = 1\""], ["proof (state)\nthis:\n  partition_on A P\n  \\<forall>X\\<in>P. card X = 1\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "from this"], ["proof (chain)\npicking this:\n  partition_on A P\n  \\<forall>X\\<in>P. card X = 1", "have \"P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\""], ["proof (prove)\nusing this:\n  partition_on A P\n  \\<forall>X\\<in>P. card X = 1\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "by simp"], ["proof (state)\nthis:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "from this"], ["proof (chain)\npicking this:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "have \"P \\<in> {(\\<lambda>a. {a}) ` A}\""], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. P \\<in> {(\\<lambda>a. {a}) ` A}", "using partition_on_size1 \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n  finite ?A \\<Longrightarrow>\n  {P. partition_on ?A P \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  {(\\<lambda>a. {a}) ` ?A}\n  finite A\n\ngoal (1 subgoal):\n 1. P \\<in> {(\\<lambda>a. {a}) ` A}", "by auto"], ["proof (state)\nthis:\n  P \\<in> {(\\<lambda>a. {a}) ` A}\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "from this"], ["proof (chain)\npicking this:\n  P \\<in> {(\\<lambda>a. {a}) ` A}", "have \"P = (\\<lambda>a. {a}) ` A\""], ["proof (prove)\nusing this:\n  P \\<in> {(\\<lambda>a. {a}) ` A}\n\ngoal (1 subgoal):\n 1. P = (\\<lambda>a. {a}) ` A", "by auto"], ["proof (state)\nthis:\n  P = (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "moreover"], ["proof (state)\nthis:\n  P = (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "from this"], ["proof (chain)\npicking this:\n  P = (\\<lambda>a. {a}) ` A", "have \"card P = card A\""], ["proof (prove)\nusing this:\n  P = (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. card P = card A", "by (auto intro: card_image)"], ["proof (state)\nthis:\n  card P = card A\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>partition_on A ?P2; \\<forall>X\\<in>?P2. card X = 1\\<rbrakk>\n  \\<Longrightarrow> card ?P2 = card A\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>partition_on A ?P2; \\<forall>X\\<in>?P2. card X = 1\\<rbrakk>\n  \\<Longrightarrow> card ?P2 = card A", "have \"{P. partition_on A P \\<and> card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} = {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>partition_on A ?P2; \\<forall>X\\<in>?P2. card X = 1\\<rbrakk>\n  \\<Longrightarrow> card ?P2 = card A\n\ngoal (1 subgoal):\n 1. {P. partition_on A P \\<and>\n        card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "using \\<open>card A \\<le> k\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>partition_on A ?P2; \\<forall>X\\<in>?P2. card X = 1\\<rbrakk>\n  \\<Longrightarrow> card ?P2 = card A\n  card A \\<le> k\n\ngoal (1 subgoal):\n 1. {P. partition_on A P \\<and>\n        card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "by auto"], ["proof (state)\nthis:\n  {P. partition_on A P \\<and>\n      card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "from this"], ["proof (chain)\npicking this:\n  {P. partition_on A P \\<and>\n      card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "show ?thesis"], ["proof (prove)\nusing this:\n  {P. partition_on A P \\<and>\n      card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  {P. partition_on A P \\<and>\n      card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n  finite A\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    1", "by (simp only: card_partition_on_size1)"], ["proof (state)\nthis:\n  card\n   {P. partition_on A P \\<and>\n       card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_partition_on_size1_eq_0:\n  assumes \"finite A\"\n  assumes \"k < card A\"\n  shows \"card {P. partition_on A P \\<and> card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "assume \"partition_on A P\" \"\\<forall>X\\<in>P. card X = 1\""], ["proof (state)\nthis:\n  partition_on A P\n  \\<forall>X\\<in>P. card X = 1\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "from this"], ["proof (chain)\npicking this:\n  partition_on A P\n  \\<forall>X\\<in>P. card X = 1", "have \"P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\""], ["proof (prove)\nusing this:\n  partition_on A P\n  \\<forall>X\\<in>P. card X = 1\n\ngoal (1 subgoal):\n 1. P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "by simp"], ["proof (state)\nthis:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "from this"], ["proof (chain)\npicking this:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}", "have \"P \\<in> {(\\<lambda>a. {a}) ` A}\""], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n\ngoal (1 subgoal):\n 1. P \\<in> {(\\<lambda>a. {a}) ` A}", "using partition_on_size1 \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  P \\<in> {P. partition_on A P \\<and> (\\<forall>X\\<in>P. card X = 1)}\n  finite ?A \\<Longrightarrow>\n  {P. partition_on ?A P \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  {(\\<lambda>a. {a}) ` ?A}\n  finite A\n\ngoal (1 subgoal):\n 1. P \\<in> {(\\<lambda>a. {a}) ` A}", "by auto"], ["proof (state)\nthis:\n  P \\<in> {(\\<lambda>a. {a}) ` A}\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "from this"], ["proof (chain)\npicking this:\n  P \\<in> {(\\<lambda>a. {a}) ` A}", "have \"P = (\\<lambda>a. {a}) ` A\""], ["proof (prove)\nusing this:\n  P \\<in> {(\\<lambda>a. {a}) ` A}\n\ngoal (1 subgoal):\n 1. P = (\\<lambda>a. {a}) ` A", "by auto"], ["proof (state)\nthis:\n  P = (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "from this"], ["proof (chain)\npicking this:\n  P = (\\<lambda>a. {a}) ` A", "have \"card P = card A\""], ["proof (prove)\nusing this:\n  P = (\\<lambda>a. {a}) ` A\n\ngoal (1 subgoal):\n 1. card P = card A", "by (auto intro: card_image)"], ["proof (state)\nthis:\n  card P = card A\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>partition_on A ?P2; \\<forall>X\\<in>?P2. card X = 1\\<rbrakk>\n  \\<Longrightarrow> card ?P2 = card A\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "from this assms(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>partition_on A ?P2; \\<forall>X\\<in>?P2. card X = 1\\<rbrakk>\n  \\<Longrightarrow> card ?P2 = card A\n  k < card A", "have \"{P. partition_on A P \\<and> card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>partition_on A ?P2; \\<forall>X\\<in>?P2. card X = 1\\<rbrakk>\n  \\<Longrightarrow> card ?P2 = card A\n  k < card A\n\ngoal (1 subgoal):\n 1. {P. partition_on A P \\<and>\n        card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    {}", "using Collect_empty_eq leD"], ["proof (prove)\nusing this:\n  \\<lbrakk>partition_on A ?P2; \\<forall>X\\<in>?P2. card X = 1\\<rbrakk>\n  \\<Longrightarrow> card ?P2 = card A\n  k < card A\n  (Collect ?P = {}) = (\\<forall>x. \\<not> ?P x)\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n\ngoal (1 subgoal):\n 1. {P. partition_on A P \\<and>\n        card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    {}", "by fastforce"], ["proof (state)\nthis:\n  {P. partition_on A P \\<and>\n      card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  {}\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "from this"], ["proof (chain)\npicking this:\n  {P. partition_on A P \\<and>\n      card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  {P. partition_on A P \\<and>\n      card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  {}\n\ngoal (1 subgoal):\n 1. card\n     {P. partition_on A P \\<and>\n         card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n    0", "by (simp only: card.empty)"], ["proof (state)\nthis:\n  card\n   {P. partition_on A P \\<and>\n       card P \\<le> k \\<and> (\\<forall>X\\<in>P. card X = 1)} =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}