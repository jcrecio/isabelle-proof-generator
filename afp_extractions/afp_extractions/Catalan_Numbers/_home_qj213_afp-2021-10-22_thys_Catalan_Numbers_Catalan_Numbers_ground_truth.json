{"file_name": "/home/qj213/afp-2021-10-22/thys/Catalan_Numbers/Catalan_Numbers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Catalan_Numbers", "problem_names": ["lemma mult_eq_imp_eq_div:\n  assumes \"a * b = c\" \"(a :: 'a :: semidom_divide) \\<noteq> 0\"\n  shows   \"b = c div a\"", "lemma Gamma_minus_one_half_real:\n  \"Gamma (-(1/2) :: real) = - 2 * sqrt pi\"", "lemma gbinomial_asymptotic':\n  assumes \"z \\<notin> \\<nat>\"\n  shows   \"(\\<lambda>n. z gchoose (n + k)) \\<sim>[at_top]\n             (\\<lambda>n. (-1)^(n+k) / (Gamma (-z) * of_nat n powr (z + 1)) :: real)\"", "lemmas catalan_0 = catalan.simps(1)", "lemmas catalan_Suc = catalan.simps(2)", "lemma catalan_1 [simp]: \"catalan (Suc 0) = 1\"", "lemma fps_catalan_nth [simp]: \"fps_nth fps_catalan n = of_nat (catalan n)\"", "lemma fps_catalan_recurrence:\n  \"fps_catalan = 1 + fps_X * fps_catalan^2\"", "lemma fps_catalan_fps_binomial:\n  \"fps_catalan = (1/2 * (1 - (fps_binomial (1/2) oo (-4*fps_X)))) / fps_X\"", "theorem catalan_closed_form_gbinomial:\n  \"real (catalan n) = 2 * (- 4) ^ n * (1/2 gchoose Suc n)\"", "lemma catalan_closed_form_aux:\n  \"catalan n * Suc n = (2*n) choose n\"", "theorem of_nat_catalan_closed_form:\n  \"of_nat (catalan n) = (of_nat ((2*n) choose n) / of_nat (Suc n) :: 'a :: field_char_0)\"", "theorem catalan_closed_form:\n  \"catalan n = ((2*n) choose n) div Suc n\"", "lemma catalan_Suc_aux:\n  \"(n + 2) * catalan (Suc n) = 2 * (2 * n + 1) * catalan n\"", "theorem of_nat_catalan_Suc':\n  \"of_nat (catalan (Suc n)) =\n     (of_nat (2*(2*n+1)) / of_nat (n+2) * of_nat (catalan n) :: 'a :: field_char_0)\"", "theorem catalan_Suc':\n  \"catalan (Suc n) = (catalan n * (2*(2*n+1))) div (n+2)\"", "lemma has_integral_I0: \"((\\<lambda>x. x powr (-(1/2)) * sqrt (4 - x)) has_integral 2*pi) {0..4}\"", "lemma integrable_I: \n  \"(\\<lambda>x. x powr (of_nat n - 1/2) * sqrt (4 - x)) integrable_on {0..4}\"", "lemma I_Suc: \"I (Suc n) = real (2 * (2*n + 1)) / real (n + 2) * I n\"", "lemma catalan_eq_I: \"real (catalan n) = I n / (2 * pi)\"", "theorem catalan_integral_form:\n  \"((\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x) / (2*pi)) \n       has_integral real (catalan n)) {0..4}\"", "theorem catalan_asymptotics:\n  \"catalan \\<sim>[at_top] (\\<lambda>n. 4 ^ n / (sqrt pi * n powr (3/2)))\"", "lemma count_nodes_eq_0_iff [simp]: \"count_nodes t = 0 \\<longleftrightarrow> t = Leaf\"", "lemma trees_of_size_0 [simp]: \"trees_of_size 0 = {Leaf}\"", "lemma trees_of_size_Suc:\n  \"trees_of_size (Suc n) = (\\<lambda>(l,r). Node l r) ` (\\<Union>k\\<le>n. trees_of_size k \\<times> trees_of_size (n - k))\"\n    (is \"?lhs = ?rhs\")", "lemma finite_trees_of_size [simp,intro]: \"finite (trees_of_size n)\"", "lemma trees_of_size_nonempty: \"trees_of_size n \\<noteq> {}\"", "lemma trees_of_size_disjoint:\n  assumes \"m \\<noteq> n\"\n  shows   \"trees_of_size m \\<inter> trees_of_size n = {}\"", "theorem card_trees_of_size: \"card (trees_of_size n) = catalan n\"", "lemma catalan_aux_simps:\n  \"k \\<ge> n \\<Longrightarrow> catalan_aux n k acc = acc\"\n  \"k < n \\<Longrightarrow> catalan_aux n k acc = catalan_aux n (Suc k) ((acc * (2*(2*k+1))) div (k+2))\"", "lemma catalan_aux_correct:\n  assumes \"k \\<le> n\"\n  shows   \"catalan_aux n k (catalan k) = catalan n\"", "lemma catalan_code [code]: \"catalan n = catalan_aux n 0 1\""], "translations": [["", "lemma mult_eq_imp_eq_div:\n  assumes \"a * b = c\" \"(a :: 'a :: semidom_divide) \\<noteq> 0\"\n  shows   \"b = c div a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = c div a", "by (simp add: assms(2) assms(1) [symmetric])"], ["", "lemma Gamma_minus_one_half_real:\n  \"Gamma (-(1/2) :: real) = - 2 * sqrt pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gamma (- (1 / 2)) = - 2 * sqrt pi", "using rGamma_plus1[of \"-1/2 :: real\"]"], ["proof (prove)\nusing this:\n  - 1 / 2 * rGamma (- 1 / 2 + 1) = rGamma (- 1 / 2)\n\ngoal (1 subgoal):\n 1. Gamma (- (1 / 2)) = - 2 * sqrt pi", "by (simp add: rGamma_inverse_Gamma divide_simps Gamma_one_half_real split: if_split_asm)"], ["", "lemma gbinomial_asymptotic':\n  assumes \"z \\<notin> \\<nat>\"\n  shows   \"(\\<lambda>n. z gchoose (n + k)) \\<sim>[at_top]\n             (\\<lambda>n. (-1)^(n+k) / (Gamma (-z) * of_nat n powr (z + 1)) :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "from assms"], ["proof (chain)\npicking this:\n  z \\<notin> \\<nat>", "have [simp]: \"Gamma (-z) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  z \\<notin> \\<nat>\n\ngoal (1 subgoal):\n 1. Gamma (- z) \\<noteq> 0", "by (simp_all add: Gamma_eq_zero_iff uminus_in_nonpos_Ints_iff)"], ["proof (state)\nthis:\n  Gamma (- z) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "have \"filterlim (\\<lambda>n. n + k) at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM n sequentially. n + k :> sequentially", "by (intro filterlim_subseq strict_mono_add)"], ["proof (state)\nthis:\n  LIM n sequentially. n + k :> sequentially\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "from asymp_equivI'_const[OF gbinomial_asymptotic[of z]] assms"], ["proof (chain)\npicking this:\n  inverse (Gamma (- z)) \\<noteq> 0 \\<Longrightarrow>\n  (gchoose)\n   z \\<sim>[sequentially] (\\<lambda>x.\n                              inverse (Gamma (- z)) *\n                              ((- 1) ^ x /\n                               exp ((z + 1) * of_real (ln (real x)))))\n  z \\<notin> \\<nat>", "have \"(\\<lambda>n. z gchoose n) \\<sim>[at_top] (\\<lambda>n. (-1)^n / (Gamma (-z) * exp ((z+1) * ln (real n))))\""], ["proof (prove)\nusing this:\n  inverse (Gamma (- z)) \\<noteq> 0 \\<Longrightarrow>\n  (gchoose)\n   z \\<sim>[sequentially] (\\<lambda>x.\n                              inverse (Gamma (- z)) *\n                              ((- 1) ^ x /\n                               exp ((z + 1) * of_real (ln (real x)))))\n  z \\<notin> \\<nat>\n\ngoal (1 subgoal):\n 1. (gchoose)\n     z \\<sim>[sequentially] (\\<lambda>n.\n                                (- 1) ^ n /\n                                (Gamma (- z) * exp ((z + 1) * ln (real n))))", "by (simp add: Gamma_eq_zero_iff uminus_in_nonpos_Ints_iff field_simps)"], ["proof (state)\nthis:\n  (gchoose)\n   z \\<sim>[sequentially] (\\<lambda>n.\n                              (- 1) ^ n /\n                              (Gamma (- z) * exp ((z + 1) * ln (real n))))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "also"], ["proof (state)\nthis:\n  (gchoose)\n   z \\<sim>[sequentially] (\\<lambda>n.\n                              (- 1) ^ n /\n                              (Gamma (- z) * exp ((z + 1) * ln (real n))))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "have \"eventually (\\<lambda>n. exp ((z+1) * ln (real n)) = real n powr (z+1)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       exp ((z + 1) * ln (real n)) = real n powr (z + 1)", "using eventually_gt_at_top[of 0]"], ["proof (prove)\nusing this:\n  eventually ((<) (0::?'a1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       exp ((z + 1) * ln (real n)) = real n powr (z + 1)", "by eventually_elim (simp add: powr_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     exp ((z + 1) * ln (real n)) = real n powr (z + 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "finally"], ["proof (chain)\npicking this:\n  (gchoose)\n   z \\<sim>[sequentially] (\\<lambda>x.\n                              (- 1) ^ x /\n                              (Gamma (- z) * real x powr (z + 1)))", "have \"(\\<lambda>x. z gchoose (x + k)) \\<sim>[at_top]\n                  (\\<lambda>x. (- 1) ^ (x + k) / (Gamma (- z) * real (x + k) powr (z + 1)))\""], ["proof (prove)\nusing this:\n  (gchoose)\n   z \\<sim>[sequentially] (\\<lambda>x.\n                              (- 1) ^ x /\n                              (Gamma (- z) * real x powr (z + 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        z gchoose\n        (x +\n         k)) \\<sim>[sequentially] (\\<lambda>x.\n(- 1) ^ (x + k) / (Gamma (- z) * real (x + k) powr (z + 1)))", "by (rule asymp_equiv_compose') (simp add: filterlim_subseq strict_mono_add)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      z gchoose\n      (x +\n       k)) \\<sim>[sequentially] (\\<lambda>x.\n                                    (- 1) ^ (x + k) /\n                                    (Gamma (- z) *\n                                     real (x + k) powr (z + 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      z gchoose\n      (x +\n       k)) \\<sim>[sequentially] (\\<lambda>x.\n                                    (- 1) ^ (x + k) /\n                                    (Gamma (- z) *\n                                     real (x + k) powr (z + 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "have \"(\\<lambda>x. real x + real k) \\<sim>[at_top] real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. real x + real k) \\<sim>[sequentially] real", "by (subst asymp_equiv_add_right) auto"], ["proof (state)\nthis:\n  (\\<lambda>x. real x + real k) \\<sim>[sequentially] real\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "hence \"(\\<lambda>x. real (x + k) powr (z + 1)) \\<sim>[at_top] (\\<lambda>x. real x powr (z + 1))\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. real x + real k) \\<sim>[sequentially] real\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real (x + k) powr\n        (z + 1)) \\<sim>[sequentially] (\\<lambda>x. real x powr (z + 1))", "by (intro asymp_equiv_powr_real) auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      real (x + k) powr\n      (z + 1)) \\<sim>[sequentially] (\\<lambda>x. real x powr (z + 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "finally"], ["proof (chain)\npicking this:\n  (\\<And>c d.\n      c \\<sim>[sequentially] d \\<Longrightarrow>\n      (\\<lambda>a.\n          (- 1) ^ (a + k) /\n          (Gamma (- z) *\n           c a)) \\<sim>[sequentially] (\\<lambda>a.\n    (- 1) ^ (a + k) / (Gamma (- z) * d a))) \\<Longrightarrow>\n  (\\<lambda>x.\n      z gchoose\n      (x +\n       k)) \\<sim>[sequentially] (\\<lambda>a.\n                                    (- 1) ^ (a + k) /\n                                    (Gamma (- z) * real a powr (z + 1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>c d.\n      c \\<sim>[sequentially] d \\<Longrightarrow>\n      (\\<lambda>a.\n          (- 1) ^ (a + k) /\n          (Gamma (- z) *\n           c a)) \\<sim>[sequentially] (\\<lambda>a.\n    (- 1) ^ (a + k) / (Gamma (- z) * d a))) \\<Longrightarrow>\n  (\\<lambda>x.\n      z gchoose\n      (x +\n       k)) \\<sim>[sequentially] (\\<lambda>a.\n                                    (- 1) ^ (a + k) /\n                                    (Gamma (- z) * real a powr (z + 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        z gchoose\n        (n +\n         k)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + k) / (Gamma (- z) * real n powr (z + 1)))", "by - (simp_all add: asymp_equiv_intros)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      z gchoose\n      (n +\n       k)) \\<sim>[sequentially] (\\<lambda>n.\n                                    (- 1) ^ (n + k) /\n                                    (Gamma (- z) * real n powr (z + 1)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definition\\<close>"], ["", "text \\<open>\n  We define Catalan numbers by their well-known recursive definition. We shall later derive\n  a few more equivalent definitions from this one.\n\\<close>"], ["", "(*<*)"], ["", "context\n  notes [fundef_cong] = sum.cong\nbegin"], ["", "(*>*)"], ["", "fun catalan :: \"nat \\<Rightarrow> nat\" where\n  \"catalan 0 = 1\"\n| \"catalan (Suc n) = (\\<Sum>i\\<le>n. catalan i * catalan (n - i))\""], ["", "(*<*)"], ["", "end"], ["", "declare catalan.simps(2) [simp del]"], ["", "lemmas catalan_0 = catalan.simps(1)"], ["", "lemmas catalan_Suc = catalan.simps(2)"], ["", "lemma catalan_1 [simp]: \"catalan (Suc 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catalan (Suc 0) = 1", "by (simp add: catalan_Suc)"], ["", "(*>*)"], ["", "text \\<open>\n  The easiest proof of the more profound properties of the Catalan numbers (such as their\n  closed-form equation and their asymptotic growth) uses their ordinary generating function (OGF).\n  This proof is almost mechanical in the sense that it does not require `guessing' the closed\n  form; one can read it directly from the generating function.\n\n  We therefore define the OGF of the Catalan numbers ($\\sum_{n=0}^\\infty C_n z^n$ in standard\n  mathematical notation):\n\\<close>"], ["", "definition \"fps_catalan = Abs_fps (of_nat \\<circ> catalan)\""], ["", "lemma fps_catalan_nth [simp]: \"fps_nth fps_catalan n = of_nat (catalan n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_nth fps_catalan n = of_nat (catalan n)", "by (simp add: fps_catalan_def)"], ["", "text \\<open>\n  Given their recursive definition, it is easy to see that the OGF of the Catalan numbers\n  satisfies the following recursive equation:\n\\<close>"], ["", "lemma fps_catalan_recurrence:\n  \"fps_catalan = 1 + fps_X * fps_catalan^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_catalan = 1 + fps_X * fps_catalan\\<^sup>2", "proof (rule fps_ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       fps_nth fps_catalan n = fps_nth (1 + fps_X * fps_catalan\\<^sup>2) n", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       fps_nth fps_catalan n = fps_nth (1 + fps_X * fps_catalan\\<^sup>2) n", "show \"fps_nth fps_catalan n = fps_nth (1 + fps_X * fps_catalan^2) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_nth fps_catalan n = fps_nth (1 + fps_X * fps_catalan\\<^sup>2) n", "by (cases n) (simp_all add: fps_square_nth catalan_Suc)"], ["proof (state)\nthis:\n  fps_nth fps_catalan n = fps_nth (1 + fps_X * fps_catalan\\<^sup>2) n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We can now easily solve this equation for @{term fps_catalan}: if we denote the unknown OGF as\n  $F(z)$, we get $F(z) = \\frac{1}{2}(1 - \\sqrt{1 - 4z})$.\n\n  Note that we do not actually use the square root as defined on real or complex numbers.\n  Any $(1 + cz)^\\alpha$ can be expressed using the formal power series whose coefficients are\n  the generalised binomial coefficients, and thus we can do all of these transformations in a\n  purely algebraic way: $\\sqrt{1-4z} = (1+z)^{\\frac{1}{2}} \\circ (-4z)$ (where ${\\circ}$ denotes\n  composition of formal power series) and $(1+z)^\\alpha$ has the well-known expansion\n  $\\sum_{n=0}^\\infty {\\alpha \\choose n} z^n$.\n\\<close>"], ["", "lemma fps_catalan_fps_binomial:\n  \"fps_catalan = (1/2 * (1 - (fps_binomial (1/2) oo (-4*fps_X)))) / fps_X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_catalan =\n    1 / 2 * (1 - (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X)) / fps_X", "proof (rule mult_eq_imp_eq_div)"], ["proof (state)\ngoal (2 subgoals):\n 1. fps_X * fps_catalan =\n    1 / 2 * (1 - (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\n 2. fps_X \\<noteq> 0", "let ?F = \"fps_catalan :: 'a fps\""], ["proof (state)\ngoal (2 subgoals):\n 1. fps_X * fps_catalan =\n    1 / 2 * (1 - (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\n 2. fps_X \\<noteq> 0", "have \"fps_X * (1 + fps_X * ?F^2) = fps_X * ?F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_X * (1 + fps_X * fps_catalan\\<^sup>2) = fps_X * fps_catalan", "by (simp only: fps_catalan_recurrence [symmetric])"], ["proof (state)\nthis:\n  fps_X * (1 + fps_X * fps_catalan\\<^sup>2) = fps_X * fps_catalan\n\ngoal (2 subgoals):\n 1. fps_X * fps_catalan =\n    1 / 2 * (1 - (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\n 2. fps_X \\<noteq> 0", "hence \"(1 / 2 - fps_X * ?F)\\<^sup>2 = - fps_X + 1 / 4\""], ["proof (prove)\nusing this:\n  fps_X * (1 + fps_X * fps_catalan\\<^sup>2) = fps_X * fps_catalan\n\ngoal (1 subgoal):\n 1. (1 / 2 - fps_X * fps_catalan)\\<^sup>2 = - fps_X + 1 / 4", "by (simp add: algebra_simps power2_eq_square fps_numeral_simps)"], ["proof (state)\nthis:\n  (1 / 2 - fps_X * fps_catalan)\\<^sup>2 = - fps_X + 1 / 4\n\ngoal (2 subgoals):\n 1. fps_X * fps_catalan =\n    1 / 2 * (1 - (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\n 2. fps_X \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (1 / 2 - fps_X * fps_catalan)\\<^sup>2 = - fps_X + 1 / 4\n\ngoal (2 subgoals):\n 1. fps_X * fps_catalan =\n    1 / 2 * (1 - (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\n 2. fps_X \\<noteq> 0", "have \"\\<dots> = (1/2 * (fps_binomial (1/2) oo (-4*fps_X)))^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - fps_X + 1 / 4 =\n    (1 / 2 * (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\\<^sup>2", "by (simp add: power_mult_distrib div_power fps_binomial_1 fps_binomial_power\n                  fps_compose_power fps_compose_add_distrib ring_distribs)"], ["proof (state)\nthis:\n  - fps_X + 1 / 4 =\n  (1 / 2 * (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\\<^sup>2\n\ngoal (2 subgoals):\n 1. fps_X * fps_catalan =\n    1 / 2 * (1 - (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\n 2. fps_X \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  (1 / 2 - fps_X * fps_catalan)\\<^sup>2 =\n  (1 / 2 * (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\\<^sup>2", "have \"1/2 - fps_X * ?F = 1/2 * (fps_binomial (1/2) oo (-4*fps_X))\""], ["proof (prove)\nusing this:\n  (1 / 2 - fps_X * fps_catalan)\\<^sup>2 =\n  (1 / 2 * (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1 / 2 - fps_X * fps_catalan =\n    1 / 2 * (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X)", "by (rule fps_power_eqD) simp_all"], ["proof (state)\nthis:\n  1 / 2 - fps_X * fps_catalan =\n  1 / 2 * (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X)\n\ngoal (2 subgoals):\n 1. fps_X * fps_catalan =\n    1 / 2 * (1 - (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\n 2. fps_X \\<noteq> 0", "thus \"fps_X*?F = 1/2 * (1 - (fps_binomial (1/2) oo (-4*fps_X)))\""], ["proof (prove)\nusing this:\n  1 / 2 - fps_X * fps_catalan =\n  1 / 2 * (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X)\n\ngoal (1 subgoal):\n 1. fps_X * fps_catalan =\n    1 / 2 * (1 - (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))", "by algebra"], ["proof (state)\nthis:\n  fps_X * fps_catalan =\n  1 / 2 * (1 - (fps_binomial ((1::'a) / (2::'a)) oo - 4 * fps_X))\n\ngoal (1 subgoal):\n 1. fps_X \\<noteq> 0", "qed simp_all"], ["", "subsection \\<open>Closed-form formulae and more recurrences\\<close>"], ["", "text \\<open>\n  We can now read a closed-form formula for the Catalan numbers directly from the generating\n  function $\\frac{1}{2z}(1 - (1+z)^{\\frac{1}{2}} \\circ (-4z))$.\n\\<close>"], ["", "theorem catalan_closed_form_gbinomial:\n  \"real (catalan n) = 2 * (- 4) ^ n * (1/2 gchoose Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (catalan n) = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (catalan n) = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)", "have \"(catalan n :: real) = fps_nth fps_catalan n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (catalan n) = fps_nth fps_catalan n", "by simp"], ["proof (state)\nthis:\n  real (catalan n) = fps_nth fps_catalan n\n\ngoal (1 subgoal):\n 1. real (catalan n) = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)", "also"], ["proof (state)\nthis:\n  real (catalan n) = fps_nth fps_catalan n\n\ngoal (1 subgoal):\n 1. real (catalan n) = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)", "have \"\\<dots> = 2 * (- 4) ^ n * (1/2 gchoose Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fps_nth fps_catalan n = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)", "by (subst fps_catalan_fps_binomial)\n       (simp add: fps_div_fps_X_nth numeral_fps_const fps_compose_linear)"], ["proof (state)\nthis:\n  fps_nth fps_catalan n = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)\n\ngoal (1 subgoal):\n 1. real (catalan n) = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)", "finally"], ["proof (chain)\npicking this:\n  real (catalan n) = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  real (catalan n) = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)\n\ngoal (1 subgoal):\n 1. real (catalan n) = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)", "."], ["proof (state)\nthis:\n  real (catalan n) = 2 * (- 4) ^ n * (1 / 2 gchoose Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  This closed-form formula can easily be rewritten to the form $C_n = \\frac{1}{n+1} {2n \\choose n}$,\n  which contains only `normal' binomial coefficients and not the generalised ones:\n\\<close>"], ["", "lemma catalan_closed_form_aux:\n  \"catalan n * Suc n = (2*n) choose n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catalan n * Suc n = 2 * n choose n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. catalan n * Suc n = 2 * n choose n", "have \"real ((2*n) choose n) = fact (2*n) / (fact n)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * n choose n) = fact (2 * n) / (fact n)\\<^sup>2", "by (simp add: binomial_fact power2_eq_square)"], ["proof (state)\nthis:\n  real (2 * n choose n) = fact (2 * n) / (fact n)\\<^sup>2\n\ngoal (1 subgoal):\n 1. catalan n * Suc n = 2 * n choose n", "also"], ["proof (state)\nthis:\n  real (2 * n choose n) = fact (2 * n) / (fact n)\\<^sup>2\n\ngoal (1 subgoal):\n 1. catalan n * Suc n = 2 * n choose n", "have \"(fact (2*n) :: real) = 4^n * pochhammer (1 / 2) n * fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (2 * n) = 4 ^ n * pochhammer (1 / 2) n * fact n", "by (simp add: fact_double power_mult)"], ["proof (state)\nthis:\n  fact (2 * n) = 4 ^ n * pochhammer (1 / 2) n * fact n\n\ngoal (1 subgoal):\n 1. catalan n * Suc n = 2 * n choose n", "also"], ["proof (state)\nthis:\n  fact (2 * n) = 4 ^ n * pochhammer (1 / 2) n * fact n\n\ngoal (1 subgoal):\n 1. catalan n * Suc n = 2 * n choose n", "have \"\\<dots> / (fact n)^2 / real (n+1) = real (catalan n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 ^ n * pochhammer (1 / 2) n * fact n / (fact n)\\<^sup>2 /\n    real (n + 1) =\n    real (catalan n)", "by (simp add: catalan_closed_form_gbinomial gbinomial_pochhammer pochhammer_rec\n          field_simps power2_eq_square power_mult_distrib [symmetric] del: of_nat_Suc)"], ["proof (state)\nthis:\n  4 ^ n * pochhammer (1 / 2) n * fact n / (fact n)\\<^sup>2 / real (n + 1) =\n  real (catalan n)\n\ngoal (1 subgoal):\n 1. catalan n * Suc n = 2 * n choose n", "finally"], ["proof (chain)\npicking this:\n  real (2 * n choose n) / real (n + 1) = real (catalan n)", "have \"real (catalan n * Suc n) = real ((2*n) choose n)\""], ["proof (prove)\nusing this:\n  real (2 * n choose n) / real (n + 1) = real (catalan n)\n\ngoal (1 subgoal):\n 1. real (catalan n * Suc n) = real (2 * n choose n)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  real (catalan n * Suc n) = real (2 * n choose n)\n\ngoal (1 subgoal):\n 1. catalan n * Suc n = 2 * n choose n", "thus ?thesis"], ["proof (prove)\nusing this:\n  real (catalan n * Suc n) = real (2 * n choose n)\n\ngoal (1 subgoal):\n 1. catalan n * Suc n = 2 * n choose n", "by (simp only: of_nat_eq_iff)"], ["proof (state)\nthis:\n  catalan n * Suc n = 2 * n choose n\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem of_nat_catalan_closed_form:\n  \"of_nat (catalan n) = (of_nat ((2*n) choose n) / of_nat (Suc n) :: 'a :: field_char_0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (catalan n) = of_nat (2 * n choose n) / of_nat (Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat (catalan n) = of_nat (2 * n choose n) / of_nat (Suc n)", "have \"of_nat (catalan n * Suc n) = of_nat ((2*n) choose n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (catalan n * Suc n) = of_nat (2 * n choose n)", "by (subst catalan_closed_form_aux) (rule refl)"], ["proof (state)\nthis:\n  of_nat (catalan n * Suc n) = of_nat (2 * n choose n)\n\ngoal (1 subgoal):\n 1. of_nat (catalan n) = of_nat (2 * n choose n) / of_nat (Suc n)", "also"], ["proof (state)\nthis:\n  of_nat (catalan n * Suc n) = of_nat (2 * n choose n)\n\ngoal (1 subgoal):\n 1. of_nat (catalan n) = of_nat (2 * n choose n) / of_nat (Suc n)", "have \"of_nat (catalan n * Suc n) = of_nat (catalan n) * of_nat (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (catalan n * Suc n) = of_nat (catalan n) * of_nat (Suc n)", "by (simp only: of_nat_mult)"], ["proof (state)\nthis:\n  of_nat (catalan n * Suc n) = of_nat (catalan n) * of_nat (Suc n)\n\ngoal (1 subgoal):\n 1. of_nat (catalan n) = of_nat (2 * n choose n) / of_nat (Suc n)", "finally"], ["proof (chain)\npicking this:\n  of_nat (catalan n) * of_nat (Suc n) = of_nat (2 * n choose n)", "show ?thesis"], ["proof (prove)\nusing this:\n  of_nat (catalan n) * of_nat (Suc n) = of_nat (2 * n choose n)\n\ngoal (1 subgoal):\n 1. of_nat (catalan n) = of_nat (2 * n choose n) / of_nat (Suc n)", "by (simp add: divide_simps del: of_nat_Suc)"], ["proof (state)\nthis:\n  of_nat (catalan n) = of_nat (2 * n choose n) / of_nat (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem catalan_closed_form:\n  \"catalan n = ((2*n) choose n) div Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catalan n = (2 * n choose n) div Suc n", "by (subst catalan_closed_form_aux [symmetric]) (simp del: mult_Suc_right)"], ["", "text \\<open>\n  The following is another nice closed-form formula for the Catalan numbers, which directly\n  follows from the previous one:\n\\<close>"], ["", "corollary catalan_closed_form':\n  \"catalan n = ((2*n) choose n) - ((2*n) choose (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catalan n = 2 * n choose n - (2 * n choose Suc n)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    catalan n = 2 * n choose n - (2 * n choose Suc n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       catalan n = 2 * n choose n - (2 * n choose Suc n)", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    catalan n = 2 * n choose n - (2 * n choose Suc n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       catalan n = 2 * n choose n - (2 * n choose Suc n)", "have \"real ((2*n) choose n) - real ((2*n) choose (Suc n)) =\n          fact (2*m+2) / (fact (m+1))^2 - fact (2*m+2) / (real (m+2) * fact (m+1) * fact m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 * n choose n) - real (2 * n choose Suc n) =\n    fact (2 * m + 2) / (fact (m + 1))\\<^sup>2 -\n    fact (2 * m + 2) / (real (m + 2) * fact (m + 1) * fact m)", "by (subst (1 2) binomial_fact) (simp_all add: Suc power2_eq_square)"], ["proof (state)\nthis:\n  real (2 * n choose n) - real (2 * n choose Suc n) =\n  fact (2 * m + 2) / (fact (m + 1))\\<^sup>2 -\n  fact (2 * m + 2) / (real (m + 2) * fact (m + 1) * fact m)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    catalan n = 2 * n choose n - (2 * n choose Suc n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       catalan n = 2 * n choose n - (2 * n choose Suc n)", "also"], ["proof (state)\nthis:\n  real (2 * n choose n) - real (2 * n choose Suc n) =\n  fact (2 * m + 2) / (fact (m + 1))\\<^sup>2 -\n  fact (2 * m + 2) / (real (m + 2) * fact (m + 1) * fact m)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    catalan n = 2 * n choose n - (2 * n choose Suc n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       catalan n = 2 * n choose n - (2 * n choose Suc n)", "have \"\\<dots> = fact (2*m+2) / ((fact (m+1))^2 * real (m+2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (2 * m + 2) / (fact (m + 1))\\<^sup>2 -\n    fact (2 * m + 2) / (real (m + 2) * fact (m + 1) * fact m) =\n    fact (2 * m + 2) / ((fact (m + 1))\\<^sup>2 * real (m + 2))", "by (simp add: divide_simps power2_eq_square) (simp_all add: algebra_simps)"], ["proof (state)\nthis:\n  fact (2 * m + 2) / (fact (m + 1))\\<^sup>2 -\n  fact (2 * m + 2) / (real (m + 2) * fact (m + 1) * fact m) =\n  fact (2 * m + 2) / ((fact (m + 1))\\<^sup>2 * real (m + 2))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    catalan n = 2 * n choose n - (2 * n choose Suc n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       catalan n = 2 * n choose n - (2 * n choose Suc n)", "also"], ["proof (state)\nthis:\n  fact (2 * m + 2) / (fact (m + 1))\\<^sup>2 -\n  fact (2 * m + 2) / (real (m + 2) * fact (m + 1) * fact m) =\n  fact (2 * m + 2) / ((fact (m + 1))\\<^sup>2 * real (m + 2))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    catalan n = 2 * n choose n - (2 * n choose Suc n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       catalan n = 2 * n choose n - (2 * n choose Suc n)", "have \"\\<dots> = real (catalan n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (2 * m + 2) / ((fact (m + 1))\\<^sup>2 * real (m + 2)) =\n    real (catalan n)", "by (subst of_nat_catalan_closed_form, subst binomial_fact) (simp_all add: Suc power2_eq_square)"], ["proof (state)\nthis:\n  fact (2 * m + 2) / ((fact (m + 1))\\<^sup>2 * real (m + 2)) =\n  real (catalan n)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    catalan n = 2 * n choose n - (2 * n choose Suc n)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       catalan n = 2 * n choose n - (2 * n choose Suc n)", "finally"], ["proof (chain)\npicking this:\n  real (2 * n choose n) - real (2 * n choose Suc n) = real (catalan n)", "show ?thesis"], ["proof (prove)\nusing this:\n  real (2 * n choose n) - real (2 * n choose Suc n) = real (catalan n)\n\ngoal (1 subgoal):\n 1. catalan n = 2 * n choose n - (2 * n choose Suc n)", "by linarith"], ["proof (state)\nthis:\n  catalan n = 2 * n choose n - (2 * n choose Suc n)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    catalan n = 2 * n choose n - (2 * n choose Suc n)", "qed simp_all"], ["", "text \\<open>\n  We can now easily show that the Catalan numbers also satisfy another, simpler recurrence,\n  namely $C_{n+1} = \\frac{2(2n+1)}{n+2} C_n$. We will later use this to prove code equations to\n  compute the Catalan numbers more efficiently.\n\\<close>"], ["", "lemma catalan_Suc_aux:\n  \"(n + 2) * catalan (Suc n) = 2 * (2 * n + 1) * catalan n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n + 2) * catalan (Suc n) = 2 * (2 * n + 1) * catalan n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (n + 2) * catalan (Suc n) = 2 * (2 * n + 1) * catalan n", "have \"real (catalan (Suc n)) * real (n + 2) = real (catalan n) * 2 * real (2 * n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (catalan (Suc n)) * real (n + 2) =\n    real (catalan n) * 2 * real (2 * n + 1)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    real (catalan (Suc n)) * real (n + 2) =\n    real (catalan n) * 2 * real (2 * n + 1)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       real (catalan (Suc n)) * real (n + 2) =\n       real (catalan n) * 2 * real (2 * n + 1)", "case (Suc n)"], ["proof (state)\nthis:\n  n = Suc n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    real (catalan (Suc n)) * real (n + 2) =\n    real (catalan n) * 2 * real (2 * n + 1)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       real (catalan (Suc n)) * real (n + 2) =\n       real (catalan n) * 2 * real (2 * n + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = Suc n\n\ngoal (1 subgoal):\n 1. real (catalan (Suc n)) * real (n + 2) =\n    real (catalan n) * 2 * real (2 * n + 1)", "by (subst (1 2) of_nat_catalan_closed_form, subst (1 2) binomial_fact)\n         (simp_all add: divide_simps)"], ["proof (state)\nthis:\n  real (catalan (Suc n)) * real (n + 2) =\n  real (catalan n) * 2 * real (2 * n + 1)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    real (catalan (Suc n)) * real (n + 2) =\n    real (catalan n) * 2 * real (2 * n + 1)", "qed simp_all"], ["proof (state)\nthis:\n  real (catalan (Suc n)) * real (n + 2) =\n  real (catalan n) * 2 * real (2 * n + 1)\n\ngoal (1 subgoal):\n 1. (n + 2) * catalan (Suc n) = 2 * (2 * n + 1) * catalan n", "hence \"real ((n + 2) * catalan (Suc n)) = real (2 * (2 * n + 1) * catalan n)\""], ["proof (prove)\nusing this:\n  real (catalan (Suc n)) * real (n + 2) =\n  real (catalan n) * 2 * real (2 * n + 1)\n\ngoal (1 subgoal):\n 1. real ((n + 2) * catalan (Suc n)) = real (2 * (2 * n + 1) * catalan n)", "by (simp only: mult_ac of_nat_mult)"], ["proof (state)\nthis:\n  real ((n + 2) * catalan (Suc n)) = real (2 * (2 * n + 1) * catalan n)\n\ngoal (1 subgoal):\n 1. (n + 2) * catalan (Suc n) = 2 * (2 * n + 1) * catalan n", "thus ?thesis"], ["proof (prove)\nusing this:\n  real ((n + 2) * catalan (Suc n)) = real (2 * (2 * n + 1) * catalan n)\n\ngoal (1 subgoal):\n 1. (n + 2) * catalan (Suc n) = 2 * (2 * n + 1) * catalan n", "by (simp only: of_nat_eq_iff)"], ["proof (state)\nthis:\n  (n + 2) * catalan (Suc n) = 2 * (2 * n + 1) * catalan n\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem of_nat_catalan_Suc':\n  \"of_nat (catalan (Suc n)) =\n     (of_nat (2*(2*n+1)) / of_nat (n+2) * of_nat (catalan n) :: 'a :: field_char_0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (catalan (Suc n)) =\n    of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat (catalan (Suc n)) =\n    of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n)", "have \"(of_nat (2*(2*n+1)) / of_nat (n+2) * of_nat (catalan n) :: 'a) =\n          of_nat (2*(2*n + 1) * catalan n) / of_nat (n+2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n) =\n    of_nat (2 * (2 * n + 1) * catalan n) / of_nat (n + 2)", "by (simp add: divide_simps mult_ac del: mult_Suc mult_Suc_right)"], ["proof (state)\nthis:\n  of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n) =\n  of_nat (2 * (2 * n + 1) * catalan n) / of_nat (n + 2)\n\ngoal (1 subgoal):\n 1. of_nat (catalan (Suc n)) =\n    of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n)", "also"], ["proof (state)\nthis:\n  of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n) =\n  of_nat (2 * (2 * n + 1) * catalan n) / of_nat (n + 2)\n\ngoal (1 subgoal):\n 1. of_nat (catalan (Suc n)) =\n    of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n)", "note catalan_Suc_aux[of n, symmetric]"], ["proof (state)\nthis:\n  2 * (2 * n + 1) * catalan n = (n + 2) * catalan (Suc n)\n\ngoal (1 subgoal):\n 1. of_nat (catalan (Suc n)) =\n    of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n)", "also"], ["proof (state)\nthis:\n  2 * (2 * n + 1) * catalan n = (n + 2) * catalan (Suc n)\n\ngoal (1 subgoal):\n 1. of_nat (catalan (Suc n)) =\n    of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n)", "have \"of_nat ((n + 2) * catalan (Suc n)) / of_nat (n + 2) = (of_nat (catalan (Suc n)) :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat ((n + 2) * catalan (Suc n)) / of_nat (n + 2) =\n    of_nat (catalan (Suc n))", "by (simp del: of_nat_Suc mult_Suc_right mult_Suc)"], ["proof (state)\nthis:\n  of_nat ((n + 2) * catalan (Suc n)) / of_nat (n + 2) =\n  of_nat (catalan (Suc n))\n\ngoal (1 subgoal):\n 1. of_nat (catalan (Suc n)) =\n    of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n)", "finally"], ["proof (chain)\npicking this:\n  of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n) =\n  of_nat (catalan (Suc n))", "show ?thesis"], ["proof (prove)\nusing this:\n  of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n) =\n  of_nat (catalan (Suc n))\n\ngoal (1 subgoal):\n 1. of_nat (catalan (Suc n)) =\n    of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n)", ".."], ["proof (state)\nthis:\n  of_nat (catalan (Suc n)) =\n  of_nat (2 * (2 * n + 1)) / of_nat (n + 2) * of_nat (catalan n)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem catalan_Suc':\n  \"catalan (Suc n) = (catalan n * (2*(2*n+1))) div (n+2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catalan (Suc n) = catalan n * (2 * (2 * n + 1)) div (n + 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. catalan (Suc n) = catalan n * (2 * (2 * n + 1)) div (n + 2)", "from catalan_Suc_aux[of n]"], ["proof (chain)\npicking this:\n  (n + 2) * catalan (Suc n) = 2 * (2 * n + 1) * catalan n", "have \"catalan n * (2*(2*n+1)) = catalan (Suc n) * (n+2)\""], ["proof (prove)\nusing this:\n  (n + 2) * catalan (Suc n) = 2 * (2 * n + 1) * catalan n\n\ngoal (1 subgoal):\n 1. catalan n * (2 * (2 * n + 1)) = catalan (Suc n) * (n + 2)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  catalan n * (2 * (2 * n + 1)) = catalan (Suc n) * (n + 2)\n\ngoal (1 subgoal):\n 1. catalan (Suc n) = catalan n * (2 * (2 * n + 1)) div (n + 2)", "also"], ["proof (state)\nthis:\n  catalan n * (2 * (2 * n + 1)) = catalan (Suc n) * (n + 2)\n\ngoal (1 subgoal):\n 1. catalan (Suc n) = catalan n * (2 * (2 * n + 1)) div (n + 2)", "have \"\\<dots> div (n+2) = catalan (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catalan (Suc n) * (n + 2) div (n + 2) = catalan (Suc n)", "by (simp del: mult_Suc mult_Suc_right)"], ["proof (state)\nthis:\n  catalan (Suc n) * (n + 2) div (n + 2) = catalan (Suc n)\n\ngoal (1 subgoal):\n 1. catalan (Suc n) = catalan n * (2 * (2 * n + 1)) div (n + 2)", "finally"], ["proof (chain)\npicking this:\n  catalan n * (2 * (2 * n + 1)) div (n + 2) = catalan (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  catalan n * (2 * (2 * n + 1)) div (n + 2) = catalan (Suc n)\n\ngoal (1 subgoal):\n 1. catalan (Suc n) = catalan n * (2 * (2 * n + 1)) div (n + 2)", ".."], ["proof (state)\nthis:\n  catalan (Suc n) = catalan n * (2 * (2 * n + 1)) div (n + 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Integral formula\\<close>"], ["", "text \\<open>\n  The recursive formula we have just proven allows us to derive an integral formula for \n  the Catalan numbers. The proof was adapted from a textbook proof by Steven Roman.~\\cite{catalan}\n\\<close>"], ["", "context\nbegin"], ["", "private"], ["", "definition I :: \"nat \\<Rightarrow> real\" where\n  \"I n = integral {0..4} (\\<lambda>x. x powr (of_nat n - 1/2) * sqrt (4 - x))\""], ["", "private"], ["", "lemma has_integral_I0: \"((\\<lambda>x. x powr (-(1/2)) * sqrt (4 - x)) has_integral 2*pi) {0..4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr - (1 / 2) * sqrt (4 - x)) has_integral 2 * pi)\n     {0..4}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr - (1 / 2) * sqrt (4 - x)) has_integral 2 * pi)\n     {0..4}", "have \"\\<And>x. x\\<in>{0..4}-{} \\<Longrightarrow> x powr (-(1/2)) * sqrt (4 - x) = sqrt ((4 - x) / x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..4} - {} \\<Longrightarrow>\n       x powr - (1 / 2) * sqrt (4 - x) = sqrt ((4 - x) / x)", "by (auto simp: powr_minus field_simps powr_half_sqrt real_sqrt_divide)"], ["proof (state)\nthis:\n  ?x \\<in> {0..4} - {} \\<Longrightarrow>\n  ?x powr - (1 / 2) * sqrt (4 - ?x) = sqrt ((4 - ?x) / ?x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr - (1 / 2) * sqrt (4 - x)) has_integral 2 * pi)\n     {0..4}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> {0..4} - {} \\<Longrightarrow>\n  ?x powr - (1 / 2) * sqrt (4 - ?x) = sqrt ((4 - ?x) / ?x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr - (1 / 2) * sqrt (4 - x)) has_integral 2 * pi)\n     {0..4}", "by (rule has_integral_spike[OF negligible_empty _ catalan_aux_integral])"], ["proof (state)\nthis:\n  ((\\<lambda>x. x powr - (1 / 2) * sqrt (4 - x)) has_integral 2 * pi) {0..4}\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma integrable_I: \n  \"(\\<lambda>x. x powr (of_nat n - 1/2) * sqrt (4 - x)) integrable_on {0..4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on\n    {0..4}", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on\n    {0..4}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on\n    {0..4}", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on\n    {0..4}\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on\n    {0..4}", "with has_integral_I0"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. x powr - (1 / 2) * sqrt (4 - x)) has_integral 2 * pi) {0..4}\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. x powr - (1 / 2) * sqrt (4 - x)) has_integral 2 * pi) {0..4}\n  n = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on\n    {0..4}", "by (simp add: has_integral_integrable)"], ["proof (state)\nthis:\n  (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on {0..4}\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on\n    {0..4}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on\n    {0..4}", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on\n    {0..4}", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on\n    {0..4}", "by (intro integrable_continuous_real continuous_on_mult continuous_on_powr')\n                  (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) integrable_on {0..4}\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma I_Suc: \"I (Suc n) = real (2 * (2*n + 1)) / real (n + 2) * I n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "define u' u v v' \n    where \"u' = (\\<lambda>x. sqrt (4 - x :: real))\" \n      and \"u = (\\<lambda>x. -2/3 * (4 - x) powr (3/2 :: real))\"\n      and \"v = (\\<lambda>x. x powr (real n + 1/2))\" \n      and \"v' = (\\<lambda>x. (real n + 1/2) * x powr (real n - 1/2))\""], ["proof (state)\nthis:\n  u' = (\\<lambda>x. sqrt (4 - x))\n  u = (\\<lambda>x. - 2 / 3 * (4 - x) powr (3 / 2))\n  v = (\\<lambda>x. x powr (real n + 1 / 2))\n  v' = (\\<lambda>x. (real n + 1 / 2) * x powr (real n - 1 / 2))\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "define c where \"c = -2/3 * (real n + 1/2)\""], ["proof (state)\nthis:\n  c = - 2 / 3 * (real n + 1 / 2)\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "define i where \"i = (\\<lambda>n x. x powr (real n - 1/2) * sqrt (4 - x) :: real)\""], ["proof (state)\nthis:\n  i = (\\<lambda>n x. x powr (real n - 1 / 2) * sqrt (4 - x))\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "have \"I (Suc n) = integral {0..4} (\\<lambda>x. u' x * v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (Suc n) = integral {0..4} (\\<lambda>x. u' x * v x)", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..4}\n     (\\<lambda>x. x powr (real (Suc n) - 1 / 2) * sqrt (4 - x)) =\n    integral {0..4} (\\<lambda>x. u' x * v x)", "by (simp add: algebra_simps u'_def v_def)"], ["proof (state)\nthis:\n  I (Suc n) = integral {0..4} (\\<lambda>x. u' x * v x)\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "have \"((\\<lambda>x. u' x * v x) has_integral - c * (4 * I n - I (Suc n))) {0..4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. u' x * v x) has_integral - c * (4 * I n - I (Suc n)))\n     {0..4}", "proof (rule integration_by_parts_interior[OF bounded_bilinear_mult])"], ["proof (state)\ngoal (6 subgoals):\n 1. 0 \\<le> 4\n 2. continuous_on {0..4} ?f\n 3. continuous_on {0..4} v\n 4. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (?f has_vector_derivative u' x) (at x)\n 5. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (v has_vector_derivative ?g' x) (at x)\n 6. ((\\<lambda>x. ?f x * ?g' x) has_integral\n     ?f 4 * v 4 - ?f 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "show \"continuous_on {0..4} u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..4} u", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..4} (\\<lambda>x. - 2 / 3 * (4 - x) powr (3 / 2))", "by (intro continuous_on_powr' continuous_on_mult) (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..4} u\n\ngoal (5 subgoals):\n 1. 0 \\<le> 4\n 2. continuous_on {0..4} v\n 3. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (u has_vector_derivative u' x) (at x)\n 4. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (v has_vector_derivative ?g' x) (at x)\n 5. ((\\<lambda>x. u x * ?g' x) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "show \"continuous_on {0..4} v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..4} v", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..4} (\\<lambda>x. x powr (real n + 1 / 2))", "by (intro continuous_on_powr' continuous_on_mult) (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..4} v\n\ngoal (4 subgoals):\n 1. 0 \\<le> 4\n 2. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (u has_vector_derivative u' x) (at x)\n 3. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (v has_vector_derivative ?g' x) (at x)\n 4. ((\\<lambda>x. u x * ?g' x) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "fix x :: real"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 \\<le> 4\n 2. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (u has_vector_derivative u' x) (at x)\n 3. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (v has_vector_derivative ?g' x) (at x)\n 4. ((\\<lambda>x. u x * ?g' x) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "assume x: \"x \\<in> {0<..<4}\""], ["proof (state)\nthis:\n  x \\<in> {0<..<4}\n\ngoal (4 subgoals):\n 1. 0 \\<le> 4\n 2. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (u has_vector_derivative u' x) (at x)\n 3. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (v has_vector_derivative ?g' x) (at x)\n 4. ((\\<lambda>x. u x * ?g' x) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "from x"], ["proof (chain)\npicking this:\n  x \\<in> {0<..<4}", "show \"(u has_vector_derivative u' x) (at x)\""], ["proof (prove)\nusing this:\n  x \\<in> {0<..<4}\n\ngoal (1 subgoal):\n 1. (u has_vector_derivative u' x) (at x)", "unfolding has_field_derivative_iff_has_vector_derivative [symmetric] u_def u'_def"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<4}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - 2 / 3 * (4 - x) powr (3 / 2)) has_real_derivative\n     sqrt (4 - x))\n     (at x)", "by (auto intro!: derivative_eq_intros simp: field_simps powr_half_sqrt)"], ["proof (state)\nthis:\n  (u has_vector_derivative u' x) (at x)\n\ngoal (3 subgoals):\n 1. 0 \\<le> 4\n 2. \\<And>x.\n       x \\<in> {0<..<4} \\<Longrightarrow>\n       (v has_vector_derivative ?g' x) (at x)\n 3. ((\\<lambda>x. u x * ?g' x) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "from x"], ["proof (chain)\npicking this:\n  x \\<in> {0<..<4}", "show \"(v has_vector_derivative v' x) (at x)\""], ["proof (prove)\nusing this:\n  x \\<in> {0<..<4}\n\ngoal (1 subgoal):\n 1. (v has_vector_derivative v' x) (at x)", "unfolding has_field_derivative_iff_has_vector_derivative [symmetric] v_def v'_def"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<4}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x powr (real n + 1 / 2)) has_real_derivative\n     (real n + 1 / 2) * x powr (real n - 1 / 2))\n     (at x)", "by (auto intro!: derivative_eq_intros simp: field_simps)"], ["proof (state)\nthis:\n  (v has_vector_derivative v' x) (at x)\n\ngoal (2 subgoals):\n 1. 0 \\<le> 4\n 2. ((\\<lambda>x. u x * v' x) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> 4\n 2. ((\\<lambda>x. u x * v' x) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "show \"((\\<lambda>x. u x * v' x) has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n))) {0..4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. u x * v' x) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "proof (rule has_integral_spike; (intro ballI)?)"], ["proof (state)\ngoal (3 subgoals):\n 1. negligible ?S1\n 2. \\<And>x. x \\<in> {0..4} - ?S1 \\<Longrightarrow> u x * v' x = ?f1 x\n 3. (?f1 has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "fix x :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. negligible ?S1\n 2. \\<And>x. x \\<in> {0..4} - ?S1 \\<Longrightarrow> u x * v' x = ?f1 x\n 3. (?f1 has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "assume x: \"x \\<in> {0..4}-{0}\""], ["proof (state)\nthis:\n  x \\<in> {0..4} - {0}\n\ngoal (3 subgoals):\n 1. negligible ?S1\n 2. \\<And>x. x \\<in> {0..4} - ?S1 \\<Longrightarrow> u x * v' x = ?f1 x\n 3. (?f1 has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "have \"u x * v' x = c * ((4 - x) powr (1 + 1/2) * x powr (real n - 1/2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u x * v' x = c * ((4 - x) powr (1 + 1 / 2) * x powr (real n - 1 / 2))", "by (simp add: u_def v'_def c_def)"], ["proof (state)\nthis:\n  u x * v' x = c * ((4 - x) powr (1 + 1 / 2) * x powr (real n - 1 / 2))\n\ngoal (3 subgoals):\n 1. negligible ?S1\n 2. \\<And>x. x \\<in> {0..4} - ?S1 \\<Longrightarrow> u x * v' x = ?f1 x\n 3. (?f1 has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "also"], ["proof (state)\nthis:\n  u x * v' x = c * ((4 - x) powr (1 + 1 / 2) * x powr (real n - 1 / 2))\n\ngoal (3 subgoals):\n 1. negligible ?S1\n 2. \\<And>x. x \\<in> {0..4} - ?S1 \\<Longrightarrow> u x * v' x = ?f1 x\n 3. (?f1 has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "from x"], ["proof (chain)\npicking this:\n  x \\<in> {0..4} - {0}", "have \"(4 - x) powr (1 + 1/2) = (4 - x) * sqrt (4 - x)\""], ["proof (prove)\nusing this:\n  x \\<in> {0..4} - {0}\n\ngoal (1 subgoal):\n 1. (4 - x) powr (1 + 1 / 2) = (4 - x) * sqrt (4 - x)", "by (subst powr_add) (simp_all add: powr_half_sqrt)"], ["proof (state)\nthis:\n  (4 - x) powr (1 + 1 / 2) = (4 - x) * sqrt (4 - x)\n\ngoal (3 subgoals):\n 1. negligible ?S1\n 2. \\<And>x. x \\<in> {0..4} - ?S1 \\<Longrightarrow> u x * v' x = ?f1 x\n 3. (?f1 has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "also"], ["proof (state)\nthis:\n  (4 - x) powr (1 + 1 / 2) = (4 - x) * sqrt (4 - x)\n\ngoal (3 subgoals):\n 1. negligible ?S1\n 2. \\<And>x. x \\<in> {0..4} - ?S1 \\<Longrightarrow> u x * v' x = ?f1 x\n 3. (?f1 has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "have \"\\<dots> * x powr (real n - 1/2) = 4 * sqrt (4 - x) * x powr (real n - 1/2) - \n                     sqrt (4 - x) * x powr (real n - 1/2 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (4 - x) * sqrt (4 - x) * x powr (real n - 1 / 2) =\n    4 * sqrt (4 - x) * x powr (real n - 1 / 2) -\n    sqrt (4 - x) * x powr (real n - 1 / 2 + 1)", "by (subst powr_add) (insert x, simp add: field_simps)"], ["proof (state)\nthis:\n  (4 - x) * sqrt (4 - x) * x powr (real n - 1 / 2) =\n  4 * sqrt (4 - x) * x powr (real n - 1 / 2) -\n  sqrt (4 - x) * x powr (real n - 1 / 2 + 1)\n\ngoal (3 subgoals):\n 1. negligible ?S1\n 2. \\<And>x. x \\<in> {0..4} - ?S1 \\<Longrightarrow> u x * v' x = ?f1 x\n 3. (?f1 has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "also"], ["proof (state)\nthis:\n  (4 - x) * sqrt (4 - x) * x powr (real n - 1 / 2) =\n  4 * sqrt (4 - x) * x powr (real n - 1 / 2) -\n  sqrt (4 - x) * x powr (real n - 1 / 2 + 1)\n\ngoal (3 subgoals):\n 1. negligible ?S1\n 2. \\<And>x. x \\<in> {0..4} - ?S1 \\<Longrightarrow> u x * v' x = ?f1 x\n 3. (?f1 has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "have \"real n - 1/2 + 1 = real (Suc n) - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n - 1 / 2 + 1 = real (Suc n) - 1 / 2", "by simp"], ["proof (state)\nthis:\n  real n - 1 / 2 + 1 = real (Suc n) - 1 / 2\n\ngoal (3 subgoals):\n 1. negligible ?S1\n 2. \\<And>x. x \\<in> {0..4} - ?S1 \\<Longrightarrow> u x * v' x = ?f1 x\n 3. (?f1 has_integral u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "finally"], ["proof (chain)\npicking this:\n  u x * v' x =\n  c *\n  (4 * sqrt (4 - x) * x powr (real n - 1 / 2) -\n   sqrt (4 - x) * x powr (real (Suc n) - 1 / 2))", "show \"u x * v' x = c * (4 * i n x - i (Suc n) x)\""], ["proof (prove)\nusing this:\n  u x * v' x =\n  c *\n  (4 * sqrt (4 - x) * x powr (real n - 1 / 2) -\n   sqrt (4 - x) * x powr (real (Suc n) - 1 / 2))\n\ngoal (1 subgoal):\n 1. u x * v' x = c * (4 * i n x - i (Suc n) x)", "by (simp add: i_def)"], ["proof (state)\nthis:\n  u x * v' x = c * (4 * i n x - i (Suc n) x)\n\ngoal (2 subgoals):\n 1. negligible {0}\n 2. ((\\<lambda>x. c * (4 * i n x - i (Suc n) x)) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. negligible {0}\n 2. ((\\<lambda>x. c * (4 * i n x - i (Suc n) x)) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "have \"((\\<lambda>x. c * (4 * i n x - i (Suc n) x)) has_integral c * (4 * I n - I (Suc n))) {0..4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. c * (4 * i n x - i (Suc n) x)) has_integral\n     c * (4 * I n - I (Suc n)))\n     {0..4}", "unfolding i_def I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         c *\n         (4 * (x powr (real n - 1 / 2) * sqrt (4 - x)) -\n          x powr (real (Suc n) - 1 / 2) * sqrt (4 - x))) has_integral\n     c *\n     (4 *\n      integral {0..4} (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) -\n      integral {0..4}\n       (\\<lambda>x. x powr (real (Suc n) - 1 / 2) * sqrt (4 - x))))\n     {0..4}", "by (intro has_integral_mult_right has_integral_diff integrable_integral integrable_I)"], ["proof (state)\nthis:\n  ((\\<lambda>x. c * (4 * i n x - i (Suc n) x)) has_integral\n   c * (4 * I n - I (Suc n)))\n   {0..4}\n\ngoal (2 subgoals):\n 1. negligible {0}\n 2. ((\\<lambda>x. c * (4 * i n x - i (Suc n) x)) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "thus \"((\\<lambda>x. c * (4 * i n x - i (Suc n) x)) has_integral  u 4 * v 4 - u 0 * v 0 - -\n               c * (4 * I n - I (Suc n))) {0..4}\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. c * (4 * i n x - i (Suc n) x)) has_integral\n   c * (4 * I n - I (Suc n)))\n   {0..4}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. c * (4 * i n x - i (Suc n) x)) has_integral\n     u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n     {0..4}", "by (simp add: u_def v_def)"], ["proof (state)\nthis:\n  ((\\<lambda>x. c * (4 * i n x - i (Suc n) x)) has_integral\n   u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n   {0..4}\n\ngoal (1 subgoal):\n 1. negligible {0}", "qed simp_all"], ["proof (state)\nthis:\n  ((\\<lambda>x. u x * v' x) has_integral\n   u 4 * v 4 - u 0 * v 0 - - c * (4 * I n - I (Suc n)))\n   {0..4}\n\ngoal (1 subgoal):\n 1. 0 \\<le> 4", "qed simp_all"], ["proof (state)\nthis:\n  ((\\<lambda>x. u' x * v x) has_integral - c * (4 * I n - I (Suc n))) {0..4}\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. u' x * v x) has_integral - c * (4 * I n - I (Suc n))) {0..4}\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "have \"(\\<lambda>x. u' x * v x) = i (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. u' x * v x) = i (Suc n)", "by (rule ext) (simp add: u'_def v_def i_def algebra_simps)"], ["proof (state)\nthis:\n  (\\<lambda>x. u' x * v x) = i (Suc n)\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "finally"], ["proof (chain)\npicking this:\n  (i (Suc n) has_integral - c * (4 * I n - I (Suc n))) {0..4}", "have \"I (Suc n) = - c * (4 * I n - I (Suc n))\""], ["proof (prove)\nusing this:\n  (i (Suc n) has_integral - c * (4 * I n - I (Suc n))) {0..4}\n\ngoal (1 subgoal):\n 1. I (Suc n) = - c * (4 * I n - I (Suc n))", "unfolding I_def i_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. x powr (real (Suc n) - 1 / 2) * sqrt (4 - x)) has_integral\n   - c *\n   (4 *\n    integral {0..4} (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) -\n    integral {0..4}\n     (\\<lambda>x. x powr (real (Suc n) - 1 / 2) * sqrt (4 - x))))\n   {0..4}\n\ngoal (1 subgoal):\n 1. integral {0..4}\n     (\\<lambda>x. x powr (real (Suc n) - 1 / 2) * sqrt (4 - x)) =\n    - c *\n    (4 *\n     integral {0..4} (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) -\n     integral {0..4}\n      (\\<lambda>x. x powr (real (Suc n) - 1 / 2) * sqrt (4 - x)))", "by blast"], ["proof (state)\nthis:\n  I (Suc n) = - c * (4 * I n - I (Suc n))\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "hence \"(1 - c) * I (Suc n) = -4 * c * I n\""], ["proof (prove)\nusing this:\n  I (Suc n) = - c * (4 * I n - I (Suc n))\n\ngoal (1 subgoal):\n 1. (1 - c) * I (Suc n) = - 4 * c * I n", "by algebra"], ["proof (state)\nthis:\n  (1 - c) * I (Suc n) = - 4 * c * I n\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "hence \"I (Suc n) = (-4 * c) / (1 - c) * I n\""], ["proof (prove)\nusing this:\n  (1 - c) * I (Suc n) = - 4 * c * I n\n\ngoal (1 subgoal):\n 1. I (Suc n) = - 4 * c / (1 - c) * I n", "by (simp add: field_simps c_def)"], ["proof (state)\nthis:\n  I (Suc n) = - 4 * c / (1 - c) * I n\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "also"], ["proof (state)\nthis:\n  I (Suc n) = - 4 * c / (1 - c) * I n\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "have \"(-4 * c) / (1 - c) = real (2*(2*n + 1)) / real (n + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 4 * c / (1 - c) = real (2 * (2 * n + 1)) / real (n + 2)", "by (simp add: c_def field_simps)"], ["proof (state)\nthis:\n  - 4 * c / (1 - c) = real (2 * (2 * n + 1)) / real (n + 2)\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "finally"], ["proof (chain)\npicking this:\n  I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "show ?thesis"], ["proof (prove)\nusing this:\n  I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n\n\ngoal (1 subgoal):\n 1. I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n", "."], ["proof (state)\nthis:\n  I (Suc n) = real (2 * (2 * n + 1)) / real (n + 2) * I n\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma catalan_eq_I: \"real (catalan n) = I n / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (catalan n) = I n / (2 * pi)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. real (catalan 0) = I 0 / (2 * pi)\n 2. \\<And>n.\n       real (catalan n) = I n / (2 * pi) \\<Longrightarrow>\n       real (catalan (Suc n)) = I (Suc n) / (2 * pi)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. real (catalan 0) = I 0 / (2 * pi)\n 2. \\<And>n.\n       real (catalan n) = I n / (2 * pi) \\<Longrightarrow>\n       real (catalan (Suc n)) = I (Suc n) / (2 * pi)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (catalan 0) = I 0 / (2 * pi)", "using has_integral_I0"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. x powr - (1 / 2) * sqrt (4 - x)) has_integral 2 * pi) {0..4}\n\ngoal (1 subgoal):\n 1. real (catalan 0) = I 0 / (2 * pi)", "by (simp add: I_def integral_unique)"], ["proof (state)\nthis:\n  real (catalan 0) = I 0 / (2 * pi)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       real (catalan n) = I n / (2 * pi) \\<Longrightarrow>\n       real (catalan (Suc n)) = I (Suc n) / (2 * pi)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       real (catalan n) = I n / (2 * pi) \\<Longrightarrow>\n       real (catalan (Suc n)) = I (Suc n) / (2 * pi)", "case (Suc n)"], ["proof (state)\nthis:\n  real (catalan n) = I n / (2 * pi)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       real (catalan n) = I n / (2 * pi) \\<Longrightarrow>\n       real (catalan (Suc n)) = I (Suc n) / (2 * pi)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (catalan (Suc n)) = I (Suc n) / (2 * pi)", "by (simp add: of_nat_catalan_Suc' Suc.IH I_Suc)"], ["proof (state)\nthis:\n  real (catalan (Suc n)) = I (Suc n) / (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem catalan_integral_form:\n  \"((\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x) / (2*pi)) \n       has_integral real (catalan n)) {0..4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (real n - 1 / 2) * sqrt (4 - x) / (2 * pi)) has_integral\n     real (catalan n))\n     {0..4}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (real n - 1 / 2) * sqrt (4 - x) / (2 * pi)) has_integral\n     real (catalan n))\n     {0..4}", "have \"((\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x) * inverse (2*pi)) has_integral \n           I n * inverse (2 * pi)) {0..4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (real n - 1 / 2) * sqrt (4 - x) *\n         inverse (2 * pi)) has_integral\n     I n * inverse (2 * pi))\n     {0..4}", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (real n - 1 / 2) * sqrt (4 - x) *\n         inverse (2 * pi)) has_integral\n     integral {0..4} (\\<lambda>x. x powr (real n - 1 / 2) * sqrt (4 - x)) *\n     inverse (2 * pi))\n     {0..4}", "by (intro has_integral_mult_left integrable_integral integrable_I)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       x powr (real n - 1 / 2) * sqrt (4 - x) *\n       inverse (2 * pi)) has_integral\n   I n * inverse (2 * pi))\n   {0..4}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (real n - 1 / 2) * sqrt (4 - x) / (2 * pi)) has_integral\n     real (catalan n))\n     {0..4}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       x powr (real n - 1 / 2) * sqrt (4 - x) *\n       inverse (2 * pi)) has_integral\n   I n * inverse (2 * pi))\n   {0..4}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         x powr (real n - 1 / 2) * sqrt (4 - x) / (2 * pi)) has_integral\n     real (catalan n))\n     {0..4}", "by (simp add: catalan_eq_I field_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       x powr (real n - 1 / 2) * sqrt (4 - x) / (2 * pi)) has_integral\n   real (catalan n))\n   {0..4}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Asymptotics\\<close>"], ["", "text \\<open>\n  Using the closed form $C_n = 2 \\cdot (-4)^n {\\frac{1}{2} \\choose n+1}$ and the fact that\n  ${\\alpha \\choose n} \\sim \\frac{(-1)^n}{\\Gamma(-\\alpha) n^{\\alpha + 1}}$ for any\n  $\\alpha \\notin \\mathbb{N}$, wwe can now easily analyse the asymptotic behaviour of the\n  Catalan numbers:\n\\<close>"], ["", "theorem catalan_asymptotics:\n  \"catalan \\<sim>[at_top] (\\<lambda>n. 4 ^ n / (sqrt pi * n powr (3/2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real\n         (catalan\n           x)) \\<sim>[sequentially] (\\<lambda>n.\n  4 ^ n / (sqrt pi * real n powr (3 / 2)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real\n         (catalan\n           x)) \\<sim>[sequentially] (\\<lambda>n.\n  4 ^ n / (sqrt pi * real n powr (3 / 2)))", "have \"catalan \\<sim>[at_top] (\\<lambda>n. 2 * (- 4) ^ n * (1/2 gchoose (n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real\n         (catalan\n           x)) \\<sim>[sequentially] (\\<lambda>n.\n  2 * (- 4) ^ n * (1 / 2 gchoose (n + 1)))", "by (subst catalan_closed_form_gbinomial) simp_all"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      real\n       (catalan\n         x)) \\<sim>[sequentially] (\\<lambda>n.\n2 * (- 4) ^ n * (1 / 2 gchoose (n + 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real\n         (catalan\n           x)) \\<sim>[sequentially] (\\<lambda>n.\n  4 ^ n / (sqrt pi * real n powr (3 / 2)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      real\n       (catalan\n         x)) \\<sim>[sequentially] (\\<lambda>n.\n2 * (- 4) ^ n * (1 / 2 gchoose (n + 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real\n         (catalan\n           x)) \\<sim>[sequentially] (\\<lambda>n.\n  4 ^ n / (sqrt pi * real n powr (3 / 2)))", "have \"(\\<lambda>n. 1/2 gchoose (n+1)) \\<sim>[at_top] (\\<lambda>n. (-1)^(n+1) / (Gamma (-(1/2)) * real n powr (1/2 + 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        1 / 2 gchoose\n        (n +\n         1)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + 1) / (Gamma (- (1 / 2)) * real n powr (1 / 2 + 1)))", "using fraction_not_in_nats[of 2 1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_unit 2; 2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> of_int 1 / of_int 2 \\<notin> \\<nat>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        1 / 2 gchoose\n        (n +\n         1)) \\<sim>[sequentially] (\\<lambda>n.\n(- 1) ^ (n + 1) / (Gamma (- (1 / 2)) * real n powr (1 / 2 + 1)))", "by (intro asymp_equiv_intros gbinomial_asymptotic') simp_all"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      1 / 2 gchoose\n      (n +\n       1)) \\<sim>[sequentially] (\\<lambda>n.\n                                    (- 1) ^ (n + 1) /\n                                    (Gamma (- (1 / 2)) *\n                                     real n powr (1 / 2 + 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real\n         (catalan\n           x)) \\<sim>[sequentially] (\\<lambda>n.\n  4 ^ n / (sqrt pi * real n powr (3 / 2)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      1 / 2 gchoose\n      (n +\n       1)) \\<sim>[sequentially] (\\<lambda>n.\n                                    (- 1) ^ (n + 1) /\n                                    (Gamma (- (1 / 2)) *\n                                     real n powr (1 / 2 + 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real\n         (catalan\n           x)) \\<sim>[sequentially] (\\<lambda>n.\n  4 ^ n / (sqrt pi * real n powr (3 / 2)))", "have \"(\\<lambda>n. 2 * (- 4) ^ n * \\<dots> n) = (\\<lambda>n. 4 ^ n / (sqrt pi * n powr (3/2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        2 * (- 4) ^ n *\n        ((- 1) ^ (n + 1) / (Gamma (- (1 / 2)) * real n powr (1 / 2 + 1)))) =\n    (\\<lambda>n. 4 ^ n / (sqrt pi * real n powr (3 / 2)))", "by (intro ext) (simp add: Gamma_minus_one_half_real power_mult_distrib [symmetric])"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      2 * (- 4) ^ n *\n      ((- 1) ^ (n + 1) / (Gamma (- (1 / 2)) * real n powr (1 / 2 + 1)))) =\n  (\\<lambda>n. 4 ^ n / (sqrt pi * real n powr (3 / 2)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real\n         (catalan\n           x)) \\<sim>[sequentially] (\\<lambda>n.\n  4 ^ n / (sqrt pi * real n powr (3 / 2)))", "finally"], ["proof (chain)\npicking this:\n  (\\<And>c d.\n      c \\<sim>[sequentially] d \\<Longrightarrow>\n      (\\<lambda>a.\n          2 * (- 4) ^ a *\n          c a) \\<sim>[sequentially] (\\<lambda>a.\n  2 * (- 4) ^ a * d a)) \\<Longrightarrow>\n  (\\<lambda>x.\n      real\n       (catalan\n         x)) \\<sim>[sequentially] (\\<lambda>a.\n4 ^ a / (sqrt pi * real a powr (3 / 2)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>c d.\n      c \\<sim>[sequentially] d \\<Longrightarrow>\n      (\\<lambda>a.\n          2 * (- 4) ^ a *\n          c a) \\<sim>[sequentially] (\\<lambda>a.\n  2 * (- 4) ^ a * d a)) \\<Longrightarrow>\n  (\\<lambda>x.\n      real\n       (catalan\n         x)) \\<sim>[sequentially] (\\<lambda>a.\n4 ^ a / (sqrt pi * real a powr (3 / 2)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        real\n         (catalan\n           x)) \\<sim>[sequentially] (\\<lambda>n.\n  4 ^ n / (sqrt pi * real n powr (3 / 2)))", "by - (simp_all add: asymp_equiv_intros)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      real\n       (catalan\n         x)) \\<sim>[sequentially] (\\<lambda>n.\n4 ^ n / (sqrt pi * real n powr (3 / 2)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Relation to binary trees\\<close>"], ["", "(*<*)"], ["", "context\nbegin"], ["", "(*>*)"], ["", "text \\<open>\n  It is well-known that the Catalan number $C_n$ is the number of rooted binary trees with\n  $n$ internal nodes (where internal nodes are those with two children and external nodes\n  are those with no children).\n\n  We will briefly show this here to show that the above asymptotic formula also describes the\n  number of binary trees of a given size.\n\\<close>"], ["", "qualified"], ["", "datatype tree = Leaf | Node tree tree"], ["", "qualified"], ["", "primrec count_nodes :: \"tree \\<Rightarrow> nat\" where\n  \"count_nodes Leaf = 0\"\n| \"count_nodes (Node l r) = 1 + count_nodes l + count_nodes r\""], ["", "qualified"], ["", "definition trees_of_size :: \"nat \\<Rightarrow> tree set\" where\n  \"trees_of_size n = {t. count_nodes t = n}\""], ["", "lemma count_nodes_eq_0_iff [simp]: \"count_nodes t = 0 \\<longleftrightarrow> t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (count_nodes t = 0) = (t = Leaf)", "by (cases t) simp_all"], ["", "lemma trees_of_size_0 [simp]: \"trees_of_size 0 = {Leaf}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trees_of_size 0 = {Leaf}", "by (simp add: trees_of_size_def)"], ["", "lemma trees_of_size_Suc:\n  \"trees_of_size (Suc n) = (\\<lambda>(l,r). Node l r) ` (\\<Union>k\\<le>n. trees_of_size k \\<times> trees_of_size (n - k))\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trees_of_size (Suc n) =\n    (\\<lambda>(l, r). Node l r) `\n    (\\<Union>k\\<le>n. trees_of_size k \\<times> trees_of_size (n - k))", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> trees_of_size (Suc n)) =\n       (x \\<in> (\\<lambda>(l, r). Node l r) `\n                (\\<Union>k\\<le>n.\n                    trees_of_size k \\<times> trees_of_size (n - k)))", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> trees_of_size (Suc n)) =\n       (x \\<in> (\\<lambda>(l, r). Node l r) `\n                (\\<Union>k\\<le>n.\n                    trees_of_size k \\<times> trees_of_size (n - k)))", "show \"t \\<in> ?lhs \\<longleftrightarrow> t \\<in> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<in> trees_of_size (Suc n)) =\n    (t \\<in> (\\<lambda>(l, r). Node l r) `\n             (\\<Union>k\\<le>n.\n                 trees_of_size k \\<times> trees_of_size (n - k)))", "by (cases t) (auto simp: trees_of_size_def)"], ["proof (state)\nthis:\n  (t \\<in> trees_of_size (Suc n)) =\n  (t \\<in> (\\<lambda>(l, r). Node l r) `\n           (\\<Union>k\\<le>n.\n               trees_of_size k \\<times> trees_of_size (n - k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_trees_of_size [simp,intro]: \"finite (trees_of_size n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (trees_of_size n)", "by (induction n rule: catalan.induct)\n     (auto simp: trees_of_size_Suc intro!: finite_imageI finite_cartesian_product)"], ["", "lemma trees_of_size_nonempty: \"trees_of_size n \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trees_of_size n \\<noteq> {}", "by (induction n rule: catalan.induct) (auto simp: trees_of_size_Suc)"], ["", "lemma trees_of_size_disjoint:\n  assumes \"m \\<noteq> n\"\n  shows   \"trees_of_size m \\<inter> trees_of_size n = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trees_of_size m \\<inter> trees_of_size n = {}", "using assms"], ["proof (prove)\nusing this:\n  m \\<noteq> n\n\ngoal (1 subgoal):\n 1. trees_of_size m \\<inter> trees_of_size n = {}", "by (auto simp: trees_of_size_def)"], ["", "theorem card_trees_of_size: \"card (trees_of_size n) = catalan n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (trees_of_size n) = catalan n", "by (induction n rule: catalan.induct)\n     (simp_all add: catalan_Suc trees_of_size_Suc card_image inj_on_def\n        trees_of_size_disjoint Times_Int_Times catalan_Suc card_UN_disjoint)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"], ["", "subsection \\<open>Efficient computation\\<close>"], ["", "(*<*)"], ["", "context\nbegin"], ["", "(*>*)"], ["", "text \\<open>\n  We shall now prove code equations that allow more efficient computation of Catalan numbers.\n  In order to do this, we define a tail-recursive function that uses the recurrence\n  @{thm catalan_Suc'[no_vars]}:\n\\<close>"], ["", "qualified"], ["", "function catalan_aux where [simp del]:\n  \"catalan_aux n k acc =\n     (if k \\<ge> n then acc else catalan_aux n (Suc k) ((acc * (2*(2*k+1))) div (k+2)))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>n k acc.\n           x = (n, k, acc) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>n k acc na ka acca.\n       (n, k, acc) = (na, ka, acca) \\<Longrightarrow>\n       (if n \\<le> k then acc\n        else catalan_aux_sumC\n              (n, Suc k, acc * (2 * (2 * k + 1)) div (k + 2))) =\n       (if na \\<le> ka then acca\n        else catalan_aux_sumC\n              (na, Suc ka, acca * (2 * (2 * ka + 1)) div (ka + 2)))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All catalan_aux_dom", "by (relation \"Wellfounded.measure (\\<lambda>(a,b,_). a - b)\") simp_all"], ["", "qualified"], ["", "lemma catalan_aux_simps:\n  \"k \\<ge> n \\<Longrightarrow> catalan_aux n k acc = acc\"\n  \"k < n \\<Longrightarrow> catalan_aux n k acc = catalan_aux n (Suc k) ((acc * (2*(2*k+1))) div (k+2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n \\<le> k \\<Longrightarrow> catalan_aux n k acc = acc) &&&\n    (k < n \\<Longrightarrow>\n     catalan_aux n k acc =\n     catalan_aux n (Suc k) (acc * (2 * (2 * k + 1)) div (k + 2)))", "by (subst catalan_aux.simps, simp)+"], ["", "qualified"], ["", "lemma catalan_aux_correct:\n  assumes \"k \\<le> n\"\n  shows   \"catalan_aux n k (catalan k) = catalan n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catalan_aux n k (catalan k) = catalan n", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. catalan_aux n k (catalan k) = catalan n", "proof (induction n k \"catalan k\" rule: catalan_aux.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n k.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> k;\n                 catalan k * (2 * (2 * k + 1)) div (k + 2) =\n                 catalan (Suc k);\n                 Suc k \\<le> n\\<rbrakk>\n                \\<Longrightarrow> catalan_aux n (Suc k) (catalan (Suc k)) =\n                                  catalan n;\n        k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> catalan_aux n k (catalan k) = catalan n", "case (1 n k)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> n \\<le> k;\n   catalan k * (2 * (2 * k + 1)) div (k + 2) = catalan (Suc k);\n   Suc k \\<le> n\\<rbrakk>\n  \\<Longrightarrow> catalan_aux n (Suc k) (catalan (Suc k)) = catalan n\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>n k.\n       \\<lbrakk>\\<lbrakk>\\<not> n \\<le> k;\n                 catalan k * (2 * (2 * k + 1)) div (k + 2) =\n                 catalan (Suc k);\n                 Suc k \\<le> n\\<rbrakk>\n                \\<Longrightarrow> catalan_aux n (Suc k) (catalan (Suc k)) =\n                                  catalan n;\n        k \\<le> n\\<rbrakk>\n       \\<Longrightarrow> catalan_aux n k (catalan k) = catalan n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. catalan_aux n k (catalan k) = catalan n", "proof (cases \"k < n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow> catalan_aux n k (catalan k) = catalan n\n 2. \\<not> k < n \\<Longrightarrow> catalan_aux n k (catalan k) = catalan n", "case True"], ["proof (state)\nthis:\n  k < n\n\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow> catalan_aux n k (catalan k) = catalan n\n 2. \\<not> k < n \\<Longrightarrow> catalan_aux n k (catalan k) = catalan n", "hence \"catalan_aux n k (catalan k) = catalan_aux n (Suc k) (catalan (Suc k))\""], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. catalan_aux n k (catalan k) = catalan_aux n (Suc k) (catalan (Suc k))", "by (subst catalan_Suc') (simp_all add: catalan_aux_simps)"], ["proof (state)\nthis:\n  catalan_aux n k (catalan k) = catalan_aux n (Suc k) (catalan (Suc k))\n\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow> catalan_aux n k (catalan k) = catalan n\n 2. \\<not> k < n \\<Longrightarrow> catalan_aux n k (catalan k) = catalan n", "with 1 True"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> n \\<le> k;\n   catalan k * (2 * (2 * k + 1)) div (k + 2) = catalan (Suc k);\n   Suc k \\<le> n\\<rbrakk>\n  \\<Longrightarrow> catalan_aux n (Suc k) (catalan (Suc k)) = catalan n\n  k \\<le> n\n  k < n\n  catalan_aux n k (catalan k) = catalan_aux n (Suc k) (catalan (Suc k))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> n \\<le> k;\n   catalan k * (2 * (2 * k + 1)) div (k + 2) = catalan (Suc k);\n   Suc k \\<le> n\\<rbrakk>\n  \\<Longrightarrow> catalan_aux n (Suc k) (catalan (Suc k)) = catalan n\n  k \\<le> n\n  k < n\n  catalan_aux n k (catalan k) = catalan_aux n (Suc k) (catalan (Suc k))\n\ngoal (1 subgoal):\n 1. catalan_aux n k (catalan k) = catalan n", "by (simp add: catalan_Suc')"], ["proof (state)\nthis:\n  catalan_aux n k (catalan k) = catalan n\n\ngoal (1 subgoal):\n 1. \\<not> k < n \\<Longrightarrow> catalan_aux n k (catalan k) = catalan n", "qed (insert \"1.prems\", simp_all add: catalan_aux_simps)"], ["proof (state)\nthis:\n  catalan_aux n k (catalan k) = catalan n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma catalan_code [code]: \"catalan n = catalan_aux n 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catalan n = catalan_aux n 0 1", "using catalan_aux_correct[of 0 n]"], ["proof (prove)\nusing this:\n  0 \\<le> n \\<Longrightarrow> catalan_aux n 0 (catalan 0) = catalan n\n\ngoal (1 subgoal):\n 1. catalan n = catalan_aux n 0 1", "by simp"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"], ["", "end"]]}