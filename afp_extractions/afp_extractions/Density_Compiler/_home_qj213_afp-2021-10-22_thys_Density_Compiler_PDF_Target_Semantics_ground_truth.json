{"file_name": "/home/qj213/afp-2021-10-22/thys/Density_Compiler/PDF_Target_Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Density_Compiler", "problem_names": ["lemma cet_val': \"t = val_type v \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c CVal v : t\"", "lemma cet_var': \"t = \\<Gamma> x \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c CVar x : t\"", "lemma cet_not: \"\\<Gamma> \\<turnstile>\\<^sub>c e : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c \\<not>\\<^sub>c e : BOOL\"", "lemma cet_and: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 \\<and>\\<^sub>c e2 : BOOL\" and\n      cet_or: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 \\<or>\\<^sub>c e2 : BOOL\"", "lemma cet_minus_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c -\\<^sub>ce : REAL\" and\n      cet_inverse: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c inverse\\<^sub>c e : REAL\" and\n      cet_sqrt: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c sqrt\\<^sub>c e : REAL\" and\n      cet_exp: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c exp\\<^sub>c e : REAL\" and\n      cet_ln: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c ln\\<^sub>c e : REAL\"", "lemma cet_pow_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 ^\\<^sub>c e2 : REAL\"", "lemma cet_add_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 +\\<^sub>c e2 : REAL\" and\n      cet_mult_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 *\\<^sub>c e2 : REAL\" and\n      cet_less_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 <\\<^sub>c e2 : BOOL\"", "lemma cet_eq: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : t \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : t \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 =\\<^sub>c e2 : BOOL\"", "lemma cet_less_eq_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 \\<le>\\<^sub>c e2 : BOOL\"", "lemma cet_minus_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c -\\<^sub>ce : INTEG\"", "lemma cet_add_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 +\\<^sub>c e2 : INTEG\" and\n      cet_mult_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 *\\<^sub>c e2 : INTEG\" and\n      cet_less_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 <\\<^sub>c e2 : BOOL\"", "lemma cet_less_eq_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 \\<le>\\<^sub>c e2 : BOOL\"", "lemma cet_sub_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 -\\<^sub>c e2 : INTEG\"", "lemma cet_fst: \"\\<Gamma> \\<turnstile>\\<^sub>c e : PRODUCT t t' \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c fst\\<^sub>c e : t\" and\n      cet_snd: \"\\<Gamma> \\<turnstile>\\<^sub>c e : PRODUCT t t' \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c snd\\<^sub>c e : t'\"", "lemma cet_cast_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c \\<langle>e\\<rangle>\\<^sub>c : REAL\"", "lemma cet_cast_real_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c \\<langle>e\\<rangle>\\<^sub>c : REAL\"", "lemma cet_sub_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 -\\<^sub>c e2 : REAL\"", "lemma cet_pi: \"\\<Gamma> \\<turnstile>\\<^sub>c \\<pi>\\<^sub>c : REAL\"", "lemmas cet_op_intros =\n  cet_minus_real cet_exp cet_sqrt cet_ln cet_inverse cet_pow_real cet_pi\n  cet_cast_real cet_add_real cet_mult_real cet_less_real\n  cet_not cet_and cet_or", "lemma cexpr_type_Some_iff: \"cexpr_type \\<Gamma> e = Some t \\<longleftrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e : t\"", "lemmas cexpr_typing_code[code_unfold] = cexpr_type_Some_iff[symmetric]", "lemma cexpr_typing_cong':\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e : t\" \"\\<And>x. x \\<in> free_vars e \\<Longrightarrow> \\<Gamma> x = \\<Gamma>' x\"\n  shows \"\\<Gamma>' \\<turnstile>\\<^sub>c e : t\"", "lemma cexpr_typing_cong:\n  assumes \"\\<And>x. x \\<in> free_vars e \\<Longrightarrow> \\<Gamma> x = \\<Gamma>' x\"\n  shows \"\\<Gamma> \\<turnstile>\\<^sub>c e : t \\<longleftrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c e : t\"", "lemma cexpr_equiv_commute: \"cexpr_equiv e1 e2 \\<longleftrightarrow> cexpr_equiv e2 e1\"", "lemma val_type_cexpr_sem[simp]:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e : t\" \"free_vars e \\<subseteq> V\" \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\"\n  shows \"val_type (cexpr_sem \\<sigma> e) = t\"", "lemma cexpr_sem_eq_on_vars:\n  assumes \"\\<And>x. x \\<in> free_vars e \\<Longrightarrow> \\<sigma> x = \\<sigma>' x\"\n  shows \"cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e\"", "lemma measurable_cexpr_sem[measurable]:\n  \"\\<Gamma> \\<turnstile>\\<^sub>c e : t \\<Longrightarrow> free_vars e \\<subseteq> V \\<Longrightarrow>\n      (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e) \\<in> measurable (state_measure V \\<Gamma>) (stock_measure t)\"", "lemma measurable_eval_cexpr[measurable]:\n  assumes \"case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\"\n  assumes \"free_vars e \\<subseteq> shift_var_set V\"\n  shows \"case_prod (eval_cexpr e) \\<in> borel_measurable (state_measure V \\<Gamma> \\<Otimes>\\<^sub>M stock_measure t)\"", "lemma cexpr_sem_Add:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\"\n  assumes \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\" \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  shows \"extract_real (cexpr_sem \\<sigma> (e1 +\\<^sub>c e2)) = extract_real (cexpr_sem \\<sigma> e1) + extract_real (cexpr_sem \\<sigma> e2)\"", "lemma cexpr_sem_Mult:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\"\n  assumes \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\" \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  shows \"extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2)) = extract_real (cexpr_sem \\<sigma> e1) * extract_real (cexpr_sem \\<sigma> e2)\"", "lemma free_vars_map_vars[simp]:\n  \"free_vars (map_vars f e) = f ` free_vars e\"", "lemma cexpr_typing_map_vars:\n  \"\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e : t \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c map_vars f e : t\"", "lemma cexpr_sem_map_vars:\n  \"cexpr_sem \\<sigma> (map_vars f e) = cexpr_sem (\\<sigma> \\<circ> f) e\"", "lemma insert_var_0[simp]: \"insert_var 0 f x = case_nat x f\"", "lemma cexpr_sem_cexpr_subst_aux:\n    \"cexpr_sem \\<sigma> (cexpr_subst x e e') = cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e)) e'\"", "lemma cexpr_sem_cexpr_subst:\n    \"cexpr_sem \\<sigma> (cexpr_subst 0 e e') = cexpr_sem (case_nat (cexpr_sem \\<sigma> e) \\<sigma>) e'\"", "lemma cexpr_typing_subst_aux:\n  assumes \"insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e' : t'\" \"\\<Gamma> \\<turnstile>\\<^sub>c e : t\"\n  shows \"\\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst x e e' : t'\"", "lemma cexpr_typing_subst[intro]:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e : t\" \"case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e' : t'\"\n  shows \"\\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst 0 e e' : t'\"", "lemma free_vars_cexpr_subst_aux:\n  \"free_vars (cexpr_subst x e e') \\<subseteq> (\\<lambda>y. if y \\<ge> x then y + 1 else y) -` free_vars e' \\<union> free_vars e\"\n    (is \"free_vars _ \\<subseteq> ?f x -` _ \\<union> _\")", "lemma free_vars_cexpr_subst:\n    \"free_vars (cexpr_subst 0 e e') \\<subseteq> Suc -` free_vars e' \\<union> free_vars e\"", "lemma cexpr_sem_cexpr_comp_aux:\n    \"cexpr_sem \\<sigma> (cexpr_comp_aux x e e') = cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'\"", "lemma cexpr_typing_cexpr_comp_aux:\n  assumes \"\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2\" \"\\<Gamma> \\<turnstile>\\<^sub>c e : t1\"\n  shows \"\\<Gamma> \\<turnstile>\\<^sub>c cexpr_comp_aux x e e' : t2\"", "lemma cexpr_typing_cexpr_comp[intro]:\n  assumes \"case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c g : t2\"\n  assumes \"case_nat t2 \\<Gamma> \\<turnstile>\\<^sub>c f : t3\"\n  shows \"case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c f \\<circ>\\<^sub>c g : t3\"", "lemma free_vars_cexpr_comp_aux:\n  \"free_vars (cexpr_comp_aux x e e') \\<subseteq> (free_vars e' - {x}) \\<union> free_vars e\"", "lemma free_vars_cexpr_comp:\n  \"free_vars (cexpr_comp e e') \\<subseteq> (free_vars e - {0}) \\<union> free_vars e'\"", "lemma free_vars_cexpr_comp':\n  \"free_vars (cexpr_comp e e') \\<subseteq> free_vars e \\<union> free_vars e'\"", "lemma cexpr_sem_cexpr_comp:\n    \"cexpr_sem \\<sigma> (f \\<circ>\\<^sub>c g) = cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> g)) f\"", "lemma eval_cexpr_comp:\n    \"eval_cexpr (f \\<circ>\\<^sub>c g) \\<sigma> x = eval_cexpr f \\<sigma> (cexpr_sem (case_nat x \\<sigma>) g)\"", "lemma cexpr_subst_val_aux_eq_cexpr_subst:\n    \"cexpr_subst_val_aux x e v = cexpr_subst x (CVal v) e\"", "lemma cexpr_sem_cexpr_subst_val[simp]:\n    \"cexpr_sem \\<sigma> (cexpr_subst_val e v) = cexpr_sem (case_nat v \\<sigma>) e\"", "lemma cexpr_typing_subst_val[intro]:\n    \"case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : t' \\<Longrightarrow> val_type v = t \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst_val e v : t'\"", "lemma free_vars_cexpr_subst_val_aux:\n    \"free_vars (cexpr_subst_val_aux x e v) = (\\<lambda>y. if y \\<ge> x then Suc y else y) -` free_vars e\"", "lemma free_vars_cexpr_subst_val[simp]:\n    \"free_vars (cexpr_subst_val e v) = Suc -` free_vars e\"", "lemma nonneg_cexprI:\n    \"(\\<And>\\<sigma>. \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow> extract_real (cexpr_sem \\<sigma> e) \\<ge> 0) \\<Longrightarrow> nonneg_cexpr V \\<Gamma> e\"", "lemma nonneg_cexprD:\n    \"nonneg_cexpr V \\<Gamma> e \\<Longrightarrow> \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow> extract_real (cexpr_sem \\<sigma> e) \\<ge> 0\"", "lemma nonneg_cexpr_map_vars:\n  assumes \"nonneg_cexpr (f -` V) (\\<Gamma> \\<circ> f) e\"\n  shows \"nonneg_cexpr V \\<Gamma> (map_vars f e)\"", "lemma nonneg_cexpr_subset:\n  assumes \"nonneg_cexpr V \\<Gamma> e\" \"V \\<subseteq> V'\" \"free_vars e \\<subseteq> V\"\n  shows \"nonneg_cexpr V' \\<Gamma> e\"", "lemma nonneg_cexpr_Mult:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\"\n  assumes \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  assumes N1: \"nonneg_cexpr V \\<Gamma> e1\" and N2: \"nonneg_cexpr V \\<Gamma> e2\"\n  shows \"nonneg_cexpr V \\<Gamma> (e1 *\\<^sub>c e2)\"", "lemma nonneg_indicator:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e : BOOL\" \"free_vars e \\<subseteq> V\"\n  shows \"nonneg_cexpr V \\<Gamma> (\\<langle>e\\<rangle>\\<^sub>c)\"", "lemma nonneg_cexpr_comp_aux:\n  assumes nonneg: \"nonneg_cexpr V (\\<Gamma>(x := t1)) e\"  and x:\"x \\<in> V\"\n  assumes t2: \"\\<Gamma>(x:=t1) \\<turnstile>\\<^sub>c e : t2\" and t1: \"\\<Gamma> \\<turnstile>\\<^sub>c f : t1\" and vars: \"free_vars f \\<subseteq> V\"\n  shows \"nonneg_cexpr V \\<Gamma> (cexpr_comp_aux x f e)\"", "lemma nonneg_cexpr_comp:\n  assumes \"nonneg_cexpr (shift_var_set V) (case_nat t2 \\<Gamma>) e\"\n  assumes \"case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c f : t2\" \"free_vars f \\<subseteq> shift_var_set V\"\n  shows \"nonneg_cexpr (shift_var_set V) (case_nat t1 \\<Gamma>) (e \\<circ>\\<^sub>c f)\"", "lemma nonneg_cexpr_subst_val:\n  assumes \"nonneg_cexpr (shift_var_set V) (case_nat t \\<Gamma>) e\" \"val_type v = t\"\n  shows \"nonneg_cexpr V \\<Gamma> (cexpr_subst_val e v)\"", "lemma nonneg_cexpr_int:\n  assumes \"nonneg_cexpr (shift_var_set V) (case_nat t \\<Gamma>) e\"\n  shows \"nonneg_cexpr V \\<Gamma> (\\<integral>\\<^sub>c e \\<partial>t)\"", "lemma subprob_cexprI:\n  assumes \"\\<And>\\<rho>. \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n                 (\\<integral>\\<^sup>+\\<sigma>. extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure V \\<Gamma>) \\<le> 1\"\n  shows \"subprob_cexpr V V' \\<Gamma> e\"", "lemma subprob_cexprD:\n  assumes \"subprob_cexpr V V' \\<Gamma> e\"\n  shows \"\\<And>\\<rho>. \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n               (\\<integral>\\<^sup>+\\<sigma>. extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure V \\<Gamma>) \\<le> 1\"", "lemma subprob_indicator:\n  assumes subprob: \"subprob_cexpr V V' \\<Gamma> e1\" and nonneg: \"nonneg_cexpr (V \\<union> V') \\<Gamma> e1\"\n  assumes t1: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL\" and t2: \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : BOOL\"\n  assumes vars1: \"free_vars e1 \\<subseteq> V \\<union> V'\" and vars2: \"free_vars e2 \\<subseteq> V \\<union> V'\"\n  shows \"subprob_cexpr V V' \\<Gamma> (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c)\"", "lemma measurable_cexpr_sem':\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  assumes e: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" \"free_vars e \\<subseteq> V \\<union> V'\"\n  shows \"(\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e))\n            \\<in> borel_measurable (state_measure V \\<Gamma>)\"", "lemma measurable_fun_upd_state_measure[measurable]:\n  assumes \"v \\<notin> V\"\n  shows \"(\\<lambda>(x,y). y(v := x)) \\<in> measurable (stock_measure (\\<Gamma> v) \\<Otimes>\\<^sub>M state_measure V \\<Gamma>)\n                                          (state_measure (insert v V) \\<Gamma>)\"", "lemma integrable_cexpr_projection:\n  assumes fin: \"finite V\"\n  assumes disjoint: \"V \\<inter> V' = {}\" \"v \\<notin> V\" \"v \\<notin> V'\"\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  assumes e: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" \"free_vars e \\<subseteq> insert v V \\<union> V'\"\n  assumes int: \"integrable (state_measure (insert v V) \\<Gamma>)\n                    (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\"\n                (is \"integrable _ ?f'\")\n  shows \"AE x in stock_measure (\\<Gamma> v).\n           integrable (state_measure V \\<Gamma>)\n               (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\"\n    (is \"AE x in ?N. integrable ?M (?f x)\")", "lemma cdens_ctxt_invarI:\n  \"\\<lbrakk>distinct (vs @ vs'); free_vars \\<delta> \\<subseteq> set (vs @ vs'); \\<Gamma> \\<turnstile>\\<^sub>c \\<delta> : REAL;\n    nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta>;\n    subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta> \\<rbrakk> \\<Longrightarrow>\n      cdens_ctxt_invar vs vs' \\<Gamma> \\<delta>\"", "lemma cdens_ctxt_invarD:\n  assumes \"cdens_ctxt_invar vs vs' \\<Gamma> \\<delta>\"\n  shows \"distinct (vs @ vs')\" \"free_vars \\<delta> \\<subseteq> set (vs @ vs')\" \"\\<Gamma> \\<turnstile>\\<^sub>c \\<delta> : REAL\"\n        \"nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta>\" \"subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>\"", "lemma cdens_ctxt_invar_empty:\n  assumes \"cdens_ctxt_invar vs vs' \\<Gamma> \\<delta>\"\n  shows \"cdens_ctxt_invar [] (vs @ vs') \\<Gamma> (CReal 1)\"", "lemma cdens_ctxt_invar_imp_integrable:\n  assumes \"cdens_ctxt_invar vs vs' \\<Gamma> \\<delta>\" and \\<rho>: \"\\<rho> \\<in> space (state_measure (set vs') \\<Gamma>)\"\n  shows \"integrable (state_measure (set vs) \\<Gamma>)\n             (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge (set vs) (set vs') (\\<sigma>, \\<rho>)) \\<delta>))\" (is \"integrable ?M ?f\")", "lemma cexpr_sem_expr_rf_to_cexpr:\n     \"randomfree e \\<Longrightarrow> cexpr_sem \\<sigma> (expr_rf_to_cexpr e) = expr_sem_rf \\<sigma> e\"", "lemma cexpr_typing_expr_rf_to_cexpr[intro]:\n    assumes \"\\<Gamma> \\<turnstile> e : t\" \"randomfree e\"\n    shows \"\\<Gamma> \\<turnstile>\\<^sub>c expr_rf_to_cexpr e : t\"", "lemma free_vars_expr_rf_to_cexpr:\n  \"randomfree e \\<Longrightarrow> free_vars (expr_rf_to_cexpr e) \\<subseteq> free_vars e\"", "lemma free_vars_dist_dens_cexpr:\n    \"free_vars (dist_dens_cexpr dst e1 e2) \\<subseteq> free_vars e1 \\<union> free_vars e2\"", "lemma cexpr_typing_dist_dens_cexpr:\n    assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst\"\n    shows \"\\<Gamma> \\<turnstile>\\<^sub>c dist_dens_cexpr dst e1 e2 : REAL\"", "lemma val_type_eq_BOOL: \"val_type x = BOOL \\<longleftrightarrow> x \\<in> BoolVal`UNIV\"", "lemma val_type_eq_INTEG: \"val_type x = INTEG \\<longleftrightarrow> x \\<in> IntVal`UNIV\"", "lemma val_type_eq_PRODUCT: \"val_type x = PRODUCT t1 t2 \\<longleftrightarrow>\n  (\\<exists>a b. val_type a = t1 \\<and> val_type b = t2 \\<and> x = <| a, b |>)\"", "lemma cexpr_sem_dist_dens_cexpr_nonneg:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst\"\n  assumes \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  assumes \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\"\n  shows \"ennreal (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n           dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2) \\<and>\n           0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))\"", "lemma cexpr_sem_dist_dens_cexpr:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst\"\n  assumes \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  assumes \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\"\n  shows \"ennreal (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n           dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2)\"", "lemma nonneg_dist_dens_cexpr:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst\"\n  assumes \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  shows \"nonneg_cexpr V \\<Gamma> (dist_dens_cexpr dst e1 e2)\"", "lemma cexpr_sem_integrate_var:\n  \"cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n    RealVal (\\<integral>x. extract_real (cexpr_sem (\\<sigma>(v := x)) e) \\<partial>stock_measure (\\<Gamma> v))\"", "lemma cexpr_sem_integrate_var':\n  \"extract_real (cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e)) =\n      (\\<integral>x. extract_real (cexpr_sem (\\<sigma>(v := x)) e) \\<partial>stock_measure (\\<Gamma> v))\"", "lemma cexpr_typing_integrate_var[simp]:\n    \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c integrate_var \\<Gamma> v e : REAL\"", "lemma cexpr_typing_integrate_vars[simp]:\n    \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c integrate_vars \\<Gamma> vs e : REAL\"", "lemma free_vars_integrate_var[simp]:\n    \"free_vars (integrate_var \\<Gamma> v e) = free_vars e - {v}\"", "lemma free_vars_integrate_vars[simp]:\n    \"free_vars (integrate_vars \\<Gamma> vs e) = free_vars e - set vs\"", "lemma (in product_sigma_finite) product_integral_insert':\n  fixes f :: \"_ \\<Rightarrow> real\"\n  assumes \"finite I\" \"i \\<notin> I\" \"integrable (Pi\\<^sub>M (insert i I) M) f\"\n  shows \"integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f = LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))\"", "lemma cexpr_sem_integrate_vars:\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  assumes disjoint: \"distinct vs\" \"set vs \\<inter> V' = {}\"\n  assumes \"integrable (state_measure (set vs) \\<Gamma>)\n               (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e))\"\n  assumes e: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" \"free_vars e \\<subseteq> set vs \\<union> V'\"\n  shows \"extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n           \\<integral>\\<sigma>. extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure (set vs) \\<Gamma>\"", "lemma cexpr_sem_integrate_vars':\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  assumes disjoint: \"distinct vs\" \"set vs \\<inter> V' = {}\"\n  assumes nonneg: \"nonneg_cexpr (set vs \\<union> V') \\<Gamma> e\"\n  assumes \"integrable (state_measure (set vs) \\<Gamma>)\n               (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e))\"\n  assumes e: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" \"free_vars e \\<subseteq> set vs \\<union> V'\"\n  shows \"ennreal (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n           \\<integral>\\<^sup>+\\<sigma>. extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure (set vs) \\<Gamma>\"", "lemma nonneg_cexpr_sem_integrate_vars:\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  assumes disjoint: \"distinct vs\" \"set vs \\<inter> V' = {}\"\n  assumes nonneg: \"nonneg_cexpr (set vs \\<union> V') \\<Gamma> e\"\n  assumes e: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" \"free_vars e \\<subseteq> set vs \\<union> V'\"\n  shows \"extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) \\<ge> 0\"", "lemma nonneg_cexpr_sem_integrate_vars':\n  \"distinct vs \\<Longrightarrow> set vs \\<inter> V' = {} \\<Longrightarrow> nonneg_cexpr (set vs \\<union> V') \\<Gamma> e \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow>\n    free_vars e \\<subseteq> set vs \\<union> V' \\<Longrightarrow> nonneg_cexpr V' \\<Gamma> (integrate_vars \\<Gamma> vs e)\"", "lemma cexpr_sem_integral_nonneg:\n  assumes finite: \"(\\<integral>\\<^sup>+x. extract_real (cexpr_sem (case_nat x \\<sigma>) e) \\<partial>stock_measure t) < \\<infinity>\"\n  assumes nonneg: \"nonneg_cexpr (shift_var_set V) (case_nat t \\<Gamma>) e\"\n  assumes t: \"case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" and vars: \"free_vars e \\<subseteq> shift_var_set V\"\n  assumes \\<rho>: \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\"\n  shows \"ennreal (extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n             \\<integral>\\<^sup>+x. extract_real (cexpr_sem (case_nat x \\<sigma>) e) \\<partial>stock_measure t\"", "lemma has_parametrized_subprob_density_cexpr_sem_integral:\n  assumes dens: \"has_parametrized_subprob_density (state_measure V' \\<Gamma>) M (stock_measure t)\n                   (\\<lambda>\\<rho> x. \\<integral>\\<^sup>+y. eval_cexpr f (case_nat x \\<rho>) y \\<partial>stock_measure t')\"\n  assumes nonneg: \"nonneg_cexpr (shift_var_set (shift_var_set V')) (case_nat t' (case_nat t \\<Gamma>)) f\"\n  assumes tf: \"case_nat t' (case_nat t \\<Gamma>) \\<turnstile>\\<^sub>c f : REAL\"\n  assumes varsf: \"free_vars f \\<subseteq> shift_var_set (shift_var_set V')\"\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  shows \"AE x in stock_measure t.\n          (\\<integral>\\<^sup>+y. eval_cexpr f (case_nat x \\<rho>) y \\<partial>stock_measure t') = ennreal (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t') \\<rho> x)\""], "translations": [["", "lemma cet_val': \"t = val_type v \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c CVal v : t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = val_type v \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c CVal v : t", "by (simp add: cet_val)"], ["", "lemma cet_var': \"t = \\<Gamma> x \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c CVar x : t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = \\<Gamma> x \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c CVar x : t", "by (simp add: cet_var)"], ["", "lemma cet_not: \"\\<Gamma> \\<turnstile>\\<^sub>c e : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c \\<not>\\<^sub>c e : BOOL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c e : BOOL \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c \\<not>\\<^sub>c e : BOOL", "by (intro cet_op[where t = \"BOOL\"] cet_pair, simp, simp)"], ["", "lemma cet_and: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 \\<and>\\<^sub>c e2 : BOOL\" and\n      cet_or: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 \\<or>\\<^sub>c e2 : BOOL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : BOOL;\n      \\<Gamma> \\<turnstile>\\<^sub>c e2 : BOOL\\<rbrakk>\n     \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                        e1 \\<and>\\<^sub>c e2 : BOOL) &&&\n    (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : BOOL;\n      \\<Gamma> \\<turnstile>\\<^sub>c e2 : BOOL\\<rbrakk>\n     \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                        e1 \\<or>\\<^sub>c e2 : BOOL)", "by (intro cet_op[where t = \"PRODUCT BOOL BOOL\"] cet_pair, simp, simp, simp)+"], ["", "lemma cet_minus_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c -\\<^sub>ce : REAL\" and\n      cet_inverse: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c inverse\\<^sub>c e : REAL\" and\n      cet_sqrt: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c sqrt\\<^sub>c e : REAL\" and\n      cet_exp: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c exp\\<^sub>c e : REAL\" and\n      cet_ln: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c ln\\<^sub>c e : REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow>\n      \\<Gamma> \\<turnstile>\\<^sub>c -\\<^sub>c e : REAL) &&&\n     (\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow>\n      \\<Gamma> \\<turnstile>\\<^sub>c inverse\\<^sub>c e : REAL)) &&&\n    (\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>c sqrt\\<^sub>c e : REAL) &&&\n    (\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>c exp\\<^sub>c e : REAL) &&&\n    (\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>c ln\\<^sub>c e : REAL)", "by (rule cet_op[where t = \"REAL\"], simp, simp)+"], ["", "lemma cet_pow_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 ^\\<^sub>c e2 : REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 ^\\<^sub>c e2 : REAL", "by (intro cet_op[where t = \"PRODUCT REAL INTEG\"] cet_pair) simp_all"], ["", "lemma cet_add_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 +\\<^sub>c e2 : REAL\" and\n      cet_mult_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 *\\<^sub>c e2 : REAL\" and\n      cet_less_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 <\\<^sub>c e2 : BOOL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n      \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\\<rbrakk>\n     \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                        e1 +\\<^sub>c e2 : REAL) &&&\n    (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n      \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\\<rbrakk>\n     \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                        e1 *\\<^sub>c e2 : REAL) &&&\n    (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n      \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\\<rbrakk>\n     \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 <\\<^sub>c e2 : BOOL)", "by (intro cet_op[where t = \"PRODUCT REAL REAL\"] cet_pair, simp, simp, simp)+"], ["", "lemma cet_eq: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : t \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : t \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 =\\<^sub>c e2 : BOOL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : t\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 =\\<^sub>c e2 : BOOL", "by (intro cet_op[where t = \"PRODUCT t t\"] cet_pair, simp, simp, simp)+"], ["", "lemma cet_less_eq_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 \\<le>\\<^sub>c e2 : BOOL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       e1 \\<le>\\<^sub>c e2 : BOOL", "by (intro cet_less_real cet_or cet_eq)"], ["", "lemma cet_minus_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c -\\<^sub>ce : INTEG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c e : INTEG \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c -\\<^sub>c e : INTEG", "by (rule cet_op[where t = \"INTEG\"], simp, simp)+"], ["", "lemma cet_add_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 +\\<^sub>c e2 : INTEG\" and\n      cet_mult_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 *\\<^sub>c e2 : INTEG\" and\n      cet_less_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 <\\<^sub>c e2 : BOOL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG;\n      \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG\\<rbrakk>\n     \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                        e1 +\\<^sub>c e2 : INTEG) &&&\n    (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG;\n      \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG\\<rbrakk>\n     \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                        e1 *\\<^sub>c e2 : INTEG) &&&\n    (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG;\n      \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG\\<rbrakk>\n     \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 <\\<^sub>c e2 : BOOL)", "by (intro cet_op[where t = \"PRODUCT INTEG INTEG\"] cet_pair, simp, simp, simp)+"], ["", "lemma cet_less_eq_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 \\<le>\\<^sub>c e2 : BOOL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       e1 \\<le>\\<^sub>c e2 : BOOL", "by (intro cet_less_int cet_or cet_eq)"], ["", "lemma cet_sub_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 -\\<^sub>c e2 : INTEG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 -\\<^sub>c e2 : INTEG", "by (intro cet_minus_int cet_add_int)"], ["", "lemma cet_fst: \"\\<Gamma> \\<turnstile>\\<^sub>c e : PRODUCT t t' \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c fst\\<^sub>c e : t\" and\n      cet_snd: \"\\<Gamma> \\<turnstile>\\<^sub>c e : PRODUCT t t' \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c snd\\<^sub>c e : t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma> \\<turnstile>\\<^sub>c e : PRODUCT t t' \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>c fst\\<^sub>c e : t) &&&\n    (\\<Gamma> \\<turnstile>\\<^sub>c e : PRODUCT t t' \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>c snd\\<^sub>c e : t')", "by (erule cet_op, simp)+"], ["", "lemma cet_cast_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e : BOOL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c \\<langle>e\\<rangle>\\<^sub>c : REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c e : BOOL \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c \\<langle>e\\<rangle>\\<^sub>c : REAL", "by (intro cet_op[where t = BOOL]) simp_all"], ["", "lemma cet_cast_real_int: \"\\<Gamma> \\<turnstile>\\<^sub>c e : INTEG \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c \\<langle>e\\<rangle>\\<^sub>c : REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c e : INTEG \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c \\<langle>e\\<rangle>\\<^sub>c : REAL", "by (intro cet_op[where t = INTEG]) simp_all"], ["", "lemma cet_sub_real: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 -\\<^sub>c e2 : REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e1 -\\<^sub>c e2 : REAL", "by (intro cet_minus_real cet_add_real)"], ["", "lemma cet_pi: \"\\<Gamma> \\<turnstile>\\<^sub>c \\<pi>\\<^sub>c : REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c \\<pi>\\<^sub>c : REAL", "by (rule cet_op, rule cet_val, simp)"], ["", "lemmas cet_op_intros =\n  cet_minus_real cet_exp cet_sqrt cet_ln cet_inverse cet_pow_real cet_pi\n  cet_cast_real cet_add_real cet_mult_real cet_less_real\n  cet_not cet_and cet_or"], ["", "inductive_cases cexpr_typing_valE[elim]:  \"\\<Gamma> \\<turnstile>\\<^sub>c CVal v : t\""], ["", "inductive_cases cexpr_typing_varE[elim]:  \"\\<Gamma> \\<turnstile>\\<^sub>c CVar x : t\""], ["", "inductive_cases cexpr_typing_pairE[elim]: \"\\<Gamma> \\<turnstile>\\<^sub>c <e1, e2>\\<^sub>c : t\""], ["", "inductive_cases cexpr_typing_opE[elim]:   \"\\<Gamma> \\<turnstile>\\<^sub>c oper $$\\<^sub>c e : t\""], ["", "inductive_cases cexpr_typing_ifE[elim]:   \"\\<Gamma> \\<turnstile>\\<^sub>c IF\\<^sub>c b THEN e1 ELSE e2 : t\""], ["", "inductive_cases cexpr_typing_intE[elim]:  \"\\<Gamma> \\<turnstile>\\<^sub>c \\<integral>\\<^sub>c e \\<partial>t : t'\""], ["", "primrec cexpr_type :: \"tyenv \\<Rightarrow> cexpr \\<Rightarrow> pdf_type option\" where\n  \"cexpr_type _ (CVal v) = Some (val_type v)\"\n| \"cexpr_type \\<Gamma> (CVar x) = Some (\\<Gamma> x)\"\n| \"cexpr_type \\<Gamma> (<e1, e2>\\<^sub>c) = (case (cexpr_type \\<Gamma> e1, cexpr_type \\<Gamma> e2) of\n                                (Some t1, Some t2) \\<Rightarrow> Some (PRODUCT t1 t2)\n                              | _ \\<Rightarrow> None)\"\n| \"cexpr_type \\<Gamma> (oper $$\\<^sub>c e) = (case cexpr_type \\<Gamma> e of\n                                 Some t \\<Rightarrow> op_type oper t\n                               | _ \\<Rightarrow> None)\"\n| \"cexpr_type \\<Gamma> (IF\\<^sub>c b THEN e1 ELSE e2) =\n                              (if cexpr_type \\<Gamma> b = Some BOOL then\n                                 case (cexpr_type \\<Gamma> e1, cexpr_type \\<Gamma> e2) of\n                                   (Some t, Some t') \\<Rightarrow> if t = t' then Some t else None\n                                 | _ \\<Rightarrow> None\n                               else None)\"\n| \"cexpr_type \\<Gamma> (\\<integral>\\<^sub>c e \\<partial>t) =\n      (if cexpr_type (case_nat t \\<Gamma>) e = Some REAL then Some REAL else None)\""], ["", "lemma cexpr_type_Some_iff: \"cexpr_type \\<Gamma> e = Some t \\<longleftrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e : t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cexpr_type \\<Gamma> e = Some t) = (\\<Gamma> \\<turnstile>\\<^sub>c e : t)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. cexpr_type \\<Gamma> e = Some t \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c e : t\n 2. \\<Gamma> \\<turnstile>\\<^sub>c e : t \\<Longrightarrow>\n    cexpr_type \\<Gamma> e = Some t", "apply (induction e arbitrary: \\<Gamma> t,\n         auto intro!: cexpr_typing.intros split: option.split_asm if_split_asm) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c e : t \\<Longrightarrow>\n    cexpr_type \\<Gamma> e = Some t", "apply (induction rule: cexpr_typing.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas cexpr_typing_code[code_unfold] = cexpr_type_Some_iff[symmetric]"], ["", "lemma cexpr_typing_cong':\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e : t\" \"\\<And>x. x \\<in> free_vars e \\<Longrightarrow> \\<Gamma> x = \\<Gamma>' x\"\n  shows \"\\<Gamma>' \\<turnstile>\\<^sub>c e : t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>c e : t", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t\n  ?x \\<in> free_vars e \\<Longrightarrow> \\<Gamma> ?x = \\<Gamma>' ?x\n\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>c e : t", "proof (induction arbitrary: \\<Gamma>' rule: cexpr_typing.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> v \\<Gamma>'.\n       (\\<And>x.\n           x \\<in> free_vars (CVal v) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n       \\<Gamma>' \\<turnstile>\\<^sub>c CVal v : val_type v\n 2. \\<And>\\<Gamma> x \\<Gamma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<Gamma> xa = \\<Gamma>' xa) \\<Longrightarrow>\n       \\<Gamma>' \\<turnstile>\\<^sub>c CVar x : \\<Gamma> x\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e1 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e1 : t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>x.\n           x \\<in> free_vars <e1, e2>\\<^sub>c \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          <e1, e2>\\<^sub>c : PRODUCT t1 t2\n 4. \\<And>\\<Gamma> e t oper t' \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e : t;\n        op_type oper t = Some t';\n        \\<And>x.\n           x \\<in> free_vars (oper $$\\<^sub>c e) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          oper $$\\<^sub>c e : t'\n 5. \\<And>\\<Gamma> b e1 t e2 \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars b \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c b : BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e1 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e1 : t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c b THEN e1 ELSE e2) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          IF\\<^sub>c b THEN e1 ELSE e2 : t\n 6. \\<And>t \\<Gamma> e \\<Gamma>'.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e \\<Longrightarrow>\n               (case x of 0 \\<Rightarrow> t\n                | Suc x \\<Rightarrow> \\<Gamma> x) =\n               \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>t) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          \\<integral>\\<^sub>c e \\<partial>t : REAL", "case (cet_int t \\<Gamma> e \\<Gamma>')"], ["proof (state)\nthis:\n  case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  (\\<And>x.\n      x \\<in> free_vars e \\<Longrightarrow>\n      (case x of 0 \\<Rightarrow> t | Suc x \\<Rightarrow> \\<Gamma> x) =\n      ?\\<Gamma>' x) \\<Longrightarrow>\n  ?\\<Gamma>' \\<turnstile>\\<^sub>c e : REAL\n  ?x \\<in> free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<Longrightarrow>\n  \\<Gamma> ?x = \\<Gamma>' ?x\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> v \\<Gamma>'.\n       (\\<And>x.\n           x \\<in> free_vars (CVal v) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n       \\<Gamma>' \\<turnstile>\\<^sub>c CVal v : val_type v\n 2. \\<And>\\<Gamma> x \\<Gamma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<Gamma> xa = \\<Gamma>' xa) \\<Longrightarrow>\n       \\<Gamma>' \\<turnstile>\\<^sub>c CVar x : \\<Gamma> x\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e1 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e1 : t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>x.\n           x \\<in> free_vars <e1, e2>\\<^sub>c \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          <e1, e2>\\<^sub>c : PRODUCT t1 t2\n 4. \\<And>\\<Gamma> e t oper t' \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e : t;\n        op_type oper t = Some t';\n        \\<And>x.\n           x \\<in> free_vars (oper $$\\<^sub>c e) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          oper $$\\<^sub>c e : t'\n 5. \\<And>\\<Gamma> b e1 t e2 \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars b \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c b : BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e1 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e1 : t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c b THEN e1 ELSE e2) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          IF\\<^sub>c b THEN e1 ELSE e2 : t\n 6. \\<And>t \\<Gamma> e \\<Gamma>'.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e \\<Longrightarrow>\n               (case x of 0 \\<Rightarrow> t\n                | Suc x \\<Rightarrow> \\<Gamma> x) =\n               \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>t) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          \\<integral>\\<^sub>c e \\<partial>t : REAL", "hence \"\\<And>x. x \\<in> free_vars e \\<Longrightarrow> case_nat t \\<Gamma> x = case_nat t \\<Gamma>' x\""], ["proof (prove)\nusing this:\n  case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  (\\<And>x.\n      x \\<in> free_vars e \\<Longrightarrow>\n      (case x of 0 \\<Rightarrow> t | Suc x \\<Rightarrow> \\<Gamma> x) =\n      ?\\<Gamma>' x) \\<Longrightarrow>\n  ?\\<Gamma>' \\<turnstile>\\<^sub>c e : REAL\n  ?x \\<in> free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<Longrightarrow>\n  \\<Gamma> ?x = \\<Gamma>' ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> free_vars e \\<Longrightarrow>\n       (case x of 0 \\<Rightarrow> t | Suc x \\<Rightarrow> \\<Gamma> x) =\n       (case x of 0 \\<Rightarrow> t | Suc x \\<Rightarrow> \\<Gamma>' x)", "by (auto split: nat.split)"], ["proof (state)\nthis:\n  ?x \\<in> free_vars e \\<Longrightarrow>\n  (case ?x of 0 \\<Rightarrow> t | Suc x \\<Rightarrow> \\<Gamma> x) =\n  (case ?x of 0 \\<Rightarrow> t | Suc x \\<Rightarrow> \\<Gamma>' x)\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> v \\<Gamma>'.\n       (\\<And>x.\n           x \\<in> free_vars (CVal v) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n       \\<Gamma>' \\<turnstile>\\<^sub>c CVal v : val_type v\n 2. \\<And>\\<Gamma> x \\<Gamma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<Gamma> xa = \\<Gamma>' xa) \\<Longrightarrow>\n       \\<Gamma>' \\<turnstile>\\<^sub>c CVar x : \\<Gamma> x\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e1 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e1 : t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>x.\n           x \\<in> free_vars <e1, e2>\\<^sub>c \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          <e1, e2>\\<^sub>c : PRODUCT t1 t2\n 4. \\<And>\\<Gamma> e t oper t' \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e : t;\n        op_type oper t = Some t';\n        \\<And>x.\n           x \\<in> free_vars (oper $$\\<^sub>c e) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          oper $$\\<^sub>c e : t'\n 5. \\<And>\\<Gamma> b e1 t e2 \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars b \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c b : BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e1 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e1 : t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c b THEN e1 ELSE e2) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          IF\\<^sub>c b THEN e1 ELSE e2 : t\n 6. \\<And>t \\<Gamma> e \\<Gamma>'.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e \\<Longrightarrow>\n               (case x of 0 \\<Rightarrow> t\n                | Suc x \\<Rightarrow> \\<Gamma> x) =\n               \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>t) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          \\<integral>\\<^sub>c e \\<partial>t : REAL", "from cet_int.IH[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> free_vars e \\<Longrightarrow>\n      x \\<in> free_vars e) \\<Longrightarrow>\n  (\\<lambda>a.\n      case a of 0 \\<Rightarrow> t | Suc x \\<Rightarrow> \\<Gamma>' x)\n   \\<turnstile>\\<^sub>c e : REAL", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> free_vars e \\<Longrightarrow>\n      x \\<in> free_vars e) \\<Longrightarrow>\n  (\\<lambda>a.\n      case a of 0 \\<Rightarrow> t | Suc x \\<Rightarrow> \\<Gamma>' x)\n   \\<turnstile>\\<^sub>c e : REAL\n\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<turnstile>\\<^sub>c \\<integral>\\<^sub>c e \\<partial>t : REAL", "by (auto intro!: cexpr_typing.intros)"], ["proof (state)\nthis:\n  \\<Gamma>' \\<turnstile>\\<^sub>c \\<integral>\\<^sub>c e \\<partial>t : REAL\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> v \\<Gamma>'.\n       (\\<And>x.\n           x \\<in> free_vars (CVal v) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n       \\<Gamma>' \\<turnstile>\\<^sub>c CVal v : val_type v\n 2. \\<And>\\<Gamma> x \\<Gamma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<Gamma> xa = \\<Gamma>' xa) \\<Longrightarrow>\n       \\<Gamma>' \\<turnstile>\\<^sub>c CVar x : \\<Gamma> x\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e1 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e1 : t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>x.\n           x \\<in> free_vars <e1, e2>\\<^sub>c \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          <e1, e2>\\<^sub>c : PRODUCT t1 t2\n 4. \\<And>\\<Gamma> e t oper t' \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e : t;\n        op_type oper t = Some t';\n        \\<And>x.\n           x \\<in> free_vars (oper $$\\<^sub>c e) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          oper $$\\<^sub>c e : t'\n 5. \\<And>\\<Gamma> b e1 t e2 \\<Gamma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars b \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c b : BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e1 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e1 : t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>\\<Gamma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<Gamma> x = \\<Gamma>' x) \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c b THEN e1 ELSE e2) \\<Longrightarrow>\n           \\<Gamma> x = \\<Gamma>' x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c\n                          IF\\<^sub>c b THEN e1 ELSE e2 : t", "qed (auto intro!: cexpr_typing.intros)"], ["", "lemma cexpr_typing_cong:\n  assumes \"\\<And>x. x \\<in> free_vars e \\<Longrightarrow> \\<Gamma> x = \\<Gamma>' x\"\n  shows \"\\<Gamma> \\<turnstile>\\<^sub>c e : t \\<longleftrightarrow> \\<Gamma>' \\<turnstile>\\<^sub>c e : t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma> \\<turnstile>\\<^sub>c e : t) =\n    (\\<Gamma>' \\<turnstile>\\<^sub>c e : t)", "by (rule iffI) (erule cexpr_typing_cong', simp add: assms)+"], ["", "primrec cexpr_sem :: \"state \\<Rightarrow> cexpr \\<Rightarrow> val\" where\n  \"cexpr_sem \\<sigma> (CVal v) = v\"\n| \"cexpr_sem \\<sigma> (CVar x) = \\<sigma> x\"\n| \"cexpr_sem \\<sigma> <e1, e2>\\<^sub>c = <|cexpr_sem \\<sigma> e1, cexpr_sem \\<sigma> e2|>\"\n| \"cexpr_sem \\<sigma> (oper $$\\<^sub>c e) = op_sem oper (cexpr_sem \\<sigma> e)\"\n| \"cexpr_sem \\<sigma> (IF\\<^sub>c b THEN e1 ELSE e2) = (if cexpr_sem \\<sigma> b = TRUE then cexpr_sem \\<sigma> e1 else cexpr_sem \\<sigma> e2)\"\n| \"cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t) = RealVal (\\<integral>x. extract_real (cexpr_sem (x \\<cdot> \\<sigma>) e) \\<partial>(stock_measure t))\""], ["", "definition cexpr_equiv :: \"cexpr \\<Rightarrow> cexpr \\<Rightarrow> bool\" where\n  \"cexpr_equiv e1 e2 \\<equiv> \\<forall>\\<sigma>. cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma> e2\""], ["", "lemma cexpr_equiv_commute: \"cexpr_equiv e1 e2 \\<longleftrightarrow> cexpr_equiv e2 e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_equiv e1 e2 = cexpr_equiv e2 e1", "by (auto simp: cexpr_equiv_def)"], ["", "lemma val_type_cexpr_sem[simp]:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e : t\" \"free_vars e \\<subseteq> V\" \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\"\n  shows \"val_type (cexpr_sem \\<sigma> e) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_type (cexpr_sem \\<sigma> e) = t", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t\n  free_vars e \\<subseteq> V\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. val_type (cexpr_sem \\<sigma> e) = t", "by (induction arbitrary: \\<sigma> V rule: cexpr_typing.induct)\n               (auto intro: state_measure_var_type op_sem_val_type)"], ["", "lemma cexpr_sem_eq_on_vars:\n  assumes \"\\<And>x. x \\<in> free_vars e \\<Longrightarrow> \\<sigma> x = \\<sigma>' x\"\n  shows \"cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> free_vars e \\<Longrightarrow> \\<sigma> ?x = \\<sigma>' ?x\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e", "proof (induction e arbitrary: \\<sigma> \\<sigma>')"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e1 e2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e1 \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma>' e1;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e2 = cexpr_sem \\<sigma>' e2;\n        \\<And>x.\n           x \\<in> free_vars <e1, e2>\\<^sub>c \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> <e1, e2>\\<^sub>c =\n                         cexpr_sem \\<sigma>' <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars (x1a $$\\<^sub>c e) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (x1a $$\\<^sub>c e) =\n                         cexpr_sem \\<sigma>' (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e1 \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma>' e1;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e2 = cexpr_sem \\<sigma>' e2;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e3 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e3 = cexpr_sem \\<sigma>' e3;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c e1 THEN e2 ELSE e3) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3) =\n                         cexpr_sem \\<sigma>' (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "case (CPair e1 e2 \\<sigma> \\<sigma>')"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> free_vars e1 \\<Longrightarrow>\n      ?\\<sigma> x = ?\\<sigma>' x) \\<Longrightarrow>\n  cexpr_sem ?\\<sigma> e1 = cexpr_sem ?\\<sigma>' e1\n  (\\<And>x.\n      x \\<in> free_vars e2 \\<Longrightarrow>\n      ?\\<sigma> x = ?\\<sigma>' x) \\<Longrightarrow>\n  cexpr_sem ?\\<sigma> e2 = cexpr_sem ?\\<sigma>' e2\n  ?x \\<in> free_vars <e1, e2>\\<^sub>c \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x\n\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e1 e2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e1 \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma>' e1;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e2 = cexpr_sem \\<sigma>' e2;\n        \\<And>x.\n           x \\<in> free_vars <e1, e2>\\<^sub>c \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> <e1, e2>\\<^sub>c =\n                         cexpr_sem \\<sigma>' <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars (x1a $$\\<^sub>c e) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (x1a $$\\<^sub>c e) =\n                         cexpr_sem \\<sigma>' (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e1 \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma>' e1;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e2 = cexpr_sem \\<sigma>' e2;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e3 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e3 = cexpr_sem \\<sigma>' e3;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c e1 THEN e2 ELSE e3) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3) =\n                         cexpr_sem \\<sigma>' (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "from CPair.prems"], ["proof (chain)\npicking this:\n  ?x \\<in> free_vars <e1, e2>\\<^sub>c \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> free_vars <e1, e2>\\<^sub>c \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> <e1, e2>\\<^sub>c =\n    cexpr_sem \\<sigma>' <e1, e2>\\<^sub>c", "by (auto intro!: CPair.IH)"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> <e1, e2>\\<^sub>c = cexpr_sem \\<sigma>' <e1, e2>\\<^sub>c\n\ngoal (5 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>x1a e \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars (x1a $$\\<^sub>c e) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (x1a $$\\<^sub>c e) =\n                         cexpr_sem \\<sigma>' (x1a $$\\<^sub>c e)\n 4. \\<And>e1 e2 e3 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e1 \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma>' e1;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e2 = cexpr_sem \\<sigma>' e2;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e3 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e3 = cexpr_sem \\<sigma>' e3;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c e1 THEN e2 ELSE e3) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3) =\n                         cexpr_sem \\<sigma>' (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 5. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>x1a e \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars (x1a $$\\<^sub>c e) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (x1a $$\\<^sub>c e) =\n                         cexpr_sem \\<sigma>' (x1a $$\\<^sub>c e)\n 4. \\<And>e1 e2 e3 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e1 \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma>' e1;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e2 = cexpr_sem \\<sigma>' e2;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e3 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e3 = cexpr_sem \\<sigma>' e3;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c e1 THEN e2 ELSE e3) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3) =\n                         cexpr_sem \\<sigma>' (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 5. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "case (COperator oper e \\<sigma> \\<sigma>')"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> free_vars e \\<Longrightarrow>\n      ?\\<sigma> x = ?\\<sigma>' x) \\<Longrightarrow>\n  cexpr_sem ?\\<sigma> e = cexpr_sem ?\\<sigma>' e\n  ?x \\<in> free_vars (oper $$\\<^sub>c e) \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x\n\ngoal (5 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>x1a e \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars (x1a $$\\<^sub>c e) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (x1a $$\\<^sub>c e) =\n                         cexpr_sem \\<sigma>' (x1a $$\\<^sub>c e)\n 4. \\<And>e1 e2 e3 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e1 \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma>' e1;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e2 = cexpr_sem \\<sigma>' e2;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e3 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e3 = cexpr_sem \\<sigma>' e3;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c e1 THEN e2 ELSE e3) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3) =\n                         cexpr_sem \\<sigma>' (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 5. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "from COperator.prems"], ["proof (chain)\npicking this:\n  ?x \\<in> free_vars (oper $$\\<^sub>c e) \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> free_vars (oper $$\\<^sub>c e) \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (oper $$\\<^sub>c e) =\n    cexpr_sem \\<sigma>' (oper $$\\<^sub>c e)", "by (auto simp: COperator.IH[of \\<sigma> \\<sigma>'])"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> (oper $$\\<^sub>c e) =\n  cexpr_sem \\<sigma>' (oper $$\\<^sub>c e)\n\ngoal (4 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e1 e2 e3 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e1 \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma>' e1;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e2 = cexpr_sem \\<sigma>' e2;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e3 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e3 = cexpr_sem \\<sigma>' e3;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c e1 THEN e2 ELSE e3) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3) =\n                         cexpr_sem \\<sigma>' (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 4. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e1 e2 e3 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e1 \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma>' e1;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e2 = cexpr_sem \\<sigma>' e2;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e3 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e3 = cexpr_sem \\<sigma>' e3;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c e1 THEN e2 ELSE e3) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3) =\n                         cexpr_sem \\<sigma>' (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 4. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "case (CIf b e1 e2 \\<sigma> \\<sigma>')"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> free_vars b \\<Longrightarrow>\n      ?\\<sigma> x = ?\\<sigma>' x) \\<Longrightarrow>\n  cexpr_sem ?\\<sigma> b = cexpr_sem ?\\<sigma>' b\n  (\\<And>x.\n      x \\<in> free_vars e1 \\<Longrightarrow>\n      ?\\<sigma> x = ?\\<sigma>' x) \\<Longrightarrow>\n  cexpr_sem ?\\<sigma> e1 = cexpr_sem ?\\<sigma>' e1\n  (\\<And>x.\n      x \\<in> free_vars e2 \\<Longrightarrow>\n      ?\\<sigma> x = ?\\<sigma>' x) \\<Longrightarrow>\n  cexpr_sem ?\\<sigma> e2 = cexpr_sem ?\\<sigma>' e2\n  ?x \\<in> free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x\n\ngoal (4 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e1 e2 e3 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e1 \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e1 = cexpr_sem \\<sigma>' e1;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e2 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e2 = cexpr_sem \\<sigma>' e2;\n        \\<And>\\<sigma> \\<sigma>'.\n           (\\<And>x.\n               x \\<in> free_vars e3 \\<Longrightarrow>\n               \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n           cexpr_sem \\<sigma> e3 = cexpr_sem \\<sigma>' e3;\n        \\<And>x.\n           x \\<in> free_vars\n                    (IF\\<^sub>c e1 THEN e2 ELSE e3) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3) =\n                         cexpr_sem \\<sigma>' (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 4. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "from CIf.prems"], ["proof (chain)\npicking this:\n  ?x \\<in> free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (IF\\<^sub>c b THEN e1 ELSE e2) =\n    cexpr_sem \\<sigma>' (IF\\<^sub>c b THEN e1 ELSE e2)", "by (auto simp: CIf.IH[of \\<sigma> \\<sigma>'])"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> (IF\\<^sub>c b THEN e1 ELSE e2) =\n  cexpr_sem \\<sigma>' (IF\\<^sub>c b THEN e1 ELSE e2)\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "case (CIntegral e t \\<sigma> \\<sigma>')"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> free_vars e \\<Longrightarrow>\n      ?\\<sigma> x = ?\\<sigma>' x) \\<Longrightarrow>\n  cexpr_sem ?\\<sigma> e = cexpr_sem ?\\<sigma>' e\n  ?x \\<in> free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "have \"cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t) = RealVal (\\<integral>x. extract_real (cexpr_sem (case_nat x \\<sigma>) e) \\<partial>stock_measure t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t) =\n    RealVal\n     (LINT x|stock_measure t.\n         extract_real (cexpr_sem (case_nat x \\<sigma>) e))", "by simp"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t) =\n  RealVal\n   (LINT x|stock_measure t.\n       extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "also"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t) =\n  RealVal\n   (LINT x|stock_measure t.\n       extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "from CIntegral.prems"], ["proof (chain)\npicking this:\n  ?x \\<in> free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x", "have A: \"(\\<lambda>v. cexpr_sem (case_nat v \\<sigma>) e) = (\\<lambda>v. cexpr_sem (case_nat v \\<sigma>') e)\""], ["proof (prove)\nusing this:\n  ?x \\<in> free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<Longrightarrow>\n  \\<sigma> ?x = \\<sigma>' ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. cexpr_sem (case_nat v \\<sigma>) e) =\n    (\\<lambda>v. cexpr_sem (case_nat v \\<sigma>') e)", "by (intro ext CIntegral.IH) (auto split: nat.split)"], ["proof (state)\nthis:\n  (\\<lambda>v. cexpr_sem (case_nat v \\<sigma>) e) =\n  (\\<lambda>v. cexpr_sem (case_nat v \\<sigma>') e)\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "also"], ["proof (state)\nthis:\n  (\\<lambda>v. cexpr_sem (case_nat v \\<sigma>) e) =\n  (\\<lambda>v. cexpr_sem (case_nat v \\<sigma>') e)\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "have \"RealVal (\\<integral>x. extract_real (cexpr_sem (case_nat x \\<sigma>') e) \\<partial>stock_measure t) = cexpr_sem \\<sigma>' (\\<integral>\\<^sub>c e \\<partial>t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RealVal\n     (LINT x|stock_measure t.\n         extract_real (cexpr_sem (case_nat x \\<sigma>') e)) =\n    cexpr_sem \\<sigma>' (\\<integral>\\<^sub>c e \\<partial>t)", "by simp"], ["proof (state)\nthis:\n  RealVal\n   (LINT x|stock_measure t.\n       extract_real (cexpr_sem (case_nat x \\<sigma>') e)) =\n  cexpr_sem \\<sigma>' (\\<integral>\\<^sub>c e \\<partial>t)\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)\n 3. \\<And>e x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   (\\<And>x.\n                       x \\<in> free_vars e \\<Longrightarrow>\n                       \\<sigma> x = \\<sigma>' x) \\<Longrightarrow>\n                   cexpr_sem \\<sigma> e = cexpr_sem \\<sigma>' e;\n        \\<And>x.\n           x \\<in> free_vars\n                    (\\<integral>\\<^sub>c e \\<partial>x2a) \\<Longrightarrow>\n           \\<sigma> x = \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (\\<integral>\\<^sub>c e \\<partial>x2a) =\n                         cexpr_sem \\<sigma>'\n                          (\\<integral>\\<^sub>c e \\<partial>x2a)", "finally"], ["proof (chain)\npicking this:\n  cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t) =\n  cexpr_sem \\<sigma>' (\\<integral>\\<^sub>c e \\<partial>t)", "show ?case"], ["proof (prove)\nusing this:\n  cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t) =\n  cexpr_sem \\<sigma>' (\\<integral>\\<^sub>c e \\<partial>t)\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t) =\n    cexpr_sem \\<sigma>' (\\<integral>\\<^sub>c e \\<partial>t)", "."], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t) =\n  cexpr_sem \\<sigma>' (\\<integral>\\<^sub>c e \\<partial>t)\n\ngoal (2 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVar x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVar x) = cexpr_sem \\<sigma>' (CVar x)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       (\\<And>xa.\n           xa \\<in> free_vars (CVal x) \\<Longrightarrow>\n           \\<sigma> xa = \\<sigma>' xa) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (CVal x) = cexpr_sem \\<sigma>' (CVal x)", "qed simp_all"], ["", "definition eval_cexpr :: \"cexpr \\<Rightarrow> state \\<Rightarrow> val \\<Rightarrow> real\" where\n  \"eval_cexpr e \\<sigma> v = extract_real (cexpr_sem (case_nat v \\<sigma>) e)\""], ["", "lemma measurable_cexpr_sem[measurable]:\n  \"\\<Gamma> \\<turnstile>\\<^sub>c e : t \\<Longrightarrow> free_vars e \\<subseteq> V \\<Longrightarrow>\n      (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e) \\<in> measurable (state_measure V \\<Gamma>) (stock_measure t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e : t;\n     free_vars e \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n                      \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                            stock_measure t", "proof (induction arbitrary: V rule: cexpr_typing.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> v V.\n       free_vars (CVal v) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVal v))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (val_type v)\n 2. \\<And>\\<Gamma> x V.\n       free_vars (CVar x) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVar x))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (\\<Gamma> x)\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t2;\n        free_vars <e1, e2>\\<^sub>c \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> <e1, e2>\\<^sub>c)\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure (PRODUCT t1 t2)\n 4. \\<And>\\<Gamma> e t oper t' V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e : t;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        op_type oper t = Some t';\n        free_vars (oper $$\\<^sub>c e) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> (oper $$\\<^sub>c e))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t'\n 5. \\<And>\\<Gamma> b e1 t e2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>V.\n           free_vars b \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> b)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (IF\\<^sub>c b THEN e1 ELSE e2))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t\n 6. \\<And>t \\<Gamma> e V.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n                 stock_measure REAL;\n        free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (\\<integral>\\<^sub>c e \\<partial>t))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure REAL", "case (cet_op oper t t' \\<Gamma> e)"], ["proof (state)\nthis:\n  oper \\<turnstile>\\<^sub>c t : t'\n  op_type \\<Gamma> t' = Some e\n  free_vars t \\<subseteq> ?V \\<Longrightarrow>\n  (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> t)\n  \\<in> state_measure ?V oper \\<rightarrow>\\<^sub>M stock_measure t'\n  free_vars (\\<Gamma> $$\\<^sub>c t) \\<subseteq> V\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> v V.\n       free_vars (CVal v) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVal v))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (val_type v)\n 2. \\<And>\\<Gamma> x V.\n       free_vars (CVar x) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVar x))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (\\<Gamma> x)\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t2;\n        free_vars <e1, e2>\\<^sub>c \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> <e1, e2>\\<^sub>c)\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure (PRODUCT t1 t2)\n 4. \\<And>\\<Gamma> e t oper t' V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e : t;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        op_type oper t = Some t';\n        free_vars (oper $$\\<^sub>c e) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> (oper $$\\<^sub>c e))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t'\n 5. \\<And>\\<Gamma> b e1 t e2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>V.\n           free_vars b \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> b)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (IF\\<^sub>c b THEN e1 ELSE e2))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t\n 6. \\<And>t \\<Gamma> e V.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n                 stock_measure REAL;\n        free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (\\<integral>\\<^sub>c e \\<partial>t))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure REAL", "thus ?case"], ["proof (prove)\nusing this:\n  oper \\<turnstile>\\<^sub>c t : t'\n  op_type \\<Gamma> t' = Some e\n  free_vars t \\<subseteq> ?V \\<Longrightarrow>\n  (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> t)\n  \\<in> state_measure ?V oper \\<rightarrow>\\<^sub>M stock_measure t'\n  free_vars (\\<Gamma> $$\\<^sub>c t) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (\\<Gamma> $$\\<^sub>c t))\n    \\<in> state_measure V oper \\<rightarrow>\\<^sub>M stock_measure e", "using measurable_op_sem"], ["proof (prove)\nusing this:\n  oper \\<turnstile>\\<^sub>c t : t'\n  op_type \\<Gamma> t' = Some e\n  free_vars t \\<subseteq> ?V \\<Longrightarrow>\n  (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> t)\n  \\<in> state_measure ?V oper \\<rightarrow>\\<^sub>M stock_measure t'\n  free_vars (\\<Gamma> $$\\<^sub>c t) \\<subseteq> V\n  op_type ?oper ?t = Some ?t' \\<Longrightarrow>\n  op_sem ?oper\n  \\<in> stock_measure ?t \\<rightarrow>\\<^sub>M stock_measure ?t'\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (\\<Gamma> $$\\<^sub>c t))\n    \\<in> state_measure V oper \\<rightarrow>\\<^sub>M stock_measure e", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (\\<Gamma> $$\\<^sub>c t))\n  \\<in> state_measure V oper \\<rightarrow>\\<^sub>M stock_measure e\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> v V.\n       free_vars (CVal v) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVal v))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (val_type v)\n 2. \\<And>\\<Gamma> x V.\n       free_vars (CVar x) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVar x))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (\\<Gamma> x)\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t2;\n        free_vars <e1, e2>\\<^sub>c \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> <e1, e2>\\<^sub>c)\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure (PRODUCT t1 t2)\n 4. \\<And>\\<Gamma> b e1 t e2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>V.\n           free_vars b \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> b)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (IF\\<^sub>c b THEN e1 ELSE e2))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t\n 5. \\<And>t \\<Gamma> e V.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n                 stock_measure REAL;\n        free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (\\<integral>\\<^sub>c e \\<partial>t))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure REAL", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> v V.\n       free_vars (CVal v) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVal v))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (val_type v)\n 2. \\<And>\\<Gamma> x V.\n       free_vars (CVar x) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVar x))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (\\<Gamma> x)\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t2;\n        free_vars <e1, e2>\\<^sub>c \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> <e1, e2>\\<^sub>c)\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure (PRODUCT t1 t2)\n 4. \\<And>\\<Gamma> b e1 t e2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>V.\n           free_vars b \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> b)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (IF\\<^sub>c b THEN e1 ELSE e2))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t\n 5. \\<And>t \\<Gamma> e V.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n                 stock_measure REAL;\n        free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (\\<integral>\\<^sub>c e \\<partial>t))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure REAL", "case (cet_int t \\<Gamma> e)"], ["proof (state)\nthis:\n  case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> ?V \\<Longrightarrow>\n  (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n  \\<in> state_measure ?V\n         (\\<lambda>a.\n             case a of 0 \\<Rightarrow> t\n             | Suc x \\<Rightarrow> \\<Gamma> x) \\<rightarrow>\\<^sub>M\n        stock_measure REAL\n  free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> v V.\n       free_vars (CVal v) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVal v))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (val_type v)\n 2. \\<And>\\<Gamma> x V.\n       free_vars (CVar x) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVar x))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (\\<Gamma> x)\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t2;\n        free_vars <e1, e2>\\<^sub>c \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> <e1, e2>\\<^sub>c)\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure (PRODUCT t1 t2)\n 4. \\<And>\\<Gamma> b e1 t e2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>V.\n           free_vars b \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> b)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (IF\\<^sub>c b THEN e1 ELSE e2))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t\n 5. \\<And>t \\<Gamma> e V.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n                 stock_measure REAL;\n        free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (\\<integral>\\<^sub>c e \\<partial>t))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure REAL", "interpret sigma_finite_measure \"stock_measure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_finite_measure (stock_measure t)", "by simp"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> v V.\n       free_vars (CVal v) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVal v))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (val_type v)\n 2. \\<And>\\<Gamma> x V.\n       free_vars (CVar x) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVar x))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (\\<Gamma> x)\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t2;\n        free_vars <e1, e2>\\<^sub>c \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> <e1, e2>\\<^sub>c)\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure (PRODUCT t1 t2)\n 4. \\<And>\\<Gamma> b e1 t e2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>V.\n           free_vars b \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> b)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (IF\\<^sub>c b THEN e1 ELSE e2))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t\n 5. \\<And>t \\<Gamma> e V.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n                 stock_measure REAL;\n        free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (\\<integral>\\<^sub>c e \\<partial>t))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure REAL", "let ?M = \"(\\<Pi>\\<^sub>M x\\<in>V. stock_measure (\\<Gamma> x)) \\<Otimes>\\<^sub>M stock_measure t\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> v V.\n       free_vars (CVal v) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVal v))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (val_type v)\n 2. \\<And>\\<Gamma> x V.\n       free_vars (CVar x) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVar x))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (\\<Gamma> x)\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t2;\n        free_vars <e1, e2>\\<^sub>c \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> <e1, e2>\\<^sub>c)\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure (PRODUCT t1 t2)\n 4. \\<And>\\<Gamma> b e1 t e2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>V.\n           free_vars b \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> b)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (IF\\<^sub>c b THEN e1 ELSE e2))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t\n 5. \\<And>t \\<Gamma> e V.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n                 stock_measure REAL;\n        free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (\\<integral>\\<^sub>c e \\<partial>t))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure REAL", "let ?N = \"embed_measure lborel RealVal\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> v V.\n       free_vars (CVal v) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVal v))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (val_type v)\n 2. \\<And>\\<Gamma> x V.\n       free_vars (CVar x) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVar x))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (\\<Gamma> x)\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t2;\n        free_vars <e1, e2>\\<^sub>c \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> <e1, e2>\\<^sub>c)\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure (PRODUCT t1 t2)\n 4. \\<And>\\<Gamma> b e1 t e2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>V.\n           free_vars b \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> b)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (IF\\<^sub>c b THEN e1 ELSE e2))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t\n 5. \\<And>t \\<Gamma> e V.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n                 stock_measure REAL;\n        free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (\\<integral>\\<^sub>c e \\<partial>t))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure REAL", "have *[measurable]: \"(\\<lambda>a. cexpr_sem a e) \\<in> measurable (state_measure (shift_var_set V) (case_nat t \\<Gamma>)) REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. cexpr_sem a e)\n    \\<in> state_measure (shift_var_set V)\n           (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n          stock_measure REAL", "using cet_int.prems subset_shift_var_set"], ["proof (prove)\nusing this:\n  free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\n  Suc -` ?A \\<subseteq> ?V \\<Longrightarrow> ?A \\<subseteq> shift_var_set ?V\n\ngoal (1 subgoal):\n 1. (\\<lambda>a. cexpr_sem a e)\n    \\<in> state_measure (shift_var_set V)\n           (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n          stock_measure REAL", "by (intro cet_int.IH) simp"], ["proof (state)\nthis:\n  (\\<lambda>a. cexpr_sem a e)\n  \\<in> state_measure (shift_var_set V)\n         (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n        stock_measure REAL\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> v V.\n       free_vars (CVal v) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVal v))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (val_type v)\n 2. \\<And>\\<Gamma> x V.\n       free_vars (CVar x) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVar x))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (\\<Gamma> x)\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t2;\n        free_vars <e1, e2>\\<^sub>c \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> <e1, e2>\\<^sub>c)\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure (PRODUCT t1 t2)\n 4. \\<And>\\<Gamma> b e1 t e2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>V.\n           free_vars b \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> b)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (IF\\<^sub>c b THEN e1 ELSE e2))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t\n 5. \\<And>t \\<Gamma> e V.\n       \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        \\<And>V.\n           free_vars e \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n           \\<in> state_measure V (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n                 stock_measure REAL;\n        free_vars (\\<integral>\\<^sub>c e \\<partial>t) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (\\<integral>\\<^sub>c e \\<partial>t))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure REAL", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))\n    \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M stock_measure REAL", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>\\<sigma>.\n      cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))\n  \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M stock_measure REAL\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> v V.\n       free_vars (CVal v) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVal v))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (val_type v)\n 2. \\<And>\\<Gamma> x V.\n       free_vars (CVar x) \\<subseteq> V \\<Longrightarrow>\n       (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> (CVar x))\n       \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n             stock_measure (\\<Gamma> x)\n 3. \\<And>\\<Gamma> e1 t1 e2 t2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t1;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t2;\n        free_vars <e1, e2>\\<^sub>c \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma> <e1, e2>\\<^sub>c)\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure (PRODUCT t1 t2)\n 4. \\<And>\\<Gamma> b e1 t e2 V.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>V.\n           free_vars b \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> b)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure BOOL;\n        \\<Gamma> \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>V.\n           free_vars e1 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e1)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        \\<Gamma> \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>V.\n           free_vars e2 \\<subseteq> V \\<Longrightarrow>\n           (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e2)\n           \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n                 stock_measure t;\n        free_vars (IF\\<^sub>c b THEN e1 ELSE e2) \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<sigma>.\n                             cexpr_sem \\<sigma>\n                              (IF\\<^sub>c b THEN e1 ELSE e2))\n                         \\<in> state_measure V\n                                \\<Gamma> \\<rightarrow>\\<^sub>M\n                               stock_measure t", "qed (simp_all add: state_measure_def inj_PairVal)"], ["", "lemma measurable_eval_cexpr[measurable]:\n  assumes \"case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\"\n  assumes \"free_vars e \\<subseteq> shift_var_set V\"\n  shows \"case_prod (eval_cexpr e) \\<in> borel_measurable (state_measure V \\<Gamma> \\<Otimes>\\<^sub>M stock_measure t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). eval_cexpr e x y)\n    \\<in> borel_measurable\n           (state_measure V \\<Gamma> \\<Otimes>\\<^sub>M stock_measure t)", "unfolding eval_cexpr_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(\\<sigma>, v).\n        extract_real (cexpr_sem (case_nat v \\<sigma>) e))\n    \\<in> borel_measurable\n           (state_measure V \\<Gamma> \\<Otimes>\\<^sub>M stock_measure t)", "using measurable_cexpr_sem[OF assms]"], ["proof (prove)\nusing this:\n  (\\<lambda>\\<sigma>. cexpr_sem \\<sigma> e)\n  \\<in> state_measure (shift_var_set V)\n         (case_nat t \\<Gamma>) \\<rightarrow>\\<^sub>M\n        stock_measure REAL\n\ngoal (1 subgoal):\n 1. (\\<lambda>(\\<sigma>, v).\n        extract_real (cexpr_sem (case_nat v \\<sigma>) e))\n    \\<in> borel_measurable\n           (state_measure V \\<Gamma> \\<Otimes>\\<^sub>M stock_measure t)", "by simp"], ["", "lemma cexpr_sem_Add:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\"\n  assumes \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\" \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  shows \"extract_real (cexpr_sem \\<sigma> (e1 +\\<^sub>c e2)) = extract_real (cexpr_sem \\<sigma> e1) + extract_real (cexpr_sem \\<sigma> e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (e1 +\\<^sub>c e2)) =\n    extract_real (cexpr_sem \\<sigma> e1) +\n    extract_real (cexpr_sem \\<sigma> e2)", "using val_type_cexpr_sem[OF assms(1,4,3)] val_type_cexpr_sem[OF assms(2,5,3)]"], ["proof (prove)\nusing this:\n  val_type (cexpr_sem \\<sigma> e1) = REAL\n  val_type (cexpr_sem \\<sigma> e2) = REAL\n\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (e1 +\\<^sub>c e2)) =\n    extract_real (cexpr_sem \\<sigma> e1) +\n    extract_real (cexpr_sem \\<sigma> e2)", "by (auto simp: lift_RealIntVal2_def extract_real_def split: val.split)"], ["", "lemma cexpr_sem_Mult:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\"\n  assumes \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\" \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  shows \"extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2)) = extract_real (cexpr_sem \\<sigma> e1) * extract_real (cexpr_sem \\<sigma> e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2)) =\n    extract_real (cexpr_sem \\<sigma> e1) *\n    extract_real (cexpr_sem \\<sigma> e2)", "using val_type_cexpr_sem[OF assms(1,4,3)] val_type_cexpr_sem[OF assms(2,5,3)]"], ["proof (prove)\nusing this:\n  val_type (cexpr_sem \\<sigma> e1) = REAL\n  val_type (cexpr_sem \\<sigma> e2) = REAL\n\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2)) =\n    extract_real (cexpr_sem \\<sigma> e1) *\n    extract_real (cexpr_sem \\<sigma> e2)", "by (auto simp: lift_RealIntVal2_def extract_real_def split: val.split)"], ["", "subsection \\<open>General functions on Expressions\\<close>"], ["", "text \\<open>\n   Transform variable names in an expression.\n\\<close>"], ["", "primrec map_vars :: \"(vname \\<Rightarrow> vname) \\<Rightarrow> cexpr \\<Rightarrow> cexpr\" where\n  \"map_vars f (CVal v) = CVal v\"\n| \"map_vars f (CVar x) = CVar (f x)\"\n| \"map_vars f (<e1, e2>\\<^sub>c) = <map_vars f e1, map_vars f e2>\\<^sub>c\"\n| \"map_vars f (oper $$\\<^sub>c e) = oper $$\\<^sub>c (map_vars f e)\"\n| \"map_vars f (IF\\<^sub>c b THEN e1 ELSE e2) = (IF\\<^sub>c map_vars f b THEN map_vars f e1 ELSE map_vars f e2)\"\n| \"map_vars f (\\<integral>\\<^sub>c e \\<partial>t) = \\<integral>\\<^sub>c map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e \\<partial>t\""], ["", "lemma free_vars_map_vars[simp]:\n  \"free_vars (map_vars f e) = f ` free_vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (map_vars f e) = f ` free_vars e", "proof (induction e arbitrary: f)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x f. free_vars (map_vars f (CVar x)) = f ` free_vars (CVar x)\n 2. \\<And>x f. free_vars (map_vars f (CVal x)) = f ` free_vars (CVal x)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2\\<rbrakk>\n       \\<Longrightarrow> free_vars (map_vars f <e1, e2>\\<^sub>c) =\n                         f ` free_vars <e1, e2>\\<^sub>c\n 4. \\<And>x1a e f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (x1a $$\\<^sub>c e)) =\n       f ` free_vars (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2;\n        \\<And>f. free_vars (map_vars f e3) = f ` free_vars e3\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         f ` free_vars (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       f ` free_vars (\\<integral>\\<^sub>c e \\<partial>x2a)", "case (CIntegral e t f)"], ["proof (state)\nthis:\n  free_vars (map_vars ?f e) = ?f ` free_vars e\n\ngoal (6 subgoals):\n 1. \\<And>x f. free_vars (map_vars f (CVar x)) = f ` free_vars (CVar x)\n 2. \\<And>x f. free_vars (map_vars f (CVal x)) = f ` free_vars (CVal x)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2\\<rbrakk>\n       \\<Longrightarrow> free_vars (map_vars f <e1, e2>\\<^sub>c) =\n                         f ` free_vars <e1, e2>\\<^sub>c\n 4. \\<And>x1a e f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (x1a $$\\<^sub>c e)) =\n       f ` free_vars (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2;\n        \\<And>f. free_vars (map_vars f e3) = f ` free_vars e3\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         f ` free_vars (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       f ` free_vars (\\<integral>\\<^sub>c e \\<partial>x2a)", "{"], ["proof (state)\nthis:\n  free_vars (map_vars ?f e) = ?f ` free_vars e\n\ngoal (6 subgoals):\n 1. \\<And>x f. free_vars (map_vars f (CVar x)) = f ` free_vars (CVar x)\n 2. \\<And>x f. free_vars (map_vars f (CVal x)) = f ` free_vars (CVal x)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2\\<rbrakk>\n       \\<Longrightarrow> free_vars (map_vars f <e1, e2>\\<^sub>c) =\n                         f ` free_vars <e1, e2>\\<^sub>c\n 4. \\<And>x1a e f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (x1a $$\\<^sub>c e)) =\n       f ` free_vars (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2;\n        \\<And>f. free_vars (map_vars f e3) = f ` free_vars e3\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         f ` free_vars (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       f ` free_vars (\\<integral>\\<^sub>c e \\<partial>x2a)", "fix x A"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x f. free_vars (map_vars f (CVar x)) = f ` free_vars (CVar x)\n 2. \\<And>x f. free_vars (map_vars f (CVal x)) = f ` free_vars (CVal x)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2\\<rbrakk>\n       \\<Longrightarrow> free_vars (map_vars f <e1, e2>\\<^sub>c) =\n                         f ` free_vars <e1, e2>\\<^sub>c\n 4. \\<And>x1a e f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (x1a $$\\<^sub>c e)) =\n       f ` free_vars (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2;\n        \\<And>f. free_vars (map_vars f e3) = f ` free_vars e3\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         f ` free_vars (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       f ` free_vars (\\<integral>\\<^sub>c e \\<partial>x2a)", "assume \"Suc x \\<in> A\""], ["proof (state)\nthis:\n  Suc x \\<in> A\n\ngoal (6 subgoals):\n 1. \\<And>x f. free_vars (map_vars f (CVar x)) = f ` free_vars (CVar x)\n 2. \\<And>x f. free_vars (map_vars f (CVal x)) = f ` free_vars (CVal x)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2\\<rbrakk>\n       \\<Longrightarrow> free_vars (map_vars f <e1, e2>\\<^sub>c) =\n                         f ` free_vars <e1, e2>\\<^sub>c\n 4. \\<And>x1a e f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (x1a $$\\<^sub>c e)) =\n       f ` free_vars (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2;\n        \\<And>f. free_vars (map_vars f e3) = f ` free_vars e3\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         f ` free_vars (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       f ` free_vars (\\<integral>\\<^sub>c e \\<partial>x2a)", "hence \"Suc (f x) \\<in> case_nat 0 (\\<lambda>x. Suc (f x)) ` A\""], ["proof (prove)\nusing this:\n  Suc x \\<in> A\n\ngoal (1 subgoal):\n 1. Suc (f x) \\<in> case_nat 0 (\\<lambda>x. Suc (f x)) ` A", "by (subst image_iff, intro bexI[of _ \"Suc x\"]) (simp split: nat.split)"], ["proof (state)\nthis:\n  Suc (f x) \\<in> case_nat 0 (\\<lambda>x. Suc (f x)) ` A\n\ngoal (6 subgoals):\n 1. \\<And>x f. free_vars (map_vars f (CVar x)) = f ` free_vars (CVar x)\n 2. \\<And>x f. free_vars (map_vars f (CVal x)) = f ` free_vars (CVal x)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2\\<rbrakk>\n       \\<Longrightarrow> free_vars (map_vars f <e1, e2>\\<^sub>c) =\n                         f ` free_vars <e1, e2>\\<^sub>c\n 4. \\<And>x1a e f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (x1a $$\\<^sub>c e)) =\n       f ` free_vars (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2;\n        \\<And>f. free_vars (map_vars f e3) = f ` free_vars e3\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         f ` free_vars (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       f ` free_vars (\\<integral>\\<^sub>c e \\<partial>x2a)", "}"], ["proof (state)\nthis:\n  Suc ?x2 \\<in> ?A2 \\<Longrightarrow>\n  Suc (f ?x2) \\<in> case_nat 0 (\\<lambda>x. Suc (f x)) ` ?A2\n\ngoal (6 subgoals):\n 1. \\<And>x f. free_vars (map_vars f (CVar x)) = f ` free_vars (CVar x)\n 2. \\<And>x f. free_vars (map_vars f (CVal x)) = f ` free_vars (CVal x)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2\\<rbrakk>\n       \\<Longrightarrow> free_vars (map_vars f <e1, e2>\\<^sub>c) =\n                         f ` free_vars <e1, e2>\\<^sub>c\n 4. \\<And>x1a e f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (x1a $$\\<^sub>c e)) =\n       f ` free_vars (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2;\n        \\<And>f. free_vars (map_vars f e3) = f ` free_vars e3\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         f ` free_vars (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       f ` free_vars (\\<integral>\\<^sub>c e \\<partial>x2a)", "with CIntegral"], ["proof (chain)\npicking this:\n  free_vars (map_vars ?f e) = ?f ` free_vars e\n  Suc ?x2 \\<in> ?A2 \\<Longrightarrow>\n  Suc (f ?x2) \\<in> case_nat 0 (\\<lambda>x. Suc (f x)) ` ?A2", "show ?case"], ["proof (prove)\nusing this:\n  free_vars (map_vars ?f e) = ?f ` free_vars e\n  Suc ?x2 \\<in> ?A2 \\<Longrightarrow>\n  Suc (f ?x2) \\<in> case_nat 0 (\\<lambda>x. Suc (f x)) ` ?A2\n\ngoal (1 subgoal):\n 1. free_vars (map_vars f (\\<integral>\\<^sub>c e \\<partial>t)) =\n    f ` free_vars (\\<integral>\\<^sub>c e \\<partial>t)", "by (auto split: nat.split_asm)"], ["proof (state)\nthis:\n  free_vars (map_vars f (\\<integral>\\<^sub>c e \\<partial>t)) =\n  f ` free_vars (\\<integral>\\<^sub>c e \\<partial>t)\n\ngoal (5 subgoals):\n 1. \\<And>x f. free_vars (map_vars f (CVar x)) = f ` free_vars (CVar x)\n 2. \\<And>x f. free_vars (map_vars f (CVal x)) = f ` free_vars (CVal x)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2\\<rbrakk>\n       \\<Longrightarrow> free_vars (map_vars f <e1, e2>\\<^sub>c) =\n                         f ` free_vars <e1, e2>\\<^sub>c\n 4. \\<And>x1a e f.\n       (\\<And>f.\n           free_vars (map_vars f e) = f ` free_vars e) \\<Longrightarrow>\n       free_vars (map_vars f (x1a $$\\<^sub>c e)) =\n       f ` free_vars (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 f.\n       \\<lbrakk>\\<And>f. free_vars (map_vars f e1) = f ` free_vars e1;\n        \\<And>f. free_vars (map_vars f e2) = f ` free_vars e2;\n        \\<And>f. free_vars (map_vars f e3) = f ` free_vars e3\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         f ` free_vars (IF\\<^sub>c e1 THEN e2 ELSE e3)", "qed auto"], ["", "lemma cexpr_typing_map_vars:\n  \"\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e : t \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c map_vars f e : t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e : t \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c map_vars f e : t", "proof (induction \"\\<Gamma> \\<circ> f\" e t arbitrary: \\<Gamma> f rule: cexpr_typing.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>v \\<Gamma> f.\n       \\<Gamma> \\<turnstile>\\<^sub>c map_vars f (CVal v) : val_type v\n 2. \\<And>x \\<Gamma> f.\n       \\<Gamma> \\<turnstile>\\<^sub>c\n        map_vars f (CVar x) : (\\<Gamma> \\<circ> f) x\n 3. \\<And>e1 t1 e2 t2 \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e1 : t1;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e2 : t2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f <e1, e2>\\<^sub>c : PRODUCT t1 t2\n 4. \\<And>e t oper t' \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e : t;\n        op_type oper t = Some t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (oper $$\\<^sub>c e) : t'\n 5. \\<And>b e1 t e2 \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa b : BOOL;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e1 : t;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e2 : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (IF\\<^sub>c b THEN e1 ELSE e2) : t\n 6. \\<And>t e \\<Gamma> f.\n       \\<lbrakk>case_nat t (\\<Gamma> \\<circ> f) \\<turnstile>\\<^sub>c\n                 e : REAL;\n        \\<And>\\<Gamma>' fa.\n           case_nat t (\\<Gamma> \\<circ> f) =\n           \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e : REAL\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (\\<integral>\\<^sub>c e \\<partial>t) :\n                          REAL", "case (cet_int t e \\<Gamma>)"], ["proof (state)\nthis:\n  case_nat t (\\<Gamma> \\<circ> f) \\<turnstile>\\<^sub>c e : REAL\n  case_nat t (\\<Gamma> \\<circ> f) = ?\\<Gamma> \\<circ> ?f \\<Longrightarrow>\n  ?\\<Gamma> \\<turnstile>\\<^sub>c map_vars ?f e : REAL\n\ngoal (6 subgoals):\n 1. \\<And>v \\<Gamma> f.\n       \\<Gamma> \\<turnstile>\\<^sub>c map_vars f (CVal v) : val_type v\n 2. \\<And>x \\<Gamma> f.\n       \\<Gamma> \\<turnstile>\\<^sub>c\n        map_vars f (CVar x) : (\\<Gamma> \\<circ> f) x\n 3. \\<And>e1 t1 e2 t2 \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e1 : t1;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e2 : t2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f <e1, e2>\\<^sub>c : PRODUCT t1 t2\n 4. \\<And>e t oper t' \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e : t;\n        op_type oper t = Some t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (oper $$\\<^sub>c e) : t'\n 5. \\<And>b e1 t e2 \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa b : BOOL;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e1 : t;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e2 : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (IF\\<^sub>c b THEN e1 ELSE e2) : t\n 6. \\<And>t e \\<Gamma> f.\n       \\<lbrakk>case_nat t (\\<Gamma> \\<circ> f) \\<turnstile>\\<^sub>c\n                 e : REAL;\n        \\<And>\\<Gamma>' fa.\n           case_nat t (\\<Gamma> \\<circ> f) =\n           \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e : REAL\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (\\<integral>\\<^sub>c e \\<partial>t) :\n                          REAL", "have \"case_nat t (\\<Gamma> \\<circ> f) = case_nat t \\<Gamma> \\<circ> (case_nat 0 (\\<lambda>x. Suc (f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat t (\\<Gamma> \\<circ> f) =\n    case_nat t \\<Gamma> \\<circ> case_nat 0 (\\<lambda>x. Suc (f x))", "by (intro ext) (auto split: nat.split)"], ["proof (state)\nthis:\n  case_nat t (\\<Gamma> \\<circ> f) =\n  case_nat t \\<Gamma> \\<circ> case_nat 0 (\\<lambda>x. Suc (f x))\n\ngoal (6 subgoals):\n 1. \\<And>v \\<Gamma> f.\n       \\<Gamma> \\<turnstile>\\<^sub>c map_vars f (CVal v) : val_type v\n 2. \\<And>x \\<Gamma> f.\n       \\<Gamma> \\<turnstile>\\<^sub>c\n        map_vars f (CVar x) : (\\<Gamma> \\<circ> f) x\n 3. \\<And>e1 t1 e2 t2 \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e1 : t1;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e2 : t2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f <e1, e2>\\<^sub>c : PRODUCT t1 t2\n 4. \\<And>e t oper t' \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e : t;\n        op_type oper t = Some t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (oper $$\\<^sub>c e) : t'\n 5. \\<And>b e1 t e2 \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa b : BOOL;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e1 : t;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e2 : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (IF\\<^sub>c b THEN e1 ELSE e2) : t\n 6. \\<And>t e \\<Gamma> f.\n       \\<lbrakk>case_nat t (\\<Gamma> \\<circ> f) \\<turnstile>\\<^sub>c\n                 e : REAL;\n        \\<And>\\<Gamma>' fa.\n           case_nat t (\\<Gamma> \\<circ> f) =\n           \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e : REAL\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (\\<integral>\\<^sub>c e \\<partial>t) :\n                          REAL", "from cet_int(2)[OF this]"], ["proof (chain)\npicking this:\n  case_nat t \\<Gamma> \\<turnstile>\\<^sub>c\n   map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e : REAL", "show ?case"], ["proof (prove)\nusing this:\n  case_nat t \\<Gamma> \\<turnstile>\\<^sub>c\n   map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e : REAL\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c\n     map_vars f (\\<integral>\\<^sub>c e \\<partial>t) : REAL", "by (auto intro!: cexpr_typing.intros)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>c\n   map_vars f (\\<integral>\\<^sub>c e \\<partial>t) : REAL\n\ngoal (5 subgoals):\n 1. \\<And>v \\<Gamma> f.\n       \\<Gamma> \\<turnstile>\\<^sub>c map_vars f (CVal v) : val_type v\n 2. \\<And>x \\<Gamma> f.\n       \\<Gamma> \\<turnstile>\\<^sub>c\n        map_vars f (CVar x) : (\\<Gamma> \\<circ> f) x\n 3. \\<And>e1 t1 e2 t2 \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e1 : t1;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e1 : t1;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e2 : t2;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e2 : t2\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f <e1, e2>\\<^sub>c : PRODUCT t1 t2\n 4. \\<And>e t oper t' \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e : t;\n        op_type oper t = Some t'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (oper $$\\<^sub>c e) : t'\n 5. \\<And>b e1 t e2 \\<Gamma> f.\n       \\<lbrakk>\\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c b : BOOL;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa b : BOOL;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e1 : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e1 : t;\n        \\<Gamma> \\<circ> f \\<turnstile>\\<^sub>c e2 : t;\n        \\<And>\\<Gamma>' fa.\n           \\<Gamma> \\<circ> f = \\<Gamma>' \\<circ> fa \\<Longrightarrow>\n           \\<Gamma>' \\<turnstile>\\<^sub>c map_vars fa e2 : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          map_vars f (IF\\<^sub>c b THEN e1 ELSE e2) : t", "qed (auto intro!: cexpr_typing.intros)"], ["", "lemma cexpr_sem_map_vars:\n  \"cexpr_sem \\<sigma> (map_vars f e) = cexpr_sem (\\<sigma> \\<circ> f) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (map_vars f e) = cexpr_sem (\\<sigma> \\<circ> f) e", "proof (induction e arbitrary: \\<sigma> f)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVar x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVar x)\n 2. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVal x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVal x)\n 3. \\<And>e1 e2 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (map_vars f <e1, e2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma> \\<circ> f) <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (map_vars f (x1a $$\\<^sub>c e)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e3) =\n           cexpr_sem (\\<sigma> \\<circ> f) e3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         cexpr_sem (\\<sigma> \\<circ> f)\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>x2a)", "case (CIntegral e t \\<sigma> f)"], ["proof (state)\nthis:\n  cexpr_sem ?\\<sigma> (map_vars ?f e) = cexpr_sem (?\\<sigma> \\<circ> ?f) e\n\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVar x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVar x)\n 2. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVal x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVal x)\n 3. \\<And>e1 e2 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (map_vars f <e1, e2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma> \\<circ> f) <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (map_vars f (x1a $$\\<^sub>c e)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e3) =\n           cexpr_sem (\\<sigma> \\<circ> f) e3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         cexpr_sem (\\<sigma> \\<circ> f)\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>x2a)", "{"], ["proof (state)\nthis:\n  cexpr_sem ?\\<sigma> (map_vars ?f e) = cexpr_sem (?\\<sigma> \\<circ> ?f) e\n\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVar x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVar x)\n 2. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVal x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVal x)\n 3. \\<And>e1 e2 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (map_vars f <e1, e2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma> \\<circ> f) <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (map_vars f (x1a $$\\<^sub>c e)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e3) =\n           cexpr_sem (\\<sigma> \\<circ> f) e3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         cexpr_sem (\\<sigma> \\<circ> f)\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>x2a)", "fix x"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVar x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVar x)\n 2. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVal x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVal x)\n 3. \\<And>e1 e2 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (map_vars f <e1, e2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma> \\<circ> f) <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (map_vars f (x1a $$\\<^sub>c e)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e3) =\n           cexpr_sem (\\<sigma> \\<circ> f) e3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         cexpr_sem (\\<sigma> \\<circ> f)\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>x2a)", "have \"cexpr_sem (case_nat x \\<sigma>) (map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e) =\n                 cexpr_sem (case_nat x \\<sigma> \\<circ> case_nat 0 (\\<lambda>x. Suc (f x))) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem (case_nat x \\<sigma>)\n     (map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e) =\n    cexpr_sem\n     (case_nat x \\<sigma> \\<circ> case_nat 0 (\\<lambda>x. Suc (f x))) e", "by (rule CIntegral.IH)"], ["proof (state)\nthis:\n  cexpr_sem (case_nat x \\<sigma>)\n   (map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e) =\n  cexpr_sem (case_nat x \\<sigma> \\<circ> case_nat 0 (\\<lambda>x. Suc (f x)))\n   e\n\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVar x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVar x)\n 2. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVal x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVal x)\n 3. \\<And>e1 e2 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (map_vars f <e1, e2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma> \\<circ> f) <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (map_vars f (x1a $$\\<^sub>c e)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e3) =\n           cexpr_sem (\\<sigma> \\<circ> f) e3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         cexpr_sem (\\<sigma> \\<circ> f)\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>x2a)", "also"], ["proof (state)\nthis:\n  cexpr_sem (case_nat x \\<sigma>)\n   (map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e) =\n  cexpr_sem (case_nat x \\<sigma> \\<circ> case_nat 0 (\\<lambda>x. Suc (f x)))\n   e\n\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVar x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVar x)\n 2. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVal x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVal x)\n 3. \\<And>e1 e2 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (map_vars f <e1, e2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma> \\<circ> f) <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (map_vars f (x1a $$\\<^sub>c e)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e3) =\n           cexpr_sem (\\<sigma> \\<circ> f) e3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         cexpr_sem (\\<sigma> \\<circ> f)\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>x2a)", "have \"case_nat x \\<sigma> \\<circ> case_nat 0 (\\<lambda>x. Suc (f x)) = case_nat x (\\<lambda>a. \\<sigma> (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat x \\<sigma> \\<circ> case_nat 0 (\\<lambda>x. Suc (f x)) =\n    case_nat x (\\<lambda>a. \\<sigma> (f a))", "by (intro ext) (auto simp add: o_def split: nat.split)"], ["proof (state)\nthis:\n  case_nat x \\<sigma> \\<circ> case_nat 0 (\\<lambda>x. Suc (f x)) =\n  case_nat x (\\<lambda>a. \\<sigma> (f a))\n\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVar x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVar x)\n 2. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVal x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVal x)\n 3. \\<And>e1 e2 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (map_vars f <e1, e2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma> \\<circ> f) <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (map_vars f (x1a $$\\<^sub>c e)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e3) =\n           cexpr_sem (\\<sigma> \\<circ> f) e3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         cexpr_sem (\\<sigma> \\<circ> f)\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>x2a)", "finally"], ["proof (chain)\npicking this:\n  cexpr_sem\n   (\\<lambda>a.\n       case a of 0 \\<Rightarrow> x | Suc a \\<Rightarrow> \\<sigma> a)\n   (map_vars\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> 0 | Suc x \\<Rightarrow> Suc (f x))\n     e) =\n  cexpr_sem\n   (\\<lambda>a.\n       case a of 0 \\<Rightarrow> x | Suc a \\<Rightarrow> \\<sigma> (f a))\n   e", "have \"cexpr_sem (case_nat x \\<sigma>) (map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e) =\n                      cexpr_sem (case_nat x (\\<lambda>a. \\<sigma> (f a))) e\""], ["proof (prove)\nusing this:\n  cexpr_sem\n   (\\<lambda>a.\n       case a of 0 \\<Rightarrow> x | Suc a \\<Rightarrow> \\<sigma> a)\n   (map_vars\n     (\\<lambda>a.\n         case a of 0 \\<Rightarrow> 0 | Suc x \\<Rightarrow> Suc (f x))\n     e) =\n  cexpr_sem\n   (\\<lambda>a.\n       case a of 0 \\<Rightarrow> x | Suc a \\<Rightarrow> \\<sigma> (f a))\n   e\n\ngoal (1 subgoal):\n 1. cexpr_sem (case_nat x \\<sigma>)\n     (map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e) =\n    cexpr_sem (case_nat x (\\<lambda>a. \\<sigma> (f a))) e", "."], ["proof (state)\nthis:\n  cexpr_sem (case_nat x \\<sigma>)\n   (map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e) =\n  cexpr_sem (case_nat x (\\<lambda>a. \\<sigma> (f a))) e\n\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVar x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVar x)\n 2. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVal x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVal x)\n 3. \\<And>e1 e2 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (map_vars f <e1, e2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma> \\<circ> f) <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (map_vars f (x1a $$\\<^sub>c e)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e3) =\n           cexpr_sem (\\<sigma> \\<circ> f) e3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         cexpr_sem (\\<sigma> \\<circ> f)\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>x2a)", "}"], ["proof (state)\nthis:\n  cexpr_sem (case_nat ?x2 \\<sigma>)\n   (map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e) =\n  cexpr_sem (case_nat ?x2 (\\<lambda>a. \\<sigma> (f a))) e\n\ngoal (6 subgoals):\n 1. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVar x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVar x)\n 2. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVal x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVal x)\n 3. \\<And>e1 e2 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (map_vars f <e1, e2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma> \\<circ> f) <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (map_vars f (x1a $$\\<^sub>c e)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e3) =\n           cexpr_sem (\\<sigma> \\<circ> f) e3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         cexpr_sem (\\<sigma> \\<circ> f)\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3)\n 6. \\<And>e x2a \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (map_vars f (\\<integral>\\<^sub>c e \\<partial>x2a)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>x2a)", "thus ?case"], ["proof (prove)\nusing this:\n  cexpr_sem (case_nat ?x2 \\<sigma>)\n   (map_vars (case_nat 0 (\\<lambda>x. Suc (f x))) e) =\n  cexpr_sem (case_nat ?x2 (\\<lambda>a. \\<sigma> (f a))) e\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (map_vars f (\\<integral>\\<^sub>c e \\<partial>t)) =\n    cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>t)", "by simp"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> (map_vars f (\\<integral>\\<^sub>c e \\<partial>t)) =\n  cexpr_sem (\\<sigma> \\<circ> f) (\\<integral>\\<^sub>c e \\<partial>t)\n\ngoal (5 subgoals):\n 1. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVar x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVar x)\n 2. \\<And>x \\<sigma> f.\n       cexpr_sem \\<sigma> (map_vars f (CVal x)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (CVal x)\n 3. \\<And>e1 e2 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma> (map_vars f <e1, e2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma> \\<circ> f) <e1, e2>\\<^sub>c\n 4. \\<And>x1a e \\<sigma> f.\n       (\\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e) =\n           cexpr_sem (\\<sigma> \\<circ> f) e) \\<Longrightarrow>\n       cexpr_sem \\<sigma> (map_vars f (x1a $$\\<^sub>c e)) =\n       cexpr_sem (\\<sigma> \\<circ> f) (x1a $$\\<^sub>c e)\n 5. \\<And>e1 e2 e3 \\<sigma> f.\n       \\<lbrakk>\\<And>\\<sigma> f.\n                   cexpr_sem \\<sigma> (map_vars f e1) =\n                   cexpr_sem (\\<sigma> \\<circ> f) e1;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e2) =\n           cexpr_sem (\\<sigma> \\<circ> f) e2;\n        \\<And>\\<sigma> f.\n           cexpr_sem \\<sigma> (map_vars f e3) =\n           cexpr_sem (\\<sigma> \\<circ> f) e3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (map_vars f (IF\\<^sub>c e1 THEN e2 ELSE e3)) =\n                         cexpr_sem (\\<sigma> \\<circ> f)\n                          (IF\\<^sub>c e1 THEN e2 ELSE e3)", "qed simp_all"], ["", "definition insert_var :: \"vname \\<Rightarrow> (vname \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> vname \\<Rightarrow> 'a\" where\n  \"insert_var v f x w \\<equiv> if w = v then x else if w > v then f (w - 1) else f w\""], ["", "lemma insert_var_0[simp]: \"insert_var 0 f x = case_nat x f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_var 0 f x = case_nat x f", "by (intro ext) (simp add: insert_var_def split: nat.split)"], ["", "text \\<open>\n  Substitutes expression e for variable x in e'.\n\\<close>"], ["", "primrec cexpr_subst :: \"vname \\<Rightarrow> cexpr \\<Rightarrow> cexpr \\<Rightarrow> cexpr\" where\n  \"cexpr_subst _ _ (CVal v) = CVal v\"\n| \"cexpr_subst x e (CVar y) = insert_var x CVar e y\"\n| \"cexpr_subst x e <e1, e2>\\<^sub>c = <cexpr_subst x e e1, cexpr_subst x e e2>\\<^sub>c\"\n| \"cexpr_subst x e (oper $$\\<^sub>c e') = oper $$\\<^sub>c (cexpr_subst x e e')\"\n| \"cexpr_subst x e (IF\\<^sub>c b THEN e1 ELSE e2) =\n      (IF\\<^sub>c cexpr_subst x e b THEN cexpr_subst x e e1 ELSE cexpr_subst x e e2)\"\n| \"cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t) = (\\<integral>\\<^sub>c cexpr_subst (Suc x) (map_vars Suc e) e' \\<partial>t)\""], ["", "lemma cexpr_sem_cexpr_subst_aux:\n    \"cexpr_sem \\<sigma> (cexpr_subst x e e') = cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e)) e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (cexpr_subst x e e') =\n    cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e)) e'", "proof (induction e' arbitrary: x e \\<sigma>)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_subst xa e (CVar x)) =\n       cexpr_sem (insert_var xa \\<sigma> (cexpr_sem \\<sigma> e)) (CVar x)\n 2. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_subst xa e (CVal x)) =\n       cexpr_sem (insert_var xa \\<sigma> (cexpr_sem \\<sigma> e)) (CVal x)\n 3. \\<And>e'1 e'2 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_subst x e e'1) =\n                   cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                    e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'2) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e'2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_subst x e <e'1, e'2>\\<^sub>c) =\n                         cexpr_sem\n                          (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                          <e'1, e'2>\\<^sub>c\n 4. \\<And>x1a e' x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e') =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma> (cexpr_subst x e (x1a $$\\<^sub>c e')) =\n       cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n        (x1a $$\\<^sub>c e')\n 5. \\<And>e'1 e'2 e'3 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_subst x e e'1) =\n                   cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                    e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'2) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e)) e'2;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'3) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e'3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)) =\n                         cexpr_sem\n                          (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                          (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)\n 6. \\<And>e' x2a x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e') =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a)) =\n       cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n        (\\<integral>\\<^sub>c e' \\<partial>x2a)", "case (CIntegral e' t x e \\<sigma>)"], ["proof (state)\nthis:\n  cexpr_sem ?\\<sigma> (cexpr_subst ?x ?e e') =\n  cexpr_sem (insert_var ?x ?\\<sigma> (cexpr_sem ?\\<sigma> ?e)) e'\n\ngoal (6 subgoals):\n 1. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_subst xa e (CVar x)) =\n       cexpr_sem (insert_var xa \\<sigma> (cexpr_sem \\<sigma> e)) (CVar x)\n 2. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_subst xa e (CVal x)) =\n       cexpr_sem (insert_var xa \\<sigma> (cexpr_sem \\<sigma> e)) (CVal x)\n 3. \\<And>e'1 e'2 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_subst x e e'1) =\n                   cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                    e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'2) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e'2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_subst x e <e'1, e'2>\\<^sub>c) =\n                         cexpr_sem\n                          (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                          <e'1, e'2>\\<^sub>c\n 4. \\<And>x1a e' x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e') =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma> (cexpr_subst x e (x1a $$\\<^sub>c e')) =\n       cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n        (x1a $$\\<^sub>c e')\n 5. \\<And>e'1 e'2 e'3 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_subst x e e'1) =\n                   cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                    e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'2) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e)) e'2;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'3) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e'3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)) =\n                         cexpr_sem\n                          (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                          (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)\n 6. \\<And>e' x2a x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e') =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a)) =\n       cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n        (\\<integral>\\<^sub>c e' \\<partial>x2a)", "have A: \"\\<And>y. insert_var (Suc x) (case_nat y \\<sigma>) (cexpr_sem \\<sigma> e) =\n                    case_nat y (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       insert_var (Suc x) (case_nat y \\<sigma>) (cexpr_sem \\<sigma> e) =\n       case_nat y (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))", "by (intro ext) (simp add: insert_var_def split: nat.split)"], ["proof (state)\nthis:\n  insert_var (Suc x) (case_nat ?y \\<sigma>) (cexpr_sem \\<sigma> e) =\n  case_nat ?y (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n\ngoal (6 subgoals):\n 1. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_subst xa e (CVar x)) =\n       cexpr_sem (insert_var xa \\<sigma> (cexpr_sem \\<sigma> e)) (CVar x)\n 2. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_subst xa e (CVal x)) =\n       cexpr_sem (insert_var xa \\<sigma> (cexpr_sem \\<sigma> e)) (CVal x)\n 3. \\<And>e'1 e'2 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_subst x e e'1) =\n                   cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                    e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'2) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e'2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_subst x e <e'1, e'2>\\<^sub>c) =\n                         cexpr_sem\n                          (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                          <e'1, e'2>\\<^sub>c\n 4. \\<And>x1a e' x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e') =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma> (cexpr_subst x e (x1a $$\\<^sub>c e')) =\n       cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n        (x1a $$\\<^sub>c e')\n 5. \\<And>e'1 e'2 e'3 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_subst x e e'1) =\n                   cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                    e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'2) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e)) e'2;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'3) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e'3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)) =\n                         cexpr_sem\n                          (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                          (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)\n 6. \\<And>e' x2a x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e') =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a)) =\n       cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n        (\\<integral>\\<^sub>c e' \\<partial>x2a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma>\n     (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t)) =\n    cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n     (\\<integral>\\<^sub>c e' \\<partial>t)", "by (simp add: o_def A cexpr_sem_map_vars CIntegral.IH)"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma>\n   (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t)) =\n  cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n   (\\<integral>\\<^sub>c e' \\<partial>t)\n\ngoal (5 subgoals):\n 1. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_subst xa e (CVar x)) =\n       cexpr_sem (insert_var xa \\<sigma> (cexpr_sem \\<sigma> e)) (CVar x)\n 2. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_subst xa e (CVal x)) =\n       cexpr_sem (insert_var xa \\<sigma> (cexpr_sem \\<sigma> e)) (CVal x)\n 3. \\<And>e'1 e'2 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_subst x e e'1) =\n                   cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                    e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'2) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e'2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_subst x e <e'1, e'2>\\<^sub>c) =\n                         cexpr_sem\n                          (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                          <e'1, e'2>\\<^sub>c\n 4. \\<And>x1a e' x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e') =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma> (cexpr_subst x e (x1a $$\\<^sub>c e')) =\n       cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n        (x1a $$\\<^sub>c e')\n 5. \\<And>e'1 e'2 e'3 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_subst x e e'1) =\n                   cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                    e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'2) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e)) e'2;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_subst x e e'3) =\n           cexpr_sem (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n            e'3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)) =\n                         cexpr_sem\n                          (insert_var x \\<sigma> (cexpr_sem \\<sigma> e))\n                          (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)", "qed (simp_all add: insert_var_def)"], ["", "text \\<open>\n   This corresponds to a Let-binding; the variable with index 0 is substituted\n   with the given expression.\n\\<close>"], ["", "lemma cexpr_sem_cexpr_subst:\n    \"cexpr_sem \\<sigma> (cexpr_subst 0 e e') = cexpr_sem (case_nat (cexpr_sem \\<sigma> e) \\<sigma>) e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (cexpr_subst 0 e e') =\n    cexpr_sem (case_nat (cexpr_sem \\<sigma> e) \\<sigma>) e'", "using cexpr_sem_cexpr_subst_aux"], ["proof (prove)\nusing this:\n  cexpr_sem ?\\<sigma> (cexpr_subst ?x ?e ?e') =\n  cexpr_sem (insert_var ?x ?\\<sigma> (cexpr_sem ?\\<sigma> ?e)) ?e'\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (cexpr_subst 0 e e') =\n    cexpr_sem (case_nat (cexpr_sem \\<sigma> e) \\<sigma>) e'", "by simp"], ["", "lemma cexpr_typing_subst_aux:\n  assumes \"insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e' : t'\" \"\\<Gamma> \\<turnstile>\\<^sub>c e : t\"\n  shows \"\\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst x e e' : t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst x e e' : t'", "using assms"], ["proof (prove)\nusing this:\n  insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e' : t'\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst x e e' : t'", "proof (induction e' arbitrary: x \\<Gamma> e t')"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVar x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVar x) : t'\n 2. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 3. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 4. \\<And>x1a e' x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c x1a $$\\<^sub>c e' : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e (x1a $$\\<^sub>c e') : t'\n 5. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 6. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "case CVar"], ["proof (state)\nthis:\n  insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c CVar x_ : t'\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t\n\ngoal (6 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVar x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVar x) : t'\n 2. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 3. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 4. \\<And>x1a e' x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c x1a $$\\<^sub>c e' : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e (x1a $$\\<^sub>c e') : t'\n 5. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 6. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "thus ?case"], ["proof (prove)\nusing this:\n  insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c CVar x_ : t'\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst x e (CVar x_) : t'", "by (auto intro!: cexpr_typing.intros simp: insert_var_def)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst x e (CVar x_) : t'\n\ngoal (5 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>x1a e' x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c x1a $$\\<^sub>c e' : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e (x1a $$\\<^sub>c e') : t'\n 4. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 5. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>x1a e' x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c x1a $$\\<^sub>c e' : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e (x1a $$\\<^sub>c e') : t'\n 4. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 5. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "case COperator"], ["proof (state)\nthis:\n  \\<lbrakk>insert_var ?x ?\\<Gamma> t \\<turnstile>\\<^sub>c e'_ : ?t';\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : t\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_subst ?x ?e e'_ : ?t'\n  insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c x1a_ $$\\<^sub>c e'_ : t'\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t\n\ngoal (5 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>x1a e' x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c x1a $$\\<^sub>c e' : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e (x1a $$\\<^sub>c e') : t'\n 4. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 5. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_var ?x ?\\<Gamma> t \\<turnstile>\\<^sub>c e'_ : ?t';\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : t\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_subst ?x ?e e'_ : ?t'\n  insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c x1a_ $$\\<^sub>c e'_ : t'\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst x e (x1a_ $$\\<^sub>c e'_) : t'", "by (auto simp: cexpr_type_Some_iff[symmetric] split: option.split_asm)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst x e (x1a_ $$\\<^sub>c e'_) : t'\n\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "case (CIntegral e' t'')"], ["proof (state)\nthis:\n  \\<lbrakk>insert_var ?x ?\\<Gamma> t \\<turnstile>\\<^sub>c e' : ?t';\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : t\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_subst ?x ?e e' : ?t'\n  insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n   \\<integral>\\<^sub>c e' \\<partial>t'' : t'\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t\n\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "have t': \"t' = REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' = REAL", "using CIntegral.prems(1)"], ["proof (prove)\nusing this:\n  insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n   \\<integral>\\<^sub>c e' \\<partial>t'' : t'\n\ngoal (1 subgoal):\n 1. t' = REAL", "by auto"], ["proof (state)\nthis:\n  t' = REAL\n\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "have \"case_nat t'' (insert_var x \\<Gamma> t) \\<turnstile>\\<^sub>c e' : t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat t'' (insert_var x \\<Gamma> t) \\<turnstile>\\<^sub>c e' : t'", "using CIntegral.prems(1)"], ["proof (prove)\nusing this:\n  insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n   \\<integral>\\<^sub>c e' \\<partial>t'' : t'\n\ngoal (1 subgoal):\n 1. case_nat t'' (insert_var x \\<Gamma> t) \\<turnstile>\\<^sub>c e' : t'", "by auto"], ["proof (state)\nthis:\n  case_nat t'' (insert_var x \\<Gamma> t) \\<turnstile>\\<^sub>c e' : t'\n\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "also"], ["proof (state)\nthis:\n  case_nat t'' (insert_var x \\<Gamma> t) \\<turnstile>\\<^sub>c e' : t'\n\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "have \"case_nat t'' (insert_var x \\<Gamma> t) = insert_var (Suc x) (case_nat t'' \\<Gamma>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat t'' (insert_var x \\<Gamma> t) =\n    insert_var (Suc x) (case_nat t'' \\<Gamma>) t", "by (intro ext) (simp add: insert_var_def split: nat.split)"], ["proof (state)\nthis:\n  case_nat t'' (insert_var x \\<Gamma> t) =\n  insert_var (Suc x) (case_nat t'' \\<Gamma>) t\n\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "finally"], ["proof (chain)\npicking this:\n  insert_var (Suc x) (case_nat t'' \\<Gamma>) t \\<turnstile>\\<^sub>c e' : t'", "have \"insert_var (Suc x) (case_nat t'' \\<Gamma>) t \\<turnstile>\\<^sub>c e' : t'\""], ["proof (prove)\nusing this:\n  insert_var (Suc x) (case_nat t'' \\<Gamma>) t \\<turnstile>\\<^sub>c e' : t'\n\ngoal (1 subgoal):\n 1. insert_var (Suc x) (case_nat t'' \\<Gamma>) t \\<turnstile>\\<^sub>c\n     e' : t'", "."], ["proof (state)\nthis:\n  insert_var (Suc x) (case_nat t'' \\<Gamma>) t \\<turnstile>\\<^sub>c e' : t'\n\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "moreover"], ["proof (state)\nthis:\n  insert_var (Suc x) (case_nat t'' \\<Gamma>) t \\<turnstile>\\<^sub>c e' : t'\n\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "from CIntegral.prems(2)"], ["proof (chain)\npicking this:\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t", "have \"case_nat t'' \\<Gamma> \\<turnstile>\\<^sub>c map_vars Suc e : t\""], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t\n\ngoal (1 subgoal):\n 1. case_nat t'' \\<Gamma> \\<turnstile>\\<^sub>c map_vars Suc e : t", "by (intro cexpr_typing_map_vars) (simp add: o_def)"], ["proof (state)\nthis:\n  case_nat t'' \\<Gamma> \\<turnstile>\\<^sub>c map_vars Suc e : t\n\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "ultimately"], ["proof (chain)\npicking this:\n  insert_var (Suc x) (case_nat t'' \\<Gamma>) t \\<turnstile>\\<^sub>c e' : t'\n  case_nat t'' \\<Gamma> \\<turnstile>\\<^sub>c map_vars Suc e : t", "have \"case_nat t'' \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst (Suc x) (map_vars Suc e) e' : t'\""], ["proof (prove)\nusing this:\n  insert_var (Suc x) (case_nat t'' \\<Gamma>) t \\<turnstile>\\<^sub>c e' : t'\n  case_nat t'' \\<Gamma> \\<turnstile>\\<^sub>c map_vars Suc e : t\n\ngoal (1 subgoal):\n 1. case_nat t'' \\<Gamma> \\<turnstile>\\<^sub>c\n     cexpr_subst (Suc x) (map_vars Suc e) e' : t'", "by (rule CIntegral.IH)"], ["proof (state)\nthis:\n  case_nat t'' \\<Gamma> \\<turnstile>\\<^sub>c\n   cexpr_subst (Suc x) (map_vars Suc e) e' : t'\n\ngoal (4 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'\n 4. \\<And>e' x2a x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e' : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e' : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t'", "thus ?case"], ["proof (prove)\nusing this:\n  case_nat t'' \\<Gamma> \\<turnstile>\\<^sub>c\n   cexpr_subst (Suc x) (map_vars Suc e) e' : t'\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c\n     cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t'') : t'", "by (auto intro: cet_int simp: t')"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>c\n   cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t'') : t'\n\ngoal (3 subgoals):\n 1. \\<And>x xa \\<Gamma> e t'.\n       \\<lbrakk>insert_var xa \\<Gamma> t \\<turnstile>\\<^sub>c CVal x : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst xa e (CVal x) : t'\n 2. \\<And>e'1 e'2 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         <e'1, e'2>\\<^sub>c : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e <e'1, e'2>\\<^sub>c : t'\n 3. \\<And>e'1 e'2 e'3 x \\<Gamma> e t'.\n       \\<lbrakk>\\<And>x \\<Gamma> e t'.\n                   \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n                             e'1 : t';\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_subst x e e'1 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'2 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'2 : t';\n        \\<And>x \\<Gamma> e t'.\n           \\<lbrakk>insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c e'3 : t';\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_subst x e e'3 : t';\n        insert_var x \\<Gamma> t \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t';\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_subst x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t'", "qed (auto intro!: cexpr_typing.intros)"], ["", "lemma cexpr_typing_subst[intro]:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e : t\" \"case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e' : t'\"\n  shows \"\\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst 0 e e' : t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst 0 e e' : t'", "using cexpr_typing_subst_aux assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_var ?x ?\\<Gamma> ?t \\<turnstile>\\<^sub>c ?e' : ?t';\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_subst ?x ?e ?e' : ?t'\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t\n  case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e' : t'\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst 0 e e' : t'", "by simp"], ["", "lemma free_vars_cexpr_subst_aux:\n  \"free_vars (cexpr_subst x e e') \\<subseteq> (\\<lambda>y. if y \\<ge> x then y + 1 else y) -` free_vars e' \\<union> free_vars e\"\n    (is \"free_vars _ \\<subseteq> ?f x -` _ \\<union> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (cexpr_subst x e e')\n    \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                free_vars e' \\<union>\n                free_vars e", "proof (induction e' arbitrary: x e)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVar x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVar x) \\<union>\n                   free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_subst x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars <e'1, e'2>\\<^sub>c \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (x1a $$\\<^sub>c e') \\<union>\n                   free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 6. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "case (CVar y x e)"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVar x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVar x) \\<union>\n                   free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_subst x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars <e'1, e'2>\\<^sub>c \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (x1a $$\\<^sub>c e') \\<union>\n                   free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 6. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (cexpr_subst x e (CVar y))\n    \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                free_vars (CVar y) \\<union>\n                free_vars e", "by (auto simp: insert_var_def)"], ["proof (state)\nthis:\n  free_vars (cexpr_subst x e (CVar y))\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars (CVar y) \\<union>\n              free_vars e\n\ngoal (5 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_subst x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars <e'1, e'2>\\<^sub>c \\<union>\n                                     free_vars e\n 3. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (x1a $$\\<^sub>c e') \\<union>\n                   free_vars e\n 4. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 5. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_subst x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars <e'1, e'2>\\<^sub>c \\<union>\n                                     free_vars e\n 3. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (x1a $$\\<^sub>c e') \\<union>\n                   free_vars e\n 4. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 5. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "case (CPair e'1 e'2 x e)"], ["proof (state)\nthis:\n  free_vars (cexpr_subst ?x ?e e'1)\n  \\<subseteq> (\\<lambda>y. if ?x \\<le> y then y + 1 else y) -`\n              free_vars e'1 \\<union>\n              free_vars ?e\n  free_vars (cexpr_subst ?x ?e e'2)\n  \\<subseteq> (\\<lambda>y. if ?x \\<le> y then y + 1 else y) -`\n              free_vars e'2 \\<union>\n              free_vars ?e\n\ngoal (5 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_subst x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars <e'1, e'2>\\<^sub>c \\<union>\n                                     free_vars e\n 3. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (x1a $$\\<^sub>c e') \\<union>\n                   free_vars e\n 4. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 5. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "from CPair.IH[of x e]"], ["proof (chain)\npicking this:\n  free_vars (cexpr_subst x e e'1)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars e'1 \\<union>\n              free_vars e\n  free_vars (cexpr_subst x e e'2)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars e'2 \\<union>\n              free_vars e", "show ?case"], ["proof (prove)\nusing this:\n  free_vars (cexpr_subst x e e'1)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars e'1 \\<union>\n              free_vars e\n  free_vars (cexpr_subst x e e'2)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars e'2 \\<union>\n              free_vars e\n\ngoal (1 subgoal):\n 1. free_vars (cexpr_subst x e <e'1, e'2>\\<^sub>c)\n    \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                free_vars <e'1, e'2>\\<^sub>c \\<union>\n                free_vars e", "by auto"], ["proof (state)\nthis:\n  free_vars (cexpr_subst x e <e'1, e'2>\\<^sub>c)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars <e'1, e'2>\\<^sub>c \\<union>\n              free_vars e\n\ngoal (4 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (x1a $$\\<^sub>c e') \\<union>\n                   free_vars e\n 3. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 4. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (x1a $$\\<^sub>c e') \\<union>\n                   free_vars e\n 3. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 4. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "case (COperator _ _ x e)"], ["proof (state)\nthis:\n  free_vars (cexpr_subst ?x ?e e'_)\n  \\<subseteq> (\\<lambda>y. if ?x \\<le> y then y + 1 else y) -`\n              free_vars e'_ \\<union>\n              free_vars ?e\n\ngoal (4 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (x1a $$\\<^sub>c e') \\<union>\n                   free_vars e\n 3. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 4. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "from COperator.IH[of x e]"], ["proof (chain)\npicking this:\n  free_vars (cexpr_subst x e e'_)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars e'_ \\<union>\n              free_vars e", "show ?case"], ["proof (prove)\nusing this:\n  free_vars (cexpr_subst x e e'_)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars e'_ \\<union>\n              free_vars e\n\ngoal (1 subgoal):\n 1. free_vars (cexpr_subst x e (x1a_ $$\\<^sub>c e'_))\n    \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                free_vars (x1a_ $$\\<^sub>c e'_) \\<union>\n                free_vars e", "by auto"], ["proof (state)\nthis:\n  free_vars (cexpr_subst x e (x1a_ $$\\<^sub>c e'_))\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars (x1a_ $$\\<^sub>c e'_) \\<union>\n              free_vars e\n\ngoal (3 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 3. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 3. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "case (CIf b e'1 e'2 x e)"], ["proof (state)\nthis:\n  free_vars (cexpr_subst ?x ?e b)\n  \\<subseteq> (\\<lambda>y. if ?x \\<le> y then y + 1 else y) -`\n              free_vars b \\<union>\n              free_vars ?e\n  free_vars (cexpr_subst ?x ?e e'1)\n  \\<subseteq> (\\<lambda>y. if ?x \\<le> y then y + 1 else y) -`\n              free_vars e'1 \\<union>\n              free_vars ?e\n  free_vars (cexpr_subst ?x ?e e'2)\n  \\<subseteq> (\\<lambda>y. if ?x \\<le> y then y + 1 else y) -`\n              free_vars e'2 \\<union>\n              free_vars ?e\n\ngoal (3 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_subst x e e'1)\n                   \\<subseteq> (\\<lambda>y.\n                                   if x \\<le> y then y + 1 else y) -`\n                               free_vars e'1 \\<union>\n                               free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'2)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'2 \\<union>\n                       free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_subst x e e'3)\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e'3 \\<union>\n                       free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_subst x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> (\\<lambda>y.\n   if x \\<le> y then y + 1 else y) -`\n                                     free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) \\<union>\n                                     free_vars e\n 3. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "from CIf.IH[of x e]"], ["proof (chain)\npicking this:\n  free_vars (cexpr_subst x e b)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars b \\<union>\n              free_vars e\n  free_vars (cexpr_subst x e e'1)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars e'1 \\<union>\n              free_vars e\n  free_vars (cexpr_subst x e e'2)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars e'2 \\<union>\n              free_vars e", "show ?case"], ["proof (prove)\nusing this:\n  free_vars (cexpr_subst x e b)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars b \\<union>\n              free_vars e\n  free_vars (cexpr_subst x e e'1)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars e'1 \\<union>\n              free_vars e\n  free_vars (cexpr_subst x e e'2)\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars e'2 \\<union>\n              free_vars e\n\ngoal (1 subgoal):\n 1. free_vars (cexpr_subst x e (IF\\<^sub>c b THEN e'1 ELSE e'2))\n    \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                free_vars (IF\\<^sub>c b THEN e'1 ELSE e'2) \\<union>\n                free_vars e", "by auto"], ["proof (state)\nthis:\n  free_vars (cexpr_subst x e (IF\\<^sub>c b THEN e'1 ELSE e'2))\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars (IF\\<^sub>c b THEN e'1 ELSE e'2) \\<union>\n              free_vars e\n\ngoal (2 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "case (CIntegral e' t x e)"], ["proof (state)\nthis:\n  free_vars (cexpr_subst ?x ?e e')\n  \\<subseteq> (\\<lambda>y. if ?x \\<le> y then y + 1 else y) -`\n              free_vars e' \\<union>\n              free_vars ?e\n\ngoal (2 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "have \"free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t)) \\<subseteq>\n          Suc -` (?f (Suc x) -` free_vars e') \\<union>\n          Suc -` (free_vars (map_vars Suc e))\" (is \"_ \\<subseteq> ?A \\<union> ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t))\n    \\<subseteq> Suc -`\n                (\\<lambda>a. if Suc x \\<le> a then a + 1 else a) -`\n                free_vars e' \\<union>\n                Suc -` free_vars (map_vars Suc e)", "by (simp only: cexpr_subst.simps free_vars_cexpr.simps\n                   vimage_mono CIntegral.IH vimage_Un[symmetric])"], ["proof (state)\nthis:\n  free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t))\n  \\<subseteq> Suc -`\n              (\\<lambda>a. if Suc x \\<le> a then a + 1 else a) -`\n              free_vars e' \\<union>\n              Suc -` free_vars (map_vars Suc e)\n\ngoal (2 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "also"], ["proof (state)\nthis:\n  free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t))\n  \\<subseteq> Suc -`\n              (\\<lambda>a. if Suc x \\<le> a then a + 1 else a) -`\n              free_vars e' \\<union>\n              Suc -` free_vars (map_vars Suc e)\n\ngoal (2 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "have \"?B = free_vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc -` free_vars (map_vars Suc e) = free_vars e", "by (simp add: inj_vimage_image_eq)"], ["proof (state)\nthis:\n  Suc -` free_vars (map_vars Suc e) = free_vars e\n\ngoal (2 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "also"], ["proof (state)\nthis:\n  Suc -` free_vars (map_vars Suc e) = free_vars e\n\ngoal (2 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "have \"?A \\<subseteq> ?f x -` free_vars (\\<integral>\\<^sub>c e' \\<partial>t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc -` (\\<lambda>a. if Suc x \\<le> a then a + 1 else a) -` free_vars e'\n    \\<subseteq> (\\<lambda>a. if x \\<le> a then a + 1 else a) -`\n                free_vars (\\<integral>\\<^sub>c e' \\<partial>t)", "by auto"], ["proof (state)\nthis:\n  Suc -` (\\<lambda>a. if Suc x \\<le> a then a + 1 else a) -` free_vars e'\n  \\<subseteq> (\\<lambda>a. if x \\<le> a then a + 1 else a) -`\n              free_vars (\\<integral>\\<^sub>c e' \\<partial>t)\n\ngoal (2 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e\n 2. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_subst x e e')\n           \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                       free_vars e' \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                   free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) \\<union>\n                   free_vars e", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<subseteq> y \\<Longrightarrow>\n      x \\<union> free_vars e\n      \\<subseteq> y \\<union> free_vars e) \\<Longrightarrow>\n  free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t))\n  \\<subseteq> (\\<lambda>a. if x \\<le> a then a + 1 else a) -`\n              free_vars (\\<integral>\\<^sub>c e' \\<partial>t) \\<union>\n              free_vars e", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<subseteq> y \\<Longrightarrow>\n      x \\<union> free_vars e\n      \\<subseteq> y \\<union> free_vars e) \\<Longrightarrow>\n  free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t))\n  \\<subseteq> (\\<lambda>a. if x \\<le> a then a + 1 else a) -`\n              free_vars (\\<integral>\\<^sub>c e' \\<partial>t) \\<union>\n              free_vars e\n\ngoal (1 subgoal):\n 1. free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t))\n    \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n                free_vars (\\<integral>\\<^sub>c e' \\<partial>t) \\<union>\n                free_vars e", "by blast"], ["proof (state)\nthis:\n  free_vars (cexpr_subst x e (\\<integral>\\<^sub>c e' \\<partial>t))\n  \\<subseteq> (\\<lambda>y. if x \\<le> y then y + 1 else y) -`\n              free_vars (\\<integral>\\<^sub>c e' \\<partial>t) \\<union>\n              free_vars e\n\ngoal (1 subgoal):\n 1. \\<And>x xa e.\n       free_vars (cexpr_subst xa e (CVal x))\n       \\<subseteq> (\\<lambda>y. if xa \\<le> y then y + 1 else y) -`\n                   free_vars (CVal x) \\<union>\n                   free_vars e", "qed simp_all"], ["", "lemma free_vars_cexpr_subst:\n    \"free_vars (cexpr_subst 0 e e') \\<subseteq> Suc -` free_vars e' \\<union> free_vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (cexpr_subst 0 e e')\n    \\<subseteq> Suc -` free_vars e' \\<union> free_vars e", "by (rule order.trans[OF free_vars_cexpr_subst_aux]) (auto simp: shift_var_set_def)"], ["", "primrec cexpr_comp_aux :: \"vname \\<Rightarrow> cexpr \\<Rightarrow> cexpr \\<Rightarrow> cexpr\" where\n  \"cexpr_comp_aux _ _ (CVal v) = CVal v\"\n| \"cexpr_comp_aux x e (CVar y) = (if x = y then e else CVar y)\"\n| \"cexpr_comp_aux x e <e1, e2>\\<^sub>c = <cexpr_comp_aux x e e1, cexpr_comp_aux x e e2>\\<^sub>c\"\n| \"cexpr_comp_aux x e (oper $$\\<^sub>c e') = oper $$\\<^sub>c (cexpr_comp_aux x e e')\"\n| \"cexpr_comp_aux x e (IF\\<^sub>c b THEN e1 ELSE e2) =\n      (IF\\<^sub>c cexpr_comp_aux x e b THEN cexpr_comp_aux x e e1 ELSE cexpr_comp_aux x e e2)\"\n| \"cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t) = (\\<integral>\\<^sub>c cexpr_comp_aux (Suc x) (map_vars Suc e) e' \\<partial>t)\""], ["", "lemma cexpr_sem_cexpr_comp_aux:\n    \"cexpr_sem \\<sigma> (cexpr_comp_aux x e e') = cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (cexpr_comp_aux x e e') =\n    cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'", "proof (induction e' arbitrary: x e \\<sigma>)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_comp_aux xa e (CVar x)) =\n       cexpr_sem (\\<sigma>(xa := cexpr_sem \\<sigma> e)) (CVar x)\n 2. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_comp_aux xa e (CVal x)) =\n       cexpr_sem (\\<sigma>(xa := cexpr_sem \\<sigma> e)) (CVal x)\n 3. \\<And>e'1 e'2 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_comp_aux x e e'1) =\n                   cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'2) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n                          <e'1, e'2>\\<^sub>c\n 4. \\<And>x1a e' x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e') =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma> (cexpr_comp_aux x e (x1a $$\\<^sub>c e')) =\n       cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) (x1a $$\\<^sub>c e')\n 5. \\<And>e'1 e'2 e'3 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_comp_aux x e e'1) =\n                   cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'2) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'2;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'3) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)) =\n                         cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n                          (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)\n 6. \\<And>e' x2a x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e') =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a)) =\n       cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n        (\\<integral>\\<^sub>c e' \\<partial>x2a)", "case (CIntegral e' t x e \\<sigma>)"], ["proof (state)\nthis:\n  cexpr_sem ?\\<sigma> (cexpr_comp_aux ?x ?e e') =\n  cexpr_sem (?\\<sigma>(?x := cexpr_sem ?\\<sigma> ?e)) e'\n\ngoal (6 subgoals):\n 1. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_comp_aux xa e (CVar x)) =\n       cexpr_sem (\\<sigma>(xa := cexpr_sem \\<sigma> e)) (CVar x)\n 2. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_comp_aux xa e (CVal x)) =\n       cexpr_sem (\\<sigma>(xa := cexpr_sem \\<sigma> e)) (CVal x)\n 3. \\<And>e'1 e'2 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_comp_aux x e e'1) =\n                   cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'2) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n                          <e'1, e'2>\\<^sub>c\n 4. \\<And>x1a e' x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e') =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma> (cexpr_comp_aux x e (x1a $$\\<^sub>c e')) =\n       cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) (x1a $$\\<^sub>c e')\n 5. \\<And>e'1 e'2 e'3 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_comp_aux x e e'1) =\n                   cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'2) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'2;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'3) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)) =\n                         cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n                          (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)\n 6. \\<And>e' x2a x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e') =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a)) =\n       cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n        (\\<integral>\\<^sub>c e' \\<partial>x2a)", "have \"\\<And>y. (case_nat y \\<sigma>)(Suc x := cexpr_sem (case_nat y \\<sigma>) (map_vars Suc e)) =\n                 case_nat y (\\<sigma>(x := cexpr_sem \\<sigma> e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (case_nat y \\<sigma>)\n       (Suc x := cexpr_sem (case_nat y \\<sigma>) (map_vars Suc e)) =\n       case_nat y (\\<sigma>(x := cexpr_sem \\<sigma> e))", "by (intro ext) (auto simp: cexpr_sem_map_vars o_def split: nat.split)"], ["proof (state)\nthis:\n  (case_nat ?y \\<sigma>)\n  (Suc x := cexpr_sem (case_nat ?y \\<sigma>) (map_vars Suc e)) =\n  case_nat ?y (\\<sigma>(x := cexpr_sem \\<sigma> e))\n\ngoal (6 subgoals):\n 1. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_comp_aux xa e (CVar x)) =\n       cexpr_sem (\\<sigma>(xa := cexpr_sem \\<sigma> e)) (CVar x)\n 2. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_comp_aux xa e (CVal x)) =\n       cexpr_sem (\\<sigma>(xa := cexpr_sem \\<sigma> e)) (CVal x)\n 3. \\<And>e'1 e'2 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_comp_aux x e e'1) =\n                   cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'2) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n                          <e'1, e'2>\\<^sub>c\n 4. \\<And>x1a e' x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e') =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma> (cexpr_comp_aux x e (x1a $$\\<^sub>c e')) =\n       cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) (x1a $$\\<^sub>c e')\n 5. \\<And>e'1 e'2 e'3 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_comp_aux x e e'1) =\n                   cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'2) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'2;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'3) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)) =\n                         cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n                          (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)\n 6. \\<And>e' x2a x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e') =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma>\n        (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a)) =\n       cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n        (\\<integral>\\<^sub>c e' \\<partial>x2a)", "thus ?case"], ["proof (prove)\nusing this:\n  (case_nat ?y \\<sigma>)\n  (Suc x := cexpr_sem (case_nat ?y \\<sigma>) (map_vars Suc e)) =\n  case_nat ?y (\\<sigma>(x := cexpr_sem \\<sigma> e))\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma>\n     (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t)) =\n    cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n     (\\<integral>\\<^sub>c e' \\<partial>t)", "by (auto intro!: integral_cong simp: CIntegral.IH simp del: fun_upd_apply)"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma>\n   (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t)) =\n  cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n   (\\<integral>\\<^sub>c e' \\<partial>t)\n\ngoal (5 subgoals):\n 1. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_comp_aux xa e (CVar x)) =\n       cexpr_sem (\\<sigma>(xa := cexpr_sem \\<sigma> e)) (CVar x)\n 2. \\<And>x xa e \\<sigma>.\n       cexpr_sem \\<sigma> (cexpr_comp_aux xa e (CVal x)) =\n       cexpr_sem (\\<sigma>(xa := cexpr_sem \\<sigma> e)) (CVal x)\n 3. \\<And>e'1 e'2 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_comp_aux x e e'1) =\n                   cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'2) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'2\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c) =\n                         cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n                          <e'1, e'2>\\<^sub>c\n 4. \\<And>x1a e' x e \\<sigma>.\n       (\\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e') =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n            e') \\<Longrightarrow>\n       cexpr_sem \\<sigma> (cexpr_comp_aux x e (x1a $$\\<^sub>c e')) =\n       cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) (x1a $$\\<^sub>c e')\n 5. \\<And>e'1 e'2 e'3 x e \\<sigma>.\n       \\<lbrakk>\\<And>x e \\<sigma>.\n                   cexpr_sem \\<sigma> (cexpr_comp_aux x e e'1) =\n                   cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'1;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'2) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'2;\n        \\<And>x e \\<sigma>.\n           cexpr_sem \\<sigma> (cexpr_comp_aux x e e'3) =\n           cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e)) e'3\\<rbrakk>\n       \\<Longrightarrow> cexpr_sem \\<sigma>\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)) =\n                         cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> e))\n                          (IF\\<^sub>c e'1 THEN e'2 ELSE e'3)", "qed (simp_all add: insert_var_def)"], ["", "definition cexpr_comp (infixl \"\\<circ>\\<^sub>c\" 55) where\n  \"cexpr_comp b a \\<equiv> cexpr_comp_aux 0 a b\""], ["", "lemma cexpr_typing_cexpr_comp_aux:\n  assumes \"\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2\" \"\\<Gamma> \\<turnstile>\\<^sub>c e : t1\"\n  shows \"\\<Gamma> \\<turnstile>\\<^sub>c cexpr_comp_aux x e e' : t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c cexpr_comp_aux x e e' : t2", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t1\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c cexpr_comp_aux x e e' : t2", "proof (induction e' arbitrary: \\<Gamma> e x t2)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c <e'1, e'2>\\<^sub>c : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e <e'1, e'2>\\<^sub>c : t2\n 4. \\<And>x1a e' \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c x1a $$\\<^sub>c e' : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e (x1a $$\\<^sub>c e') : t2\n 5. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 6. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "case COperator"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<Gamma>(?x := t1) \\<turnstile>\\<^sub>c e'_ : ?t2.0;\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : t1\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_comp_aux ?x ?e e'_ : ?t2.0\n  \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c x1a_ $$\\<^sub>c e'_ : t2\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t1\n\ngoal (6 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c <e'1, e'2>\\<^sub>c : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e <e'1, e'2>\\<^sub>c : t2\n 4. \\<And>x1a e' \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c x1a $$\\<^sub>c e' : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e (x1a $$\\<^sub>c e') : t2\n 5. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 6. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<Gamma>(?x := t1) \\<turnstile>\\<^sub>c e'_ : ?t2.0;\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : t1\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_comp_aux ?x ?e e'_ : ?t2.0\n  \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c x1a_ $$\\<^sub>c e'_ : t2\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t1\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c\n     cexpr_comp_aux x e (x1a_ $$\\<^sub>c e'_) : t2", "by (elim cexpr_typing_opE) (auto intro!: cexpr_typing.intros) []"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>c\n   cexpr_comp_aux x e (x1a_ $$\\<^sub>c e'_) : t2\n\ngoal (5 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c <e'1, e'2>\\<^sub>c : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e <e'1, e'2>\\<^sub>c : t2\n 4. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 5. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c <e'1, e'2>\\<^sub>c : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e <e'1, e'2>\\<^sub>c : t2\n 4. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 5. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "case CPair"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<Gamma>(?x := t1) \\<turnstile>\\<^sub>c e'1_ : ?t2.0;\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : t1\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_comp_aux ?x ?e e'1_ : ?t2.0\n  \\<lbrakk>?\\<Gamma>(?x := t1) \\<turnstile>\\<^sub>c e'2_ : ?t2.0;\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : t1\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_comp_aux ?x ?e e'2_ : ?t2.0\n  \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c <e'1_, e'2_>\\<^sub>c : t2\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t1\n\ngoal (5 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c <e'1, e'2>\\<^sub>c : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e <e'1, e'2>\\<^sub>c : t2\n 4. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 5. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<Gamma>(?x := t1) \\<turnstile>\\<^sub>c e'1_ : ?t2.0;\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : t1\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_comp_aux ?x ?e e'1_ : ?t2.0\n  \\<lbrakk>?\\<Gamma>(?x := t1) \\<turnstile>\\<^sub>c e'2_ : ?t2.0;\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : t1\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_comp_aux ?x ?e e'2_ : ?t2.0\n  \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c <e'1_, e'2_>\\<^sub>c : t2\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t1\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c\n     cexpr_comp_aux x e <e'1_, e'2_>\\<^sub>c : t2", "by (elim cexpr_typing_pairE) (auto intro!: cexpr_typing.intros) []"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>c cexpr_comp_aux x e <e'1_, e'2_>\\<^sub>c : t2\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 4. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 4. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "case (CIntegral e' t \\<Gamma> e x t2)"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<Gamma>(?x := t1) \\<turnstile>\\<^sub>c e' : ?t2.0;\n   ?\\<Gamma> \\<turnstile>\\<^sub>c ?e : t1\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<turnstile>\\<^sub>c\n                     cexpr_comp_aux ?x ?e e' : ?t2.0\n  \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n   \\<integral>\\<^sub>c e' \\<partial>t : t2\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t1\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 4. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "from CIntegral.prems"], ["proof (chain)\npicking this:\n  \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n   \\<integral>\\<^sub>c e' \\<partial>t : t2\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t1", "have [simp]: \"t2 = REAL\""], ["proof (prove)\nusing this:\n  \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n   \\<integral>\\<^sub>c e' \\<partial>t : t2\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t1\n\ngoal (1 subgoal):\n 1. t2 = REAL", "by auto"], ["proof (state)\nthis:\n  t2 = REAL\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 4. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "from CIntegral.prems"], ["proof (chain)\npicking this:\n  \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n   \\<integral>\\<^sub>c e' \\<partial>t : t2\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t1", "have \"case_nat t (\\<Gamma>(x := t1)) \\<turnstile>\\<^sub>c e' : REAL\""], ["proof (prove)\nusing this:\n  \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n   \\<integral>\\<^sub>c e' \\<partial>t : t2\n  \\<Gamma> \\<turnstile>\\<^sub>c e : t1\n\ngoal (1 subgoal):\n 1. case_nat t (\\<Gamma>(x := t1)) \\<turnstile>\\<^sub>c e' : REAL", "by (elim cexpr_typing_intE)"], ["proof (state)\nthis:\n  case_nat t (\\<Gamma>(x := t1)) \\<turnstile>\\<^sub>c e' : REAL\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 4. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "also"], ["proof (state)\nthis:\n  case_nat t (\\<Gamma>(x := t1)) \\<turnstile>\\<^sub>c e' : REAL\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 4. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "have \"case_nat t (\\<Gamma>(x := t1)) = (case_nat t \\<Gamma>)(Suc x := t1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat t (\\<Gamma>(x := t1)) = (case_nat t \\<Gamma>)(Suc x := t1)", "by (intro ext) (simp split: nat.split)"], ["proof (state)\nthis:\n  case_nat t (\\<Gamma>(x := t1)) = (case_nat t \\<Gamma>)(Suc x := t1)\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 4. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "finally"], ["proof (chain)\npicking this:\n  (case_nat t \\<Gamma>)(Suc x := t1) \\<turnstile>\\<^sub>c e' : REAL", "have \"... \\<turnstile>\\<^sub>c e' : REAL\""], ["proof (prove)\nusing this:\n  (case_nat t \\<Gamma>)(Suc x := t1) \\<turnstile>\\<^sub>c e' : REAL\n\ngoal (1 subgoal):\n 1. (case_nat t \\<Gamma>)(Suc x := t1) \\<turnstile>\\<^sub>c e' : REAL", "."], ["proof (state)\nthis:\n  (case_nat t \\<Gamma>)(Suc x := t1) \\<turnstile>\\<^sub>c e' : REAL\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2\n 4. \\<And>e' x2a \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e' : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e' : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         \\<integral>\\<^sub>c e' \\<partial>x2a : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (\\<integral>\\<^sub>c e' \\<partial>x2a) :\n                          t2", "thus \"\\<Gamma> \\<turnstile>\\<^sub>c cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t) : t2\""], ["proof (prove)\nusing this:\n  (case_nat t \\<Gamma>)(Suc x := t1) \\<turnstile>\\<^sub>c e' : REAL\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c\n     cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t) : t2", "by (auto intro!: cexpr_typing.intros CIntegral.IH cexpr_typing_map_vars\n             simp: o_def CIntegral.prems)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>c\n   cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t) : t2\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVar x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVar x) : t2\n 2. \\<And>x \\<Gamma> e xa t2.\n       \\<lbrakk>\\<Gamma>(xa := t1) \\<turnstile>\\<^sub>c CVal x : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux xa e (CVal x) : t2\n 3. \\<And>e'1 e'2 e'3 \\<Gamma> e x t2.\n       \\<lbrakk>\\<And>\\<Gamma> e x t2.\n                   \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'1 : t2;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\ncexpr_comp_aux x e e'1 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'2 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'2 : t2;\n        \\<And>\\<Gamma> e x t2.\n           \\<lbrakk>\\<Gamma>(x := t1) \\<turnstile>\\<^sub>c e'3 : t2;\n            \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n           \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                              cexpr_comp_aux x e e'3 : t2;\n        \\<Gamma>(x := t1) \\<turnstile>\\<^sub>c\n         IF\\<^sub>c e'1 THEN e'2 ELSE e'3 : t2;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : t1\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                          cexpr_comp_aux x e\n                           (IF\\<^sub>c e'1 THEN e'2 ELSE e'3) :\n                          t2", "qed (auto intro!: cexpr_typing.intros)"], ["", "lemma cexpr_typing_cexpr_comp[intro]:\n  assumes \"case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c g : t2\"\n  assumes \"case_nat t2 \\<Gamma> \\<turnstile>\\<^sub>c f : t3\"\n  shows \"case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c f \\<circ>\\<^sub>c g : t3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c f \\<circ>\\<^sub>c g : t3", "proof (unfold cexpr_comp_def, intro cexpr_typing_cexpr_comp_aux)"], ["proof (state)\ngoal (2 subgoals):\n 1. (case_nat t1 \\<Gamma>)(0 := ?t1.0) \\<turnstile>\\<^sub>c f : t3\n 2. case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c g : ?t1.0", "have \"(case_nat t1 \\<Gamma>)(0 := t2) = case_nat t2 \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case_nat t1 \\<Gamma>)(0 := t2) = case_nat t2 \\<Gamma>", "by (intro ext) (simp split: nat.split)"], ["proof (state)\nthis:\n  (case_nat t1 \\<Gamma>)(0 := t2) = case_nat t2 \\<Gamma>\n\ngoal (2 subgoals):\n 1. (case_nat t1 \\<Gamma>)(0 := ?t1.0) \\<turnstile>\\<^sub>c f : t3\n 2. case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c g : ?t1.0", "with assms"], ["proof (chain)\npicking this:\n  case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c g : t2\n  case_nat t2 \\<Gamma> \\<turnstile>\\<^sub>c f : t3\n  (case_nat t1 \\<Gamma>)(0 := t2) = case_nat t2 \\<Gamma>", "show \"(case_nat t1 \\<Gamma>)(0 := t2) \\<turnstile>\\<^sub>c f : t3\""], ["proof (prove)\nusing this:\n  case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c g : t2\n  case_nat t2 \\<Gamma> \\<turnstile>\\<^sub>c f : t3\n  (case_nat t1 \\<Gamma>)(0 := t2) = case_nat t2 \\<Gamma>\n\ngoal (1 subgoal):\n 1. (case_nat t1 \\<Gamma>)(0 := t2) \\<turnstile>\\<^sub>c f : t3", "by simp"], ["proof (state)\nthis:\n  (case_nat t1 \\<Gamma>)(0 := t2) \\<turnstile>\\<^sub>c f : t3\n\ngoal (1 subgoal):\n 1. case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c g : t2", "qed (insert assms)"], ["", "lemma free_vars_cexpr_comp_aux:\n  \"free_vars (cexpr_comp_aux x e e') \\<subseteq> (free_vars e' - {x}) \\<union> free_vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (cexpr_comp_aux x e e')\n    \\<subseteq> free_vars e' - {x} \\<union> free_vars e", "proof (induction e' arbitrary: x e)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVar x))\n       \\<subseteq> free_vars (CVar x) - {xa} \\<union> free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVal x))\n       \\<subseteq> free_vars (CVal x) - {xa} \\<union> free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> free_vars <e'1, e'2>\\<^sub>c -\n                                     {x} \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> free_vars (x1a $$\\<^sub>c e') - {x} \\<union> free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'3)\n           \\<subseteq> free_vars e'3 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) -\n                                     {x} \\<union>\n                                     free_vars e\n 6. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) -\n                   {x} \\<union>\n                   free_vars e", "case (CIntegral e' t x e)"], ["proof (state)\nthis:\n  free_vars (cexpr_comp_aux ?x ?e e')\n  \\<subseteq> free_vars e' - {?x} \\<union> free_vars ?e\n\ngoal (6 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVar x))\n       \\<subseteq> free_vars (CVar x) - {xa} \\<union> free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVal x))\n       \\<subseteq> free_vars (CVal x) - {xa} \\<union> free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> free_vars <e'1, e'2>\\<^sub>c -\n                                     {x} \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> free_vars (x1a $$\\<^sub>c e') - {x} \\<union> free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'3)\n           \\<subseteq> free_vars e'3 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) -\n                                     {x} \\<union>\n                                     free_vars e\n 6. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) -\n                   {x} \\<union>\n                   free_vars e", "note IH = CIntegral.IH[of \"Suc x\" \"map_vars Suc e\"]"], ["proof (state)\nthis:\n  free_vars (cexpr_comp_aux (Suc x) (map_vars Suc e) e')\n  \\<subseteq> free_vars e' - {Suc x} \\<union> free_vars (map_vars Suc e)\n\ngoal (6 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVar x))\n       \\<subseteq> free_vars (CVar x) - {xa} \\<union> free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVal x))\n       \\<subseteq> free_vars (CVal x) - {xa} \\<union> free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> free_vars <e'1, e'2>\\<^sub>c -\n                                     {x} \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> free_vars (x1a $$\\<^sub>c e') - {x} \\<union> free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'3)\n           \\<subseteq> free_vars e'3 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) -\n                                     {x} \\<union>\n                                     free_vars e\n 6. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) -\n                   {x} \\<union>\n                   free_vars e", "have \"free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t)) =\n           Suc -` free_vars (cexpr_comp_aux (Suc x) (map_vars Suc e) e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t)) =\n    Suc -` free_vars (cexpr_comp_aux (Suc x) (map_vars Suc e) e')", "by simp"], ["proof (state)\nthis:\n  free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t)) =\n  Suc -` free_vars (cexpr_comp_aux (Suc x) (map_vars Suc e) e')\n\ngoal (6 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVar x))\n       \\<subseteq> free_vars (CVar x) - {xa} \\<union> free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVal x))\n       \\<subseteq> free_vars (CVal x) - {xa} \\<union> free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> free_vars <e'1, e'2>\\<^sub>c -\n                                     {x} \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> free_vars (x1a $$\\<^sub>c e') - {x} \\<union> free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'3)\n           \\<subseteq> free_vars e'3 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) -\n                                     {x} \\<union>\n                                     free_vars e\n 6. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) -\n                   {x} \\<union>\n                   free_vars e", "also"], ["proof (state)\nthis:\n  free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t)) =\n  Suc -` free_vars (cexpr_comp_aux (Suc x) (map_vars Suc e) e')\n\ngoal (6 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVar x))\n       \\<subseteq> free_vars (CVar x) - {xa} \\<union> free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVal x))\n       \\<subseteq> free_vars (CVal x) - {xa} \\<union> free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> free_vars <e'1, e'2>\\<^sub>c -\n                                     {x} \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> free_vars (x1a $$\\<^sub>c e') - {x} \\<union> free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'3)\n           \\<subseteq> free_vars e'3 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) -\n                                     {x} \\<union>\n                                     free_vars e\n 6. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) -\n                   {x} \\<union>\n                   free_vars e", "have \"... \\<subseteq> Suc -` (free_vars e' - {Suc x} \\<union> free_vars (map_vars Suc e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc -` free_vars (cexpr_comp_aux (Suc x) (map_vars Suc e) e')\n    \\<subseteq> Suc -`\n                (free_vars e' - {Suc x} \\<union> free_vars (map_vars Suc e))", "by (rule vimage_mono, rule CIntegral.IH)"], ["proof (state)\nthis:\n  Suc -` free_vars (cexpr_comp_aux (Suc x) (map_vars Suc e) e')\n  \\<subseteq> Suc -`\n              (free_vars e' - {Suc x} \\<union> free_vars (map_vars Suc e))\n\ngoal (6 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVar x))\n       \\<subseteq> free_vars (CVar x) - {xa} \\<union> free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVal x))\n       \\<subseteq> free_vars (CVal x) - {xa} \\<union> free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> free_vars <e'1, e'2>\\<^sub>c -\n                                     {x} \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> free_vars (x1a $$\\<^sub>c e') - {x} \\<union> free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'3)\n           \\<subseteq> free_vars e'3 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) -\n                                     {x} \\<union>\n                                     free_vars e\n 6. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) -\n                   {x} \\<union>\n                   free_vars e", "also"], ["proof (state)\nthis:\n  Suc -` free_vars (cexpr_comp_aux (Suc x) (map_vars Suc e) e')\n  \\<subseteq> Suc -`\n              (free_vars e' - {Suc x} \\<union> free_vars (map_vars Suc e))\n\ngoal (6 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVar x))\n       \\<subseteq> free_vars (CVar x) - {xa} \\<union> free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVal x))\n       \\<subseteq> free_vars (CVal x) - {xa} \\<union> free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> free_vars <e'1, e'2>\\<^sub>c -\n                                     {x} \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> free_vars (x1a $$\\<^sub>c e') - {x} \\<union> free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'3)\n           \\<subseteq> free_vars e'3 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) -\n                                     {x} \\<union>\n                                     free_vars e\n 6. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) -\n                   {x} \\<union>\n                   free_vars e", "have \"... \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>t) - {x} \\<union> free_vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc -` (free_vars e' - {Suc x} \\<union> free_vars (map_vars Suc e))\n    \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>t) -\n                {x} \\<union>\n                free_vars e", "by (auto simp add: vimage_Diff vimage_image_eq)"], ["proof (state)\nthis:\n  Suc -` (free_vars e' - {Suc x} \\<union> free_vars (map_vars Suc e))\n  \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>t) - {x} \\<union>\n              free_vars e\n\ngoal (6 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVar x))\n       \\<subseteq> free_vars (CVar x) - {xa} \\<union> free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVal x))\n       \\<subseteq> free_vars (CVal x) - {xa} \\<union> free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> free_vars <e'1, e'2>\\<^sub>c -\n                                     {x} \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> free_vars (x1a $$\\<^sub>c e') - {x} \\<union> free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'3)\n           \\<subseteq> free_vars e'3 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) -\n                                     {x} \\<union>\n                                     free_vars e\n 6. \\<And>e' x2a x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>x2a))\n       \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>x2a) -\n                   {x} \\<union>\n                   free_vars e", "finally"], ["proof (chain)\npicking this:\n  free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t))\n  \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>t) - {x} \\<union>\n              free_vars e", "show ?case"], ["proof (prove)\nusing this:\n  free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t))\n  \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>t) - {x} \\<union>\n              free_vars e\n\ngoal (1 subgoal):\n 1. free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t))\n    \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>t) -\n                {x} \\<union>\n                free_vars e", "."], ["proof (state)\nthis:\n  free_vars (cexpr_comp_aux x e (\\<integral>\\<^sub>c e' \\<partial>t))\n  \\<subseteq> free_vars (\\<integral>\\<^sub>c e' \\<partial>t) - {x} \\<union>\n              free_vars e\n\ngoal (5 subgoals):\n 1. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVar x))\n       \\<subseteq> free_vars (CVar x) - {xa} \\<union> free_vars e\n 2. \\<And>x xa e.\n       free_vars (cexpr_comp_aux xa e (CVal x))\n       \\<subseteq> free_vars (CVal x) - {xa} \\<union> free_vars e\n 3. \\<And>e'1 e'2 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars (cexpr_comp_aux x e <e'1, e'2>\\<^sub>c)\n                         \\<subseteq> free_vars <e'1, e'2>\\<^sub>c -\n                                     {x} \\<union>\n                                     free_vars e\n 4. \\<And>x1a e' x e.\n       (\\<And>x e.\n           free_vars (cexpr_comp_aux x e e')\n           \\<subseteq> free_vars e' - {x} \\<union>\n                       free_vars e) \\<Longrightarrow>\n       free_vars (cexpr_comp_aux x e (x1a $$\\<^sub>c e'))\n       \\<subseteq> free_vars (x1a $$\\<^sub>c e') - {x} \\<union> free_vars e\n 5. \\<And>e'1 e'2 e'3 x e.\n       \\<lbrakk>\\<And>x e.\n                   free_vars (cexpr_comp_aux x e e'1)\n                   \\<subseteq> free_vars e'1 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'2)\n           \\<subseteq> free_vars e'2 - {x} \\<union> free_vars e;\n        \\<And>x e.\n           free_vars (cexpr_comp_aux x e e'3)\n           \\<subseteq> free_vars e'3 - {x} \\<union> free_vars e\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (cexpr_comp_aux x e\n                            (IF\\<^sub>c e'1 THEN e'2 ELSE e'3))\n                         \\<subseteq> free_vars\n(IF\\<^sub>c e'1 THEN e'2 ELSE e'3) -\n                                     {x} \\<union>\n                                     free_vars e", "qed (simp, blast?)+"], ["", "lemma free_vars_cexpr_comp:\n  \"free_vars (cexpr_comp e e') \\<subseteq> (free_vars e - {0}) \\<union> free_vars e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (e \\<circ>\\<^sub>c e')\n    \\<subseteq> free_vars e - {0} \\<union> free_vars e'", "by (simp add: free_vars_cexpr_comp_aux cexpr_comp_def)"], ["", "lemma free_vars_cexpr_comp':\n  \"free_vars (cexpr_comp e e') \\<subseteq> free_vars e \\<union> free_vars e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (e \\<circ>\\<^sub>c e')\n    \\<subseteq> free_vars e \\<union> free_vars e'", "using free_vars_cexpr_comp"], ["proof (prove)\nusing this:\n  free_vars (?e \\<circ>\\<^sub>c ?e')\n  \\<subseteq> free_vars ?e - {0} \\<union> free_vars ?e'\n\ngoal (1 subgoal):\n 1. free_vars (e \\<circ>\\<^sub>c e')\n    \\<subseteq> free_vars e \\<union> free_vars e'", "by blast"], ["", "lemma cexpr_sem_cexpr_comp:\n    \"cexpr_sem \\<sigma> (f \\<circ>\\<^sub>c g) = cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> g)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (f \\<circ>\\<^sub>c g) =\n    cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> g)) f", "unfolding cexpr_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (cexpr_comp_aux 0 g f) =\n    cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> g)) f", "by (simp add: cexpr_sem_cexpr_comp_aux)"], ["", "lemma eval_cexpr_comp:\n    \"eval_cexpr (f \\<circ>\\<^sub>c g) \\<sigma> x = eval_cexpr f \\<sigma> (cexpr_sem (case_nat x \\<sigma>) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_cexpr (f \\<circ>\\<^sub>c g) \\<sigma> x =\n    eval_cexpr f \\<sigma> (cexpr_sem (case_nat x \\<sigma>) g)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_cexpr (f \\<circ>\\<^sub>c g) \\<sigma> x =\n    eval_cexpr f \\<sigma> (cexpr_sem (case_nat x \\<sigma>) g)", "have \"(case_nat x \\<sigma>)(0 := cexpr_sem (case_nat x \\<sigma>) g) = case_nat (cexpr_sem (case_nat x \\<sigma>) g) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case_nat x \\<sigma>)(0 := cexpr_sem (case_nat x \\<sigma>) g) =\n    case_nat (cexpr_sem (case_nat x \\<sigma>) g) \\<sigma>", "by (intro ext) (auto split: nat.split)"], ["proof (state)\nthis:\n  (case_nat x \\<sigma>)(0 := cexpr_sem (case_nat x \\<sigma>) g) =\n  case_nat (cexpr_sem (case_nat x \\<sigma>) g) \\<sigma>\n\ngoal (1 subgoal):\n 1. eval_cexpr (f \\<circ>\\<^sub>c g) \\<sigma> x =\n    eval_cexpr f \\<sigma> (cexpr_sem (case_nat x \\<sigma>) g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (case_nat x \\<sigma>)(0 := cexpr_sem (case_nat x \\<sigma>) g) =\n  case_nat (cexpr_sem (case_nat x \\<sigma>) g) \\<sigma>\n\ngoal (1 subgoal):\n 1. eval_cexpr (f \\<circ>\\<^sub>c g) \\<sigma> x =\n    eval_cexpr f \\<sigma> (cexpr_sem (case_nat x \\<sigma>) g)", "by (simp add: eval_cexpr_def cexpr_sem_cexpr_comp)"], ["proof (state)\nthis:\n  eval_cexpr (f \\<circ>\\<^sub>c g) \\<sigma> x =\n  eval_cexpr f \\<sigma> (cexpr_sem (case_nat x \\<sigma>) g)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec cexpr_subst_val_aux :: \"nat \\<Rightarrow> cexpr \\<Rightarrow> val \\<Rightarrow> cexpr\" where\n  \"cexpr_subst_val_aux _ (CVal v) _ = CVal v\"\n| \"cexpr_subst_val_aux x (CVar y) v = insert_var x CVar (CVal v) y\"\n| \"cexpr_subst_val_aux x (IF\\<^sub>c b THEN e1 ELSE e2) v =\n    (IF\\<^sub>c cexpr_subst_val_aux x b v THEN cexpr_subst_val_aux x e1 v ELSE cexpr_subst_val_aux x e2 v)\"\n| \"cexpr_subst_val_aux x (oper $$\\<^sub>c e) v = oper $$\\<^sub>c (cexpr_subst_val_aux x e v)\"\n| \"cexpr_subst_val_aux x <e1, e2>\\<^sub>c v = <cexpr_subst_val_aux x e1 v, cexpr_subst_val_aux x e2 v>\\<^sub>c\"\n| \"cexpr_subst_val_aux x (\\<integral>\\<^sub>c e \\<partial>t) v = \\<integral>\\<^sub>c cexpr_subst_val_aux (Suc x) e v \\<partial>t\""], ["", "lemma cexpr_subst_val_aux_eq_cexpr_subst:\n    \"cexpr_subst_val_aux x e v = cexpr_subst x (CVal v) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_subst_val_aux x e v = cexpr_subst x (CVal v) e", "by (induction e arbitrary: x) simp_all"], ["", "definition cexpr_subst_val :: \"cexpr \\<Rightarrow> val \\<Rightarrow> cexpr\" where\n  \"cexpr_subst_val e v \\<equiv> cexpr_subst_val_aux 0 e v\""], ["", "lemma cexpr_sem_cexpr_subst_val[simp]:\n    \"cexpr_sem \\<sigma> (cexpr_subst_val e v) = cexpr_sem (case_nat v \\<sigma>) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (cexpr_subst_val e v) =\n    cexpr_sem (case_nat v \\<sigma>) e", "by (simp add: cexpr_subst_val_def cexpr_subst_val_aux_eq_cexpr_subst cexpr_sem_cexpr_subst)"], ["", "lemma cexpr_typing_subst_val[intro]:\n    \"case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : t' \\<Longrightarrow> val_type v = t \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst_val e v : t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : t';\n     val_type v = t\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c cexpr_subst_val e v : t'", "by (auto simp: cexpr_subst_val_def cexpr_subst_val_aux_eq_cexpr_subst intro!: cet_val')"], ["", "lemma free_vars_cexpr_subst_val_aux:\n    \"free_vars (cexpr_subst_val_aux x e v) = (\\<lambda>y. if y \\<ge> x then Suc y else y) -` free_vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (cexpr_subst_val_aux x e v) =\n    (\\<lambda>y. if x \\<le> y then Suc y else y) -` free_vars e", "by (induction e arbitrary: x) (auto simp: insert_var_def split: if_split_asm)"], ["", "lemma free_vars_cexpr_subst_val[simp]:\n    \"free_vars (cexpr_subst_val e v) = Suc -` free_vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (cexpr_subst_val e v) = Suc -` free_vars e", "by (simp add: cexpr_subst_val_def free_vars_cexpr_subst_val_aux)"], ["", "subsection \\<open>Nonnegative expressions\\<close>"], ["", "definition \"nonneg_cexpr V \\<Gamma> e \\<equiv>\n    \\<forall>\\<sigma> \\<in> space (state_measure V \\<Gamma>). extract_real (cexpr_sem \\<sigma> e) \\<ge> 0\""], ["", "lemma nonneg_cexprI:\n    \"(\\<And>\\<sigma>. \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow> extract_real (cexpr_sem \\<sigma> e) \\<ge> 0) \\<Longrightarrow> nonneg_cexpr V \\<Gamma> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n        0 \\<le> extract_real (cexpr_sem \\<sigma> e)) \\<Longrightarrow>\n    nonneg_cexpr V \\<Gamma> e", "unfolding nonneg_cexpr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n        0 \\<le> extract_real (cexpr_sem \\<sigma> e)) \\<Longrightarrow>\n    \\<forall>\\<sigma>\\<in>space (state_measure V \\<Gamma>).\n       0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "by simp"], ["", "lemma nonneg_cexprD:\n    \"nonneg_cexpr V \\<Gamma> e \\<Longrightarrow> \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow> extract_real (cexpr_sem \\<sigma> e) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nonneg_cexpr V \\<Gamma> e;\n     \\<sigma> \\<in> space (state_measure V \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "unfolding nonneg_cexpr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<sigma>\\<in>space (state_measure V \\<Gamma>).\n                0 \\<le> extract_real (cexpr_sem \\<sigma> e);\n     \\<sigma> \\<in> space (state_measure V \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "by simp"], ["", "lemma nonneg_cexpr_map_vars:\n  assumes \"nonneg_cexpr (f -` V) (\\<Gamma> \\<circ> f) e\"\n  shows \"nonneg_cexpr V \\<Gamma> (map_vars f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_cexpr V \\<Gamma> (map_vars f e)", "by (intro nonneg_cexprI, subst cexpr_sem_map_vars, intro nonneg_cexprD[OF assms])\n     (auto simp: state_measure_def space_PiM)"], ["", "lemma nonneg_cexpr_subset:\n  assumes \"nonneg_cexpr V \\<Gamma> e\" \"V \\<subseteq> V'\" \"free_vars e \\<subseteq> V\"\n  shows \"nonneg_cexpr V' \\<Gamma> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_cexpr V' \\<Gamma> e", "proof (intro nonneg_cexprI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "assume \"\\<sigma> \\<in> space (state_measure V' \\<Gamma>)\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> space (state_measure V' \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "with assms(2)"], ["proof (chain)\npicking this:\n  V \\<subseteq> V'\n  \\<sigma> \\<in> space (state_measure V' \\<Gamma>)", "have \"restrict \\<sigma> V \\<in> space (state_measure V \\<Gamma>)\""], ["proof (prove)\nusing this:\n  V \\<subseteq> V'\n  \\<sigma> \\<in> space (state_measure V' \\<Gamma>)\n\ngoal (1 subgoal):\n 1. restrict \\<sigma> V \\<in> space (state_measure V \\<Gamma>)", "by (auto simp: state_measure_def space_PiM restrict_def)"], ["proof (state)\nthis:\n  restrict \\<sigma> V \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "from nonneg_cexprD[OF assms(1) this]"], ["proof (chain)\npicking this:\n  0 \\<le> extract_real (cexpr_sem (restrict \\<sigma> V) e)", "have \"extract_real (cexpr_sem (restrict \\<sigma> V) e) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> extract_real (cexpr_sem (restrict \\<sigma> V) e)\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem (restrict \\<sigma> V) e)", "."], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem (restrict \\<sigma> V) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "also"], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem (restrict \\<sigma> V) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "have \"cexpr_sem (restrict \\<sigma> V) e = cexpr_sem \\<sigma> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem (restrict \\<sigma> V) e = cexpr_sem \\<sigma> e", "using assms(3)"], ["proof (prove)\nusing this:\n  free_vars e \\<subseteq> V\n\ngoal (1 subgoal):\n 1. cexpr_sem (restrict \\<sigma> V) e = cexpr_sem \\<sigma> e", "by (intro cexpr_sem_eq_on_vars) auto"], ["proof (state)\nthis:\n  cexpr_sem (restrict \\<sigma> V) e = cexpr_sem \\<sigma> e\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "show \"extract_real (cexpr_sem \\<sigma> e) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> e)\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<sigma> e)", "."], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonneg_cexpr_Mult:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\"\n  assumes \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  assumes N1: \"nonneg_cexpr V \\<Gamma> e1\" and N2: \"nonneg_cexpr V \\<Gamma> e2\"\n  shows \"nonneg_cexpr V \\<Gamma> (e1 *\\<^sub>c e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_cexpr V \\<Gamma> (e1 *\\<^sub>c e2)", "proof (rule nonneg_cexprI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2))", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2))", "assume \\<sigma>: \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2))", "hence \"extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2)) = extract_real (cexpr_sem \\<sigma> e1) * extract_real (cexpr_sem \\<sigma> e2)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2)) =\n    extract_real (cexpr_sem \\<sigma> e1) *\n    extract_real (cexpr_sem \\<sigma> e2)", "using assms"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n  \\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL\n  \\<Gamma> \\<turnstile>\\<^sub>c e2 : REAL\n  free_vars e1 \\<subseteq> V\n  free_vars e2 \\<subseteq> V\n  nonneg_cexpr V \\<Gamma> e1\n  nonneg_cexpr V \\<Gamma> e2\n\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2)) =\n    extract_real (cexpr_sem \\<sigma> e1) *\n    extract_real (cexpr_sem \\<sigma> e2)", "by (subst cexpr_sem_Mult[of \\<Gamma> _ _ _ V]) simp_all"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2)) =\n  extract_real (cexpr_sem \\<sigma> e1) *\n  extract_real (cexpr_sem \\<sigma> e2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2))", "also"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2)) =\n  extract_real (cexpr_sem \\<sigma> e1) *\n  extract_real (cexpr_sem \\<sigma> e2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2))", "have \"... \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<sigma> e1) *\n            extract_real (cexpr_sem \\<sigma> e2)", "using \\<sigma> N1 N2"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n  nonneg_cexpr V \\<Gamma> e1\n  nonneg_cexpr V \\<Gamma> e2\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<sigma> e1) *\n            extract_real (cexpr_sem \\<sigma> e2)", "by (intro mult_nonneg_nonneg nonneg_cexprD)"], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> e1) *\n          extract_real (cexpr_sem \\<sigma> e2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2))", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2))", "show \"extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2))\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2))", "."], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (e1 *\\<^sub>c e2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonneg_indicator:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e : BOOL\" \"free_vars e \\<subseteq> V\"\n  shows \"nonneg_cexpr V \\<Gamma> (\\<langle>e\\<rangle>\\<^sub>c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_cexpr V \\<Gamma> (\\<langle>e\\<rangle>\\<^sub>c)", "proof (intro nonneg_cexprI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem \\<sigma> (\\<langle>e\\<rangle>\\<^sub>c))", "fix \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem \\<sigma> (\\<langle>e\\<rangle>\\<^sub>c))", "assume \"\\<rho> \\<in> space (state_measure V \\<Gamma>)\""], ["proof (state)\nthis:\n  \\<rho> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem \\<sigma> (\\<langle>e\\<rangle>\\<^sub>c))", "with assms"], ["proof (chain)\npicking this:\n  \\<Gamma> \\<turnstile>\\<^sub>c e : BOOL\n  free_vars e \\<subseteq> V\n  \\<rho> \\<in> space (state_measure V \\<Gamma>)", "have \"val_type (cexpr_sem \\<rho> e) = BOOL\""], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>c e : BOOL\n  free_vars e \\<subseteq> V\n  \\<rho> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. val_type (cexpr_sem \\<rho> e) = BOOL", "by (rule val_type_cexpr_sem)"], ["proof (state)\nthis:\n  val_type (cexpr_sem \\<rho> e) = BOOL\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem \\<sigma> (\\<langle>e\\<rangle>\\<^sub>c))", "thus \"extract_real (cexpr_sem \\<rho> (\\<langle>e\\<rangle>\\<^sub>c)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  val_type (cexpr_sem \\<rho> e) = BOOL\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<rho> (\\<langle>e\\<rangle>\\<^sub>c))", "by (auto simp: extract_real_def bool_to_real_def split: val.split)"], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem \\<rho> (\\<langle>e\\<rangle>\\<^sub>c))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonneg_cexpr_comp_aux:\n  assumes nonneg: \"nonneg_cexpr V (\\<Gamma>(x := t1)) e\"  and x:\"x \\<in> V\"\n  assumes t2: \"\\<Gamma>(x:=t1) \\<turnstile>\\<^sub>c e : t2\" and t1: \"\\<Gamma> \\<turnstile>\\<^sub>c f : t1\" and vars: \"free_vars f \\<subseteq> V\"\n  shows \"nonneg_cexpr V \\<Gamma> (cexpr_comp_aux x f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_cexpr V \\<Gamma> (cexpr_comp_aux x f e)", "proof (intro nonneg_cexprI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))", "assume \\<sigma>: \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))", "have \"extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e)) =\n            extract_real (cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> f)) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e)) =\n    extract_real (cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> f)) e)", "by (simp add: cexpr_sem_cexpr_comp_aux)"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e)) =\n  extract_real (cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> f)) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))", "also"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e)) =\n  extract_real (cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> f)) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))", "from val_type_cexpr_sem[OF t1 vars \\<sigma>]"], ["proof (chain)\npicking this:\n  val_type (cexpr_sem \\<sigma> f) = t1", "have \"cexpr_sem \\<sigma> f \\<in> type_universe t1\""], ["proof (prove)\nusing this:\n  val_type (cexpr_sem \\<sigma> f) = t1\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> f \\<in> type_universe t1", "by auto"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> f \\<in> type_universe t1\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))", "with \\<sigma> x"], ["proof (chain)\npicking this:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n  x \\<in> V\n  cexpr_sem \\<sigma> f \\<in> type_universe t1", "have \"\\<sigma>(x := cexpr_sem \\<sigma> f) \\<in> space (state_measure V (\\<Gamma>(x := t1)))\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n  x \\<in> V\n  cexpr_sem \\<sigma> f \\<in> type_universe t1\n\ngoal (1 subgoal):\n 1. \\<sigma>(x := cexpr_sem \\<sigma> f)\n    \\<in> space (state_measure V (\\<Gamma>(x := t1)))", "by (auto simp: state_measure_def space_PiM shift_var_set_def split: if_split_asm)"], ["proof (state)\nthis:\n  \\<sigma>(x := cexpr_sem \\<sigma> f)\n  \\<in> space (state_measure V (\\<Gamma>(x := t1)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))", "hence \"extract_real (cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> f)) e) \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<sigma>(x := cexpr_sem \\<sigma> f)\n  \\<in> space (state_measure V (\\<Gamma>(x := t1)))\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> f)) e)", "by(intro nonneg_cexprD[OF assms(1)])"], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem (\\<sigma>(x := cexpr_sem \\<sigma> f)) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))", "show \"extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))", "."], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_comp_aux x f e))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonneg_cexpr_comp:\n  assumes \"nonneg_cexpr (shift_var_set V) (case_nat t2 \\<Gamma>) e\"\n  assumes \"case_nat t1 \\<Gamma> \\<turnstile>\\<^sub>c f : t2\" \"free_vars f \\<subseteq> shift_var_set V\"\n  shows \"nonneg_cexpr (shift_var_set V) (case_nat t1 \\<Gamma>) (e \\<circ>\\<^sub>c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_cexpr (shift_var_set V) (case_nat t1 \\<Gamma>)\n     (e \\<circ>\\<^sub>c f)", "proof (intro nonneg_cexprI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma>\n       \\<in> space\n              (state_measure (shift_var_set V)\n                (case_nat t1 \\<Gamma>)) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma>\n       \\<in> space\n              (state_measure (shift_var_set V)\n                (case_nat t1 \\<Gamma>)) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))", "assume \\<sigma>: \"\\<sigma> \\<in> space (state_measure (shift_var_set V) (case_nat t1 \\<Gamma>))\""], ["proof (state)\nthis:\n  \\<sigma>\n  \\<in> space (state_measure (shift_var_set V) (case_nat t1 \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma>\n       \\<in> space\n              (state_measure (shift_var_set V)\n                (case_nat t1 \\<Gamma>)) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))", "have \"extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f)) = extract_real (cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> f)) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f)) =\n    extract_real (cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> f)) e)", "by (simp add: cexpr_sem_cexpr_comp)"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f)) =\n  extract_real (cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> f)) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma>\n       \\<in> space\n              (state_measure (shift_var_set V)\n                (case_nat t1 \\<Gamma>)) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))", "also"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f)) =\n  extract_real (cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> f)) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma>\n       \\<in> space\n              (state_measure (shift_var_set V)\n                (case_nat t1 \\<Gamma>)) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))", "from val_type_cexpr_sem[OF assms(2,3) \\<sigma>]"], ["proof (chain)\npicking this:\n  val_type (cexpr_sem \\<sigma> f) = t2", "have \"cexpr_sem \\<sigma> f \\<in> type_universe t2\""], ["proof (prove)\nusing this:\n  val_type (cexpr_sem \\<sigma> f) = t2\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> f \\<in> type_universe t2", "by auto"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> f \\<in> type_universe t2\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma>\n       \\<in> space\n              (state_measure (shift_var_set V)\n                (case_nat t1 \\<Gamma>)) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))", "with \\<sigma>"], ["proof (chain)\npicking this:\n  \\<sigma>\n  \\<in> space (state_measure (shift_var_set V) (case_nat t1 \\<Gamma>))\n  cexpr_sem \\<sigma> f \\<in> type_universe t2", "have \"\\<sigma>(0 := cexpr_sem \\<sigma> f) \\<in> space (state_measure (shift_var_set V) (case_nat t2 \\<Gamma>))\""], ["proof (prove)\nusing this:\n  \\<sigma>\n  \\<in> space (state_measure (shift_var_set V) (case_nat t1 \\<Gamma>))\n  cexpr_sem \\<sigma> f \\<in> type_universe t2\n\ngoal (1 subgoal):\n 1. \\<sigma>(0 := cexpr_sem \\<sigma> f)\n    \\<in> space (state_measure (shift_var_set V) (case_nat t2 \\<Gamma>))", "by (auto simp: state_measure_def space_PiM shift_var_set_def split: if_split_asm)"], ["proof (state)\nthis:\n  \\<sigma>(0 := cexpr_sem \\<sigma> f)\n  \\<in> space (state_measure (shift_var_set V) (case_nat t2 \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma>\n       \\<in> space\n              (state_measure (shift_var_set V)\n                (case_nat t1 \\<Gamma>)) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))", "hence \"extract_real (cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> f)) e) \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<sigma>(0 := cexpr_sem \\<sigma> f)\n  \\<in> space (state_measure (shift_var_set V) (case_nat t2 \\<Gamma>))\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> f)) e)", "by(intro nonneg_cexprD[OF assms(1)])"], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem (\\<sigma>(0 := cexpr_sem \\<sigma> f)) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma>\n       \\<in> space\n              (state_measure (shift_var_set V)\n                (case_nat t1 \\<Gamma>)) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))", "show \"extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))", "."], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (e \\<circ>\\<^sub>c f))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonneg_cexpr_subst_val:\n  assumes \"nonneg_cexpr (shift_var_set V) (case_nat t \\<Gamma>) e\" \"val_type v = t\"\n  shows \"nonneg_cexpr V \\<Gamma> (cexpr_subst_val e v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_cexpr V \\<Gamma> (cexpr_subst_val e v)", "proof (intro nonneg_cexprI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_subst_val e v))", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_subst_val e v))", "assume \\<sigma>: \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_subst_val e v))", "moreover"], ["proof (state)\nthis:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_subst_val e v))", "from assms(2)"], ["proof (chain)\npicking this:\n  val_type v = t", "have \"v \\<in> type_universe t\""], ["proof (prove)\nusing this:\n  val_type v = t\n\ngoal (1 subgoal):\n 1. v \\<in> type_universe t", "by auto"], ["proof (state)\nthis:\n  v \\<in> type_universe t\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_subst_val e v))", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n  v \\<in> type_universe t", "show \"extract_real (cexpr_sem \\<sigma> (cexpr_subst_val e v)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n  v \\<in> type_universe t\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_subst_val e v))", "by (auto intro!: nonneg_cexprD[OF assms(1)])"], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (cexpr_subst_val e v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonneg_cexpr_int:\n  assumes \"nonneg_cexpr (shift_var_set V) (case_nat t \\<Gamma>) e\"\n  shows \"nonneg_cexpr V \\<Gamma> (\\<integral>\\<^sub>c e \\<partial>t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_cexpr V \\<Gamma> (\\<integral>\\<^sub>c e \\<partial>t)", "proof (intro nonneg_cexprI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))", "assume \\<sigma>: \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))", "have \"extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t)) = \\<integral>x. extract_real (cexpr_sem (case_nat x \\<sigma>) e) \\<partial>stock_measure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t)) =\n    LINT x|stock_measure t. extract_real (cexpr_sem (case_nat x \\<sigma>) e)", "by (simp add: extract_real_def)"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t)) =\n  LINT x|stock_measure t. extract_real (cexpr_sem (case_nat x \\<sigma>) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))", "also"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t)) =\n  LINT x|stock_measure t. extract_real (cexpr_sem (case_nat x \\<sigma>) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))", "from \\<sigma>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)", "have \"... \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> LINT x|stock_measure t.\n               extract_real (cexpr_sem (case_nat x \\<sigma>) e)", "by (intro integral_nonneg_AE AE_I2 nonneg_cexprD[OF assms]) auto"], ["proof (state)\nthis:\n  0 \\<le> LINT x|stock_measure t.\n             extract_real (cexpr_sem (case_nat x \\<sigma>) e)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> extract_real\n           (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))", "show \"extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> extract_real\n           (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real\n             (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))", "."], ["proof (state)\nthis:\n  0 \\<le> extract_real\n           (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Subprobability density expressions\\<close>"], ["", "definition \"subprob_cexpr V V' \\<Gamma> e \\<equiv>\n    \\<forall>\\<rho> \\<in> space (state_measure V' \\<Gamma>).\n      (\\<integral>\\<^sup>+\\<sigma>. extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure V \\<Gamma>) \\<le> 1\""], ["", "lemma subprob_cexprI:\n  assumes \"\\<And>\\<rho>. \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n                 (\\<integral>\\<^sup>+\\<sigma>. extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure V \\<Gamma>) \\<le> 1\"\n  shows \"subprob_cexpr V V' \\<Gamma> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subprob_cexpr V V' \\<Gamma> e", "using assms"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, ?\\<rho>)) e))\n                     \\<partial>state_measure V \\<Gamma>\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. subprob_cexpr V V' \\<Gamma> e", "unfolding subprob_cexpr_def"], ["proof (prove)\nusing this:\n  ?\\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, ?\\<rho>)) e))\n                     \\<partial>state_measure V \\<Gamma>\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<rho>\\<in>space (state_measure V' \\<Gamma>).\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>)) e))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "by simp"], ["", "lemma subprob_cexprD:\n  assumes \"subprob_cexpr V V' \\<Gamma> e\"\n  shows \"\\<And>\\<rho>. \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n               (\\<integral>\\<^sup>+\\<sigma>. extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure V \\<Gamma>) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>)) e))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "using assms"], ["proof (prove)\nusing this:\n  subprob_cexpr V V' \\<Gamma> e\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>)) e))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "unfolding subprob_cexpr_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<rho>\\<in>space (state_measure V' \\<Gamma>).\n     \\<integral>\\<^sup>+ x. ennreal\n                             (extract_real\n                               (cexpr_sem (merge V V' (x, \\<rho>)) e))\n                        \\<partial>state_measure V \\<Gamma>\n     \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>)) e))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "by simp"], ["", "lemma subprob_indicator:\n  assumes subprob: \"subprob_cexpr V V' \\<Gamma> e1\" and nonneg: \"nonneg_cexpr (V \\<union> V') \\<Gamma> e1\"\n  assumes t1: \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL\" and t2: \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : BOOL\"\n  assumes vars1: \"free_vars e1 \\<subseteq> V \\<union> V'\" and vars2: \"free_vars e2 \\<subseteq> V \\<union> V'\"\n  shows \"subprob_cexpr V V' \\<Gamma> (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subprob_cexpr V V' \\<Gamma> (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c)", "proof (intro subprob_cexprI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "fix \\<rho>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "assume \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\""], ["proof (state)\nthis:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "from t2"], ["proof (chain)\npicking this:\n  \\<Gamma> \\<turnstile>\\<^sub>c e2 : BOOL", "have t2': \"\\<Gamma> \\<turnstile>\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c : REAL\""], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>c e2 : BOOL\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c : REAL", "by (rule cet_op) simp_all"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c : REAL\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "from vars2"], ["proof (chain)\npicking this:\n  free_vars e2 \\<subseteq> V \\<union> V'", "have vars2': \"free_vars (\\<langle>e2\\<rangle>\\<^sub>c) \\<subseteq> V \\<union> V'\""], ["proof (prove)\nusing this:\n  free_vars e2 \\<subseteq> V \\<union> V'\n\ngoal (1 subgoal):\n 1. free_vars (\\<langle>e2\\<rangle>\\<^sub>c) \\<subseteq> V \\<union> V'", "by simp"], ["proof (state)\nthis:\n  free_vars (\\<langle>e2\\<rangle>\\<^sub>c) \\<subseteq> V \\<union> V'\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "let ?eval = \"\\<lambda>\\<sigma> e. extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "have \"(\\<integral>\\<^sup>+\\<sigma>. ?eval \\<sigma> (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c) \\<partial>state_measure V \\<Gamma>) =\n            (\\<integral>\\<^sup>+\\<sigma>. ?eval \\<sigma> e1 * ?eval \\<sigma> (\\<langle>e2\\<rangle>\\<^sub>c) \\<partial>state_measure V \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge V V' (x, \\<rho>))\n                                (e1 *\\<^sub>c\n                                 \\<langle>e2\\<rangle>\\<^sub>c)))\n                       \\<partial>state_measure V \\<Gamma> =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge V V' (x, \\<rho>)) e1) *\n                             extract_real\n                              (cexpr_sem (merge V V' (x, \\<rho>))\n                                (\\<langle>e2\\<rangle>\\<^sub>c)))\n                       \\<partial>state_measure V \\<Gamma>", "by (intro nn_integral_cong)\n       (simp only: cexpr_sem_Mult[OF t1 t2' merge_in_state_measure[OF _ \\<rho>] vars1 vars2'])"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma> =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>)) e1) *\n                           extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (\\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma> =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>)) e1) *\n                           extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (\\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "{"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma> =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>)) e1) *\n                           extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (\\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "assume \\<sigma>: \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "with \\<rho>"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)", "have \"val_type (cexpr_sem (merge V V' (\\<sigma>,\\<rho>)) e2) = BOOL\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. val_type (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e2) = BOOL", "by (intro val_type_cexpr_sem[OF t2 vars2] merge_in_state_measure)"], ["proof (state)\nthis:\n  val_type (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e2) = BOOL\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "hence \"?eval \\<sigma> (\\<langle>e2\\<rangle>\\<^sub>c) \\<in> {0,1}\""], ["proof (prove)\nusing this:\n  val_type (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e2) = BOOL\n\ngoal (1 subgoal):\n 1. extract_real\n     (cexpr_sem (merge V V' (\\<sigma>, \\<rho>))\n       (\\<langle>e2\\<rangle>\\<^sub>c))\n    \\<in> {0, 1}", "by (cases \"cexpr_sem (merge V V' (\\<sigma>,\\<rho>)) e2\") (auto simp: extract_real_def bool_to_real_def)"], ["proof (state)\nthis:\n  extract_real\n   (cexpr_sem (merge V V' (\\<sigma>, \\<rho>))\n     (\\<langle>e2\\<rangle>\\<^sub>c))\n  \\<in> {0, 1}\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "moreover"], ["proof (state)\nthis:\n  extract_real\n   (cexpr_sem (merge V V' (\\<sigma>, \\<rho>))\n     (\\<langle>e2\\<rangle>\\<^sub>c))\n  \\<in> {0, 1}\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "have \"?eval \\<sigma> e1 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e1)", "using nonneg \\<rho> \\<sigma>"], ["proof (prove)\nusing this:\n  nonneg_cexpr (V \\<union> V') \\<Gamma> e1\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e1)", "by (auto intro!: nonneg_cexprD merge_in_state_measure)"], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e1)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  extract_real\n   (cexpr_sem (merge V V' (\\<sigma>, \\<rho>))\n     (\\<langle>e2\\<rangle>\\<^sub>c))\n  \\<in> {0, 1}\n  0 \\<le> extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e1)", "have \"?eval \\<sigma> e1 * ?eval \\<sigma> (\\<langle>e2\\<rangle>\\<^sub>c) \\<le> ?eval \\<sigma> e1\""], ["proof (prove)\nusing this:\n  extract_real\n   (cexpr_sem (merge V V' (\\<sigma>, \\<rho>))\n     (\\<langle>e2\\<rangle>\\<^sub>c))\n  \\<in> {0, 1}\n  0 \\<le> extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e1)\n\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e1) *\n    extract_real\n     (cexpr_sem (merge V V' (\\<sigma>, \\<rho>))\n       (\\<langle>e2\\<rangle>\\<^sub>c))\n    \\<le> extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e1)", "by (intro mult_right_le_one_le) auto"], ["proof (state)\nthis:\n  extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e1) *\n  extract_real\n   (cexpr_sem (merge V V' (\\<sigma>, \\<rho>))\n     (\\<langle>e2\\<rangle>\\<^sub>c))\n  \\<le> extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e1)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "}"], ["proof (state)\nthis:\n  ?\\<sigma>2 \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n  extract_real (cexpr_sem (merge V V' (?\\<sigma>2, \\<rho>)) e1) *\n  extract_real\n   (cexpr_sem (merge V V' (?\\<sigma>2, \\<rho>))\n     (\\<langle>e2\\<rangle>\\<^sub>c))\n  \\<le> extract_real (cexpr_sem (merge V V' (?\\<sigma>2, \\<rho>)) e1)\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "hence \"(\\<integral>\\<^sup>+\\<sigma>. ?eval \\<sigma> e1 * ?eval \\<sigma> (\\<langle>e2\\<rangle>\\<^sub>c) \\<partial>state_measure V \\<Gamma>) \\<le>\n             (\\<integral>\\<^sup>+\\<sigma>. ?eval \\<sigma> e1 \\<partial>state_measure V \\<Gamma>)\""], ["proof (prove)\nusing this:\n  ?\\<sigma>2 \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n  extract_real (cexpr_sem (merge V V' (?\\<sigma>2, \\<rho>)) e1) *\n  extract_real\n   (cexpr_sem (merge V V' (?\\<sigma>2, \\<rho>))\n     (\\<langle>e2\\<rangle>\\<^sub>c))\n  \\<le> extract_real (cexpr_sem (merge V V' (?\\<sigma>2, \\<rho>)) e1)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge V V' (x, \\<rho>)) e1) *\n                             extract_real\n                              (cexpr_sem (merge V V' (x, \\<rho>))\n                                (\\<langle>e2\\<rangle>\\<^sub>c)))\n                       \\<partial>state_measure V \\<Gamma>\n    \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                  (extract_real\n                                    (cexpr_sem (merge V V' (x, \\<rho>)) e1))\n                             \\<partial>state_measure V \\<Gamma>", "by (intro nn_integral_mono) (simp add: ennreal_leI)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>)) e1) *\n                           extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (\\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma>\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (extract_real\n                                  (cexpr_sem (merge V V' (x, \\<rho>)) e1))\n                           \\<partial>state_measure V \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>)) e1) *\n                           extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (\\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma>\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (extract_real\n                                  (cexpr_sem (merge V V' (x, \\<rho>)) e1))\n                           \\<partial>state_measure V \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "from subprob and \\<rho>"], ["proof (chain)\npicking this:\n  subprob_cexpr V V' \\<Gamma> e1\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)", "have \"... \\<le> 1\""], ["proof (prove)\nusing this:\n  subprob_cexpr V V' \\<Gamma> e1\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge V V' (x, \\<rho>)) e1))\n                       \\<partial>state_measure V \\<Gamma>\n    \\<le> 1", "by (rule subprob_cexprD)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>)) e1))\n                     \\<partial>state_measure V \\<Gamma>\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>.\n       \\<rho> \\<in> space (state_measure V' \\<Gamma>) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (extract_real\n                                 (cexpr_sem (merge V V' (x, \\<rho>))\n                                   (e1 *\\<^sub>c\n                                    \\<langle>e2\\<rangle>\\<^sub>c)))\n                          \\<partial>state_measure V \\<Gamma>\n       \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma>\n  \\<le> 1", "show \"(\\<integral>\\<^sup>+\\<sigma>. ?eval \\<sigma> (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c) \\<partial>state_measure V \\<Gamma>)  \\<le> 1\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma>\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge V V' (x, \\<rho>))\n                                (e1 *\\<^sub>c\n                                 \\<langle>e2\\<rangle>\\<^sub>c)))\n                       \\<partial>state_measure V \\<Gamma>\n    \\<le> 1", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge V V' (x, \\<rho>))\n                              (e1 *\\<^sub>c \\<langle>e2\\<rangle>\\<^sub>c)))\n                     \\<partial>state_measure V \\<Gamma>\n  \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_cexpr_sem':\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  assumes e: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" \"free_vars e \\<subseteq> V \\<union> V'\"\n  shows \"(\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e))\n            \\<in> borel_measurable (state_measure V \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        extract_real (cexpr_sem (merge V V' (\\<sigma>, \\<rho>)) e))\n    \\<in> borel_measurable (state_measure V \\<Gamma>)", "apply (rule measurable_compose[OF _ measurable_extract_real])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. cexpr_sem (merge V V' (x, \\<rho>)) e)\n    \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M stock_measure REAL", "apply (rule measurable_compose[OF _ measurable_cexpr_sem[OF e]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. merge V V' (x, \\<rho>))\n    \\<in> state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n          state_measure (V \\<union> V') \\<Gamma>", "apply (insert \\<rho>, unfold state_measure_def, rule measurable_compose[OF _ measurable_merge], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma measurable_fun_upd_state_measure[measurable]:\n  assumes \"v \\<notin> V\"\n  shows \"(\\<lambda>(x,y). y(v := x)) \\<in> measurable (stock_measure (\\<Gamma> v) \\<Otimes>\\<^sub>M state_measure V \\<Gamma>)\n                                          (state_measure (insert v V) \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). y(v := x))\n    \\<in> stock_measure (\\<Gamma> v) \\<Otimes>\\<^sub>M\n          state_measure V \\<Gamma> \\<rightarrow>\\<^sub>M\n          state_measure (insert v V) \\<Gamma>", "unfolding state_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). y(v := x))\n    \\<in> stock_measure (\\<Gamma> v) \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M V\n           (\\<lambda>x. stock_measure (\\<Gamma> x)) \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M (insert v V) (\\<lambda>x. stock_measure (\\<Gamma> x))", "by simp"], ["", "lemma integrable_cexpr_projection:\n  assumes fin: \"finite V\"\n  assumes disjoint: \"V \\<inter> V' = {}\" \"v \\<notin> V\" \"v \\<notin> V'\"\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  assumes e: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" \"free_vars e \\<subseteq> insert v V \\<union> V'\"\n  assumes int: \"integrable (state_measure (insert v V) \\<Gamma>)\n                    (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\"\n                (is \"integrable _ ?f'\")\n  shows \"AE x in stock_measure (\\<Gamma> v).\n           integrable (state_measure V \\<Gamma>)\n               (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\"\n    (is \"AE x in ?N. integrable ?M (?f x)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). integrable (state_measure V \\<Gamma>)\n                    (\\<lambda>\\<sigma>.\n                        extract_real\n                         (cexpr_sem\n                           (merge V (insert v V')\n                             (\\<sigma>, \\<rho>(v := x)))\n                           e))", "proof (unfold real_integrable_def, intro AE_conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). (\\<lambda>\\<sigma>.\n                       extract_real\n                        (cexpr_sem\n                          (merge V (insert v V') (\\<sigma>, \\<rho>(v := x)))\n                          e))\n                   \\<in> borel_measurable (state_measure V \\<Gamma>)\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 3. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "show \"AE x in ?N. ?f x \\<in> borel_measurable ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). (\\<lambda>\\<sigma>.\n                       extract_real\n                        (cexpr_sem\n                          (merge V (insert v V') (\\<sigma>, \\<rho>(v := x)))\n                          e))\n                   \\<in> borel_measurable (state_measure V \\<Gamma>)", "using \\<rho> e disjoint"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> insert v V \\<union> V'\n  V \\<inter> V' = {}\n  v \\<notin> V\n  v \\<notin> V'\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). (\\<lambda>\\<sigma>.\n                       extract_real\n                        (cexpr_sem\n                          (merge V (insert v V') (\\<sigma>, \\<rho>(v := x)))\n                          e))\n                   \\<in> borel_measurable (state_measure V \\<Gamma>)", "by (intro AE_I2 measurable_cexpr_sem')\n       (auto simp: state_measure_def space_PiM dest: PiE_mem split: if_split_asm)"], ["proof (state)\nthis:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). (\\<lambda>\\<sigma>.\n                     extract_real\n                      (cexpr_sem\n                        (merge V (insert v V') (\\<sigma>, \\<rho>(v := x)))\n                        e))\n                 \\<in> borel_measurable (state_measure V \\<Gamma>)\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "let ?f'' = \"\\<lambda>x \\<sigma>. extract_real (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e)\""], ["proof (state)\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "fix x \\<sigma>"], ["proof (state)\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "assume \"x \\<in> space ?N\" \"\\<sigma> \\<in> space ?M\""], ["proof (state)\nthis:\n  x \\<in> space (stock_measure (\\<Gamma> v))\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "hence \"merge (insert v V) V' (\\<sigma>(v := x), \\<rho>) = merge V (insert v V') (\\<sigma>, \\<rho>(v := x))\""], ["proof (prove)\nusing this:\n  x \\<in> space (stock_measure (\\<Gamma> v))\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. merge (insert v V) V' (\\<sigma>(v := x), \\<rho>) =\n    merge V (insert v V') (\\<sigma>, \\<rho>(v := x))", "using disjoint"], ["proof (prove)\nusing this:\n  x \\<in> space (stock_measure (\\<Gamma> v))\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n  V \\<inter> V' = {}\n  v \\<notin> V\n  v \\<notin> V'\n\ngoal (1 subgoal):\n 1. merge (insert v V) V' (\\<sigma>(v := x), \\<rho>) =\n    merge V (insert v V') (\\<sigma>, \\<rho>(v := x))", "by (intro ext) (simp add: merge_def split: if_split_asm)"], ["proof (state)\nthis:\n  merge (insert v V) V' (\\<sigma>(v := x), \\<rho>) =\n  merge V (insert v V') (\\<sigma>, \\<rho>(v := x))\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "hence \"?f'' x \\<sigma> = ?f x \\<sigma>\""], ["proof (prove)\nusing this:\n  merge (insert v V) V' (\\<sigma>(v := x), \\<rho>) =\n  merge V (insert v V') (\\<sigma>, \\<rho>(v := x))\n\ngoal (1 subgoal):\n 1. extract_real\n     (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e) =\n    extract_real\n     (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "by simp"], ["proof (state)\nthis:\n  extract_real\n   (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e) =\n  extract_real\n   (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e)\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> space (stock_measure (\\<Gamma> v));\n   ?\\<sigma>2 \\<in> space (state_measure V \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> extract_real\n                     (cexpr_sem\n                       (merge (insert v V) V'\n                         (?\\<sigma>2(v := ?x2), \\<rho>))\n                       e) =\n                    extract_real\n                     (cexpr_sem\n                       (merge V (insert v V')\n                         (?\\<sigma>2, \\<rho>(v := ?x2)))\n                       e)\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "note f''_eq_f = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> space (stock_measure (\\<Gamma> v));\n   ?\\<sigma>2 \\<in> space (state_measure V \\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> extract_real\n                     (cexpr_sem\n                       (merge (insert v V) V'\n                         (?\\<sigma>2(v := ?x2), \\<rho>))\n                       e) =\n                    extract_real\n                     (cexpr_sem\n                       (merge V (insert v V')\n                         (?\\<sigma>2, \\<rho>(v := ?x2)))\n                       e)\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "interpret product_sigma_finite \"(\\<lambda>v. stock_measure (\\<Gamma> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. product_sigma_finite (\\<lambda>v. stock_measure (\\<Gamma> v))", "by (simp add: product_sigma_finite_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "interpret sigma_finite_measure \"state_measure V \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_finite_measure (state_measure V \\<Gamma>)", "by (rule sigma_finite_state_measure[OF fin])"], ["proof (state)\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "from int"], ["proof (chain)\npicking this:\n  integrable (state_measure (insert v V) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))", "have \"(\\<integral>\\<^sup>+\\<sigma>. ennreal (?f' \\<sigma>) \\<partial>state_measure (insert v V) \\<Gamma>) \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  integrable (state_measure (insert v V) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<sigma>.\n                         ennreal\n                          (extract_real\n                            (cexpr_sem\n                              (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n                       \\<partial>state_measure (insert v V)\n                                  \\<Gamma> \\<noteq>\n    \\<infinity>", "by (simp add: real_integrable_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (extract_real\n                          (cexpr_sem\n                            (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n                     \\<partial>state_measure (insert v V) \\<Gamma> \\<noteq>\n  \\<infinity>\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (extract_real\n                          (cexpr_sem\n                            (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n                     \\<partial>state_measure (insert v V) \\<Gamma> \\<noteq>\n  \\<infinity>\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "have \"(\\<integral>\\<^sup>+\\<sigma>. ennreal (?f' \\<sigma>) \\<partial>state_measure (insert v V) \\<Gamma>) =\n                 \\<integral>\\<^sup>+x. \\<integral>\\<^sup>+\\<sigma>. ennreal (?f'' x \\<sigma>) \\<partial>?M \\<partial>?N\" (is \"_ = ?I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<sigma>.\n                         ennreal\n                          (extract_real\n                            (cexpr_sem\n                              (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n                       \\<partial>state_measure (insert v V) \\<Gamma> =\n    \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n          ennreal\n           (extract_real\n             (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>))\n               e))\n        \\<partial>state_measure V \\<Gamma>\n                       \\<partial>stock_measure (\\<Gamma> v)", "using fin disjoint e \\<rho>"], ["proof (prove)\nusing this:\n  finite V\n  V \\<inter> V' = {}\n  v \\<notin> V\n  v \\<notin> V'\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> insert v V \\<union> V'\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<sigma>.\n                         ennreal\n                          (extract_real\n                            (cexpr_sem\n                              (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n                       \\<partial>state_measure (insert v V) \\<Gamma> =\n    \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n          ennreal\n           (extract_real\n             (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>))\n               e))\n        \\<partial>state_measure V \\<Gamma>\n                       \\<partial>stock_measure (\\<Gamma> v)", "by (unfold state_measure_def, subst product_nn_integral_insert_rev)\n       (auto intro!: measurable_compose[OF _ measurable_ennreal] measurable_cexpr_sem'[unfolded state_measure_def])"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (extract_real\n                          (cexpr_sem\n                            (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n                     \\<partial>state_measure (insert v V) \\<Gamma> =\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n        ennreal\n         (extract_real\n           (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n      \\<partial>state_measure V \\<Gamma>\n                     \\<partial>stock_measure (\\<Gamma> v)\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n        ennreal\n         (extract_real\n           (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n      \\<partial>state_measure V \\<Gamma>\n                     \\<partial>stock_measure (\\<Gamma> v) \\<noteq>\n  \\<infinity>", "have \"AE x in ?N. (\\<integral>\\<^sup>+\\<sigma>. ennreal (?f'' x \\<sigma>) \\<partial>?M) \\<noteq> \\<infinity>\" (is ?P)"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n        ennreal\n         (extract_real\n           (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n      \\<partial>state_measure V \\<Gamma>\n                     \\<partial>stock_measure (\\<Gamma> v) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ \\<sigma>.\n  ennreal\n   (extract_real\n     (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "using e disjoint"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n        ennreal\n         (extract_real\n           (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n      \\<partial>state_measure V \\<Gamma>\n                     \\<partial>stock_measure (\\<Gamma> v) \\<noteq>\n  \\<infinity>\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> insert v V \\<union> V'\n  V \\<inter> V' = {}\n  v \\<notin> V\n  v \\<notin> V'\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ \\<sigma>.\n  ennreal\n   (extract_real\n     (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "by (intro nn_integral_PInf_AE)\n       (auto simp: measurable_split_conv intro!: borel_measurable_nn_integral measurable_compose[OF _ measurable_ennreal]\n                   measurable_compose[OF _ measurable_cexpr_sem'[OF \\<rho>]])"], ["proof (state)\nthis:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). \\<integral>\\<^sup>+ \\<sigma>.\nennreal\n (extract_real\n   (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                    \\<partial>state_measure V\n         \\<Gamma> \\<noteq>\n                 \\<infinity>\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "moreover"], ["proof (state)\nthis:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). \\<integral>\\<^sup>+ \\<sigma>.\nennreal\n (extract_real\n   (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                    \\<partial>state_measure V\n         \\<Gamma> \\<noteq>\n                 \\<infinity>\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "have \"\\<And>x. x \\<in> space ?N \\<Longrightarrow> (\\<integral>\\<^sup>+\\<sigma>. ennreal (?f'' x \\<sigma>) \\<partial>?M) = (\\<integral>\\<^sup>+\\<sigma>. ennreal (?f x \\<sigma>) \\<partial>?M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (stock_measure (\\<Gamma> v)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ \\<sigma>.\n                            ennreal\n                             (extract_real\n                               (cexpr_sem\n                                 (merge (insert v V) V'\n                                   (\\<sigma>(v := x), \\<rho>))\n                                 e))\n                          \\<partial>state_measure V \\<Gamma> =\n       \\<integral>\\<^sup>+ \\<sigma>.\n                            ennreal\n                             (extract_real\n                               (cexpr_sem\n                                 (merge V (insert v V')\n                                   (\\<sigma>, \\<rho>(v := x)))\n                                 e))\n                          \\<partial>state_measure V \\<Gamma>", "by (intro nn_integral_cong) (simp add: f''_eq_f)"], ["proof (state)\nthis:\n  ?x \\<in> space (stock_measure (\\<Gamma> v)) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (extract_real\n                          (cexpr_sem\n                            (merge (insert v V) V'\n                              (\\<sigma>(v := ?x), \\<rho>))\n                            e))\n                     \\<partial>state_measure V \\<Gamma> =\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (extract_real\n                          (cexpr_sem\n                            (merge V (insert v V')\n                              (\\<sigma>, \\<rho>(v := ?x)))\n                            e))\n                     \\<partial>state_measure V \\<Gamma>\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "hence \"?P \\<longleftrightarrow> (AE x in ?N. (\\<integral>\\<^sup>+\\<sigma>. ennreal (?f x \\<sigma>) \\<partial>?M) \\<noteq> \\<infinity>)\""], ["proof (prove)\nusing this:\n  ?x \\<in> space (stock_measure (\\<Gamma> v)) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (extract_real\n                          (cexpr_sem\n                            (merge (insert v V) V'\n                              (\\<sigma>(v := ?x), \\<rho>))\n                            e))\n                     \\<partial>state_measure V \\<Gamma> =\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (extract_real\n                          (cexpr_sem\n                            (merge V (insert v V')\n                              (\\<sigma>, \\<rho>(v := ?x)))\n                            e))\n                     \\<partial>state_measure V \\<Gamma>\n\ngoal (1 subgoal):\n 1. (AE x in stock_measure\n              (\\<Gamma>\n                v). \\<integral>\\<^sup>+ \\<sigma>.\n   ennreal\n    (extract_real\n      (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n \\<partial>state_measure V \\<Gamma> \\<noteq>\n                    \\<infinity>) =\n    (AE x in stock_measure\n              (\\<Gamma>\n                v). \\<integral>\\<^sup>+ \\<sigma>.\n   ennreal\n    (extract_real\n      (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n \\<partial>state_measure V \\<Gamma> \\<noteq>\n                    \\<infinity>)", "by (intro AE_cong) simp"], ["proof (state)\nthis:\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (extract_real\n    (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>) =\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (extract_real\n    (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>)\n\ngoal (2 subgoals):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (extract_real (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>\n 2. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "ultimately"], ["proof (chain)\npicking this:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). \\<integral>\\<^sup>+ \\<sigma>.\nennreal\n (extract_real\n   (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                    \\<partial>state_measure V\n         \\<Gamma> \\<noteq>\n                 \\<infinity>\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (extract_real\n    (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>) =\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (extract_real\n    (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>)", "show \"AE x in ?N. (\\<integral>\\<^sup>+\\<sigma>. ennreal (?f x \\<sigma>) \\<partial>?M) \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). \\<integral>\\<^sup>+ \\<sigma>.\nennreal\n (extract_real\n   (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                    \\<partial>state_measure V\n         \\<Gamma> \\<noteq>\n                 \\<infinity>\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (extract_real\n    (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>) =\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (extract_real\n    (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>)\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ \\<sigma>.\n  ennreal\n   (extract_real\n     (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "by simp"], ["proof (state)\nthis:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). \\<integral>\\<^sup>+ \\<sigma>.\nennreal\n (extract_real\n   (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n                                    \\<partial>state_measure V\n         \\<Gamma> \\<noteq>\n                 \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "from int"], ["proof (chain)\npicking this:\n  integrable (state_measure (insert v V) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))", "have \"(\\<integral>\\<^sup>+\\<sigma>. ennreal (-?f' \\<sigma>) \\<partial>state_measure (insert v V) \\<Gamma>) \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  integrable (state_measure (insert v V) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<sigma>.\n                         ennreal\n                          (- extract_real\n                              (cexpr_sem\n                                (merge (insert v V) V' (\\<sigma>, \\<rho>))\n                                e))\n                       \\<partial>state_measure (insert v V)\n                                  \\<Gamma> \\<noteq>\n    \\<infinity>", "by (simp add: real_integrable_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (- extract_real\n                            (cexpr_sem\n                              (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n                     \\<partial>state_measure (insert v V) \\<Gamma> \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (- extract_real\n                            (cexpr_sem\n                              (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n                     \\<partial>state_measure (insert v V) \\<Gamma> \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "have \"(\\<integral>\\<^sup>+\\<sigma>. ennreal (-?f' \\<sigma>) \\<partial>state_measure (insert v V) \\<Gamma>) =\n                 \\<integral>\\<^sup>+x. \\<integral>\\<^sup>+\\<sigma>. ennreal (-?f'' x \\<sigma>) \\<partial>?M \\<partial>?N\" (is \"_ = ?I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<sigma>.\n                         ennreal\n                          (- extract_real\n                              (cexpr_sem\n                                (merge (insert v V) V' (\\<sigma>, \\<rho>))\n                                e))\n                       \\<partial>state_measure (insert v V) \\<Gamma> =\n    \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n          ennreal\n           (- extract_real\n               (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>))\n                 e))\n        \\<partial>state_measure V \\<Gamma>\n                       \\<partial>stock_measure (\\<Gamma> v)", "using fin disjoint e \\<rho>"], ["proof (prove)\nusing this:\n  finite V\n  V \\<inter> V' = {}\n  v \\<notin> V\n  v \\<notin> V'\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> insert v V \\<union> V'\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<sigma>.\n                         ennreal\n                          (- extract_real\n                              (cexpr_sem\n                                (merge (insert v V) V' (\\<sigma>, \\<rho>))\n                                e))\n                       \\<partial>state_measure (insert v V) \\<Gamma> =\n    \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n          ennreal\n           (- extract_real\n               (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>))\n                 e))\n        \\<partial>state_measure V \\<Gamma>\n                       \\<partial>stock_measure (\\<Gamma> v)", "by (unfold state_measure_def, subst product_nn_integral_insert_rev)\n       (auto intro!: measurable_compose[OF _ measurable_ennreal] borel_measurable_uminus\n                     measurable_cexpr_sem'[unfolded state_measure_def])"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (- extract_real\n                            (cexpr_sem\n                              (merge (insert v V) V' (\\<sigma>, \\<rho>)) e))\n                     \\<partial>state_measure (insert v V) \\<Gamma> =\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n        ennreal\n         (- extract_real\n             (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>))\n               e))\n      \\<partial>state_measure V \\<Gamma>\n                     \\<partial>stock_measure (\\<Gamma> v)\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n        ennreal\n         (- extract_real\n             (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>))\n               e))\n      \\<partial>state_measure V \\<Gamma>\n                     \\<partial>stock_measure (\\<Gamma> v) \\<noteq>\n  \\<infinity>", "have \"AE x in ?N. (\\<integral>\\<^sup>+\\<sigma>. ennreal (-?f'' x \\<sigma>) \\<partial>?M) \\<noteq> \\<infinity>\" (is ?P)"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n        ennreal\n         (- extract_real\n             (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>))\n               e))\n      \\<partial>state_measure V \\<Gamma>\n                     \\<partial>stock_measure (\\<Gamma> v) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ \\<sigma>.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "using e disjoint"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ \\<sigma>.\n        ennreal\n         (- extract_real\n             (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>))\n               e))\n      \\<partial>state_measure V \\<Gamma>\n                     \\<partial>stock_measure (\\<Gamma> v) \\<noteq>\n  \\<infinity>\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> insert v V \\<union> V'\n  V \\<inter> V' = {}\n  v \\<notin> V\n  v \\<notin> V'\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ \\<sigma>.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "by (intro nn_integral_PInf_AE)\n       (auto simp: measurable_split_conv intro!: borel_measurable_nn_integral measurable_compose[OF _ measurable_ennreal]\n                   measurable_compose[OF _ measurable_cexpr_sem'[OF \\<rho>]] borel_measurable_uminus)"], ["proof (state)\nthis:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). \\<integral>\\<^sup>+ \\<sigma>.\nennreal\n (- extract_real\n     (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                    \\<partial>state_measure V\n         \\<Gamma> \\<noteq>\n                 \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "moreover"], ["proof (state)\nthis:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). \\<integral>\\<^sup>+ \\<sigma>.\nennreal\n (- extract_real\n     (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                    \\<partial>state_measure V\n         \\<Gamma> \\<noteq>\n                 \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "have \"\\<And>x. x \\<in> space ?N \\<Longrightarrow> (\\<integral>\\<^sup>+\\<sigma>. ennreal (-?f'' x \\<sigma>) \\<partial>?M) = (\\<integral>\\<^sup>+\\<sigma>. ennreal (-?f x \\<sigma>) \\<partial>?M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (stock_measure (\\<Gamma> v)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ \\<sigma>.\n                            ennreal\n                             (- extract_real\n                                 (cexpr_sem\n                                   (merge (insert v V) V'\n                                     (\\<sigma>(v := x), \\<rho>))\n                                   e))\n                          \\<partial>state_measure V \\<Gamma> =\n       \\<integral>\\<^sup>+ \\<sigma>.\n                            ennreal\n                             (- extract_real\n                                 (cexpr_sem\n                                   (merge V (insert v V')\n                                     (\\<sigma>, \\<rho>(v := x)))\n                                   e))\n                          \\<partial>state_measure V \\<Gamma>", "by (intro nn_integral_cong) (simp add: f''_eq_f)"], ["proof (state)\nthis:\n  ?x \\<in> space (stock_measure (\\<Gamma> v)) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (- extract_real\n                            (cexpr_sem\n                              (merge (insert v V) V'\n                                (\\<sigma>(v := ?x), \\<rho>))\n                              e))\n                     \\<partial>state_measure V \\<Gamma> =\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (- extract_real\n                            (cexpr_sem\n                              (merge V (insert v V')\n                                (\\<sigma>, \\<rho>(v := ?x)))\n                              e))\n                     \\<partial>state_measure V \\<Gamma>\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "hence \"?P \\<longleftrightarrow> (AE x in ?N. (\\<integral>\\<^sup>+\\<sigma>. ennreal (-?f x \\<sigma>) \\<partial>?M) \\<noteq> \\<infinity>)\""], ["proof (prove)\nusing this:\n  ?x \\<in> space (stock_measure (\\<Gamma> v)) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (- extract_real\n                            (cexpr_sem\n                              (merge (insert v V) V'\n                                (\\<sigma>(v := ?x), \\<rho>))\n                              e))\n                     \\<partial>state_measure V \\<Gamma> =\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (- extract_real\n                            (cexpr_sem\n                              (merge V (insert v V')\n                                (\\<sigma>, \\<rho>(v := ?x)))\n                              e))\n                     \\<partial>state_measure V \\<Gamma>\n\ngoal (1 subgoal):\n 1. (AE x in stock_measure\n              (\\<Gamma>\n                v). \\<integral>\\<^sup>+ \\<sigma>.\n   ennreal\n    (- extract_real\n        (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n \\<partial>state_measure V \\<Gamma> \\<noteq>\n                    \\<infinity>) =\n    (AE x in stock_measure\n              (\\<Gamma>\n                v). \\<integral>\\<^sup>+ \\<sigma>.\n   ennreal\n    (- extract_real\n        (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n \\<partial>state_measure V \\<Gamma> \\<noteq>\n                    \\<infinity>)", "by (intro AE_cong) simp"], ["proof (state)\nthis:\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (- extract_real\n      (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>) =\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (- extract_real\n      (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>)\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ xa.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (xa, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "ultimately"], ["proof (chain)\npicking this:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). \\<integral>\\<^sup>+ \\<sigma>.\nennreal\n (- extract_real\n     (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                    \\<partial>state_measure V\n         \\<Gamma> \\<noteq>\n                 \\<infinity>\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (- extract_real\n      (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>) =\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (- extract_real\n      (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>)", "show \"AE x in ?N. (\\<integral>\\<^sup>+\\<sigma>. ennreal (-?f x \\<sigma>) \\<partial>?M) \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). \\<integral>\\<^sup>+ \\<sigma>.\nennreal\n (- extract_real\n     (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                    \\<partial>state_measure V\n         \\<Gamma> \\<noteq>\n                 \\<infinity>\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (- extract_real\n      (cexpr_sem (merge (insert v V) V' (\\<sigma>(v := x), \\<rho>)) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>) =\n  (AE x in stock_measure\n            (\\<Gamma>\n              v). \\<integral>\\<^sup>+ \\<sigma>.\n ennreal\n  (- extract_real\n      (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n                                     \\<partial>state_measure V\n          \\<Gamma> \\<noteq>\n                  \\<infinity>)\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). \\<integral>\\<^sup>+ \\<sigma>.\n  ennreal\n   (- extract_real\n       (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n\\<partial>state_measure V \\<Gamma> \\<noteq>\n                   \\<infinity>", "by simp"], ["proof (state)\nthis:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). \\<integral>\\<^sup>+ \\<sigma>.\nennreal\n (- extract_real\n     (cexpr_sem (merge V (insert v V') (\\<sigma>, \\<rho>(v := x))) e))\n                                    \\<partial>state_measure V\n         \\<Gamma> \\<noteq>\n                 \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition cdens_ctxt_invar :: \"vname list \\<Rightarrow> vname list \\<Rightarrow> tyenv \\<Rightarrow> cexpr \\<Rightarrow> bool\" where\n  \"cdens_ctxt_invar vs vs' \\<Gamma> \\<delta> \\<equiv>\n       distinct (vs @ vs') \\<and>\n       free_vars \\<delta> \\<subseteq> set (vs @ vs') \\<and>\n       \\<Gamma> \\<turnstile>\\<^sub>c \\<delta> : REAL \\<and>\n       nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta> \\<and>\n       subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>\""], ["", "lemma cdens_ctxt_invarI:\n  \"\\<lbrakk>distinct (vs @ vs'); free_vars \\<delta> \\<subseteq> set (vs @ vs'); \\<Gamma> \\<turnstile>\\<^sub>c \\<delta> : REAL;\n    nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta>;\n    subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta> \\<rbrakk> \\<Longrightarrow>\n      cdens_ctxt_invar vs vs' \\<Gamma> \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (vs @ vs');\n     free_vars \\<delta> \\<subseteq> set (vs @ vs');\n     \\<Gamma> \\<turnstile>\\<^sub>c \\<delta> : REAL;\n     nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta>;\n     subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>\\<rbrakk>\n    \\<Longrightarrow> cdens_ctxt_invar vs vs' \\<Gamma> \\<delta>", "by (simp add: cdens_ctxt_invar_def)"], ["", "lemma cdens_ctxt_invarD:\n  assumes \"cdens_ctxt_invar vs vs' \\<Gamma> \\<delta>\"\n  shows \"distinct (vs @ vs')\" \"free_vars \\<delta> \\<subseteq> set (vs @ vs')\" \"\\<Gamma> \\<turnstile>\\<^sub>c \\<delta> : REAL\"\n        \"nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta>\" \"subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct (vs @ vs') &&&\n     free_vars \\<delta> \\<subseteq> set (vs @ vs')) &&&\n    \\<Gamma> \\<turnstile>\\<^sub>c \\<delta> : REAL &&&\n    nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta> &&&\n    subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>", "using assms"], ["proof (prove)\nusing this:\n  cdens_ctxt_invar vs vs' \\<Gamma> \\<delta>\n\ngoal (1 subgoal):\n 1. (distinct (vs @ vs') &&&\n     free_vars \\<delta> \\<subseteq> set (vs @ vs')) &&&\n    \\<Gamma> \\<turnstile>\\<^sub>c \\<delta> : REAL &&&\n    nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta> &&&\n    subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>", "by (simp_all add: cdens_ctxt_invar_def)"], ["", "lemma cdens_ctxt_invar_empty:\n  assumes \"cdens_ctxt_invar vs vs' \\<Gamma> \\<delta>\"\n  shows \"cdens_ctxt_invar [] (vs @ vs') \\<Gamma> (CReal 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cdens_ctxt_invar [] (vs @ vs') \\<Gamma> (CReal 1)", "using cdens_ctxt_invarD[OF assms]"], ["proof (prove)\nusing this:\n  distinct (vs @ vs')\n  free_vars \\<delta> \\<subseteq> set (vs @ vs')\n  \\<Gamma> \\<turnstile>\\<^sub>c \\<delta> : REAL\n  nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta>\n  subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>\n\ngoal (1 subgoal):\n 1. cdens_ctxt_invar [] (vs @ vs') \\<Gamma> (CReal 1)", "by (intro cdens_ctxt_invarI)\n     (auto simp: cexpr_type_Some_iff[symmetric] extract_real_def state_measure_def PiM_empty\n           intro!: nonneg_cexprI subprob_cexprI)"], ["", "lemma cdens_ctxt_invar_imp_integrable:\n  assumes \"cdens_ctxt_invar vs vs' \\<Gamma> \\<delta>\" and \\<rho>: \"\\<rho> \\<in> space (state_measure (set vs') \\<Gamma>)\"\n  shows \"integrable (state_measure (set vs) \\<Gamma>)\n             (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge (set vs) (set vs') (\\<sigma>, \\<rho>)) \\<delta>))\" (is \"integrable ?M ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable (state_measure (set vs) \\<Gamma>)\n     (\\<lambda>\\<sigma>.\n         extract_real\n          (cexpr_sem (merge (set vs) (set vs') (\\<sigma>, \\<rho>))\n            \\<delta>))", "unfolding integrable_iff_bounded"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        extract_real\n         (cexpr_sem (merge (set vs) (set vs') (\\<sigma>, \\<rho>)) \\<delta>))\n    \\<in> borel_measurable (state_measure (set vs) \\<Gamma>) \\<and>\n    \\<integral>\\<^sup>+ x. ennreal\n                            (norm\n                              (extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (set vs') (x, \\<rho>))\n                                  \\<delta>)))\n                       \\<partial>state_measure (set vs) \\<Gamma>\n    < \\<infinity>", "proof (intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>\\<sigma>.\n        extract_real\n         (cexpr_sem (merge (set vs) (set vs') (\\<sigma>, \\<rho>)) \\<delta>))\n    \\<in> borel_measurable (state_measure (set vs) \\<Gamma>)\n 2. \\<integral>\\<^sup>+ x. ennreal\n                            (norm\n                              (extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (set vs') (x, \\<rho>))\n                                  \\<delta>)))\n                       \\<partial>state_measure (set vs) \\<Gamma>\n    < \\<infinity>", "note invar = cdens_ctxt_invarD[OF assms(1)]"], ["proof (state)\nthis:\n  distinct (vs @ vs')\n  free_vars \\<delta> \\<subseteq> set (vs @ vs')\n  \\<Gamma> \\<turnstile>\\<^sub>c \\<delta> : REAL\n  nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta>\n  subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>\n\ngoal (2 subgoals):\n 1. (\\<lambda>\\<sigma>.\n        extract_real\n         (cexpr_sem (merge (set vs) (set vs') (\\<sigma>, \\<rho>)) \\<delta>))\n    \\<in> borel_measurable (state_measure (set vs) \\<Gamma>)\n 2. \\<integral>\\<^sup>+ x. ennreal\n                            (norm\n                              (extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (set vs') (x, \\<rho>))\n                                  \\<delta>)))\n                       \\<partial>state_measure (set vs) \\<Gamma>\n    < \\<infinity>", "show \"?f \\<in> borel_measurable ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        extract_real\n         (cexpr_sem (merge (set vs) (set vs') (\\<sigma>, \\<rho>)) \\<delta>))\n    \\<in> borel_measurable (state_measure (set vs) \\<Gamma>)", "apply (rule measurable_compose[OF _ measurable_extract_real])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. cexpr_sem (merge (set vs) (set vs') (x, \\<rho>)) \\<delta>)\n    \\<in> state_measure (set vs) \\<Gamma> \\<rightarrow>\\<^sub>M\n          stock_measure REAL", "apply (rule measurable_compose[OF _ measurable_cexpr_sem[OF invar(3,2)]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. merge (set vs) (set vs') (x, \\<rho>))\n    \\<in> state_measure (set vs) \\<Gamma> \\<rightarrow>\\<^sub>M\n          state_measure (set (vs @ vs')) \\<Gamma>", "apply (simp only: state_measure_def set_append, rule measurable_compose[OF _ measurable_merge])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (x, \\<rho>))\n    \\<in> Pi\\<^sub>M (set vs)\n           (\\<lambda>x. stock_measure (\\<Gamma> x)) \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M (set vs)\n           (\\<lambda>x. stock_measure (\\<Gamma> x)) \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M (set vs') (\\<lambda>x. stock_measure (\\<Gamma> x))", "apply (rule measurable_Pair, simp, insert assms(2), simp add: state_measure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>\\<sigma>.\n      extract_real\n       (cexpr_sem (merge (set vs) (set vs') (\\<sigma>, \\<rho>)) \\<delta>))\n  \\<in> borel_measurable (state_measure (set vs) \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (norm\n                              (extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (set vs') (x, \\<rho>))\n                                  \\<delta>)))\n                       \\<partial>state_measure (set vs) \\<Gamma>\n    < \\<infinity>", "have nonneg: \"\\<And>\\<sigma>. \\<sigma> \\<in> space ?M \\<Longrightarrow> ?f \\<sigma> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma>\n       \\<in> space (state_measure (set vs) \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem (merge (set vs) (set vs') (\\<sigma>, \\<rho>))\n                  \\<delta>)", "using \\<open>nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta>\\<close>"], ["proof (prove)\nusing this:\n  nonneg_cexpr (set vs \\<union> set vs') \\<Gamma> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma>\n       \\<in> space (state_measure (set vs) \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real\n                (cexpr_sem (merge (set vs) (set vs') (\\<sigma>, \\<rho>))\n                  \\<delta>)", "by (rule nonneg_cexprD, intro merge_in_state_measure[OF _ \\<rho>])"], ["proof (state)\nthis:\n  ?\\<sigma> \\<in> space (state_measure (set vs) \\<Gamma>) \\<Longrightarrow>\n  0 \\<le> extract_real\n           (cexpr_sem (merge (set vs) (set vs') (?\\<sigma>, \\<rho>))\n             \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (norm\n                              (extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (set vs') (x, \\<rho>))\n                                  \\<delta>)))\n                       \\<partial>state_measure (set vs) \\<Gamma>\n    < \\<infinity>", "with \\<open>subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>\\<close> and \\<rho>"], ["proof (chain)\npicking this:\n  subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>\n  \\<rho> \\<in> space (state_measure (set vs') \\<Gamma>)\n  ?\\<sigma> \\<in> space (state_measure (set vs) \\<Gamma>) \\<Longrightarrow>\n  0 \\<le> extract_real\n           (cexpr_sem (merge (set vs) (set vs') (?\\<sigma>, \\<rho>))\n             \\<delta>)", "show \"(\\<integral>\\<^sup>+\\<sigma>. ennreal (norm (?f \\<sigma>)) \\<partial>?M) < \\<infinity>\""], ["proof (prove)\nusing this:\n  subprob_cexpr (set vs) (set vs') \\<Gamma> \\<delta>\n  \\<rho> \\<in> space (state_measure (set vs') \\<Gamma>)\n  ?\\<sigma> \\<in> space (state_measure (set vs) \\<Gamma>) \\<Longrightarrow>\n  0 \\<le> extract_real\n           (cexpr_sem (merge (set vs) (set vs') (?\\<sigma>, \\<rho>))\n             \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<sigma>.\n                         ennreal\n                          (norm\n                            (extract_real\n                              (cexpr_sem\n                                (merge (set vs) (set vs')\n                                  (\\<sigma>, \\<rho>))\n                                \\<delta>)))\n                       \\<partial>state_measure (set vs) \\<Gamma>\n    < \\<infinity>", "unfolding subprob_cexpr_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<rho>\\<in>space (state_measure (set vs') \\<Gamma>).\n     \\<integral>\\<^sup>+ x. ennreal\n                             (extract_real\n                               (cexpr_sem\n                                 (merge (set vs) (set vs') (x, \\<rho>))\n                                 \\<delta>))\n                        \\<partial>state_measure (set vs) \\<Gamma>\n     \\<le> 1\n  \\<rho> \\<in> space (state_measure (set vs') \\<Gamma>)\n  ?\\<sigma> \\<in> space (state_measure (set vs) \\<Gamma>) \\<Longrightarrow>\n  0 \\<le> extract_real\n           (cexpr_sem (merge (set vs) (set vs') (?\\<sigma>, \\<rho>))\n             \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<sigma>.\n                         ennreal\n                          (norm\n                            (extract_real\n                              (cexpr_sem\n                                (merge (set vs) (set vs')\n                                  (\\<sigma>, \\<rho>))\n                                \\<delta>)))\n                       \\<partial>state_measure (set vs) \\<Gamma>\n    < \\<infinity>", "by (auto simp: less_top[symmetric] top_unique cong: nn_integral_cong)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<sigma>.\n                       ennreal\n                        (norm\n                          (extract_real\n                            (cexpr_sem\n                              (merge (set vs) (set vs') (\\<sigma>, \\<rho>))\n                              \\<delta>)))\n                     \\<partial>state_measure (set vs) \\<Gamma>\n  < \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Randomfree expressions\\<close>"], ["", "text \\<open>\n  Translates an expression with no occurrences of Random or Fail into an\n  equivalent target language expression.\n\\<close>"], ["", "primrec expr_rf_to_cexpr :: \"expr \\<Rightarrow> cexpr\" where\n  \"expr_rf_to_cexpr (Val v) = CVal v\"\n| \"expr_rf_to_cexpr (Var x) = CVar x\"\n| \"expr_rf_to_cexpr <e1, e2> = <expr_rf_to_cexpr e1, expr_rf_to_cexpr e2>\\<^sub>c\"\n| \"expr_rf_to_cexpr (oper $$ e) = oper $$\\<^sub>c (expr_rf_to_cexpr e)\"\n| \"expr_rf_to_cexpr (IF b THEN e1 ELSE e2) =\n      (IF\\<^sub>c expr_rf_to_cexpr b THEN expr_rf_to_cexpr e1 ELSE expr_rf_to_cexpr e2)\"\n| \"expr_rf_to_cexpr (LET e1 IN e2) =\n      cexpr_subst 0 (expr_rf_to_cexpr e1) (expr_rf_to_cexpr e2)\"\n| \"expr_rf_to_cexpr (Random _ _) = undefined\"\n| \"expr_rf_to_cexpr (Fail _) = undefined\""], ["", "lemma cexpr_sem_expr_rf_to_cexpr:\n     \"randomfree e \\<Longrightarrow> cexpr_sem \\<sigma> (expr_rf_to_cexpr e) = expr_sem_rf \\<sigma> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. randomfree e \\<Longrightarrow>\n    cexpr_sem \\<sigma> (expr_rf_to_cexpr e) = expr_sem_rf \\<sigma> e", "by (induction e arbitrary: \\<sigma>) (auto simp: cexpr_sem_cexpr_subst)"], ["", "lemma cexpr_typing_expr_rf_to_cexpr[intro]:\n    assumes \"\\<Gamma> \\<turnstile> e : t\" \"randomfree e\"\n    shows \"\\<Gamma> \\<turnstile>\\<^sub>c expr_rf_to_cexpr e : t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c expr_rf_to_cexpr e : t", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> e : t\n  randomfree e\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c expr_rf_to_cexpr e : t", "by (induction rule: expr_typing.induct) (auto intro!: cexpr_typing.intros)"], ["", "lemma free_vars_expr_rf_to_cexpr:\n  \"randomfree e \\<Longrightarrow> free_vars (expr_rf_to_cexpr e) \\<subseteq> free_vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. randomfree e \\<Longrightarrow>\n    free_vars (expr_rf_to_cexpr e) \\<subseteq> free_vars e", "proof (induction e)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x.\n       randomfree (Var x) \\<Longrightarrow>\n       free_vars (expr_rf_to_cexpr (Var x)) \\<subseteq> free_vars (Var x)\n 2. \\<And>x.\n       randomfree (Val x) \\<Longrightarrow>\n       free_vars (expr_rf_to_cexpr (Val x)) \\<subseteq> free_vars (Val x)\n 3. \\<And>e1 e2.\n       \\<lbrakk>randomfree e1 \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e1) \\<subseteq> free_vars e1;\n        randomfree e2 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e2) \\<subseteq> free_vars e2;\n        randomfree (LET e1 IN e2)\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr (LET e1 IN e2))\n                         \\<subseteq> free_vars (LET e1 IN e2)\n 4. \\<And>x1a e.\n       \\<lbrakk>randomfree e \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e) \\<subseteq> free_vars e;\n        randomfree (x1a $$ e)\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr (x1a $$ e))\n                         \\<subseteq> free_vars (x1a $$ e)\n 5. \\<And>e1 e2.\n       \\<lbrakk>randomfree e1 \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e1) \\<subseteq> free_vars e1;\n        randomfree e2 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e2) \\<subseteq> free_vars e2;\n        randomfree <e1 ,  e2>\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr <e1 ,  e2>)\n                         \\<subseteq> free_vars <e1 ,  e2>\n 6. \\<And>x1a e.\n       \\<lbrakk>randomfree e \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e) \\<subseteq> free_vars e;\n        randomfree (Random x1a e)\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr (Random x1a e))\n                         \\<subseteq> free_vars (Random x1a e)\n 7. \\<And>e1 e2 e3.\n       \\<lbrakk>randomfree e1 \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e1) \\<subseteq> free_vars e1;\n        randomfree e2 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e2) \\<subseteq> free_vars e2;\n        randomfree e3 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e3) \\<subseteq> free_vars e3;\n        randomfree (IF e1 THEN e2 ELSE e3)\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (expr_rf_to_cexpr (IF e1 THEN e2 ELSE e3))\n                         \\<subseteq> free_vars (IF e1 THEN e2 ELSE e3)\n 8. \\<And>x.\n       randomfree (Fail x) \\<Longrightarrow>\n       free_vars (expr_rf_to_cexpr (Fail x)) \\<subseteq> free_vars (Fail x)", "case (LetVar e1 e2)"], ["proof (state)\nthis:\n  randomfree e1 \\<Longrightarrow>\n  free_vars (expr_rf_to_cexpr e1) \\<subseteq> free_vars e1\n  randomfree e2 \\<Longrightarrow>\n  free_vars (expr_rf_to_cexpr e2) \\<subseteq> free_vars e2\n  randomfree (LET e1 IN e2)\n\ngoal (8 subgoals):\n 1. \\<And>x.\n       randomfree (Var x) \\<Longrightarrow>\n       free_vars (expr_rf_to_cexpr (Var x)) \\<subseteq> free_vars (Var x)\n 2. \\<And>x.\n       randomfree (Val x) \\<Longrightarrow>\n       free_vars (expr_rf_to_cexpr (Val x)) \\<subseteq> free_vars (Val x)\n 3. \\<And>e1 e2.\n       \\<lbrakk>randomfree e1 \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e1) \\<subseteq> free_vars e1;\n        randomfree e2 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e2) \\<subseteq> free_vars e2;\n        randomfree (LET e1 IN e2)\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr (LET e1 IN e2))\n                         \\<subseteq> free_vars (LET e1 IN e2)\n 4. \\<And>x1a e.\n       \\<lbrakk>randomfree e \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e) \\<subseteq> free_vars e;\n        randomfree (x1a $$ e)\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr (x1a $$ e))\n                         \\<subseteq> free_vars (x1a $$ e)\n 5. \\<And>e1 e2.\n       \\<lbrakk>randomfree e1 \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e1) \\<subseteq> free_vars e1;\n        randomfree e2 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e2) \\<subseteq> free_vars e2;\n        randomfree <e1 ,  e2>\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr <e1 ,  e2>)\n                         \\<subseteq> free_vars <e1 ,  e2>\n 6. \\<And>x1a e.\n       \\<lbrakk>randomfree e \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e) \\<subseteq> free_vars e;\n        randomfree (Random x1a e)\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr (Random x1a e))\n                         \\<subseteq> free_vars (Random x1a e)\n 7. \\<And>e1 e2 e3.\n       \\<lbrakk>randomfree e1 \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e1) \\<subseteq> free_vars e1;\n        randomfree e2 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e2) \\<subseteq> free_vars e2;\n        randomfree e3 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e3) \\<subseteq> free_vars e3;\n        randomfree (IF e1 THEN e2 ELSE e3)\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (expr_rf_to_cexpr (IF e1 THEN e2 ELSE e3))\n                         \\<subseteq> free_vars (IF e1 THEN e2 ELSE e3)\n 8. \\<And>x.\n       randomfree (Fail x) \\<Longrightarrow>\n       free_vars (expr_rf_to_cexpr (Fail x)) \\<subseteq> free_vars (Fail x)", "thus ?case"], ["proof (prove)\nusing this:\n  randomfree e1 \\<Longrightarrow>\n  free_vars (expr_rf_to_cexpr e1) \\<subseteq> free_vars e1\n  randomfree e2 \\<Longrightarrow>\n  free_vars (expr_rf_to_cexpr e2) \\<subseteq> free_vars e2\n  randomfree (LET e1 IN e2)\n\ngoal (1 subgoal):\n 1. free_vars (expr_rf_to_cexpr (LET e1 IN e2))\n    \\<subseteq> free_vars (LET e1 IN e2)", "by (simp only: free_vars_cexpr.simps expr_rf_to_cexpr.simps,\n        intro order.trans[OF free_vars_cexpr_subst]) auto"], ["proof (state)\nthis:\n  free_vars (expr_rf_to_cexpr (LET e1 IN e2))\n  \\<subseteq> free_vars (LET e1 IN e2)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       randomfree (Var x) \\<Longrightarrow>\n       free_vars (expr_rf_to_cexpr (Var x)) \\<subseteq> free_vars (Var x)\n 2. \\<And>x.\n       randomfree (Val x) \\<Longrightarrow>\n       free_vars (expr_rf_to_cexpr (Val x)) \\<subseteq> free_vars (Val x)\n 3. \\<And>x1a e.\n       \\<lbrakk>randomfree e \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e) \\<subseteq> free_vars e;\n        randomfree (x1a $$ e)\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr (x1a $$ e))\n                         \\<subseteq> free_vars (x1a $$ e)\n 4. \\<And>e1 e2.\n       \\<lbrakk>randomfree e1 \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e1) \\<subseteq> free_vars e1;\n        randomfree e2 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e2) \\<subseteq> free_vars e2;\n        randomfree <e1 ,  e2>\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr <e1 ,  e2>)\n                         \\<subseteq> free_vars <e1 ,  e2>\n 5. \\<And>x1a e.\n       \\<lbrakk>randomfree e \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e) \\<subseteq> free_vars e;\n        randomfree (Random x1a e)\\<rbrakk>\n       \\<Longrightarrow> free_vars (expr_rf_to_cexpr (Random x1a e))\n                         \\<subseteq> free_vars (Random x1a e)\n 6. \\<And>e1 e2 e3.\n       \\<lbrakk>randomfree e1 \\<Longrightarrow>\n                free_vars (expr_rf_to_cexpr e1) \\<subseteq> free_vars e1;\n        randomfree e2 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e2) \\<subseteq> free_vars e2;\n        randomfree e3 \\<Longrightarrow>\n        free_vars (expr_rf_to_cexpr e3) \\<subseteq> free_vars e3;\n        randomfree (IF e1 THEN e2 ELSE e3)\\<rbrakk>\n       \\<Longrightarrow> free_vars\n                          (expr_rf_to_cexpr (IF e1 THEN e2 ELSE e3))\n                         \\<subseteq> free_vars (IF e1 THEN e2 ELSE e3)\n 7. \\<And>x.\n       randomfree (Fail x) \\<Longrightarrow>\n       free_vars (expr_rf_to_cexpr (Fail x)) \\<subseteq> free_vars (Fail x)", "qed auto"], ["", "subsection \\<open>Builtin density expressions\\<close>"], ["", "primrec dist_dens_cexpr :: \"pdf_dist \\<Rightarrow> cexpr \\<Rightarrow> cexpr \\<Rightarrow> cexpr\" where\n  \"dist_dens_cexpr Bernoulli p x = (IF\\<^sub>c CReal 0 \\<le>\\<^sub>c p \\<and>\\<^sub>c p \\<le>\\<^sub>c CReal 1 THEN\n                                       IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p\n                                    ELSE CReal 0)\"\n| \"dist_dens_cexpr UniformInt p x = (IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c snd\\<^sub>c p \\<and>\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c x \\<le>\\<^sub>c snd\\<^sub>c p THEN\n                                         inverse\\<^sub>c (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\"\n| \"dist_dens_cexpr UniformReal p x = (IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c snd\\<^sub>c p \\<and>\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c x \\<le>\\<^sub>c snd\\<^sub>c p THEN\n                                         inverse\\<^sub>c (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\"\n| \"dist_dens_cexpr Gaussian p x = (IF\\<^sub>c CReal 0 <\\<^sub>c snd\\<^sub>c p THEN\n                                     exp\\<^sub>c (-\\<^sub>c((x -\\<^sub>c fst\\<^sub>c p)^\\<^sub>cCInt 2 /\\<^sub>c (CReal 2 *\\<^sub>c snd\\<^sub>c p^\\<^sub>cCInt 2))) /\\<^sub>c\n                                         sqrt\\<^sub>c (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\"\n| \"dist_dens_cexpr Poisson p x = (IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c CInt 0 \\<le>\\<^sub>c x THEN\n                                    p ^\\<^sub>c x /\\<^sub>c \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\""], ["", "lemma free_vars_dist_dens_cexpr:\n    \"free_vars (dist_dens_cexpr dst e1 e2) \\<subseteq> free_vars e1 \\<union> free_vars e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (dist_dens_cexpr dst e1 e2)\n    \\<subseteq> free_vars e1 \\<union> free_vars e2", "by (subst dist_dens_cexpr_def, cases dst) simp_all"], ["", "lemma cexpr_typing_dist_dens_cexpr:\n    assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst\"\n    shows \"\\<Gamma> \\<turnstile>\\<^sub>c dist_dens_cexpr dst e1 e2 : REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c dist_dens_cexpr dst e1 e2 : REAL", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst\n  \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c dist_dens_cexpr dst e1 e2 : REAL", "apply (subst dist_dens_cexpr_def, cases dst)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Bernoulli\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformReal\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 4. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 5. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "(* Bernoulli *)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Bernoulli\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformReal\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 4. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 5. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "apply (simp, intro cet_op_intros cet_if cet_val' cet_var' cet_eq, simp_all) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformReal\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 4. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "(* Uniform int *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformReal\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 4. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "apply (simp, intro cet_if cet_and cet_or cet_less_int cet_eq)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c fst\\<^sub>c e1 : ?t36\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c snd\\<^sub>c e1 : ?t36\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c fst\\<^sub>c e1 : INTEG\n 4. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c snd\\<^sub>c e1 : INTEG\n 5. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c fst\\<^sub>c e1 : ?t33\n 6. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : ?t33\n 7. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c fst\\<^sub>c e1 : INTEG\n 8. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG\n 9. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e2 : ?t29\n 10. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n      \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n     \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c snd\\<^sub>c e1 : ?t29\nA total of 17 subgoals...", "apply (erule cet_fst cet_snd | simp)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       inverse\\<^sub>c\n                        (\\<langle>snd\\<^sub>c e1 -\\<^sub>c\n                                  fst\\<^sub>c e1 +\\<^sub>c\n                                  CInt 1\\<rangle>\\<^sub>c) :\n                       REAL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c CReal 0 : REAL\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformReal\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 4. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 5. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "apply (rule cet_inverse, rule cet_op[where t = INTEG], intro cet_add_int cet_minus_int)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c snd\\<^sub>c e1 : INTEG\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c fst\\<^sub>c e1 : INTEG\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c CInt 1 : INTEG\n 4. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> op_type (Cast REAL) INTEG = Some REAL\n 5. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : PRODUCT INTEG INTEG;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = UniformInt\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c CReal 0 : REAL\n 6. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformReal\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 7. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 8. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "apply (simp_all add: cet_val' cet_fst cet_snd) [5]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformReal\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "(* Uniform real *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = UniformReal\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "apply (simp, intro cet_if cet_op_intros cet_eq cet_fst cet_snd, simp_all add: cet_val') []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "(* Poisson *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "apply (simp, intro cet_if cet_and, rule cet_less_real, simp add: cet_val', simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       CInt 0 \\<le>\\<^sub>c e2 : BOOL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       e1 ^\\<^sub>c e2 /\\<^sub>c\n                       \\<langle>fact\\<^sub>c e2\\<rangle>\\<^sub>c *\\<^sub>c\n                       exp\\<^sub>c (-\\<^sub>c e1) :\n                       REAL\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c CReal 0 : REAL\n 4. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "apply (rule cet_less_eq_int, simp add: cet_val', simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       e1 ^\\<^sub>c e2 /\\<^sub>c\n                       \\<langle>fact\\<^sub>c e2\\<rangle>\\<^sub>c *\\<^sub>c\n                       exp\\<^sub>c (-\\<^sub>c e1) :\n                       REAL\n 2. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : REAL;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : INTEG; dst = Poisson\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c CReal 0 : REAL\n 3. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "apply (intro cet_mult_real cet_pow_real cet_inverse cet_cast_real_int cet_exp cet_minus_real\n               cet_op[where oper = Fact and t = INTEG] cet_var', simp_all add: cet_val') [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "(* Gaussian *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst;\n     \\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst;\n     dst = Gaussian\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c\n                       rec_pdf_dist\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 \\<le>\\<^sub>c\n p \\<and>\\<^sub>c\n p \\<le>\\<^sub>c\n CReal 1 THEN IF\\<^sub>c x THEN p ELSE CReal 1 -\\<^sub>c p ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p \\<le>\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (\\<langle>snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p +\\<^sub>c\n                    CInt 1\\<rangle>\\<^sub>c) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c fst\\<^sub>c p <\\<^sub>c\n snd\\<^sub>c p \\<and>\\<^sub>c\n fst\\<^sub>c p \\<le>\\<^sub>c x \\<and>\\<^sub>c\n x \\<le>\\<^sub>c\n snd\\<^sub>c\n  p THEN inverse\\<^sub>c\n          (snd\\<^sub>c p -\\<^sub>c fst\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c p \\<and>\\<^sub>c\n CInt 0 \\<le>\\<^sub>c\n x THEN p ^\\<^sub>c x /\\<^sub>c\n        \\<langle>fact\\<^sub>c x\\<rangle>\\<^sub>c *\\<^sub>c\n        exp\\<^sub>c (-\\<^sub>c p) ELSE CReal 0)\n                        (\\<lambda>p x.\n                            IF\\<^sub>c CReal 0 <\\<^sub>c\n snd\\<^sub>c\n  p THEN exp\\<^sub>c\n          (-\\<^sub>c ((x -\\<^sub>c fst\\<^sub>c p) ^\\<^sub>c CInt 2 /\\<^sub>c\n                      (CReal 2 *\\<^sub>c\n                       snd\\<^sub>c p ^\\<^sub>c CInt 2))) /\\<^sub>c\n         sqrt\\<^sub>c\n          (CReal 2 *\\<^sub>c \\<pi>\\<^sub>c *\\<^sub>c\n           snd\\<^sub>c p ^\\<^sub>c CInt 2) ELSE CReal 0)\n                        dst e1 e2 :\n                       REAL", "apply (simp, intro cet_if cet_op_intros cet_val', simp_all add: cet_fst cet_snd)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma val_type_eq_BOOL: \"val_type x = BOOL \\<longleftrightarrow> x \\<in> BoolVal`UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (val_type x = BOOL) = (x \\<in> range BoolVal)", "by (cases x) auto"], ["", "lemma val_type_eq_INTEG: \"val_type x = INTEG \\<longleftrightarrow> x \\<in> IntVal`UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (val_type x = INTEG) = (x \\<in> range IntVal)", "by (cases x) auto"], ["", "lemma val_type_eq_PRODUCT: \"val_type x = PRODUCT t1 t2 \\<longleftrightarrow>\n  (\\<exists>a b. val_type a = t1 \\<and> val_type b = t2 \\<and> x = <| a, b |>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (val_type x = PRODUCT t1 t2) =\n    (\\<exists>a b.\n        val_type a = t1 \\<and> val_type b = t2 \\<and> x = <|a, b|>)", "by (cases x) auto"], ["", "lemma cexpr_sem_dist_dens_cexpr_nonneg:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst\"\n  assumes \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  assumes \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\"\n  shows \"ennreal (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n           dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2) \\<and>\n           0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n    dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2) \\<and>\n    0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n    dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2) \\<and>\n    0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))", "from val_type_cexpr_sem[OF assms(1,3,5)] and val_type_cexpr_sem[OF assms(2,4,5)]"], ["proof (chain)\npicking this:\n  val_type (cexpr_sem \\<sigma> e1) = dist_param_type dst\n  val_type (cexpr_sem \\<sigma> e2) = dist_result_type dst", "have \"cexpr_sem \\<sigma> e1 \\<in> space (stock_measure (dist_param_type dst))\" and\n         \"cexpr_sem \\<sigma> e2 \\<in> space (stock_measure (dist_result_type dst))\""], ["proof (prove)\nusing this:\n  val_type (cexpr_sem \\<sigma> e1) = dist_param_type dst\n  val_type (cexpr_sem \\<sigma> e2) = dist_result_type dst\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> e1\n    \\<in> space (stock_measure (dist_param_type dst)) &&&\n    cexpr_sem \\<sigma> e2 \\<in> space (stock_measure (dist_result_type dst))", "by (auto simp: type_universe_def simp del: type_universe_type)"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> e1 \\<in> space (stock_measure (dist_param_type dst))\n  cexpr_sem \\<sigma> e2 \\<in> space (stock_measure (dist_result_type dst))\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n    dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2) \\<and>\n    0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  cexpr_sem \\<sigma> e1 \\<in> space (stock_measure (dist_param_type dst))\n  cexpr_sem \\<sigma> e2 \\<in> space (stock_measure (dist_result_type dst))\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n    dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2) \\<and>\n    0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))", "by (subst dist_dens_cexpr_def, cases dst)\n       (auto simp:\n            lift_Comp_def lift_RealVal_def lift_RealIntVal_def lift_RealIntVal2_def\n            bernoulli_density_def val_type_eq_REAL val_type_eq_BOOL val_type_eq_PRODUCT val_type_eq_INTEG\n            uniform_int_density_def uniform_real_density_def\n            lift_IntVal_def poisson_density'_def one_ennreal_def\n            field_simps gaussian_density_def)"], ["proof (state)\nthis:\n  ennreal (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n  dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2) \\<and>\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cexpr_sem_dist_dens_cexpr:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst\"\n  assumes \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  assumes \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\"\n  shows \"ennreal (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n           dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n    dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2)", "using cexpr_sem_dist_dens_cexpr_nonneg[OF assms]"], ["proof (prove)\nusing this:\n  ennreal (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n  dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2) \\<and>\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n    dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2)", "by simp"], ["", "lemma nonneg_dist_dens_cexpr:\n  assumes \"\\<Gamma> \\<turnstile>\\<^sub>c e1 : dist_param_type dst\" \"\\<Gamma> \\<turnstile>\\<^sub>c e2 : dist_result_type dst\"\n  assumes \"free_vars e1 \\<subseteq> V\" \"free_vars e2 \\<subseteq> V\"\n  shows \"nonneg_cexpr V \\<Gamma> (dist_dens_cexpr dst e1 e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonneg_cexpr V \\<Gamma> (dist_dens_cexpr dst e1 e2)", "proof (intro nonneg_cexprI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))", "assume \\<rho>: \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow>\n       0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))", "from cexpr_sem_dist_dens_cexpr_nonneg[OF assms this]"], ["proof (chain)\npicking this:\n  ennreal (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n  dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2) \\<and>\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))", "show \"0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))\""], ["proof (prove)\nusing this:\n  ennreal (extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))) =\n  dist_dens dst (cexpr_sem \\<sigma> e1) (cexpr_sem \\<sigma> e2) \\<and>\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))", "by simp"], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem \\<sigma> (dist_dens_cexpr dst e1 e2))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Integral expressions\\<close>"], ["", "definition integrate_var :: \"tyenv \\<Rightarrow> vname \\<Rightarrow> cexpr \\<Rightarrow> cexpr\" where\n  \"integrate_var \\<Gamma> v e = \\<integral>\\<^sub>c map_vars (\\<lambda>w. if v = w then 0 else Suc w) e \\<partial>(\\<Gamma> v)\""], ["", "definition integrate_vars :: \"tyenv \\<Rightarrow> vname list \\<Rightarrow> cexpr \\<Rightarrow> cexpr\" where\n  \"integrate_vars \\<Gamma> = foldr (integrate_var \\<Gamma>)\""], ["", "lemma cexpr_sem_integrate_var:\n  \"cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n    RealVal (\\<integral>x. extract_real (cexpr_sem (\\<sigma>(v := x)) e) \\<partial>stock_measure (\\<Gamma> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n    RealVal\n     (LINT x|stock_measure (\\<Gamma> v).\n         extract_real (cexpr_sem (\\<sigma>(v := x)) e))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n    RealVal\n     (LINT x|stock_measure (\\<Gamma> v).\n         extract_real (cexpr_sem (\\<sigma>(v := x)) e))", "let ?f = \"(\\<lambda>w. if v = w then 0 else Suc w)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n    RealVal\n     (LINT x|stock_measure (\\<Gamma> v).\n         extract_real (cexpr_sem (\\<sigma>(v := x)) e))", "have \"cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n          RealVal (\\<integral>x. extract_real (cexpr_sem (case_nat x \\<sigma> \\<circ> ?f) e) \\<partial>stock_measure (\\<Gamma> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n    RealVal\n     (LINT x|stock_measure (\\<Gamma> v).\n         extract_real\n          (cexpr_sem\n            (case_nat x \\<sigma> \\<circ>\n             (\\<lambda>w. if v = w then 0 else Suc w))\n            e))", "by (simp add: extract_real_def integrate_var_def cexpr_sem_map_vars)"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n  RealVal\n   (LINT x|stock_measure (\\<Gamma> v).\n       extract_real\n        (cexpr_sem\n          (case_nat x \\<sigma> \\<circ>\n           (\\<lambda>w. if v = w then 0 else Suc w))\n          e))\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n    RealVal\n     (LINT x|stock_measure (\\<Gamma> v).\n         extract_real (cexpr_sem (\\<sigma>(v := x)) e))", "also"], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n  RealVal\n   (LINT x|stock_measure (\\<Gamma> v).\n       extract_real\n        (cexpr_sem\n          (case_nat x \\<sigma> \\<circ>\n           (\\<lambda>w. if v = w then 0 else Suc w))\n          e))\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n    RealVal\n     (LINT x|stock_measure (\\<Gamma> v).\n         extract_real (cexpr_sem (\\<sigma>(v := x)) e))", "have \"(\\<lambda>x. case_nat x \\<sigma> \\<circ> ?f) = (\\<lambda>x. \\<sigma>(v := x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case_nat x \\<sigma> \\<circ>\n        (\\<lambda>w. if v = w then 0 else Suc w)) =\n    fun_upd \\<sigma> v", "by (intro ext) (simp add: o_def split: if_split)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      case_nat x \\<sigma> \\<circ>\n      (\\<lambda>w. if v = w then 0 else Suc w)) =\n  fun_upd \\<sigma> v\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n    RealVal\n     (LINT x|stock_measure (\\<Gamma> v).\n         extract_real (cexpr_sem (\\<sigma>(v := x)) e))", "finally"], ["proof (chain)\npicking this:\n  cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n  RealVal\n   (LINT x|stock_measure (\\<Gamma> v).\n       extract_real (cexpr_sem (\\<sigma>(v := x)) e))", "show ?thesis"], ["proof (prove)\nusing this:\n  cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n  RealVal\n   (LINT x|stock_measure (\\<Gamma> v).\n       extract_real (cexpr_sem (\\<sigma>(v := x)) e))\n\ngoal (1 subgoal):\n 1. cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n    RealVal\n     (LINT x|stock_measure (\\<Gamma> v).\n         extract_real (cexpr_sem (\\<sigma>(v := x)) e))", "."], ["proof (state)\nthis:\n  cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e) =\n  RealVal\n   (LINT x|stock_measure (\\<Gamma> v).\n       extract_real (cexpr_sem (\\<sigma>(v := x)) e))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cexpr_sem_integrate_var':\n  \"extract_real (cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e)) =\n      (\\<integral>x. extract_real (cexpr_sem (\\<sigma>(v := x)) e) \\<partial>stock_measure (\\<Gamma> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (integrate_var \\<Gamma> v e)) =\n    LINT x|stock_measure (\\<Gamma> v).\n       extract_real (cexpr_sem (\\<sigma>(v := x)) e)", "by (subst cexpr_sem_integrate_var, simp add: extract_real_def)"], ["", "lemma cexpr_typing_integrate_var[simp]:\n    \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c integrate_var \\<Gamma> v e : REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c integrate_var \\<Gamma> v e : REAL", "unfolding integrate_var_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c\n     \\<integral>\\<^sub>c map_vars (\\<lambda>w. if v = w then 0 else Suc w)\n                          e \\<partial>\\<Gamma> v :\n     REAL", "by (rule cexpr_typing.intros, rule cexpr_typing_map_vars)\n     (erule cexpr_typing_cong', simp split: nat.split)"], ["", "lemma cexpr_typing_integrate_vars[simp]:\n    \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c integrate_vars \\<Gamma> vs e : REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow>\n    \\<Gamma> \\<turnstile>\\<^sub>c integrate_vars \\<Gamma> vs e : REAL", "by (induction vs arbitrary: e)\n     (simp_all add: integrate_vars_def)"], ["", "lemma free_vars_integrate_var[simp]:\n    \"free_vars (integrate_var \\<Gamma> v e) = free_vars e - {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (integrate_var \\<Gamma> v e) = free_vars e - {v}", "by (auto simp: integrate_var_def)"], ["", "lemma free_vars_integrate_vars[simp]:\n    \"free_vars (integrate_vars \\<Gamma> vs e) = free_vars e - set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_vars (integrate_vars \\<Gamma> vs e) = free_vars e - set vs", "by (induction vs arbitrary: e) (auto simp: integrate_vars_def)"], ["", "lemma (in product_sigma_finite) product_integral_insert':\n  fixes f :: \"_ \\<Rightarrow> real\"\n  assumes \"finite I\" \"i \\<notin> I\" \"integrable (Pi\\<^sub>M (insert i I) M) f\"\n  shows \"integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f = LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n    LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n    LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "interpret pair_sigma_finite \"M i\" \"Pi\\<^sub>M I M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_sigma_finite (M i) (Pi\\<^sub>M I M)", "by (simp_all add: sigma_finite assms pair_sigma_finite_def sigma_finite_measures)"], ["proof (state)\ngoal (1 subgoal):\n 1. integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n    LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "interpret Mi: sigma_finite_measure \"M i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_finite_measure (M i)", "by (simp add: assms sigma_finite_measures)"], ["proof (state)\ngoal (1 subgoal):\n 1. integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n    LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "from assms(3)"], ["proof (chain)\npicking this:\n  integrable (Pi\\<^sub>M (insert i I) M) f", "have int: \"integrable (M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M) (\\<lambda>(x, y). f (y(i := x)))\""], ["proof (prove)\nusing this:\n  integrable (Pi\\<^sub>M (insert i I) M) f\n\ngoal (1 subgoal):\n 1. integrable (M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M)\n     (\\<lambda>(x, y). f (y(i := x)))", "unfolding real_integrable_def"], ["proof (prove)\nusing this:\n  f \\<in> borel_measurable (Pi\\<^sub>M (insert i I) M) \\<and>\n  \\<integral>\\<^sup>+ x. ennreal (f x)\n                     \\<partial>Pi\\<^sub>M (insert i I) M \\<noteq>\n  \\<infinity> \\<and>\n  \\<integral>\\<^sup>+ x. ennreal (- f x)\n                     \\<partial>Pi\\<^sub>M (insert i I) M \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). f (y(i := x)))\n    \\<in> borel_measurable (M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M) \\<and>\n    \\<integral>\\<^sup>+ x. ennreal\n                            (case x of (x, y) \\<Rightarrow> f (y(i := x)))\n                       \\<partial>M i \\<Otimes>\\<^sub>M\n                                 Pi\\<^sub>M I M \\<noteq>\n    \\<infinity> \\<and>\n    \\<integral>\\<^sup>+ x. ennreal\n                            (- (case x of\n                                (x, y) \\<Rightarrow> f (y(i := x))))\n                       \\<partial>M i \\<Otimes>\\<^sub>M\n                                 Pi\\<^sub>M I M \\<noteq>\n    \\<infinity>", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> borel_measurable (Pi\\<^sub>M (insert i I) M);\n     \\<integral>\\<^sup>+ x. ennreal (f x)\n                        \\<partial>Pi\\<^sub>M (insert i I) M \\<noteq>\n     \\<infinity>;\n     \\<integral>\\<^sup>+ x. ennreal (- f x)\n                        \\<partial>Pi\\<^sub>M (insert i I) M \\<noteq>\n     \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(x, y). f (y(i := x)))\n                      \\<in> borel_measurable\n                             (M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M) \\<and>\n                      \\<integral>\\<^sup>+ x.\n     ennreal (case x of (x, y) \\<Rightarrow> f (y(i := x)))\n   \\<partial>M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M \\<noteq>\n                      \\<infinity> \\<and>\n                      \\<integral>\\<^sup>+ x.\n     ennreal (- (case x of (x, y) \\<Rightarrow> f (y(i := x))))\n   \\<partial>M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M \\<noteq>\n                      \\<infinity>", "apply (subst (1 2) nn_integral_snd[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>f \\<in> borel_measurable (Pi\\<^sub>M (insert i I) M);\n     \\<integral>\\<^sup>+ x. ennreal (f x)\n                        \\<partial>Pi\\<^sub>M (insert i I) M \\<noteq>\n     \\<infinity>;\n     \\<integral>\\<^sup>+ x. ennreal (- f x)\n                        \\<partial>Pi\\<^sub>M (insert i I) M \\<noteq>\n     \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          ennreal\n                           (- (case x of\n                               (x, y) \\<Rightarrow> f (y(i := x)))))\n                      \\<in> borel_measurable\n                             (M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M)\n 2. \\<lbrakk>f \\<in> borel_measurable (Pi\\<^sub>M (insert i I) M);\n     \\<integral>\\<^sup>+ x. ennreal (f x)\n                        \\<partial>Pi\\<^sub>M (insert i I) M \\<noteq>\n     \\<infinity>;\n     \\<integral>\\<^sup>+ x. ennreal (- f x)\n                        \\<partial>Pi\\<^sub>M (insert i I) M \\<noteq>\n     \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          ennreal\n                           (case x of (x, y) \\<Rightarrow> f (y(i := x))))\n                      \\<in> borel_measurable\n                             (M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M)\n 3. \\<lbrakk>f \\<in> borel_measurable (Pi\\<^sub>M (insert i I) M);\n     \\<integral>\\<^sup>+ x. ennreal (f x)\n                        \\<partial>Pi\\<^sub>M (insert i I) M \\<noteq>\n     \\<infinity>;\n     \\<integral>\\<^sup>+ x. ennreal (- f x)\n                        \\<partial>Pi\\<^sub>M (insert i I) M \\<noteq>\n     \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(x, y). f (y(i := x)))\n                      \\<in> borel_measurable\n                             (M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M) \\<and>\n                      \\<integral>\\<^sup>+ y.\n     \\<integral>\\<^sup>+ x. ennreal\n                             (case (x, y) of\n                              (x, y) \\<Rightarrow> f (y(i := x)))\n                        \\<partial>M i\n   \\<partial>Pi\\<^sub>M I M \\<noteq>\n                      \\<infinity> \\<and>\n                      \\<integral>\\<^sup>+ y.\n     \\<integral>\\<^sup>+ x. ennreal\n                             (- (case (x, y) of\n                                 (x, y) \\<Rightarrow> f (y(i := x))))\n                        \\<partial>M i\n   \\<partial>Pi\\<^sub>M I M \\<noteq>\n                      \\<infinity>", "apply ((subst (asm) (1 2) product_nn_integral_insert[OF assms(1,2)],\n           auto intro!: measurable_compose[OF _ measurable_ennreal] borel_measurable_uminus) [])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  integrable (M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M)\n   (\\<lambda>(x, y). f (y(i := x)))\n\ngoal (1 subgoal):\n 1. integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n    LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "from assms"], ["proof (chain)\npicking this:\n  finite I\n  i \\<notin> I\n  integrable (Pi\\<^sub>M (insert i I) M) f", "have \"integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f = LINT x|Pi\\<^sub>M I M. LINT y|M i. f (x(i := y))\""], ["proof (prove)\nusing this:\n  finite I\n  i \\<notin> I\n  integrable (Pi\\<^sub>M (insert i I) M) f\n\ngoal (1 subgoal):\n 1. integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n    LINT x|Pi\\<^sub>M I M. LINT y|M i. f (x(i := y))", "by (rule product_integral_insert)"], ["proof (state)\nthis:\n  integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n  LINT x|Pi\\<^sub>M I M. LINT y|M i. f (x(i := y))\n\ngoal (1 subgoal):\n 1. integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n    LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "also"], ["proof (state)\nthis:\n  integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n  LINT x|Pi\\<^sub>M I M. LINT y|M i. f (x(i := y))\n\ngoal (1 subgoal):\n 1. integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n    LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "from int"], ["proof (chain)\npicking this:\n  integrable (M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M)\n   (\\<lambda>(x, y). f (y(i := x)))", "have \"... = LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))\""], ["proof (prove)\nusing this:\n  integrable (M i \\<Otimes>\\<^sub>M Pi\\<^sub>M I M)\n   (\\<lambda>(x, y). f (y(i := x)))\n\ngoal (1 subgoal):\n 1. LINT x|Pi\\<^sub>M I M. LINT y|M i. f (x(i := y)) =\n    LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "by (rule Fubini_integral)"], ["proof (state)\nthis:\n  LINT x|Pi\\<^sub>M I M. LINT y|M i. f (x(i := y)) =\n  LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))\n\ngoal (1 subgoal):\n 1. integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n    LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "finally"], ["proof (chain)\npicking this:\n  integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n  LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "show ?thesis"], ["proof (prove)\nusing this:\n  integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n  LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))\n\ngoal (1 subgoal):\n 1. integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n    LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))", "."], ["proof (state)\nthis:\n  integral\\<^sup>L (Pi\\<^sub>M (insert i I) M) f =\n  LINT y|M i. LINT x|Pi\\<^sub>M I M. f (x(i := y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cexpr_sem_integrate_vars:\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  assumes disjoint: \"distinct vs\" \"set vs \\<inter> V' = {}\"\n  assumes \"integrable (state_measure (set vs) \\<Gamma>)\n               (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e))\"\n  assumes e: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" \"free_vars e \\<subseteq> set vs \\<union> V'\"\n  shows \"extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n           \\<integral>\\<sigma>. extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure (set vs) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n    LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n       extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e)", "using assms"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct vs\n  set vs \\<inter> V' = {}\n  integrable (state_measure (set vs) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set vs \\<union> V'\n\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n    LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n       extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e)", "proof (induction vs arbitrary: \\<rho> V')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<rho> V'.\n       \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct [];\n        set [] \\<inter> V' = {};\n        integrable (state_measure (set []) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set []) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set [] \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> [] e)) =\n                         LINT \\<sigma>|state_measure (set []) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set []) V' (\\<sigma>, \\<rho>)) e)\n 2. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "case Nil"], ["proof (state)\nthis:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct []\n  set [] \\<inter> V' = {}\n  integrable (state_measure (set []) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real (cexpr_sem (merge (set []) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set [] \\<union> V'\n\ngoal (2 subgoals):\n 1. \\<And>\\<rho> V'.\n       \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct [];\n        set [] \\<inter> V' = {};\n        integrable (state_measure (set []) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set []) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set [] \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> [] e)) =\n                         LINT \\<sigma>|state_measure (set []) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set []) V' (\\<sigma>, \\<rho>)) e)\n 2. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "hence \"\\<And>v. (if v \\<in> V' then \\<rho> v else undefined) = \\<rho> v\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct []\n  set [] \\<inter> V' = {}\n  integrable (state_measure (set []) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real (cexpr_sem (merge (set []) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set [] \\<union> V'\n\ngoal (1 subgoal):\n 1. \\<And>v. (if v \\<in> V' then \\<rho> v else undefined) = \\<rho> v", "by (auto simp: state_measure_def space_PiM)"], ["proof (state)\nthis:\n  (if ?v \\<in> V' then \\<rho> ?v else undefined) = \\<rho> ?v\n\ngoal (2 subgoals):\n 1. \\<And>\\<rho> V'.\n       \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct [];\n        set [] \\<inter> V' = {};\n        integrable (state_measure (set []) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set []) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set [] \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> [] e)) =\n                         LINT \\<sigma>|state_measure (set []) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set []) V' (\\<sigma>, \\<rho>)) e)\n 2. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "thus ?case"], ["proof (prove)\nusing this:\n  (if ?v \\<in> V' then \\<rho> ?v else undefined) = \\<rho> ?v\n\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> [] e)) =\n    LINT \\<sigma>|state_measure (set []) \\<Gamma>.\n       extract_real (cexpr_sem (merge (set []) V' (\\<sigma>, \\<rho>)) e)", "by (auto simp: integrate_vars_def state_measure_def merge_def PiM_empty)"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> [] e)) =\n  LINT \\<sigma>|state_measure (set []) \\<Gamma>.\n     extract_real (cexpr_sem (merge (set []) V' (\\<sigma>, \\<rho>)) e)\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "case (Cons v vs \\<rho> V')"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<rho> \\<in> space (state_measure ?V' \\<Gamma>); distinct vs;\n   set vs \\<inter> ?V' = {};\n   integrable (state_measure (set vs) \\<Gamma>)\n    (\\<lambda>\\<sigma>.\n        extract_real\n         (cexpr_sem (merge (set vs) ?V' (\\<sigma>, ?\\<rho>)) e));\n   \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n   free_vars e \\<subseteq> set vs \\<union> ?V'\\<rbrakk>\n  \\<Longrightarrow> extract_real\n                     (cexpr_sem ?\\<rho> (integrate_vars \\<Gamma> vs e)) =\n                    LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                       extract_real\n                        (cexpr_sem (merge (set vs) ?V' (\\<sigma>, ?\\<rho>))\n                          e)\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct (v # vs)\n  set (v # vs) \\<inter> V' = {}\n  integrable (state_measure (set (v # vs)) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set (v # vs) \\<union> V'\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "interpret product_sigma_finite \"\\<lambda>v. stock_measure (\\<Gamma> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. product_sigma_finite (\\<lambda>v. stock_measure (\\<Gamma> v))", "by (simp add: product_sigma_finite_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "interpret sigma_finite_measure \"state_measure (set vs) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_finite_measure (state_measure (set vs) \\<Gamma>)", "by (simp add: sigma_finite_state_measure)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "have \\<rho>': \"\\<And>x. x \\<in> type_universe (\\<Gamma> v) \\<Longrightarrow> \\<rho>(v := x) \\<in> space (state_measure (insert v V') \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> type_universe (\\<Gamma> v) \\<Longrightarrow>\n       \\<rho>(v := x) \\<in> space (state_measure (insert v V') \\<Gamma>)", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> type_universe (\\<Gamma> v) \\<Longrightarrow>\n       \\<rho>(v := x) \\<in> space (state_measure (insert v V') \\<Gamma>)", "by (auto simp: state_measure_def space_PiM split: if_split_asm)"], ["proof (state)\nthis:\n  ?x \\<in> type_universe (\\<Gamma> v) \\<Longrightarrow>\n  \\<rho>(v := ?x) \\<in> space (state_measure (insert v V') \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "have \"extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n          \\<integral>x. extract_real (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) \\<partial>stock_measure (\\<Gamma> v)\"\n    (is \"_ = ?I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n    LINT x|stock_measure (\\<Gamma> v).\n       extract_real\n        (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e))", "by (simp add: integrate_vars_def cexpr_sem_integrate_var extract_real_def)"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n  LINT x|stock_measure (\\<Gamma> v).\n     extract_real\n      (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e))\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "also"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n  LINT x|stock_measure (\\<Gamma> v).\n     extract_real\n      (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e))\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "from Cons.prems(4)"], ["proof (chain)\npicking this:\n  integrable (state_measure (set (v # vs)) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e))", "have int: \"integrable (state_measure (insert v (set vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge (insert v (set vs)) V' (\\<sigma>, \\<rho>)) e))\""], ["proof (prove)\nusing this:\n  integrable (state_measure (set (v # vs)) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e))\n\ngoal (1 subgoal):\n 1. integrable (state_measure (insert v (set vs)) \\<Gamma>)\n     (\\<lambda>\\<sigma>.\n         extract_real\n          (cexpr_sem (merge (insert v (set vs)) V' (\\<sigma>, \\<rho>)) e))", "by simp"], ["proof (state)\nthis:\n  integrable (state_measure (insert v (set vs)) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (insert v (set vs)) V' (\\<sigma>, \\<rho>)) e))\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "have \"AE x in stock_measure (\\<Gamma> v).\n                extract_real (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n                  \\<integral>\\<sigma>. extract_real (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)\n                      \\<partial>state_measure (set vs) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             (\\<Gamma>\n               v). extract_real\n                    (cexpr_sem (\\<rho>(v := x))\n                      (integrate_vars \\<Gamma> vs e)) =\n                   LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                      extract_real\n                       (cexpr_sem\n                         (merge (set vs) (insert v V')\n                           (\\<sigma>, \\<rho>(v := x)))\n                         e)", "apply (rule AE_mp[OF _ AE_I2[OF impI]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. almost_everywhere (stock_measure (\\<Gamma> v)) ?P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure (\\<Gamma> v)); ?P x\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem (\\<rho>(v := x))\n                            (integrate_vars \\<Gamma> vs e)) =\n                         LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set vs) (insert v V')\n                                 (\\<sigma>, \\<rho>(v := x)))\n                               e)", "apply (rule integrable_cexpr_projection[OF _ _ _ _ _ _ _ int])"], ["proof (prove)\ngoal (8 subgoals):\n 1. finite (set vs)\n 2. set vs \\<inter> V' = {}\n 3. v \\<notin> set vs\n 4. v \\<notin> V'\n 5. \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n 6. \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n 7. free_vars e \\<subseteq> insert v (set vs) \\<union> V'\n 8. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure (\\<Gamma> v));\n        integrable (state_measure (set vs) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem\n                (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x)))\n                e))\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem (\\<rho>(v := x))\n                            (integrate_vars \\<Gamma> vs e)) =\n                         LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set vs) (insert v V')\n                                 (\\<sigma>, \\<rho>(v := x)))\n                               e)", "apply (insert Cons.prems, auto) [7]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure (\\<Gamma> v));\n        integrable (state_measure (set vs) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem\n                (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x)))\n                e))\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem (\\<rho>(v := x))\n                            (integrate_vars \\<Gamma> vs e)) =\n                         LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set vs) (insert v V')\n                                 (\\<sigma>, \\<rho>(v := x)))\n                               e)", "apply (subst Cons.IH, rule \\<rho>', insert Cons.prems, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). extract_real\n                  (cexpr_sem (\\<rho>(v := x))\n                    (integrate_vars \\<Gamma> vs e)) =\n                 LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                    extract_real\n                     (cexpr_sem\n                       (merge (set vs) (insert v V')\n                         (\\<sigma>, \\<rho>(v := x)))\n                       e)\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "hence \"?I = \\<integral>x. \\<integral>\\<sigma>. extract_real (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)\n                  \\<partial>state_measure (set vs) \\<Gamma> \\<partial>stock_measure (\\<Gamma> v)\""], ["proof (prove)\nusing this:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). extract_real\n                  (cexpr_sem (\\<rho>(v := x))\n                    (integrate_vars \\<Gamma> vs e)) =\n                 LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                    extract_real\n                     (cexpr_sem\n                       (merge (set vs) (insert v V')\n                         (\\<sigma>, \\<rho>(v := x)))\n                       e)\n\ngoal (1 subgoal):\n 1. LINT x|stock_measure (\\<Gamma> v).\n       extract_real\n        (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n    LINT x|stock_measure (\\<Gamma> v).\n       LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n          extract_real\n           (cexpr_sem\n             (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "using Cons.prems"], ["proof (prove)\nusing this:\n  AE x in stock_measure\n           (\\<Gamma>\n             v). extract_real\n                  (cexpr_sem (\\<rho>(v := x))\n                    (integrate_vars \\<Gamma> vs e)) =\n                 LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                    extract_real\n                     (cexpr_sem\n                       (merge (set vs) (insert v V')\n                         (\\<sigma>, \\<rho>(v := x)))\n                       e)\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct (v # vs)\n  set (v # vs) \\<inter> V' = {}\n  integrable (state_measure (set (v # vs)) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set (v # vs) \\<union> V'\n\ngoal (1 subgoal):\n 1. LINT x|stock_measure (\\<Gamma> v).\n       extract_real\n        (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n    LINT x|stock_measure (\\<Gamma> v).\n       LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n          extract_real\n           (cexpr_sem\n             (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "apply (intro integral_cong_AE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          extract_real\n                           (cexpr_sem (\\<rho>(v := x))\n                             (integrate_vars \\<Gamma> vs e)))\n                      \\<in> borel_measurable (stock_measure (\\<Gamma> v))\n 2. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                             extract_real\n                              (cexpr_sem\n                                (merge (set vs) (insert v V')\n                                  (\\<sigma>, \\<rho>(v := x)))\n                                e))\n                      \\<in> borel_measurable (stock_measure (\\<Gamma> v))\n 3. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> AE x in stock_measure\n                               (\\<Gamma>\n                                 v). extract_real\n(cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real\n   (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "apply (rule measurable_compose[OF measurable_Pair_compose_split[OF\n                measurable_fun_upd_state_measure[of v V' \\<Gamma>]]])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> v \\<notin> V'\n 2. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>a. a)\n                      \\<in> stock_measure (\\<Gamma> v) \\<rightarrow>\\<^sub>M\n                            stock_measure (\\<Gamma> v)\n 3. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>a. \\<rho>)\n                      \\<in> stock_measure (\\<Gamma> v) \\<rightarrow>\\<^sub>M\n                            state_measure V' \\<Gamma>\n 4. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>a.\n                          extract_real\n                           (cexpr_sem a (integrate_vars \\<Gamma> vs e)))\n                      \\<in> borel_measurable\n                             (state_measure (insert v V') \\<Gamma>)\n 5. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                             extract_real\n                              (cexpr_sem\n                                (merge (set vs) (insert v V')\n                                  (\\<sigma>, \\<rho>(v := x)))\n                                e))\n                      \\<in> borel_measurable (stock_measure (\\<Gamma> v))\n 6. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> AE x in stock_measure\n                               (\\<Gamma>\n                                 v). extract_real\n(cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real\n   (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "apply (simp, simp, simp, rule measurable_compose[OF _ measurable_extract_real])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          cexpr_sem x (integrate_vars \\<Gamma> vs e))\n                      \\<in> state_measure (insert v V')\n                             \\<Gamma> \\<rightarrow>\\<^sub>M\n                            stock_measure REAL\n 2. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                             extract_real\n                              (cexpr_sem\n                                (merge (set vs) (insert v V')\n                                  (\\<sigma>, \\<rho>(v := x)))\n                                e))\n                      \\<in> borel_measurable (stock_measure (\\<Gamma> v))\n 3. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> AE x in stock_measure\n                               (\\<Gamma>\n                                 v). extract_real\n(cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real\n   (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "apply (rule measurable_cexpr_sem, simp, (auto) [])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                             extract_real\n                              (cexpr_sem\n                                (merge (set vs) (insert v V')\n                                  (\\<sigma>, \\<rho>(v := x)))\n                                e))\n                      \\<in> borel_measurable (stock_measure (\\<Gamma> v))\n 2. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> AE x in stock_measure\n                               (\\<Gamma>\n                                 v). extract_real\n(cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real\n   (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "apply (rule borel_measurable_lebesgue_integral)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(x, y).\n                          extract_real\n                           (cexpr_sem\n                             (merge (set vs) (insert v V')\n                               (y, \\<rho>(v := x)))\n                             e))\n                      \\<in> borel_measurable\n                             (stock_measure (\\<Gamma> v) \\<Otimes>\\<^sub>M\n                              state_measure (set vs) \\<Gamma>)\n 2. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> AE x in stock_measure\n                               (\\<Gamma>\n                                 v). extract_real\n(cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real\n   (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "apply (subst measurable_split_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          extract_real\n                           (cexpr_sem\n                             (merge (set vs) (insert v V')\n                               (snd x, \\<rho>(v := fst x)))\n                             e))\n                      \\<in> borel_measurable\n                             (stock_measure (\\<Gamma> v) \\<Otimes>\\<^sub>M\n                              state_measure (set vs) \\<Gamma>)\n 2. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> AE x in stock_measure\n                               (\\<Gamma>\n                                 v). extract_real\n(cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real\n   (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "apply (rule measurable_compose[OF _ measurable_extract_real])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          cexpr_sem\n                           (merge (set vs) (insert v V')\n                             (snd x, \\<rho>(v := fst x)))\n                           e)\n                      \\<in> stock_measure (\\<Gamma> v) \\<Otimes>\\<^sub>M\n                            state_measure (set vs)\n                             \\<Gamma> \\<rightarrow>\\<^sub>M\n                            stock_measure REAL\n 2. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> AE x in stock_measure\n                               (\\<Gamma>\n                                 v). extract_real\n(cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real\n   (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "apply (rule measurable_compose[OF _ measurable_cexpr_sem[of \\<Gamma> _ _  \"set vs \\<union> insert v V'\"]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x.\n                          merge (set vs) (insert v V')\n                           (snd x, \\<rho>(v := fst x)))\n                      \\<in> stock_measure (\\<Gamma> v) \\<Otimes>\\<^sub>M\n                            state_measure (set vs)\n                             \\<Gamma> \\<rightarrow>\\<^sub>M\n                            state_measure (set vs \\<union> insert v V')\n                             \\<Gamma>\n 2. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n 3. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> free_vars e \\<subseteq> set vs \\<union> insert v V'\n 4. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (v # vs);\n     set (v # vs) \\<inter> V' = {};\n     integrable (state_measure (set (v # vs)) \\<Gamma>)\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> AE x in stock_measure\n                               (\\<Gamma>\n                                 v). extract_real\n(cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real\n   (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "apply (unfold state_measure_def, rule measurable_compose[OF _ measurable_merge])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>\n                               |Pi\\<^sub>M (set vs)\n                                 (\\<lambda>x. stock_measure (\\<Gamma> x)).\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho>\n     \\<in> space (Pi\\<^sub>M V' (\\<lambda>x. stock_measure (\\<Gamma> x)));\n     distinct (v # vs); set (v # vs) \\<inter> V' = {};\n     integrable\n      (Pi\\<^sub>M (set (v # vs)) (\\<lambda>x. stock_measure (\\<Gamma> x)))\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. (snd x, \\<rho>(v := fst x)))\n                      \\<in> stock_measure (\\<Gamma> v) \\<Otimes>\\<^sub>M\n                            Pi\\<^sub>M (set vs)\n                             (\\<lambda>x.\n                                 stock_measure\n                                  (\\<Gamma> x)) \\<rightarrow>\\<^sub>M\n                            Pi\\<^sub>M (set vs)\n                             (\\<lambda>x.\n                                 stock_measure\n                                  (\\<Gamma> x)) \\<Otimes>\\<^sub>M\n                            Pi\\<^sub>M (insert v V')\n                             (\\<lambda>x. stock_measure (\\<Gamma> x))\n 2. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>\n                               |Pi\\<^sub>M (set vs)\n                                 (\\<lambda>x. stock_measure (\\<Gamma> x)).\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho>\n     \\<in> space (Pi\\<^sub>M V' (\\<lambda>x. stock_measure (\\<Gamma> x)));\n     distinct (v # vs); set (v # vs) \\<inter> V' = {};\n     integrable\n      (Pi\\<^sub>M (set (v # vs)) (\\<lambda>x. stock_measure (\\<Gamma> x)))\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n 3. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>\n                               |Pi\\<^sub>M (set vs)\n                                 (\\<lambda>x. stock_measure (\\<Gamma> x)).\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho>\n     \\<in> space (Pi\\<^sub>M V' (\\<lambda>x. stock_measure (\\<Gamma> x)));\n     distinct (v # vs); set (v # vs) \\<inter> V' = {};\n     integrable\n      (Pi\\<^sub>M (set (v # vs)) (\\<lambda>x. stock_measure (\\<Gamma> x)))\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> free_vars e \\<subseteq> set vs \\<union> insert v V'\n 4. \\<lbrakk>AE x in stock_measure\n                      (\\<Gamma>\n                        v). extract_real\n                             (cexpr_sem (\\<rho>(v := x))\n                               (integrate_vars \\<Gamma> vs e)) =\n                            LINT \\<sigma>\n                               |Pi\\<^sub>M (set vs)\n                                 (\\<lambda>x. stock_measure (\\<Gamma> x)).\n                               extract_real\n                                (cexpr_sem\n                                  (merge (set vs) (insert v V')\n                                    (\\<sigma>, \\<rho>(v := x)))\n                                  e);\n     \\<rho>\n     \\<in> space (Pi\\<^sub>M V' (\\<lambda>x. stock_measure (\\<Gamma> x)));\n     distinct (v # vs); set (v # vs) \\<inter> V' = {};\n     integrable\n      (Pi\\<^sub>M (set (v # vs)) (\\<lambda>x. stock_measure (\\<Gamma> x)))\n      (\\<lambda>\\<sigma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e));\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set (v # vs) \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> AE x in stock_measure\n                               (\\<Gamma>\n                                 v). extract_real\n(cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |Pi\\<^sub>M (set vs) (\\<lambda>x. stock_measure (\\<Gamma> x)).\n  extract_real\n   (cexpr_sem (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  LINT x|stock_measure (\\<Gamma> v).\n     extract_real\n      (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n  LINT x|stock_measure (\\<Gamma> v).\n     LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n        extract_real\n         (cexpr_sem\n           (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "also"], ["proof (state)\nthis:\n  LINT x|stock_measure (\\<Gamma> v).\n     extract_real\n      (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) =\n  LINT x|stock_measure (\\<Gamma> v).\n     LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n        extract_real\n         (cexpr_sem\n           (merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) e)\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "have \"(\\<lambda>x \\<sigma>. merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) =\n                 (\\<lambda>x \\<sigma>. merge (set (v#vs)) V' (\\<sigma>(v := x), \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x \\<sigma>.\n        merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) =\n    (\\<lambda>x \\<sigma>.\n        merge (set (v # vs)) V' (\\<sigma>(v := x), \\<rho>))", "using Cons.prems"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct (v # vs)\n  set (v # vs) \\<inter> V' = {}\n  integrable (state_measure (set (v # vs)) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set (v # vs) \\<union> V'\n\ngoal (1 subgoal):\n 1. (\\<lambda>x \\<sigma>.\n        merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) =\n    (\\<lambda>x \\<sigma>.\n        merge (set (v # vs)) V' (\\<sigma>(v := x), \\<rho>))", "by (intro ext) (auto simp: merge_def split: if_split)"], ["proof (state)\nthis:\n  (\\<lambda>x \\<sigma>.\n      merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) =\n  (\\<lambda>x \\<sigma>. merge (set (v # vs)) V' (\\<sigma>(v := x), \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x \\<sigma>.\n      merge (set vs) (insert v V') (\\<sigma>, \\<rho>(v := x))) =\n  (\\<lambda>x \\<sigma>. merge (set (v # vs)) V' (\\<sigma>(v := x), \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "have \"(\\<integral>x. \\<integral>\\<sigma>. extract_real (cexpr_sem (merge (set (v#vs)) V' (\\<sigma>(v := x), \\<rho>)) e)\n                  \\<partial>state_measure (set vs) \\<Gamma> \\<partial>stock_measure (\\<Gamma> v)) =\n               \\<integral>\\<sigma>. extract_real (cexpr_sem (merge (set (v#vs)) V' (\\<sigma>, \\<rho>)) e)\n                  \\<partial>state_measure (set (v#vs)) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|stock_measure (\\<Gamma> v).\n       LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>(v := x), \\<rho>))\n             e) =\n    LINT \\<sigma>|state_measure (set (v # vs)) \\<Gamma>.\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e)", "using Cons.prems"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct (v # vs)\n  set (v # vs) \\<inter> V' = {}\n  integrable (state_measure (set (v # vs)) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set (v # vs) \\<union> V'\n\ngoal (1 subgoal):\n 1. LINT x|stock_measure (\\<Gamma> v).\n       LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>(v := x), \\<rho>))\n             e) =\n    LINT \\<sigma>|state_measure (set (v # vs)) \\<Gamma>.\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e)", "unfolding state_measure_def"], ["proof (prove)\nusing this:\n  \\<rho>\n  \\<in> space (Pi\\<^sub>M V' (\\<lambda>x. stock_measure (\\<Gamma> x)))\n  distinct (v # vs)\n  set (v # vs) \\<inter> V' = {}\n  integrable\n   (Pi\\<^sub>M (set (v # vs)) (\\<lambda>x. stock_measure (\\<Gamma> x)))\n   (\\<lambda>\\<sigma>.\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set (v # vs) \\<union> V'\n\ngoal (1 subgoal):\n 1. LINT x|stock_measure (\\<Gamma> v).\n       LINT \\<sigma>\n          |Pi\\<^sub>M (set vs) (\\<lambda>x. stock_measure (\\<Gamma> x)).\n          extract_real\n           (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>(v := x), \\<rho>))\n             e) =\n    LINT \\<sigma>\n       |Pi\\<^sub>M (set (v # vs)) (\\<lambda>x. stock_measure (\\<Gamma> x)).\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e)", "by (subst (2) set_simps, subst product_integral_insert') simp_all"], ["proof (state)\nthis:\n  LINT x|stock_measure (\\<Gamma> v).\n     LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n        extract_real\n         (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>(v := x), \\<rho>))\n           e) =\n  LINT \\<sigma>|state_measure (set (v # vs)) \\<Gamma>.\n     extract_real (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e)\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    integrable (state_measure (set vs) \\<Gamma>)\n                     (\\<lambda>\\<sigma>.\n                         extract_real\n                          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>))\n                            e));\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> extract_real\n(cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n                                     LINT \\<sigma>\n  |state_measure (set vs) \\<Gamma>.\n  extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e);\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        integrable (state_measure (set (a # vs)) \\<Gamma>)\n         (\\<lambda>\\<sigma>.\n             extract_real\n              (cexpr_sem (merge (set (a # vs)) V' (\\<sigma>, \\<rho>)) e));\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> extract_real\n                          (cexpr_sem \\<rho>\n                            (integrate_vars \\<Gamma> (a # vs) e)) =\n                         LINT \\<sigma>\n                            |state_measure (set (a # vs)) \\<Gamma>.\n                            extract_real\n                             (cexpr_sem\n                               (merge (set (a # vs)) V' (\\<sigma>, \\<rho>))\n                               e)", "finally"], ["proof (chain)\npicking this:\n  extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n  LINT \\<sigma>|state_measure (set (v # vs)) \\<Gamma>.\n     extract_real (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e)", "show ?case"], ["proof (prove)\nusing this:\n  extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n  LINT \\<sigma>|state_measure (set (v # vs)) \\<Gamma>.\n     extract_real (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e)\n\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n    LINT \\<sigma>|state_measure (set (v # vs)) \\<Gamma>.\n       extract_real\n        (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e)", "."], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n  LINT \\<sigma>|state_measure (set (v # vs)) \\<Gamma>.\n     extract_real (cexpr_sem (merge (set (v # vs)) V' (\\<sigma>, \\<rho>)) e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cexpr_sem_integrate_vars':\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  assumes disjoint: \"distinct vs\" \"set vs \\<inter> V' = {}\"\n  assumes nonneg: \"nonneg_cexpr (set vs \\<union> V') \\<Gamma> e\"\n  assumes \"integrable (state_measure (set vs) \\<Gamma>)\n               (\\<lambda>\\<sigma>. extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e))\"\n  assumes e: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" \"free_vars e \\<subseteq> set vs \\<union> V'\"\n  shows \"ennreal (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n           \\<integral>\\<^sup>+\\<sigma>. extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure (set vs) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                       \\<partial>state_measure (set vs) \\<Gamma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                       \\<partial>state_measure (set vs) \\<Gamma>", "from assms"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct vs\n  set vs \\<inter> V' = {}\n  nonneg_cexpr (set vs \\<union> V') \\<Gamma> e\n  integrable (state_measure (set vs) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set vs \\<union> V'", "have \"extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n      \\<integral>\\<sigma>. extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure (set vs) \\<Gamma>\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct vs\n  set vs \\<inter> V' = {}\n  nonneg_cexpr (set vs \\<union> V') \\<Gamma> e\n  integrable (state_measure (set vs) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set vs \\<union> V'\n\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n    LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n       extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e)", "by (intro cexpr_sem_integrate_vars)"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n  LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n     extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e)\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                       \\<partial>state_measure (set vs) \\<Gamma>", "also"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) =\n  LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n     extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e)\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                       \\<partial>state_measure (set vs) \\<Gamma>", "have \"ennreal ... =\n      \\<integral>\\<^sup>+\\<sigma>. extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e) \\<partial>state_measure (set vs) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n         extract_real\n          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e)) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                       \\<partial>state_measure (set vs) \\<Gamma>", "using assms"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct vs\n  set vs \\<inter> V' = {}\n  nonneg_cexpr (set vs \\<union> V') \\<Gamma> e\n  integrable (state_measure (set vs) \\<Gamma>)\n   (\\<lambda>\\<sigma>.\n       extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e))\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set vs \\<union> V'\n\ngoal (1 subgoal):\n 1. ennreal\n     (LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n         extract_real\n          (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e)) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                       \\<partial>state_measure (set vs) \\<Gamma>", "by (intro nn_integral_eq_integral[symmetric] AE_I2)\n       (auto intro!: nonneg_cexprD merge_in_state_measure)"], ["proof (state)\nthis:\n  ennreal\n   (LINT \\<sigma>|state_measure (set vs) \\<Gamma>.\n       extract_real (cexpr_sem (merge (set vs) V' (\\<sigma>, \\<rho>)) e)) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                     \\<partial>state_measure (set vs) \\<Gamma>\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                       \\<partial>state_measure (set vs) \\<Gamma>", "finally"], ["proof (chain)\npicking this:\n  ennreal (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                     \\<partial>state_measure (set vs) \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                     \\<partial>state_measure (set vs) \\<Gamma>\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                       \\<partial>state_measure (set vs) \\<Gamma>", "."], ["proof (state)\nthis:\n  ennreal (extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem (merge (set vs) V' (x, \\<rho>)) e))\n                     \\<partial>state_measure (set vs) \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonneg_cexpr_sem_integrate_vars:\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  assumes disjoint: \"distinct vs\" \"set vs \\<inter> V' = {}\"\n  assumes nonneg: \"nonneg_cexpr (set vs \\<union> V') \\<Gamma> e\"\n  assumes e: \"\\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" \"free_vars e \\<subseteq> set vs \\<union> V'\"\n  shows \"extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))", "using assms"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct vs\n  set vs \\<inter> V' = {}\n  nonneg_cexpr (set vs \\<union> V') \\<Gamma> e\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set vs \\<union> V'\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e))", "proof (induction vs arbitrary: \\<rho> V')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<rho> V'.\n       \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct [];\n        set [] \\<inter> V' = {};\n        nonneg_cexpr (set [] \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set [] \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> [] e))\n 2. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> 0 \\<le> extract_real\n        (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e));\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        nonneg_cexpr (set (a # vs) \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> (a # vs) e))", "case Nil"], ["proof (state)\nthis:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct []\n  set [] \\<inter> V' = {}\n  nonneg_cexpr (set [] \\<union> V') \\<Gamma> e\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set [] \\<union> V'\n\ngoal (2 subgoals):\n 1. \\<And>\\<rho> V'.\n       \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct [];\n        set [] \\<inter> V' = {};\n        nonneg_cexpr (set [] \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set [] \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> [] e))\n 2. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> 0 \\<le> extract_real\n        (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e));\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        nonneg_cexpr (set (a # vs) \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> (a # vs) e))", "hence \"\\<And>v. (if v \\<in> V' then \\<rho> v else undefined) = \\<rho> v\""], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct []\n  set [] \\<inter> V' = {}\n  nonneg_cexpr (set [] \\<union> V') \\<Gamma> e\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set [] \\<union> V'\n\ngoal (1 subgoal):\n 1. \\<And>v. (if v \\<in> V' then \\<rho> v else undefined) = \\<rho> v", "by (auto simp: state_measure_def space_PiM)"], ["proof (state)\nthis:\n  (if ?v \\<in> V' then \\<rho> ?v else undefined) = \\<rho> ?v\n\ngoal (2 subgoals):\n 1. \\<And>\\<rho> V'.\n       \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct [];\n        set [] \\<inter> V' = {};\n        nonneg_cexpr (set [] \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set [] \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> [] e))\n 2. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> 0 \\<le> extract_real\n        (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e));\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        nonneg_cexpr (set (a # vs) \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> (a # vs) e))", "with Nil"], ["proof (chain)\npicking this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct []\n  set [] \\<inter> V' = {}\n  nonneg_cexpr (set [] \\<union> V') \\<Gamma> e\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set [] \\<union> V'\n  (if ?v \\<in> V' then \\<rho> ?v else undefined) = \\<rho> ?v", "show ?case"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct []\n  set [] \\<inter> V' = {}\n  nonneg_cexpr (set [] \\<union> V') \\<Gamma> e\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set [] \\<union> V'\n  (if ?v \\<in> V' then \\<rho> ?v else undefined) = \\<rho> ?v\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> [] e))", "by (auto simp: integrate_vars_def state_measure_def merge_def PiM_empty nonneg_cexprD)"], ["proof (state)\nthis:\n  0 \\<le> extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> [] e))\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> 0 \\<le> extract_real\n        (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e));\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        nonneg_cexpr (set (a # vs) \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> (a # vs) e))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> 0 \\<le> extract_real\n        (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e));\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        nonneg_cexpr (set (a # vs) \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> (a # vs) e))", "case (Cons v vs \\<rho> V')"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<rho> \\<in> space (state_measure ?V' \\<Gamma>); distinct vs;\n   set vs \\<inter> ?V' = {}; nonneg_cexpr (set vs \\<union> ?V') \\<Gamma> e;\n   \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n   free_vars e \\<subseteq> set vs \\<union> ?V'\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> extract_real\n                             (cexpr_sem ?\\<rho>\n                               (integrate_vars \\<Gamma> vs e))\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  distinct (v # vs)\n  set (v # vs) \\<inter> V' = {}\n  nonneg_cexpr (set (v # vs) \\<union> V') \\<Gamma> e\n  \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n  free_vars e \\<subseteq> set (v # vs) \\<union> V'\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> 0 \\<le> extract_real\n        (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e));\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        nonneg_cexpr (set (a # vs) \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> (a # vs) e))", "have \\<rho>': \"\\<And>x. x \\<in> type_universe (\\<Gamma> v) \\<Longrightarrow> \\<rho>(v := x) \\<in> space (state_measure (insert v V') \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> type_universe (\\<Gamma> v) \\<Longrightarrow>\n       \\<rho>(v := x) \\<in> space (state_measure (insert v V') \\<Gamma>)", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> type_universe (\\<Gamma> v) \\<Longrightarrow>\n       \\<rho>(v := x) \\<in> space (state_measure (insert v V') \\<Gamma>)", "by (auto simp: state_measure_def space_PiM split: if_split_asm)"], ["proof (state)\nthis:\n  ?x \\<in> type_universe (\\<Gamma> v) \\<Longrightarrow>\n  \\<rho>(v := ?x) \\<in> space (state_measure (insert v V') \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> 0 \\<le> extract_real\n        (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e));\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        nonneg_cexpr (set (a # vs) \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> (a # vs) e))", "have \"extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n          \\<integral>x. extract_real (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e)) \\<partial>stock_measure (\\<Gamma> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n    LINT x|stock_measure (\\<Gamma> v).\n       extract_real\n        (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e))", "by (simp add: integrate_vars_def cexpr_sem_integrate_var extract_real_def)"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n  LINT x|stock_measure (\\<Gamma> v).\n     extract_real\n      (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e))\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> 0 \\<le> extract_real\n        (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e));\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        nonneg_cexpr (set (a # vs) \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> (a # vs) e))", "also"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) =\n  LINT x|stock_measure (\\<Gamma> v).\n     extract_real\n      (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e))\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> 0 \\<le> extract_real\n        (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e));\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        nonneg_cexpr (set (a # vs) \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> (a # vs) e))", "have \"... \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> LINT x|stock_measure (\\<Gamma> v).\n               extract_real\n                (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e))", "by (rule integral_nonneg_AE, rule AE_I2, subst Cons.IH[OF \\<rho>']) (insert Cons.prems, auto)"], ["proof (state)\nthis:\n  0 \\<le> LINT x|stock_measure (\\<Gamma> v).\n             extract_real\n              (cexpr_sem (\\<rho>(v := x)) (integrate_vars \\<Gamma> vs e))\n\ngoal (1 subgoal):\n 1. \\<And>a vs \\<rho> V'.\n       \\<lbrakk>\\<And>\\<rho> V'.\n                   \\<lbrakk>\\<rho> \\<in> space (state_measure V' \\<Gamma>);\n                    distinct vs; set vs \\<inter> V' = {};\n                    nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n                    \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n                    free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n                   \\<Longrightarrow> 0 \\<le> extract_real\n        (cexpr_sem \\<rho> (integrate_vars \\<Gamma> vs e));\n        \\<rho> \\<in> space (state_measure V' \\<Gamma>); distinct (a # vs);\n        set (a # vs) \\<inter> V' = {};\n        nonneg_cexpr (set (a # vs) \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set (a # vs) \\<union> V'\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<rho>\n                                    (integrate_vars \\<Gamma> (a # vs) e))", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> extract_real\n           (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e))", "show \"extract_real (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> extract_real\n           (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e))\n\ngoal (1 subgoal):\n 1. 0 \\<le> extract_real\n             (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e))", "."], ["proof (state)\nthis:\n  0 \\<le> extract_real\n           (cexpr_sem \\<rho> (integrate_vars \\<Gamma> (v # vs) e))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonneg_cexpr_sem_integrate_vars':\n  \"distinct vs \\<Longrightarrow> set vs \\<inter> V' = {} \\<Longrightarrow> nonneg_cexpr (set vs \\<union> V') \\<Gamma> e \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e : REAL \\<Longrightarrow>\n    free_vars e \\<subseteq> set vs \\<union> V' \\<Longrightarrow> nonneg_cexpr V' \\<Gamma> (integrate_vars \\<Gamma> vs e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; set vs \\<inter> V' = {};\n     nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n     \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n     free_vars e \\<subseteq> set vs \\<union> V'\\<rbrakk>\n    \\<Longrightarrow> nonneg_cexpr V' \\<Gamma>\n                       (integrate_vars \\<Gamma> vs e)", "apply (intro nonneg_cexprI allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>distinct vs; set vs \\<inter> V' = {};\n        nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set vs \\<union> V';\n        \\<sigma> \\<in> space (state_measure V' \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> extract_real\n                                  (cexpr_sem \\<sigma>\n                                    (integrate_vars \\<Gamma> vs e))", "apply (rule nonneg_cexpr_sem_integrate_vars[where V'=V'])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>distinct vs; set vs \\<inter> V' = {};\n        nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set vs \\<union> V';\n        \\<sigma> \\<in> space (state_measure V' \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> space (state_measure V' \\<Gamma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>distinct vs; set vs \\<inter> V' = {};\n        nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set vs \\<union> V';\n        \\<sigma> \\<in> space (state_measure V' \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> distinct vs\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>distinct vs; set vs \\<inter> V' = {};\n        nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set vs \\<union> V';\n        \\<sigma> \\<in> space (state_measure V' \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> set vs \\<inter> V' = {}\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>distinct vs; set vs \\<inter> V' = {};\n        nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set vs \\<union> V';\n        \\<sigma> \\<in> space (state_measure V' \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nonneg_cexpr (set vs \\<union> V') \\<Gamma> e\n 5. \\<And>\\<sigma>.\n       \\<lbrakk>distinct vs; set vs \\<inter> V' = {};\n        nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set vs \\<union> V';\n        \\<sigma> \\<in> space (state_measure V' \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n 6. \\<And>\\<sigma>.\n       \\<lbrakk>distinct vs; set vs \\<inter> V' = {};\n        nonneg_cexpr (set vs \\<union> V') \\<Gamma> e;\n        \\<Gamma> \\<turnstile>\\<^sub>c e : REAL;\n        free_vars e \\<subseteq> set vs \\<union> V';\n        \\<sigma> \\<in> space (state_measure V' \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> free_vars e \\<subseteq> set vs \\<union> V'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cexpr_sem_integral_nonneg:\n  assumes finite: \"(\\<integral>\\<^sup>+x. extract_real (cexpr_sem (case_nat x \\<sigma>) e) \\<partial>stock_measure t) < \\<infinity>\"\n  assumes nonneg: \"nonneg_cexpr (shift_var_set V) (case_nat t \\<Gamma>) e\"\n  assumes t: \"case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\" and vars: \"free_vars e \\<subseteq> shift_var_set V\"\n  assumes \\<rho>: \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\"\n  shows \"ennreal (extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n             \\<integral>\\<^sup>+x. extract_real (cexpr_sem (case_nat x \\<sigma>) e) \\<partial>stock_measure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real\n       (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (case_nat x \\<sigma>) e))\n                       \\<partial>stock_measure t", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real\n       (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (case_nat x \\<sigma>) e))\n                       \\<partial>stock_measure t", "let ?f = \"\\<lambda>x. extract_real (cexpr_sem (case_nat x \\<sigma>) e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real\n       (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (case_nat x \\<sigma>) e))\n                       \\<partial>stock_measure t", "have meas: \"?f \\<in> borel_measurable (stock_measure t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n    \\<in> borel_measurable (stock_measure t)", "apply (rule measurable_compose[OF _ measurable_extract_real])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. cexpr_sem (case_nat x \\<sigma>) e)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M stock_measure REAL", "apply (rule measurable_compose[OF measurable_case_nat' measurable_cexpr_sem])"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<lambda>x. x)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M stock_measure ?t5\n 2. (\\<lambda>x. \\<sigma>)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M state_measure ?V5 ?\\<Gamma>5\n 3. case_nat ?t5 ?\\<Gamma>5 \\<turnstile>\\<^sub>c e : REAL\n 4. free_vars e \\<subseteq> shift_var_set ?V5", "apply (rule measurable_ident_sets[OF refl], rule measurable_const[OF \\<rho>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. case_nat t \\<Gamma> \\<turnstile>\\<^sub>c e : REAL\n 2. free_vars e \\<subseteq> shift_var_set V", "apply (simp_all add: t vars)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>x. extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n  \\<in> borel_measurable (stock_measure t)\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real\n       (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (case_nat x \\<sigma>) e))\n                       \\<partial>stock_measure t", "from this and finite and nonneg"], ["proof (chain)\npicking this:\n  (\\<lambda>x. extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n  \\<in> borel_measurable (stock_measure t)\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n                     \\<partial>stock_measure t\n  < \\<infinity>\n  nonneg_cexpr (shift_var_set V) (case_nat t \\<Gamma>) e", "have int: \"integrable (stock_measure t) ?f\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n  \\<in> borel_measurable (stock_measure t)\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n                     \\<partial>stock_measure t\n  < \\<infinity>\n  nonneg_cexpr (shift_var_set V) (case_nat t \\<Gamma>) e\n\ngoal (1 subgoal):\n 1. integrable (stock_measure t)\n     (\\<lambda>x. extract_real (cexpr_sem (case_nat x \\<sigma>) e))", "by (auto intro!: integrableI_nonneg nonneg_cexprD case_nat_in_state_measure[OF _ \\<rho>])"], ["proof (state)\nthis:\n  integrable (stock_measure t)\n   (\\<lambda>x. extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real\n       (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (case_nat x \\<sigma>) e))\n                       \\<partial>stock_measure t", "have \"extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t)) =\n          \\<integral>x. extract_real (cexpr_sem (case_nat x \\<sigma>) e) \\<partial>stock_measure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t)) =\n    LINT x|stock_measure t. extract_real (cexpr_sem (case_nat x \\<sigma>) e)", "by (simp add: extract_real_def)"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t)) =\n  LINT x|stock_measure t. extract_real (cexpr_sem (case_nat x \\<sigma>) e)\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real\n       (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (case_nat x \\<sigma>) e))\n                       \\<partial>stock_measure t", "also"], ["proof (state)\nthis:\n  extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t)) =\n  LINT x|stock_measure t. extract_real (cexpr_sem (case_nat x \\<sigma>) e)\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real\n       (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (case_nat x \\<sigma>) e))\n                       \\<partial>stock_measure t", "have \"ennreal ... = \\<integral>\\<^sup>+x. extract_real (cexpr_sem (case_nat x \\<sigma>) e) \\<partial>stock_measure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (LINT x|stock_measure t.\n         extract_real (cexpr_sem (case_nat x \\<sigma>) e)) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (case_nat x \\<sigma>) e))\n                       \\<partial>stock_measure t", "by (subst nn_integral_eq_integral[OF int AE_I2])\n       (auto intro!: nonneg_cexprD[OF nonneg] case_nat_in_state_measure[OF _ \\<rho>])"], ["proof (state)\nthis:\n  ennreal\n   (LINT x|stock_measure t.\n       extract_real (cexpr_sem (case_nat x \\<sigma>) e)) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n                     \\<partial>stock_measure t\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real\n       (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (case_nat x \\<sigma>) e))\n                       \\<partial>stock_measure t", "finally"], ["proof (chain)\npicking this:\n  ennreal\n   (extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem\n                              (\\<lambda>a.\n                                  case a of 0 \\<Rightarrow> x\n                                  | Suc a \\<Rightarrow> \\<sigma> a)\n                              e))\n                     \\<partial>stock_measure t", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal\n   (extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real\n                            (cexpr_sem\n                              (\\<lambda>a.\n                                  case a of 0 \\<Rightarrow> x\n                                  | Suc a \\<Rightarrow> \\<sigma> a)\n                              e))\n                     \\<partial>stock_measure t\n\ngoal (1 subgoal):\n 1. ennreal\n     (extract_real\n       (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (extract_real\n                              (cexpr_sem (case_nat x \\<sigma>) e))\n                       \\<partial>stock_measure t", "."], ["proof (state)\nthis:\n  ennreal\n   (extract_real (cexpr_sem \\<sigma> (\\<integral>\\<^sub>c e \\<partial>t))) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (extract_real (cexpr_sem (case_nat x \\<sigma>) e))\n                     \\<partial>stock_measure t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_parametrized_subprob_density_cexpr_sem_integral:\n  assumes dens: \"has_parametrized_subprob_density (state_measure V' \\<Gamma>) M (stock_measure t)\n                   (\\<lambda>\\<rho> x. \\<integral>\\<^sup>+y. eval_cexpr f (case_nat x \\<rho>) y \\<partial>stock_measure t')\"\n  assumes nonneg: \"nonneg_cexpr (shift_var_set (shift_var_set V')) (case_nat t' (case_nat t \\<Gamma>)) f\"\n  assumes tf: \"case_nat t' (case_nat t \\<Gamma>) \\<turnstile>\\<^sub>c f : REAL\"\n  assumes varsf: \"free_vars f \\<subseteq> shift_var_set (shift_var_set V')\"\n  assumes \\<rho>: \"\\<rho> \\<in> space (state_measure V' \\<Gamma>)\"\n  shows \"AE x in stock_measure t.\n          (\\<integral>\\<^sup>+y. eval_cexpr f (case_nat x \\<rho>) y \\<partial>stock_measure t') = ennreal (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t') \\<rho> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             t. \\<integral>\\<^sup>+ xa. ennreal\n   (eval_cexpr f (case_nat x \\<rho>) xa)\n                                   \\<partial>stock_measure t' =\n                ennreal\n                 (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t') \\<rho> x)", "proof (rule AE_mp[OF _ AE_I2[OF impI]])"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere (stock_measure t) ?P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure t); ?P x\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t' =\n                         ennreal\n                          (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t')\n                            \\<rho> x)", "interpret sigma_finite_measure \"stock_measure t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_finite_measure (stock_measure t')", "by simp"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere (stock_measure t) ?P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure t); ?P x\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t' =\n                         ennreal\n                          (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t')\n                            \\<rho> x)", "let ?f = \"\\<lambda>x. \\<integral>\\<^sup>+y. eval_cexpr f (case_nat x \\<rho>) y \\<partial>stock_measure t'\""], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere (stock_measure t) ?P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure t); ?P x\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t' =\n                         ennreal\n                          (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t')\n                            \\<rho> x)", "from has_parametrized_subprob_density_integral[OF dens \\<rho>]"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x.\n        ennreal (eval_cexpr f (case_nat y \\<rho>) x)\n      \\<partial>stock_measure t'\n                     \\<partial>stock_measure t\n  \\<le> 1", "have \"(\\<integral>\\<^sup>+x. ?f x \\<partial>stock_measure t) \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x.\n        ennreal (eval_cexpr f (case_nat y \\<rho>) x)\n      \\<partial>stock_measure t'\n                     \\<partial>stock_measure t\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n          ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n        \\<partial>stock_measure t'\n                       \\<partial>stock_measure t \\<noteq>\n    \\<infinity>", "by (auto simp: eval_cexpr_def top_unique)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t'\n                     \\<partial>stock_measure t \\<noteq>\n  \\<infinity>\n\ngoal (2 subgoals):\n 1. almost_everywhere (stock_measure t) ?P\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure t); ?P x\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t' =\n                         ennreal\n                          (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t')\n                            \\<rho> x)", "thus \"AE x in stock_measure t. ?f x \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t'\n                     \\<partial>stock_measure t \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             t. \\<integral>\\<^sup>+ xa. ennreal\n   (eval_cexpr f (case_nat x \\<rho>) xa)\n                                   \\<partial>stock_measure t' \\<noteq>\n                \\<infinity>", "using \\<rho> tf varsf"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t'\n                     \\<partial>stock_measure t \\<noteq>\n  \\<infinity>\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  case_nat t' (case_nat t \\<Gamma>) \\<turnstile>\\<^sub>c f : REAL\n  free_vars f \\<subseteq> shift_var_set (shift_var_set V')\n\ngoal (1 subgoal):\n 1. AE x in stock_measure\n             t. \\<integral>\\<^sup>+ xa. ennreal\n   (eval_cexpr f (case_nat x \\<rho>) xa)\n                                   \\<partial>stock_measure t' \\<noteq>\n                \\<infinity>", "by (intro nn_integral_PInf_AE) simp_all"], ["proof (state)\nthis:\n  AE x in stock_measure\n           t. \\<integral>\\<^sup>+ xa. ennreal\n (eval_cexpr f (case_nat x \\<rho>) xa)\n                                 \\<partial>stock_measure t' \\<noteq>\n              \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure t);\n        \\<integral>\\<^sup>+ xa. ennreal\n                                 (eval_cexpr f (case_nat x \\<rho>) xa)\n                           \\<partial>stock_measure t' \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t' =\n                         ennreal\n                          (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t')\n                            \\<rho> x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure t);\n        \\<integral>\\<^sup>+ xa. ennreal\n                                 (eval_cexpr f (case_nat x \\<rho>) xa)\n                           \\<partial>stock_measure t' \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t' =\n                         ennreal\n                          (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t')\n                            \\<rho> x)", "assume x: \"x \\<in> space (stock_measure t)\" and finite: \"?f x \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  x \\<in> space (stock_measure t)\n  \\<integral>\\<^sup>+ xa. ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n                     \\<partial>stock_measure t' \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure t);\n        \\<integral>\\<^sup>+ xa. ennreal\n                                 (eval_cexpr f (case_nat x \\<rho>) xa)\n                           \\<partial>stock_measure t' \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t' =\n                         ennreal\n                          (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t')\n                            \\<rho> x)", "have nonneg': \"AE y in stock_measure t'. eval_cexpr f (case_nat x \\<rho>) y \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE y in stock_measure t'. 0 \\<le> eval_cexpr f (case_nat x \\<rho>) y", "unfolding eval_cexpr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE y in stock_measure\n             t'. 0 \\<le> extract_real\n                          (cexpr_sem (case_nat y (case_nat x \\<rho>)) f)", "using \\<rho> x"], ["proof (prove)\nusing this:\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  x \\<in> space (stock_measure t)\n\ngoal (1 subgoal):\n 1. AE y in stock_measure\n             t'. 0 \\<le> extract_real\n                          (cexpr_sem (case_nat y (case_nat x \\<rho>)) f)", "by (intro AE_I2 nonneg_cexprD[OF nonneg]) (auto intro!: case_nat_in_state_measure)"], ["proof (state)\nthis:\n  AE y in stock_measure t'. 0 \\<le> eval_cexpr f (case_nat x \\<rho>) y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure t);\n        \\<integral>\\<^sup>+ xa. ennreal\n                                 (eval_cexpr f (case_nat x \\<rho>) xa)\n                           \\<partial>stock_measure t' \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t' =\n                         ennreal\n                          (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t')\n                            \\<rho> x)", "hence \"integrable (stock_measure t') (\\<lambda>y. eval_cexpr f (case_nat x \\<rho>) y)\""], ["proof (prove)\nusing this:\n  AE y in stock_measure t'. 0 \\<le> eval_cexpr f (case_nat x \\<rho>) y\n\ngoal (1 subgoal):\n 1. integrable (stock_measure t') (eval_cexpr f (case_nat x \\<rho>))", "using x \\<rho> tf varsf finite"], ["proof (prove)\nusing this:\n  AE y in stock_measure t'. 0 \\<le> eval_cexpr f (case_nat x \\<rho>) y\n  x \\<in> space (stock_measure t)\n  \\<rho> \\<in> space (state_measure V' \\<Gamma>)\n  case_nat t' (case_nat t \\<Gamma>) \\<turnstile>\\<^sub>c f : REAL\n  free_vars f \\<subseteq> shift_var_set (shift_var_set V')\n  \\<integral>\\<^sup>+ xa. ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n                     \\<partial>stock_measure t' \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. integrable (stock_measure t') (eval_cexpr f (case_nat x \\<rho>))", "by (intro integrableI_nonneg) (simp_all add: top_unique less_top)"], ["proof (state)\nthis:\n  integrable (stock_measure t') (eval_cexpr f (case_nat x \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (stock_measure t);\n        \\<integral>\\<^sup>+ xa. ennreal\n                                 (eval_cexpr f (case_nat x \\<rho>) xa)\n                           \\<partial>stock_measure t' \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n      \\<partial>stock_measure t' =\n                         ennreal\n                          (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t')\n                            \\<rho> x)", "thus \"?f x = ennreal (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t') \\<rho> x)\""], ["proof (prove)\nusing this:\n  integrable (stock_measure t') (eval_cexpr f (case_nat x \\<rho>))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n                       \\<partial>stock_measure t' =\n    ennreal (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t') \\<rho> x)", "using nonneg'"], ["proof (prove)\nusing this:\n  integrable (stock_measure t') (eval_cexpr f (case_nat x \\<rho>))\n  AE y in stock_measure t'. 0 \\<le> eval_cexpr f (case_nat x \\<rho>) y\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n                       \\<partial>stock_measure t' =\n    ennreal (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t') \\<rho> x)", "by (simp add: extract_real_def nn_integral_eq_integral eval_cexpr_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ xa. ennreal (eval_cexpr f (case_nat x \\<rho>) xa)\n                     \\<partial>stock_measure t' =\n  ennreal (eval_cexpr (\\<integral>\\<^sub>c f \\<partial>t') \\<rho> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}