{"file_name": "/home/qj213/afp-2021-10-22/thys/Density_Compiler/PDF_Values.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Density_Compiler", "problem_names": ["lemma map_int_pair[simp]: \"map_int_pair f g <| IntVal i, IntVal j |> = f i j\"", "lemma map_int_pair_REAL[simp]: \"map_int_pair f g <| RealVal i, RealVal j |> = g <| RealVal i, RealVal j |>\"", "lemma map_real_pair[simp]: \"map_real_pair f g <| RealVal i, RealVal j |> = f i j\"", "lemma inj_RealPairVal: \"inj RealPairVal\"", "lemma inj_IntPairVal: \"inj IntPairVal\"", "lemma val_type_eq_REAL: \"val_type x = REAL \\<longleftrightarrow> x \\<in> RealVal`UNIV\"", "lemma val_type_eq_INTEG: \"val_type x = INTEG \\<longleftrightarrow> x \\<in> IntVal`UNIV\"", "lemma type_universe_nonempty[simp]: \"type_universe t \\<noteq> {}\"", "lemma val_in_type_universe[simp]:\n    \"v \\<in> type_universe (val_type v)\"", "lemma BoolVal_in_type_universe[simp]: \"BoolVal v \\<in> type_universe BOOL\"", "lemma IntVal_in_type_universe[simp]: \"IntVal v \\<in> type_universe INTEG\"", "lemma type_universe_type[simp]:\n    \"w \\<in> type_universe t \\<longleftrightarrow> val_type w = t\"", "lemma type_universe_REAL: \"type_universe REAL = RealVal ` UNIV\"", "lemma type_universe_eq_imp_type_eq:\n  assumes \"type_universe t1 = type_universe t2\"\n  shows \"t1 = t2\"", "lemma type_universe_eq_iff[simp]: \"type_universe t1 = type_universe t2 \\<longleftrightarrow> t1 = t2\"", "lemma sigma_finite_stock_measure[simp]: \"sigma_finite_measure (stock_measure t)\"", "lemma val_case_stock_measurable:\n  assumes \"t = UNIT \\<Longrightarrow> c \\<in> space M\"\n  assumes \"\\<And>b. t = BOOL \\<Longrightarrow> g b \\<in> space M\"\n  assumes \"\\<And>i. t = INTEG \\<Longrightarrow> h i \\<in> space M\"\n  assumes \"t = REAL \\<Longrightarrow> j \\<in> measurable borel M\"\n  assumes *: \"\\<And>t1 t2. t = PRODUCT t1 t2 \\<Longrightarrow> case_prod k \\<in> measurable (stock_measure t1 \\<Otimes>\\<^sub>M stock_measure t2) M\"\n  shows \"(\\<lambda>x. case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n                | PairVal y z \\<Rightarrow> k y z) \\<in> measurable t M\"", "lemma space_stock_measure[simp]: \"space (stock_measure t) = type_universe t\"", "lemma type_universe_stock_measure[measurable]: \"type_universe t \\<in> sets (stock_measure t)\"", "lemma inj_RealVal[simp]: \"inj RealVal\"", "lemma inj_IntVal[simp]: \"inj IntVal\"", "lemma inj_BoolVal[simp]: \"inj BoolVal\"", "lemma inj_PairVal[simp]: \"inj (\\<lambda>(x, y). <| x ,  y |>)\"", "lemma measurable_PairVal[measurable]:\n  fixes t1 t2 :: pdf_type\n  shows \"case_prod PairVal \\<in> measurable (t1 \\<Otimes>\\<^sub>M t2) (PRODUCT t1 t2)\"", "lemma measurable_RealVal[measurable]: \"RealVal \\<in> measurable borel REAL\"", "lemma nn_integral_BoolVal:\n  assumes \"\\<And>x. f (BoolVal x) \\<ge> 0\"\n  shows \"(\\<integral>\\<^sup>+x. f x \\<partial>BOOL) = f (BoolVal True) + f (BoolVal False)\"", "lemma nn_integral_RealVal:\n  \"f \\<in> borel_measurable REAL \\<Longrightarrow> (\\<integral>\\<^sup>+x. f x \\<partial>REAL) = (\\<integral>\\<^sup>+x. f (RealVal x) \\<partial>lborel)\"", "lemma nn_integral_IntVal: \"(\\<integral>\\<^sup>+x. f x \\<partial>INTEG) = (\\<integral>\\<^sup>+x. f (IntVal x) \\<partial>count_space UNIV)\"", "lemma nn_integral_PairVal:\n  \"f \\<in> borel_measurable (PRODUCT t1 t2) \\<Longrightarrow>\n    (\\<integral>\\<^sup>+x. f x \\<partial>PRODUCT t1 t2) = (\\<integral>\\<^sup>+x. f (PairVal (fst x) (snd x)) \\<partial>(t1 \\<Otimes>\\<^sub>M t2))\"", "lemma BOOL_E: \"\\<lbrakk>val_type v = BOOL; \\<And>b. v = BoolVal b \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma PROD_E: \"\\<lbrakk>val_type v = PRODUCT t1 t2 ;\n     \\<And>a b. val_type a = t1 \\<Longrightarrow> val_type b = t2 \\<Longrightarrow> v = <| a, b |> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma REAL_E: \"\\<lbrakk>val_type v = REAL; \\<And>b. v = RealVal b \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma INTEG_E: \"\\<lbrakk>val_type v = INTEG; \\<And>i. v = IntVal i \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma measurable_extract_pair'[measurable (raw)]:\n  fixes t1 t2 :: pdf_type\n  assumes [measurable]: \"f \\<in> measurable t1 M\"\n  assumes [measurable]: \"g \\<in> measurable t2 N\"\n  assumes h: \"h \\<in> measurable K (PRODUCT t1 t2)\"\n  shows \"(\\<lambda>x. extract_pair' f g (h x)) \\<in> measurable K (M \\<Otimes>\\<^sub>M N)\"", "lemma measurable_extract_pair[measurable]: \"extract_pair \\<in> measurable (PRODUCT t1 t2) (t1 \\<Otimes>\\<^sub>M t2)\"", "lemma measurable_extract_real[measurable]: \"extract_real \\<in> measurable REAL borel\"", "lemma measurable_extract_int[measurable]: \"extract_int \\<in> measurable INTEG (count_space UNIV)\"", "lemma measurable_extract_int_pair[measurable]:\n  \"extract_int_pair \\<in> measurable (PRODUCT INTEG INTEG) (count_space UNIV \\<Otimes>\\<^sub>M count_space UNIV)\"", "lemma measurable_extract_real_pair[measurable]:\n  \"extract_real_pair \\<in> measurable (PRODUCT REAL REAL) (borel \\<Otimes>\\<^sub>M borel)\"", "lemma measurable_extract_real_pair'[measurable]:\n  \"extract_real_pair \\<in> measurable (PRODUCT REAL REAL) borel\"", "lemma measurable_extract_bool[measurable]: \"extract_bool \\<in> measurable BOOL (count_space UNIV)\"", "lemma map_int_pair_measurable[measurable]:\n  assumes f: \"case_prod f \\<in> measurable (count_space UNIV \\<Otimes>\\<^sub>M count_space UNIV) M\"\n  shows \"map_int_pair f g \\<in> measurable (PRODUCT INTEG INTEG) M\"", "lemma map_int_pair_measurable_REAL[measurable]:\n  assumes \"g \\<in> measurable (PRODUCT REAL REAL) M\"\n  shows \"map_int_pair f g \\<in> measurable (PRODUCT REAL REAL) M\"", "lemma map_real_pair_measurable[measurable]:\n  assumes f: \"case_prod f \\<in> measurable (borel \\<Otimes>\\<^sub>M borel) M\"\n  shows \"map_real_pair f g \\<in> measurable (PRODUCT REAL REAL) M\"", "lemma count_space_IntVal_prod[simp]: \"INTEG \\<Otimes>\\<^sub>M INTEG = count_space (range IntVal \\<times> range IntVal)\"", "lemma count_space_BoolVal_prod[simp]: \"BOOL \\<Otimes>\\<^sub>M BOOL = count_space (range BoolVal \\<times> range BoolVal)\"", "lemma measurable_stock_measure_val_type:\n  assumes \"f \\<in> measurable M (stock_measure t)\" \"x \\<in> space M\"\n  shows \"val_type (f x) = t\"", "lemma singleton_in_stock_measure[simp]: \"val_type v = t \\<Longrightarrow> {v} \\<in> sets t\"", "lemma emeasure_stock_measure_singleton_finite[simp]:\n    \"emeasure (stock_measure (val_type v)) {v} \\<noteq> \\<infinity>\"", "lemma state_measure_nonempty[simp]: \"space (state_measure V \\<Gamma>) \\<noteq> {}\"", "lemma space_state_measure: \"space (state_measure V \\<Gamma>) = (\\<Pi>\\<^sub>E y\\<in>V. type_universe (\\<Gamma> y))\"", "lemma state_measure_var_type:\n    \"\\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow> x \\<in> V \\<Longrightarrow> val_type (\\<sigma> x) = \\<Gamma> x\"", "lemma merge_in_state_measure:\n  \"x \\<in> space (state_measure A \\<Gamma>) \\<Longrightarrow> y \\<in> space (state_measure B \\<Gamma>) \\<Longrightarrow>\n      merge A B (x, y) \\<in> space (state_measure (A\\<union>B) \\<Gamma>)\"", "lemma measurable_merge_stock[measurable (raw)]:\n  \"f \\<in> N \\<rightarrow>\\<^sub>M state_measure V \\<Gamma> \\<Longrightarrow> g \\<in> N \\<rightarrow>\\<^sub>M state_measure V' \\<Gamma> \\<Longrightarrow>\n    (\\<lambda>x. merge V V' (f x, g x)) \\<in> N \\<rightarrow>\\<^sub>M state_measure (V \\<union> V') \\<Gamma>\"", "lemma comp_in_state_measure:\n    assumes \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\"\n    shows \"\\<sigma> \\<circ> f \\<in> space (state_measure (f -` V) (\\<Gamma> \\<circ> f))\"", "lemma sigma_finite_state_measure[intro]:\n    \"finite V \\<Longrightarrow> sigma_finite_measure (state_measure V \\<Gamma>)\"", "lemma embed_measure_RealPairVal:\n   \"stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal\"", "lemma embed_measure_IntPairVal:\n  \"stock_measure (PRODUCT INTEG INTEG) = count_space (range IntPairVal)\"", "lemma sets_return_val[measurable_cong]: \"sets (return_val x) = sets (stock_measure (val_type x))\"", "lemma measurable_return_val[simp]:\n    \"return_val \\<in> measurable (stock_measure t) (subprob_algebra (stock_measure t))\"", "lemma bind_return_val:\n  assumes \"space M \\<noteq> {}\" \"f \\<in> measurable M (stock_measure t')\"\n  shows \"M \\<bind> (\\<lambda>x. return_val (f x)) = distr M (stock_measure t') f\"", "lemma bind_return_val':\n  assumes \"val_type x = t\" \"f \\<in> measurable (stock_measure t) (stock_measure t')\"\n  shows \"return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)\"", "lemma bind_return_val'':\n  assumes \"f \\<in> measurable (stock_measure (val_type x)) (subprob_algebra M)\"\n  shows \"return_val x \\<bind> f = f x\"", "lemma bind_assoc_return_val:\n  assumes sets_M: \"sets M = sets (stock_measure t)\"\n  assumes Mf: \"f \\<in> measurable (stock_measure t) (stock_measure t')\"\n  assumes Mg: \"g \\<in> measurable (stock_measure t') (stock_measure t'')\"\n  shows \"(M \\<bind> (\\<lambda>x. return_val (f x))) \\<bind> (\\<lambda>x. return_val (g x)) =\n             M \\<bind> (\\<lambda>x. return_val (g (f x)))\"", "lemma bind_return_val_distr:\n  assumes sets_M: \"sets M = sets (stock_measure t)\"\n  assumes Mf: \"f \\<in> measurable (stock_measure t) (stock_measure t')\"\n  shows \"M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f\"", "lemma lift_RealVal_eq: \"lift_RealVal f (RealVal x) = RealVal (f x)\"", "lemma lift_RealIntVal_Real:\n  \"x \\<in> space (stock_measure REAL) \\<Longrightarrow> lift_RealIntVal f g x = lift_RealVal g x\"", "lemma lift_RealIntVal_Int:\n  \"x \\<in> space (stock_measure INTEG) \\<Longrightarrow> lift_RealIntVal f g x = lift_IntVal f x\"", "lemma measurable_lift_RealVal[measurable]:\n  assumes [measurable]: \"f \\<in> borel_measurable borel\"\n  shows \"lift_RealVal f \\<in> measurable REAL REAL\"", "lemma measurable_lift_IntVal[simp]: \"lift_IntVal f \\<in> range IntVal \\<rightarrow> range IntVal\"", "lemma measurable_lift_IntVal'[measurable]: \"lift_IntVal f \\<in> measurable INTEG INTEG\"", "lemma split_apply: \"(case x of (a, b) \\<Rightarrow> f a b) y = (case x of (a, b) \\<Rightarrow> f a b y)\"", "lemma measurable_lift_Comp_RealVal[measurable]:\n  assumes [measurable]: \"Measurable.pred (borel \\<Otimes>\\<^sub>M borel) (case_prod g)\"\n  shows \"lift_Comp f g \\<in> measurable (PRODUCT REAL REAL) BOOL\"", "lemma measurable_lift_Comp_IntVal[simp]:\n  \"lift_Comp f g \\<in> measurable (PRODUCT INTEG INTEG) BOOL\"", "lemma measurable_lift_RealIntVal_IntVal[simp]: \"lift_RealIntVal f g \\<in> range IntVal \\<rightarrow> range IntVal\"", "lemma measurable_lift_RealIntVal_IntVal'[measurable]:\n   \"lift_RealIntVal f g \\<in> measurable INTEG INTEG\"", "lemma measurable_lift_RealIntVal_RealVal[measurable]:\n  assumes [measurable]: \"g \\<in> borel_measurable borel\"\n  shows \"lift_RealIntVal f g \\<in> measurable REAL REAL\"", "lemma measurable_lift_RealIntVal2_IntVal[measurable]:\n  \"lift_RealIntVal2 f g \\<in> measurable (PRODUCT INTEG INTEG) INTEG\"", "lemma measurable_lift_RealIntVal2_RealVal[measurable]:\n  assumes [measurable]: \"case_prod g \\<in> borel_measurable (borel \\<Otimes>\\<^sub>M borel)\"\n  shows \"lift_RealIntVal2 f g \\<in> measurable (PRODUCT REAL REAL) REAL\"", "lemma distr_lift_RealVal:\n  fixes f\n  assumes Mf[measurable]: \"f \\<in> borel_measurable borel\"\n  assumes pdens: \"has_subprob_density M (stock_measure REAL) \\<delta>\"\n  assumes dens': \"\\<And>M \\<delta>. has_subprob_density M lborel \\<delta> \\<Longrightarrow> has_density (distr M borel f) lborel (g \\<delta>)\"\n  defines \"N \\<equiv> distr M (stock_measure REAL) (lift_RealVal f)\"\n  shows \"has_density N (stock_measure REAL) (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\"", "lemma distr_lift_IntVal:\n  fixes f\n  assumes pdens: \"has_density M (stock_measure INTEG) \\<delta>\"\n  assumes dens': \"\\<And>M \\<delta>. has_density M (count_space UNIV) \\<delta> \\<Longrightarrow>\n                            has_density (distr M (count_space UNIV) f) (count_space UNIV) (g \\<delta>)\"\n  defines \"N \\<equiv> distr M (stock_measure INTEG) (lift_IntVal f)\"\n  shows \"has_density N (stock_measure INTEG) (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\"", "lemma distr_lift_RealPairVal:\n  fixes f f' g\n  assumes Mf[measurable]: \"case_prod f \\<in> borel_measurable borel\"\n  assumes pdens: \"has_subprob_density M (stock_measure (PRODUCT REAL REAL)) \\<delta>\"\n  assumes dens': \"\\<And>M \\<delta>. has_subprob_density M lborel \\<delta> \\<Longrightarrow> has_density (distr M borel (case_prod f)) lborel (g \\<delta>)\"\n  defines \"N \\<equiv> distr M (stock_measure REAL) (lift_RealIntVal2 f' f)\"\n  shows \"has_density N (stock_measure REAL) (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\"", "lemma distr_lift_IntPairVal:\n  fixes f f'\n  assumes pdens: \"has_density M (stock_measure (PRODUCT INTEG INTEG)) \\<delta>\"\n  assumes dens': \"\\<And>M \\<delta>. has_density M (count_space UNIV) \\<delta> \\<Longrightarrow>\n                            has_density (distr M (count_space UNIV) (case_prod f))\n                                        (count_space UNIV) (g \\<delta>)\"\n  defines \"N \\<equiv> distr M (stock_measure INTEG) (lift_RealIntVal2 f f')\"\n  shows \"has_density N (stock_measure INTEG) (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\""], "translations": [["", "lemma map_int_pair[simp]: \"map_int_pair f g <| IntVal i, IntVal j |> = f i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_int_pair f g <|IntVal i, IntVal j|> = f i j", "by (simp add: map_int_pair_def)"], ["", "lemma map_int_pair_REAL[simp]: \"map_int_pair f g <| RealVal i, RealVal j |> = g <| RealVal i, RealVal j |>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_int_pair f g <|RealVal i, RealVal j|> = g <|RealVal i, RealVal j|>", "by (simp add: map_int_pair_def)"], ["", "lemma map_real_pair[simp]: \"map_real_pair f g <| RealVal i, RealVal j |> = f i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_real_pair f g <|RealVal i, RealVal j|> = f i j", "by (simp add: map_real_pair_def)"], ["", "abbreviation \"extract_pair \\<equiv> extract_pair' id id\""], ["", "abbreviation \"extract_real_pair \\<equiv> extract_pair' extract_real extract_real\""], ["", "abbreviation \"extract_int_pair \\<equiv> extract_pair' extract_int extract_int\""], ["", "definition \"RealPairVal \\<equiv> \\<lambda>(x,y). <|RealVal x, RealVal y|>\""], ["", "definition \"IntPairVal \\<equiv> \\<lambda>(x,y). <|IntVal x, IntVal y|>\""], ["", "lemma inj_RealPairVal: \"inj RealPairVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj RealPairVal", "by (auto simp: RealPairVal_def intro!: injI)"], ["", "lemma inj_IntPairVal: \"inj IntPairVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj IntPairVal", "by (auto simp: IntPairVal_def intro!: injI)"], ["", "fun val_type :: \"val \\<Rightarrow> pdf_type\" where\n  \"val_type (BoolVal b) = BOOL\"\n| \"val_type (IntVal i) = INTEG\"\n| \"val_type UnitVal = UNIT\"\n| \"val_type (RealVal r) = REAL\"\n| \"val_type (<|v1 , v2|>) = (PRODUCT (val_type v1) (val_type v2))\""], ["", "lemma val_type_eq_REAL: \"val_type x = REAL \\<longleftrightarrow> x \\<in> RealVal`UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (val_type x = REAL) = (x \\<in> range RealVal)", "by (cases x) auto"], ["", "lemma val_type_eq_INTEG: \"val_type x = INTEG \\<longleftrightarrow> x \\<in> IntVal`UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (val_type x = INTEG) = (x \\<in> range IntVal)", "by (cases x) auto"], ["", "definition \"type_universe t = {v. val_type v = t}\""], ["", "lemma type_universe_nonempty[simp]: \"type_universe t \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_universe t \\<noteq> {}", "by (induction t) (auto intro: val_type.simps simp: type_universe_def)"], ["", "lemma val_in_type_universe[simp]:\n    \"v \\<in> type_universe (val_type v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> type_universe (val_type v)", "by (simp add: type_universe_def)"], ["", "lemma BoolVal_in_type_universe[simp]: \"BoolVal v \\<in> type_universe BOOL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BoolVal v \\<in> type_universe BOOL", "by (simp add: type_universe_def)"], ["", "lemma IntVal_in_type_universe[simp]: \"IntVal v \\<in> type_universe INTEG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IntVal v \\<in> type_universe INTEG", "by (simp add: type_universe_def)"], ["", "lemma type_universe_type[simp]:\n    \"w \\<in> type_universe t \\<longleftrightarrow> val_type w = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> type_universe t) = (val_type w = t)", "by (simp add: type_universe_def)"], ["", "lemma type_universe_REAL: \"type_universe REAL = RealVal ` UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_universe REAL = range RealVal", "apply (auto simp add: set_eq_iff image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. val_type x = REAL \\<Longrightarrow> \\<exists>xa. x = RealVal xa", "apply (case_tac x)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>val_type x = REAL; x = UnitVal\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x = RealVal xa\n 2. \\<And>x x2.\n       \\<lbrakk>val_type x = REAL; x = BoolVal x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x = RealVal xa\n 3. \\<And>x x3.\n       \\<lbrakk>val_type x = REAL; x = IntVal x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x = RealVal xa\n 4. \\<And>x x4.\n       \\<lbrakk>val_type x = REAL; x = RealVal x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x = RealVal xa\n 5. \\<And>x x51 x52.\n       \\<lbrakk>val_type x = REAL; x = <|x51, x52|>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa. x = RealVal xa", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_universe_eq_imp_type_eq:\n  assumes \"type_universe t1 = type_universe t2\"\n  shows \"t1 = t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t1 = t2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. t1 = t2", "from type_universe_nonempty"], ["proof (chain)\npicking this:\n  type_universe ?t \\<noteq> {}", "obtain v where A: \"v \\<in> type_universe t1\""], ["proof (prove)\nusing this:\n  type_universe ?t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> type_universe t1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> type_universe t1\n\ngoal (1 subgoal):\n 1. t1 = t2", "hence \"t1 = val_type v\""], ["proof (prove)\nusing this:\n  v \\<in> type_universe t1\n\ngoal (1 subgoal):\n 1. t1 = val_type v", "by simp"], ["proof (state)\nthis:\n  t1 = val_type v\n\ngoal (1 subgoal):\n 1. t1 = t2", "also"], ["proof (state)\nthis:\n  t1 = val_type v\n\ngoal (1 subgoal):\n 1. t1 = t2", "from A and assms"], ["proof (chain)\npicking this:\n  v \\<in> type_universe t1\n  type_universe t1 = type_universe t2", "have \"v \\<in> type_universe t2\""], ["proof (prove)\nusing this:\n  v \\<in> type_universe t1\n  type_universe t1 = type_universe t2\n\ngoal (1 subgoal):\n 1. v \\<in> type_universe t2", "by simp"], ["proof (state)\nthis:\n  v \\<in> type_universe t2\n\ngoal (1 subgoal):\n 1. t1 = t2", "hence \"val_type v = t2\""], ["proof (prove)\nusing this:\n  v \\<in> type_universe t2\n\ngoal (1 subgoal):\n 1. val_type v = t2", "by simp"], ["proof (state)\nthis:\n  val_type v = t2\n\ngoal (1 subgoal):\n 1. t1 = t2", "finally"], ["proof (chain)\npicking this:\n  t1 = t2", "show ?thesis"], ["proof (prove)\nusing this:\n  t1 = t2\n\ngoal (1 subgoal):\n 1. t1 = t2", "."], ["proof (state)\nthis:\n  t1 = t2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_universe_eq_iff[simp]: \"type_universe t1 = type_universe t2 \\<longleftrightarrow> t1 = t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (type_universe t1 = type_universe t2) = (t1 = t2)", "by (blast intro: type_universe_eq_imp_type_eq)"], ["", "primrec stock_measure :: \"pdf_type \\<Rightarrow> val measure\" where\n  \"stock_measure UNIT = count_space {UnitVal}\"\n| \"stock_measure INTEG = count_space (range IntVal)\"\n| \"stock_measure BOOL = count_space (range BoolVal)\"\n| \"stock_measure REAL = embed_measure lborel RealVal\"\n| \"stock_measure (PRODUCT t1 t2) =\n       embed_measure (stock_measure t1 \\<Otimes>\\<^sub>M stock_measure t2) (\\<lambda>(a, b). <|a, b|>)\""], ["", "declare [[coercion stock_measure]]"], ["", "lemma sigma_finite_stock_measure[simp]: \"sigma_finite_measure (stock_measure t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_finite_measure (stock_measure t)", "by (induction t)\n     (auto intro!: sigma_finite_measure_count_space_countable sigma_finite_pair_measure\n                   sigma_finite_embed_measure injI sigma_finite_lborel)"], ["", "lemma val_case_stock_measurable:\n  assumes \"t = UNIT \\<Longrightarrow> c \\<in> space M\"\n  assumes \"\\<And>b. t = BOOL \\<Longrightarrow> g b \\<in> space M\"\n  assumes \"\\<And>i. t = INTEG \\<Longrightarrow> h i \\<in> space M\"\n  assumes \"t = REAL \\<Longrightarrow> j \\<in> measurable borel M\"\n  assumes *: \"\\<And>t1 t2. t = PRODUCT t1 t2 \\<Longrightarrow> case_prod k \\<in> measurable (stock_measure t1 \\<Otimes>\\<^sub>M stock_measure t2) M\"\n  shows \"(\\<lambda>x. case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n                | PairVal y z \\<Rightarrow> k y z) \\<in> measurable t M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M", "proof (cases t)"], ["proof (state)\ngoal (5 subgoals):\n 1. t = UNIT \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 2. t = BOOL \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 3. t = INTEG \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 4. t = REAL \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 5. \\<And>x51 x52.\n       t = PRODUCT x51 x52 \\<Longrightarrow>\n       (\\<lambda>x.\n           case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n           | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n           | <|y, z|> \\<Rightarrow> k y z)\n       \\<in> stock_measure t \\<rightarrow>\\<^sub>M M", "case (PRODUCT t1 t2)"], ["proof (state)\nthis:\n  t = PRODUCT t1 t2\n\ngoal (5 subgoals):\n 1. t = UNIT \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 2. t = BOOL \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 3. t = INTEG \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 4. t = REAL \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 5. \\<And>x51 x52.\n       t = PRODUCT x51 x52 \\<Longrightarrow>\n       (\\<lambda>x.\n           case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n           | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n           | <|y, z|> \\<Rightarrow> k y z)\n       \\<in> stock_measure t \\<rightarrow>\\<^sub>M M", "with *[of t1 t2]"], ["proof (chain)\npicking this:\n  t = PRODUCT t1 t2 \\<Longrightarrow>\n  (\\<lambda>(x, y). k x y)\n  \\<in> stock_measure t1 \\<Otimes>\\<^sub>M\n        stock_measure t2 \\<rightarrow>\\<^sub>M\n        M\n  t = PRODUCT t1 t2", "show ?thesis"], ["proof (prove)\nusing this:\n  t = PRODUCT t1 t2 \\<Longrightarrow>\n  (\\<lambda>(x, y). k x y)\n  \\<in> stock_measure t1 \\<Otimes>\\<^sub>M\n        stock_measure t2 \\<rightarrow>\\<^sub>M\n        M\n  t = PRODUCT t1 t2\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M", "by (auto intro!: measurable_embed_measure1 simp: split_beta')"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n      | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n      | <|y, z|> \\<Rightarrow> k y z)\n  \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n\ngoal (4 subgoals):\n 1. t = UNIT \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 2. t = BOOL \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 3. t = INTEG \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M\n 4. t = REAL \\<Longrightarrow>\n    (\\<lambda>x.\n        case x of UnitVal \\<Rightarrow> c | BoolVal b \\<Rightarrow> g b\n        | IntVal i \\<Rightarrow> h i | RealVal r \\<Rightarrow> j r\n        | <|y, z|> \\<Rightarrow> k y z)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M M", "qed (auto intro!: measurable_embed_measure1 assms)"], ["", "lemma space_stock_measure[simp]: \"space (stock_measure t) = type_universe t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (stock_measure t) = type_universe t", "by (induction t)\n     (auto simp add: type_universe_def space_pair_measure space_embed_measure\n           simp del: type_universe_type elim: val_type.elims)"], ["", "lemma type_universe_stock_measure[measurable]: \"type_universe t \\<in> sets (stock_measure t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_universe t \\<in> sets (stock_measure t)", "using sets.top[of \"stock_measure t\"]"], ["proof (prove)\nusing this:\n  space (stock_measure t) \\<in> sets (stock_measure t)\n\ngoal (1 subgoal):\n 1. type_universe t \\<in> sets (stock_measure t)", "by simp"], ["", "lemma inj_RealVal[simp]: \"inj RealVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj RealVal", "by (auto intro!: inj_onI)"], ["", "lemma inj_IntVal[simp]: \"inj IntVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj IntVal", "by (auto intro!: inj_onI)"], ["", "lemma inj_BoolVal[simp]: \"inj BoolVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj BoolVal", "by (auto intro!: inj_onI)"], ["", "lemma inj_PairVal[simp]: \"inj (\\<lambda>(x, y). <| x ,  y |>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>(x, y). <|x, y|>)", "by (auto intro: injI)"], ["", "lemma measurable_PairVal[measurable]:\n  fixes t1 t2 :: pdf_type\n  shows \"case_prod PairVal \\<in> measurable (t1 \\<Otimes>\\<^sub>M t2) (PRODUCT t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). <|x, y|>)\n    \\<in> stock_measure t1 \\<Otimes>\\<^sub>M\n          stock_measure t2 \\<rightarrow>\\<^sub>M\n          stock_measure (PRODUCT t1 t2)", "using measurable_embed_measure2[measurable]"], ["proof (prove)\nusing this:\n  inj ?f \\<Longrightarrow>\n  ?f \\<in> ?M \\<rightarrow>\\<^sub>M embed_measure ?M ?f\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). <|x, y|>)\n    \\<in> stock_measure t1 \\<Otimes>\\<^sub>M\n          stock_measure t2 \\<rightarrow>\\<^sub>M\n          stock_measure (PRODUCT t1 t2)", "by simp"], ["", "lemma measurable_RealVal[measurable]: \"RealVal \\<in> measurable borel REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RealVal \\<in> borel \\<rightarrow>\\<^sub>M stock_measure REAL", "using measurable_embed_measure2[measurable]"], ["proof (prove)\nusing this:\n  inj ?f \\<Longrightarrow>\n  ?f \\<in> ?M \\<rightarrow>\\<^sub>M embed_measure ?M ?f\n\ngoal (1 subgoal):\n 1. RealVal \\<in> borel \\<rightarrow>\\<^sub>M stock_measure REAL", "by simp"], ["", "lemma nn_integral_BoolVal:\n  assumes \"\\<And>x. f (BoolVal x) \\<ge> 0\"\n  shows \"(\\<integral>\\<^sup>+x. f x \\<partial>BOOL) = f (BoolVal True) + f (BoolVal False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (stock_measure BOOL) f = f TRUE + f FALSE", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (stock_measure BOOL) f = f TRUE + f FALSE", "have A: \"range BoolVal = {BoolVal True, BoolVal False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range BoolVal = {TRUE, FALSE}", "by auto"], ["proof (state)\nthis:\n  range BoolVal = {TRUE, FALSE}\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (stock_measure BOOL) f = f TRUE + f FALSE", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> f (BoolVal ?x)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> f (BoolVal ?x)\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (stock_measure BOOL) f = f TRUE + f FALSE", "by (subst stock_measure.simps, subst A, subst nn_integral_count_space_finite)\n       (simp_all add: max_def A)"], ["proof (state)\nthis:\n  integral\\<^sup>N (stock_measure BOOL) f = f TRUE + f FALSE\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nn_integral_RealVal:\n  \"f \\<in> borel_measurable REAL \\<Longrightarrow> (\\<integral>\\<^sup>+x. f x \\<partial>REAL) = (\\<integral>\\<^sup>+x. f (RealVal x) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable (stock_measure REAL) \\<Longrightarrow>\n    integral\\<^sup>N (stock_measure REAL) f =\n    \\<integral>\\<^sup>+ x. f (RealVal x) \\<partial>lborel", "unfolding stock_measure.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable\n             (embed_measure lborel RealVal) \\<Longrightarrow>\n    integral\\<^sup>N (embed_measure lborel RealVal) f =\n    \\<integral>\\<^sup>+ x. f (RealVal x) \\<partial>lborel", "using measurable_embed_measure2[measurable]"], ["proof (prove)\nusing this:\n  inj ?f \\<Longrightarrow>\n  ?f \\<in> ?M \\<rightarrow>\\<^sub>M embed_measure ?M ?f\n\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable\n             (embed_measure lborel RealVal) \\<Longrightarrow>\n    integral\\<^sup>N (embed_measure lborel RealVal) f =\n    \\<integral>\\<^sup>+ x. f (RealVal x) \\<partial>lborel", "by (subst embed_measure_eq_distr, simp_all add: nn_integral_distr)"], ["", "lemma nn_integral_IntVal: \"(\\<integral>\\<^sup>+x. f x \\<partial>INTEG) = (\\<integral>\\<^sup>+x. f (IntVal x) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (stock_measure INTEG) f =\n    \\<integral>\\<^sup>+ x. f (IntVal x) \\<partial>count_space UNIV", "using measurable_embed_measure1[measurable (raw)]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ?g (?f x))\n  \\<in> ?M \\<rightarrow>\\<^sub>M ?N \\<Longrightarrow>\n  ?g \\<in> embed_measure ?M ?f \\<rightarrow>\\<^sub>M ?N\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (stock_measure INTEG) f =\n    \\<integral>\\<^sup>+ x. f (IntVal x) \\<partial>count_space UNIV", "unfolding stock_measure.simps embed_measure_count_space[OF inj_IntVal, symmetric]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ?g (?f x))\n  \\<in> ?M \\<rightarrow>\\<^sub>M ?N \\<Longrightarrow>\n  ?g \\<in> embed_measure ?M ?f \\<rightarrow>\\<^sub>M ?N\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (embed_measure (count_space UNIV) IntVal) f =\n    \\<integral>\\<^sup>+ x. f (IntVal x) \\<partial>count_space UNIV", "by (subst embed_measure_eq_distr[OF inj_IntVal], simp add: nn_integral_distr space_embed_measure)"], ["", "lemma nn_integral_PairVal:\n  \"f \\<in> borel_measurable (PRODUCT t1 t2) \\<Longrightarrow>\n    (\\<integral>\\<^sup>+x. f x \\<partial>PRODUCT t1 t2) = (\\<integral>\\<^sup>+x. f (PairVal (fst x) (snd x)) \\<partial>(t1 \\<Otimes>\\<^sub>M t2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable\n             (stock_measure (PRODUCT t1 t2)) \\<Longrightarrow>\n    integral\\<^sup>N (stock_measure (PRODUCT t1 t2)) f =\n    \\<integral>\\<^sup>+ x. f <|fst x, snd x|>\n                       \\<partial>stock_measure t1 \\<Otimes>\\<^sub>M\n                                 stock_measure t2", "unfolding stock_measure.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable\n             (embed_measure\n               (stock_measure t1 \\<Otimes>\\<^sub>M stock_measure t2)\n               (\\<lambda>(x, y). <|x, y|>)) \\<Longrightarrow>\n    integral\\<^sup>N\n     (embed_measure (stock_measure t1 \\<Otimes>\\<^sub>M stock_measure t2)\n       (\\<lambda>(x, y). <|x, y|>))\n     f =\n    \\<integral>\\<^sup>+ x. f <|fst x, snd x|>\n                       \\<partial>stock_measure t1 \\<Otimes>\\<^sub>M\n                                 stock_measure t2", "by (subst nn_integral_embed_measure) (simp_all add: split_beta' inj_on_def)"], ["", "lemma BOOL_E: \"\\<lbrakk>val_type v = BOOL; \\<And>b. v = BoolVal b \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>val_type v = BOOL;\n     \\<And>b. v = BoolVal b \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases v) auto"], ["", "lemma PROD_E: \"\\<lbrakk>val_type v = PRODUCT t1 t2 ;\n     \\<And>a b. val_type a = t1 \\<Longrightarrow> val_type b = t2 \\<Longrightarrow> v = <| a, b |> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>val_type v = PRODUCT t1 t2;\n     \\<And>a b.\n        \\<lbrakk>val_type a = t1; val_type b = t2; v = <|a, b|>\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases v) auto"], ["", "lemma REAL_E: \"\\<lbrakk>val_type v = REAL; \\<And>b. v = RealVal b \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>val_type v = REAL;\n     \\<And>b. v = RealVal b \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases v) auto"], ["", "lemma INTEG_E: \"\\<lbrakk>val_type v = INTEG; \\<And>i. v = IntVal i \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>val_type v = INTEG;\n     \\<And>i. v = IntVal i \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases v) auto"], ["", "lemma measurable_extract_pair'[measurable (raw)]:\n  fixes t1 t2 :: pdf_type\n  assumes [measurable]: \"f \\<in> measurable t1 M\"\n  assumes [measurable]: \"g \\<in> measurable t2 N\"\n  assumes h: \"h \\<in> measurable K (PRODUCT t1 t2)\"\n  shows \"(\\<lambda>x. extract_pair' f g (h x)) \\<in> measurable K (M \\<Otimes>\\<^sub>M N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. extract_pair' f g (h x))\n    \\<in> K \\<rightarrow>\\<^sub>M M \\<Otimes>\\<^sub>M N", "by (rule measurable_compose[OF h[unfolded stock_measure.simps] measurable_embed_measure1])\n     (simp add: split_beta')"], ["", "lemma measurable_extract_pair[measurable]: \"extract_pair \\<in> measurable (PRODUCT t1 t2) (t1 \\<Otimes>\\<^sub>M t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_pair\n    \\<in> stock_measure (PRODUCT t1 t2) \\<rightarrow>\\<^sub>M\n          stock_measure t1 \\<Otimes>\\<^sub>M stock_measure t2", "by measurable"], ["", "lemma measurable_extract_real[measurable]: \"extract_real \\<in> measurable REAL borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real \\<in> borel_measurable (stock_measure REAL)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real \\<in> borel_measurable (embed_measure lborel RealVal)", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real \\<in> borel_measurable (embed_measure lborel RealVal)", "apply (rule measurable_embed_measure1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. extract_real (RealVal x)) \\<in> borel_measurable lborel", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma measurable_extract_int[measurable]: \"extract_int \\<in> measurable INTEG (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_int\n    \\<in> stock_measure INTEG \\<rightarrow>\\<^sub>M count_space UNIV", "by simp measurable"], ["", "lemma measurable_extract_int_pair[measurable]:\n  \"extract_int_pair \\<in> measurable (PRODUCT INTEG INTEG) (count_space UNIV \\<Otimes>\\<^sub>M count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_int_pair\n    \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M\n          count_space UNIV \\<Otimes>\\<^sub>M count_space UNIV", "by measurable"], ["", "lemma measurable_extract_real_pair[measurable]:\n  \"extract_real_pair \\<in> measurable (PRODUCT REAL REAL) (borel \\<Otimes>\\<^sub>M borel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real_pair\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M\n          borel \\<Otimes>\\<^sub>M borel", "by measurable"], ["", "lemma measurable_extract_real_pair'[measurable]:\n  \"extract_real_pair \\<in> measurable (PRODUCT REAL REAL) borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_real_pair\n    \\<in> borel_measurable (stock_measure (PRODUCT REAL REAL))", "by (subst borel_prod[symmetric]) measurable"], ["", "lemma measurable_extract_bool[measurable]: \"extract_bool \\<in> measurable BOOL (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stock_measure BOOL) extract_bool", "by simp"], ["", "lemma map_int_pair_measurable[measurable]:\n  assumes f: \"case_prod f \\<in> measurable (count_space UNIV \\<Otimes>\\<^sub>M count_space UNIV) M\"\n  shows \"map_int_pair f g \\<in> measurable (PRODUCT INTEG INTEG) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_int_pair f g\n    \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M M", "proof (subst measurable_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure (PRODUCT INTEG INTEG)) \\<Longrightarrow>\n       map_int_pair f g w = ?g w\n 2. ?g \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M M", "fix w"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure (PRODUCT INTEG INTEG)) \\<Longrightarrow>\n       map_int_pair f g w = ?g w\n 2. ?g \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M M", "assume \"w \\<in> space (PRODUCT INTEG INTEG)\""], ["proof (state)\nthis:\n  w \\<in> space (stock_measure (PRODUCT INTEG INTEG))\n\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure (PRODUCT INTEG INTEG)) \\<Longrightarrow>\n       map_int_pair f g w = ?g w\n 2. ?g \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M M", "then"], ["proof (chain)\npicking this:\n  w \\<in> space (stock_measure (PRODUCT INTEG INTEG))", "show \"map_int_pair f g w = (case_prod f o extract_int_pair) w\""], ["proof (prove)\nusing this:\n  w \\<in> space (stock_measure (PRODUCT INTEG INTEG))\n\ngoal (1 subgoal):\n 1. map_int_pair f g w =\n    ((\\<lambda>(x, y). f x y) \\<circ> extract_int_pair) w", "by (auto simp: space_embed_measure space_pair_measure)"], ["proof (state)\nthis:\n  map_int_pair f g w = ((\\<lambda>(x, y). f x y) \\<circ> extract_int_pair) w\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair\n    \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair\n    \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M M", "show \"(\\<lambda>(x, y). f x y) \\<circ> extract_int_pair \\<in> measurable (stock_measure (PRODUCT INTEG INTEG)) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair\n    \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M M", "using measurable_extract_int_pair f"], ["proof (prove)\nusing this:\n  extract_int_pair\n  \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M\n        count_space UNIV \\<Otimes>\\<^sub>M count_space UNIV\n  (\\<lambda>(x, y). f x y)\n  \\<in> count_space UNIV \\<Otimes>\\<^sub>M\n        count_space UNIV \\<rightarrow>\\<^sub>M\n        M\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair\n    \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M M", "by (rule measurable)"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair\n  \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_int_pair_measurable_REAL[measurable]:\n  assumes \"g \\<in> measurable (PRODUCT REAL REAL) M\"\n  shows \"map_int_pair f g \\<in> measurable (PRODUCT REAL REAL) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_int_pair f g\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "proof (subst measurable_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure (PRODUCT REAL REAL)) \\<Longrightarrow>\n       map_int_pair f g w = ?g w\n 2. ?g \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "fix w"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure (PRODUCT REAL REAL)) \\<Longrightarrow>\n       map_int_pair f g w = ?g w\n 2. ?g \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "assume \"w \\<in> space (PRODUCT REAL REAL)\""], ["proof (state)\nthis:\n  w \\<in> space (stock_measure (PRODUCT REAL REAL))\n\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure (PRODUCT REAL REAL)) \\<Longrightarrow>\n       map_int_pair f g w = ?g w\n 2. ?g \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "then"], ["proof (chain)\npicking this:\n  w \\<in> space (stock_measure (PRODUCT REAL REAL))", "show \"map_int_pair f g w = g w\""], ["proof (prove)\nusing this:\n  w \\<in> space (stock_measure (PRODUCT REAL REAL))\n\ngoal (1 subgoal):\n 1. map_int_pair f g w = g w", "by (auto simp: space_embed_measure space_pair_measure map_int_pair_def)"], ["proof (state)\nthis:\n  map_int_pair f g w = g w\n\ngoal (1 subgoal):\n 1. g \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "qed fact"], ["", "lemma map_real_pair_measurable[measurable]:\n  assumes f: \"case_prod f \\<in> measurable (borel \\<Otimes>\\<^sub>M borel) M\"\n  shows \"map_real_pair f g \\<in> measurable (PRODUCT REAL REAL) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_real_pair f g\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "proof (subst measurable_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure (PRODUCT REAL REAL)) \\<Longrightarrow>\n       map_real_pair f g w = ?g w\n 2. ?g \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "fix w"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure (PRODUCT REAL REAL)) \\<Longrightarrow>\n       map_real_pair f g w = ?g w\n 2. ?g \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "assume \"w \\<in> space (PRODUCT REAL REAL)\""], ["proof (state)\nthis:\n  w \\<in> space (stock_measure (PRODUCT REAL REAL))\n\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure (PRODUCT REAL REAL)) \\<Longrightarrow>\n       map_real_pair f g w = ?g w\n 2. ?g \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "then"], ["proof (chain)\npicking this:\n  w \\<in> space (stock_measure (PRODUCT REAL REAL))", "show \"map_real_pair f g w = (case_prod f o extract_real_pair) w\""], ["proof (prove)\nusing this:\n  w \\<in> space (stock_measure (PRODUCT REAL REAL))\n\ngoal (1 subgoal):\n 1. map_real_pair f g w =\n    ((\\<lambda>(x, y). f x y) \\<circ> extract_real_pair) w", "by (auto simp: space_embed_measure space_pair_measure)"], ["proof (state)\nthis:\n  map_real_pair f g w =\n  ((\\<lambda>(x, y). f x y) \\<circ> extract_real_pair) w\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "show \"(\\<lambda>(x, y). f x y) \\<circ> extract_real_pair \\<in> measurable (stock_measure (PRODUCT REAL REAL)) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "using measurable_extract_real_pair f"], ["proof (prove)\nusing this:\n  extract_real_pair\n  \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M\n        borel \\<Otimes>\\<^sub>M borel\n  (\\<lambda>(x, y). f x y)\n  \\<in> borel \\<Otimes>\\<^sub>M borel \\<rightarrow>\\<^sub>M M\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M", "by (rule measurable)"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair\n  \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_space_IntVal_prod[simp]: \"INTEG \\<Otimes>\\<^sub>M INTEG = count_space (range IntVal \\<times> range IntVal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stock_measure INTEG \\<Otimes>\\<^sub>M stock_measure INTEG =\n    count_space (range IntVal \\<times> range IntVal)", "by (auto intro!: pair_measure_countable)"], ["", "lemma count_space_BoolVal_prod[simp]: \"BOOL \\<Otimes>\\<^sub>M BOOL = count_space (range BoolVal \\<times> range BoolVal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stock_measure BOOL \\<Otimes>\\<^sub>M stock_measure BOOL =\n    count_space (range BoolVal \\<times> range BoolVal)", "by (auto intro!: pair_measure_countable)"], ["", "lemma measurable_stock_measure_val_type:\n  assumes \"f \\<in> measurable M (stock_measure t)\" \"x \\<in> space M\"\n  shows \"val_type (f x) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_type (f x) = t", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> M \\<rightarrow>\\<^sub>M stock_measure t\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. val_type (f x) = t", "by (auto dest!: measurable_space)"], ["", "lemma singleton_in_stock_measure[simp]: \"val_type v = t \\<Longrightarrow> {v} \\<in> sets t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_type v = t \\<Longrightarrow> {v} \\<in> sets (stock_measure t)", "proof (induction v arbitrary: t)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t.\n       val_type UnitVal = t \\<Longrightarrow>\n       {UnitVal} \\<in> sets (stock_measure t)\n 2. \\<And>x t.\n       val_type (BoolVal x) = t \\<Longrightarrow>\n       {BoolVal x} \\<in> sets (stock_measure t)\n 3. \\<And>x t.\n       val_type (IntVal x) = t \\<Longrightarrow>\n       {IntVal x} \\<in> sets (stock_measure t)\n 4. \\<And>x t.\n       val_type (RealVal x) = t \\<Longrightarrow>\n       {RealVal x} \\<in> sets (stock_measure t)\n 5. \\<And>v1 v2 t.\n       \\<lbrakk>\\<And>t.\n                   val_type v1 = t \\<Longrightarrow>\n                   {v1} \\<in> sets (stock_measure t);\n        \\<And>t.\n           val_type v2 = t \\<Longrightarrow>\n           {v2} \\<in> sets (stock_measure t);\n        val_type <|v1, v2|> = t\\<rbrakk>\n       \\<Longrightarrow> {<|v1, v2|>} \\<in> sets (stock_measure t)", "case (PairVal v1 v2)"], ["proof (state)\nthis:\n  val_type v1 = ?t \\<Longrightarrow> {v1} \\<in> sets (stock_measure ?t)\n  val_type v2 = ?t \\<Longrightarrow> {v2} \\<in> sets (stock_measure ?t)\n  val_type <|v1, v2|> = t\n\ngoal (5 subgoals):\n 1. \\<And>t.\n       val_type UnitVal = t \\<Longrightarrow>\n       {UnitVal} \\<in> sets (stock_measure t)\n 2. \\<And>x t.\n       val_type (BoolVal x) = t \\<Longrightarrow>\n       {BoolVal x} \\<in> sets (stock_measure t)\n 3. \\<And>x t.\n       val_type (IntVal x) = t \\<Longrightarrow>\n       {IntVal x} \\<in> sets (stock_measure t)\n 4. \\<And>x t.\n       val_type (RealVal x) = t \\<Longrightarrow>\n       {RealVal x} \\<in> sets (stock_measure t)\n 5. \\<And>v1 v2 t.\n       \\<lbrakk>\\<And>t.\n                   val_type v1 = t \\<Longrightarrow>\n                   {v1} \\<in> sets (stock_measure t);\n        \\<And>t.\n           val_type v2 = t \\<Longrightarrow>\n           {v2} \\<in> sets (stock_measure t);\n        val_type <|v1, v2|> = t\\<rbrakk>\n       \\<Longrightarrow> {<|v1, v2|>} \\<in> sets (stock_measure t)", "have A: \"{<|v1, v2|>} = (\\<lambda>(v1,v2). <|v1,v2|>) ` ({v1}\\<times>{v2})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {<|v1, v2|>} = (\\<lambda>(v1, v2). <|v1, v2|>) ` ({v1} \\<times> {v2})", "by simp"], ["proof (state)\nthis:\n  {<|v1, v2|>} = (\\<lambda>(v1, v2). <|v1, v2|>) ` ({v1} \\<times> {v2})\n\ngoal (5 subgoals):\n 1. \\<And>t.\n       val_type UnitVal = t \\<Longrightarrow>\n       {UnitVal} \\<in> sets (stock_measure t)\n 2. \\<And>x t.\n       val_type (BoolVal x) = t \\<Longrightarrow>\n       {BoolVal x} \\<in> sets (stock_measure t)\n 3. \\<And>x t.\n       val_type (IntVal x) = t \\<Longrightarrow>\n       {IntVal x} \\<in> sets (stock_measure t)\n 4. \\<And>x t.\n       val_type (RealVal x) = t \\<Longrightarrow>\n       {RealVal x} \\<in> sets (stock_measure t)\n 5. \\<And>v1 v2 t.\n       \\<lbrakk>\\<And>t.\n                   val_type v1 = t \\<Longrightarrow>\n                   {v1} \\<in> sets (stock_measure t);\n        \\<And>t.\n           val_type v2 = t \\<Longrightarrow>\n           {v2} \\<in> sets (stock_measure t);\n        val_type <|v1, v2|> = t\\<rbrakk>\n       \\<Longrightarrow> {<|v1, v2|>} \\<in> sets (stock_measure t)", "from pair_measureI[OF PairVal.IH, OF refl refl] PairVal.prems[symmetric]"], ["proof (chain)\npicking this:\n  {v1} \\<times> {v2}\n  \\<in> sets\n         (stock_measure (val_type v1) \\<Otimes>\\<^sub>M\n          stock_measure (val_type v2))\n  t = val_type <|v1, v2|>", "show ?case"], ["proof (prove)\nusing this:\n  {v1} \\<times> {v2}\n  \\<in> sets\n         (stock_measure (val_type v1) \\<Otimes>\\<^sub>M\n          stock_measure (val_type v2))\n  t = val_type <|v1, v2|>\n\ngoal (1 subgoal):\n 1. {<|v1, v2|>} \\<in> sets (stock_measure t)", "by (simp only: val_type.simps stock_measure.simps A in_sets_embed_measure)"], ["proof (state)\nthis:\n  {<|v1, v2|>} \\<in> sets (stock_measure t)\n\ngoal (4 subgoals):\n 1. \\<And>t.\n       val_type UnitVal = t \\<Longrightarrow>\n       {UnitVal} \\<in> sets (stock_measure t)\n 2. \\<And>x t.\n       val_type (BoolVal x) = t \\<Longrightarrow>\n       {BoolVal x} \\<in> sets (stock_measure t)\n 3. \\<And>x t.\n       val_type (IntVal x) = t \\<Longrightarrow>\n       {IntVal x} \\<in> sets (stock_measure t)\n 4. \\<And>x t.\n       val_type (RealVal x) = t \\<Longrightarrow>\n       {RealVal x} \\<in> sets (stock_measure t)", "qed (auto simp: sets_embed_measure)"], ["", "lemma emeasure_stock_measure_singleton_finite[simp]:\n    \"emeasure (stock_measure (val_type v)) {v} \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (stock_measure (val_type v)) {v} \\<noteq> \\<infinity>", "proof (induction v)"], ["proof (state)\ngoal (5 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>x.\n       emeasure (stock_measure (val_type (RealVal x))) {RealVal x} \\<noteq>\n       \\<infinity>\n 5. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "case (RealVal r)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>x.\n       emeasure (stock_measure (val_type (RealVal x))) {RealVal x} \\<noteq>\n       \\<infinity>\n 5. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "have A: \"{RealVal r} = RealVal ` {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {RealVal r} = RealVal ` {r}", "by simp"], ["proof (state)\nthis:\n  {RealVal r} = RealVal ` {r}\n\ngoal (5 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>x.\n       emeasure (stock_measure (val_type (RealVal x))) {RealVal x} \\<noteq>\n       \\<infinity>\n 5. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "have \"RealVal ` {r} \\<in> sets (embed_measure lborel RealVal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RealVal ` {r} \\<in> sets (embed_measure lborel RealVal)", "by (rule in_sets_embed_measure) simp"], ["proof (state)\nthis:\n  RealVal ` {r} \\<in> sets (embed_measure lborel RealVal)\n\ngoal (5 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>x.\n       emeasure (stock_measure (val_type (RealVal x))) {RealVal x} \\<noteq>\n       \\<infinity>\n 5. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "thus ?case"], ["proof (prove)\nusing this:\n  RealVal ` {r} \\<in> sets (embed_measure lborel RealVal)\n\ngoal (1 subgoal):\n 1. emeasure (stock_measure (val_type (RealVal r))) {RealVal r} \\<noteq>\n    \\<infinity>", "by (simp only: A val_type.simps stock_measure.simps emeasure_embed_measure\n                            inj_RealVal inj_vimage_image_eq) simp"], ["proof (state)\nthis:\n  emeasure (stock_measure (val_type (RealVal r))) {RealVal r} \\<noteq>\n  \\<infinity>\n\ngoal (4 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "case (PairVal v1 v2)"], ["proof (state)\nthis:\n  emeasure (stock_measure (val_type v1)) {v1} \\<noteq> \\<infinity>\n  emeasure (stock_measure (val_type v2)) {v2} \\<noteq> \\<infinity>\n\ngoal (4 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "let ?M = \"\\<lambda>x. stock_measure (val_type x)\""], ["proof (state)\ngoal (4 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "interpret sigma_finite_measure \"stock_measure (val_type v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_finite_measure (stock_measure (val_type v2))", "by (rule sigma_finite_stock_measure)"], ["proof (state)\ngoal (4 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "have A: \"{<|v1, v2|>} = (\\<lambda>(v1,v2). <|v1,v2|>) ` ({v1}\\<times>{v2})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {<|v1, v2|>} = (\\<lambda>(v1, v2). <|v1, v2|>) ` ({v1} \\<times> {v2})", "by simp"], ["proof (state)\nthis:\n  {<|v1, v2|>} = (\\<lambda>(v1, v2). <|v1, v2|>) ` ({v1} \\<times> {v2})\n\ngoal (4 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "have B: \"{v1}\\<times>{v2} \\<in> ?M v1 \\<Otimes>\\<^sub>M ?M v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v1} \\<times> {v2}\n    \\<in> sets\n           (stock_measure (val_type v1) \\<Otimes>\\<^sub>M\n            stock_measure (val_type v2))", "by (intro pair_measureI singleton_in_stock_measure) simp_all"], ["proof (state)\nthis:\n  {v1} \\<times> {v2}\n  \\<in> sets\n         (stock_measure (val_type v1) \\<Otimes>\\<^sub>M\n          stock_measure (val_type v2))\n\ngoal (4 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "hence \"emeasure (?M (<|v1,v2|>)) {<|v1,v2|>} = emeasure (?M v1) {v1} * emeasure (?M v2) {v2}\""], ["proof (prove)\nusing this:\n  {v1} \\<times> {v2}\n  \\<in> sets\n         (stock_measure (val_type v1) \\<Otimes>\\<^sub>M\n          stock_measure (val_type v2))\n\ngoal (1 subgoal):\n 1. emeasure (stock_measure (val_type <|v1, v2|>)) {<|v1, v2|>} =\n    emeasure (stock_measure (val_type v1)) {v1} *\n    emeasure (stock_measure (val_type v2)) {v2}", "by (simp only: stock_measure.simps val_type.simps A emeasure_embed_measure_image inj_PairVal\n                     inj_vimage_image_eq emeasure_pair_measure_Times singleton_in_stock_measure B)"], ["proof (state)\nthis:\n  emeasure (stock_measure (val_type <|v1, v2|>)) {<|v1, v2|>} =\n  emeasure (stock_measure (val_type v1)) {v1} *\n  emeasure (stock_measure (val_type v2)) {v2}\n\ngoal (4 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>\n 4. \\<And>v1 v2.\n       \\<lbrakk>emeasure (stock_measure (val_type v1)) {v1} \\<noteq>\n                \\<infinity>;\n        emeasure (stock_measure (val_type v2)) {v2} \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> emeasure (stock_measure (val_type <|v1, v2|>))\n                          {<|v1, v2|>} \\<noteq>\n                         \\<infinity>", "with PairVal.IH"], ["proof (chain)\npicking this:\n  emeasure (stock_measure (val_type v1)) {v1} \\<noteq> \\<infinity>\n  emeasure (stock_measure (val_type v2)) {v2} \\<noteq> \\<infinity>\n  emeasure (stock_measure (val_type <|v1, v2|>)) {<|v1, v2|>} =\n  emeasure (stock_measure (val_type v1)) {v1} *\n  emeasure (stock_measure (val_type v2)) {v2}", "show ?case"], ["proof (prove)\nusing this:\n  emeasure (stock_measure (val_type v1)) {v1} \\<noteq> \\<infinity>\n  emeasure (stock_measure (val_type v2)) {v2} \\<noteq> \\<infinity>\n  emeasure (stock_measure (val_type <|v1, v2|>)) {<|v1, v2|>} =\n  emeasure (stock_measure (val_type v1)) {v1} *\n  emeasure (stock_measure (val_type v2)) {v2}\n\ngoal (1 subgoal):\n 1. emeasure (stock_measure (val_type <|v1, v2|>)) {<|v1, v2|>} \\<noteq>\n    \\<infinity>", "by (simp add: ennreal_mult_eq_top_iff)"], ["proof (state)\nthis:\n  emeasure (stock_measure (val_type <|v1, v2|>)) {<|v1, v2|>} \\<noteq>\n  \\<infinity>\n\ngoal (3 subgoals):\n 1. emeasure (stock_measure (val_type UnitVal)) {UnitVal} \\<noteq>\n    \\<infinity>\n 2. \\<And>x.\n       emeasure (stock_measure (val_type (BoolVal x))) {BoolVal x} \\<noteq>\n       \\<infinity>\n 3. \\<And>x.\n       emeasure (stock_measure (val_type (IntVal x))) {IntVal x} \\<noteq>\n       \\<infinity>", "qed simp_all"], ["", "subsection \\<open>Measures on states\\<close>"], ["", "definition state_measure :: \"vname set \\<Rightarrow> (vname \\<Rightarrow> pdf_type) \\<Rightarrow> state measure\" where\n  \"state_measure V \\<Gamma> \\<equiv> \\<Pi>\\<^sub>M y\\<in>V. \\<Gamma> y\""], ["", "lemma state_measure_nonempty[simp]: \"space (state_measure V \\<Gamma>) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (state_measure V \\<Gamma>) \\<noteq> {}", "by (simp add: state_measure_def space_PiM PiE_eq_empty_iff)"], ["", "lemma space_state_measure: \"space (state_measure V \\<Gamma>) = (\\<Pi>\\<^sub>E y\\<in>V. type_universe (\\<Gamma> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (state_measure V \\<Gamma>) =\n    (\\<Pi>\\<^sub>E y\\<in>V. type_universe (\\<Gamma> y))", "by (simp add: state_measure_def space_PiM PiE_eq_empty_iff)"], ["", "lemma state_measure_var_type:\n    \"\\<sigma> \\<in> space (state_measure V \\<Gamma>) \\<Longrightarrow> x \\<in> V \\<Longrightarrow> val_type (\\<sigma> x) = \\<Gamma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<sigma> \\<in> space (state_measure V \\<Gamma>);\n     x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> val_type (\\<sigma> x) = \\<Gamma> x", "by (auto simp: state_measure_def space_PiM dest!: PiE_mem)"], ["", "lemma merge_in_state_measure:\n  \"x \\<in> space (state_measure A \\<Gamma>) \\<Longrightarrow> y \\<in> space (state_measure B \\<Gamma>) \\<Longrightarrow>\n      merge A B (x, y) \\<in> space (state_measure (A\\<union>B) \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> space (state_measure A \\<Gamma>);\n     y \\<in> space (state_measure B \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> merge A B (x, y)\n                      \\<in> space (state_measure (A \\<union> B) \\<Gamma>)", "unfolding state_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> space\n                      (Pi\\<^sub>M A\n                        (\\<lambda>x. stock_measure (\\<Gamma> x)));\n     y \\<in> space\n              (Pi\\<^sub>M B\n                (\\<lambda>x. stock_measure (\\<Gamma> x)))\\<rbrakk>\n    \\<Longrightarrow> merge A B (x, y)\n                      \\<in> space\n                             (Pi\\<^sub>M (A \\<union> B)\n                               (\\<lambda>x. stock_measure (\\<Gamma> x)))", "by (rule measurable_space, rule measurable_merge) (simp add: space_pair_measure)"], ["", "lemma measurable_merge_stock[measurable (raw)]:\n  \"f \\<in> N \\<rightarrow>\\<^sub>M state_measure V \\<Gamma> \\<Longrightarrow> g \\<in> N \\<rightarrow>\\<^sub>M state_measure V' \\<Gamma> \\<Longrightarrow>\n    (\\<lambda>x. merge V V' (f x, g x)) \\<in> N \\<rightarrow>\\<^sub>M state_measure (V \\<union> V') \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> N \\<rightarrow>\\<^sub>M state_measure V \\<Gamma>;\n     g \\<in> N \\<rightarrow>\\<^sub>M state_measure V' \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. merge V V' (f x, g x))\n                      \\<in> N \\<rightarrow>\\<^sub>M\n                            state_measure (V \\<union> V') \\<Gamma>", "by (auto simp: state_measure_def)"], ["", "lemma comp_in_state_measure:\n    assumes \"\\<sigma> \\<in> space (state_measure V \\<Gamma>)\"\n    shows \"\\<sigma> \\<circ> f \\<in> space (state_measure (f -` V) (\\<Gamma> \\<circ> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ> f\n    \\<in> space (state_measure (f -` V) (\\<Gamma> \\<circ> f))", "using assms"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> space (state_measure V \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ> f\n    \\<in> space (state_measure (f -` V) (\\<Gamma> \\<circ> f))", "by (auto simp: state_measure_def space_PiM)"], ["", "lemma sigma_finite_state_measure[intro]:\n    \"finite V \\<Longrightarrow> sigma_finite_measure (state_measure V \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V \\<Longrightarrow>\n    sigma_finite_measure (state_measure V \\<Gamma>)", "unfolding state_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V \\<Longrightarrow>\n    sigma_finite_measure\n     (Pi\\<^sub>M V (\\<lambda>x. stock_measure (\\<Gamma> x)))", "by (auto intro!: product_sigma_finite.sigma_finite simp: product_sigma_finite_def)"], ["", "subsection \\<open>Equalities of measure embeddings\\<close>"], ["", "lemma embed_measure_RealPairVal:\n   \"stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal", "have [simp]: \"(\\<lambda>(x, y). <| x ,  y |>) \\<circ> (\\<lambda>(x, y). (RealVal x, RealVal y)) = RealPairVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). <|x, y|>) \\<circ>\n    (\\<lambda>(x, y). (RealVal x, RealVal y)) =\n    RealPairVal", "unfolding RealPairVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). <|x, y|>) \\<circ>\n    (\\<lambda>(x, y). (RealVal x, RealVal y)) =\n    (\\<lambda>(x, y). <|RealVal x, RealVal y|>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). <|x, y|>) \\<circ>\n  (\\<lambda>(x, y). (RealVal x, RealVal y)) =\n  RealPairVal\n\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal", "have \"stock_measure (PRODUCT REAL REAL) =\n            embed_measure (embed_measure lborel (\\<lambda>(x, y). (RealVal x, RealVal y))) (case_prod PairVal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT REAL REAL) =\n    embed_measure\n     (embed_measure lborel (\\<lambda>(x, y). (RealVal x, RealVal y)))\n     (\\<lambda>(x, y). <|x, y|>)", "by (auto simp: embed_measure_prod sigma_finite_lborel lborel_prod)"], ["proof (state)\nthis:\n  stock_measure (PRODUCT REAL REAL) =\n  embed_measure\n   (embed_measure lborel (\\<lambda>(x, y). (RealVal x, RealVal y)))\n   (\\<lambda>(x, y). <|x, y|>)\n\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal", "also"], ["proof (state)\nthis:\n  stock_measure (PRODUCT REAL REAL) =\n  embed_measure\n   (embed_measure lborel (\\<lambda>(x, y). (RealVal x, RealVal y)))\n   (\\<lambda>(x, y). <|x, y|>)\n\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal", "have \"... = embed_measure lborel RealPairVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_measure\n     (embed_measure lborel (\\<lambda>(x, y). (RealVal x, RealVal y)))\n     (\\<lambda>(x, y). <|x, y|>) =\n    embed_measure lborel RealPairVal", "by (subst embed_measure_comp) (auto intro!: injI)"], ["proof (state)\nthis:\n  embed_measure\n   (embed_measure lborel (\\<lambda>(x, y). (RealVal x, RealVal y)))\n   (\\<lambda>(x, y). <|x, y|>) =\n  embed_measure lborel RealPairVal\n\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal", "finally"], ["proof (chain)\npicking this:\n  stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal", "show ?thesis"], ["proof (prove)\nusing this:\n  stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal\n\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal", "."], ["proof (state)\nthis:\n  stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma embed_measure_IntPairVal:\n  \"stock_measure (PRODUCT INTEG INTEG) = count_space (range IntPairVal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT INTEG INTEG) = count_space (range IntPairVal)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT INTEG INTEG) = count_space (range IntPairVal)", "have [simp]: \"(\\<lambda>(x, y). <| x ,  y |>) ` (range IntVal \\<times> range IntVal) = range IntPairVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). <|x, y|>) ` (range IntVal \\<times> range IntVal) =\n    range IntPairVal", "by (auto simp: IntPairVal_def)"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). <|x, y|>) ` (range IntVal \\<times> range IntVal) =\n  range IntPairVal\n\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT INTEG INTEG) = count_space (range IntPairVal)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT INTEG INTEG) = count_space (range IntPairVal)", "using count_space_IntVal_prod"], ["proof (prove)\nusing this:\n  stock_measure INTEG \\<Otimes>\\<^sub>M stock_measure INTEG =\n  count_space (range IntVal \\<times> range IntVal)\n\ngoal (1 subgoal):\n 1. stock_measure (PRODUCT INTEG INTEG) = count_space (range IntPairVal)", "by (auto simp: embed_measure_prod embed_measure_count_space)"], ["proof (state)\nthis:\n  stock_measure (PRODUCT INTEG INTEG) = count_space (range IntPairVal)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Monadic operations on values\\<close>"], ["", "definition \"return_val x = return (stock_measure (val_type x)) x\""], ["", "lemma sets_return_val[measurable_cong]: \"sets (return_val x) = sets (stock_measure (val_type x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (return_val x) = sets (stock_measure (val_type x))", "by (simp add: return_val_def)"], ["", "lemma measurable_return_val[simp]:\n    \"return_val \\<in> measurable (stock_measure t) (subprob_algebra (stock_measure t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_val\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M\n          subprob_algebra (stock_measure t)", "unfolding return_val_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. return (stock_measure (val_type x)) x)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M\n          subprob_algebra (stock_measure t)", "apply (subst measurable_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure t) \\<Longrightarrow>\n       return (stock_measure (val_type w)) w = ?g1 w\n 2. ?g1\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M\n          subprob_algebra (stock_measure t)", "apply (subst type_universe_type[THEN iffD1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure t) \\<Longrightarrow>\n       w \\<in> type_universe (?y3 w)\n 2. \\<And>w.\n       w \\<in> space (stock_measure t) \\<Longrightarrow>\n       return (stock_measure (?y3 w)) w = ?g3 w w\n 3. (\\<lambda>w. ?g3 w w)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M\n          subprob_algebra (stock_measure t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> space (stock_measure t) \\<Longrightarrow>\n       return (stock_measure t) w = ?g3 w w\n 2. (\\<lambda>w. ?g3 w w)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M\n          subprob_algebra (stock_measure t)", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. return (stock_measure t)\n    \\<in> stock_measure t \\<rightarrow>\\<^sub>M\n          subprob_algebra (stock_measure t)", "apply (rule return_measurable)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind_return_val:\n  assumes \"space M \\<noteq> {}\" \"f \\<in> measurable M (stock_measure t')\"\n  shows \"M \\<bind> (\\<lambda>x. return_val (f x)) = distr M (stock_measure t') f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> (\\<lambda>x. return_val (f x)) = distr M (stock_measure t') f", "using assms"], ["proof (prove)\nusing this:\n  space M \\<noteq> {}\n  f \\<in> M \\<rightarrow>\\<^sub>M stock_measure t'\n\ngoal (1 subgoal):\n 1. M \\<bind> (\\<lambda>x. return_val (f x)) = distr M (stock_measure t') f", "by (subst bind_return_distr[symmetric])\n     (auto simp: return_val_def intro!: bind_cong dest: measurable_stock_measure_val_type)"], ["", "lemma bind_return_val':\n  assumes \"val_type x = t\" \"f \\<in> measurable (stock_measure t) (stock_measure t')\"\n  shows \"return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)", "have \"return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return (stock_measure t') (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_val x \\<bind> (\\<lambda>x. return_val (f x)) =\n    return (stock_measure t') (f x)", "apply (subst bind_return_val, unfold return_val_def, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f \\<in> return (stock_measure (val_type x)) x \\<rightarrow>\\<^sub>M\n            stock_measure ?t'\n 2. distr (return (stock_measure (val_type x)) x) (stock_measure ?t') f =\n    return (stock_measure t') (f x)", "apply (insert assms, simp cong: measurable_cong_sets) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (return (stock_measure (val_type x)) x) (stock_measure t') f =\n    return (stock_measure t') (f x)", "apply (subst distr_return, simp_all add: assms type_universe_def\n                                        del: type_universe_type)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  return_val x \\<bind> (\\<lambda>x. return_val (f x)) =\n  return (stock_measure t') (f x)\n\ngoal (1 subgoal):\n 1. return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)", "also"], ["proof (state)\nthis:\n  return_val x \\<bind> (\\<lambda>x. return_val (f x)) =\n  return (stock_measure t') (f x)\n\ngoal (1 subgoal):\n 1. return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)", "from assms(2)"], ["proof (chain)\npicking this:\n  f \\<in> stock_measure t \\<rightarrow>\\<^sub>M stock_measure t'", "have \"f x \\<in> space (stock_measure t')\""], ["proof (prove)\nusing this:\n  f \\<in> stock_measure t \\<rightarrow>\\<^sub>M stock_measure t'\n\ngoal (1 subgoal):\n 1. f x \\<in> space (stock_measure t')", "by (rule measurable_space)\n       (simp add: assms(1) type_universe_def del: type_universe_type)"], ["proof (state)\nthis:\n  f x \\<in> space (stock_measure t')\n\ngoal (1 subgoal):\n 1. return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)", "hence \"return (stock_measure t') (f x) = return_val (f x)\""], ["proof (prove)\nusing this:\n  f x \\<in> space (stock_measure t')\n\ngoal (1 subgoal):\n 1. return (stock_measure t') (f x) = return_val (f x)", "by (simp add: return_val_def)"], ["proof (state)\nthis:\n  return (stock_measure t') (f x) = return_val (f x)\n\ngoal (1 subgoal):\n 1. return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)", "finally"], ["proof (chain)\npicking this:\n  return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)\n\ngoal (1 subgoal):\n 1. return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)", "."], ["proof (state)\nthis:\n  return_val x \\<bind> (\\<lambda>x. return_val (f x)) = return_val (f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bind_return_val'':\n  assumes \"f \\<in> measurable (stock_measure (val_type x)) (subprob_algebra M)\"\n  shows \"return_val x \\<bind> f = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_val x \\<bind> f = f x", "unfolding return_val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. return (stock_measure (val_type x)) x \\<bind> f = f x", "by (subst bind_return[OF assms]) simp_all"], ["", "lemma bind_assoc_return_val:\n  assumes sets_M: \"sets M = sets (stock_measure t)\"\n  assumes Mf: \"f \\<in> measurable (stock_measure t) (stock_measure t')\"\n  assumes Mg: \"g \\<in> measurable (stock_measure t') (stock_measure t'')\"\n  shows \"(M \\<bind> (\\<lambda>x. return_val (f x))) \\<bind> (\\<lambda>x. return_val (g x)) =\n             M \\<bind> (\\<lambda>x. return_val (g (f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n    (\\<lambda>x. return_val (g x)) =\n    M \\<bind> (\\<lambda>x. return_val (g (f x)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n    (\\<lambda>x. return_val (g x)) =\n    M \\<bind> (\\<lambda>x. return_val (g (f x)))", "have \"(M \\<bind> (\\<lambda>x. return_val (f x))) \\<bind> (\\<lambda>x. return_val (g x)) =\n           M \\<bind> (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n    (\\<lambda>x. return_val (g x)) =\n    M \\<bind>\n    (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x)))", "apply (subst bind_assoc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. return_val (f x))\n    \\<in> M \\<rightarrow>\\<^sub>M subprob_algebra ?N\n 2. (\\<lambda>x. return_val (g x))\n    \\<in> ?N \\<rightarrow>\\<^sub>M subprob_algebra ?R\n 3. M \\<bind>\n    (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x))) =\n    M \\<bind>\n    (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x)))", "apply (rule measurable_compose[OF _ measurable_return_val])"], ["proof (prove)\ngoal (3 subgoals):\n 1. f \\<in> M \\<rightarrow>\\<^sub>M stock_measure ?t2\n 2. (\\<lambda>x. return_val (g x))\n    \\<in> stock_measure ?t2 \\<rightarrow>\\<^sub>M subprob_algebra ?R\n 3. M \\<bind>\n    (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x))) =\n    M \\<bind>\n    (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x)))", "apply (subst measurable_cong_sets[OF sets_M refl], rule Mf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. return_val (g x))\n    \\<in> stock_measure t' \\<rightarrow>\\<^sub>M subprob_algebra ?R\n 2. M \\<bind>\n    (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x))) =\n    M \\<bind>\n    (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x)))", "apply (rule measurable_compose[OF Mg measurable_return_val], rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n  (\\<lambda>x. return_val (g x)) =\n  M \\<bind>\n  (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x)))\n\ngoal (1 subgoal):\n 1. M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n    (\\<lambda>x. return_val (g x)) =\n    M \\<bind> (\\<lambda>x. return_val (g (f x)))", "also"], ["proof (state)\nthis:\n  M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n  (\\<lambda>x. return_val (g x)) =\n  M \\<bind>\n  (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x)))\n\ngoal (1 subgoal):\n 1. M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n    (\\<lambda>x. return_val (g x)) =\n    M \\<bind> (\\<lambda>x. return_val (g (f x)))", "have \"... = M \\<bind> (\\<lambda>x. return_val (g (f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind>\n    (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x))) =\n    M \\<bind> (\\<lambda>x. return_val (g (f x)))", "apply (intro bind_cong refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       return_val (f x) \\<bind> (\\<lambda>x. return_val (g x)) =\n       return_val (g (f x))", "apply (subst (asm) sets_eq_imp_space_eq[OF sets_M])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (stock_measure t) \\<Longrightarrow>\n       return_val (f x) \\<bind> (\\<lambda>x. return_val (g x)) =\n       return_val (g (f x))", "apply (drule measurable_space[OF Mf])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       f x \\<in> space (stock_measure t') \\<Longrightarrow>\n       return_val (f x) \\<bind> (\\<lambda>x. return_val (g x)) =\n       return_val (g (f x))", "apply (subst bind_return_val'[where t = t' and t' = t''])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       f x \\<in> space (stock_measure t') \\<Longrightarrow>\n       val_type (f x) = t'\n 2. \\<And>x.\n       f x \\<in> space (stock_measure t') \\<Longrightarrow>\n       g \\<in> stock_measure t' \\<rightarrow>\\<^sub>M stock_measure t''\n 3. \\<And>x.\n       f x \\<in> space (stock_measure t') \\<Longrightarrow>\n       return_val (g (f x)) = return_val (g (f x))", "apply (simp_all add: Mg)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  M \\<bind>\n  (\\<lambda>x. return_val (f x) \\<bind> (\\<lambda>x. return_val (g x))) =\n  M \\<bind> (\\<lambda>x. return_val (g (f x)))\n\ngoal (1 subgoal):\n 1. M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n    (\\<lambda>x. return_val (g x)) =\n    M \\<bind> (\\<lambda>x. return_val (g (f x)))", "finally"], ["proof (chain)\npicking this:\n  M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n  (\\<lambda>x. return_val (g x)) =\n  M \\<bind> (\\<lambda>x. return_val (g (f x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n  (\\<lambda>x. return_val (g x)) =\n  M \\<bind> (\\<lambda>x. return_val (g (f x)))\n\ngoal (1 subgoal):\n 1. M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n    (\\<lambda>x. return_val (g x)) =\n    M \\<bind> (\\<lambda>x. return_val (g (f x)))", "."], ["proof (state)\nthis:\n  M \\<bind> (\\<lambda>x. return_val (f x)) \\<bind>\n  (\\<lambda>x. return_val (g x)) =\n  M \\<bind> (\\<lambda>x. return_val (g (f x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bind_return_val_distr:\n  assumes sets_M: \"sets M = sets (stock_measure t)\"\n  assumes Mf: \"f \\<in> measurable (stock_measure t) (stock_measure t')\"\n  shows \"M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f", "have \"M \\<bind> return_val \\<circ> f = M \\<bind> return (stock_measure t') \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> return_val \\<circ> f =\n    M \\<bind> return (stock_measure t') \\<circ> f", "apply (intro bind_cong refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       (return_val \\<circ> f) x = (return (stock_measure t') \\<circ> f) x", "apply (subst (asm) sets_eq_imp_space_eq[OF sets_M])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (stock_measure t) \\<Longrightarrow>\n       (return_val \\<circ> f) x = (return (stock_measure t') \\<circ> f) x", "apply (drule measurable_space[OF Mf])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       f x \\<in> space (stock_measure t') \\<Longrightarrow>\n       (return_val \\<circ> f) x = (return (stock_measure t') \\<circ> f) x", "apply (simp add: return_val_def o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  M \\<bind> return_val \\<circ> f =\n  M \\<bind> return (stock_measure t') \\<circ> f\n\ngoal (1 subgoal):\n 1. M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f", "also"], ["proof (state)\nthis:\n  M \\<bind> return_val \\<circ> f =\n  M \\<bind> return (stock_measure t') \\<circ> f\n\ngoal (1 subgoal):\n 1. M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f", "have \"... = distr M (stock_measure t') f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<bind> return (stock_measure t') \\<circ> f =\n    distr M (stock_measure t') f", "apply (rule bind_return_distr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. space M \\<noteq> {}\n 2. f \\<in> M \\<rightarrow>\\<^sub>M stock_measure t'", "apply (simp add: sets_eq_imp_space_eq[OF sets_M])"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> M \\<rightarrow>\\<^sub>M stock_measure t'", "apply (subst measurable_cong_sets[OF sets_M refl], rule Mf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  M \\<bind> return (stock_measure t') \\<circ> f =\n  distr M (stock_measure t') f\n\ngoal (1 subgoal):\n 1. M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f", "finally"], ["proof (chain)\npicking this:\n  M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f", "show ?thesis"], ["proof (prove)\nusing this:\n  M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f\n\ngoal (1 subgoal):\n 1. M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f", "."], ["proof (state)\nthis:\n  M \\<bind> return_val \\<circ> f = distr M (stock_measure t') f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lifting of functions\\<close>"], ["", "definition lift_RealVal where\n  \"lift_RealVal f \\<equiv> \\<lambda> RealVal v \\<Rightarrow> RealVal (f v) | _ \\<Rightarrow> RealVal (f 0)\""], ["", "definition lift_IntVal where\n  \"lift_IntVal f \\<equiv> \\<lambda> IntVal v \\<Rightarrow> IntVal (f v) | _ \\<Rightarrow> IntVal (f 0)\""], ["", "definition lift_RealIntVal where\n  \"lift_RealIntVal f g \\<equiv> \\<lambda> IntVal v \\<Rightarrow> IntVal (f v) | RealVal v \\<Rightarrow> RealVal (g v)\""], ["", "definition lift_RealIntVal2 where\n  \"lift_RealIntVal2 f g \\<equiv>\n    map_int_pair (\\<lambda>a b. IntVal (f a b))\n    (map_real_pair (\\<lambda>a b. RealVal (g a b))\n      id)\""], ["", "definition  lift_Comp where\n  \"lift_Comp f g \\<equiv> map_int_pair (\\<lambda>a b. BoolVal (f a b))\n    (map_real_pair (\\<lambda>a b. BoolVal (g a b))\n      (\\<lambda>_. FALSE))\""], ["", "lemma lift_RealVal_eq: \"lift_RealVal f (RealVal x) = RealVal (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_RealVal f (RealVal x) = RealVal (f x)", "by (simp add: lift_RealVal_def)"], ["", "lemma lift_RealIntVal_Real:\n  \"x \\<in> space (stock_measure REAL) \\<Longrightarrow> lift_RealIntVal f g x = lift_RealVal g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space (stock_measure REAL) \\<Longrightarrow>\n    lift_RealIntVal f g x = lift_RealVal g x", "by (auto simp: space_embed_measure lift_RealIntVal_def lift_RealVal_def)"], ["", "lemma lift_RealIntVal_Int:\n  \"x \\<in> space (stock_measure INTEG) \\<Longrightarrow> lift_RealIntVal f g x = lift_IntVal f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space (stock_measure INTEG) \\<Longrightarrow>\n    lift_RealIntVal f g x = lift_IntVal f x", "by (auto simp: space_embed_measure lift_RealIntVal_def lift_IntVal_def)"], ["", "declare stock_measure.simps[simp del]"], ["", "lemma measurable_lift_RealVal[measurable]:\n  assumes [measurable]: \"f \\<in> borel_measurable borel\"\n  shows \"lift_RealVal f \\<in> measurable REAL REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_RealVal f\n    \\<in> stock_measure REAL \\<rightarrow>\\<^sub>M stock_measure REAL", "unfolding lift_RealVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case x of RealVal v \\<Rightarrow> RealVal (f v)\n        | _ \\<Rightarrow> RealVal (f 0))\n    \\<in> stock_measure REAL \\<rightarrow>\\<^sub>M stock_measure REAL", "by (auto intro!: val_case_stock_measurable)"], ["", "lemma measurable_lift_IntVal[simp]: \"lift_IntVal f \\<in> range IntVal \\<rightarrow> range IntVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_IntVal f \\<in> range IntVal \\<rightarrow> range IntVal", "by (auto simp: lift_IntVal_def)"], ["", "lemma measurable_lift_IntVal'[measurable]: \"lift_IntVal f \\<in> measurable INTEG INTEG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_IntVal f\n    \\<in> stock_measure INTEG \\<rightarrow>\\<^sub>M stock_measure INTEG", "unfolding lift_IntVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case x of IntVal v \\<Rightarrow> IntVal (f v)\n        | _ \\<Rightarrow> IntVal (f 0))\n    \\<in> stock_measure INTEG \\<rightarrow>\\<^sub>M stock_measure INTEG", "by (auto intro!: val_case_stock_measurable)"], ["", "lemma split_apply: \"(case x of (a, b) \\<Rightarrow> f a b) y = (case x of (a, b) \\<Rightarrow> f a b y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of (a, b) \\<Rightarrow> f a b) y =\n    (case x of (a, b) \\<Rightarrow> f a b y)", "by (cases x) simp"], ["", "lemma measurable_lift_Comp_RealVal[measurable]:\n  assumes [measurable]: \"Measurable.pred (borel \\<Otimes>\\<^sub>M borel) (case_prod g)\"\n  shows \"lift_Comp f g \\<in> measurable (PRODUCT REAL REAL) BOOL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_Comp f g\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M\n          stock_measure BOOL", "unfolding lift_Comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_int_pair (\\<lambda>a b. BoolVal (f a b))\n     (map_real_pair (\\<lambda>a b. BoolVal (g a b)) (\\<lambda>_. FALSE))\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M\n          stock_measure BOOL", "by measurable"], ["", "lemma measurable_lift_Comp_IntVal[simp]:\n  \"lift_Comp f g \\<in> measurable (PRODUCT INTEG INTEG) BOOL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_Comp f g\n    \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M\n          stock_measure BOOL", "unfolding lift_Comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_int_pair (\\<lambda>a b. BoolVal (f a b))\n     (map_real_pair (\\<lambda>a b. BoolVal (g a b)) (\\<lambda>_. FALSE))\n    \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M\n          stock_measure BOOL", "by (auto intro!: val_case_stock_measurable)"], ["", "lemma measurable_lift_RealIntVal_IntVal[simp]: \"lift_RealIntVal f g \\<in> range IntVal \\<rightarrow> range IntVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_RealIntVal f g \\<in> range IntVal \\<rightarrow> range IntVal", "by (auto simp: embed_measure_count_space lift_RealIntVal_def)"], ["", "lemma measurable_lift_RealIntVal_IntVal'[measurable]:\n   \"lift_RealIntVal f g \\<in> measurable INTEG INTEG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_RealIntVal f g\n    \\<in> stock_measure INTEG \\<rightarrow>\\<^sub>M stock_measure INTEG", "by (auto simp: lift_RealIntVal_def intro!: val_case_stock_measurable)"], ["", "lemma measurable_lift_RealIntVal_RealVal[measurable]:\n  assumes [measurable]: \"g \\<in> borel_measurable borel\"\n  shows \"lift_RealIntVal f g \\<in> measurable REAL REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_RealIntVal f g\n    \\<in> stock_measure REAL \\<rightarrow>\\<^sub>M stock_measure REAL", "unfolding lift_RealIntVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case x of IntVal v \\<Rightarrow> IntVal (f v)\n        | RealVal v \\<Rightarrow> RealVal (g v))\n    \\<in> stock_measure REAL \\<rightarrow>\\<^sub>M stock_measure REAL", "by (auto intro!: val_case_stock_measurable)"], ["", "lemma measurable_lift_RealIntVal2_IntVal[measurable]:\n  \"lift_RealIntVal2 f g \\<in> measurable (PRODUCT INTEG INTEG) INTEG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_RealIntVal2 f g\n    \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M\n          stock_measure INTEG", "unfolding lift_RealIntVal2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_int_pair (\\<lambda>a b. IntVal (f a b))\n     (map_real_pair (\\<lambda>a b. RealVal (g a b)) id)\n    \\<in> stock_measure (PRODUCT INTEG INTEG) \\<rightarrow>\\<^sub>M\n          stock_measure INTEG", "by (auto intro!: val_case_stock_measurable)"], ["", "lemma measurable_lift_RealIntVal2_RealVal[measurable]:\n  assumes [measurable]: \"case_prod g \\<in> borel_measurable (borel \\<Otimes>\\<^sub>M borel)\"\n  shows \"lift_RealIntVal2 f g \\<in> measurable (PRODUCT REAL REAL) REAL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_RealIntVal2 f g\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M\n          stock_measure REAL", "unfolding lift_RealIntVal2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_int_pair (\\<lambda>a b. IntVal (f a b))\n     (map_real_pair (\\<lambda>a b. RealVal (g a b)) id)\n    \\<in> stock_measure (PRODUCT REAL REAL) \\<rightarrow>\\<^sub>M\n          stock_measure REAL", "by measurable"], ["", "lemma distr_lift_RealVal:\n  fixes f\n  assumes Mf[measurable]: \"f \\<in> borel_measurable borel\"\n  assumes pdens: \"has_subprob_density M (stock_measure REAL) \\<delta>\"\n  assumes dens': \"\\<And>M \\<delta>. has_subprob_density M lborel \\<delta> \\<Longrightarrow> has_density (distr M borel f) lborel (g \\<delta>)\"\n  defines \"N \\<equiv> distr M (stock_measure REAL) (lift_RealVal f)\"\n  shows \"has_density N (stock_measure REAL) (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_density N (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)", "proof (rule has_densityI)"], ["proof (state)\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "from assms(2)"], ["proof (chain)\npicking this:\n  has_subprob_density M (stock_measure REAL) \\<delta>", "have dens: \"has_density M (stock_measure REAL) \\<delta>\""], ["proof (prove)\nusing this:\n  has_subprob_density M (stock_measure REAL) \\<delta>\n\ngoal (1 subgoal):\n 1. has_density M (stock_measure REAL) \\<delta>", "unfolding has_subprob_density_def"], ["proof (prove)\nusing this:\n  has_density M (stock_measure REAL) \\<delta> \\<and> subprob_space M\n\ngoal (1 subgoal):\n 1. has_density M (stock_measure REAL) \\<delta>", "by simp"], ["proof (state)\nthis:\n  has_density M (stock_measure REAL) \\<delta>\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "from dens"], ["proof (chain)\npicking this:\n  has_density M (stock_measure REAL) \\<delta>", "have sets_M[measurable_cong]: \"sets M = sets REAL\""], ["proof (prove)\nusing this:\n  has_density M (stock_measure REAL) \\<delta>\n\ngoal (1 subgoal):\n 1. sets M = sets (stock_measure REAL)", "by (auto dest: has_densityD)"], ["proof (state)\nthis:\n  sets M = sets (stock_measure REAL)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "note measurable_embed_measure1[measurable del]"], ["proof (state)\nthis:\n  (\\<lambda>x. ?g (?f x))\n  \\<in> ?M \\<rightarrow>\\<^sub>M ?N \\<Longrightarrow>\n  ?g \\<in> embed_measure ?M ?f \\<rightarrow>\\<^sub>M ?N\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have \"N = distr M (stock_measure REAL) (lift_RealVal f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = distr M (stock_measure REAL) (lift_RealVal f)", "by (simp add: N_def)"], ["proof (state)\nthis:\n  N = distr M (stock_measure REAL) (lift_RealVal f)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  N = distr M (stock_measure REAL) (lift_RealVal f)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have \"\\<dots> = distr M (stock_measure REAL) (RealVal \\<circ> f \\<circ> extract_real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr M (stock_measure REAL) (lift_RealVal f) =\n    distr M (stock_measure REAL) (RealVal \\<circ> f \\<circ> extract_real)", "using sets_eq_imp_space_eq[OF sets_M]"], ["proof (prove)\nusing this:\n  space M = space (stock_measure REAL)\n\ngoal (1 subgoal):\n 1. distr M (stock_measure REAL) (lift_RealVal f) =\n    distr M (stock_measure REAL) (RealVal \\<circ> f \\<circ> extract_real)", "by (intro distr_cong) (auto simp: lift_RealVal_def stock_measure.simps space_embed_measure)"], ["proof (state)\nthis:\n  distr M (stock_measure REAL) (lift_RealVal f) =\n  distr M (stock_measure REAL) (RealVal \\<circ> f \\<circ> extract_real)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr M (stock_measure REAL) (lift_RealVal f) =\n  distr M (stock_measure REAL) (RealVal \\<circ> f \\<circ> extract_real)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have \"... = distr (distr (distr M lborel extract_real) borel f) (stock_measure REAL) RealVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr M (stock_measure REAL) (RealVal \\<circ> f \\<circ> extract_real) =\n    distr (distr (distr M lborel extract_real) borel f) (stock_measure REAL)\n     RealVal", "by (subst distr_distr)\n       (simp_all add: distr_distr[OF _ measurable_comp[OF _ Mf]] comp_assoc)"], ["proof (state)\nthis:\n  distr M (stock_measure REAL) (RealVal \\<circ> f \\<circ> extract_real) =\n  distr (distr (distr M lborel extract_real) borel f) (stock_measure REAL)\n   RealVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr M (stock_measure REAL) (RealVal \\<circ> f \\<circ> extract_real) =\n  distr (distr (distr M lborel extract_real) borel f) (stock_measure REAL)\n   RealVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have dens'': \"has_density (distr (distr M lborel extract_real) borel f) lborel (g (\\<delta> \\<circ> RealVal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_density (distr (distr M lborel extract_real) borel f) lborel\n     (g (\\<delta> \\<circ> RealVal))", "by (intro dens' has_subprob_density_embed_measure'') (insert pdens, simp_all add: extract_real_def stock_measure.simps)"], ["proof (state)\nthis:\n  has_density (distr (distr M lborel extract_real) borel f) lborel\n   (g (\\<delta> \\<circ> RealVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "hence \"distr (distr M lborel extract_real) borel f = density lborel (g (\\<delta> \\<circ> RealVal))\""], ["proof (prove)\nusing this:\n  has_density (distr (distr M lborel extract_real) borel f) lborel\n   (g (\\<delta> \\<circ> RealVal))\n\ngoal (1 subgoal):\n 1. distr (distr M lborel extract_real) borel f =\n    density lborel (g (\\<delta> \\<circ> RealVal))", "by (rule has_densityD)"], ["proof (state)\nthis:\n  distr (distr M lborel extract_real) borel f =\n  density lborel (g (\\<delta> \\<circ> RealVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr (distr M lborel extract_real) borel f =\n  density lborel (g (\\<delta> \\<circ> RealVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have \"distr ... (stock_measure REAL) RealVal = embed_measure ... RealVal\" (is \"_ = ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (density lborel (g (\\<delta> \\<circ> RealVal)))\n     (stock_measure REAL) RealVal =\n    embed_measure (density lborel (g (\\<delta> \\<circ> RealVal))) RealVal", "by (subst embed_measure_eq_distr[OF inj_RealVal], intro distr_cong)\n       (simp_all add: sets_embed_measure stock_measure.simps)"], ["proof (state)\nthis:\n  distr (density lborel (g (\\<delta> \\<circ> RealVal))) (stock_measure REAL)\n   RealVal =\n  embed_measure (density lborel (g (\\<delta> \\<circ> RealVal))) RealVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr (density lborel (g (\\<delta> \\<circ> RealVal))) (stock_measure REAL)\n   RealVal =\n  embed_measure (density lborel (g (\\<delta> \\<circ> RealVal))) RealVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have \"... = density (embed_measure lborel RealVal) (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_measure (density lborel (g (\\<delta> \\<circ> RealVal))) RealVal =\n    density (embed_measure lborel RealVal)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)", "using dens''[unfolded o_def]"], ["proof (prove)\nusing this:\n  has_density (distr (distr M lborel extract_real) borel f) lborel\n   (g (\\<lambda>x. \\<delta> (RealVal x)))\n\ngoal (1 subgoal):\n 1. embed_measure (density lborel (g (\\<delta> \\<circ> RealVal))) RealVal =\n    density (embed_measure lborel RealVal)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)", "apply (subst density_embed_measure', simp, simp add: extract_real_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. has_density (distr (distr M lborel extract_real) borel f) lborel\n     (g (\\<lambda>x. \\<delta> (RealVal x))) \\<Longrightarrow>\n    g (\\<lambda>x. \\<delta> (RealVal x)) \\<in> borel_measurable lborel\n 2. has_density (distr (distr M lborel extract_real) borel f) lborel\n     (g (\\<lambda>x. \\<delta> (RealVal x))) \\<Longrightarrow>\n    embed_measure (density lborel (g (\\<delta> \\<circ> RealVal))) RealVal =\n    embed_measure (density lborel (g (\\<lambda>x. \\<delta> (RealVal x))))\n     RealVal", "apply (erule has_densityD, simp add: o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  embed_measure (density lborel (g (\\<delta> \\<circ> RealVal))) RealVal =\n  density (embed_measure lborel RealVal)\n   (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "finally"], ["proof (chain)\npicking this:\n  N =\n  density (embed_measure lborel RealVal)\n   (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)", "show \"N = density (stock_measure REAL) (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\""], ["proof (prove)\nusing this:\n  N =\n  density (embed_measure lborel RealVal)\n   (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n\ngoal (1 subgoal):\n 1. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)", "by (simp add: stock_measure.simps)"], ["proof (state)\nthis:\n  N =\n  density (stock_measure REAL)\n   (g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real)\n\ngoal (2 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. space (stock_measure REAL) \\<noteq> {}", "from dens''[unfolded o_def, THEN has_densityD(1)]  measurable_extract_real"], ["proof (chain)\npicking this:\n  g (\\<lambda>x. \\<delta> (RealVal x)) \\<in> borel_measurable lborel\n  extract_real \\<in> borel_measurable (stock_measure REAL)", "show \"g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real \\<in> borel_measurable (stock_measure REAL)\""], ["proof (prove)\nusing this:\n  g (\\<lambda>x. \\<delta> (RealVal x)) \\<in> borel_measurable lborel\n  extract_real \\<in> borel_measurable (stock_measure REAL)\n\ngoal (1 subgoal):\n 1. g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)", "by (intro measurable_comp) auto"], ["proof (state)\nthis:\n  g (\\<lambda>x. \\<delta> (RealVal x)) \\<circ> extract_real\n  \\<in> borel_measurable (stock_measure REAL)\n\ngoal (1 subgoal):\n 1. space (stock_measure REAL) \\<noteq> {}", "qed (subst space_stock_measure, simp)"], ["", "lemma distr_lift_IntVal:\n  fixes f\n  assumes pdens: \"has_density M (stock_measure INTEG) \\<delta>\"\n  assumes dens': \"\\<And>M \\<delta>. has_density M (count_space UNIV) \\<delta> \\<Longrightarrow>\n                            has_density (distr M (count_space UNIV) f) (count_space UNIV) (g \\<delta>)\"\n  defines \"N \\<equiv> distr M (stock_measure INTEG) (lift_IntVal f)\"\n  shows \"has_density N (stock_measure INTEG) (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_density N (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)", "proof (rule has_densityI)"], ["proof (state)\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "let ?R = \"count_space UNIV\" and ?S = \"count_space (range IntVal)\""], ["proof (state)\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have Mf: \"f \\<in> measurable ?R ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space UNIV", "by simp"], ["proof (state)\nthis:\n  f \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space UNIV\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "from assms(1)"], ["proof (chain)\npicking this:\n  has_density M (stock_measure INTEG) \\<delta>", "have dens: \"has_density M (stock_measure INTEG) \\<delta>\""], ["proof (prove)\nusing this:\n  has_density M (stock_measure INTEG) \\<delta>\n\ngoal (1 subgoal):\n 1. has_density M (stock_measure INTEG) \\<delta>", "unfolding has_subprob_density_def"], ["proof (prove)\nusing this:\n  has_density M (stock_measure INTEG) \\<delta>\n\ngoal (1 subgoal):\n 1. has_density M (stock_measure INTEG) \\<delta>", "by simp"], ["proof (state)\nthis:\n  has_density M (stock_measure INTEG) \\<delta>\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "from dens"], ["proof (chain)\npicking this:\n  has_density M (stock_measure INTEG) \\<delta>", "have sets_M[measurable_cong]: \"sets M = sets INTEG\""], ["proof (prove)\nusing this:\n  has_density M (stock_measure INTEG) \\<delta>\n\ngoal (1 subgoal):\n 1. sets M = sets (stock_measure INTEG)", "by (auto dest!: has_densityD(2))"], ["proof (state)\nthis:\n  sets M = sets (stock_measure INTEG)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have \"N = distr M (stock_measure INTEG) (lift_IntVal f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = distr M (stock_measure INTEG) (lift_IntVal f)", "by (simp add: N_def)"], ["proof (state)\nthis:\n  N = distr M (stock_measure INTEG) (lift_IntVal f)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  N = distr M (stock_measure INTEG) (lift_IntVal f)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have \"\\<dots> = distr M (stock_measure INTEG) (IntVal \\<circ> f \\<circ> extract_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr M (stock_measure INTEG) (lift_IntVal f) =\n    distr M (stock_measure INTEG) (IntVal \\<circ> f \\<circ> extract_int)", "using sets_eq_imp_space_eq[OF sets_M]"], ["proof (prove)\nusing this:\n  space M = space (stock_measure INTEG)\n\ngoal (1 subgoal):\n 1. distr M (stock_measure INTEG) (lift_IntVal f) =\n    distr M (stock_measure INTEG) (IntVal \\<circ> f \\<circ> extract_int)", "by (intro distr_cong) (auto simp: space_embed_measure lift_IntVal_def stock_measure.simps)"], ["proof (state)\nthis:\n  distr M (stock_measure INTEG) (lift_IntVal f) =\n  distr M (stock_measure INTEG) (IntVal \\<circ> f \\<circ> extract_int)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr M (stock_measure INTEG) (lift_IntVal f) =\n  distr M (stock_measure INTEG) (IntVal \\<circ> f \\<circ> extract_int)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have \"\\<dots> = distr (distr (distr M ?R extract_int) ?R f) (stock_measure INTEG) IntVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr M (stock_measure INTEG) (IntVal \\<circ> f \\<circ> extract_int) =\n    distr\n     (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n     (stock_measure INTEG) IntVal", "by (subst distr_distr) (simp_all add: distr_distr[OF _ measurable_comp[OF _ Mf]] comp_assoc)"], ["proof (state)\nthis:\n  distr M (stock_measure INTEG) (IntVal \\<circ> f \\<circ> extract_int) =\n  distr\n   (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n   (stock_measure INTEG) IntVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr M (stock_measure INTEG) (IntVal \\<circ> f \\<circ> extract_int) =\n  distr\n   (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n   (stock_measure INTEG) IntVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have dens'': \"has_density (distr (distr M ?R extract_int) ?R f) ?R (g (\\<delta> \\<circ> IntVal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_density\n     (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n     (count_space UNIV) (g (\\<delta> \\<circ> IntVal))", "by (intro dens' has_density_embed_measure'')\n       (insert dens, simp_all add: extract_int_def embed_measure_count_space stock_measure.simps)"], ["proof (state)\nthis:\n  has_density\n   (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n   (count_space UNIV) (g (\\<delta> \\<circ> IntVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "hence \"distr (distr M ?R extract_int) ?R f = density ?R (g (\\<delta> \\<circ> IntVal))\""], ["proof (prove)\nusing this:\n  has_density\n   (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n   (count_space UNIV) (g (\\<delta> \\<circ> IntVal))\n\ngoal (1 subgoal):\n 1. distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f =\n    density (count_space UNIV) (g (\\<delta> \\<circ> IntVal))", "by (rule has_densityD)"], ["proof (state)\nthis:\n  distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f =\n  density (count_space UNIV) (g (\\<delta> \\<circ> IntVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f =\n  density (count_space UNIV) (g (\\<delta> \\<circ> IntVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have \"distr ... (stock_measure INTEG) IntVal = embed_measure ... IntVal\" (is \"_ = ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (density (count_space UNIV) (g (\\<delta> \\<circ> IntVal)))\n     (stock_measure INTEG) IntVal =\n    embed_measure (density (count_space UNIV) (g (\\<delta> \\<circ> IntVal)))\n     IntVal", "by (subst embed_measure_eq_distr[OF inj_IntVal], intro distr_cong)\n       (auto simp: sets_embed_measure subset_image_iff stock_measure.simps)"], ["proof (state)\nthis:\n  distr (density (count_space UNIV) (g (\\<delta> \\<circ> IntVal)))\n   (stock_measure INTEG) IntVal =\n  embed_measure (density (count_space UNIV) (g (\\<delta> \\<circ> IntVal)))\n   IntVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr (density (count_space UNIV) (g (\\<delta> \\<circ> IntVal)))\n   (stock_measure INTEG) IntVal =\n  embed_measure (density (count_space UNIV) (g (\\<delta> \\<circ> IntVal)))\n   IntVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have \"... = density (embed_measure ?R IntVal) (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_measure (density (count_space UNIV) (g (\\<delta> \\<circ> IntVal)))\n     IntVal =\n    density (embed_measure (count_space UNIV) IntVal)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)", "using dens''[unfolded o_def]"], ["proof (prove)\nusing this:\n  has_density\n   (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n   (count_space UNIV) (g (\\<lambda>x. \\<delta> (IntVal x)))\n\ngoal (1 subgoal):\n 1. embed_measure (density (count_space UNIV) (g (\\<delta> \\<circ> IntVal)))\n     IntVal =\n    density (embed_measure (count_space UNIV) IntVal)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)", "apply (subst density_embed_measure', simp, simp add: extract_int_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. has_density\n     (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n     (count_space UNIV)\n     (g (\\<lambda>x. \\<delta> (IntVal x))) \\<Longrightarrow>\n    g (\\<lambda>x. \\<delta> (IntVal x))\n    \\<in> borel_measurable (count_space UNIV)\n 2. has_density\n     (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n     (count_space UNIV)\n     (g (\\<lambda>x. \\<delta> (IntVal x))) \\<Longrightarrow>\n    embed_measure (density (count_space UNIV) (g (\\<delta> \\<circ> IntVal)))\n     IntVal =\n    embed_measure\n     (density (count_space UNIV) (g (\\<lambda>x. \\<delta> (IntVal x))))\n     IntVal", "apply (erule has_densityD, simp add: o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  embed_measure (density (count_space UNIV) (g (\\<delta> \\<circ> IntVal)))\n   IntVal =\n  density (embed_measure (count_space UNIV) IntVal)\n   (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "finally"], ["proof (chain)\npicking this:\n  N =\n  density (embed_measure (count_space UNIV) IntVal)\n   (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)", "show \"N = density (stock_measure INTEG) (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\""], ["proof (prove)\nusing this:\n  N =\n  density (embed_measure (count_space UNIV) IntVal)\n   (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n\ngoal (1 subgoal):\n 1. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)", "by (simp add: embed_measure_count_space stock_measure.simps)"], ["proof (state)\nthis:\n  N =\n  density (stock_measure INTEG)\n   (g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int)\n\ngoal (2 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. space (stock_measure INTEG) \\<noteq> {}", "from dens''[unfolded o_def]"], ["proof (chain)\npicking this:\n  has_density\n   (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n   (count_space UNIV) (g (\\<lambda>x. \\<delta> (IntVal x)))", "show \"g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int \\<in> borel_measurable (stock_measure INTEG)\""], ["proof (prove)\nusing this:\n  has_density\n   (distr (distr M (count_space UNIV) extract_int) (count_space UNIV) f)\n   (count_space UNIV) (g (\\<lambda>x. \\<delta> (IntVal x)))\n\ngoal (1 subgoal):\n 1. g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)", "by (simp add: embed_measure_count_space stock_measure.simps)"], ["proof (state)\nthis:\n  g (\\<lambda>x. \\<delta> (IntVal x)) \\<circ> extract_int\n  \\<in> borel_measurable (stock_measure INTEG)\n\ngoal (1 subgoal):\n 1. space (stock_measure INTEG) \\<noteq> {}", "qed (subst space_stock_measure, simp)"], ["", "lemma distr_lift_RealPairVal:\n  fixes f f' g\n  assumes Mf[measurable]: \"case_prod f \\<in> borel_measurable borel\"\n  assumes pdens: \"has_subprob_density M (stock_measure (PRODUCT REAL REAL)) \\<delta>\"\n  assumes dens': \"\\<And>M \\<delta>. has_subprob_density M lborel \\<delta> \\<Longrightarrow> has_density (distr M borel (case_prod f)) lborel (g \\<delta>)\"\n  defines \"N \\<equiv> distr M (stock_measure REAL) (lift_RealIntVal2 f' f)\"\n  shows \"has_density N (stock_measure REAL) (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_density N (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)", "proof (rule has_densityI)"], ["proof (state)\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "from assms(2)"], ["proof (chain)\npicking this:\n  has_subprob_density M (stock_measure (PRODUCT REAL REAL)) \\<delta>", "have dens: \"has_density M (stock_measure (PRODUCT REAL REAL)) \\<delta>\""], ["proof (prove)\nusing this:\n  has_subprob_density M (stock_measure (PRODUCT REAL REAL)) \\<delta>\n\ngoal (1 subgoal):\n 1. has_density M (stock_measure (PRODUCT REAL REAL)) \\<delta>", "unfolding has_subprob_density_def"], ["proof (prove)\nusing this:\n  has_density M (stock_measure (PRODUCT REAL REAL)) \\<delta> \\<and>\n  subprob_space M\n\ngoal (1 subgoal):\n 1. has_density M (stock_measure (PRODUCT REAL REAL)) \\<delta>", "by simp"], ["proof (state)\nthis:\n  has_density M (stock_measure (PRODUCT REAL REAL)) \\<delta>\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have sets_M[measurable_cong]: \"sets M = sets (stock_measure (PRODUCT REAL REAL))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets M = sets (stock_measure (PRODUCT REAL REAL))", "by (auto simp: has_subprob_densityD[OF pdens])"], ["proof (state)\nthis:\n  sets M = sets (stock_measure (PRODUCT REAL REAL))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have \"N = distr M (stock_measure REAL) (lift_RealIntVal2 f' f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = distr M (stock_measure REAL) (lift_RealIntVal2 f' f)", "by (simp add: N_def)"], ["proof (state)\nthis:\n  N = distr M (stock_measure REAL) (lift_RealIntVal2 f' f)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  N = distr M (stock_measure REAL) (lift_RealIntVal2 f' f)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have \"... = distr M (stock_measure REAL) (RealVal \\<circ> case_prod f \\<circ> extract_real_pair)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr M (stock_measure REAL) (lift_RealIntVal2 f' f) =\n    distr M (stock_measure REAL)\n     (RealVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair)", "using sets_eq_imp_space_eq[OF sets_M]"], ["proof (prove)\nusing this:\n  space M = space (stock_measure (PRODUCT REAL REAL))\n\ngoal (1 subgoal):\n 1. distr M (stock_measure REAL) (lift_RealIntVal2 f' f) =\n    distr M (stock_measure REAL)\n     (RealVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair)", "by (intro distr_cong) (auto simp: lift_RealIntVal2_def space_embed_measure space_pair_measure stock_measure.simps)"], ["proof (state)\nthis:\n  distr M (stock_measure REAL) (lift_RealIntVal2 f' f) =\n  distr M (stock_measure REAL)\n   (RealVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr M (stock_measure REAL) (lift_RealIntVal2 f' f) =\n  distr M (stock_measure REAL)\n   (RealVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have \"... = distr (distr (distr M lborel extract_real_pair) borel (case_prod f)) REAL RealVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr M (stock_measure REAL)\n     (RealVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair) =\n    distr\n     (distr (distr M lborel extract_real_pair) borel\n       (\\<lambda>(x, y). f x y))\n     (stock_measure REAL) RealVal", "by (subst distr_distr) (simp_all add: distr_distr[OF _ measurable_comp[OF _ Mf]] comp_assoc)"], ["proof (state)\nthis:\n  distr M (stock_measure REAL)\n   (RealVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair) =\n  distr\n   (distr (distr M lborel extract_real_pair) borel (\\<lambda>(x, y). f x y))\n   (stock_measure REAL) RealVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr M (stock_measure REAL)\n   (RealVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_real_pair) =\n  distr\n   (distr (distr M lborel extract_real_pair) borel (\\<lambda>(x, y). f x y))\n   (stock_measure REAL) RealVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have dens'': \"has_density (distr (distr M lborel extract_real_pair) borel (case_prod f)) lborel\n                      (g (\\<delta> \\<circ> RealPairVal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_density\n     (distr (distr M lborel extract_real_pair) borel\n       (\\<lambda>(x, y). f x y))\n     lborel (g (\\<delta> \\<circ> RealPairVal))", "using inj_RealPairVal embed_measure_RealPairVal"], ["proof (prove)\nusing this:\n  inj RealPairVal\n  stock_measure (PRODUCT REAL REAL) = embed_measure lborel RealPairVal\n\ngoal (1 subgoal):\n 1. has_density\n     (distr (distr M lborel extract_real_pair) borel\n       (\\<lambda>(x, y). f x y))\n     lborel (g (\\<delta> \\<circ> RealPairVal))", "by (intro dens' has_subprob_density_embed_measure'')\n       (insert pdens, simp_all add: RealPairVal_def split: prod.split)"], ["proof (state)\nthis:\n  has_density\n   (distr (distr M lborel extract_real_pair) borel (\\<lambda>(x, y). f x y))\n   lborel (g (\\<delta> \\<circ> RealPairVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "hence \"distr (distr M lborel extract_real_pair) borel (case_prod f) =\n             density lborel (g (\\<delta> \\<circ> RealPairVal))\""], ["proof (prove)\nusing this:\n  has_density\n   (distr (distr M lborel extract_real_pair) borel (\\<lambda>(x, y). f x y))\n   lborel (g (\\<delta> \\<circ> RealPairVal))\n\ngoal (1 subgoal):\n 1. distr (distr M lborel extract_real_pair) borel\n     (\\<lambda>(x, y). f x y) =\n    density lborel (g (\\<delta> \\<circ> RealPairVal))", "by (rule has_densityD)"], ["proof (state)\nthis:\n  distr (distr M lborel extract_real_pair) borel (\\<lambda>(x, y). f x y) =\n  density lborel (g (\\<delta> \\<circ> RealPairVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr (distr M lborel extract_real_pair) borel (\\<lambda>(x, y). f x y) =\n  density lborel (g (\\<delta> \\<circ> RealPairVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have \"distr ... (stock_measure REAL) RealVal = embed_measure ... RealVal\" (is \"_ = ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (density lborel (g (\\<delta> \\<circ> RealPairVal)))\n     (stock_measure REAL) RealVal =\n    embed_measure (density lborel (g (\\<delta> \\<circ> RealPairVal)))\n     RealVal", "by (subst embed_measure_eq_distr[OF inj_RealVal], intro distr_cong)\n       (simp_all add: sets_embed_measure stock_measure.simps)"], ["proof (state)\nthis:\n  distr (density lborel (g (\\<delta> \\<circ> RealPairVal)))\n   (stock_measure REAL) RealVal =\n  embed_measure (density lborel (g (\\<delta> \\<circ> RealPairVal))) RealVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr (density lborel (g (\\<delta> \\<circ> RealPairVal)))\n   (stock_measure REAL) RealVal =\n  embed_measure (density lborel (g (\\<delta> \\<circ> RealPairVal))) RealVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "have \"... = density (embed_measure lborel RealVal) (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_measure (density lborel (g (\\<delta> \\<circ> RealPairVal)))\n     RealVal =\n    density (embed_measure lborel RealVal)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)", "using dens''[unfolded o_def]"], ["proof (prove)\nusing this:\n  has_density\n   (distr (distr M lborel extract_real_pair) borel (\\<lambda>(x, y). f x y))\n   lborel (g (\\<lambda>x. \\<delta> (RealPairVal x)))\n\ngoal (1 subgoal):\n 1. embed_measure (density lborel (g (\\<delta> \\<circ> RealPairVal)))\n     RealVal =\n    density (embed_measure lborel RealVal)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)", "by (subst density_embed_measure', simp, simp add: extract_real_def)\n       (erule has_densityD, simp add: o_def)"], ["proof (state)\nthis:\n  embed_measure (density lborel (g (\\<delta> \\<circ> RealPairVal)))\n   RealVal =\n  density (embed_measure lborel RealVal)\n   (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n 3. space (stock_measure REAL) \\<noteq> {}", "finally"], ["proof (chain)\npicking this:\n  N =\n  density (embed_measure lborel RealVal)\n   (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)", "show \"N = density (stock_measure REAL) (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\""], ["proof (prove)\nusing this:\n  N =\n  density (embed_measure lborel RealVal)\n   (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n\ngoal (1 subgoal):\n 1. N =\n    density (stock_measure REAL)\n     (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)", "by (simp add: stock_measure.simps)"], ["proof (state)\nthis:\n  N =\n  density (stock_measure REAL)\n   (g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real)\n\ngoal (2 subgoals):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)\n 2. space (stock_measure REAL) \\<noteq> {}", "from dens''[unfolded o_def]"], ["proof (chain)\npicking this:\n  has_density\n   (distr (distr M lborel extract_real_pair) borel (\\<lambda>(x, y). f x y))\n   lborel (g (\\<lambda>x. \\<delta> (RealPairVal x)))", "show \"g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real \\<in> borel_measurable (stock_measure REAL)\""], ["proof (prove)\nusing this:\n  has_density\n   (distr (distr M lborel extract_real_pair) borel (\\<lambda>(x, y). f x y))\n   lborel (g (\\<lambda>x. \\<delta> (RealPairVal x)))\n\ngoal (1 subgoal):\n 1. g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n    \\<in> borel_measurable (stock_measure REAL)", "by (intro measurable_comp)\n       (rule measurable_extract_real, subst measurable_lborel2[symmetric], erule has_densityD)"], ["proof (state)\nthis:\n  g (\\<lambda>x. \\<delta> (RealPairVal x)) \\<circ> extract_real\n  \\<in> borel_measurable (stock_measure REAL)\n\ngoal (1 subgoal):\n 1. space (stock_measure REAL) \\<noteq> {}", "qed (subst space_stock_measure, simp)"], ["", "lemma distr_lift_IntPairVal:\n  fixes f f'\n  assumes pdens: \"has_density M (stock_measure (PRODUCT INTEG INTEG)) \\<delta>\"\n  assumes dens': \"\\<And>M \\<delta>. has_density M (count_space UNIV) \\<delta> \\<Longrightarrow>\n                            has_density (distr M (count_space UNIV) (case_prod f))\n                                        (count_space UNIV) (g \\<delta>)\"\n  defines \"N \\<equiv> distr M (stock_measure INTEG) (lift_RealIntVal2 f f')\"\n  shows \"has_density N (stock_measure INTEG) (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_density N (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)", "proof (rule has_densityI)"], ["proof (state)\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "let ?R = \"count_space UNIV\" and ?S = \"count_space (range IntVal)\"\n  and ?T = \"count_space (range IntPairVal)\" and ?tp = \"PRODUCT INTEG INTEG\""], ["proof (state)\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have Mf: \"f \\<in> measurable ?R ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space UNIV", "by simp"], ["proof (state)\nthis:\n  f \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space UNIV\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have MIV: \"IntVal \\<in> measurable ?R ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IntVal\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space (range IntVal)", "by simp"], ["proof (state)\nthis:\n  IntVal\n  \\<in> count_space UNIV \\<rightarrow>\\<^sub>M count_space (range IntVal)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "from assms(1)"], ["proof (chain)\npicking this:\n  has_density M (stock_measure (PRODUCT INTEG INTEG)) \\<delta>", "have dens: \"has_density M (stock_measure ?tp) \\<delta>\""], ["proof (prove)\nusing this:\n  has_density M (stock_measure (PRODUCT INTEG INTEG)) \\<delta>\n\ngoal (1 subgoal):\n 1. has_density M (stock_measure (PRODUCT INTEG INTEG)) \\<delta>", "unfolding has_subprob_density_def"], ["proof (prove)\nusing this:\n  has_density M (stock_measure (PRODUCT INTEG INTEG)) \\<delta>\n\ngoal (1 subgoal):\n 1. has_density M (stock_measure (PRODUCT INTEG INTEG)) \\<delta>", "by simp"], ["proof (state)\nthis:\n  has_density M (stock_measure (PRODUCT INTEG INTEG)) \\<delta>\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "from dens"], ["proof (chain)\npicking this:\n  has_density M (stock_measure (PRODUCT INTEG INTEG)) \\<delta>", "have \"M = density (stock_measure ?tp) \\<delta>\""], ["proof (prove)\nusing this:\n  has_density M (stock_measure (PRODUCT INTEG INTEG)) \\<delta>\n\ngoal (1 subgoal):\n 1. M = density (stock_measure (PRODUCT INTEG INTEG)) \\<delta>", "by (rule has_densityD)"], ["proof (state)\nthis:\n  M = density (stock_measure (PRODUCT INTEG INTEG)) \\<delta>\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "hence sets_M: \"sets M = sets ?T\""], ["proof (prove)\nusing this:\n  M = density (stock_measure (PRODUCT INTEG INTEG)) \\<delta>\n\ngoal (1 subgoal):\n 1. sets M = sets (count_space (range IntPairVal))", "by (subst embed_measure_IntPairVal[symmetric]) auto"], ["proof (state)\nthis:\n  sets M = sets (count_space (range IntPairVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "hence [simp]: \"space M = space ?T\""], ["proof (prove)\nusing this:\n  sets M = sets (count_space (range IntPairVal))\n\ngoal (1 subgoal):\n 1. space M = space (count_space (range IntPairVal))", "by (rule sets_eq_imp_space_eq)"], ["proof (state)\nthis:\n  space M = space (count_space (range IntPairVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "from sets_M"], ["proof (chain)\npicking this:\n  sets M = sets (count_space (range IntPairVal))", "have [simp]: \"measurable M = measurable (count_space (range IntPairVal))\""], ["proof (prove)\nusing this:\n  sets M = sets (count_space (range IntPairVal))\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>\\<^sub>M) M =\n    (\\<rightarrow>\\<^sub>M) (count_space (range IntPairVal))", "by (intro ext measurable_cong_sets) simp_all"], ["proof (state)\nthis:\n  (\\<rightarrow>\\<^sub>M) M =\n  (\\<rightarrow>\\<^sub>M) (count_space (range IntPairVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have \"N = distr M (stock_measure INTEG) (lift_RealIntVal2 f f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = distr M (stock_measure INTEG) (lift_RealIntVal2 f f')", "by (simp add: N_def)"], ["proof (state)\nthis:\n  N = distr M (stock_measure INTEG) (lift_RealIntVal2 f f')\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  N = distr M (stock_measure INTEG) (lift_RealIntVal2 f f')\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have \"... = distr M (stock_measure INTEG) (IntVal \\<circ> case_prod f \\<circ> extract_int_pair)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr M (stock_measure INTEG) (lift_RealIntVal2 f f') =\n    distr M (stock_measure INTEG)\n     (IntVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair)", "by (intro distr_cong) (auto simp: lift_RealIntVal2_def space_embed_measure space_pair_measure IntPairVal_def)"], ["proof (state)\nthis:\n  distr M (stock_measure INTEG) (lift_RealIntVal2 f f') =\n  distr M (stock_measure INTEG)\n   (IntVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr M (stock_measure INTEG) (lift_RealIntVal2 f f') =\n  distr M (stock_measure INTEG)\n   (IntVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have \"... = distr (distr (distr M (count_space UNIV) extract_int_pair)\n                        (count_space UNIV) (case_prod f)) (stock_measure INTEG) IntVal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr M (stock_measure INTEG)\n     (IntVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair) =\n    distr\n     (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n       (\\<lambda>(x, y). f x y))\n     (stock_measure INTEG) IntVal", "apply (subst distr_distr[of _ ?R, symmetric], simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (distr M (count_space UNIV) extract_int_pair)\n     (stock_measure INTEG) (IntVal \\<circ> (\\<lambda>(x, y). f x y)) =\n    distr\n     (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n       (\\<lambda>(x, y). f x y))\n     (stock_measure INTEG) IntVal", "apply (subst distr_distr[symmetric], subst stock_measure.simps, rule MIV,\n           simp_all add: assms(1) cong: distr_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distr M (stock_measure INTEG)\n   (IntVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair) =\n  distr\n   (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n     (\\<lambda>(x, y). f x y))\n   (stock_measure INTEG) IntVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr M (stock_measure INTEG)\n   (IntVal \\<circ> (\\<lambda>(x, y). f x y) \\<circ> extract_int_pair) =\n  distr\n   (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n     (\\<lambda>(x, y). f x y))\n   (stock_measure INTEG) IntVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have dens'': \"has_density (distr (distr M (count_space UNIV) extract_int_pair) ?R (case_prod f)) ?R\n                      (g (\\<delta> \\<circ> IntPairVal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_density\n     (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n       (\\<lambda>(x, y). f x y))\n     (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))", "using inj_IntPairVal embed_measure_IntPairVal"], ["proof (prove)\nusing this:\n  inj IntPairVal\n  stock_measure (PRODUCT INTEG INTEG) = count_space (range IntPairVal)\n\ngoal (1 subgoal):\n 1. has_density\n     (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n       (\\<lambda>(x, y). f x y))\n     (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))", "by (intro dens' has_density_embed_measure'')\n       (insert dens, simp_all add: extract_int_def embed_measure_count_space IntPairVal_def split: prod.split)"], ["proof (state)\nthis:\n  has_density\n   (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n     (\\<lambda>(x, y). f x y))\n   (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "hence \"distr (distr M (count_space UNIV) extract_int_pair) ?R (case_prod f) =\n             density ?R (g (\\<delta> \\<circ> IntPairVal))\""], ["proof (prove)\nusing this:\n  has_density\n   (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n     (\\<lambda>(x, y). f x y))\n   (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))\n\ngoal (1 subgoal):\n 1. distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n     (\\<lambda>(x, y). f x y) =\n    density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))", "by (rule has_densityD)"], ["proof (state)\nthis:\n  distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n   (\\<lambda>(x, y). f x y) =\n  density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n   (\\<lambda>(x, y). f x y) =\n  density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have \"distr ... (stock_measure INTEG) IntVal = embed_measure ... IntVal\" (is \"_ = ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal)))\n     (stock_measure INTEG) IntVal =\n    embed_measure\n     (density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))) IntVal", "by (subst embed_measure_eq_distr[OF inj_IntVal], intro distr_cong)\n       (auto simp: sets_embed_measure subset_image_iff stock_measure.simps)"], ["proof (state)\nthis:\n  distr (density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal)))\n   (stock_measure INTEG) IntVal =\n  embed_measure\n   (density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))) IntVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "also"], ["proof (state)\nthis:\n  distr (density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal)))\n   (stock_measure INTEG) IntVal =\n  embed_measure\n   (density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))) IntVal\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "have \"... = density (embed_measure ?R IntVal) (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_measure\n     (density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))) IntVal =\n    density (embed_measure (count_space UNIV) IntVal)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)", "using dens''[unfolded o_def]"], ["proof (prove)\nusing this:\n  has_density\n   (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n     (\\<lambda>(x, y). f x y))\n   (count_space UNIV) (g (\\<lambda>x. \\<delta> (IntPairVal x)))\n\ngoal (1 subgoal):\n 1. embed_measure\n     (density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))) IntVal =\n    density (embed_measure (count_space UNIV) IntVal)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)", "by (subst density_embed_measure', simp, simp add: extract_int_def)\n       (erule has_densityD, simp add: o_def)"], ["proof (state)\nthis:\n  embed_measure\n   (density (count_space UNIV) (g (\\<delta> \\<circ> IntPairVal))) IntVal =\n  density (embed_measure (count_space UNIV) IntVal)\n   (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n\ngoal (3 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n 3. space (stock_measure INTEG) \\<noteq> {}", "finally"], ["proof (chain)\npicking this:\n  N =\n  density (embed_measure (count_space UNIV) IntVal)\n   (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)", "show \"N = density (stock_measure INTEG) (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\""], ["proof (prove)\nusing this:\n  N =\n  density (embed_measure (count_space UNIV) IntVal)\n   (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n\ngoal (1 subgoal):\n 1. N =\n    density (stock_measure INTEG)\n     (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)", "by (simp add: embed_measure_count_space stock_measure.simps)"], ["proof (state)\nthis:\n  N =\n  density (stock_measure INTEG)\n   (g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int)\n\ngoal (2 subgoals):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)\n 2. space (stock_measure INTEG) \\<noteq> {}", "from dens''[unfolded o_def]"], ["proof (chain)\npicking this:\n  has_density\n   (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n     (\\<lambda>(x, y). f x y))\n   (count_space UNIV) (g (\\<lambda>x. \\<delta> (IntPairVal x)))", "show \"g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int \\<in> borel_measurable (stock_measure INTEG)\""], ["proof (prove)\nusing this:\n  has_density\n   (distr (distr M (count_space UNIV) extract_int_pair) (count_space UNIV)\n     (\\<lambda>(x, y). f x y))\n   (count_space UNIV) (g (\\<lambda>x. \\<delta> (IntPairVal x)))\n\ngoal (1 subgoal):\n 1. g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n    \\<in> borel_measurable (stock_measure INTEG)", "by (simp add: embed_measure_count_space stock_measure.simps)"], ["proof (state)\nthis:\n  g (\\<lambda>x. \\<delta> (IntPairVal x)) \\<circ> extract_int\n  \\<in> borel_measurable (stock_measure INTEG)\n\ngoal (1 subgoal):\n 1. space (stock_measure INTEG) \\<noteq> {}", "qed (subst space_stock_measure, simp)"], ["", "end"]]}