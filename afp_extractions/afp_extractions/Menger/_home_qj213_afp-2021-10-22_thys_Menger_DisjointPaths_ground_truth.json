{"file_name": "/home/qj213/afp-2021-10-22/thys/Menger/DisjointPaths.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Menger", "problem_names": ["lemma (in v0_v1_Digraph) DisjointPaths_empty: \"DisjointPaths G v0 v1 {}\"", "lemma (in v0_v1_Digraph) DisjointPaths_supergraph:\n  assumes \"DisjointPaths (remove_vertex v) v0 v1 paths\"\n  shows \"DisjointPaths G v0 v1 paths\"", "lemma paths_in_all_paths: \"paths \\<subseteq> all_paths\"", "lemma finite_paths: \"finite paths\"", "lemma paths_edge_finite: \"finite (\\<Union>(edges_of_walk ` paths))\"", "lemma paths_tl_notnil: \"xs \\<in> paths \\<Longrightarrow> tl xs \\<noteq> Nil\"", "lemma paths_second_in_V: \"xs \\<in> paths \\<Longrightarrow> hd (tl xs) \\<in> V\"", "lemma paths_second_not_v0: \"xs \\<in> paths \\<Longrightarrow> hd (tl xs) \\<noteq> v0\"", "lemma paths_second_not_v1: \"xs \\<in> paths \\<Longrightarrow> hd (tl xs) \\<noteq> v1\"", "lemma paths_second_disjoint: \"\\<lbrakk> xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys \\<rbrakk> \\<Longrightarrow> hd (tl xs) \\<noteq> hd (tl ys)\"", "lemma paths_edge_disjoint:\n  assumes \"xs \\<in> paths\" \"ys \\<in> paths\" \"xs \\<noteq> ys\"\n  shows \"edges_of_walk xs \\<inter> edges_of_walk ys = {}\"", "lemma DisjointPaths_extend:\n  assumes P_path: \"v0\\<leadsto>P\\<leadsto>v1\"\n      and P_disjoint: \"\\<And>xs v. \\<lbrakk> xs \\<in> paths; xs \\<noteq> P; v \\<in> set xs; v \\<in> set P \\<rbrakk> \\<Longrightarrow> v = v0 \\<or> v = v1\"\n  shows \"DisjointPaths G v0 v1 (insert P paths)\"", "lemma DisjointPaths_reduce:\n  assumes \"paths' \\<subseteq> paths\"\n  shows \"DisjointPaths G v0 v1 paths'\"", "lemma second_vertex_inj: \"inj_on second_vertex paths\"", "lemma second_vertices_card: \"card second_vertices = card paths\"", "lemma second_vertices_in_V: \"second_vertices \\<subseteq> V\"", "lemma v0_v1_notin_second_vertices: \"v0 \\<notin> second_vertices\" \"v1 \\<notin> second_vertices\"", "lemma second_vertices_new_path: \"hd (tl xs) \\<notin> second_vertices \\<Longrightarrow> xs \\<notin> paths\"", "lemma second_vertices_first_edge:\n  \"\\<lbrakk> xs \\<in> paths; first_edge_of_walk xs = (v,w) \\<rbrakk> \\<Longrightarrow> w \\<in> second_vertices\"", "lemma disjoint_paths_new_path:\n  assumes no_small_separations: \"\\<And>S. Separation G v0 v1 S \\<Longrightarrow> card S \\<ge> Suc (card paths)\"\n  shows \"\\<exists>P_new. v0\\<leadsto>P_new\\<leadsto>v1 \\<and> set P_new \\<inter> second_vertices = {}\"", "lemma P_new_hd_disjoint: \"\\<And>xs. xs \\<in> paths \\<Longrightarrow> hd (tl P_new) \\<noteq> hd (tl xs)\"", "lemma P_new_new: \"P_new \\<notin> paths\"", "lemma card_paths_with_new: \"card paths_with_new = Suc (card paths)\"", "lemma paths_with_new_no_Nil: \"Nil \\<notin> paths_with_new\"", "lemma paths_with_new_path: \"xs \\<in> paths_with_new \\<Longrightarrow> path xs\"", "lemma paths_with_new_start_in_v0: \"xs \\<in> paths_with_new \\<Longrightarrow> hd xs = v0\"", "lemma P_new_decomp: \"P_new = new_pre @ [new_last]\"", "lemma new_pre_not_Nil: \"new_pre \\<noteq> Nil\"", "lemma new_pre_hitting: \"x' \\<in> set new_pre \\<Longrightarrow> \\<not>hitting_paths x'\"", "lemma P_hit: \"hitting_paths new_last\"", "lemma new_last_neq_v0: \"new_last \\<noteq> v0\"", "lemma new_last_in_V: \"new_last \\<in> V\"", "lemma new_last_to_v1: \"\\<exists>R. new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\"", "lemma paths_plus_one_disjoint:\n  assumes \"xs \\<in> paths_with_new\" \"ys \\<in> paths_with_new\" \"xs \\<noteq> ys\" \"v \\<in> set xs\" \"v \\<in> set ys\"\n  shows \"v = v0 \\<or> v = v1 \\<or> v = new_last\"", "lemma P_new_solves_if_disjoint:\n  \"new_last = v1 \\<Longrightarrow> \\<exists>paths'. DisjointPaths G v0 v1 paths' \\<and> card paths' = Suc (card paths)\"", "lemma H_x_Digraph: \"Digraph H_x\"", "lemma H_x_v0_v1_Digraph: \"new_last \\<noteq> v1 \\<Longrightarrow> v0_v1_Digraph H_x v0 v1\"", "lemma new_path_follows_old_paths:\n  assumes xs: \"v0 \\<leadsto>xs\\<leadsto> w\" \"tl xs \\<noteq> Nil\" \"v1 \\<notin> set xs\" \"new_last \\<notin> set xs\"\n      and P: \"P \\<in> paths_with_new\" \"hd (tl xs) = hd (tl P)\"\n      and edges_subset: \"edges_of_walk xs \\<subseteq> \\<Union>(edges_of_walk ` paths_with_new)\"\n    shows \"edges_of_walk xs \\<subseteq> edges_of_walk P\""], "translations": [["", "lemma (in v0_v1_Digraph) DisjointPaths_empty: \"DisjointPaths G v0 v1 {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 {}", "by (simp add: DisjointPaths.intro DisjointPaths_axioms_def v0_v1_Digraph_axioms)"], ["", "text \\<open>Re-adding a deleted vertex is fine.\\<close>"], ["", "lemma (in v0_v1_Digraph) DisjointPaths_supergraph:\n  assumes \"DisjointPaths (remove_vertex v) v0 v1 paths\"\n  shows \"DisjointPaths G v0 v1 paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 paths", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1\n 2. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "interpret H: DisjointPaths \"remove_vertex v\" v0 v1 paths"], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths (remove_vertex v) v0 v1 paths", "using assms"], ["proof (prove)\nusing this:\n  DisjointPaths (remove_vertex v) v0 v1 paths\n\ngoal (1 subgoal):\n 1. DisjointPaths (remove_vertex v) v0 v1 paths", "."], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1\n 2. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "show \"\\<And>xs. xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1", "using remove_vertex_path_from_to_add H.paths"], ["proof (prove)\nusing this:\n  ?v \\<leadsto>?xs\\<leadsto>\\<^bsub>remove_vertex ?x\\<^esub> ?w \\<Longrightarrow>\n  ?v \\<leadsto>?xs\\<leadsto> ?w\n  ?xs \\<in> paths \\<Longrightarrow>\n  v0 \\<leadsto>?xs\\<leadsto>\\<^bsub>remove_vertex v\\<^esub> v1\n\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1", "by blast"], ["proof (state)\nthis:\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "show \"\\<And>xs ys v. \\<lbrakk> xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys; v \\<in> set xs; v \\<in> set ys \\<rbrakk> \\<Longrightarrow> v = v0 \\<or> v = v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "by (meson DisjointPaths.paths_disjoint H.DisjointPaths_axioms)"], ["proof (state)\nthis:\n  \\<lbrakk>?xs \\<in> paths; ?ys \\<in> paths; ?xs \\<noteq> ?ys;\n   ?v \\<in> set ?xs; ?v \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?v = v0 \\<or> ?v = v1\n\ngoal:\nNo subgoals!", "qed"], ["", "context DisjointPaths begin"], ["", "lemma paths_in_all_paths: \"paths \\<subseteq> all_paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. paths \\<subseteq> all_paths", "unfolding all_paths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. paths \\<subseteq> {xs |xs. path xs}", "using paths"], ["proof (prove)\nusing this:\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. paths \\<subseteq> {xs |xs. path xs}", "by blast"], ["", "lemma finite_paths: \"finite paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite paths", "using finitely_many_paths infinite_super paths_in_all_paths"], ["proof (prove)\nusing this:\n  finite all_paths\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n  paths \\<subseteq> all_paths\n\ngoal (1 subgoal):\n 1. finite paths", "by blast"], ["", "lemma paths_edge_finite: \"finite (\\<Union>(edges_of_walk ` paths))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (edges_of_walk ` paths))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (\\<Union> (edges_of_walk ` paths))", "have \"\\<Union>(edges_of_walk ` paths) \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (edges_of_walk ` paths) \\<subseteq> E", "using edges_of_walk_in_E paths"], ["proof (prove)\nusing this:\n  walk ?xs \\<Longrightarrow> edges_of_walk ?xs \\<subseteq> E\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. \\<Union> (edges_of_walk ` paths) \\<subseteq> E", "by fastforce"], ["proof (state)\nthis:\n  \\<Union> (edges_of_walk ` paths) \\<subseteq> E\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (edges_of_walk ` paths))", "then"], ["proof (chain)\npicking this:\n  \\<Union> (edges_of_walk ` paths) \\<subseteq> E", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Union> (edges_of_walk ` paths) \\<subseteq> E\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (edges_of_walk ` paths))", "by (meson finite_edge_set finite_subset)"], ["proof (state)\nthis:\n  finite (\\<Union> (edges_of_walk ` paths))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma paths_tl_notnil: \"xs \\<in> paths \\<Longrightarrow> tl xs \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> paths \\<Longrightarrow> tl xs \\<noteq> []", "by (metis path_from_toE hd_Cons_tl last_ConsL paths v0_neq_v1)"], ["", "lemma paths_second_in_V: \"xs \\<in> paths \\<Longrightarrow> hd (tl xs) \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> paths \\<Longrightarrow> hd (tl xs) \\<in> V", "by (metis paths edges_are_in_V(2) list.exhaust_sel path_from_toE paths_tl_notnil walk_first_edge')"], ["", "lemma paths_second_not_v0: \"xs \\<in> paths \\<Longrightarrow> hd (tl xs) \\<noteq> v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> paths \\<Longrightarrow> hd (tl xs) \\<noteq> v0", "by (metis distinct.simps(2) hd_in_set list.exhaust_sel path_from_to_def paths paths_tl_notnil)"], ["", "lemma paths_second_not_v1: \"xs \\<in> paths \\<Longrightarrow> hd (tl xs) \\<noteq> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> paths \\<Longrightarrow> hd (tl xs) \\<noteq> v1", "using paths paths_tl_notnil v0_nonadj_v1 walk_first_edge'"], ["proof (prove)\nusing this:\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n  ?xs \\<in> paths \\<Longrightarrow> tl ?xs \\<noteq> []\n  (v0, v1) \\<notin> E\n  \\<lbrakk>walk (?v # ?xs); ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?v \\<rightarrow> hd ?xs\n\ngoal (1 subgoal):\n 1. xs \\<in> paths \\<Longrightarrow> hd (tl xs) \\<noteq> v1", "by fastforce"], ["", "lemma paths_second_disjoint: \"\\<lbrakk> xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys \\<rbrakk> \\<Longrightarrow> hd (tl xs) \\<noteq> hd (tl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys\\<rbrakk>\n    \\<Longrightarrow> hd (tl xs) \\<noteq> hd (tl ys)", "by (metis paths_disjoint Nil_tl hd_in_set list.set_sel(2)\n      paths_second_not_v0 paths_second_not_v1 paths_tl_notnil)"], ["", "lemma paths_edge_disjoint:\n  assumes \"xs \\<in> paths\" \"ys \\<in> paths\" \"xs \\<noteq> ys\"\n  shows \"edges_of_walk xs \\<inter> edges_of_walk ys = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<inter> edges_of_walk ys = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<inter> edges_of_walk ys \\<noteq> {} \\<Longrightarrow>\n    False", "assume \"edges_of_walk xs \\<inter> edges_of_walk ys \\<noteq> {}\""], ["proof (state)\nthis:\n  edges_of_walk xs \\<inter> edges_of_walk ys \\<noteq> {}\n\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<inter> edges_of_walk ys \\<noteq> {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  edges_of_walk xs \\<inter> edges_of_walk ys \\<noteq> {}", "obtain v w where v_w: \"(v,w) \\<in> edges_of_walk xs\" \"(v,w) \\<in> edges_of_walk ys\""], ["proof (prove)\nusing this:\n  edges_of_walk xs \\<inter> edges_of_walk ys \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>v w.\n        \\<lbrakk>(v, w) \\<in> edges_of_walk xs;\n         (v, w) \\<in> edges_of_walk ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (v, w) \\<in> edges_of_walk xs\n  (v, w) \\<in> edges_of_walk ys\n\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<inter> edges_of_walk ys \\<noteq> {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> edges_of_walk xs\n  (v, w) \\<in> edges_of_walk ys", "have \"v \\<in> set xs\" \"w \\<in> set xs\" \"v \\<in> set ys\" \"w \\<in> set ys\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> edges_of_walk xs\n  (v, w) \\<in> edges_of_walk ys\n\ngoal (1 subgoal):\n 1. (v \\<in> set xs &&& w \\<in> set xs) &&&\n    v \\<in> set ys &&& w \\<in> set ys", "by (meson walk_edges_vertices)+"], ["proof (state)\nthis:\n  v \\<in> set xs\n  w \\<in> set xs\n  v \\<in> set ys\n  w \\<in> set ys\n\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<inter> edges_of_walk ys \\<noteq> {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v \\<in> set xs\n  w \\<in> set xs\n  v \\<in> set ys\n  w \\<in> set ys", "have \"v = v0 \\<or> v = v1\" \"w = v0 \\<or> w = v1\""], ["proof (prove)\nusing this:\n  v \\<in> set xs\n  w \\<in> set xs\n  v \\<in> set ys\n  w \\<in> set ys\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1 &&& w = v0 \\<or> w = v1", "using assms paths_disjoint"], ["proof (prove)\nusing this:\n  v \\<in> set xs\n  w \\<in> set xs\n  v \\<in> set ys\n  w \\<in> set ys\n  xs \\<in> paths\n  ys \\<in> paths\n  xs \\<noteq> ys\n  \\<lbrakk>?xs \\<in> paths; ?ys \\<in> paths; ?xs \\<noteq> ?ys;\n   ?v \\<in> set ?xs; ?v \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?v = v0 \\<or> ?v = v1\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1 &&& w = v0 \\<or> w = v1", "by blast+"], ["proof (state)\nthis:\n  v = v0 \\<or> v = v1\n  w = v0 \\<or> w = v1\n\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<inter> edges_of_walk ys \\<noteq> {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v = v0 \\<or> v = v1\n  w = v0 \\<or> w = v1", "show False"], ["proof (prove)\nusing this:\n  v = v0 \\<or> v = v1\n  w = v0 \\<or> w = v1\n\ngoal (1 subgoal):\n 1. False", "using v_w(1) assms(1) v0_nonadj_v1 edges_of_walk_edge path_edges"], ["proof (prove)\nusing this:\n  v = v0 \\<or> v = v1\n  w = v0 \\<or> w = v1\n  (v, w) \\<in> edges_of_walk xs\n  xs \\<in> paths\n  (v0, v1) \\<notin> E\n  \\<lbrakk>walk ?xs; (?v, ?w) \\<in> edges_of_walk ?xs\\<rbrakk>\n  \\<Longrightarrow> ?v \\<rightarrow> ?w\n  \\<lbrakk>path ?xs; (?v, ?w) \\<in> edges_of_walk ?xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs_pre xs_post.\n                       ?xs = xs_pre @ ?v # ?w # xs_post \\<and>\n                       (?v, ?w)\n                       \\<notin> edges_of_walk (xs_pre @ [?v]) \\<and>\n                       (?v, ?w) \\<notin> edges_of_walk (?w # xs_post)\n\ngoal (1 subgoal):\n 1. False", "by (metis distinct_length_2_or_more path_decomp(2) path_from_to_def path_from_to_ends paths)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Specify the conditions for adding a new disjoint path to the set of disjoint paths.\\<close>"], ["", "lemma DisjointPaths_extend:\n  assumes P_path: \"v0\\<leadsto>P\\<leadsto>v1\"\n      and P_disjoint: \"\\<And>xs v. \\<lbrakk> xs \\<in> paths; xs \\<noteq> P; v \\<in> set xs; v \\<in> set P \\<rbrakk> \\<Longrightarrow> v = v0 \\<or> v = v1\"\n  shows \"DisjointPaths G v0 v1 (insert P paths)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 (insert P paths)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       xs \\<in> insert P paths \\<Longrightarrow>\n       v0 \\<leadsto>xs\\<leadsto> v1\n 2. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> insert P paths; ys \\<in> insert P paths;\n        xs \\<noteq> ys; v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "fix xs ys v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       xs \\<in> insert P paths \\<Longrightarrow>\n       v0 \\<leadsto>xs\\<leadsto> v1\n 2. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> insert P paths; ys \\<in> insert P paths;\n        xs \\<noteq> ys; v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "assume \"xs \\<in> insert P paths\" \"ys \\<in> insert P paths\" \"xs \\<noteq> ys\" \"v \\<in> set xs\" \"v \\<in> set ys\""], ["proof (state)\nthis:\n  xs \\<in> insert P paths\n  ys \\<in> insert P paths\n  xs \\<noteq> ys\n  v \\<in> set xs\n  v \\<in> set ys\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       xs \\<in> insert P paths \\<Longrightarrow>\n       v0 \\<leadsto>xs\\<leadsto> v1\n 2. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> insert P paths; ys \\<in> insert P paths;\n        xs \\<noteq> ys; v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "then"], ["proof (chain)\npicking this:\n  xs \\<in> insert P paths\n  ys \\<in> insert P paths\n  xs \\<noteq> ys\n  v \\<in> set xs\n  v \\<in> set ys", "show \"v = v0 \\<or> v = v1\""], ["proof (prove)\nusing this:\n  xs \\<in> insert P paths\n  ys \\<in> insert P paths\n  xs \\<noteq> ys\n  v \\<in> set xs\n  v \\<in> set ys\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1", "by (metis DisjointPaths.paths_disjoint DisjointPaths_axioms P_disjoint insert_iff)"], ["proof (state)\nthis:\n  v = v0 \\<or> v = v1\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> insert P paths \\<Longrightarrow>\n       v0 \\<leadsto>xs\\<leadsto> v1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> insert P paths \\<Longrightarrow>\n       v0 \\<leadsto>xs\\<leadsto> v1", "show \"\\<And>xs. xs \\<in> insert P paths \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> insert P paths \\<Longrightarrow>\n       v0 \\<leadsto>xs\\<leadsto> v1", "using P_path paths"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>P\\<leadsto> v1\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> insert P paths \\<Longrightarrow>\n       v0 \\<leadsto>xs\\<leadsto> v1", "by blast"], ["proof (state)\nthis:\n  ?xs \\<in> insert P paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DisjointPaths_reduce:\n  assumes \"paths' \\<subseteq> paths\"\n  shows \"DisjointPaths G v0 v1 paths'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 paths'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. xs \\<in> paths' \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1\n 2. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths'; ys \\<in> paths'; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. xs \\<in> paths' \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1\n 2. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths'; ys \\<in> paths'; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "assume \"xs \\<in> paths'\""], ["proof (state)\nthis:\n  xs \\<in> paths'\n\ngoal (2 subgoals):\n 1. \\<And>xs. xs \\<in> paths' \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1\n 2. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths'; ys \\<in> paths'; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "then"], ["proof (chain)\npicking this:\n  xs \\<in> paths'", "show \"v0 \\<leadsto>xs\\<leadsto> v1\""], ["proof (prove)\nusing this:\n  xs \\<in> paths'\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>xs\\<leadsto> v1", "using assms paths"], ["proof (prove)\nusing this:\n  xs \\<in> paths'\n  paths' \\<subseteq> paths\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>xs\\<leadsto> v1", "by blast"], ["proof (state)\nthis:\n  v0 \\<leadsto>xs\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths'; ys \\<in> paths'; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths'; ys \\<in> paths'; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "fix xs ys v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths'; ys \\<in> paths'; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "assume \"xs \\<in> paths'\" \"ys \\<in> paths'\" \"xs \\<noteq> ys\" \"v \\<in> set xs\" \"v \\<in> set ys\""], ["proof (state)\nthis:\n  xs \\<in> paths'\n  ys \\<in> paths'\n  xs \\<noteq> ys\n  v \\<in> set xs\n  v \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths'; ys \\<in> paths'; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "then"], ["proof (chain)\npicking this:\n  xs \\<in> paths'\n  ys \\<in> paths'\n  xs \\<noteq> ys\n  v \\<in> set xs\n  v \\<in> set ys", "show \"v = v0 \\<or> v = v1\""], ["proof (prove)\nusing this:\n  xs \\<in> paths'\n  ys \\<in> paths'\n  xs \\<noteq> ys\n  v \\<in> set xs\n  v \\<in> set ys\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1", "by (meson assms paths_disjoint subsetCE)"], ["proof (state)\nthis:\n  v = v0 \\<or> v = v1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Second Vertices\\<close>"], ["", "text \\<open>\n  Let us now define the set of second vertices of the paths.  We are going to need this in order\n  to find a path avoiding the old paths on its first edge.\n\\<close>"], ["", "definition second_vertex where \"second_vertex \\<equiv> \\<lambda>xs :: 'a Walk. hd (tl xs)\""], ["", "definition second_vertices where \"second_vertices \\<equiv> second_vertex ` paths\""], ["", "lemma second_vertex_inj: \"inj_on second_vertex paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on second_vertex paths", "unfolding second_vertex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>xs. hd (tl xs)) paths", "using paths_second_disjoint"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs \\<in> paths; ?ys \\<in> paths; ?xs \\<noteq> ?ys\\<rbrakk>\n  \\<Longrightarrow> hd (tl ?xs) \\<noteq> hd (tl ?ys)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>xs. hd (tl xs)) paths", "by (meson inj_onI)"], ["", "lemma second_vertices_card: \"card second_vertices = card paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card second_vertices = card paths", "unfolding second_vertices_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (second_vertex ` paths) = card paths", "using finite_paths card_image second_vertex_inj"], ["proof (prove)\nusing this:\n  finite paths\n  inj_on ?f ?A \\<Longrightarrow> card (?f ` ?A) = card ?A\n  inj_on second_vertex paths\n\ngoal (1 subgoal):\n 1. card (second_vertex ` paths) = card paths", "by blast"], ["", "lemma second_vertices_in_V: \"second_vertices \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. second_vertices \\<subseteq> V", "unfolding second_vertex_def second_vertices_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs. hd (tl xs)) ` paths \\<subseteq> V", "using paths_second_in_V"], ["proof (prove)\nusing this:\n  ?xs \\<in> paths \\<Longrightarrow> hd (tl ?xs) \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<lambda>xs. hd (tl xs)) ` paths \\<subseteq> V", "by blast"], ["", "lemma v0_v1_notin_second_vertices: \"v0 \\<notin> second_vertices\" \"v1 \\<notin> second_vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<notin> second_vertices &&& v1 \\<notin> second_vertices", "unfolding second_vertices_def second_vertex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<notin> (\\<lambda>xs. hd (tl xs)) ` paths &&&\n    v1 \\<notin> (\\<lambda>xs. hd (tl xs)) ` paths", "using paths_second_not_v0 paths_second_not_v1"], ["proof (prove)\nusing this:\n  ?xs \\<in> paths \\<Longrightarrow> hd (tl ?xs) \\<noteq> v0\n  ?xs \\<in> paths \\<Longrightarrow> hd (tl ?xs) \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v0 \\<notin> (\\<lambda>xs. hd (tl xs)) ` paths &&&\n    v1 \\<notin> (\\<lambda>xs. hd (tl xs)) ` paths", "by blast+"], ["", "lemma second_vertices_new_path: \"hd (tl xs) \\<notin> second_vertices \\<Longrightarrow> xs \\<notin> paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl xs) \\<notin> second_vertices \\<Longrightarrow> xs \\<notin> paths", "by (metis image_iff second_vertex_def second_vertices_def)"], ["", "lemma second_vertices_first_edge:\n  \"\\<lbrakk> xs \\<in> paths; first_edge_of_walk xs = (v,w) \\<rbrakk> \\<Longrightarrow> w \\<in> second_vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> paths; first_edge_of_walk xs = (v, w)\\<rbrakk>\n    \\<Longrightarrow> w \\<in> second_vertices", "unfolding second_vertices_def second_vertex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> paths; first_edge_of_walk xs = (v, w)\\<rbrakk>\n    \\<Longrightarrow> w \\<in> (\\<lambda>xs. hd (tl xs)) ` paths", "using first_edge_hd_tl paths paths_tl_notnil"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<leadsto>?xs\\<leadsto> ?w; tl ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> first_edge_of_walk ?xs = (?v, hd (tl ?xs))\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n  ?xs \\<in> paths \\<Longrightarrow> tl ?xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<in> paths; first_edge_of_walk xs = (v, w)\\<rbrakk>\n    \\<Longrightarrow> w \\<in> (\\<lambda>xs. hd (tl xs)) ` paths", "by fastforce"], ["", "text \\<open>\n  If we have no small separations, then the set of second vertices is not a separator and we can\n  find a path avoiding this set.\n\\<close>"], ["", "lemma disjoint_paths_new_path:\n  assumes no_small_separations: \"\\<And>S. Separation G v0 v1 S \\<Longrightarrow> card S \\<ge> Suc (card paths)\"\n  shows \"\\<exists>P_new. v0\\<leadsto>P_new\\<leadsto>v1 \\<and> set P_new \\<inter> second_vertices = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P_new.\n       v0 \\<leadsto>P_new\\<leadsto> v1 \\<and>\n       set P_new \\<inter> second_vertices = {}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P_new.\n       v0 \\<leadsto>P_new\\<leadsto> v1 \\<and>\n       set P_new \\<inter> second_vertices = {}", "have \"\\<not>Separation G v0 v1 second_vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Separation G v0 v1 second_vertices", "using no_small_separations second_vertices_card"], ["proof (prove)\nusing this:\n  Separation G v0 v1 ?S \\<Longrightarrow> Suc (card paths) \\<le> card ?S\n  card second_vertices = card paths\n\ngoal (1 subgoal):\n 1. \\<not> Separation G v0 v1 second_vertices", "by force"], ["proof (state)\nthis:\n  \\<not> Separation G v0 v1 second_vertices\n\ngoal (1 subgoal):\n 1. \\<exists>P_new.\n       v0 \\<leadsto>P_new\\<leadsto> v1 \\<and>\n       set P_new \\<inter> second_vertices = {}", "then"], ["proof (chain)\npicking this:\n  \\<not> Separation G v0 v1 second_vertices", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Separation G v0 v1 second_vertices\n\ngoal (1 subgoal):\n 1. \\<exists>P_new.\n       v0 \\<leadsto>P_new\\<leadsto> v1 \\<and>\n       set P_new \\<inter> second_vertices = {}", "by (simp add: path_exists_if_no_separation second_vertices_in_V v0_v1_notin_second_vertices)"], ["proof (state)\nthis:\n  \\<exists>P_new.\n     v0 \\<leadsto>P_new\\<leadsto> v1 \\<and>\n     set P_new \\<inter> second_vertices = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We need the following predicate to find the first vertex on a new path that hits one of the\n  other paths.  We add the condition @{term \"x = v1\"} to cover the case @{term \"paths = {}\"}.\n\\<close>"], ["", "definition hitting_paths where\n  \"hitting_paths \\<equiv> \\<lambda>x. x \\<noteq> v0 \\<and> ((\\<exists>xs \\<in> paths. x \\<in> set xs) \\<or> x = v1)\""], ["", "end \\<comment> \\<open>DisjointPaths\\<close>"], ["", "section \\<open>One More Path\\<close>"], ["", "text \\<open>\n  Let us define a set of disjoint paths with one more path.  Except for the first and last vertex,\n  the new path must be disjoint from all other paths.  The first vertex must be @{term v0} and the\n  last vertex must be on some other path.  In the ideal case, the last vertex will be @{term v1},\n  in which case we are already done because we have found a new disjoint path between @{term v0}\n  and @{term v1}.\n\\<close>"], ["", "locale DisjointPathsPlusOne = DisjointPaths +\n  fixes P_new :: \"'a Walk\"\n  assumes P_new:\n    \"v0 \\<leadsto>P_new\\<leadsto> (last P_new)\"\n  and tl_P_new:\n    \"tl P_new \\<noteq> Nil\"\n    \"hd (tl P_new) \\<notin> second_vertices\"\n  and last_P_new:\n    \"hitting_paths (last P_new)\"\n    \"\\<And>v. v \\<in> set (butlast P_new) \\<Longrightarrow> \\<not>hitting_paths v\"\nbegin"], ["", "subsection \\<open>Characterizing the New Path\\<close>"], ["", "lemma P_new_hd_disjoint: \"\\<And>xs. xs \\<in> paths \\<Longrightarrow> hd (tl P_new) \\<noteq> hd (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths \\<Longrightarrow> hd (tl P_new) \\<noteq> hd (tl xs)", "using tl_P_new(2)"], ["proof (prove)\nusing this:\n  hd (tl P_new) \\<notin> second_vertices\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths \\<Longrightarrow> hd (tl P_new) \\<noteq> hd (tl xs)", "unfolding second_vertices_def second_vertex_def"], ["proof (prove)\nusing this:\n  hd (tl P_new) \\<notin> (\\<lambda>xs. hd (tl xs)) ` paths\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths \\<Longrightarrow> hd (tl P_new) \\<noteq> hd (tl xs)", "by blast"], ["", "lemma P_new_new: \"P_new \\<notin> paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_new \\<notin> paths", "using P_new_hd_disjoint"], ["proof (prove)\nusing this:\n  ?xs \\<in> paths \\<Longrightarrow> hd (tl P_new) \\<noteq> hd (tl ?xs)\n\ngoal (1 subgoal):\n 1. P_new \\<notin> paths", "by auto"], ["", "definition paths_with_new where \"paths_with_new \\<equiv> insert P_new paths\""], ["", "lemma card_paths_with_new: \"card paths_with_new = Suc (card paths)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card paths_with_new = Suc (card paths)", "unfolding paths_with_new_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert P_new paths) = Suc (card paths)", "using P_new_new"], ["proof (prove)\nusing this:\n  P_new \\<notin> paths\n\ngoal (1 subgoal):\n 1. card (insert P_new paths) = Suc (card paths)", "by (simp add: finite_paths)"], ["", "lemma paths_with_new_no_Nil: \"Nil \\<notin> paths_with_new\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<notin> paths_with_new", "using P_new paths_tl_notnil paths_with_new_def"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>P_new\\<leadsto> last P_new\n  ?xs \\<in> paths \\<Longrightarrow> tl ?xs \\<noteq> []\n  paths_with_new \\<equiv> insert P_new paths\n\ngoal (1 subgoal):\n 1. [] \\<notin> paths_with_new", "by fastforce"], ["", "lemma paths_with_new_path: \"xs \\<in> paths_with_new \\<Longrightarrow> path xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> paths_with_new \\<Longrightarrow> path xs", "using P_new paths paths_with_new_def"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>P_new\\<leadsto> last P_new\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n  paths_with_new \\<equiv> insert P_new paths\n\ngoal (1 subgoal):\n 1. xs \\<in> paths_with_new \\<Longrightarrow> path xs", "by auto"], ["", "lemma paths_with_new_start_in_v0: \"xs \\<in> paths_with_new \\<Longrightarrow> hd xs = v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> paths_with_new \\<Longrightarrow> hd xs = v0", "using P_new paths paths_with_new_def"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>P_new\\<leadsto> last P_new\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n  paths_with_new \\<equiv> insert P_new paths\n\ngoal (1 subgoal):\n 1. xs \\<in> paths_with_new \\<Longrightarrow> hd xs = v0", "by auto"], ["", "subsection \\<open>The Last Vertex of the New Path\\<close>"], ["", "text \\<open>\n  McCuaig in \\cite{DBLP:journals/jgt/McCuaig84} calls the last vertex of @{term P_new} by the name\n  @{term x}.  However, this name is somewhat confusing because it is so short and it will be visible\n  in most places from now on, so let us give this vertex the more descriptive name of\n  @{term new_last}.\n\\<close>"], ["", "definition new_pre where \"new_pre \\<equiv> butlast P_new\""], ["", "definition new_last where \"new_last \\<equiv> last P_new\""], ["", "lemma P_new_decomp: \"P_new = new_pre @ [new_last]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_new = new_pre @ [new_last]", "by (metis new_pre_def append_butlast_last_id list.sel(2) tl_P_new(1) new_last_def)"], ["", "lemma new_pre_not_Nil: \"new_pre \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_pre \\<noteq> []", "using P_new(1) hitting_paths_def"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>P_new\\<leadsto> last P_new\n  hitting_paths \\<equiv>\n  \\<lambda>x.\n     x \\<noteq> v0 \\<and>\n     ((\\<exists>xs\\<in>paths. x \\<in> set xs) \\<or> x = v1)\n\ngoal (1 subgoal):\n 1. new_pre \\<noteq> []", "by (metis P_new_decomp list.sel(3) self_append_conv2 tl_P_new(1))"], ["", "lemma new_pre_hitting: \"x' \\<in> set new_pre \\<Longrightarrow> \\<not>hitting_paths x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> set new_pre \\<Longrightarrow> \\<not> hitting_paths x'", "by (simp add: new_pre_def last_P_new(2))"], ["", "lemma P_hit: \"hitting_paths new_last\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hitting_paths new_last", "by (simp add: last_P_new(1) new_last_def)"], ["", "lemma new_last_neq_v0: \"new_last \\<noteq> v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<noteq> v0", "using hitting_paths_def P_hit"], ["proof (prove)\nusing this:\n  hitting_paths \\<equiv>\n  \\<lambda>x.\n     x \\<noteq> v0 \\<and>\n     ((\\<exists>xs\\<in>paths. x \\<in> set xs) \\<or> x = v1)\n  hitting_paths new_last\n\ngoal (1 subgoal):\n 1. new_last \\<noteq> v0", "by force"], ["", "lemma new_last_in_V: \"new_last \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<in> V", "using P_new new_last_def path_in_V"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>P_new\\<leadsto> last P_new\n  new_last \\<equiv> last P_new\n  path ?xs \\<Longrightarrow> set ?xs \\<subseteq> V\n\ngoal (1 subgoal):\n 1. new_last \\<in> V", "by fastforce"], ["", "lemma new_last_to_v1: \"\\<exists>R. new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "assume \"new_last = v1\""], ["proof (state)\nthis:\n  new_last = v1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "then"], ["proof (chain)\npicking this:\n  new_last = v1", "have \"new_last \\<leadsto>[v1]\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\""], ["proof (prove)\nusing this:\n  new_last = v1\n\ngoal (1 subgoal):\n 1. new_last \\<leadsto>[v1]\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "by (metis last.simps list.sel(1) list.set(1) list.simps(15) list.simps(3) path_from_to_def\n        path_singleton remove_vertex_path_from_to singletonD v0_V v0_neq_v1 v1_V)"], ["proof (state)\nthis:\n  new_last \\<leadsto>[v1]\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "then"], ["proof (chain)\npicking this:\n  new_last \\<leadsto>[v1]\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "show ?thesis"], ["proof (prove)\nusing this:\n  new_last \\<leadsto>[v1]\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\n\ngoal (1 subgoal):\n 1. \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "by blast"], ["proof (state)\nthis:\n  \\<exists>R.\n     new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\n\ngoal (1 subgoal):\n 1. new_last \\<noteq> v1 \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. new_last \\<noteq> v1 \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "assume \"new_last \\<noteq> v1\""], ["proof (state)\nthis:\n  new_last \\<noteq> v1\n\ngoal (1 subgoal):\n 1. new_last \\<noteq> v1 \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "then"], ["proof (chain)\npicking this:\n  new_last \\<noteq> v1", "obtain xs where xs: \"xs \\<in> paths\" \"new_last \\<in> set xs\""], ["proof (prove)\nusing this:\n  new_last \\<noteq> v1\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs \\<in> paths; new_last \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hitting_paths_def last_P_new(1) new_last_def"], ["proof (prove)\nusing this:\n  new_last \\<noteq> v1\n  hitting_paths \\<equiv>\n  \\<lambda>x.\n     x \\<noteq> v0 \\<and>\n     ((\\<exists>xs\\<in>paths. x \\<in> set xs) \\<or> x = v1)\n  hitting_paths (last P_new)\n  new_last \\<equiv> last P_new\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs \\<in> paths; new_last \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs \\<in> paths\n  new_last \\<in> set xs\n\ngoal (1 subgoal):\n 1. new_last \\<noteq> v1 \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "then"], ["proof (chain)\npicking this:\n  xs \\<in> paths\n  new_last \\<in> set xs", "obtain xs_pre xs_post where xs_decomp: \"xs = xs_pre @ new_last # xs_post\""], ["proof (prove)\nusing this:\n  xs \\<in> paths\n  new_last \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs_pre xs_post.\n        xs = xs_pre @ new_last # xs_post \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = xs_pre @ new_last # xs_post\n\ngoal (1 subgoal):\n 1. new_last \\<noteq> v1 \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "then"], ["proof (chain)\npicking this:\n  xs = xs_pre @ new_last # xs_post", "have \"new_last \\<leadsto>(new_last # xs_post)\\<leadsto> v1\""], ["proof (prove)\nusing this:\n  xs = xs_pre @ new_last # xs_post\n\ngoal (1 subgoal):\n 1. new_last \\<leadsto>(new_last # xs_post)\\<leadsto> v1", "using \\<open>xs \\<in> paths\\<close>"], ["proof (prove)\nusing this:\n  xs = xs_pre @ new_last # xs_post\n  xs \\<in> paths\n\ngoal (1 subgoal):\n 1. new_last \\<leadsto>(new_last # xs_post)\\<leadsto> v1", "by (metis paths last_appendR list.sel(1) list.simps(3) path_decomp(2) path_from_to_def)"], ["proof (state)\nthis:\n  new_last \\<leadsto>(new_last # xs_post)\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. new_last \\<noteq> v1 \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "then"], ["proof (chain)\npicking this:\n  new_last \\<leadsto>(new_last # xs_post)\\<leadsto> v1", "have \"new_last \\<leadsto>(new_last # xs_post)\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\""], ["proof (prove)\nusing this:\n  new_last \\<leadsto>(new_last # xs_post)\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. new_last \\<leadsto>(new_last #\n                        xs_post)\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "using remove_vertex_path_from_to"], ["proof (prove)\nusing this:\n  new_last \\<leadsto>(new_last # xs_post)\\<leadsto> v1\n  \\<lbrakk>?v \\<leadsto>?xs\\<leadsto> ?w; ?x \\<in> V;\n   ?x \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> ?v \\<leadsto>?xs\\<leadsto>\\<^bsub>remove_vertex ?x\\<^esub> ?w\n\ngoal (1 subgoal):\n 1. new_last \\<leadsto>(new_last #\n                        xs_post)\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "by (metis paths Set.set_insert xs_decomp xs(1) disjoint_insert(1) distinct_append hd_append\n        hitting_paths_def last_P_new(1) list.set_sel(1) path_from_to_def v0_V new_last_def)"], ["proof (state)\nthis:\n  new_last \\<leadsto>(new_last #\n                      xs_post)\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\n\ngoal (1 subgoal):\n 1. new_last \\<noteq> v1 \\<Longrightarrow>\n    \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "then"], ["proof (chain)\npicking this:\n  new_last \\<leadsto>(new_last #\n                      xs_post)\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "show ?thesis"], ["proof (prove)\nusing this:\n  new_last \\<leadsto>(new_last #\n                      xs_post)\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\n\ngoal (1 subgoal):\n 1. \\<exists>R.\n       new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1", "by blast"], ["proof (state)\nthis:\n  \\<exists>R.\n     new_last \\<leadsto>R\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma paths_plus_one_disjoint:\n  assumes \"xs \\<in> paths_with_new\" \"ys \\<in> paths_with_new\" \"xs \\<noteq> ys\" \"v \\<in> set xs\" \"v \\<in> set ys\"\n  shows \"v = v0 \\<or> v = v1 \\<or> v = new_last\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1 \\<or> v = new_last", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1 \\<or> v = new_last", "have \"xs \\<in> paths \\<or> ys \\<in> paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> paths \\<or> ys \\<in> paths", "using assms(1,2,3) paths_with_new_def"], ["proof (prove)\nusing this:\n  xs \\<in> paths_with_new\n  ys \\<in> paths_with_new\n  xs \\<noteq> ys\n  paths_with_new \\<equiv> insert P_new paths\n\ngoal (1 subgoal):\n 1. xs \\<in> paths \\<or> ys \\<in> paths", "by auto"], ["proof (state)\nthis:\n  xs \\<in> paths \\<or> ys \\<in> paths\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1 \\<or> v = new_last", "then"], ["proof (chain)\npicking this:\n  xs \\<in> paths \\<or> ys \\<in> paths", "have \"hitting_paths v \\<or> v = v0\""], ["proof (prove)\nusing this:\n  xs \\<in> paths \\<or> ys \\<in> paths\n\ngoal (1 subgoal):\n 1. hitting_paths v \\<or> v = v0", "using assms(1,2,4,5)"], ["proof (prove)\nusing this:\n  xs \\<in> paths \\<or> ys \\<in> paths\n  xs \\<in> paths_with_new\n  ys \\<in> paths_with_new\n  v \\<in> set xs\n  v \\<in> set ys\n\ngoal (1 subgoal):\n 1. hitting_paths v \\<or> v = v0", "unfolding hitting_paths_def"], ["proof (prove)\nusing this:\n  xs \\<in> paths \\<or> ys \\<in> paths\n  xs \\<in> paths_with_new\n  ys \\<in> paths_with_new\n  v \\<in> set xs\n  v \\<in> set ys\n\ngoal (1 subgoal):\n 1. v \\<noteq> v0 \\<and>\n    ((\\<exists>xs\\<in>paths. v \\<in> set xs) \\<or> v = v1) \\<or>\n    v = v0", "by blast"], ["proof (state)\nthis:\n  hitting_paths v \\<or> v = v0\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1 \\<or> v = new_last", "then"], ["proof (chain)\npicking this:\n  hitting_paths v \\<or> v = v0", "show ?thesis"], ["proof (prove)\nusing this:\n  hitting_paths v \\<or> v = v0\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1 \\<or> v = new_last", "using assms last_P_new(2) set_butlast paths_disjoint"], ["proof (prove)\nusing this:\n  hitting_paths v \\<or> v = v0\n  xs \\<in> paths_with_new\n  ys \\<in> paths_with_new\n  xs \\<noteq> ys\n  v \\<in> set xs\n  v \\<in> set ys\n  ?v \\<in> set (butlast P_new) \\<Longrightarrow> \\<not> hitting_paths ?v\n  \\<lbrakk>?x \\<in> set ?xs; ?x \\<noteq> last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> set (butlast ?xs)\n  \\<lbrakk>?xs \\<in> paths; ?ys \\<in> paths; ?xs \\<noteq> ?ys;\n   ?v \\<in> set ?xs; ?v \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?v = v0 \\<or> ?v = v1\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1 \\<or> v = new_last", "by (metis insert_iff paths_with_new_def new_last_def)"], ["proof (state)\nthis:\n  v = v0 \\<or> v = v1 \\<or> v = new_last\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If the new path is disjoint, we are happy.\\<close>"], ["", "lemma P_new_solves_if_disjoint:\n  \"new_last = v1 \\<Longrightarrow> \\<exists>paths'. DisjointPaths G v0 v1 paths' \\<and> card paths' = Suc (card paths)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last = v1 \\<Longrightarrow>\n    \\<exists>paths'.\n       DisjointPaths G v0 v1 paths' \\<and> card paths' = Suc (card paths)", "using DisjointPaths_extend P_new(1) paths_plus_one_disjoint card_paths_with_new"], ["proof (prove)\nusing this:\n  \\<lbrakk>v0 \\<leadsto>?P\\<leadsto> v1;\n   \\<And>xs v.\n      \\<lbrakk>xs \\<in> paths; xs \\<noteq> ?P; v \\<in> set xs;\n       v \\<in> set ?P\\<rbrakk>\n      \\<Longrightarrow> v = v0 \\<or> v = v1\\<rbrakk>\n  \\<Longrightarrow> DisjointPaths G v0 v1 (insert ?P paths)\n  v0 \\<leadsto>P_new\\<leadsto> last P_new\n  \\<lbrakk>?xs \\<in> paths_with_new; ?ys \\<in> paths_with_new;\n   ?xs \\<noteq> ?ys; ?v \\<in> set ?xs; ?v \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?v = v0 \\<or> ?v = v1 \\<or> ?v = new_last\n  card paths_with_new = Suc (card paths)\n\ngoal (1 subgoal):\n 1. new_last = v1 \\<Longrightarrow>\n    \\<exists>paths'.\n       DisjointPaths G v0 v1 paths' \\<and> card paths' = Suc (card paths)", "unfolding paths_with_new_def new_last_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>v0 \\<leadsto>?P\\<leadsto> v1;\n   \\<And>xs v.\n      \\<lbrakk>xs \\<in> paths; xs \\<noteq> ?P; v \\<in> set xs;\n       v \\<in> set ?P\\<rbrakk>\n      \\<Longrightarrow> v = v0 \\<or> v = v1\\<rbrakk>\n  \\<Longrightarrow> DisjointPaths G v0 v1 (insert ?P paths)\n  v0 \\<leadsto>P_new\\<leadsto> last P_new\n  \\<lbrakk>?xs \\<in> insert P_new paths; ?ys \\<in> insert P_new paths;\n   ?xs \\<noteq> ?ys; ?v \\<in> set ?xs; ?v \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?v = v0 \\<or> ?v = v1 \\<or> ?v = last P_new\n  card (insert P_new paths) = Suc (card paths)\n\ngoal (1 subgoal):\n 1. last P_new = v1 \\<Longrightarrow>\n    \\<exists>paths'.\n       DisjointPaths G v0 v1 paths' \\<and> card paths' = Suc (card paths)", "by blast"], ["", "subsection \\<open>Removing the Last Vertex\\<close>"], ["", "definition H_x where \"H_x \\<equiv> remove_vertex new_last\""], ["", "lemma H_x_Digraph: \"Digraph H_x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph H_x", "unfolding H_x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph (remove_vertex new_last)", "using remove_vertex_Digraph"], ["proof (prove)\nusing this:\n  Digraph (remove_vertex ?v)\n\ngoal (1 subgoal):\n 1. Digraph (remove_vertex new_last)", "."], ["", "lemma H_x_v0_v1_Digraph: \"new_last \\<noteq> v1 \\<Longrightarrow> v0_v1_Digraph H_x v0 v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<noteq> v1 \\<Longrightarrow> v0_v1_Digraph H_x v0 v1", "unfolding H_x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<noteq> v1 \\<Longrightarrow>\n    v0_v1_Digraph (remove_vertex new_last) v0 v1", "using remove_vertices_v0_v1_Digraph hitting_paths_def P_hit"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<noteq> v0; ?v \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> v0_v1_Digraph (remove_vertex ?v) v0 v1\n  hitting_paths \\<equiv>\n  \\<lambda>x.\n     x \\<noteq> v0 \\<and>\n     ((\\<exists>xs\\<in>paths. x \\<in> set xs) \\<or> x = v1)\n  hitting_paths new_last\n\ngoal (1 subgoal):\n 1. new_last \\<noteq> v1 \\<Longrightarrow>\n    v0_v1_Digraph (remove_vertex new_last) v0 v1", "by (simp add: H_x_def)"], ["", "subsection \\<open>A New Path Following the Other Paths\\<close>"], ["", "text \\<open>\n  The following lemma is one of the most complicated technical lemmas in the proof of Menger's\n  Theorem.\n\n  Suppose we have a non-trivial path whose edges are all in the edge set of @{term path_with_new}\n  and whose first edge equals the first edge of some @{term \"P \\<in> path_with_new\"}.  Also suppose that\n  the path does not contain @{term v1} or @{term new_last}.  Then it follows by induction that this\n  path is an initial segment of @{term P}.\n\n  Note that McCuaig does not mention this statement at all in his proof because it looks so obvious.\n\\<close>"], ["", "lemma new_path_follows_old_paths:\n  assumes xs: \"v0 \\<leadsto>xs\\<leadsto> w\" \"tl xs \\<noteq> Nil\" \"v1 \\<notin> set xs\" \"new_last \\<notin> set xs\"\n      and P: \"P \\<in> paths_with_new\" \"hd (tl xs) = hd (tl P)\"\n      and edges_subset: \"edges_of_walk xs \\<subseteq> \\<Union>(edges_of_walk ` paths_with_new)\"\n    shows \"edges_of_walk xs \\<subseteq> edges_of_walk P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<subseteq> edges_of_walk P", "using xs P(2) edges_subset"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>xs\\<leadsto> w\n  tl xs \\<noteq> []\n  v1 \\<notin> set xs\n  new_last \\<notin> set xs\n  hd (tl xs) = hd (tl P)\n  edges_of_walk xs \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<subseteq> edges_of_walk P", "proof (induct \"length xs\" arbitrary: xs w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs w.\n       \\<lbrakk>0 = length xs; v0 \\<leadsto>xs\\<leadsto> w;\n        tl xs \\<noteq> []; v1 \\<notin> set xs; new_last \\<notin> set xs;\n        hd (tl xs) = hd (tl P);\n        edges_of_walk xs\n        \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\\<rbrakk>\n       \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<And>x xs w.\n       \\<lbrakk>\\<And>xs w.\n                   \\<lbrakk>x = length xs; v0 \\<leadsto>xs\\<leadsto> w;\n                    tl xs \\<noteq> []; v1 \\<notin> set xs;\n                    new_last \\<notin> set xs; hd (tl xs) = hd (tl P);\n                    edges_of_walk xs\n                    \\<subseteq> \\<Union>\n                                 (edges_of_walk ` paths_with_new)\\<rbrakk>\n                   \\<Longrightarrow> edges_of_walk xs\n                                     \\<subseteq> edges_of_walk P;\n        Suc x = length xs; v0 \\<leadsto>xs\\<leadsto> w; tl xs \\<noteq> [];\n        v1 \\<notin> set xs; new_last \\<notin> set xs;\n        hd (tl xs) = hd (tl P);\n        edges_of_walk xs\n        \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\\<rbrakk>\n       \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "case 0"], ["proof (state)\nthis:\n  0 = length xs\n  v0 \\<leadsto>xs\\<leadsto> w\n  tl xs \\<noteq> []\n  v1 \\<notin> set xs\n  new_last \\<notin> set xs\n  hd (tl xs) = hd (tl P)\n  edges_of_walk xs \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\n\ngoal (2 subgoals):\n 1. \\<And>xs w.\n       \\<lbrakk>0 = length xs; v0 \\<leadsto>xs\\<leadsto> w;\n        tl xs \\<noteq> []; v1 \\<notin> set xs; new_last \\<notin> set xs;\n        hd (tl xs) = hd (tl P);\n        edges_of_walk xs\n        \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\\<rbrakk>\n       \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<And>x xs w.\n       \\<lbrakk>\\<And>xs w.\n                   \\<lbrakk>x = length xs; v0 \\<leadsto>xs\\<leadsto> w;\n                    tl xs \\<noteq> []; v1 \\<notin> set xs;\n                    new_last \\<notin> set xs; hd (tl xs) = hd (tl P);\n                    edges_of_walk xs\n                    \\<subseteq> \\<Union>\n                                 (edges_of_walk ` paths_with_new)\\<rbrakk>\n                   \\<Longrightarrow> edges_of_walk xs\n                                     \\<subseteq> edges_of_walk P;\n        Suc x = length xs; v0 \\<leadsto>xs\\<leadsto> w; tl xs \\<noteq> [];\n        v1 \\<notin> set xs; new_last \\<notin> set xs;\n        hd (tl xs) = hd (tl P);\n        edges_of_walk xs\n        \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\\<rbrakk>\n       \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "then"], ["proof (chain)\npicking this:\n  0 = length xs\n  v0 \\<leadsto>xs\\<leadsto> w\n  tl xs \\<noteq> []\n  v1 \\<notin> set xs\n  new_last \\<notin> set xs\n  hd (tl xs) = hd (tl P)\n  edges_of_walk xs \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)", "show ?case"], ["proof (prove)\nusing this:\n  0 = length xs\n  v0 \\<leadsto>xs\\<leadsto> w\n  tl xs \\<noteq> []\n  v1 \\<notin> set xs\n  new_last \\<notin> set xs\n  hd (tl xs) = hd (tl P)\n  edges_of_walk xs \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<subseteq> edges_of_walk P", "using xs(1)"], ["proof (prove)\nusing this:\n  0 = length xs\n  v0 \\<leadsto>xs\\<leadsto> w\n  tl xs \\<noteq> []\n  v1 \\<notin> set xs\n  new_last \\<notin> set xs\n  hd (tl xs) = hd (tl P)\n  edges_of_walk xs \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\n  v0 \\<leadsto>xs\\<leadsto> w\n\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<subseteq> edges_of_walk P", "by auto"], ["proof (state)\nthis:\n  edges_of_walk xs \\<subseteq> edges_of_walk P\n\ngoal (1 subgoal):\n 1. \\<And>x xs w.\n       \\<lbrakk>\\<And>xs w.\n                   \\<lbrakk>x = length xs; v0 \\<leadsto>xs\\<leadsto> w;\n                    tl xs \\<noteq> []; v1 \\<notin> set xs;\n                    new_last \\<notin> set xs; hd (tl xs) = hd (tl P);\n                    edges_of_walk xs\n                    \\<subseteq> \\<Union>\n                                 (edges_of_walk ` paths_with_new)\\<rbrakk>\n                   \\<Longrightarrow> edges_of_walk xs\n                                     \\<subseteq> edges_of_walk P;\n        Suc x = length xs; v0 \\<leadsto>xs\\<leadsto> w; tl xs \\<noteq> [];\n        v1 \\<notin> set xs; new_last \\<notin> set xs;\n        hd (tl xs) = hd (tl P);\n        edges_of_walk xs\n        \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\\<rbrakk>\n       \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs w.\n       \\<lbrakk>\\<And>xs w.\n                   \\<lbrakk>x = length xs; v0 \\<leadsto>xs\\<leadsto> w;\n                    tl xs \\<noteq> []; v1 \\<notin> set xs;\n                    new_last \\<notin> set xs; hd (tl xs) = hd (tl P);\n                    edges_of_walk xs\n                    \\<subseteq> \\<Union>\n                                 (edges_of_walk ` paths_with_new)\\<rbrakk>\n                   \\<Longrightarrow> edges_of_walk xs\n                                     \\<subseteq> edges_of_walk P;\n        Suc x = length xs; v0 \\<leadsto>xs\\<leadsto> w; tl xs \\<noteq> [];\n        v1 \\<notin> set xs; new_last \\<notin> set xs;\n        hd (tl xs) = hd (tl P);\n        edges_of_walk xs\n        \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\\<rbrakk>\n       \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "case (Suc n xs w)"], ["proof (state)\nthis:\n  \\<lbrakk>n = length ?xs; v0 \\<leadsto>?xs\\<leadsto> ?w;\n   tl ?xs \\<noteq> []; v1 \\<notin> set ?xs; new_last \\<notin> set ?xs;\n   hd (tl ?xs) = hd (tl P);\n   edges_of_walk ?xs\n   \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\\<rbrakk>\n  \\<Longrightarrow> edges_of_walk ?xs \\<subseteq> edges_of_walk P\n  Suc n = length xs\n  v0 \\<leadsto>xs\\<leadsto> w\n  tl xs \\<noteq> []\n  v1 \\<notin> set xs\n  new_last \\<notin> set xs\n  hd (tl xs) = hd (tl P)\n  edges_of_walk xs \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. \\<And>x xs w.\n       \\<lbrakk>\\<And>xs w.\n                   \\<lbrakk>x = length xs; v0 \\<leadsto>xs\\<leadsto> w;\n                    tl xs \\<noteq> []; v1 \\<notin> set xs;\n                    new_last \\<notin> set xs; hd (tl xs) = hd (tl P);\n                    edges_of_walk xs\n                    \\<subseteq> \\<Union>\n                                 (edges_of_walk ` paths_with_new)\\<rbrakk>\n                   \\<Longrightarrow> edges_of_walk xs\n                                     \\<subseteq> edges_of_walk P;\n        Suc x = length xs; v0 \\<leadsto>xs\\<leadsto> w; tl xs \\<noteq> [];\n        v1 \\<notin> set xs; new_last \\<notin> set xs;\n        hd (tl xs) = hd (tl P);\n        edges_of_walk xs\n        \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\\<rbrakk>\n       \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "using Suc.hyps(2) Suc.prems(1,2)"], ["proof (prove)\nusing this:\n  Suc n = length xs\n  v0 \\<leadsto>xs\\<leadsto> w\n  tl xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by (metis path_from_toE Nitpick.size_list_simp(2) Suc_inject length_0_conv)"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs w.\n       \\<lbrakk>\\<And>xs w.\n                   \\<lbrakk>x = length xs; v0 \\<leadsto>xs\\<leadsto> w;\n                    tl xs \\<noteq> []; v1 \\<notin> set xs;\n                    new_last \\<notin> set xs; hd (tl xs) = hd (tl P);\n                    edges_of_walk xs\n                    \\<subseteq> \\<Union>\n                                 (edges_of_walk ` paths_with_new)\\<rbrakk>\n                   \\<Longrightarrow> edges_of_walk xs\n                                     \\<subseteq> edges_of_walk P;\n        Suc x = length xs; v0 \\<leadsto>xs\\<leadsto> w; tl xs \\<noteq> [];\n        v1 \\<notin> set xs; new_last \\<notin> set xs;\n        hd (tl xs) = hd (tl P);\n        edges_of_walk xs\n        \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\\<rbrakk>\n       \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<subseteq> edges_of_walk P", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<not> ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "assume \"n = Suc 0\""], ["proof (state)\nthis:\n  n = Suc 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<not> ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "then"], ["proof (chain)\npicking this:\n  n = Suc 0", "obtain v w where v_w: \"xs = [v,w]\""], ["proof (prove)\nusing this:\n  n = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>v w. xs = [v, w] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) Suc.hyps(2) length_0_conv length_Suc_conv)"], ["proof (state)\nthis:\n  xs = [v, w]\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<not> ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "then"], ["proof (chain)\npicking this:\n  xs = [v, w]", "have \"v = v0\""], ["proof (prove)\nusing this:\n  xs = [v, w]\n\ngoal (1 subgoal):\n 1. v = v0", "using Suc.prems(1)"], ["proof (prove)\nusing this:\n  xs = [v, w]\n  v0 \\<leadsto>xs\\<leadsto> wa__\n\ngoal (1 subgoal):\n 1. v = v0", "by auto"], ["proof (state)\nthis:\n  v = v0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<not> ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  v = v0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<not> ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"w = hd (tl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = hd (tl P)", "using Suc.prems(5) v_w"], ["proof (prove)\nusing this:\n  hd (tl xs) = hd (tl P)\n  xs = [v, w]\n\ngoal (1 subgoal):\n 1. w = hd (tl P)", "by auto"], ["proof (state)\nthis:\n  w = hd (tl P)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<not> ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  w = hd (tl P)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<not> ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"edges_of_walk xs = {(v, w)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk xs = {(v, w)}", "using v_w edges_of_walk_2"], ["proof (prove)\nusing this:\n  xs = [v, w]\n  edges_of_walk [?v, ?w] = {(?v, ?w)}\n\ngoal (1 subgoal):\n 1. edges_of_walk xs = {(v, w)}", "by simp"], ["proof (state)\nthis:\n  edges_of_walk xs = {(v, w)}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<not> ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  edges_of_walk xs = {(v, w)}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<not> ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"(v0, hd (tl P)) \\<in> edges_of_walk P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v0, hd (tl P)) \\<in> edges_of_walk P", "using P tl_P_new(1) P_new paths"], ["proof (prove)\nusing this:\n  P \\<in> paths_with_new\n  hd (tl xs) = hd (tl P)\n  tl P_new \\<noteq> []\n  v0 \\<leadsto>P_new\\<leadsto> last P_new\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. (v0, hd (tl P)) \\<in> edges_of_walk P", "by (metis first_edge_hd_tl first_edge_in_edges insert_iff paths_tl_notnil paths_with_new_def)"], ["proof (state)\nthis:\n  (v0, hd (tl P)) \\<in> edges_of_walk P\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P\n 2. \\<not> ?P \\<Longrightarrow> edges_of_walk xs \\<subseteq> edges_of_walk P", "ultimately"], ["proof (chain)\npicking this:\n  v = v0\n  w = hd (tl P)\n  edges_of_walk xs = {(v, w)}\n  (v0, hd (tl P)) \\<in> edges_of_walk P", "show ?thesis"], ["proof (prove)\nusing this:\n  v = v0\n  w = hd (tl P)\n  edges_of_walk xs = {(v, w)}\n  (v0, hd (tl P)) \\<in> edges_of_walk P\n\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<subseteq> edges_of_walk P", "by auto"], ["proof (state)\nthis:\n  edges_of_walk xs \\<subseteq> edges_of_walk P\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "assume \"n \\<noteq> Suc 0\""], ["proof (state)\nthis:\n  n \\<noteq> Suc 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "obtain xs' x where xs': \"xs = xs' @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' x. xs = xs' @ [x] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis path_from_toE Suc.prems(1) append_butlast_last_id)"], ["proof (state)\nthis:\n  xs = xs' @ [x]\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "then"], ["proof (chain)\npicking this:\n  xs = xs' @ [x]", "have \"n = length xs'\""], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n\ngoal (1 subgoal):\n 1. n = length xs'", "using xs'"], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n  xs = xs' @ [x]\n\ngoal (1 subgoal):\n 1. n = length xs'", "using Suc.hyps(2)"], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n  xs = xs' @ [x]\n  Suc n = length xs\n\ngoal (1 subgoal):\n 1. n = length xs'", "by auto"], ["proof (state)\nthis:\n  n = length xs'\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  n = length xs'\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "have xs'_path: \"v0 \\<leadsto>xs'\\<leadsto> last xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>xs'\\<leadsto> last xs'", "using xs' Suc.prems(1) \\<open>tl xs \\<noteq> Nil\\<close> walk_decomp(1)"], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n  v0 \\<leadsto>xs\\<leadsto> w\n  tl xs \\<noteq> []\n  walk (?xs @ ?ys) \\<Longrightarrow> walk ?xs\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>xs'\\<leadsto> last xs'", "by (metis distinct_append hd_append list.sel(3) path_from_to_def self_append_conv2)"], ["proof (state)\nthis:\n  v0 \\<leadsto>xs'\\<leadsto> last xs'\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  v0 \\<leadsto>xs'\\<leadsto> last xs'\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"tl xs' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl xs' \\<noteq> []", "using \\<open>n \\<noteq> Suc 0\\<close>"], ["proof (prove)\nusing this:\n  n \\<noteq> Suc 0\n\ngoal (1 subgoal):\n 1. tl xs' \\<noteq> []", "by (metis path_from_toE Nitpick.size_list_simp(2) calculation(1,2))"], ["proof (state)\nthis:\n  tl xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  tl xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"v1 \\<notin> set xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<notin> set xs'", "using xs' Suc.prems(3)"], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n  v1 \\<notin> set xs\n\ngoal (1 subgoal):\n 1. v1 \\<notin> set xs'", "by auto"], ["proof (state)\nthis:\n  v1 \\<notin> set xs'\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  v1 \\<notin> set xs'\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"new_last \\<notin> set xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<notin> set xs'", "using xs' Suc.prems(4)"], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n  new_last \\<notin> set xs\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set xs'", "by auto"], ["proof (state)\nthis:\n  new_last \\<notin> set xs'\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  new_last \\<notin> set xs'\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"hd (tl xs') = hd (tl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl xs') = hd (tl P)", "using xs' \\<open>tl xs' \\<noteq> []\\<close> Suc.prems(5) calculation(2)"], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n  tl xs' \\<noteq> []\n  hd (tl xs) = hd (tl P)\n  v0 \\<leadsto>xs'\\<leadsto> last xs'\n\ngoal (1 subgoal):\n 1. hd (tl xs') = hd (tl P)", "by auto"], ["proof (state)\nthis:\n  hd (tl xs') = hd (tl P)\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  hd (tl xs') = hd (tl P)\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"edges_of_walk xs' \\<subseteq> \\<Union>(edges_of_walk ` paths_with_new)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk xs' \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)", "using xs' Suc.prems(6) edges_of_comp1"], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n  edges_of_walk xs \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\n  edges_of_walk ?xs \\<subseteq> edges_of_walk (?xs @ ?ys)\n\ngoal (1 subgoal):\n 1. edges_of_walk xs' \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)", "by blast"], ["proof (state)\nthis:\n  edges_of_walk xs' \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "ultimately"], ["proof (chain)\npicking this:\n  n = length xs'\n  v0 \\<leadsto>xs'\\<leadsto> last xs'\n  tl xs' \\<noteq> []\n  v1 \\<notin> set xs'\n  new_last \\<notin> set xs'\n  hd (tl xs') = hd (tl P)\n  edges_of_walk xs' \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)", "have xs'_edges: \"edges_of_walk xs' \\<subseteq> edges_of_walk P\""], ["proof (prove)\nusing this:\n  n = length xs'\n  v0 \\<leadsto>xs'\\<leadsto> last xs'\n  tl xs' \\<noteq> []\n  v1 \\<notin> set xs'\n  new_last \\<notin> set xs'\n  hd (tl xs') = hd (tl P)\n  edges_of_walk xs' \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. edges_of_walk xs' \\<subseteq> edges_of_walk P", "using Suc.hyps(1)"], ["proof (prove)\nusing this:\n  n = length xs'\n  v0 \\<leadsto>xs'\\<leadsto> last xs'\n  tl xs' \\<noteq> []\n  v1 \\<notin> set xs'\n  new_last \\<notin> set xs'\n  hd (tl xs') = hd (tl P)\n  edges_of_walk xs' \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\n  \\<lbrakk>n = length ?xs; v0 \\<leadsto>?xs\\<leadsto> ?w;\n   tl ?xs \\<noteq> []; v1 \\<notin> set ?xs; new_last \\<notin> set ?xs;\n   hd (tl ?xs) = hd (tl P);\n   edges_of_walk ?xs\n   \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\\<rbrakk>\n  \\<Longrightarrow> edges_of_walk ?xs \\<subseteq> edges_of_walk P\n\ngoal (1 subgoal):\n 1. edges_of_walk xs' \\<subseteq> edges_of_walk P", "by blast"], ["proof (state)\nthis:\n  edges_of_walk xs' \\<subseteq> edges_of_walk P\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  edges_of_walk xs' \\<subseteq> edges_of_walk P\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"edges_of_walk xs = edges_of_walk xs' \\<union> { (last xs', x) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk xs = edges_of_walk xs' \\<union> {(last xs', x)}", "using xs'"], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n\ngoal (1 subgoal):\n 1. edges_of_walk xs = edges_of_walk xs' \\<union> {(last xs', x)}", "using walk_edges_decomp'[of \"butlast xs'\" \"last xs'\" x Nil] xs'_path"], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n  edges_of_walk (butlast xs' @ [last xs', x]) =\n  edges_of_walk (butlast xs' @ [last xs']) \\<union> {(last xs', x)} \\<union>\n  edges_of_walk [x]\n  v0 \\<leadsto>xs'\\<leadsto> last xs'\n\ngoal (1 subgoal):\n 1. edges_of_walk xs = edges_of_walk xs' \\<union> {(last xs', x)}", "by (metis path_from_toE Un_empty_right append_assoc append_butlast_last_id butlast.simps(2)\n          edges_of_walk_empty(2) last_ConsL last_ConsR list.distinct(1))"], ["proof (state)\nthis:\n  edges_of_walk xs = edges_of_walk xs' \\<union> {(last xs', x)}\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "moreover"], ["proof (state)\nthis:\n  edges_of_walk xs = edges_of_walk xs' \\<union> {(last xs', x)}\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "have \"(last xs', x) \\<in> edges_of_walk P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (last xs', x) \\<in> edges_of_walk P", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. (last xs', x) \\<notin> edges_of_walk P \\<Longrightarrow> False", "assume contra: \"(last xs', x) \\<notin> edges_of_walk P\""], ["proof (state)\nthis:\n  (last xs', x) \\<notin> edges_of_walk P\n\ngoal (1 subgoal):\n 1. (last xs', x) \\<notin> edges_of_walk P \\<Longrightarrow> False", "have xs_last_edge: \"(last xs', x) \\<in> edges_of_walk xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (last xs', x) \\<in> edges_of_walk xs", "using xs' calculation(2)"], ["proof (prove)\nusing this:\n  xs = xs' @ [x]\n  edges_of_walk xs = edges_of_walk xs' \\<union> {(last xs', x)}\n\ngoal (1 subgoal):\n 1. (last xs', x) \\<in> edges_of_walk xs", "by blast"], ["proof (state)\nthis:\n  (last xs', x) \\<in> edges_of_walk xs\n\ngoal (1 subgoal):\n 1. (last xs', x) \\<notin> edges_of_walk P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (last xs', x) \\<in> edges_of_walk xs", "obtain P' where\n        P': \"P' \\<in> paths_with_new\" \"(last xs', x) \\<in> edges_of_walk P'\""], ["proof (prove)\nusing this:\n  (last xs', x) \\<in> edges_of_walk xs\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>P' \\<in> paths_with_new;\n         (last xs', x) \\<in> edges_of_walk P'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.prems(6)"], ["proof (prove)\nusing this:\n  (last xs', x) \\<in> edges_of_walk xs\n  edges_of_walk xs \\<subseteq> \\<Union> (edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>P' \\<in> paths_with_new;\n         (last xs', x) \\<in> edges_of_walk P'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P' \\<in> paths_with_new\n  (last xs', x) \\<in> edges_of_walk P'\n\ngoal (1 subgoal):\n 1. (last xs', x) \\<notin> edges_of_walk P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  P' \\<in> paths_with_new\n  (last xs', x) \\<in> edges_of_walk P'", "have \"P \\<noteq> P'\""], ["proof (prove)\nusing this:\n  P' \\<in> paths_with_new\n  (last xs', x) \\<in> edges_of_walk P'\n\ngoal (1 subgoal):\n 1. P \\<noteq> P'", "using contra"], ["proof (prove)\nusing this:\n  P' \\<in> paths_with_new\n  (last xs', x) \\<in> edges_of_walk P'\n  (last xs', x) \\<notin> edges_of_walk P\n\ngoal (1 subgoal):\n 1. P \\<noteq> P'", "by blast"], ["proof (state)\nthis:\n  P \\<noteq> P'\n\ngoal (1 subgoal):\n 1. (last xs', x) \\<notin> edges_of_walk P \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  P \\<noteq> P'\n\ngoal (1 subgoal):\n 1. (last xs', x) \\<notin> edges_of_walk P \\<Longrightarrow> False", "have \"last xs' \\<in> set P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last xs' \\<in> set P", "using xs_last_edge xs'_edges \\<open>tl xs' \\<noteq> []\\<close> xs'_path"], ["proof (prove)\nusing this:\n  (last xs', x) \\<in> edges_of_walk xs\n  edges_of_walk xs' \\<subseteq> edges_of_walk P\n  tl xs' \\<noteq> []\n  v0 \\<leadsto>xs'\\<leadsto> last xs'\n\ngoal (1 subgoal):\n 1. last xs' \\<in> set P", "by (metis path_from_toE last_in_set subsetCE walk_edges_subset)"], ["proof (state)\nthis:\n  last xs' \\<in> set P\n\ngoal (1 subgoal):\n 1. (last xs', x) \\<notin> edges_of_walk P \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  last xs' \\<in> set P\n\ngoal (1 subgoal):\n 1. (last xs', x) \\<notin> edges_of_walk P \\<Longrightarrow> False", "have \"last xs' \\<in> set P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last xs' \\<in> set P'", "using P'(2)"], ["proof (prove)\nusing this:\n  (last xs', x) \\<in> edges_of_walk P'\n\ngoal (1 subgoal):\n 1. last xs' \\<in> set P'", "by (meson walk_edges_vertices(1))"], ["proof (state)\nthis:\n  last xs' \\<in> set P'\n\ngoal (1 subgoal):\n 1. (last xs', x) \\<notin> edges_of_walk P \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  P \\<noteq> P'\n  last xs' \\<in> set P\n  last xs' \\<in> set P'", "have \"last xs' = v0 \\<or> last xs' = v1 \\<or> last xs' = new_last\""], ["proof (prove)\nusing this:\n  P \\<noteq> P'\n  last xs' \\<in> set P\n  last xs' \\<in> set P'\n\ngoal (1 subgoal):\n 1. last xs' = v0 \\<or> last xs' = v1 \\<or> last xs' = new_last", "using paths_plus_one_disjoint P'(1) P paths_with_new_def"], ["proof (prove)\nusing this:\n  P \\<noteq> P'\n  last xs' \\<in> set P\n  last xs' \\<in> set P'\n  \\<lbrakk>?xs \\<in> paths_with_new; ?ys \\<in> paths_with_new;\n   ?xs \\<noteq> ?ys; ?v \\<in> set ?xs; ?v \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?v = v0 \\<or> ?v = v1 \\<or> ?v = new_last\n  P' \\<in> paths_with_new\n  P \\<in> paths_with_new\n  hd (tl xs) = hd (tl P)\n  paths_with_new \\<equiv> insert P_new paths\n\ngoal (1 subgoal):\n 1. last xs' = v0 \\<or> last xs' = v1 \\<or> last xs' = new_last", "by auto"], ["proof (state)\nthis:\n  last xs' = v0 \\<or> last xs' = v1 \\<or> last xs' = new_last\n\ngoal (1 subgoal):\n 1. (last xs', x) \\<notin> edges_of_walk P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  last xs' = v0 \\<or> last xs' = v1 \\<or> last xs' = new_last", "show False"], ["proof (prove)\nusing this:\n  last xs' = v0 \\<or> last xs' = v1 \\<or> last xs' = new_last\n\ngoal (1 subgoal):\n 1. False", "using Suc.prems(3) \\<open>new_last \\<notin> set xs'\\<close> \\<open>tl xs' \\<noteq> []\\<close> xs' xs'_path"], ["proof (prove)\nusing this:\n  last xs' = v0 \\<or> last xs' = v1 \\<or> last xs' = new_last\n  v1 \\<notin> set xs\n  new_last \\<notin> set xs'\n  tl xs' \\<noteq> []\n  xs = xs' @ [x]\n  v0 \\<leadsto>xs'\\<leadsto> last xs'\n\ngoal (1 subgoal):\n 1. False", "by (metis path_from_toE butlast_snoc in_set_butlastD last_in_set last_tl path_from_to_first)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (last xs', x) \\<in> edges_of_walk P\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc 0 \\<Longrightarrow>\n    edges_of_walk xs \\<subseteq> edges_of_walk P", "ultimately"], ["proof (chain)\npicking this:\n  edges_of_walk xs' \\<subseteq> edges_of_walk P\n  edges_of_walk xs = edges_of_walk xs' \\<union> {(last xs', x)}\n  (last xs', x) \\<in> edges_of_walk P", "show ?thesis"], ["proof (prove)\nusing this:\n  edges_of_walk xs' \\<subseteq> edges_of_walk P\n  edges_of_walk xs = edges_of_walk xs' \\<union> {(last xs', x)}\n  (last xs', x) \\<in> edges_of_walk P\n\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<subseteq> edges_of_walk P", "by simp"], ["proof (state)\nthis:\n  edges_of_walk xs \\<subseteq> edges_of_walk P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  edges_of_walk xs \\<subseteq> edges_of_walk P\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>locale @{locale DisjointPathsPlusOne}\\<close>"], ["", "end"]]}