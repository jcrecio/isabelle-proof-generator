{"file_name": "/home/qj213/afp-2021-10-22/thys/Menger/MengerInduction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Menger", "problem_names": ["lemma (in ProofStepInduct) hitting_paths_v1: \"hitting_paths v1\"", "lemma Q_exists: \"\\<exists>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size\"", "lemma Q: \"DisjointPaths H_x v0 v1 Q\" \"card Q = sep_size\"\n  and Q_min: \"\\<And>Q'. DisjointPaths H_x v0 v1 Q' \\<and> card Q' = sep_size \\<Longrightarrow> Q_weight Q \\<le> Q_weight Q'\"", "lemma P_k: \"P_k \\<in> paths_with_new\" \"hd (tl P_k) \\<notin> Q.second_vertices\"", "lemma path_P_k [simp]: \"path P_k\"", "lemma hd_P_k_v0 [simp]: \"hd P_k = v0\"", "lemma P_k_hits_Q: \"\\<exists>y \\<in> set P_k. hitting_Q_or_new_last y\"", "lemma (in ProofStepInduct_NonTrivial) ProofStepInduct_NonTrivial_P_k_pre_exists:\n  shows \"\\<exists>P_k_pre y P_k_post.\n     ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y P_k_post\"", "lemma y_neq_v0: \"y \\<noteq> v0\"", "lemma P_k_pre_not_Nil: \"P_k_pre \\<noteq> Nil\"", "lemma second_P_k_pre_not_in_Q: \"hd (tl (P_k_pre @ [y])) \\<notin> Q.second_vertices\"", "lemma y_eq_v1_implies_P_k_neq_P_new: assumes \"y = v1\" shows \"P_k \\<noteq> P_new\"", "lemma y_eq_v1_solves:\n    assumes \"y = v1\"\n    shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], "translations": [["", "lemma (in ProofStepInduct) hitting_paths_v1: \"hitting_paths v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hitting_paths v1", "unfolding hitting_paths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v0 \\<and>\n    ((\\<exists>xs\\<in>paths. v1 \\<in> set xs) \\<or> v1 = v1)", "using paths v0_neq_v1"], ["proof (prove)\nusing this:\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n  v0 \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v0 \\<and>\n    ((\\<exists>xs\\<in>paths. v1 \\<in> set xs) \\<or> v1 = v1)", "by force"], ["", "subsection \\<open>Choosing Paths Avoiding $new\\_last$\\<close>"], ["", "text \\<open>Let us now consider only the non-trivial case that @{term \"new_last \\<noteq> v1\"}.\\<close>"], ["", "locale ProofStepInduct_NonTrivial = ProofStepInduct +\n  assumes new_last_neq_v1: \"new_last \\<noteq> v1\"\nbegin"], ["", "text \\<open>\n  The next step is the observation that in the graph @{term \"remove_vertex new_last\"}, which \n  we called @{term H_x}, there are also @{term sep_size} many internally vertex-disjoint paths,\n  again by the induction hypothesis.\n\\<close>"], ["", "lemma Q_exists: \"\\<exists>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size", "have \"\\<And>S. Separation H_x v0 v1 S \\<Longrightarrow> card S \\<ge> sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S. Separation H_x v0 v1 S \\<Longrightarrow> sep_size \\<le> card S", "using subgraph_separation_min_size paths walk_in_V P_hit new_last_neq_v1 no_small_separations"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<noteq> v0; ?v \\<noteq> v1; ?v \\<in> V;\n   \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc ?n \\<le> card S;\n   Separation (remove_vertex ?v) v0 v1 ?S\\<rbrakk>\n  \\<Longrightarrow> ?n \\<le> card ?S\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n  walk ?xs \\<Longrightarrow> set ?xs \\<subseteq> V\n  hitting_paths new_last\n  new_last \\<noteq> v1\n  Separation G v0 v1 ?S \\<Longrightarrow> Suc sep_size \\<le> card ?S\n\ngoal (1 subgoal):\n 1. \\<And>S. Separation H_x v0 v1 S \\<Longrightarrow> sep_size \\<le> card S", "by (metis H_x_def new_last_in_V new_last_neq_v0)"], ["proof (state)\nthis:\n  Separation H_x v0 v1 ?S \\<Longrightarrow> sep_size \\<le> card ?S\n\ngoal (1 subgoal):\n 1. \\<exists>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size", "then"], ["proof (chain)\npicking this:\n  Separation H_x v0 v1 ?S \\<Longrightarrow> sep_size \\<le> card ?S", "show ?thesis"], ["proof (prove)\nusing this:\n  Separation H_x v0 v1 ?S \\<Longrightarrow> sep_size \\<le> card ?S\n\ngoal (1 subgoal):\n 1. \\<exists>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size", "using H_x_v0_v1_Digraph new_last_neq_v1"], ["proof (prove)\nusing this:\n  Separation H_x v0 v1 ?S \\<Longrightarrow> sep_size \\<le> card ?S\n  new_last \\<noteq> v1 \\<Longrightarrow> v0_v1_Digraph H_x v0 v1\n  new_last \\<noteq> v1\n\ngoal (1 subgoal):\n 1. \\<exists>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size", "by (meson no_small_separations_hyp)"], ["proof (state)\nthis:\n  \\<exists>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We want to choose these paths in a clever way, too.  Our goal is to choose these paths such that\n  the number of edges in @{term \"(\\<Union>(edges_of_walk ` Q) \\<inter> (E - \\<Union>(edges_of_walk ` paths_with_new)))\"}\n  is minimal.\n\\<close>"], ["", "definition B where \"B \\<equiv> E - \\<Union>(edges_of_walk ` paths_with_new)\""], ["", "definition Q_weight where \"Q_weight \\<equiv> \\<lambda>Q. card (\\<Union>(edges_of_walk ` Q) \\<inter> B)\""], ["", "definition Q_good where \"Q_good \\<equiv> \\<lambda>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size \\<and>\n  (\\<forall>Q'. DisjointPaths H_x v0 v1 Q' \\<and> card Q' = sep_size \\<longrightarrow> Q_weight Q \\<le> Q_weight Q')\""], ["", "definition Q where \"Q \\<equiv> SOME Q. Q_good Q\""], ["", "text \\<open>It is easy to show that such a @{const Q} exists.\\<close>"], ["", "lemma Q: \"DisjointPaths H_x v0 v1 Q\" \"card Q = sep_size\"\n  and Q_min: \"\\<And>Q'. DisjointPaths H_x v0 v1 Q' \\<and> card Q' = sep_size \\<Longrightarrow> Q_weight Q \\<le> Q_weight Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (DisjointPaths H_x v0 v1 Q &&& card Q = sep_size) &&&\n    (\\<And>Q'.\n        DisjointPaths H_x v0 v1 Q' \\<and>\n        card Q' = sep_size \\<Longrightarrow>\n        Q_weight Q \\<le> Q_weight Q')", "proof-"], ["proof (state)\ngoal (3 subgoals):\n 1. DisjointPaths H_x v0 v1 Q\n 2. card Q = sep_size\n 3. \\<And>Q'.\n       DisjointPaths H_x v0 v1 Q' \\<and>\n       card Q' = sep_size \\<Longrightarrow>\n       Q_weight Q \\<le> Q_weight Q'", "obtain Q' where \"DisjointPaths H_x v0 v1 Q'\" \"card Q' = sep_size\"\n    \"\\<And>Q''. DisjointPaths H_x v0 v1 Q'' \\<and> card Q'' = sep_size \\<Longrightarrow> Q_weight Q' \\<le> Q_weight Q''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        \\<lbrakk>DisjointPaths H_x v0 v1 Q'; card Q' = sep_size;\n         \\<And>Q''.\n            DisjointPaths H_x v0 v1 Q'' \\<and>\n            card Q'' = sep_size \\<Longrightarrow>\n            Q_weight Q' \\<le> Q_weight Q''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using arg_min_ex[of \"\\<lambda>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size\" Q_weight]\n      new_last_neq_v1 Q_exists"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>x. DisjointPaths H_x v0 v1 x \\<and> card x = sep_size;\n   \\<And>x.\n      \\<lbrakk>DisjointPaths H_x v0 v1 x \\<and> card x = sep_size;\n       \\<And>y.\n          DisjointPaths H_x v0 v1 y \\<and>\n          card y = sep_size \\<Longrightarrow>\n          Q_weight x \\<le> Q_weight y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  new_last \\<noteq> v1\n  \\<exists>Q. DisjointPaths H_x v0 v1 Q \\<and> card Q = sep_size\n\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        \\<lbrakk>DisjointPaths H_x v0 v1 Q'; card Q' = sep_size;\n         \\<And>Q''.\n            DisjointPaths H_x v0 v1 Q'' \\<and>\n            card Q'' = sep_size \\<Longrightarrow>\n            Q_weight Q' \\<le> Q_weight Q''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  DisjointPaths H_x v0 v1 Q'\n  card Q' = sep_size\n  DisjointPaths H_x v0 v1 ?Q'' \\<and> card ?Q'' = sep_size \\<Longrightarrow>\n  Q_weight Q' \\<le> Q_weight ?Q''\n\ngoal (3 subgoals):\n 1. DisjointPaths H_x v0 v1 Q\n 2. card Q = sep_size\n 3. \\<And>Q'.\n       DisjointPaths H_x v0 v1 Q' \\<and>\n       card Q' = sep_size \\<Longrightarrow>\n       Q_weight Q \\<le> Q_weight Q'", "then"], ["proof (chain)\npicking this:\n  DisjointPaths H_x v0 v1 Q'\n  card Q' = sep_size\n  DisjointPaths H_x v0 v1 ?Q'' \\<and> card ?Q'' = sep_size \\<Longrightarrow>\n  Q_weight Q' \\<le> Q_weight ?Q''", "have \"Q_good Q'\""], ["proof (prove)\nusing this:\n  DisjointPaths H_x v0 v1 Q'\n  card Q' = sep_size\n  DisjointPaths H_x v0 v1 ?Q'' \\<and> card ?Q'' = sep_size \\<Longrightarrow>\n  Q_weight Q' \\<le> Q_weight ?Q''\n\ngoal (1 subgoal):\n 1. Q_good Q'", "unfolding Q_good_def"], ["proof (prove)\nusing this:\n  DisjointPaths H_x v0 v1 Q'\n  card Q' = sep_size\n  DisjointPaths H_x v0 v1 ?Q'' \\<and> card ?Q'' = sep_size \\<Longrightarrow>\n  Q_weight Q' \\<le> Q_weight ?Q''\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q' \\<and>\n    card Q' = sep_size \\<and>\n    (\\<forall>Q'a.\n        DisjointPaths H_x v0 v1 Q'a \\<and>\n        card Q'a = sep_size \\<longrightarrow>\n        Q_weight Q' \\<le> Q_weight Q'a)", "by blast"], ["proof (state)\nthis:\n  Q_good Q'\n\ngoal (3 subgoals):\n 1. DisjointPaths H_x v0 v1 Q\n 2. card Q = sep_size\n 3. \\<And>Q'.\n       DisjointPaths H_x v0 v1 Q' \\<and>\n       card Q' = sep_size \\<Longrightarrow>\n       Q_weight Q \\<le> Q_weight Q'", "then"], ["proof (chain)\npicking this:\n  Q_good Q'", "show \"DisjointPaths H_x v0 v1 Q\" \"card Q = sep_size\"\n    \"\\<And>Q'. DisjointPaths H_x v0 v1 Q' \\<and> card Q' = sep_size \\<Longrightarrow> Q_weight Q \\<le> Q_weight Q'\""], ["proof (prove)\nusing this:\n  Q_good Q'\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q &&&\n    card Q = sep_size &&&\n    (\\<And>Q'.\n        DisjointPaths H_x v0 v1 Q' \\<and>\n        card Q' = sep_size \\<Longrightarrow>\n        Q_weight Q \\<le> Q_weight Q')", "using someI[of Q_good]"], ["proof (prove)\nusing this:\n  Q_good Q'\n  Q_good ?x \\<Longrightarrow> Q_good (Eps Q_good)\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q &&&\n    card Q = sep_size &&&\n    (\\<And>Q'.\n        DisjointPaths H_x v0 v1 Q' \\<and>\n        card Q' = sep_size \\<Longrightarrow>\n        Q_weight Q \\<le> Q_weight Q')", "by (simp_all add: Q_def Q_good_def)"], ["proof (state)\nthis:\n  DisjointPaths H_x v0 v1 Q\n  card Q = sep_size\n  DisjointPaths H_x v0 v1 ?Q' \\<and> card ?Q' = sep_size \\<Longrightarrow>\n  Q_weight Q \\<le> Q_weight ?Q'\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale Q: DisjointPaths H_x v0 v1 Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q", "using Q(1)"], ["proof (prove)\nusing this:\n  DisjointPaths H_x v0 v1 Q\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q", "."], ["", "subsection \\<open>Finding a Path Avoiding $Q$\\<close>"], ["", "text \\<open>\n  Because @{const Q} contains only @{term sep_size} many paths, we have\n  @{term \"card Q.second_vertices = sep_size\"}.  So there exists a path @{term P_k} among the\n  @{term \"Suc sep_size\"} many paths in @{term paths_with_new} such that the second vertex of\n  @{term P_k} is not among @{term Q.second_vertices}.\n\\<close>"], ["", "definition P_k where\n  \"P_k \\<equiv> SOME P_k. P_k \\<in> paths_with_new \\<and> hd (tl P_k) \\<notin> Q.second_vertices\""], ["", "lemma P_k: \"P_k \\<in> paths_with_new\" \"hd (tl P_k) \\<notin> Q.second_vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_k \\<in> paths_with_new &&& hd (tl P_k) \\<notin> Q.second_vertices", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. P_k \\<in> paths_with_new\n 2. hd (tl P_k) \\<notin> Q.second_vertices", "obtain y where \"y \\<in> insert (hd (tl P_new)) second_vertices\" \"y \\<notin> Q.second_vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> insert (hd (tl P_new)) second_vertices;\n         y \\<notin> Q.second_vertices\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> insert (hd (tl P_new)) second_vertices;\n         y \\<notin> Q.second_vertices\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"hd (tl P_new) \\<notin> second_vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl P_new) \\<notin> second_vertices", "using P_new_decomp tl_P_new(2)"], ["proof (prove)\nusing this:\n  P_new = new_pre @ [new_last]\n  hd (tl P_new) \\<notin> second_vertices\n\ngoal (1 subgoal):\n 1. hd (tl P_new) \\<notin> second_vertices", "by simp"], ["proof (state)\nthis:\n  hd (tl P_new) \\<notin> second_vertices\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> insert (hd (tl P_new)) second_vertices;\n         y \\<notin> Q.second_vertices\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  hd (tl P_new) \\<notin> second_vertices\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> insert (hd (tl P_new)) second_vertices;\n         y \\<notin> Q.second_vertices\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"card second_vertices = card Q.second_vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card second_vertices = card Q.second_vertices", "using Q(2) paths_sep_size"], ["proof (prove)\nusing this:\n  card Q = sep_size\n  card paths = sep_size\n\ngoal (1 subgoal):\n 1. card second_vertices = card Q.second_vertices", "using Q.second_vertices_card second_vertices_card"], ["proof (prove)\nusing this:\n  card Q = sep_size\n  card paths = sep_size\n  card Q.second_vertices = card Q\n  card second_vertices = card paths\n\ngoal (1 subgoal):\n 1. card second_vertices = card Q.second_vertices", "by (simp add: new_last_neq_v1)"], ["proof (state)\nthis:\n  card second_vertices = card Q.second_vertices\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> insert (hd (tl P_new)) second_vertices;\n         y \\<notin> Q.second_vertices\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  hd (tl P_new) \\<notin> second_vertices\n  card second_vertices = card Q.second_vertices", "have \"card (insert (hd (tl P_new)) second_vertices) = Suc (card Q.second_vertices)\""], ["proof (prove)\nusing this:\n  hd (tl P_new) \\<notin> second_vertices\n  card second_vertices = card Q.second_vertices\n\ngoal (1 subgoal):\n 1. card (insert (hd (tl P_new)) second_vertices) =\n    Suc (card Q.second_vertices)", "using finite_paths second_vertices_def"], ["proof (prove)\nusing this:\n  hd (tl P_new) \\<notin> second_vertices\n  card second_vertices = card Q.second_vertices\n  finite paths\n  second_vertices \\<equiv> Q.second_vertex ` paths\n\ngoal (1 subgoal):\n 1. card (insert (hd (tl P_new)) second_vertices) =\n    Suc (card Q.second_vertices)", "by auto"], ["proof (state)\nthis:\n  card (insert (hd (tl P_new)) second_vertices) =\n  Suc (card Q.second_vertices)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> insert (hd (tl P_new)) second_vertices;\n         y \\<notin> Q.second_vertices\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  card (insert (hd (tl P_new)) second_vertices) =\n  Suc (card Q.second_vertices)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (insert (hd (tl P_new)) second_vertices) =\n  Suc (card Q.second_vertices)\n\ngoal (1 subgoal):\n 1. thesis", "using that card_finite_less_ex"], ["proof (prove)\nusing this:\n  card (insert (hd (tl P_new)) second_vertices) =\n  Suc (card Q.second_vertices)\n  \\<lbrakk>?y \\<in> insert (hd (tl P_new)) second_vertices;\n   ?y \\<notin> Q.second_vertices\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>finite ?A; finite ?B; card ?A < card ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b\\<in>?B. b \\<notin> ?A\n\ngoal (1 subgoal):\n 1. thesis", "by (metis Q.finite_paths Q.second_vertices_def Zero_not_Suc card.infinite finite_imageI lessI)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> insert (hd (tl P_new)) second_vertices\n  y \\<notin> Q.second_vertices\n\ngoal (2 subgoals):\n 1. P_k \\<in> paths_with_new\n 2. hd (tl P_k) \\<notin> Q.second_vertices", "then"], ["proof (chain)\npicking this:\n  y \\<in> insert (hd (tl P_new)) second_vertices\n  y \\<notin> Q.second_vertices", "have \"\\<exists>P_k. P_k \\<in> paths_with_new \\<and> hd (tl P_k) \\<notin> Q.second_vertices\""], ["proof (prove)\nusing this:\n  y \\<in> insert (hd (tl P_new)) second_vertices\n  y \\<notin> Q.second_vertices\n\ngoal (1 subgoal):\n 1. \\<exists>P_k.\n       P_k \\<in> paths_with_new \\<and>\n       hd (tl P_k) \\<notin> Q.second_vertices", "by (metis (mono_tags, lifting) image_iff insertCI insertE paths_with_new_def second_vertex_def\n        second_vertices_def)"], ["proof (state)\nthis:\n  \\<exists>P_k.\n     P_k \\<in> paths_with_new \\<and> hd (tl P_k) \\<notin> Q.second_vertices\n\ngoal (2 subgoals):\n 1. P_k \\<in> paths_with_new\n 2. hd (tl P_k) \\<notin> Q.second_vertices", "then"], ["proof (chain)\npicking this:\n  \\<exists>P_k.\n     P_k \\<in> paths_with_new \\<and> hd (tl P_k) \\<notin> Q.second_vertices", "show \"P_k \\<in> paths_with_new\" \"hd (tl P_k) \\<notin> Q.second_vertices\""], ["proof (prove)\nusing this:\n  \\<exists>P_k.\n     P_k \\<in> paths_with_new \\<and> hd (tl P_k) \\<notin> Q.second_vertices\n\ngoal (1 subgoal):\n 1. P_k \\<in> paths_with_new &&& hd (tl P_k) \\<notin> Q.second_vertices", "using someI[of \"\\<lambda>P_k. P_k \\<in> paths_with_new \\<and> hd (tl P_k) \\<notin> Q.second_vertices\"] P_k_def"], ["proof (prove)\nusing this:\n  \\<exists>P_k.\n     P_k \\<in> paths_with_new \\<and> hd (tl P_k) \\<notin> Q.second_vertices\n  ?x \\<in> paths_with_new \\<and>\n  hd (tl ?x) \\<notin> Q.second_vertices \\<Longrightarrow>\n  (SOME P_k.\n      P_k \\<in> paths_with_new \\<and>\n      hd (tl P_k) \\<notin> Q.second_vertices)\n  \\<in> paths_with_new \\<and>\n  hd (tl (SOME P_k.\n             P_k \\<in> paths_with_new \\<and>\n             hd (tl P_k) \\<notin> Q.second_vertices))\n  \\<notin> Q.second_vertices\n  P_k \\<equiv>\n  SOME P_k.\n     P_k \\<in> paths_with_new \\<and> hd (tl P_k) \\<notin> Q.second_vertices\n\ngoal (1 subgoal):\n 1. P_k \\<in> paths_with_new &&& hd (tl P_k) \\<notin> Q.second_vertices", "by auto"], ["proof (state)\nthis:\n  P_k \\<in> paths_with_new\n  hd (tl P_k) \\<notin> Q.second_vertices\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_P_k [simp]: \"path P_k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path P_k", "by (simp add: P_k(1) paths_with_new_path)"], ["", "lemma hd_P_k_v0 [simp]: \"hd P_k = v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd P_k = v0", "by (simp add: P_k(1) paths_with_new_start_in_v0)"], ["", "definition hitting_Q_or_new_last where\n  \"hitting_Q_or_new_last \\<equiv> \\<lambda>y. y \\<noteq> v0 \\<and> (y = new_last \\<or> (\\<exists>Q_hit \\<in> Q. y \\<in> set Q_hit))\""], ["", "text \\<open>\n  @{term P_k} hits a vertex in @{term Q} or it hits @{term new_last} because it either ends in\n  @{term v1} or in @{term new_last}.\n\\<close>"], ["", "lemma P_k_hits_Q: \"\\<exists>y \\<in> set P_k. hitting_Q_or_new_last y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex (set P_k) hitting_Q_or_new_last", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> Bex (set P_k) hitting_Q_or_new_last\n 2. \\<not> ?P \\<Longrightarrow> Bex (set P_k) hitting_Q_or_new_last", "assume \"P_k \\<noteq> P_new\""], ["proof (state)\nthis:\n  P_k \\<noteq> P_new\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> Bex (set P_k) hitting_Q_or_new_last\n 2. \\<not> ?P \\<Longrightarrow> Bex (set P_k) hitting_Q_or_new_last", "then"], ["proof (chain)\npicking this:\n  P_k \\<noteq> P_new", "have \"v1 \\<in> set P_k\""], ["proof (prove)\nusing this:\n  P_k \\<noteq> P_new\n\ngoal (1 subgoal):\n 1. v1 \\<in> set P_k", "by (metis P_k(1) insertE last_in_set path_from_toE paths paths_with_new_def)"], ["proof (state)\nthis:\n  v1 \\<in> set P_k\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> Bex (set P_k) hitting_Q_or_new_last\n 2. \\<not> ?P \\<Longrightarrow> Bex (set P_k) hitting_Q_or_new_last", "moreover"], ["proof (state)\nthis:\n  v1 \\<in> set P_k\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> Bex (set P_k) hitting_Q_or_new_last\n 2. \\<not> ?P \\<Longrightarrow> Bex (set P_k) hitting_Q_or_new_last", "have \"\\<exists>Q_witness. Q_witness \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q_witness. Q_witness \\<in> Q", "using Q(2) sep_size_not0 finite.simps"], ["proof (prove)\nusing this:\n  card Q = sep_size\n  sep_size \\<noteq> 0\n  finite ?a =\n  (?a = {} \\<or> (\\<exists>A a. ?a = insert a A \\<and> finite A))\n\ngoal (1 subgoal):\n 1. \\<exists>Q_witness. Q_witness \\<in> Q", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>Q_witness. Q_witness \\<in> Q\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> Bex (set P_k) hitting_Q_or_new_last\n 2. \\<not> ?P \\<Longrightarrow> Bex (set P_k) hitting_Q_or_new_last", "ultimately"], ["proof (chain)\npicking this:\n  v1 \\<in> set P_k\n  \\<exists>Q_witness. Q_witness \\<in> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<in> set P_k\n  \\<exists>Q_witness. Q_witness \\<in> Q\n\ngoal (1 subgoal):\n 1. Bex (set P_k) hitting_Q_or_new_last", "using Q.paths path_from_toE hitting_Q_or_new_last_def v0_neq_v1"], ["proof (prove)\nusing this:\n  v1 \\<in> set P_k\n  \\<exists>Q_witness. Q_witness \\<in> Q\n  ?xs \\<in> Q \\<Longrightarrow>\n  v0 \\<leadsto>?xs\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  ?v \\<leadsto>?xs\\<leadsto> ?w \\<Longrightarrow>\n  path ?xs \\<and> ?xs \\<noteq> [] \\<and> hd ?xs = ?v \\<and> last ?xs = ?w\n  hitting_Q_or_new_last \\<equiv>\n  \\<lambda>y.\n     y \\<noteq> v0 \\<and>\n     (y = new_last \\<or> (\\<exists>Q_hit\\<in>Q. y \\<in> set Q_hit))\n  v0 \\<noteq> v1\n\ngoal (1 subgoal):\n 1. Bex (set P_k) hitting_Q_or_new_last", "by fastforce"], ["proof (state)\nthis:\n  Bex (set P_k) hitting_Q_or_new_last\n\ngoal (1 subgoal):\n 1. \\<not> P_k \\<noteq> P_new \\<Longrightarrow>\n    Bex (set P_k) hitting_Q_or_new_last", "qed (metis P_new new_last_neq_v0 hitting_Q_or_new_last_def last_in_set path_from_toE new_last_def)"], ["", "end \\<comment> \\<open>locale @{locale ProofStepInduct_NonTrivial}\\<close>"], ["", "subsection \\<open>Decomposing $P_k$\\<close>"], ["", "text \\<open>\n  Having established with the previous lemma that @{term P_k} hits @{term Q} or @{term new_last},\n  let @{term y} be the first such vertex on @{term P_k}.  Then we can split @{term P_k} at\n  this vertex.\n\\<close>"], ["", "locale ProofStepInduct_NonTrivial_P_k_pre = ProofStepInduct_NonTrivial +\n  fixes P_k_pre y P_k_post\n  assumes P_k_decomp: \"P_k = P_k_pre @ y # P_k_post\"\n      and y: \"hitting_Q_or_new_last y\"\n      and y_min: \"\\<And>y'. y' \\<in> set P_k_pre \\<Longrightarrow> \\<not>hitting_Q_or_new_last y'\""], ["", "text \\<open>\n  We can always go from @{locale ProofStepInduct_NonTrivial} to @{locale ProofStepInduct_NonTrivial_P_k_pre}.\n\\<close>"], ["", "lemma (in ProofStepInduct_NonTrivial) ProofStepInduct_NonTrivial_P_k_pre_exists:\n  shows \"\\<exists>P_k_pre y P_k_post.\n     ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y P_k_post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P_k_pre y P_k_post.\n       ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size\n        P_k_pre y P_k_post", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P_k_pre y P_k_post.\n       ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size\n        P_k_pre y P_k_post", "obtain y P_k_pre P_k_post where\n    \"P_k = P_k_pre @ y # P_k_post\" \"hitting_Q_or_new_last y\"\n    \"\\<And>y'. y' \\<in> set P_k_pre \\<Longrightarrow> \\<not>hitting_Q_or_new_last y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P_k_pre y P_k_post.\n        \\<lbrakk>P_k = P_k_pre @ y # P_k_post; hitting_Q_or_new_last y;\n         \\<And>y'.\n            y' \\<in> set P_k_pre \\<Longrightarrow>\n            \\<not> hitting_Q_or_new_last y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P_k_hits_Q split_list_first_prop[of P_k hitting_Q_or_new_last]"], ["proof (prove)\nusing this:\n  Bex (set P_k) hitting_Q_or_new_last\n  Bex (set P_k) hitting_Q_or_new_last \\<Longrightarrow>\n  \\<exists>ys x zs.\n     P_k = ys @ x # zs \\<and>\n     hitting_Q_or_new_last x \\<and>\n     (\\<forall>y\\<in>set ys. \\<not> hitting_Q_or_new_last y)\n\ngoal (1 subgoal):\n 1. (\\<And>P_k_pre y P_k_post.\n        \\<lbrakk>P_k = P_k_pre @ y # P_k_post; hitting_Q_or_new_last y;\n         \\<And>y'.\n            y' \\<in> set P_k_pre \\<Longrightarrow>\n            \\<not> hitting_Q_or_new_last y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P_k = P_k_pre @ y # P_k_post\n  hitting_Q_or_new_last y\n  ?y' \\<in> set P_k_pre \\<Longrightarrow> \\<not> hitting_Q_or_new_last ?y'\n\ngoal (1 subgoal):\n 1. \\<exists>P_k_pre y P_k_post.\n       ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size\n        P_k_pre y P_k_post", "then"], ["proof (chain)\npicking this:\n  P_k = P_k_pre @ y # P_k_post\n  hitting_Q_or_new_last y\n  ?y' \\<in> set P_k_pre \\<Longrightarrow> \\<not> hitting_Q_or_new_last ?y'", "have \"ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y P_k_post\""], ["proof (prove)\nusing this:\n  P_k = P_k_pre @ y # P_k_post\n  hitting_Q_or_new_last y\n  ?y' \\<in> set P_k_pre \\<Longrightarrow> \\<not> hitting_Q_or_new_last ?y'\n\ngoal (1 subgoal):\n 1. ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre\n     y P_k_post", "by unfold_locales"], ["proof (state)\nthis:\n  ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y\n   P_k_post\n\ngoal (1 subgoal):\n 1. \\<exists>P_k_pre y P_k_post.\n       ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size\n        P_k_pre y P_k_post", "then"], ["proof (chain)\npicking this:\n  ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y\n   P_k_post", "show ?thesis"], ["proof (prove)\nusing this:\n  ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y\n   P_k_post\n\ngoal (1 subgoal):\n 1. \\<exists>P_k_pre y P_k_post.\n       ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size\n        P_k_pre y P_k_post", "by blast"], ["proof (state)\nthis:\n  \\<exists>P_k_pre y P_k_post.\n     ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre\n      y P_k_post\n\ngoal:\nNo subgoals!", "qed"], ["", "context ProofStepInduct_NonTrivial_P_k_pre begin"], ["", "lemma y_neq_v0: \"y \\<noteq> v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> v0", "using hitting_Q_or_new_last_def y"], ["proof (prove)\nusing this:\n  hitting_Q_or_new_last \\<equiv>\n  \\<lambda>y.\n     y \\<noteq> v0 \\<and>\n     (y = new_last \\<or> (\\<exists>Q_hit\\<in>Q. y \\<in> set Q_hit))\n  hitting_Q_or_new_last y\n\ngoal (1 subgoal):\n 1. y \\<noteq> v0", "by auto"], ["", "lemma P_k_pre_not_Nil: \"P_k_pre \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_k_pre \\<noteq> []", "using P_k_decomp hd_P_k_v0 hitting_Q_or_new_last_def y"], ["proof (prove)\nusing this:\n  P_k = P_k_pre @ y # P_k_post\n  hd P_k = v0\n  hitting_Q_or_new_last \\<equiv>\n  \\<lambda>y.\n     y \\<noteq> v0 \\<and>\n     (y = new_last \\<or> (\\<exists>Q_hit\\<in>Q. y \\<in> set Q_hit))\n  hitting_Q_or_new_last y\n\ngoal (1 subgoal):\n 1. P_k_pre \\<noteq> []", "by auto"], ["", "lemma second_P_k_pre_not_in_Q: \"hd (tl (P_k_pre @ [y])) \\<notin> Q.second_vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl (P_k_pre @ [y])) \\<notin> Q.second_vertices", "using P_k(2) P_k_decomp P_k_pre_not_Nil"], ["proof (prove)\nusing this:\n  hd (tl P_k) \\<notin> Q.second_vertices\n  P_k = P_k_pre @ y # P_k_post\n  P_k_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (tl (P_k_pre @ [y])) \\<notin> Q.second_vertices", "by (metis append_eq_append_conv2 append_self_conv hd_append2 list.sel(1) tl_append2)"], ["", "definition H where \"H \\<equiv> remove_vertex v0\""], ["", "sublocale H: Digraph H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph H", "unfolding H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph (remove_vertex v0)", "using remove_vertex_Digraph"], ["proof (prove)\nusing this:\n  Digraph (remove_vertex ?v)\n\ngoal (1 subgoal):\n 1. Digraph (remove_vertex v0)", "."], ["", "lemma y_eq_v1_implies_P_k_neq_P_new: assumes \"y = v1\" shows \"P_k \\<noteq> P_new\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_k \\<noteq> P_new", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. P_k = P_new \\<Longrightarrow> False", "assume contra: \"P_k = P_new\""], ["proof (state)\nthis:\n  P_k = P_new\n\ngoal (1 subgoal):\n 1. P_k = P_new \\<Longrightarrow> False", "have \"v0 \\<leadsto>(new_pre @ [new_last])\\<leadsto> new_last\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(new_pre @ [new_last])\\<leadsto> new_last", "using P_new(1) P_new_decomp new_last_def"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>P_new\\<leadsto> last P_new\n  P_new = new_pre @ [new_last]\n  new_last \\<equiv> last P_new\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(new_pre @ [new_last])\\<leadsto> new_last", "by auto"], ["proof (state)\nthis:\n  v0 \\<leadsto>(new_pre @ [new_last])\\<leadsto> new_last\n\ngoal (1 subgoal):\n 1. P_k = P_new \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v0 \\<leadsto>(new_pre @ [new_last])\\<leadsto> new_last", "have \"v0 \\<leadsto>P_k\\<leadsto> new_last\""], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(new_pre @ [new_last])\\<leadsto> new_last\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>P_k\\<leadsto> new_last", "using P_new_decomp contra"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(new_pre @ [new_last])\\<leadsto> new_last\n  P_new = new_pre @ [new_last]\n  P_k = P_new\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>P_k\\<leadsto> new_last", "by auto"], ["proof (state)\nthis:\n  v0 \\<leadsto>P_k\\<leadsto> new_last\n\ngoal (1 subgoal):\n 1. P_k = P_new \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  v0 \\<leadsto>P_k\\<leadsto> new_last\n\ngoal (1 subgoal):\n 1. P_k = P_new \\<Longrightarrow> False", "have \"P_k = P_k_pre @ v1 # P_k_post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_k = P_k_pre @ v1 # P_k_post", "using P_k_decomp assms(1)"], ["proof (prove)\nusing this:\n  P_k = P_k_pre @ y # P_k_post\n  y = v1\n\ngoal (1 subgoal):\n 1. P_k = P_k_pre @ v1 # P_k_post", "by blast"], ["proof (state)\nthis:\n  P_k = P_k_pre @ v1 # P_k_post\n\ngoal (1 subgoal):\n 1. P_k = P_new \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  v0 \\<leadsto>P_k\\<leadsto> new_last\n  P_k = P_k_pre @ v1 # P_k_post", "have **: \"v0 \\<leadsto>(P_k_pre @ v1 # P_k_post)\\<leadsto> new_last\""], ["proof (prove)\nusing this:\n  v0 \\<leadsto>P_k\\<leadsto> new_last\n  P_k = P_k_pre @ v1 # P_k_post\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(P_k_pre @ v1 # P_k_post)\\<leadsto> new_last", "by simp"], ["proof (state)\nthis:\n  v0 \\<leadsto>(P_k_pre @ v1 # P_k_post)\\<leadsto> new_last\n\ngoal (1 subgoal):\n 1. P_k = P_new \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v0 \\<leadsto>(P_k_pre @ v1 # P_k_post)\\<leadsto> new_last", "have \"v1 \\<in> set P_new\""], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(P_k_pre @ v1 # P_k_post)\\<leadsto> new_last\n\ngoal (1 subgoal):\n 1. v1 \\<in> set P_new", "by (metis assms contra P_k_decomp in_set_conv_decomp)"], ["proof (state)\nthis:\n  v1 \\<in> set P_new\n\ngoal (1 subgoal):\n 1. P_k = P_new \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v1 \\<in> set P_new", "have \"new_last = v1\""], ["proof (prove)\nusing this:\n  v1 \\<in> set P_new\n\ngoal (1 subgoal):\n 1. new_last = v1", "using hitting_paths_v1 assms last_P_new(2) set_butlast new_last_def"], ["proof (prove)\nusing this:\n  v1 \\<in> set P_new\n  hitting_paths v1\n  y = v1\n  ?v \\<in> set (butlast P_new) \\<Longrightarrow> \\<not> hitting_paths ?v\n  \\<lbrakk>?x \\<in> set ?xs; ?x \\<noteq> last ?xs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> set (butlast ?xs)\n  new_last \\<equiv> last P_new\n\ngoal (1 subgoal):\n 1. new_last = v1", "by fastforce"], ["proof (state)\nthis:\n  new_last = v1\n\ngoal (1 subgoal):\n 1. P_k = P_new \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  new_last = v1", "show False"], ["proof (prove)\nusing this:\n  new_last = v1\n\ngoal (1 subgoal):\n 1. False", "using new_last_neq_v1"], ["proof (prove)\nusing this:\n  new_last = v1\n  new_last \\<noteq> v1\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If @{term \"y = v1\"}, then we are done.\\<close>"], ["", "lemma y_eq_v1_solves:\n    assumes \"y = v1\"\n    shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have \"P_k \\<noteq> P_new\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_k \\<noteq> P_new", "using y_eq_v1_implies_P_k_neq_P_new assms"], ["proof (prove)\nusing this:\n  y = v1 \\<Longrightarrow> P_k \\<noteq> P_new\n  y = v1\n\ngoal (1 subgoal):\n 1. P_k \\<noteq> P_new", "by blast"], ["proof (state)\nthis:\n  P_k \\<noteq> P_new\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  P_k \\<noteq> P_new", "have \"P_k = P_k_pre @ [y]\""], ["proof (prove)\nusing this:\n  P_k \\<noteq> P_new\n\ngoal (1 subgoal):\n 1. P_k = P_k_pre @ [y]", "using P_k(1) P_k_decomp paths assms paths_with_new_def"], ["proof (prove)\nusing this:\n  P_k \\<noteq> P_new\n  P_k \\<in> paths_with_new\n  P_k = P_k_pre @ y # P_k_post\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n  y = v1\n  paths_with_new \\<equiv> insert P_new paths\n\ngoal (1 subgoal):\n 1. P_k = P_k_pre @ [y]", "by fastforce"], ["proof (state)\nthis:\n  P_k = P_k_pre @ [y]\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  P_k = P_k_pre @ [y]", "have \"v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto> v1\""], ["proof (prove)\nusing this:\n  P_k = P_k_pre @ [y]\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto> v1", "using paths P_k(1) \\<open>P_k \\<noteq> P_new\\<close>"], ["proof (prove)\nusing this:\n  P_k = P_k_pre @ [y]\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n  P_k \\<in> paths_with_new\n  P_k \\<noteq> P_new\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto> v1", "by (simp add: paths_with_new_def)"], ["proof (state)\nthis:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "moreover"], ["proof (state)\nthis:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have \"new_last \\<notin> set P_k_pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<notin> set P_k_pre", "using hitting_Q_or_new_last_def y_min new_last_neq_v0"], ["proof (prove)\nusing this:\n  hitting_Q_or_new_last \\<equiv>\n  \\<lambda>y.\n     y \\<noteq> v0 \\<and>\n     (y = new_last \\<or> (\\<exists>Q_hit\\<in>Q. y \\<in> set Q_hit))\n  ?y' \\<in> set P_k_pre \\<Longrightarrow> \\<not> hitting_Q_or_new_last ?y'\n  new_last \\<noteq> v0\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set P_k_pre", "by auto"], ["proof (state)\nthis:\n  new_last \\<notin> set P_k_pre\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "ultimately"], ["proof (chain)\npicking this:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto> v1\n  new_last \\<notin> set P_k_pre", "have \"v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto>\\<^bsub>H_x\\<^esub> v1\""], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto> v1\n  new_last \\<notin> set P_k_pre\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "using remove_vertex_path_from_to"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto> v1\n  new_last \\<notin> set P_k_pre\n  \\<lbrakk>?v \\<leadsto>?xs\\<leadsto> ?w; ?x \\<in> V;\n   ?x \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> ?v \\<leadsto>?xs\\<leadsto>\\<^bsub>remove_vertex ?x\\<^esub> ?w\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "by (simp add: H_x_def assms new_last_in_V new_last_neq_v1)"], ["proof (state)\nthis:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "moreover"], ["proof (state)\nthis:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "{"], ["proof (state)\nthis:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "fix xs v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "assume \"xs \\<in> Q\" \"v \\<in> set xs\" \"v \\<in> set (P_k_pre @ [y])\" \"v \\<noteq> v0\" \"v \\<noteq> v1\""], ["proof (state)\nthis:\n  xs \\<in> Q\n  v \\<in> set xs\n  v \\<in> set (P_k_pre @ [y])\n  v \\<noteq> v0\n  v \\<noteq> v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  xs \\<in> Q\n  v \\<in> set xs\n  v \\<in> set (P_k_pre @ [y])\n  v \\<noteq> v0\n  v \\<noteq> v1", "have \"v \\<in> set P_k_pre\""], ["proof (prove)\nusing this:\n  xs \\<in> Q\n  v \\<in> set xs\n  v \\<in> set (P_k_pre @ [y])\n  v \\<noteq> v0\n  v \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v \\<in> set P_k_pre", "using assms"], ["proof (prove)\nusing this:\n  xs \\<in> Q\n  v \\<in> set xs\n  v \\<in> set (P_k_pre @ [y])\n  v \\<noteq> v0\n  v \\<noteq> v1\n  y = v1\n\ngoal (1 subgoal):\n 1. v \\<in> set P_k_pre", "by simp"], ["proof (state)\nthis:\n  v \\<in> set P_k_pre\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  v \\<in> set P_k_pre", "have \"\\<not>hitting_Q_or_new_last v\""], ["proof (prove)\nusing this:\n  v \\<in> set P_k_pre\n\ngoal (1 subgoal):\n 1. \\<not> hitting_Q_or_new_last v", "using y_min"], ["proof (prove)\nusing this:\n  v \\<in> set P_k_pre\n  ?y' \\<in> set P_k_pre \\<Longrightarrow> \\<not> hitting_Q_or_new_last ?y'\n\ngoal (1 subgoal):\n 1. \\<not> hitting_Q_or_new_last v", "by blast"], ["proof (state)\nthis:\n  \\<not> hitting_Q_or_new_last v\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  \\<not> hitting_Q_or_new_last v", "have \"False\""], ["proof (prove)\nusing this:\n  \\<not> hitting_Q_or_new_last v\n\ngoal (1 subgoal):\n 1. False", "using \\<open>v \\<in> set xs\\<close> \\<open>xs \\<in> Q\\<close> hitting_Q_or_new_last_def \\<open>v \\<noteq> v0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> hitting_Q_or_new_last v\n  v \\<in> set xs\n  xs \\<in> Q\n  hitting_Q_or_new_last \\<equiv>\n  \\<lambda>y.\n     y \\<noteq> v0 \\<and>\n     (y = new_last \\<or> (\\<exists>Q_hit\\<in>Q. y \\<in> set Q_hit))\n  v \\<noteq> v0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xs2 \\<in> Q; ?v2 \\<in> set ?xs2; ?v2 \\<in> set (P_k_pre @ [y]);\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "ultimately"], ["proof (chain)\npicking this:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  \\<lbrakk>?xs2 \\<in> Q; ?v2 \\<in> set ?xs2; ?v2 \\<in> set (P_k_pre @ [y]);\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False", "have \"DisjointPaths H_x v0 v1 (insert (P_k_pre @ [y]) Q)\""], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  \\<lbrakk>?xs2 \\<in> Q; ?v2 \\<in> set ?xs2; ?v2 \\<in> set (P_k_pre @ [y]);\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 (insert (P_k_pre @ [y]) Q)", "using Q.DisjointPaths_extend"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(P_k_pre @ [y])\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  \\<lbrakk>?xs2 \\<in> Q; ?v2 \\<in> set ?xs2; ?v2 \\<in> set (P_k_pre @ [y]);\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>v0 \\<leadsto>?P\\<leadsto>\\<^bsub>H_x\\<^esub> v1;\n   \\<And>xs v.\n      \\<lbrakk>xs \\<in> Q; xs \\<noteq> ?P; v \\<in> set xs;\n       v \\<in> set ?P\\<rbrakk>\n      \\<Longrightarrow> v = v0 \\<or> v = v1\\<rbrakk>\n  \\<Longrightarrow> DisjointPaths H_x v0 v1 (insert ?P Q)\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 (insert (P_k_pre @ [y]) Q)", "by blast"], ["proof (state)\nthis:\n  DisjointPaths H_x v0 v1 (insert (P_k_pre @ [y]) Q)\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  DisjointPaths H_x v0 v1 (insert (P_k_pre @ [y]) Q)", "have \"DisjointPaths G v0 v1 (insert (P_k_pre @ [y]) Q)\""], ["proof (prove)\nusing this:\n  DisjointPaths H_x v0 v1 (insert (P_k_pre @ [y]) Q)\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 (insert (P_k_pre @ [y]) Q)", "using DisjointPaths_supergraph H_x_def new_last_in_V new_last_neq_v0 new_last_neq_v1"], ["proof (prove)\nusing this:\n  DisjointPaths H_x v0 v1 (insert (P_k_pre @ [y]) Q)\n  DisjointPaths (remove_vertex ?v) v0 v1 ?paths \\<Longrightarrow>\n  DisjointPaths G v0 v1 ?paths\n  H_x \\<equiv> remove_vertex new_last\n  new_last \\<in> V\n  new_last \\<noteq> v0\n  new_last \\<noteq> v1\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 (insert (P_k_pre @ [y]) Q)", "by auto"], ["proof (state)\nthis:\n  DisjointPaths G v0 v1 (insert (P_k_pre @ [y]) Q)\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "moreover"], ["proof (state)\nthis:\n  DisjointPaths G v0 v1 (insert (P_k_pre @ [y]) Q)\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have \"card (insert (P_k_pre @ [y]) Q) = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert (P_k_pre @ [y]) Q) = Suc sep_size", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. card (insert (P_k_pre @ [y]) Q) = Suc sep_size", "have \"P_k_pre @ [y] \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_k_pre @ [y] \\<notin> Q", "by (metis P_k(2) Q.second_vertices_def \\<open>P_k = P_k_pre @ [y]\\<close> image_iff second_vertex_def)"], ["proof (state)\nthis:\n  P_k_pre @ [y] \\<notin> Q\n\ngoal (1 subgoal):\n 1. card (insert (P_k_pre @ [y]) Q) = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  P_k_pre @ [y] \\<notin> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  P_k_pre @ [y] \\<notin> Q\n\ngoal (1 subgoal):\n 1. card (insert (P_k_pre @ [y]) Q) = Suc sep_size", "by (simp add: Q(2) Q.finite_paths)"], ["proof (state)\nthis:\n  card (insert (P_k_pre @ [y]) Q) = Suc sep_size\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (insert (P_k_pre @ [y]) Q) = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "ultimately"], ["proof (chain)\npicking this:\n  DisjointPaths G v0 v1 (insert (P_k_pre @ [y]) Q)\n  card (insert (P_k_pre @ [y]) Q) = Suc sep_size", "show ?thesis"], ["proof (prove)\nusing this:\n  DisjointPaths G v0 v1 (insert (P_k_pre @ [y]) Q)\n  card (insert (P_k_pre @ [y]) Q) = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["proof (state)\nthis:\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>locale @{locale ProofStepInduct_NonTrivial_P_k_pre}\\<close>"], ["", "end"]]}