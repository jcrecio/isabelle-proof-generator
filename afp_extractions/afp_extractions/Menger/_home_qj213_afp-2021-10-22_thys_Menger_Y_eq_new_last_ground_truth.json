{"file_name": "/home/qj213/afp-2021-10-22/thys/Menger/Y_eq_new_last.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Menger", "problem_names": ["lemma R: \"new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\" \"\\<And>R'. new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow> length R \\<le> length R'\"", "lemma v1_in_Q: \"\\<exists>Q_hit \\<in> Q. v1 \\<in> set Q_hit\"", "lemma R_hits_Q: \"\\<exists>z \\<in> set R. Q.hitting_paths z\"", "lemma R_decomp_exists:\n  obtains R_pre z R_post\n    where \"R = R_pre @ z # R_post\"\n      and \"Q.hitting_paths z\"\n      and \"\\<And>z'. z' \\<in> set R_pre \\<Longrightarrow> \\<not>Q.hitting_paths z'\"", "lemma z_neq_v0: \"z \\<noteq> v0\"", "lemma z_neq_new_last: \"z \\<noteq> new_last\"", "lemma R_pre_neq_Nil: \"R_pre \\<noteq> Nil\"", "lemma z_closer_than_new_last: \"H.distance z v1 < H.distance new_last v1\"", "lemma R'_walk_not_Nil: \"R'_walk \\<noteq> Nil\"", "lemma R'_walk_no_Q: \"\\<lbrakk> v \\<in> set R'_walk; v \\<noteq> z \\<rbrakk> \\<Longrightarrow> \\<not>Q.hitting_paths v\"", "lemma R': \"hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\" \"set R' \\<subseteq> set (tl R'_walk)\"", "lemma hd_R': \"hd R' = hd (tl P_k)\"", "lemma R'_no_Q: \"\\<lbrakk> v \\<in> set R'; v \\<noteq> z \\<rbrakk> \\<Longrightarrow> \\<not>Q.hitting_paths v\"", "lemma v0_R'_path: \"v0 \\<leadsto>(v0 # R')\\<leadsto> z\"", "lemma z_eq_v1_solves:\n    assumes \"z = v1\"\n    shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\"", "lemma z_neq_v1_solves:\n    assumes \"z \\<noteq> v1\"\n    shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], "translations": [["", "lemma R: \"new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\" \"\\<And>R'. new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow> length R \\<le> length R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1 &&&\n    (\\<And>R'.\n        new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n        length R \\<le> length R')", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\n 2. \\<And>R'.\n       new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n       length R \\<le> length R'", "obtain R' where\n    R': \"new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1\" \"\\<And>R''. new_last \\<leadsto>R''\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow> length R' \\<le> length R''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<lbrakk>new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1;\n         \\<And>R''.\n            new_last \\<leadsto>R''\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n            length R' \\<le> length R''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using arg_min_ex[OF new_last_to_v1]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<lbrakk>new_last \\<leadsto>x\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1;\n       \\<And>y.\n          new_last \\<leadsto>y\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1 \\<Longrightarrow>\n          ?weight x \\<le> ?weight y\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<lbrakk>new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1;\n         \\<And>R''.\n            new_last \\<leadsto>R''\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n            length R' \\<le> length R''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding H_def"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<lbrakk>new_last \\<leadsto>x\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1;\n       \\<And>y.\n          new_last \\<leadsto>y\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1 \\<Longrightarrow>\n          ?weight x \\<le> ?weight y\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        \\<lbrakk>new_last \\<leadsto>R'\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1;\n         \\<And>R''.\n            new_last \\<leadsto>R''\\<leadsto>\\<^bsub>remove_vertex v0\\<^esub> v1 \\<Longrightarrow>\n            length R' \\<le> length R''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1\n  new_last \\<leadsto>?R''\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n  length R' \\<le> length ?R''\n\ngoal (2 subgoals):\n 1. new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\n 2. \\<And>R'.\n       new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n       length R \\<le> length R'", "then"], ["proof (chain)\npicking this:\n  new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1\n  new_last \\<leadsto>?R''\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n  length R' \\<le> length ?R''", "show \"new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\" \"\\<And>R'. new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow> length R \\<le> length R'\""], ["proof (prove)\nusing this:\n  new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1\n  new_last \\<leadsto>?R''\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n  length R' \\<le> length ?R''\n\ngoal (1 subgoal):\n 1. new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1 &&&\n    (\\<And>R'.\n        new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n        length R \\<le> length R')", "using someI[of \"\\<lambda>R. new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<and> (\\<forall>R'. new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<longrightarrow> length R \\<le> length R')\"]\n      R_def"], ["proof (prove)\nusing this:\n  new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1\n  new_last \\<leadsto>?R''\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n  length R' \\<le> length ?R''\n  new_last \\<leadsto>?x\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<and>\n  (\\<forall>R'.\n      new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<longrightarrow>\n      length ?x \\<le> length R') \\<Longrightarrow>\n  new_last \\<leadsto>(SOME R.\n                         new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<and>\n                         (\\<forall>R'.\n                             new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<longrightarrow>\n                             length R\n                             \\<le> length\n                                    R'))\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<and>\n  (\\<forall>R'.\n      new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<longrightarrow>\n      length\n       (SOME R.\n           new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<and>\n           (\\<forall>R'.\n               new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<longrightarrow>\n               length R \\<le> length R'))\n      \\<le> length R')\n  R \\<equiv>\n  SOME R.\n     new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<and>\n     (\\<forall>R'.\n         new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<longrightarrow>\n         length R \\<le> length R')\n\ngoal (1 subgoal):\n 1. new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1 &&&\n    (\\<And>R'.\n        new_last \\<leadsto>R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n        length R \\<le> length R')", "by auto"], ["proof (state)\nthis:\n  new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\n  new_last \\<leadsto>?R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n  length R \\<le> length ?R'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma v1_in_Q: \"\\<exists>Q_hit \\<in> Q. v1 \\<in> set Q_hit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q_hit\\<in>Q. v1 \\<in> set Q_hit", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Q_hit\\<in>Q. v1 \\<in> set Q_hit", "obtain xs where \"xs \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. xs \\<in> Q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using Q(2) sep_size_not0"], ["proof (prove)\nusing this:\n  card Q = sep_size\n  sep_size \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>xs. xs \\<in> Q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  xs \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<exists>Q_hit\\<in>Q. v1 \\<in> set Q_hit", "then"], ["proof (chain)\npicking this:\n  xs \\<in> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<exists>Q_hit\\<in>Q. v1 \\<in> set Q_hit", "using Q.paths last_in_set"], ["proof (prove)\nusing this:\n  xs \\<in> Q\n  ?xs \\<in> Q \\<Longrightarrow>\n  v0 \\<leadsto>?xs\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. \\<exists>Q_hit\\<in>Q. v1 \\<in> set Q_hit", "by blast"], ["proof (state)\nthis:\n  \\<exists>Q_hit\\<in>Q. v1 \\<in> set Q_hit\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_hits_Q: \"\\<exists>z \\<in> set R. Q.hitting_paths z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex (set R) Q.hitting_paths", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Bex (set R) Q.hitting_paths", "have \"v1 \\<in> set R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<in> set R", "using R(1) last_in_set"], ["proof (prove)\nusing this:\n  new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. v1 \\<in> set R", "by (metis path_from_to_def)"], ["proof (state)\nthis:\n  v1 \\<in> set R\n\ngoal (1 subgoal):\n 1. Bex (set R) Q.hitting_paths", "then"], ["proof (chain)\npicking this:\n  v1 \\<in> set R", "show ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<in> set R\n\ngoal (1 subgoal):\n 1. Bex (set R) Q.hitting_paths", "unfolding Q.hitting_paths_def"], ["proof (prove)\nusing this:\n  v1 \\<in> set R\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set R.\n       z \\<noteq> v0 \\<and>\n       ((\\<exists>xs\\<in>Q. z \\<in> set xs) \\<or> z = v1)", "using v0_neq_v1"], ["proof (prove)\nusing this:\n  v1 \\<in> set R\n  v0 \\<noteq> v1\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>set R.\n       z \\<noteq> v0 \\<and>\n       ((\\<exists>xs\\<in>Q. z \\<in> set xs) \\<or> z = v1)", "by auto"], ["proof (state)\nthis:\n  Bex (set R) Q.hitting_paths\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_decomp_exists:\n  obtains R_pre z R_post\n    where \"R = R_pre @ z # R_post\"\n      and \"Q.hitting_paths z\"\n      and \"\\<And>z'. z' \\<in> set R_pre \\<Longrightarrow> \\<not>Q.hitting_paths z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R_pre z R_post.\n        \\<lbrakk>R = R_pre @ z # R_post; Q.hitting_paths z;\n         \\<And>z'.\n            z' \\<in> set R_pre \\<Longrightarrow>\n            \\<not> Q.hitting_paths z'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using R_hits_Q split_list_first_prop[of R Q.hitting_paths]"], ["proof (prove)\nusing this:\n  Bex (set R) Q.hitting_paths\n  Bex (set R) Q.hitting_paths \\<Longrightarrow>\n  \\<exists>ys x zs.\n     R = ys @ x # zs \\<and>\n     Q.hitting_paths x \\<and>\n     (\\<forall>y\\<in>set ys. \\<not> Q.hitting_paths y)\n\ngoal (1 subgoal):\n 1. (\\<And>R_pre z R_post.\n        \\<lbrakk>R = R_pre @ z # R_post; Q.hitting_paths z;\n         \\<And>z'.\n            z' \\<in> set R_pre \\<Longrightarrow>\n            \\<not> Q.hitting_paths z'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "text \\<open>\n  We open an anonymous context in order to hide all but the final lemma.  This also gives us the\n  decomposition of @{term R} whose existence we established above.\n\\<close>"], ["", "context fixes R_pre z R_post\n  assumes R_decomp: \"R = R_pre @ z # R_post\"\n      and z: \"Q.hitting_paths z\"\n      and z_min: \"\\<And>z'. z' \\<in> set R_pre \\<Longrightarrow> \\<not>Q.hitting_paths z'\"\nbegin"], ["", "private"], ["", "lemma z_neq_v0: \"z \\<noteq> v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<noteq> v0", "using z Q.hitting_paths_def"], ["proof (prove)\nusing this:\n  Q.hitting_paths z\n  Q.hitting_paths \\<equiv>\n  \\<lambda>x.\n     x \\<noteq> v0 \\<and> ((\\<exists>xs\\<in>Q. x \\<in> set xs) \\<or> x = v1)\n\ngoal (1 subgoal):\n 1. z \\<noteq> v0", "by auto"], ["", "private"], ["", "lemma z_neq_new_last: \"z \\<noteq> new_last\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<noteq> new_last", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. z = new_last \\<Longrightarrow> False", "assume \"z = new_last\""], ["proof (state)\nthis:\n  z = new_last\n\ngoal (1 subgoal):\n 1. z = new_last \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  z = new_last", "obtain Q_hit where Q_hit: \"Q_hit \\<in> Q\" \"new_last \\<in> set Q_hit\""], ["proof (prove)\nusing this:\n  z = new_last\n\ngoal (1 subgoal):\n 1. (\\<And>Q_hit.\n        \\<lbrakk>Q_hit \\<in> Q; new_last \\<in> set Q_hit\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using z Q.hitting_paths_def y_eq_new_last y_neq_v1"], ["proof (prove)\nusing this:\n  z = new_last\n  Q.hitting_paths z\n  Q.hitting_paths \\<equiv>\n  \\<lambda>x.\n     x \\<noteq> v0 \\<and> ((\\<exists>xs\\<in>Q. x \\<in> set xs) \\<or> x = v1)\n  y = new_last\n  y \\<noteq> v1\n\ngoal (1 subgoal):\n 1. (\\<And>Q_hit.\n        \\<lbrakk>Q_hit \\<in> Q; new_last \\<in> set Q_hit\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Q_hit \\<in> Q\n  new_last \\<in> set Q_hit\n\ngoal (1 subgoal):\n 1. z = new_last \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Q_hit \\<in> Q\n  new_last \\<in> set Q_hit", "have \"Q.path Q_hit\""], ["proof (prove)\nusing this:\n  Q_hit \\<in> Q\n  new_last \\<in> set Q_hit\n\ngoal (1 subgoal):\n 1. Q.path Q_hit", "by (meson Q.paths path_from_to_def)"], ["proof (state)\nthis:\n  Q.path Q_hit\n\ngoal (1 subgoal):\n 1. z = new_last \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Q.path Q_hit", "have \"set Q_hit \\<subseteq> V - {new_last}\""], ["proof (prove)\nusing this:\n  Q.path Q_hit\n\ngoal (1 subgoal):\n 1. set Q_hit \\<subseteq> V - {new_last}", "using Q.walk_in_V H_x_def remove_vertex_V"], ["proof (prove)\nusing this:\n  Q.path Q_hit\n  Q.walk ?xs \\<Longrightarrow> set ?xs \\<subseteq> V\\<^bsub>H_x\\<^esub>\n  H_x \\<equiv> remove_vertex new_last\n  V\\<^bsub>remove_vertex ?x\\<^esub> = V - {?x}\n\ngoal (1 subgoal):\n 1. set Q_hit \\<subseteq> V - {new_last}", "by simp"], ["proof (state)\nthis:\n  set Q_hit \\<subseteq> V - {new_last}\n\ngoal (1 subgoal):\n 1. z = new_last \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  set Q_hit \\<subseteq> V - {new_last}", "show False"], ["proof (prove)\nusing this:\n  set Q_hit \\<subseteq> V - {new_last}\n\ngoal (1 subgoal):\n 1. False", "using Q_hit(2)"], ["proof (prove)\nusing this:\n  set Q_hit \\<subseteq> V - {new_last}\n  new_last \\<in> set Q_hit\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma R_pre_neq_Nil: \"R_pre \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R_pre \\<noteq> []", "using z_neq_new_last R_decomp R(1)"], ["proof (prove)\nusing this:\n  z \\<noteq> new_last\n  R = R_pre @ z # R_post\n  new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\n\ngoal (1 subgoal):\n 1. R_pre \\<noteq> []", "by auto"], ["", "private"], ["", "lemma z_closer_than_new_last: \"H.distance z v1 < H.distance new_last v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.distance z v1 < H.distance new_last v1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. H.distance z v1 < H.distance new_last v1", "have \"H.distance new_last v1 = length R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.distance new_last v1 = length R", "using H.distance_witness R"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<leadsto>?xs\\<leadsto>\\<^bsub>H\\<^esub> ?w;\n   \\<And>xs'.\n      ?v \\<leadsto>xs'\\<leadsto>\\<^bsub>H\\<^esub> ?w \\<Longrightarrow>\n      length ?xs \\<le> length xs'\\<rbrakk>\n  \\<Longrightarrow> H.distance ?v ?w = length ?xs\n  new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\n  new_last \\<leadsto>?R'\\<leadsto>\\<^bsub>H\\<^esub> v1 \\<Longrightarrow>\n  length R \\<le> length ?R'\n\ngoal (1 subgoal):\n 1. H.distance new_last v1 = length R", "by auto"], ["proof (state)\nthis:\n  H.distance new_last v1 = length R\n\ngoal (1 subgoal):\n 1. H.distance z v1 < H.distance new_last v1", "moreover"], ["proof (state)\nthis:\n  H.distance new_last v1 = length R\n\ngoal (1 subgoal):\n 1. H.distance z v1 < H.distance new_last v1", "have \"z \\<leadsto>(z # R_post)\\<leadsto>\\<^bsub>H\\<^esub> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<leadsto>(z # R_post)\\<leadsto>\\<^bsub>H\\<^esub> v1", "using R_decomp R(1)"], ["proof (prove)\nusing this:\n  R = R_pre @ z # R_post\n  new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\n\ngoal (1 subgoal):\n 1. z \\<leadsto>(z # R_post)\\<leadsto>\\<^bsub>H\\<^esub> v1", "by (metis H.walk_decomp(2) distinct_append last_appendR list.sel(1)\n          list.simps(3) path_from_to_def)"], ["proof (state)\nthis:\n  z \\<leadsto>(z # R_post)\\<leadsto>\\<^bsub>H\\<^esub> v1\n\ngoal (1 subgoal):\n 1. H.distance z v1 < H.distance new_last v1", "moreover"], ["proof (state)\nthis:\n  z \\<leadsto>(z # R_post)\\<leadsto>\\<^bsub>H\\<^esub> v1\n\ngoal (1 subgoal):\n 1. H.distance z v1 < H.distance new_last v1", "have \"length R > length (z # R_post)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (z # R_post) < length R", "unfolding R_decomp"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (z # R_post) < length (R_pre @ z # R_post)", "using R_pre_neq_Nil"], ["proof (prove)\nusing this:\n  R_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (z # R_post) < length (R_pre @ z # R_post)", "by simp"], ["proof (state)\nthis:\n  length (z # R_post) < length R\n\ngoal (1 subgoal):\n 1. H.distance z v1 < H.distance new_last v1", "ultimately"], ["proof (chain)\npicking this:\n  H.distance new_last v1 = length R\n  z \\<leadsto>(z # R_post)\\<leadsto>\\<^bsub>H\\<^esub> v1\n  length (z # R_post) < length R", "show ?thesis"], ["proof (prove)\nusing this:\n  H.distance new_last v1 = length R\n  z \\<leadsto>(z # R_post)\\<leadsto>\\<^bsub>H\\<^esub> v1\n  length (z # R_post) < length R\n\ngoal (1 subgoal):\n 1. H.distance z v1 < H.distance new_last v1", "using H.distance_upper_bound"], ["proof (prove)\nusing this:\n  H.distance new_last v1 = length R\n  z \\<leadsto>(z # R_post)\\<leadsto>\\<^bsub>H\\<^esub> v1\n  length (z # R_post) < length R\n  ?v \\<leadsto>?xs\\<leadsto>\\<^bsub>H\\<^esub> ?w \\<Longrightarrow>\n  H.distance ?v ?w \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. H.distance z v1 < H.distance new_last v1", "by fastforce"], ["proof (state)\nthis:\n  H.distance z v1 < H.distance new_last v1\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "definition R'_walk where \"R'_walk \\<equiv> P_k_pre @ R_pre @ [z]\""], ["", "private"], ["", "lemma R'_walk_not_Nil: \"R'_walk \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R'_walk \\<noteq> []", "using R'_walk_def R(1)"], ["proof (prove)\nusing this:\n  R'_walk \\<equiv> P_k_pre @ R_pre @ [z]\n  new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\n\ngoal (1 subgoal):\n 1. R'_walk \\<noteq> []", "by simp"], ["", "private"], ["", "lemma R'_walk_no_Q: \"\\<lbrakk> v \\<in> set R'_walk; v \\<noteq> z \\<rbrakk> \\<Longrightarrow> \\<not>Q.hitting_paths v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set R'_walk; v \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<not> Q.hitting_paths v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set R'_walk; v \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<not> Q.hitting_paths v", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set R'_walk; v \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<not> Q.hitting_paths v", "assume \"v \\<in> set R'_walk\" \"v \\<noteq> z\""], ["proof (state)\nthis:\n  v \\<in> set R'_walk\n  v \\<noteq> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set R'_walk; v \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<not> Q.hitting_paths v", "moreover"], ["proof (state)\nthis:\n  v \\<in> set R'_walk\n  v \\<noteq> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set R'_walk; v \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<not> Q.hitting_paths v", "have \"v \\<in> set P_k_pre \\<Longrightarrow> \\<not>Q.hitting_paths v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set P_k_pre \\<Longrightarrow> \\<not> Q.hitting_paths v", "using Q.hitting_paths_def hitting_Q_or_new_last_def y_min v1_in_Q"], ["proof (prove)\nusing this:\n  Q.hitting_paths \\<equiv>\n  \\<lambda>x.\n     x \\<noteq> v0 \\<and> ((\\<exists>xs\\<in>Q. x \\<in> set xs) \\<or> x = v1)\n  hitting_Q_or_new_last \\<equiv>\n  \\<lambda>y.\n     y \\<noteq> v0 \\<and>\n     (y = new_last \\<or> (\\<exists>Q_hit\\<in>Q. y \\<in> set Q_hit))\n  ?y' \\<in> set P_k_pre \\<Longrightarrow> \\<not> hitting_Q_or_new_last ?y'\n  \\<exists>Q_hit\\<in>Q. v1 \\<in> set Q_hit\n\ngoal (1 subgoal):\n 1. v \\<in> set P_k_pre \\<Longrightarrow> \\<not> Q.hitting_paths v", "by auto"], ["proof (state)\nthis:\n  v \\<in> set P_k_pre \\<Longrightarrow> \\<not> Q.hitting_paths v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set R'_walk; v \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<not> Q.hitting_paths v", "moreover"], ["proof (state)\nthis:\n  v \\<in> set P_k_pre \\<Longrightarrow> \\<not> Q.hitting_paths v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set R'_walk; v \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<not> Q.hitting_paths v", "have \"v \\<in> set R_pre \\<Longrightarrow> \\<not>Q.hitting_paths v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set R_pre \\<Longrightarrow> \\<not> Q.hitting_paths v", "using z_min"], ["proof (prove)\nusing this:\n  ?z' \\<in> set R_pre \\<Longrightarrow> \\<not> Q.hitting_paths ?z'\n\ngoal (1 subgoal):\n 1. v \\<in> set R_pre \\<Longrightarrow> \\<not> Q.hitting_paths v", "by simp"], ["proof (state)\nthis:\n  v \\<in> set R_pre \\<Longrightarrow> \\<not> Q.hitting_paths v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set R'_walk; v \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<not> Q.hitting_paths v", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> set R'_walk\n  v \\<noteq> z\n  v \\<in> set P_k_pre \\<Longrightarrow> \\<not> Q.hitting_paths v\n  v \\<in> set R_pre \\<Longrightarrow> \\<not> Q.hitting_paths v", "show \"\\<not>Q.hitting_paths v\""], ["proof (prove)\nusing this:\n  v \\<in> set R'_walk\n  v \\<noteq> z\n  v \\<in> set P_k_pre \\<Longrightarrow> \\<not> Q.hitting_paths v\n  v \\<in> set R_pre \\<Longrightarrow> \\<not> Q.hitting_paths v\n\ngoal (1 subgoal):\n 1. \\<not> Q.hitting_paths v", "unfolding R'_walk_def"], ["proof (prove)\nusing this:\n  v \\<in> set (P_k_pre @ R_pre @ [z])\n  v \\<noteq> z\n  v \\<in> set P_k_pre \\<Longrightarrow> \\<not> Q.hitting_paths v\n  v \\<in> set R_pre \\<Longrightarrow> \\<not> Q.hitting_paths v\n\ngoal (1 subgoal):\n 1. \\<not> Q.hitting_paths v", "using R'_walk_def"], ["proof (prove)\nusing this:\n  v \\<in> set (P_k_pre @ R_pre @ [z])\n  v \\<noteq> z\n  v \\<in> set P_k_pre \\<Longrightarrow> \\<not> Q.hitting_paths v\n  v \\<in> set R_pre \\<Longrightarrow> \\<not> Q.hitting_paths v\n  R'_walk \\<equiv> P_k_pre @ R_pre @ [z]\n\ngoal (1 subgoal):\n 1. \\<not> Q.hitting_paths v", "by auto"], ["proof (state)\nthis:\n  \\<not> Q.hitting_paths v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n    The original proof goes like this:\n    ``Let @{term z} be the first vertex of @{term R} on some path in @{term Q}.\n    Then the distance in @{term \"H\"} from @{term z} to @{term v1} is less than the distance\n    from @{term new_last} to @{term v1}.  This contradicts the choice of @{term paths} and\n    @{term P_new}.''\n\n    It does not say exactly why it contradicts the choice of @{term paths} and @{term P_new}.\n    It seems we can choose @{term Q} together with @{term R'_walk} as our new paths plus\n    extrapath. But this seems to be wrong because we cannot show that @{term R'_walk} is a path:\n    @{term P_k_pre} and @{term R_pre} could intersect.\n\n    So we use @{thm walk_to_path} to transform @{term R'_walk} into a path @{term R'}.\n\\<close>"], ["", "private"], ["", "definition R' where\n    \"R' \\<equiv> SOME R'. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z \\<and> set R' \\<subseteq> set (tl R'_walk)\""], ["", "private"], ["", "lemma R': \"hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\" \"set R' \\<subseteq> set (tl R'_walk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z &&&\n    set R' \\<subseteq> set (tl R'_walk)", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\n 2. set R' \\<subseteq> set (tl R'_walk)", "have \"tl R'_walk \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl R'_walk \\<noteq> []", "by (simp add: P_k_pre_not_Nil R'_walk_def)"], ["proof (state)\nthis:\n  tl R'_walk \\<noteq> []\n\ngoal (2 subgoals):\n 1. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\n 2. set R' \\<subseteq> set (tl R'_walk)", "moreover"], ["proof (state)\nthis:\n  tl R'_walk \\<noteq> []\n\ngoal (2 subgoals):\n 1. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\n 2. set R' \\<subseteq> set (tl R'_walk)", "have \"last R'_walk = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last R'_walk = z", "unfolding R'_walk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (P_k_pre @ R_pre @ [z]) = z", "by simp"], ["proof (state)\nthis:\n  last R'_walk = z\n\ngoal (2 subgoals):\n 1. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\n 2. set R' \\<subseteq> set (tl R'_walk)", "moreover"], ["proof (state)\nthis:\n  last R'_walk = z\n\ngoal (2 subgoals):\n 1. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\n 2. set R' \\<subseteq> set (tl R'_walk)", "have \"walk (tl R'_walk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk (tl R'_walk)", "by (metis (no_types, lifting) path_from_toE walk_tl H_def P_k_decomp R'_walk_def R(1)\n          R_decomp path_P_k y_eq_new_last hd_append list.sel(1) list.simps(3) path_decomp'\n          remove_vertex_path_from_to_add walk_comp walk_decomp(1) walk_last_edge)"], ["proof (state)\nthis:\n  walk (tl R'_walk)\n\ngoal (2 subgoals):\n 1. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\n 2. set R' \\<subseteq> set (tl R'_walk)", "ultimately"], ["proof (chain)\npicking this:\n  tl R'_walk \\<noteq> []\n  last R'_walk = z\n  walk (tl R'_walk)", "obtain R'' where \"hd (tl R'_walk) \\<leadsto>R''\\<leadsto> z\" \"set R'' \\<subseteq> set (tl R'_walk)\""], ["proof (prove)\nusing this:\n  tl R'_walk \\<noteq> []\n  last R'_walk = z\n  walk (tl R'_walk)\n\ngoal (1 subgoal):\n 1. (\\<And>R''.\n        \\<lbrakk>hd (tl R'_walk) \\<leadsto>R''\\<leadsto> z;\n         set R'' \\<subseteq> set (tl R'_walk)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using walk_to_path[of \"tl R'_walk\" \"hd (tl R'_walk)\" z] last_tl"], ["proof (prove)\nusing this:\n  tl R'_walk \\<noteq> []\n  last R'_walk = z\n  walk (tl R'_walk)\n  \\<lbrakk>walk (tl R'_walk); tl R'_walk \\<noteq> [];\n   hd (tl R'_walk) = hd (tl R'_walk); last (tl R'_walk) = z\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ys.\n                       hd (tl R'_walk) \\<leadsto>ys\\<leadsto> z \\<and>\n                       set ys \\<subseteq> set (tl R'_walk)\n  ?xs = [] \\<or> tl ?xs \\<noteq> [] \\<Longrightarrow>\n  last (tl ?xs) = last ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>R''.\n        \\<lbrakk>hd (tl R'_walk) \\<leadsto>R''\\<leadsto> z;\n         set R'' \\<subseteq> set (tl R'_walk)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  hd (tl R'_walk) \\<leadsto>R''\\<leadsto> z\n  set R'' \\<subseteq> set (tl R'_walk)\n\ngoal (2 subgoals):\n 1. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\n 2. set R' \\<subseteq> set (tl R'_walk)", "then"], ["proof (chain)\npicking this:\n  hd (tl R'_walk) \\<leadsto>R''\\<leadsto> z\n  set R'' \\<subseteq> set (tl R'_walk)", "show \"hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\" \"set R' \\<subseteq> set (tl R'_walk)\""], ["proof (prove)\nusing this:\n  hd (tl R'_walk) \\<leadsto>R''\\<leadsto> z\n  set R'' \\<subseteq> set (tl R'_walk)\n\ngoal (1 subgoal):\n 1. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z &&&\n    set R' \\<subseteq> set (tl R'_walk)", "unfolding R'_def"], ["proof (prove)\nusing this:\n  hd (tl R'_walk) \\<leadsto>R''\\<leadsto> z\n  set R'' \\<subseteq> set (tl R'_walk)\n\ngoal (1 subgoal):\n 1. hd (tl R'_walk) \\<leadsto>(SOME R'.\n                                  hd (tl\n R'_walk) \\<leadsto>R'\\<leadsto> z \\<and>\n                                  set R'\n                                  \\<subseteq> set\n         (tl R'_walk))\\<leadsto> z &&&\n    set (SOME R'.\n            hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z \\<and>\n            set R' \\<subseteq> set (tl R'_walk))\n    \\<subseteq> set (tl R'_walk)", "using someI[of \"\\<lambda>R'. hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z \\<and> set R' \\<subseteq> set (tl R'_walk)\"]"], ["proof (prove)\nusing this:\n  hd (tl R'_walk) \\<leadsto>R''\\<leadsto> z\n  set R'' \\<subseteq> set (tl R'_walk)\n  hd (tl R'_walk) \\<leadsto>?x\\<leadsto> z \\<and>\n  set ?x \\<subseteq> set (tl R'_walk) \\<Longrightarrow>\n  hd (tl R'_walk) \\<leadsto>(SOME R'.\n                                hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z \\<and>\n                                set R'\n                                \\<subseteq> set\n       (tl R'_walk))\\<leadsto> z \\<and>\n  set (SOME R'.\n          hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z \\<and>\n          set R' \\<subseteq> set (tl R'_walk))\n  \\<subseteq> set (tl R'_walk)\n\ngoal (1 subgoal):\n 1. hd (tl R'_walk) \\<leadsto>(SOME R'.\n                                  hd (tl\n R'_walk) \\<leadsto>R'\\<leadsto> z \\<and>\n                                  set R'\n                                  \\<subseteq> set\n         (tl R'_walk))\\<leadsto> z &&&\n    set (SOME R'.\n            hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z \\<and>\n            set R' \\<subseteq> set (tl R'_walk))\n    \\<subseteq> set (tl R'_walk)", "by auto"], ["proof (state)\nthis:\n  hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\n  set R' \\<subseteq> set (tl R'_walk)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma hd_R': \"hd R' = hd (tl P_k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd R' = hd (tl P_k)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. hd R' = hd (tl P_k)", "have \"hd (tl R'_walk) = hd (tl P_k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl R'_walk) = hd (tl P_k)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> hd (tl R'_walk) = hd (tl P_k)\n 2. \\<not> ?P \\<Longrightarrow> hd (tl R'_walk) = hd (tl P_k)", "assume \"tl P_k_pre = Nil\""], ["proof (state)\nthis:\n  tl P_k_pre = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> hd (tl R'_walk) = hd (tl P_k)\n 2. \\<not> ?P \\<Longrightarrow> hd (tl R'_walk) = hd (tl P_k)", "then"], ["proof (chain)\npicking this:\n  tl P_k_pre = []", "show ?thesis"], ["proof (prove)\nusing this:\n  tl P_k_pre = []\n\ngoal (1 subgoal):\n 1. hd (tl R'_walk) = hd (tl P_k)", "unfolding R'_walk_def"], ["proof (prove)\nusing this:\n  tl P_k_pre = []\n\ngoal (1 subgoal):\n 1. hd (tl (P_k_pre @ R_pre @ [z])) = hd (tl P_k)", "using P_k_decomp R(1) P_k_pre_not_Nil y_eq_new_last"], ["proof (prove)\nusing this:\n  tl P_k_pre = []\n  P_k = P_k_pre @ y # P_k_post\n  new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\n  P_k_pre \\<noteq> []\n  y = new_last\n\ngoal (1 subgoal):\n 1. hd (tl (P_k_pre @ R_pre @ [z])) = hd (tl P_k)", "by (metis H.path_from_toE R_decomp hd_append list.sel(1) tl_append2)"], ["proof (state)\nthis:\n  hd (tl R'_walk) = hd (tl P_k)\n\ngoal (1 subgoal):\n 1. tl P_k_pre \\<noteq> [] \\<Longrightarrow> hd (tl R'_walk) = hd (tl P_k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tl P_k_pre \\<noteq> [] \\<Longrightarrow> hd (tl R'_walk) = hd (tl P_k)", "assume \"tl P_k_pre \\<noteq> Nil\""], ["proof (state)\nthis:\n  tl P_k_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. tl P_k_pre \\<noteq> [] \\<Longrightarrow> hd (tl R'_walk) = hd (tl P_k)", "then"], ["proof (chain)\npicking this:\n  tl P_k_pre \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  tl P_k_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (tl R'_walk) = hd (tl P_k)", "unfolding R'_walk_def"], ["proof (prove)\nusing this:\n  tl P_k_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (tl (P_k_pre @ R_pre @ [z])) = hd (tl P_k)", "using P_k_pre_not_Nil"], ["proof (prove)\nusing this:\n  tl P_k_pre \\<noteq> []\n  P_k_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (tl (P_k_pre @ R_pre @ [z])) = hd (tl P_k)", "by (simp add: P_k_decomp)"], ["proof (state)\nthis:\n  hd (tl R'_walk) = hd (tl P_k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd (tl R'_walk) = hd (tl P_k)\n\ngoal (1 subgoal):\n 1. hd R' = hd (tl P_k)", "then"], ["proof (chain)\npicking this:\n  hd (tl R'_walk) = hd (tl P_k)", "show ?thesis"], ["proof (prove)\nusing this:\n  hd (tl R'_walk) = hd (tl P_k)\n\ngoal (1 subgoal):\n 1. hd R' = hd (tl P_k)", "using R'(1)"], ["proof (prove)\nusing this:\n  hd (tl R'_walk) = hd (tl P_k)\n  hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\n\ngoal (1 subgoal):\n 1. hd R' = hd (tl P_k)", "by auto"], ["proof (state)\nthis:\n  hd R' = hd (tl P_k)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma R'_no_Q: \"\\<lbrakk> v \\<in> set R'; v \\<noteq> z \\<rbrakk> \\<Longrightarrow> \\<not>Q.hitting_paths v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set R'; v \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<not> Q.hitting_paths v", "using R'_walk_no_Q"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> set R'_walk; ?v \\<noteq> z\\<rbrakk>\n  \\<Longrightarrow> \\<not> Q.hitting_paths ?v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set R'; v \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<not> Q.hitting_paths v", "by (meson R'(2) R'_walk_not_Nil list.set_sel(2) subsetCE)"], ["", "private"], ["", "lemma v0_R'_path: \"v0 \\<leadsto>(v0 # R')\\<leadsto> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> z", "have \"v0\\<rightarrow>hd R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<rightarrow> hd R'", "using hd_R' hd_P_k_v0"], ["proof (prove)\nusing this:\n  hd R' = hd (tl P_k)\n  hd P_k = v0\n\ngoal (1 subgoal):\n 1. v0 \\<rightarrow> hd R'", "by (metis Nil_is_append_conv P_k_decomp P_k_pre_not_Nil path_P_k list.distinct(1)\n          list.exhaust_sel path_first_edge' tl_append2)"], ["proof (state)\nthis:\n  v0 \\<rightarrow> hd R'\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> z", "moreover"], ["proof (state)\nthis:\n  v0 \\<rightarrow> hd R'\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> z", "have \"v0 \\<notin> set R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<notin> set R'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v0 \\<notin> set R'", "have \"v0 \\<notin> set R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<notin> set R", "using R(1) H_def H.path_in_V remove_vertex_V"], ["proof (prove)\nusing this:\n  new_last \\<leadsto>R\\<leadsto>\\<^bsub>H\\<^esub> v1\n  H \\<equiv> remove_vertex v0\n  H.path ?xs \\<Longrightarrow> set ?xs \\<subseteq> V\\<^bsub>H\\<^esub>\n  V\\<^bsub>remove_vertex ?x\\<^esub> = V - {?x}\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R", "by (simp add: path_from_to_def subset_Diff_insert)"], ["proof (state)\nthis:\n  v0 \\<notin> set R\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R'", "then"], ["proof (chain)\npicking this:\n  v0 \\<notin> set R", "have \"v0 \\<notin> set R_pre\""], ["proof (prove)\nusing this:\n  v0 \\<notin> set R\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R_pre", "using R_decomp"], ["proof (prove)\nusing this:\n  v0 \\<notin> set R\n  R = R_pre @ z # R_post\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R_pre", "by simp"], ["proof (state)\nthis:\n  v0 \\<notin> set R_pre\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R'", "moreover"], ["proof (state)\nthis:\n  v0 \\<notin> set R_pre\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R'", "have \"v0 \\<notin> set (tl P_k_pre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<notin> set (tl P_k_pre)", "using hd_P_k_v0 path_P_k path_first_vertex"], ["proof (prove)\nusing this:\n  hd P_k = v0\n  path P_k\n  path (?x # ?xs) \\<Longrightarrow> ?x \\<notin> set ?xs\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set (tl P_k_pre)", "by (metis P_k_decomp P_k_pre_not_Nil hd_append list.exhaust_sel path_decomp(1))"], ["proof (state)\nthis:\n  v0 \\<notin> set (tl P_k_pre)\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R'", "ultimately"], ["proof (chain)\npicking this:\n  v0 \\<notin> set R_pre\n  v0 \\<notin> set (tl P_k_pre)", "show ?thesis"], ["proof (prove)\nusing this:\n  v0 \\<notin> set R_pre\n  v0 \\<notin> set (tl P_k_pre)\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R'", "using R'(2)"], ["proof (prove)\nusing this:\n  v0 \\<notin> set R_pre\n  v0 \\<notin> set (tl P_k_pre)\n  set R' \\<subseteq> set (tl R'_walk)\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R'", "unfolding R'_walk_def"], ["proof (prove)\nusing this:\n  v0 \\<notin> set R_pre\n  v0 \\<notin> set (tl P_k_pre)\n  set R' \\<subseteq> set (tl (P_k_pre @ R_pre @ [z]))\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R'", "using P_k_pre_not_Nil z_neq_v0"], ["proof (prove)\nusing this:\n  v0 \\<notin> set R_pre\n  v0 \\<notin> set (tl P_k_pre)\n  set R' \\<subseteq> set (tl (P_k_pre @ R_pre @ [z]))\n  P_k_pre \\<noteq> []\n  z \\<noteq> v0\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set R'", "by auto"], ["proof (state)\nthis:\n  v0 \\<notin> set R'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v0 \\<notin> set R'\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> z", "ultimately"], ["proof (chain)\npicking this:\n  v0 \\<rightarrow> hd R'\n  v0 \\<notin> set R'", "show ?thesis"], ["proof (prove)\nusing this:\n  v0 \\<rightarrow> hd R'\n  v0 \\<notin> set R'\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> z", "using path_cons"], ["proof (prove)\nusing this:\n  v0 \\<rightarrow> hd R'\n  v0 \\<notin> set R'\n  \\<lbrakk>path ?xs; ?xs \\<noteq> []; ?v \\<rightarrow> hd ?xs;\n   ?v \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> path (?v # ?xs)\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> z", "by (metis R'(1) last.simps list.sel(1) list.simps(3) path_from_to_def)"], ["proof (state)\nthis:\n  v0 \\<leadsto>(v0 # R')\\<leadsto> z\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "corollary z_last_R': \"z = last (v0 # R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z = last (v0 # R')", "using v0_R'_path"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(v0 # R')\\<leadsto> z\n\ngoal (1 subgoal):\n 1. z = last (v0 # R')", "by auto"], ["", "private"], ["", "lemma z_eq_v1_solves:\n    assumes \"z = v1\"\n    shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "interpret Q': DisjointPaths G v0 v1 Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 Q", "using DisjointPaths_supergraph H_x_def Q.DisjointPaths_axioms"], ["proof (prove)\nusing this:\n  DisjointPaths (remove_vertex ?v) v0 v1 ?paths \\<Longrightarrow>\n  DisjointPaths G v0 v1 ?paths\n  H_x \\<equiv> remove_vertex new_last\n  DisjointPaths H_x v0 v1 Q\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 Q", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have \"v0 \\<leadsto>(v0 # R')\\<leadsto> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> v1", "using assms v0_R'_path"], ["proof (prove)\nusing this:\n  z = v1\n  v0 \\<leadsto>(v0 # R')\\<leadsto> z\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> v1", "by auto"], ["proof (state)\nthis:\n  v0 \\<leadsto>(v0 # R')\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "moreover"], ["proof (state)\nthis:\n  v0 \\<leadsto>(v0 # R')\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "{"], ["proof (state)\nthis:\n  v0 \\<leadsto>(v0 # R')\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "fix xs v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "assume \"xs \\<in> Q\" \"xs \\<noteq> v0 # R'\" \"v \\<in> set xs\" \"v \\<in> set (v0 # R')\""], ["proof (state)\nthis:\n  xs \\<in> Q\n  xs \\<noteq> v0 # R'\n  v \\<in> set xs\n  v \\<in> set (v0 # R')\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  xs \\<in> Q\n  xs \\<noteq> v0 # R'\n  v \\<in> set xs\n  v \\<in> set (v0 # R')", "have \"v = v0 \\<or> v = v1\""], ["proof (prove)\nusing this:\n  xs \\<in> Q\n  xs \\<noteq> v0 # R'\n  v \\<in> set xs\n  v \\<in> set (v0 # R')\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1", "using R'_no_Q Q.hitting_paths_def \\<open>z = v1\\<close>"], ["proof (prove)\nusing this:\n  xs \\<in> Q\n  xs \\<noteq> v0 # R'\n  v \\<in> set xs\n  v \\<in> set (v0 # R')\n  \\<lbrakk>?v \\<in> set R'; ?v \\<noteq> z\\<rbrakk>\n  \\<Longrightarrow> \\<not> Q'.hitting_paths ?v\n  Q'.hitting_paths \\<equiv>\n  \\<lambda>x.\n     x \\<noteq> v0 \\<and> ((\\<exists>xs\\<in>Q. x \\<in> set xs) \\<or> x = v1)\n  z = v1\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1", "by auto"], ["proof (state)\nthis:\n  v = v0 \\<or> v = v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xs2 \\<in> Q; ?xs2 \\<noteq> v0 # R'; ?v2 \\<in> set ?xs2;\n   ?v2 \\<in> set (v0 # R')\\<rbrakk>\n  \\<Longrightarrow> ?v2 = v0 \\<or> ?v2 = v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "ultimately"], ["proof (chain)\npicking this:\n  v0 \\<leadsto>(v0 # R')\\<leadsto> v1\n  \\<lbrakk>?xs2 \\<in> Q; ?xs2 \\<noteq> v0 # R'; ?v2 \\<in> set ?xs2;\n   ?v2 \\<in> set (v0 # R')\\<rbrakk>\n  \\<Longrightarrow> ?v2 = v0 \\<or> ?v2 = v1", "have \"DisjointPaths G v0 v1 (insert (v0 # R') Q)\""], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(v0 # R')\\<leadsto> v1\n  \\<lbrakk>?xs2 \\<in> Q; ?xs2 \\<noteq> v0 # R'; ?v2 \\<in> set ?xs2;\n   ?v2 \\<in> set (v0 # R')\\<rbrakk>\n  \\<Longrightarrow> ?v2 = v0 \\<or> ?v2 = v1\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 (insert (v0 # R') Q)", "using Q'.DisjointPaths_extend"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(v0 # R')\\<leadsto> v1\n  \\<lbrakk>?xs2 \\<in> Q; ?xs2 \\<noteq> v0 # R'; ?v2 \\<in> set ?xs2;\n   ?v2 \\<in> set (v0 # R')\\<rbrakk>\n  \\<Longrightarrow> ?v2 = v0 \\<or> ?v2 = v1\n  \\<lbrakk>v0 \\<leadsto>?P\\<leadsto> v1;\n   \\<And>xs v.\n      \\<lbrakk>xs \\<in> Q; xs \\<noteq> ?P; v \\<in> set xs;\n       v \\<in> set ?P\\<rbrakk>\n      \\<Longrightarrow> v = v0 \\<or> v = v1\\<rbrakk>\n  \\<Longrightarrow> DisjointPaths G v0 v1 (insert ?P Q)\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 (insert (v0 # R') Q)", "by blast"], ["proof (state)\nthis:\n  DisjointPaths G v0 v1 (insert (v0 # R') Q)\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "moreover"], ["proof (state)\nthis:\n  DisjointPaths G v0 v1 (insert (v0 # R') Q)\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have \"card (insert (v0 # R') Q) = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert (v0 # R') Q) = Suc sep_size", "by (simp add: P_k(2) Q(2) Q.finite_paths Q.second_vertices_new_path hd_R')"], ["proof (state)\nthis:\n  card (insert (v0 # R') Q) = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "ultimately"], ["proof (chain)\npicking this:\n  DisjointPaths G v0 v1 (insert (v0 # R') Q)\n  card (insert (v0 # R') Q) = Suc sep_size", "show ?thesis"], ["proof (prove)\nusing this:\n  DisjointPaths G v0 v1 (insert (v0 # R') Q)\n  card (insert (v0 # R') Q) = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["proof (state)\nthis:\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma z_neq_v1_solves:\n    assumes \"z \\<noteq> v1\"\n    shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have \"ProofStepInduct G v0 v1 Q (v0 # R') sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProofStepInduct G v0 v1 Q (v0 # R') sep_size", "proof (rule ProofStepInduct.intro)"], ["proof (state)\ngoal (3 subgoals):\n 1. NoSmallSeparationsInduct G v0 v1 sep_size\n 2. DisjointPathsPlusOne G v0 v1 Q (v0 # R')\n 3. ProofStepInduct_axioms Q sep_size", "show \"DisjointPathsPlusOne G v0 v1 Q (v0 # R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPathsPlusOne G v0 v1 Q (v0 # R')", "proof (rule DisjointPathsPlusOne.intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. DisjointPaths G v0 v1 Q\n 2. DisjointPathsPlusOne_axioms G v0 v1 Q (v0 # R')", "show \"DisjointPaths G v0 v1 Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 Q", "using DisjointPaths_supergraph H_x_def Q.DisjointPaths_axioms"], ["proof (prove)\nusing this:\n  DisjointPaths (remove_vertex ?v) v0 v1 ?paths \\<Longrightarrow>\n  DisjointPaths G v0 v1 ?paths\n  H_x \\<equiv> remove_vertex new_last\n  DisjointPaths H_x v0 v1 Q\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 Q", "by auto"], ["proof (state)\nthis:\n  DisjointPaths G v0 v1 Q\n\ngoal (1 subgoal):\n 1. DisjointPathsPlusOne_axioms G v0 v1 Q (v0 # R')", "show \"DisjointPathsPlusOne_axioms G v0 v1 Q (v0 # R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPathsPlusOne_axioms G v0 v1 Q (v0 # R')", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> last (v0 # R')\n 2. tl (v0 # R') \\<noteq> []\n 3. hd (tl (v0 # R')) \\<notin> Q.second_vertices\n 4. Q.hitting_paths (last (v0 # R'))\n 5. \\<And>v.\n       v \\<in> set (butlast (v0 # R')) \\<Longrightarrow>\n       \\<not> Q.hitting_paths v", "show \"v0 \\<leadsto>(v0 # R')\\<leadsto> last (v0 # R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> last (v0 # R')", "using v0_R'_path"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(v0 # R')\\<leadsto> z\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(v0 # R')\\<leadsto> last (v0 # R')", "by blast"], ["proof (state)\nthis:\n  v0 \\<leadsto>(v0 # R')\\<leadsto> last (v0 # R')\n\ngoal (4 subgoals):\n 1. tl (v0 # R') \\<noteq> []\n 2. hd (tl (v0 # R')) \\<notin> Q.second_vertices\n 3. Q.hitting_paths (last (v0 # R'))\n 4. \\<And>v.\n       v \\<in> set (butlast (v0 # R')) \\<Longrightarrow>\n       \\<not> Q.hitting_paths v", "show \"tl (v0 # R') \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (v0 # R') \\<noteq> []", "using R'(1)"], ["proof (prove)\nusing this:\n  hd (tl R'_walk) \\<leadsto>R'\\<leadsto> z\n\ngoal (1 subgoal):\n 1. tl (v0 # R') \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  tl (v0 # R') \\<noteq> []\n\ngoal (3 subgoals):\n 1. hd (tl (v0 # R')) \\<notin> Q.second_vertices\n 2. Q.hitting_paths (last (v0 # R'))\n 3. \\<And>v.\n       v \\<in> set (butlast (v0 # R')) \\<Longrightarrow>\n       \\<not> Q.hitting_paths v", "show \"hd (tl (v0 # R')) \\<notin> Q.second_vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl (v0 # R')) \\<notin> Q.second_vertices", "using hd_R' P_k(2)"], ["proof (prove)\nusing this:\n  hd R' = hd (tl P_k)\n  hd (tl P_k) \\<notin> Q.second_vertices\n\ngoal (1 subgoal):\n 1. hd (tl (v0 # R')) \\<notin> Q.second_vertices", "by auto"], ["proof (state)\nthis:\n  hd (tl (v0 # R')) \\<notin> Q.second_vertices\n\ngoal (2 subgoals):\n 1. Q.hitting_paths (last (v0 # R'))\n 2. \\<And>v.\n       v \\<in> set (butlast (v0 # R')) \\<Longrightarrow>\n       \\<not> Q.hitting_paths v", "show \"Q.hitting_paths (last (v0 # R'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q.hitting_paths (last (v0 # R'))", "using z z_last_R'"], ["proof (prove)\nusing this:\n  Q.hitting_paths z\n  z = last (v0 # R')\n\ngoal (1 subgoal):\n 1. Q.hitting_paths (last (v0 # R'))", "by auto"], ["proof (state)\nthis:\n  Q.hitting_paths (last (v0 # R'))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (butlast (v0 # R')) \\<Longrightarrow>\n       \\<not> Q.hitting_paths v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (butlast (v0 # R')) \\<Longrightarrow>\n       \\<not> Q.hitting_paths v", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (butlast (v0 # R')) \\<Longrightarrow>\n       \\<not> Q.hitting_paths v", "assume \"v \\<in> set (butlast (v0 # R'))\""], ["proof (state)\nthis:\n  v \\<in> set (butlast (v0 # R'))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (butlast (v0 # R')) \\<Longrightarrow>\n       \\<not> Q.hitting_paths v", "then"], ["proof (chain)\npicking this:\n  v \\<in> set (butlast (v0 # R'))", "show \"\\<not>Q.hitting_paths v\""], ["proof (prove)\nusing this:\n  v \\<in> set (butlast (v0 # R'))\n\ngoal (1 subgoal):\n 1. \\<not> Q.hitting_paths v", "using R'_no_Q path_from_to_last[OF v0_R'_path]"], ["proof (prove)\nusing this:\n  v \\<in> set (butlast (v0 # R'))\n  \\<lbrakk>?v \\<in> set R'; ?v \\<noteq> z\\<rbrakk>\n  \\<Longrightarrow> \\<not> Q.hitting_paths ?v\n  z \\<notin> set (butlast (v0 # R'))\n\ngoal (1 subgoal):\n 1. \\<not> Q.hitting_paths v", "by (metis Q.hitting_paths_def in_set_butlastD set_ConsD)"], ["proof (state)\nthis:\n  \\<not> Q.hitting_paths v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DisjointPathsPlusOne_axioms G v0 v1 Q (v0 # R')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DisjointPathsPlusOne G v0 v1 Q (v0 # R')\n\ngoal (2 subgoals):\n 1. NoSmallSeparationsInduct G v0 v1 sep_size\n 2. ProofStepInduct_axioms Q sep_size", "show \"ProofStepInduct_axioms Q sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProofStepInduct_axioms Q sep_size", "using sep_size_not0 Q(2)"], ["proof (prove)\nusing this:\n  sep_size \\<noteq> 0\n  card Q = sep_size\n\ngoal (1 subgoal):\n 1. ProofStepInduct_axioms Q sep_size", "by unfold_locales"], ["proof (state)\nthis:\n  ProofStepInduct_axioms Q sep_size\n\ngoal (1 subgoal):\n 1. NoSmallSeparationsInduct G v0 v1 sep_size", "qed (insert NoSmallSeparationsInduct_axioms)"], ["proof (state)\nthis:\n  ProofStepInduct G v0 v1 Q (v0 # R') sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  ProofStepInduct G v0 v1 Q (v0 # R') sep_size", "have \"H.distance (last P_new) v1 \\<le> H.distance (last (v0 # R')) v1\""], ["proof (prove)\nusing this:\n  ProofStepInduct G v0 v1 Q (v0 # R') sep_size\n\ngoal (1 subgoal):\n 1. H.distance (last P_new) v1 \\<le> H.distance (last (v0 # R')) v1", "using H_def optimal_paths[of Q \"v0 # R'\"]"], ["proof (prove)\nusing this:\n  ProofStepInduct G v0 v1 Q (v0 # R') sep_size\n  H \\<equiv> remove_vertex v0\n  ProofStepInduct G v0 v1 Q (v0 # R') sep_size \\<Longrightarrow>\n  H.distance (last P_new) v1 \\<le> H.distance (last (v0 # R')) v1\n\ngoal (1 subgoal):\n 1. H.distance (last P_new) v1 \\<le> H.distance (last (v0 # R')) v1", "by blast"], ["proof (state)\nthis:\n  H.distance (last P_new) v1 \\<le> H.distance (last (v0 # R')) v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  H.distance (last P_new) v1 \\<le> H.distance (last (v0 # R')) v1", "have False"], ["proof (prove)\nusing this:\n  H.distance (last P_new) v1 \\<le> H.distance (last (v0 # R')) v1\n\ngoal (1 subgoal):\n 1. False", "using z_last_R' new_last_def z_closer_than_new_last"], ["proof (prove)\nusing this:\n  H.distance (last P_new) v1 \\<le> H.distance (last (v0 # R')) v1\n  z = last (v0 # R')\n  new_last \\<equiv> last P_new\n  H.distance z v1 < H.distance new_last v1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["proof (state)\nthis:\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary with_optimal_paths_solves':\n    shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "using optimal_paths z_eq_v1_solves z_neq_v1_solves"], ["proof (prove)\nusing this:\n  ProofStepInduct G v0 v1 ?paths' ?P_new' sep_size \\<Longrightarrow>\n  H.distance (last P_new) v1 \\<le> H.distance (last ?P_new') v1\n  z = v1 \\<Longrightarrow>\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n  z \\<noteq> v1 \\<Longrightarrow>\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["", "end \\<comment> \\<open>anonymous context\\<close>"], ["", "corollary with_optimal_paths_solves:\n  \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "using optimal_paths with_optimal_paths_solves' R_decomp_exists"], ["proof (prove)\nusing this:\n  ProofStepInduct G v0 v1 ?paths' ?P_new' sep_size \\<Longrightarrow>\n  H.distance (last P_new) v1 \\<le> H.distance (last ?P_new') v1\n  \\<lbrakk>R = ?R_pre @ ?z # ?R_post; Q.hitting_paths ?z;\n   \\<And>z'.\n      z' \\<in> set ?R_pre \\<Longrightarrow>\n      \\<not> Q.hitting_paths z'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size\n  (\\<And>R_pre z R_post.\n      \\<lbrakk>R = R_pre @ z # R_post; Q.hitting_paths z;\n       \\<And>z'.\n          z' \\<in> set R_pre \\<Longrightarrow>\n          \\<not> Q.hitting_paths z'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["", "end \\<comment> \\<open>locale @{locale ProofStepInduct_y_eq_new_last}\\<close>"], ["", "end"]]}