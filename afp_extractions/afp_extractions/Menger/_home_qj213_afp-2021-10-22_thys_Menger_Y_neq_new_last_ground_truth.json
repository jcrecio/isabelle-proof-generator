{"file_name": "/home/qj213/afp-2021-10-22/thys/Menger/Y_neq_new_last.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Menger", "problem_names": ["lemma Q_hit_exists: obtains Q_hit Q_hit_pre Q_hit_post where\n  \"Q_hit \\<in> Q\" \"y \\<in> set Q_hit\" \"Q_hit = Q_hit_pre @ y # Q_hit_post\"", "lemma Q_hit_v0_v1: \"v0 \\<leadsto>Q_hit\\<leadsto>\\<^bsub>H_x\\<^esub> v1\"", "lemma Q_hit_vertices: \"set Q_hit \\<subseteq> V - {new_last}\"", "lemma Q_hit_pre_not_Nil: \"Q_hit_pre \\<noteq> Nil\"", "lemma tl_Q_hit_pre: \"tl (Q_hit_pre @ [y]) \\<noteq> Nil\"", "lemma Q_hit_pre_edges: \"edges_of_walk (Q_hit_pre @ [y]) \\<inter> B \\<noteq> {}\"", "lemma P_k_pre_edges: \"edges_of_walk (P_k_pre @ [y]) \\<inter> B = {}\"", "lemma Q_hit'_v0_v1: \"v0 \\<leadsto>Q_hit'\\<leadsto> v1\"", "lemma Q_hit'_v0_v1_H_x: \"v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1\"", "lemma Q_hit_edges_disjoint:\n    \"\\<Union>(edges_of_walk ` (Q - {Q_hit})) \\<inter> edges_of_walk Q_hit = {}\"", "lemma Q_hit'_notin_Q_minus_Q_hit: \"Q_hit' \\<notin> Q - {Q_hit}\"", "lemma Q_weight_smaller: \"Q_weight Q' < Q_weight Q\"", "lemma DisjointPaths_Q': \"DisjointPaths H_x v0 v1 Q'\"", "lemma card_Q': \"card Q' = sep_size\"", "lemma contradiction': \"False\""], "translations": [["", "lemma Q_hit_exists: obtains Q_hit Q_hit_pre Q_hit_post where\n  \"Q_hit \\<in> Q\" \"y \\<in> set Q_hit\" \"Q_hit = Q_hit_pre @ y # Q_hit_post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q_hit Q_hit_pre Q_hit_post.\n        \\<lbrakk>Q_hit \\<in> Q; y \\<in> set Q_hit;\n         Q_hit = Q_hit_pre @ y # Q_hit_post\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Q_hit Q_hit_pre Q_hit_post.\n        \\<lbrakk>Q_hit \\<in> Q; y \\<in> set Q_hit;\n         Q_hit = Q_hit_pre @ y # Q_hit_post\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain Q_hit where \"Q_hit \\<in> Q\" \"y \\<in> set Q_hit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q_hit.\n        \\<lbrakk>Q_hit \\<in> Q; y \\<in> set Q_hit\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hitting_Q_or_new_last_def y y_neq_v1 y_neq_new_last"], ["proof (prove)\nusing this:\n  hitting_Q_or_new_last \\<equiv>\n  \\<lambda>y.\n     y \\<noteq> v0 \\<and>\n     (y = new_last \\<or> (\\<exists>Q_hit\\<in>Q. y \\<in> set Q_hit))\n  hitting_Q_or_new_last y\n  y \\<noteq> v1\n  y \\<noteq> new_last\n\ngoal (1 subgoal):\n 1. (\\<And>Q_hit.\n        \\<lbrakk>Q_hit \\<in> Q; y \\<in> set Q_hit\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Q_hit \\<in> Q\n  y \\<in> set Q_hit\n\ngoal (1 subgoal):\n 1. (\\<And>Q_hit Q_hit_pre Q_hit_post.\n        \\<lbrakk>Q_hit \\<in> Q; y \\<in> set Q_hit;\n         Q_hit = Q_hit_pre @ y # Q_hit_post\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  Q_hit \\<in> Q\n  y \\<in> set Q_hit", "show ?thesis"], ["proof (prove)\nusing this:\n  Q_hit \\<in> Q\n  y \\<in> set Q_hit\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  Q_hit \\<in> Q\n  y \\<in> set Q_hit\n  \\<lbrakk>?Q_hit \\<in> Q; y \\<in> set ?Q_hit;\n   ?Q_hit = ?Q_hit_pre @ y # ?Q_hit_post\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We open an anonymous context because we do not want to export any lemmas except the final lemma\n  proving the contradiction.  This is also an easy way to get the decomposition of @{term Q_hit},\n  whose existence we have established above.\n\\<close>"], ["", "context\n  fixes Q_hit Q_hit_pre Q_hit_post\n  assumes Q_hit: \"Q_hit \\<in> Q\" \"y \\<in> set Q_hit\"\n    and Q_hit_decomp: \"Q_hit = Q_hit_pre @ y # Q_hit_post\"\nbegin"], ["", "private"], ["", "lemma Q_hit_v0_v1: \"v0 \\<leadsto>Q_hit\\<leadsto>\\<^bsub>H_x\\<^esub> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "using Q.paths Q_hit(1)"], ["proof (prove)\nusing this:\n  ?xs \\<in> Q \\<Longrightarrow>\n  v0 \\<leadsto>?xs\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  Q_hit \\<in> Q\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "by blast"], ["", "private"], ["", "lemma Q_hit_vertices: \"set Q_hit \\<subseteq> V - {new_last}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set Q_hit \\<subseteq> V - {new_last}", "using Q.walk_in_V H_x_def path_from_to_def remove_vertex_V Q_hit_v0_v1"], ["proof (prove)\nusing this:\n  Q.walk ?xs \\<Longrightarrow> set ?xs \\<subseteq> V\\<^bsub>H_x\\<^esub>\n  H_x \\<equiv> remove_vertex new_last\n  ?v \\<leadsto>?xs\\<leadsto>\\<^bsub>?G\\<^esub> ?w \\<equiv>\n  (Digraph.walk ?G ?xs \\<and> distinct ?xs) \\<and>\n  ?xs \\<noteq> [] \\<and> hd ?xs = ?v \\<and> last ?xs = ?w\n  V\\<^bsub>remove_vertex ?x\\<^esub> = V - {?x}\n  v0 \\<leadsto>Q_hit\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n\ngoal (1 subgoal):\n 1. set Q_hit \\<subseteq> V - {new_last}", "by fastforce"], ["", "private"], ["", "lemma Q_hit_pre_not_Nil: \"Q_hit_pre \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_hit_pre \\<noteq> []", "using Q_hit_v0_v1 y_neq_v0"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>Q_hit\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  y \\<noteq> v0\n\ngoal (1 subgoal):\n 1. Q_hit_pre \\<noteq> []", "unfolding Q_hit_decomp"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(Q_hit_pre @ y # Q_hit_post)\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  y \\<noteq> v0\n\ngoal (1 subgoal):\n 1. Q_hit_pre \\<noteq> []", "by auto"], ["", "private"], ["", "lemma tl_Q_hit_pre: \"tl (Q_hit_pre @ [y]) \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (Q_hit_pre @ [y]) \\<noteq> []", "using Q_hit_pre_not_Nil"], ["proof (prove)\nusing this:\n  Q_hit_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. tl (Q_hit_pre @ [y]) \\<noteq> []", "by simp"], ["", "private"], ["", "lemma Q_hit_pre_edges: \"edges_of_walk (Q_hit_pre @ [y]) \\<inter> B \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B \\<noteq> {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "assume \"edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {}\""], ["proof (state)\nthis:\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "have \"edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> E", "by (metis Q.paths H_x_def Q_hit(1) Q_hit_decomp edges_of_walk_in_E path_decomp'\n          path_from_to_def remove_vertex_walk_add)"], ["proof (state)\nthis:\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> E\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {}\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> E", "have Q_hit_pre_edges:\n      \"edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> \\<Union>(edges_of_walk ` paths_with_new)\""], ["proof (prove)\nusing this:\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {}\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> E\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "unfolding B_def"], ["proof (prove)\nusing this:\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<inter>\n  (E - \\<Union> (H.edges_of_walk ` paths_with_new)) =\n  {}\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> E\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "by blast"], ["proof (state)\nthis:\n  H.edges_of_walk (Q_hit_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  H.edges_of_walk (Q_hit_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "have *: \"first_edge_of_walk (Q_hit_pre @ [y]) \\<in> \\<Union>(edges_of_walk ` paths_with_new)\""], ["proof (prove)\nusing this:\n  H.edges_of_walk (Q_hit_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. H.first_edge_of_walk (Q_hit_pre @ [y])\n    \\<in> \\<Union> (H.edges_of_walk ` paths_with_new)", "using tl_Q_hit_pre first_edge_in_edges"], ["proof (prove)\nusing this:\n  H.edges_of_walk (Q_hit_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n  tl (Q_hit_pre @ [y]) \\<noteq> []\n  tl ?xs \\<noteq> [] \\<Longrightarrow>\n  H.first_edge_of_walk ?xs \\<in> H.edges_of_walk ?xs\n\ngoal (1 subgoal):\n 1. H.first_edge_of_walk (Q_hit_pre @ [y])\n    \\<in> \\<Union> (H.edges_of_walk ` paths_with_new)", "by blast"], ["proof (state)\nthis:\n  H.first_edge_of_walk (Q_hit_pre @ [y])\n  \\<in> \\<Union> (H.edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "define v' where \"v' \\<equiv> hd (tl (Q_hit_pre @ [y]))\""], ["proof (state)\nthis:\n  v' \\<equiv> hd (tl (Q_hit_pre @ [y]))\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v' \\<equiv> hd (tl (Q_hit_pre @ [y]))", "have v': \"(v0, v') = first_edge_of_walk (Q_hit_pre @ [y])\""], ["proof (prove)\nusing this:\n  v' \\<equiv> hd (tl (Q_hit_pre @ [y]))\n\ngoal (1 subgoal):\n 1. (v0, v') = H.first_edge_of_walk (Q_hit_pre @ [y])", "using first_edge_hd_tl Q_hit_pre_not_Nil tl_Q_hit_pre"], ["proof (prove)\nusing this:\n  v' \\<equiv> hd (tl (Q_hit_pre @ [y]))\n  \\<lbrakk>?v \\<leadsto>?xs\\<leadsto> ?w; tl ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> H.first_edge_of_walk ?xs = (?v, hd (tl ?xs))\n  Q_hit_pre \\<noteq> []\n  tl (Q_hit_pre @ [y]) \\<noteq> []\n\ngoal (1 subgoal):\n 1. (v0, v') = H.first_edge_of_walk (Q_hit_pre @ [y])", "by (metis Q.path_from_toE Q_hit_decomp Q_hit_v0_v1 first_edge_of_walk.simps(1)\n          hd_Cons_tl hd_append snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  (v0, v') = H.first_edge_of_walk (Q_hit_pre @ [y])\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (v0, v') = H.first_edge_of_walk (Q_hit_pre @ [y])", "obtain P_i where\n      P_i: \"P_i \\<in> paths_with_new\" \"(v0, v') \\<in> edges_of_walk P_i\""], ["proof (prove)\nusing this:\n  (v0, v') = H.first_edge_of_walk (Q_hit_pre @ [y])\n\ngoal (1 subgoal):\n 1. (\\<And>P_i.\n        \\<lbrakk>P_i \\<in> paths_with_new;\n         (v0, v') \\<in> H.edges_of_walk P_i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using *"], ["proof (prove)\nusing this:\n  (v0, v') = H.first_edge_of_walk (Q_hit_pre @ [y])\n  H.first_edge_of_walk (Q_hit_pre @ [y])\n  \\<in> \\<Union> (H.edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. (\\<And>P_i.\n        \\<lbrakk>P_i \\<in> paths_with_new;\n         (v0, v') \\<in> H.edges_of_walk P_i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P_i \\<in> paths_with_new\n  (v0, v') \\<in> H.edges_of_walk P_i\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  P_i \\<in> paths_with_new\n  (v0, v') \\<in> H.edges_of_walk P_i", "have P_i_first: \"first_edge_of_walk P_i = (v0, v')\""], ["proof (prove)\nusing this:\n  P_i \\<in> paths_with_new\n  (v0, v') \\<in> H.edges_of_walk P_i\n\ngoal (1 subgoal):\n 1. H.first_edge_of_walk P_i = (v0, v')", "using first_edge_first paths_with_new_def paths P_new"], ["proof (prove)\nusing this:\n  P_i \\<in> paths_with_new\n  (v0, v') \\<in> H.edges_of_walk P_i\n  \\<lbrakk>?v \\<leadsto>?xs\\<leadsto> ?w;\n   (?v, ?w') \\<in> H.edges_of_walk ?xs\\<rbrakk>\n  \\<Longrightarrow> H.first_edge_of_walk ?xs = (?v, ?w')\n  paths_with_new \\<equiv> insert P_new paths\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n  v0 \\<leadsto>P_new\\<leadsto> last P_new\n\ngoal (1 subgoal):\n 1. H.first_edge_of_walk P_i = (v0, v')", "by (metis insert_iff)"], ["proof (state)\nthis:\n  H.first_edge_of_walk P_i = (v0, v')\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  H.first_edge_of_walk P_i = (v0, v')\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "have \"first_edge_of_walk P_k = (v0, hd (tl P_k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.first_edge_of_walk P_k = (v0, hd (tl P_k))", "by (metis P_k_decomp P_k_pre_not_Nil append_is_Nil_conv first_edge_of_walk.simps(1)\n          hd_P_k_v0 list.distinct(1) list.exhaust_sel tl_append2)"], ["proof (state)\nthis:\n  H.first_edge_of_walk P_k = (v0, hd (tl P_k))\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  H.first_edge_of_walk P_i = (v0, v')\n  H.first_edge_of_walk P_k = (v0, hd (tl P_k))", "have \"P_i \\<noteq> P_k\""], ["proof (prove)\nusing this:\n  H.first_edge_of_walk P_i = (v0, v')\n  H.first_edge_of_walk P_k = (v0, hd (tl P_k))\n\ngoal (1 subgoal):\n 1. P_i \\<noteq> P_k", "by (metis Q.first_edge_first P_k(2) Q.second_vertices_first_edge Q_hit(1) Q_hit_decomp\n          Q_hit_v0_v1 Un_iff v' tl_Q_hit_pre first_edge_in_edges walk_edges_decomp)"], ["proof (state)\nthis:\n  P_i \\<noteq> P_k\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "text \\<open>\n      Then @{term P_k} and @{term P_i} intersect in @{term y}, which is not one of @{term v0},\n      @{term v1}, or @{term new_last}.  So we get a contradiction because these two paths should be\n      disjoint on all other vertices.\n\\<close>"], ["proof (state)\nthis:\n  P_i \\<noteq> P_k\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  P_i \\<noteq> P_k\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "have \"v1 \\<notin> set (Q_hit_pre @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<notin> set (Q_hit_pre @ [y])", "using Q_hit_v0_v1 Q_hit_decomp y_neq_v1"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>Q_hit\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  Q_hit = Q_hit_pre @ y # Q_hit_post\n  y \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v1 \\<notin> set (Q_hit_pre @ [y])", "by (simp add: Q.path_from_to_last')"], ["proof (state)\nthis:\n  v1 \\<notin> set (Q_hit_pre @ [y])\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  v1 \\<notin> set (Q_hit_pre @ [y])\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "have \"new_last \\<notin> set (Q_hit_pre @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<notin> set (Q_hit_pre @ [y])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. new_last \\<notin> set (Q_hit_pre @ [y])", "have \"new_last \\<notin> set Q_hit_pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<notin> set Q_hit_pre", "using Q_hit_decomp Q_hit_vertices"], ["proof (prove)\nusing this:\n  Q_hit = Q_hit_pre @ y # Q_hit_post\n  set Q_hit \\<subseteq> V - {new_last}\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set Q_hit_pre", "by auto"], ["proof (state)\nthis:\n  new_last \\<notin> set Q_hit_pre\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set (Q_hit_pre @ [y])", "then"], ["proof (chain)\npicking this:\n  new_last \\<notin> set Q_hit_pre", "show ?thesis"], ["proof (prove)\nusing this:\n  new_last \\<notin> set Q_hit_pre\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set (Q_hit_pre @ [y])", "using y_neq_new_last"], ["proof (prove)\nusing this:\n  new_last \\<notin> set Q_hit_pre\n  y \\<noteq> new_last\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set (Q_hit_pre @ [y])", "by auto"], ["proof (state)\nthis:\n  new_last \\<notin> set (Q_hit_pre @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  new_last \\<notin> set (Q_hit_pre @ [y])\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  new_last \\<notin> set (Q_hit_pre @ [y])\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "have \"hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)", "have \"hd (tl P_i) = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl P_i) = v'", "using P_i_first P_i(1) tl_P_new(1)"], ["proof (prove)\nusing this:\n  H.first_edge_of_walk P_i = (v0, v')\n  P_i \\<in> paths_with_new\n  tl P_new \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (tl P_i) = v'", "by (metis Pair_inject first_edge_of_walk.simps(1) insert_iff list.collapse\n            paths_tl_notnil paths_with_new_def tl_Nil)"], ["proof (state)\nthis:\n  hd (tl P_i) = v'\n\ngoal (1 subgoal):\n 1. hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)", "then"], ["proof (chain)\npicking this:\n  hd (tl P_i) = v'", "show ?thesis"], ["proof (prove)\nusing this:\n  hd (tl P_i) = v'\n\ngoal (1 subgoal):\n 1. hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)", "using v'_def"], ["proof (prove)\nusing this:\n  hd (tl P_i) = v'\n  v' \\<equiv> hd (tl (Q_hit_pre @ [y]))\n\ngoal (1 subgoal):\n 1. hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)", "by simp"], ["proof (state)\nthis:\n  hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "have \"v0 \\<leadsto>(Q_hit_pre @ [y])\\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(Q_hit_pre @ [y])\\<leadsto> y", "by (metis Q.path_decomp' H_x_def Q_hit_decomp Q_hit_v0_v1 Q_hit_pre_not_Nil\n          hd_append2 path_from_to_def remove_vertex_walk_add snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  v0 \\<leadsto>(Q_hit_pre @ [y])\\<leadsto> y\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  P_i \\<noteq> P_k\n  v1 \\<notin> set (Q_hit_pre @ [y])\n  new_last \\<notin> set (Q_hit_pre @ [y])\n  hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)\n  v0 \\<leadsto>(Q_hit_pre @ [y])\\<leadsto> y", "have \"edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> edges_of_walk P_i\""], ["proof (prove)\nusing this:\n  P_i \\<noteq> P_k\n  v1 \\<notin> set (Q_hit_pre @ [y])\n  new_last \\<notin> set (Q_hit_pre @ [y])\n  hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)\n  v0 \\<leadsto>(Q_hit_pre @ [y])\\<leadsto> y\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> H.edges_of_walk P_i", "using new_path_follows_old_paths tl_Q_hit_pre P_i(1) Q_hit_pre_edges"], ["proof (prove)\nusing this:\n  P_i \\<noteq> P_k\n  v1 \\<notin> set (Q_hit_pre @ [y])\n  new_last \\<notin> set (Q_hit_pre @ [y])\n  hd (tl (Q_hit_pre @ [y])) = hd (tl P_i)\n  v0 \\<leadsto>(Q_hit_pre @ [y])\\<leadsto> y\n  \\<lbrakk>v0 \\<leadsto>?xs\\<leadsto> ?w; tl ?xs \\<noteq> [];\n   v1 \\<notin> set ?xs; new_last \\<notin> set ?xs; ?P \\<in> paths_with_new;\n   hd (tl ?xs) = hd (tl ?P);\n   H.edges_of_walk ?xs\n   \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\\<rbrakk>\n  \\<Longrightarrow> H.edges_of_walk ?xs \\<subseteq> H.edges_of_walk ?P\n  tl (Q_hit_pre @ [y]) \\<noteq> []\n  P_i \\<in> paths_with_new\n  H.edges_of_walk (Q_hit_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> H.edges_of_walk P_i", "by blast"], ["proof (state)\nthis:\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<subseteq> H.edges_of_walk P_i\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "from walk_edges_subset[OF this]"], ["proof (chain)\npicking this:\n  tl (Q_hit_pre @ [y]) \\<noteq> [] \\<Longrightarrow>\n  set (Q_hit_pre @ [y]) \\<subseteq> set P_i", "have \"y \\<in> set P_i\""], ["proof (prove)\nusing this:\n  tl (Q_hit_pre @ [y]) \\<noteq> [] \\<Longrightarrow>\n  set (Q_hit_pre @ [y]) \\<subseteq> set P_i\n\ngoal (1 subgoal):\n 1. y \\<in> set P_i", "by (simp add: tl_Q_hit_pre)"], ["proof (state)\nthis:\n  y \\<in> set P_i\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  y \\<in> set P_i\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "have \"y \\<in> set P_k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set P_k", "using P_k_decomp"], ["proof (prove)\nusing this:\n  P_k = P_k_pre @ y # P_k_post\n\ngoal (1 subgoal):\n 1. y \\<in> set P_k", "by auto"], ["proof (state)\nthis:\n  y \\<in> set P_k\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B = {} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> set P_i\n  y \\<in> set P_k", "show False"], ["proof (prove)\nusing this:\n  y \\<in> set P_i\n  y \\<in> set P_k\n\ngoal (1 subgoal):\n 1. False", "using y_neq_v0 y_neq_v1 y_neq_new_last \\<open>P_i \\<noteq> P_k\\<close>\n        paths_plus_one_disjoint[OF P_i(1), of P_k y] P_k(1) P_new_decomp"], ["proof (prove)\nusing this:\n  y \\<in> set P_i\n  y \\<in> set P_k\n  y \\<noteq> v0\n  y \\<noteq> v1\n  y \\<noteq> new_last\n  P_i \\<noteq> P_k\n  \\<lbrakk>P_k \\<in> paths_with_new; P_i \\<noteq> P_k; y \\<in> set P_i;\n   y \\<in> set P_k\\<rbrakk>\n  \\<Longrightarrow> y = v0 \\<or> y = v1 \\<or> y = new_last\n  P_k \\<in> paths_with_new\n  P_new = new_pre @ [new_last]\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma P_k_pre_edges: \"edges_of_walk (P_k_pre @ [y]) \\<inter> B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y]) \\<inter> B = {}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y]) \\<inter> B = {}", "have \"edges_of_walk (P_k_pre @ [y]) \\<subseteq> \\<Union>(edges_of_walk ` paths_with_new)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n 2. \\<not> ?P \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "assume \"P_k = P_new\""], ["proof (state)\nthis:\n  P_k = P_new\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n 2. \\<not> ?P \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "then"], ["proof (chain)\npicking this:\n  P_k = P_new", "have \"edges_of_walk (P_k_pre @ [y]) \\<subseteq> edges_of_walk P_new\""], ["proof (prove)\nusing this:\n  P_k = P_new\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y]) \\<subseteq> H.edges_of_walk P_new", "using P_k_decomp edges_of_comp1"], ["proof (prove)\nusing this:\n  P_k = P_new\n  P_k = P_k_pre @ y # P_k_post\n  H.edges_of_walk ?xs \\<subseteq> H.edges_of_walk (?xs @ ?ys)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y]) \\<subseteq> H.edges_of_walk P_new", "by force"], ["proof (state)\nthis:\n  H.edges_of_walk (P_k_pre @ [y]) \\<subseteq> H.edges_of_walk P_new\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n 2. \\<not> ?P \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "then"], ["proof (chain)\npicking this:\n  H.edges_of_walk (P_k_pre @ [y]) \\<subseteq> H.edges_of_walk P_new", "show ?thesis"], ["proof (prove)\nusing this:\n  H.edges_of_walk (P_k_pre @ [y]) \\<subseteq> H.edges_of_walk P_new\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "unfolding paths_with_new_def"], ["proof (prove)\nusing this:\n  H.edges_of_walk (P_k_pre @ [y]) \\<subseteq> H.edges_of_walk P_new\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` insert P_new paths)", "by blast"], ["proof (state)\nthis:\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. P_k \\<noteq> P_new \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P_k \\<noteq> P_new \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "assume \"P_k \\<noteq> P_new\""], ["proof (state)\nthis:\n  P_k \\<noteq> P_new\n\ngoal (1 subgoal):\n 1. P_k \\<noteq> P_new \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "then"], ["proof (chain)\npicking this:\n  P_k \\<noteq> P_new", "have \"P_k \\<in> paths\""], ["proof (prove)\nusing this:\n  P_k \\<noteq> P_new\n\ngoal (1 subgoal):\n 1. P_k \\<in> paths", "using P_k(1) paths_with_new_def"], ["proof (prove)\nusing this:\n  P_k \\<noteq> P_new\n  P_k \\<in> paths_with_new\n  paths_with_new \\<equiv> insert P_new paths\n\ngoal (1 subgoal):\n 1. P_k \\<in> paths", "by blast"], ["proof (state)\nthis:\n  P_k \\<in> paths\n\ngoal (1 subgoal):\n 1. P_k \\<noteq> P_new \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "then"], ["proof (chain)\npicking this:\n  P_k \\<in> paths", "have \"edges_of_walk (P_k_pre @ [y]) \\<subseteq> \\<Union>(edges_of_walk ` paths)\""], ["proof (prove)\nusing this:\n  P_k \\<in> paths\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths)", "using edges_of_comp1[of \"P_k_pre @ [y]\"] P_k_decomp"], ["proof (prove)\nusing this:\n  P_k \\<in> paths\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> H.edges_of_walk ((P_k_pre @ [y]) @ ?ys)\n  P_k = P_k_pre @ y # P_k_post\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths)", "by auto"], ["proof (state)\nthis:\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths)\n\ngoal (1 subgoal):\n 1. P_k \\<noteq> P_new \\<Longrightarrow>\n    H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "then"], ["proof (chain)\npicking this:\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths)", "show ?thesis"], ["proof (prove)\nusing this:\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "unfolding paths_with_new_def"], ["proof (prove)\nusing this:\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y])\n    \\<subseteq> \\<Union> (H.edges_of_walk ` insert P_new paths)", "by blast"], ["proof (state)\nthis:\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y]) \\<inter> B = {}", "then"], ["proof (chain)\npicking this:\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)", "show ?thesis"], ["proof (prove)\nusing this:\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y]) \\<inter> B = {}", "unfolding B_def"], ["proof (prove)\nusing this:\n  H.edges_of_walk (P_k_pre @ [y])\n  \\<subseteq> \\<Union> (H.edges_of_walk ` paths_with_new)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk (P_k_pre @ [y]) \\<inter>\n    (E - \\<Union> (H.edges_of_walk ` paths_with_new)) =\n    {}", "by blast"], ["proof (state)\nthis:\n  H.edges_of_walk (P_k_pre @ [y]) \\<inter> B = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "definition Q_hit' where \"Q_hit' \\<equiv> P_k_pre @ y # Q_hit_post\""], ["", "private"], ["", "lemma Q_hit'_v0_v1: \"v0 \\<leadsto>Q_hit'\\<leadsto> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "assume \"v \\<in> set P_k_pre\""], ["proof (state)\nthis:\n  v \\<in> set P_k_pre\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "then"], ["proof (chain)\npicking this:\n  v \\<in> set P_k_pre", "have \"\\<not>Q.hitting_paths v\""], ["proof (prove)\nusing this:\n  v \\<in> set P_k_pre\n\ngoal (1 subgoal):\n 1. \\<not> Q.hitting_paths v", "using Q.paths Q_hit(1) y_min"], ["proof (prove)\nusing this:\n  v \\<in> set P_k_pre\n  ?xs \\<in> Q \\<Longrightarrow>\n  v0 \\<leadsto>?xs\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  Q_hit \\<in> Q\n  ?y' \\<in> set P_k_pre \\<Longrightarrow> \\<not> hitting_Q_or_new_last ?y'\n\ngoal (1 subgoal):\n 1. \\<not> Q.hitting_paths v", "by (metis Q.hitting_paths_def hitting_Q_or_new_last_def last_in_set path_from_to_def)"], ["proof (state)\nthis:\n  \\<not> Q.hitting_paths v\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "moreover"], ["proof (state)\nthis:\n  \\<not> Q.hitting_paths v\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "have \"v0 \\<notin> set Q_hit_post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<notin> set Q_hit_post", "using Q.path_from_to_first' Q_hit_v0_v1"], ["proof (prove)\nusing this:\n  ?v \\<leadsto>(?xs @\n                ?x # ?xs')\\<leadsto>\\<^bsub>H_x\\<^esub> ?w \\<Longrightarrow>\n  ?v \\<notin> set ?xs'\n  v0 \\<leadsto>Q_hit\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set Q_hit_post", "unfolding Q_hit_decomp"], ["proof (prove)\nusing this:\n  ?v \\<leadsto>(?xs @\n                ?x # ?xs')\\<leadsto>\\<^bsub>H_x\\<^esub> ?w \\<Longrightarrow>\n  ?v \\<notin> set ?xs'\n  v0 \\<leadsto>(Q_hit_pre @ y # Q_hit_post)\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n\ngoal (1 subgoal):\n 1. v0 \\<notin> set Q_hit_post", "by blast"], ["proof (state)\nthis:\n  v0 \\<notin> set Q_hit_post\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> Q.hitting_paths v\n  v0 \\<notin> set Q_hit_post", "have \"v \\<notin> set Q_hit_post\""], ["proof (prove)\nusing this:\n  \\<not> Q.hitting_paths v\n  v0 \\<notin> set Q_hit_post\n\ngoal (1 subgoal):\n 1. v \\<notin> set Q_hit_post", "unfolding Q.hitting_paths_def"], ["proof (prove)\nusing this:\n  \\<not> (v \\<noteq> v0 \\<and>\n          ((\\<exists>xs\\<in>Q. v \\<in> set xs) \\<or> v = v1))\n  v0 \\<notin> set Q_hit_post\n\ngoal (1 subgoal):\n 1. v \\<notin> set Q_hit_post", "using Q_hit(1) Q_hit_decomp"], ["proof (prove)\nusing this:\n  \\<not> (v \\<noteq> v0 \\<and>\n          ((\\<exists>xs\\<in>Q. v \\<in> set xs) \\<or> v = v1))\n  v0 \\<notin> set Q_hit_post\n  Q_hit \\<in> Q\n  Q_hit = Q_hit_pre @ y # Q_hit_post\n\ngoal (1 subgoal):\n 1. v \\<notin> set Q_hit_post", "by auto"], ["proof (state)\nthis:\n  v \\<notin> set Q_hit_post\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> set P_k_pre \\<Longrightarrow> ?v2 \\<notin> set Q_hit_post\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "then"], ["proof (chain)\npicking this:\n  ?v2 \\<in> set P_k_pre \\<Longrightarrow> ?v2 \\<notin> set Q_hit_post", "have \"set P_k_pre \\<inter> set Q_hit_post = {}\""], ["proof (prove)\nusing this:\n  ?v2 \\<in> set P_k_pre \\<Longrightarrow> ?v2 \\<notin> set Q_hit_post\n\ngoal (1 subgoal):\n 1. set P_k_pre \\<inter> set Q_hit_post = {}", "by blast"], ["proof (state)\nthis:\n  set P_k_pre \\<inter> set Q_hit_post = {}\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "then"], ["proof (chain)\npicking this:\n  set P_k_pre \\<inter> set Q_hit_post = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  set P_k_pre \\<inter> set Q_hit_post = {}\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto> v1", "unfolding Q_hit'_def"], ["proof (prove)\nusing this:\n  set P_k_pre \\<inter> set Q_hit_post = {}\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(P_k_pre @ y # Q_hit_post)\\<leadsto> v1", "using path_from_to_combine"], ["proof (prove)\nusing this:\n  set P_k_pre \\<inter> set Q_hit_post = {}\n  \\<lbrakk>?v \\<leadsto>(?xs @ ?x # ?xs')\\<leadsto> ?w;\n   ?v' \\<leadsto>(?ys @ ?x # ?ys')\\<leadsto> ?w';\n   set ?xs \\<inter> set ?ys' = {}\\<rbrakk>\n  \\<Longrightarrow> ?v \\<leadsto>(?xs @ ?x # ?ys')\\<leadsto> ?w'\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(P_k_pre @ y # Q_hit_post)\\<leadsto> v1", "by (metis H_x_def P_k_decomp P_k_pre_not_Nil Q_hit_decomp Q_hit_v0_v1 append_is_Nil_conv\n          hd_P_k_v0 path_P_k path_from_toI remove_vertex_path_from_to_add)"], ["proof (state)\nthis:\n  v0 \\<leadsto>Q_hit'\\<leadsto> v1\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma Q_hit'_v0_v1_H_x: \"v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "have \"new_last \\<notin> set P_k_pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<notin> set P_k_pre", "using new_last_neq_v0 hitting_Q_or_new_last_def y_min"], ["proof (prove)\nusing this:\n  new_last \\<noteq> v0\n  hitting_Q_or_new_last \\<equiv>\n  \\<lambda>y.\n     y \\<noteq> v0 \\<and>\n     (y = new_last \\<or> (\\<exists>Q_hit\\<in>Q. y \\<in> set Q_hit))\n  ?y' \\<in> set P_k_pre \\<Longrightarrow> \\<not> hitting_Q_or_new_last ?y'\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set P_k_pre", "by auto"], ["proof (state)\nthis:\n  new_last \\<notin> set P_k_pre\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "moreover"], ["proof (state)\nthis:\n  new_last \\<notin> set P_k_pre\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "have \"new_last \\<notin> set Q_hit_post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last \\<notin> set Q_hit_post", "using Q_hit_vertices"], ["proof (prove)\nusing this:\n  set Q_hit \\<subseteq> V - {new_last}\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set Q_hit_post", "unfolding Q_hit_decomp"], ["proof (prove)\nusing this:\n  set (Q_hit_pre @ y # Q_hit_post) \\<subseteq> V - {new_last}\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set Q_hit_post", "by auto"], ["proof (state)\nthis:\n  new_last \\<notin> set Q_hit_post\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "ultimately"], ["proof (chain)\npicking this:\n  new_last \\<notin> set P_k_pre\n  new_last \\<notin> set Q_hit_post", "have \"new_last \\<notin> set Q_hit'\""], ["proof (prove)\nusing this:\n  new_last \\<notin> set P_k_pre\n  new_last \\<notin> set Q_hit_post\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set Q_hit'", "using y_neq_new_last Q_hit'_def"], ["proof (prove)\nusing this:\n  new_last \\<notin> set P_k_pre\n  new_last \\<notin> set Q_hit_post\n  y \\<noteq> new_last\n  Q_hit' \\<equiv> P_k_pre @ y # Q_hit_post\n\ngoal (1 subgoal):\n 1. new_last \\<notin> set Q_hit'", "by auto"], ["proof (state)\nthis:\n  new_last \\<notin> set Q_hit'\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "then"], ["proof (chain)\npicking this:\n  new_last \\<notin> set Q_hit'", "show ?thesis"], ["proof (prove)\nusing this:\n  new_last \\<notin> set Q_hit'\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "using remove_vertex_path_from_to[OF Q_hit'_v0_v1] H_x_def new_last_in_V"], ["proof (prove)\nusing this:\n  new_last \\<notin> set Q_hit'\n  \\<lbrakk>?x \\<in> V; ?x \\<notin> set Q_hit'\\<rbrakk>\n  \\<Longrightarrow> v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>remove_vertex ?x\\<^esub> v1\n  H_x \\<equiv> remove_vertex new_last\n  new_last \\<in> V\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1", "by simp"], ["proof (state)\nthis:\n  v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "definition Q' where \"Q' \\<equiv> insert Q_hit' (Q - {Q_hit})\""], ["", "private"], ["", "lemma Q_hit_edges_disjoint:\n    \"\\<Union>(edges_of_walk ` (Q - {Q_hit})) \\<inter> edges_of_walk Q_hit = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (H.edges_of_walk ` (Q - {Q_hit})) \\<inter>\n    H.edges_of_walk Q_hit =\n    {}", "using DiffD1 Q.paths_edge_disjoint Q_hit(1)"], ["proof (prove)\nusing this:\n  ?c \\<in> ?A - ?B \\<Longrightarrow> ?c \\<in> ?A\n  \\<lbrakk>?xs \\<in> Q; ?ys \\<in> Q; ?xs \\<noteq> ?ys\\<rbrakk>\n  \\<Longrightarrow> H.edges_of_walk ?xs \\<inter> H.edges_of_walk ?ys = {}\n  Q_hit \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<Union> (H.edges_of_walk ` (Q - {Q_hit})) \\<inter>\n    H.edges_of_walk Q_hit =\n    {}", "by fastforce"], ["", "private"], ["", "lemma Q_hit'_notin_Q_minus_Q_hit: \"Q_hit' \\<notin> Q - {Q_hit}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_hit' \\<notin> Q - {Q_hit}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Q_hit' \\<notin> Q - {Q_hit}", "have \"hd (tl Q_hit') \\<notin> Q.second_vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tl Q_hit') \\<notin> Q.second_vertices", "using P_k(2) P_k_decomp"], ["proof (prove)\nusing this:\n  hd (tl P_k) \\<notin> Q.second_vertices\n  P_k = P_k_pre @ y # P_k_post\n\ngoal (1 subgoal):\n 1. hd (tl Q_hit') \\<notin> Q.second_vertices", "by (metis P_k_pre_not_Nil Q_hit'_def append_eq_append_conv2 append_self_conv hd_append2\n          list.sel(1) tl_append2)"], ["proof (state)\nthis:\n  hd (tl Q_hit') \\<notin> Q.second_vertices\n\ngoal (1 subgoal):\n 1. Q_hit' \\<notin> Q - {Q_hit}", "then"], ["proof (chain)\npicking this:\n  hd (tl Q_hit') \\<notin> Q.second_vertices", "show ?thesis"], ["proof (prove)\nusing this:\n  hd (tl Q_hit') \\<notin> Q.second_vertices\n\ngoal (1 subgoal):\n 1. Q_hit' \\<notin> Q - {Q_hit}", "using Q.second_vertices_new_path[of Q_hit']"], ["proof (prove)\nusing this:\n  hd (tl Q_hit') \\<notin> Q.second_vertices\n  hd (tl Q_hit') \\<notin> Q.second_vertices \\<Longrightarrow>\n  Q_hit' \\<notin> Q\n\ngoal (1 subgoal):\n 1. Q_hit' \\<notin> Q - {Q_hit}", "by blast"], ["proof (state)\nthis:\n  Q_hit' \\<notin> Q - {Q_hit}\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma Q_weight_smaller: \"Q_weight Q' < Q_weight Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "define Q_edges where \"Q_edges \\<equiv> \\<Union>(edges_of_walk ` Q) \\<inter> B\""], ["proof (state)\nthis:\n  Q_edges \\<equiv> \\<Union> (H.edges_of_walk ` Q) \\<inter> B\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "define Q'_edges where \"Q'_edges \\<equiv> \\<Union>(edges_of_walk ` Q') \\<inter> B\""], ["proof (state)\nthis:\n  Q'_edges \\<equiv> \\<Union> (H.edges_of_walk ` Q') \\<inter> B\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "{"], ["proof (state)\nthis:\n  Q'_edges \\<equiv> \\<Union> (H.edges_of_walk ` Q') \\<inter> B\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "fix v w"], ["proof (state)\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "assume *: \"(v,w) \\<in> Q'_edges\" \"(v,w) \\<notin> Q_edges\""], ["proof (state)\nthis:\n  (v, w) \\<in> Q'_edges\n  (v, w) \\<notin> Q_edges\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> Q'_edges\n  (v, w) \\<notin> Q_edges", "have v_w_in_B: \"(v,w) \\<in> B\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> Q'_edges\n  (v, w) \\<notin> Q_edges\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> B", "unfolding Q'_edges_def"], ["proof (prove)\nusing this:\n  (v, w) \\<in> \\<Union> (H.edges_of_walk ` Q') \\<inter> B\n  (v, w) \\<notin> Q_edges\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> B", "by blast"], ["proof (state)\nthis:\n  (v, w) \\<in> B\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "obtain Q'_v_w_witness where Q'_v_w_witness:\n        \"Q'_v_w_witness \\<in> Q'\" \"(v,w) \\<in> edges_of_walk Q'_v_w_witness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q'_v_w_witness.\n        \\<lbrakk>Q'_v_w_witness \\<in> Q';\n         (v, w) \\<in> H.edges_of_walk Q'_v_w_witness\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using *(1)"], ["proof (prove)\nusing this:\n  (v, w) \\<in> Q'_edges\n\ngoal (1 subgoal):\n 1. (\\<And>Q'_v_w_witness.\n        \\<lbrakk>Q'_v_w_witness \\<in> Q';\n         (v, w) \\<in> H.edges_of_walk Q'_v_w_witness\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Q'_edges_def"], ["proof (prove)\nusing this:\n  (v, w) \\<in> \\<Union> (H.edges_of_walk ` Q') \\<inter> B\n\ngoal (1 subgoal):\n 1. (\\<And>Q'_v_w_witness.\n        \\<lbrakk>Q'_v_w_witness \\<in> Q';\n         (v, w) \\<in> H.edges_of_walk Q'_v_w_witness\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Q'_v_w_witness \\<in> Q'\n  (v, w) \\<in> H.edges_of_walk Q'_v_w_witness\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "have \"Q'_v_w_witness \\<noteq> Q_hit'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q'_v_w_witness \\<noteq> Q_hit'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Q'_v_w_witness = Q_hit' \\<Longrightarrow> False", "assume \"Q'_v_w_witness = Q_hit'\""], ["proof (state)\nthis:\n  Q'_v_w_witness = Q_hit'\n\ngoal (1 subgoal):\n 1. Q'_v_w_witness = Q_hit' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Q'_v_w_witness = Q_hit'", "have \"edges_of_walk Q'_v_w_witness =\n            edges_of_walk (P_k_pre @ [y]) \\<union> edges_of_walk (y # Q_hit_post)\""], ["proof (prove)\nusing this:\n  Q'_v_w_witness = Q_hit'\n\ngoal (1 subgoal):\n 1. H.edges_of_walk Q'_v_w_witness =\n    H.edges_of_walk (P_k_pre @ [y]) \\<union>\n    H.edges_of_walk (y # Q_hit_post)", "unfolding Q_hit'_def"], ["proof (prove)\nusing this:\n  Q'_v_w_witness = P_k_pre @ y # Q_hit_post\n\ngoal (1 subgoal):\n 1. H.edges_of_walk Q'_v_w_witness =\n    H.edges_of_walk (P_k_pre @ [y]) \\<union>\n    H.edges_of_walk (y # Q_hit_post)", "using walk_edges_decomp[of P_k_pre y Q_hit_post]"], ["proof (prove)\nusing this:\n  Q'_v_w_witness = P_k_pre @ y # Q_hit_post\n  H.edges_of_walk (P_k_pre @ y # Q_hit_post) =\n  H.edges_of_walk (P_k_pre @ [y]) \\<union> H.edges_of_walk (y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. H.edges_of_walk Q'_v_w_witness =\n    H.edges_of_walk (P_k_pre @ [y]) \\<union>\n    H.edges_of_walk (y # Q_hit_post)", "by simp"], ["proof (state)\nthis:\n  H.edges_of_walk Q'_v_w_witness =\n  H.edges_of_walk (P_k_pre @ [y]) \\<union> H.edges_of_walk (y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. Q'_v_w_witness = Q_hit' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  H.edges_of_walk Q'_v_w_witness =\n  H.edges_of_walk (P_k_pre @ [y]) \\<union> H.edges_of_walk (y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. Q'_v_w_witness = Q_hit' \\<Longrightarrow> False", "have \"(v,w) \\<notin> edges_of_walk (P_k_pre @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<notin> H.edges_of_walk (P_k_pre @ [y])", "using P_k_pre_edges v_w_in_B"], ["proof (prove)\nusing this:\n  H.edges_of_walk (P_k_pre @ [y]) \\<inter> B = {}\n  (v, w) \\<in> B\n\ngoal (1 subgoal):\n 1. (v, w) \\<notin> H.edges_of_walk (P_k_pre @ [y])", "by blast"], ["proof (state)\nthis:\n  (v, w) \\<notin> H.edges_of_walk (P_k_pre @ [y])\n\ngoal (1 subgoal):\n 1. Q'_v_w_witness = Q_hit' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (v, w) \\<notin> H.edges_of_walk (P_k_pre @ [y])\n\ngoal (1 subgoal):\n 1. Q'_v_w_witness = Q_hit' \\<Longrightarrow> False", "have \"(v,w) \\<notin> edges_of_walk (y # Q_hit_post)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<notin> H.edges_of_walk (y # Q_hit_post)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk (y # Q_hit_post) \\<Longrightarrow> False", "assume \"(v,w) \\<in> edges_of_walk (y # Q_hit_post)\""], ["proof (state)\nthis:\n  (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk (y # Q_hit_post) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)", "have \"(v,w) \\<in> edges_of_walk Q_hit\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk Q_hit", "unfolding Q_hit_decomp"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk (Q_hit_pre @ y # Q_hit_post)", "by (metis UnCI walk_edges_decomp)"], ["proof (state)\nthis:\n  (v, w) \\<in> H.edges_of_walk Q_hit\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk (y # Q_hit_post) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> H.edges_of_walk Q_hit", "show False"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk Q_hit\n\ngoal (1 subgoal):\n 1. False", "using *(2) v_w_in_B Q_hit(1)"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk Q_hit\n  (v, w) \\<notin> Q_edges\n  (v, w) \\<in> B\n  Q_hit \\<in> Q\n\ngoal (1 subgoal):\n 1. False", "unfolding Q_edges_def"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk Q_hit\n  (v, w) \\<notin> \\<Union> (H.edges_of_walk ` Q) \\<inter> B\n  (v, w) \\<in> B\n  Q_hit \\<in> Q\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, w) \\<notin> H.edges_of_walk (y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. Q'_v_w_witness = Q_hit' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  H.edges_of_walk Q'_v_w_witness =\n  H.edges_of_walk (P_k_pre @ [y]) \\<union> H.edges_of_walk (y # Q_hit_post)\n  (v, w) \\<notin> H.edges_of_walk (P_k_pre @ [y])\n  (v, w) \\<notin> H.edges_of_walk (y # Q_hit_post)", "show False"], ["proof (prove)\nusing this:\n  H.edges_of_walk Q'_v_w_witness =\n  H.edges_of_walk (P_k_pre @ [y]) \\<union> H.edges_of_walk (y # Q_hit_post)\n  (v, w) \\<notin> H.edges_of_walk (P_k_pre @ [y])\n  (v, w) \\<notin> H.edges_of_walk (y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. False", "using Q'_v_w_witness(2)"], ["proof (prove)\nusing this:\n  H.edges_of_walk Q'_v_w_witness =\n  H.edges_of_walk (P_k_pre @ [y]) \\<union> H.edges_of_walk (y # Q_hit_post)\n  (v, w) \\<notin> H.edges_of_walk (P_k_pre @ [y])\n  (v, w) \\<notin> H.edges_of_walk (y # Q_hit_post)\n  (v, w) \\<in> H.edges_of_walk Q'_v_w_witness\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Q'_v_w_witness \\<noteq> Q_hit'\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "then"], ["proof (chain)\npicking this:\n  Q'_v_w_witness \\<noteq> Q_hit'", "have \"Q'_v_w_witness \\<in> Q\""], ["proof (prove)\nusing this:\n  Q'_v_w_witness \\<noteq> Q_hit'\n\ngoal (1 subgoal):\n 1. Q'_v_w_witness \\<in> Q", "using Q'_v_w_witness(1)"], ["proof (prove)\nusing this:\n  Q'_v_w_witness \\<noteq> Q_hit'\n  Q'_v_w_witness \\<in> Q'\n\ngoal (1 subgoal):\n 1. Q'_v_w_witness \\<in> Q", "unfolding Q'_def"], ["proof (prove)\nusing this:\n  Q'_v_w_witness \\<noteq> Q_hit'\n  Q'_v_w_witness \\<in> insert Q_hit' (Q - {Q_hit})\n\ngoal (1 subgoal):\n 1. Q'_v_w_witness \\<in> Q", "by blast"], ["proof (state)\nthis:\n  Q'_v_w_witness \\<in> Q\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "then"], ["proof (chain)\npicking this:\n  Q'_v_w_witness \\<in> Q", "have False"], ["proof (prove)\nusing this:\n  Q'_v_w_witness \\<in> Q\n\ngoal (1 subgoal):\n 1. False", "using *(2) v_w_in_B Q'_v_w_witness(2)"], ["proof (prove)\nusing this:\n  Q'_v_w_witness \\<in> Q\n  (v, w) \\<notin> Q_edges\n  (v, w) \\<in> B\n  (v, w) \\<in> H.edges_of_walk Q'_v_w_witness\n\ngoal (1 subgoal):\n 1. False", "unfolding Q_edges_def"], ["proof (prove)\nusing this:\n  Q'_v_w_witness \\<in> Q\n  (v, w) \\<notin> \\<Union> (H.edges_of_walk ` Q) \\<inter> B\n  (v, w) \\<in> B\n  (v, w) \\<in> H.edges_of_walk Q'_v_w_witness\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?w2) \\<in> Q'_edges; (?v2, ?w2) \\<notin> Q_edges\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?w2) \\<in> Q'_edges; (?v2, ?w2) \\<notin> Q_edges\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "have \"\\<exists>e \\<in> Q_edges. e \\<notin> Q'_edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges", "obtain v w where v_w: \"(v,w) \\<in> edges_of_walk (Q_hit_pre @ [y]) \\<inter> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v w.\n        (v, w)\n        \\<in> H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Q_hit_pre_edges"], ["proof (prove)\nusing this:\n  H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>v w.\n        (v, w)\n        \\<in> H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (v, w) \\<in> H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B", "have v_w_in_Q_hit: \"(v,w) \\<in> edges_of_walk Q_hit \\<inter> B\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk Q_hit \\<inter> B", "unfolding Q_hit_decomp"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk (Q_hit_pre @ y # Q_hit_post) \\<inter> B", "by (metis Int_iff UnCI walk_edges_decomp)"], ["proof (state)\nthis:\n  (v, w) \\<in> H.edges_of_walk Q_hit \\<inter> B\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> H.edges_of_walk Q_hit \\<inter> B", "have \"(v,w) \\<in> Q_edges\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk Q_hit \\<inter> B\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> Q_edges", "unfolding Q_edges_def"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk Q_hit \\<inter> B\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> \\<Union> (H.edges_of_walk ` Q) \\<inter> B", "using Q_hit(1)"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk Q_hit \\<inter> B\n  Q_hit \\<in> Q\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> \\<Union> (H.edges_of_walk ` Q) \\<inter> B", "by blast"], ["proof (state)\nthis:\n  (v, w) \\<in> Q_edges\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges", "moreover"], ["proof (state)\nthis:\n  (v, w) \\<in> Q_edges\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges", "have \"(v,w) \\<notin> Q'_edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<notin> Q'_edges", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, w) \\<in> Q'_edges \\<Longrightarrow> False", "assume \"(v,w) \\<in> Q'_edges\""], ["proof (state)\nthis:\n  (v, w) \\<in> Q'_edges\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> Q'_edges \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> Q'_edges", "have \"(v,w) \\<in> edges_of_walk Q_hit'\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> Q'_edges\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk Q_hit'", "unfolding Q'_edges_def Q'_def"], ["proof (prove)\nusing this:\n  (v, w)\n  \\<in> \\<Union> (H.edges_of_walk ` insert Q_hit' (Q - {Q_hit})) \\<inter> B\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk Q_hit'", "using IntD1 v_w_in_Q_hit Q_hit_edges_disjoint"], ["proof (prove)\nusing this:\n  (v, w)\n  \\<in> \\<Union> (H.edges_of_walk ` insert Q_hit' (Q - {Q_hit})) \\<inter> B\n  ?c \\<in> ?A \\<inter> ?B \\<Longrightarrow> ?c \\<in> ?A\n  (v, w) \\<in> H.edges_of_walk Q_hit \\<inter> B\n  \\<Union> (H.edges_of_walk ` (Q - {Q_hit})) \\<inter>\n  H.edges_of_walk Q_hit =\n  {}\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk Q_hit'", "by auto"], ["proof (state)\nthis:\n  (v, w) \\<in> H.edges_of_walk Q_hit'\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> Q'_edges \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> H.edges_of_walk Q_hit'", "have \"(v,w) \\<in> edges_of_walk (y # Q_hit_post)\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk Q_hit'\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)", "unfolding Q_hit'_def"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk (P_k_pre @ y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)", "using v_w P_k_pre_edges"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk (P_k_pre @ y # Q_hit_post)\n  (v, w) \\<in> H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B\n  H.edges_of_walk (P_k_pre @ [y]) \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)", "by (metis (no_types, lifting) IntD2 UnE disjoint_iff_not_equal walk_edges_decomp)"], ["proof (state)\nthis:\n  (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> Q'_edges \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)", "show False"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. False", "using v_w Q_hit(1) Q.paths Q_hit_decomp"], ["proof (prove)\nusing this:\n  (v, w) \\<in> H.edges_of_walk (y # Q_hit_post)\n  (v, w) \\<in> H.edges_of_walk (Q_hit_pre @ [y]) \\<inter> B\n  Q_hit \\<in> Q\n  ?xs \\<in> Q \\<Longrightarrow>\n  v0 \\<leadsto>?xs\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n  Q_hit = Q_hit_pre @ y # Q_hit_post\n\ngoal (1 subgoal):\n 1. False", "by (metis DiffE Q.path_edges_remove_prefix IntD1 path_from_to_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, w) \\<notin> Q'_edges\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges", "ultimately"], ["proof (chain)\npicking this:\n  (v, w) \\<in> Q_edges\n  (v, w) \\<notin> Q'_edges", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, w) \\<in> Q_edges\n  (v, w) \\<notin> Q'_edges\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges", "by blast"], ["proof (state)\nthis:\n  \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "moreover"], ["proof (state)\nthis:\n  \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "have \"finite Q_edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Q_edges", "unfolding Q_edges_def B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union> (H.edges_of_walk ` Q) \\<inter>\n      (E - \\<Union> (H.edges_of_walk ` paths_with_new)))", "by simp"], ["proof (state)\nthis:\n  finite Q_edges\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "moreover"], ["proof (state)\nthis:\n  finite Q_edges\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "have \"finite Q'_edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Q'_edges", "unfolding Q'_edges_def B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union> (H.edges_of_walk ` Q') \\<inter>\n      (E - \\<Union> (H.edges_of_walk ` paths_with_new)))", "by simp"], ["proof (state)\nthis:\n  finite Q'_edges\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?v2, ?w2) \\<in> Q'_edges; (?v2, ?w2) \\<notin> Q_edges\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges\n  finite Q_edges\n  finite Q'_edges", "have \"card Q'_edges < card Q_edges\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v2, ?w2) \\<in> Q'_edges; (?v2, ?w2) \\<notin> Q_edges\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<exists>e\\<in>Q_edges. e \\<notin> Q'_edges\n  finite Q_edges\n  finite Q'_edges\n\ngoal (1 subgoal):\n 1. card Q'_edges < card Q_edges", "by (metis card_seteq not_le subrelI)"], ["proof (state)\nthis:\n  card Q'_edges < card Q_edges\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "then"], ["proof (chain)\npicking this:\n  card Q'_edges < card Q_edges", "have \"card (\\<Union>(edges_of_walk ` Q') \\<inter> B) < card (\\<Union>(edges_of_walk ` Q) \\<inter> B)\""], ["proof (prove)\nusing this:\n  card Q'_edges < card Q_edges\n\ngoal (1 subgoal):\n 1. card (\\<Union> (H.edges_of_walk ` Q') \\<inter> B)\n    < card (\\<Union> (H.edges_of_walk ` Q) \\<inter> B)", "unfolding Q_edges_def Q'_edges_def"], ["proof (prove)\nusing this:\n  card (\\<Union> (H.edges_of_walk ` Q') \\<inter> B)\n  < card (\\<Union> (H.edges_of_walk ` Q) \\<inter> B)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (H.edges_of_walk ` Q') \\<inter> B)\n    < card (\\<Union> (H.edges_of_walk ` Q) \\<inter> B)", "by blast"], ["proof (state)\nthis:\n  card (\\<Union> (H.edges_of_walk ` Q') \\<inter> B)\n  < card (\\<Union> (H.edges_of_walk ` Q) \\<inter> B)\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "then"], ["proof (chain)\npicking this:\n  card (\\<Union> (H.edges_of_walk ` Q') \\<inter> B)\n  < card (\\<Union> (H.edges_of_walk ` Q) \\<inter> B)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (\\<Union> (H.edges_of_walk ` Q') \\<inter> B)\n  < card (\\<Union> (H.edges_of_walk ` Q) \\<inter> B)\n\ngoal (1 subgoal):\n 1. Q_weight Q' < Q_weight Q", "unfolding Q_weight_def"], ["proof (prove)\nusing this:\n  card (\\<Union> (H.edges_of_walk ` Q') \\<inter> B)\n  < card (\\<Union> (H.edges_of_walk ` Q) \\<inter> B)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (H.edges_of_walk ` Q') \\<inter> B)\n    < card (\\<Union> (H.edges_of_walk ` Q) \\<inter> B)", "by blast"], ["proof (state)\nthis:\n  Q_weight Q' < Q_weight Q\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma DisjointPaths_Q': \"DisjointPaths H_x v0 v1 Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "interpret Q_reduced: DisjointPaths H_x v0 v1 \"Q - {Q_hit}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 (Q - {Q_hit})", "using Q.DisjointPaths_reduce[of \"Q - {Q_hit}\"]"], ["proof (prove)\nusing this:\n  Q - {Q_hit} \\<subseteq> Q \\<Longrightarrow>\n  DisjointPaths H_x v0 v1 (Q - {Q_hit})\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 (Q - {Q_hit})", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "fix xs v"], ["proof (state)\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "assume xs: \"xs \\<in> Q - {Q_hit}\"\n          and v: \"v \\<in> set xs\" \"v \\<in> set Q_hit'\" \"v \\<noteq> v0\" \"v \\<noteq> v1\""], ["proof (state)\nthis:\n  xs \\<in> Q - {Q_hit}\n  v \\<in> set xs\n  v \\<in> set Q_hit'\n  v \\<noteq> v0\n  v \\<noteq> v1\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "have \"v \\<notin> set P_k_pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> set P_k_pre", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set P_k_pre \\<Longrightarrow> False", "assume \"v \\<in> set P_k_pre\""], ["proof (state)\nthis:\n  v \\<in> set P_k_pre\n\ngoal (1 subgoal):\n 1. v \\<in> set P_k_pre \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v \\<in> set P_k_pre", "have \"\\<not>hitting_Q_or_new_last v\""], ["proof (prove)\nusing this:\n  v \\<in> set P_k_pre\n\ngoal (1 subgoal):\n 1. \\<not> hitting_Q_or_new_last v", "using y_min"], ["proof (prove)\nusing this:\n  v \\<in> set P_k_pre\n  ?y' \\<in> set P_k_pre \\<Longrightarrow> \\<not> hitting_Q_or_new_last ?y'\n\ngoal (1 subgoal):\n 1. \\<not> hitting_Q_or_new_last v", "by blast"], ["proof (state)\nthis:\n  \\<not> hitting_Q_or_new_last v\n\ngoal (1 subgoal):\n 1. v \\<in> set P_k_pre \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> hitting_Q_or_new_last v\n\ngoal (1 subgoal):\n 1. v \\<in> set P_k_pre \\<Longrightarrow> False", "have \"v \\<noteq> new_last\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> new_last", "using v(2) calculation hitting_Q_or_new_last_def v(3)"], ["proof (prove)\nusing this:\n  v \\<in> set Q_hit'\n  \\<not> hitting_Q_or_new_last v\n  hitting_Q_or_new_last \\<equiv>\n  \\<lambda>y.\n     y \\<noteq> v0 \\<and>\n     (y = new_last \\<or> (\\<exists>Q_hit\\<in>Q. y \\<in> set Q_hit))\n  v \\<noteq> v0\n\ngoal (1 subgoal):\n 1. v \\<noteq> new_last", "by auto"], ["proof (state)\nthis:\n  v \\<noteq> new_last\n\ngoal (1 subgoal):\n 1. v \\<in> set P_k_pre \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> hitting_Q_or_new_last v\n  v \\<noteq> new_last", "show False"], ["proof (prove)\nusing this:\n  \\<not> hitting_Q_or_new_last v\n  v \\<noteq> new_last\n\ngoal (1 subgoal):\n 1. False", "unfolding hitting_Q_or_new_last_def"], ["proof (prove)\nusing this:\n  \\<not> (v \\<noteq> v0 \\<and>\n          (v = new_last \\<or> (\\<exists>Q_hit\\<in>Q. v \\<in> set Q_hit)))\n  v \\<noteq> new_last\n\ngoal (1 subgoal):\n 1. False", "using v(1,3) xs"], ["proof (prove)\nusing this:\n  \\<not> (v \\<noteq> v0 \\<and>\n          (v = new_last \\<or> (\\<exists>Q_hit\\<in>Q. v \\<in> set Q_hit)))\n  v \\<noteq> new_last\n  v \\<in> set xs\n  v \\<noteq> v0\n  xs \\<in> Q - {Q_hit}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<notin> set P_k_pre\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "moreover"], ["proof (state)\nthis:\n  v \\<notin> set P_k_pre\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "have \"v \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> y", "by (metis DiffE Q.paths_disjoint Q_hit y_neq_v0 y_neq_v1 insert_iff v(1) xs)"], ["proof (state)\nthis:\n  v \\<noteq> y\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "moreover"], ["proof (state)\nthis:\n  v \\<noteq> y\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "have \"v \\<notin> set Q_hit_post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> set Q_hit_post", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set Q_hit_post \\<Longrightarrow> False", "assume \"v \\<in> set Q_hit_post\""], ["proof (state)\nthis:\n  v \\<in> set Q_hit_post\n\ngoal (1 subgoal):\n 1. v \\<in> set Q_hit_post \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v \\<in> set Q_hit_post", "have \"v \\<in> set Q_hit\""], ["proof (prove)\nusing this:\n  v \\<in> set Q_hit_post\n\ngoal (1 subgoal):\n 1. v \\<in> set Q_hit", "unfolding Q_hit_decomp"], ["proof (prove)\nusing this:\n  v \\<in> set Q_hit_post\n\ngoal (1 subgoal):\n 1. v \\<in> set (Q_hit_pre @ y # Q_hit_post)", "by simp"], ["proof (state)\nthis:\n  v \\<in> set Q_hit\n\ngoal (1 subgoal):\n 1. v \\<in> set Q_hit_post \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v \\<in> set Q_hit", "show False"], ["proof (prove)\nusing this:\n  v \\<in> set Q_hit\n\ngoal (1 subgoal):\n 1. False", "using Q.paths_disjoint[of Q_hit xs] xs Q_hit(1) v"], ["proof (prove)\nusing this:\n  v \\<in> set Q_hit\n  \\<lbrakk>Q_hit \\<in> Q; xs \\<in> Q; Q_hit \\<noteq> xs; ?v \\<in> set Q_hit;\n   ?v \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> ?v = v0 \\<or> ?v = v1\n  xs \\<in> Q - {Q_hit}\n  Q_hit \\<in> Q\n  v \\<in> set xs\n  v \\<in> set Q_hit'\n  v \\<noteq> v0\n  v \\<noteq> v1\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<notin> set Q_hit_post\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "ultimately"], ["proof (chain)\npicking this:\n  v \\<notin> set P_k_pre\n  v \\<noteq> y\n  v \\<notin> set Q_hit_post", "have False"], ["proof (prove)\nusing this:\n  v \\<notin> set P_k_pre\n  v \\<noteq> y\n  v \\<notin> set Q_hit_post\n\ngoal (1 subgoal):\n 1. False", "using v(2)"], ["proof (prove)\nusing this:\n  v \\<notin> set P_k_pre\n  v \\<noteq> y\n  v \\<notin> set Q_hit_post\n  v \\<in> set Q_hit'\n\ngoal (1 subgoal):\n 1. False", "unfolding Q_hit'_def"], ["proof (prove)\nusing this:\n  v \\<notin> set P_k_pre\n  v \\<noteq> y\n  v \\<notin> set Q_hit_post\n  v \\<in> set (P_k_pre @ y # Q_hit_post)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xs2 \\<in> Q - {Q_hit}; ?v2 \\<in> set ?xs2; ?v2 \\<in> set Q_hit';\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xs2 \\<in> Q - {Q_hit}; ?v2 \\<in> set ?xs2; ?v2 \\<in> set Q_hit';\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs2 \\<in> Q - {Q_hit}; ?v2 \\<in> set ?xs2; ?v2 \\<in> set Q_hit';\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "using Q_reduced.DisjointPaths_extend Q_hit'_v0_v1_H_x"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs2 \\<in> Q - {Q_hit}; ?v2 \\<in> set ?xs2; ?v2 \\<in> set Q_hit';\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>v0 \\<leadsto>?P\\<leadsto>\\<^bsub>H_x\\<^esub> v1;\n   \\<And>xs v.\n      \\<lbrakk>xs \\<in> Q - {Q_hit}; xs \\<noteq> ?P; v \\<in> set xs;\n       v \\<in> set ?P\\<rbrakk>\n      \\<Longrightarrow> v = v0 \\<or> v = v1\\<rbrakk>\n  \\<Longrightarrow> DisjointPaths H_x v0 v1 (insert ?P (Q - {Q_hit}))\n  v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 Q'", "unfolding Q'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs2 \\<in> Q - {Q_hit}; ?v2 \\<in> set ?xs2; ?v2 \\<in> set Q_hit';\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>v0 \\<leadsto>?P\\<leadsto>\\<^bsub>H_x\\<^esub> v1;\n   \\<And>xs v.\n      \\<lbrakk>xs \\<in> Q - {Q_hit}; xs \\<noteq> ?P; v \\<in> set xs;\n       v \\<in> set ?P\\<rbrakk>\n      \\<Longrightarrow> v = v0 \\<or> v = v1\\<rbrakk>\n  \\<Longrightarrow> DisjointPaths H_x v0 v1 (insert ?P (Q - {Q_hit}))\n  v0 \\<leadsto>Q_hit'\\<leadsto>\\<^bsub>H_x\\<^esub> v1\n\ngoal (1 subgoal):\n 1. DisjointPaths H_x v0 v1 (insert Q_hit' (Q - {Q_hit}))", "by blast"], ["proof (state)\nthis:\n  DisjointPaths H_x v0 v1 Q'\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma card_Q': \"card Q' = sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card Q' = sep_size", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. card Q' = sep_size", "have \"Suc (card (Q - {Q_hit})) = card Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card (Q - {Q_hit})) = card Q", "using Q_hit(1) Q.finite_paths"], ["proof (prove)\nusing this:\n  Q_hit \\<in> Q\n  finite Q\n\ngoal (1 subgoal):\n 1. Suc (card (Q - {Q_hit})) = card Q", "by (meson card_Suc_Diff1)"], ["proof (state)\nthis:\n  Suc (card (Q - {Q_hit})) = card Q\n\ngoal (1 subgoal):\n 1. card Q' = sep_size", "then"], ["proof (chain)\npicking this:\n  Suc (card (Q - {Q_hit})) = card Q", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc (card (Q - {Q_hit})) = card Q\n\ngoal (1 subgoal):\n 1. card Q' = sep_size", "using Q(2) Q.finite_paths Q_hit'_notin_Q_minus_Q_hit"], ["proof (prove)\nusing this:\n  Suc (card (Q - {Q_hit})) = card Q\n  card Q = sep_size\n  finite Q\n  Q_hit' \\<notin> Q - {Q_hit}\n\ngoal (1 subgoal):\n 1. card Q' = sep_size", "unfolding Q'_def"], ["proof (prove)\nusing this:\n  Suc (card (Q - {Q_hit})) = card Q\n  card Q = sep_size\n  finite Q\n  Q_hit' \\<notin> Q - {Q_hit}\n\ngoal (1 subgoal):\n 1. card (insert Q_hit' (Q - {Q_hit})) = sep_size", "by simp"], ["proof (state)\nthis:\n  card Q' = sep_size\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contradiction': \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using Q_weight_smaller DisjointPaths_Q' card_Q' Q_min"], ["proof (prove)\nusing this:\n  Q_weight Q' < Q_weight Q\n  DisjointPaths H_x v0 v1 Q'\n  card Q' = sep_size\n  DisjointPaths H_x v0 v1 ?Q' \\<and> card ?Q' = sep_size \\<Longrightarrow>\n  Q_weight Q \\<le> Q_weight ?Q'\n\ngoal (1 subgoal):\n 1. False", "using Suc_leI not_less_eq_eq"], ["proof (prove)\nusing this:\n  Q_weight Q' < Q_weight Q\n  DisjointPaths H_x v0 v1 Q'\n  card Q' = sep_size\n  DisjointPaths H_x v0 v1 ?Q' \\<and> card ?Q' = sep_size \\<Longrightarrow>\n  Q_weight Q \\<le> Q_weight ?Q'\n  ?m < ?n \\<Longrightarrow> Suc ?m \\<le> ?n\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["", "end \\<comment> \\<open>anonymous context\\<close>"], ["", "corollary contradiction: \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using Q_hit_exists contradiction'"], ["proof (prove)\nusing this:\n  (\\<And>Q_hit Q_hit_pre Q_hit_post.\n      \\<lbrakk>Q_hit \\<in> Q; y \\<in> set Q_hit;\n       Q_hit = Q_hit_pre @ y # Q_hit_post\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>?Q_hit \\<in> Q; y \\<in> set ?Q_hit;\n   ?Q_hit = ?Q_hit_pre @ y # ?Q_hit_post\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["", "end \\<comment> \\<open>locale @{locale ProofStepInduct_y_neq_new_last}\\<close>"], ["", "end"]]}