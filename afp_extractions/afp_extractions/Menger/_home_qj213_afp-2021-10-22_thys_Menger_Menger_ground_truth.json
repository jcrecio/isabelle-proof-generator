{"file_name": "/home/qj213/afp-2021-10-22/thys/Menger/Menger.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Menger", "problem_names": ["lemma one_more_paths_exists_trivial:\n  \"new_last = v1 \\<Longrightarrow> \\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\"", "lemma one_more_paths_exists_nontrivial:\n  assumes \"new_last \\<noteq> v1\"\n  shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\"", "lemma (in ProofStepInduct) one_more_paths_exists:\n  \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\"", "theorem (in v0_v1_Digraph) menger:\n  assumes \"\\<And>S. Separation G v0 v1 S \\<Longrightarrow> card S \\<ge> n\"\n  shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = n\"", "theorem (in v0_v1_Digraph) menger_trivial:\n  assumes \"DisjointPaths G v0 v1 paths\" \"card paths = n\"\n  shows \"\\<And>S. Separation G v0 v1 S \\<Longrightarrow> card S \\<ge> n\"", "theorem (in Digraph) menger:\n  fixes v0 v1 :: 'a and n :: nat\n  assumes v0_V: \"v0 \\<in> V\"\n      and v1_V: \"v1 \\<in> V\"\n      and v0_nonadj_v1: \"\\<not>v0\\<rightarrow>v1\"\n      and v0_neq_v1: \"v0 \\<noteq> v1\"\n      and no_small_separators: \"\\<And>S.\n        \\<lbrakk> S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S; \\<And>xs. v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow> set xs \\<inter> S \\<noteq> {} \\<rbrakk> \\<Longrightarrow> card S \\<ge> n\"\n  shows \"\\<exists>paths. card paths = n \\<and> (\\<forall>xs \\<in> paths.\n    v0 \\<leadsto>xs\\<leadsto> v1 \\<and> (\\<forall>ys \\<in> paths - {xs}. (\\<forall>v \\<in> set xs \\<inter> set ys. v = v0 \\<or> v = v1)))\"", "theorem (in Digraph) menger_trivial:\n  fixes v0 v1 :: 'a and n :: nat\n  assumes v0_V: \"v0 \\<in> V\"\n      and v1_V: \"v1 \\<in> V\"\n      and v0_nonadj_v1: \"\\<not>v0\\<rightarrow>v1\"\n      and v0_neq_v1: \"v0 \\<noteq> v1\"\n      and n_paths: \"card paths = n\"\n      and paths_disjoint: \"\\<forall>xs \\<in> paths.\n        v0 \\<leadsto>xs\\<leadsto> v1 \\<and> (\\<forall>ys \\<in> paths - {xs}. (\\<forall>v \\<in> set xs \\<inter> set ys. v = v0 \\<or> v = v1))\"\n  shows \"\\<And>S. \\<lbrakk> S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S; \\<And>xs. v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow> set xs \\<inter> S \\<noteq> {} \\<rbrakk> \\<Longrightarrow> card S \\<ge> n\""], "translations": [["", "lemma one_more_paths_exists_trivial:\n  \"new_last = v1 \\<Longrightarrow> \\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_last = v1 \\<Longrightarrow>\n    \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "using P_new_solves_if_disjoint paths_sep_size"], ["proof (prove)\nusing this:\n  new_last = v1 \\<Longrightarrow>\n  \\<exists>paths'.\n     DisjointPaths G v0 v1 paths' \\<and> card paths' = Suc (card paths)\n  card paths = sep_size\n\ngoal (1 subgoal):\n 1. new_last = v1 \\<Longrightarrow>\n    \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["", "lemma one_more_paths_exists_nontrivial:\n  assumes \"new_last \\<noteq> v1\"\n  shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "interpret ProofStepInduct_NonTrivial G v0 v1 paths P_new sep_size"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProofStepInduct_NonTrivial G v0 v1 paths P_new sep_size", "using assms new_last_def"], ["proof (prove)\nusing this:\n  new_last \\<noteq> v1\n  new_last \\<equiv> last P_new\n\ngoal (1 subgoal):\n 1. ProofStepInduct_NonTrivial G v0 v1 paths P_new sep_size", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "obtain P_k_pre y P_k_post where\n    \"ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y P_k_post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P_k_pre y P_k_post.\n        ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size\n         P_k_pre y P_k_post \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ProofStepInduct_NonTrivial_P_k_pre_exists"], ["proof (prove)\nusing this:\n  \\<exists>P_k_pre y P_k_post.\n     ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre\n      y P_k_post\n\ngoal (1 subgoal):\n 1. (\\<And>P_k_pre y P_k_post.\n        ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size\n         P_k_pre y P_k_post \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y\n   P_k_post\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y\n   P_k_post", "interpret ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y P_k_post"], ["proof (prove)\nusing this:\n  ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre y\n   P_k_post\n\ngoal (1 subgoal):\n 1. ProofStepInduct_NonTrivial_P_k_pre G v0 v1 paths P_new sep_size P_k_pre\n     y P_k_post", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "assume \"y \\<noteq> v1\" \"y = new_last\""], ["proof (state)\nthis:\n  y \\<noteq> v1\n  y = new_last\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> v1\n  y = new_last", "interpret ProofStepInduct_y_eq_new_last G v0 v1 paths P_new sep_size P_k_pre y P_k_post"], ["proof (prove)\nusing this:\n  y \\<noteq> v1\n  y = new_last\n\ngoal (1 subgoal):\n 1. ProofStepInduct_y_eq_new_last G v0 v1 paths P_new sep_size P_k_pre y\n     P_k_post", "using optimal_paths[folded H_def]"], ["proof (prove)\nusing this:\n  y \\<noteq> v1\n  y = new_last\n  ProofStepInduct G v0 v1 ?paths' ?P_new' sep_size \\<Longrightarrow>\n  H.distance (last P_new) v1 \\<le> H.distance (last ?P_new') v1\n\ngoal (1 subgoal):\n 1. ProofStepInduct_y_eq_new_last G v0 v1 paths P_new sep_size P_k_pre y\n     P_k_post", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "using with_optimal_paths_solves"], ["proof (prove)\nusing this:\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["proof (state)\nthis:\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "}"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<noteq> v1; y = new_last\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<noteq> v1; y = new_last\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "{"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<noteq> v1; y = new_last\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "assume \"y \\<noteq> v1\" \"y \\<noteq> new_last\""], ["proof (state)\nthis:\n  y \\<noteq> v1\n  y \\<noteq> new_last\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> v1\n  y \\<noteq> new_last", "interpret ProofStepInduct_y_neq_new_last G v0 v1 paths P_new sep_size P_k_pre y P_k_post"], ["proof (prove)\nusing this:\n  y \\<noteq> v1\n  y \\<noteq> new_last\n\ngoal (1 subgoal):\n 1. ProofStepInduct_y_neq_new_last G v0 v1 paths P_new sep_size P_k_pre y\n     P_k_post", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "using contradiction"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["proof (state)\nthis:\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "}"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<noteq> v1; y \\<noteq> new_last\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>y \\<noteq> v1; y = new_last\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size\n  \\<lbrakk>y \\<noteq> v1; y \\<noteq> new_last\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<noteq> v1; y = new_last\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size\n  \\<lbrakk>y \\<noteq> v1; y \\<noteq> new_last\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "using y_eq_v1_solves"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<noteq> v1; y = new_last\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size\n  \\<lbrakk>y \\<noteq> v1; y \\<noteq> new_last\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths G v0 v1 paths \\<and>\n                       card paths = Suc sep_size\n  y = v1 \\<Longrightarrow>\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["proof (state)\nthis:\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary one_more_paths_exists:\n  shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "using one_more_paths_exists_trivial one_more_paths_exists_nontrivial"], ["proof (prove)\nusing this:\n  new_last = v1 \\<Longrightarrow>\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n  new_last \\<noteq> v1 \\<Longrightarrow>\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["", "end"], ["", "lemma (in ProofStepInduct) one_more_paths_exists:\n  \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "define paths_weight where \"paths_weight \\<equiv>\n    \\<lambda>(paths' :: 'a Walk set, P_new'). Digraph.distance (remove_vertex v0) (last P_new') v1\""], ["proof (state)\nthis:\n  paths_weight \\<equiv>\n  \\<lambda>(paths', P_new').\n     Digraph.distance (remove_vertex v0) (last P_new') v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "define paths_good where \"paths_good \\<equiv>\n    \\<lambda>(paths', P_new'). ProofStepInduct G v0 v1 paths' P_new' sep_size\""], ["proof (state)\nthis:\n  paths_good \\<equiv>\n  \\<lambda>(paths', P_new'). ProofStepInduct G v0 v1 paths' P_new' sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have \"\\<exists>paths' P_new'. paths_good (paths', P_new')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths' P_new'. paths_good (paths', P_new')", "unfolding paths_good_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths' P_new'.\n       case (paths', P_new') of\n       (paths', P_new') \\<Rightarrow>\n         ProofStepInduct G v0 v1 paths' P_new' sep_size", "using ProofStepInduct_axioms"], ["proof (prove)\nusing this:\n  ProofStepInduct G v0 v1 paths P_new sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths' P_new'.\n       case (paths', P_new') of\n       (paths', P_new') \\<Rightarrow>\n         ProofStepInduct G v0 v1 paths' P_new' sep_size", "by auto"], ["proof (state)\nthis:\n  \\<exists>paths' P_new'. paths_good (paths', P_new')\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  \\<exists>paths' P_new'. paths_good (paths', P_new')", "obtain P' where\n    P': \"paths_good P'\" \"\\<And>P''. paths_good P'' \\<Longrightarrow> paths_weight P' \\<le> paths_weight P''\""], ["proof (prove)\nusing this:\n  \\<exists>paths' P_new'. paths_good (paths', P_new')\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>paths_good P';\n         \\<And>P''.\n            paths_good P'' \\<Longrightarrow>\n            paths_weight P' \\<le> paths_weight P''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using arg_min_ex[of paths_good paths_weight]"], ["proof (prove)\nusing this:\n  \\<exists>paths' P_new'. paths_good (paths', P_new')\n  \\<lbrakk>\\<exists>x. paths_good x;\n   \\<And>x.\n      \\<lbrakk>paths_good x;\n       \\<And>y.\n          paths_good y \\<Longrightarrow>\n          paths_weight x \\<le> paths_weight y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>paths_good P';\n         \\<And>P''.\n            paths_good P'' \\<Longrightarrow>\n            paths_weight P' \\<le> paths_weight P''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  paths_good P'\n  paths_good ?P'' \\<Longrightarrow> paths_weight P' \\<le> paths_weight ?P''\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  paths_good P'\n  paths_good ?P'' \\<Longrightarrow> paths_weight P' \\<le> paths_weight ?P''", "obtain paths' P_new' where P'_decomp: \"P' = (paths', P_new')\""], ["proof (prove)\nusing this:\n  paths_good P'\n  paths_good ?P'' \\<Longrightarrow> paths_weight P' \\<le> paths_weight ?P''\n\ngoal (1 subgoal):\n 1. (\\<And>paths' P_new'.\n        P' = (paths', P_new') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  P' = (paths', P_new')\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have optimal_paths_good: \"ProofStepInduct G v0 v1 paths' P_new' sep_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProofStepInduct G v0 v1 paths' P_new' sep_size", "using P'(1) P'_decomp"], ["proof (prove)\nusing this:\n  paths_good P'\n  P' = (paths', P_new')\n\ngoal (1 subgoal):\n 1. ProofStepInduct G v0 v1 paths' P_new' sep_size", "unfolding paths_good_def"], ["proof (prove)\nusing this:\n  case P' of\n  (paths', P_new') \\<Rightarrow>\n    ProofStepInduct G v0 v1 paths' P_new' sep_size\n  P' = (paths', P_new')\n\ngoal (1 subgoal):\n 1. ProofStepInduct G v0 v1 paths' P_new' sep_size", "by auto"], ["proof (state)\nthis:\n  ProofStepInduct G v0 v1 paths' P_new' sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "have \"\\<And>paths'' P_new''. paths_good (paths'', P_new'')\n    \\<Longrightarrow> paths_weight P' \\<le> paths_weight (paths'', P_new'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>paths'' P_new''.\n       paths_good (paths'', P_new'') \\<Longrightarrow>\n       paths_weight P' \\<le> paths_weight (paths'', P_new'')", "by (simp add: P'(2))"], ["proof (state)\nthis:\n  paths_good (?paths'', ?P_new'') \\<Longrightarrow>\n  paths_weight P' \\<le> paths_weight (?paths'', ?P_new'')\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "then"], ["proof (chain)\npicking this:\n  paths_good (?paths'', ?P_new'') \\<Longrightarrow>\n  paths_weight P' \\<le> paths_weight (?paths'', ?P_new'')", "have optimal_paths_min: \"\\<And>paths'' P_new''. ProofStepInduct G v0 v1 paths'' P_new'' sep_size\n    \\<Longrightarrow> Digraph.distance (remove_vertex v0) (last P_new') v1\n        \\<le> Digraph.distance (remove_vertex v0) (last P_new'') v1\""], ["proof (prove)\nusing this:\n  paths_good (?paths'', ?P_new'') \\<Longrightarrow>\n  paths_weight P' \\<le> paths_weight (?paths'', ?P_new'')\n\ngoal (1 subgoal):\n 1. \\<And>paths'' P_new''.\n       ProofStepInduct G v0 v1 paths'' P_new'' sep_size \\<Longrightarrow>\n       Digraph.distance (remove_vertex v0) (last P_new') v1\n       \\<le> Digraph.distance (remove_vertex v0) (last P_new'') v1", "unfolding paths_good_def paths_weight_def"], ["proof (prove)\nusing this:\n  case (?paths'', ?P_new'') of\n  (paths', P_new') \\<Rightarrow>\n    ProofStepInduct G v0 v1 paths' P_new' sep_size \\<Longrightarrow>\n  (case P' of\n   (paths', P_new') \\<Rightarrow>\n     Digraph.distance (remove_vertex v0) (last P_new') v1)\n  \\<le> (case (?paths'', ?P_new'') of\n         (paths', P_new') \\<Rightarrow>\n           Digraph.distance (remove_vertex v0) (last P_new') v1)\n\ngoal (1 subgoal):\n 1. \\<And>paths'' P_new''.\n       ProofStepInduct G v0 v1 paths'' P_new'' sep_size \\<Longrightarrow>\n       Digraph.distance (remove_vertex v0) (last P_new') v1\n       \\<le> Digraph.distance (remove_vertex v0) (last P_new'') v1", "by (simp add: P'_decomp)"], ["proof (state)\nthis:\n  ProofStepInduct G v0 v1 ?paths'' ?P_new'' sep_size \\<Longrightarrow>\n  Digraph.distance (remove_vertex v0) (last P_new') v1\n  \\<le> Digraph.distance (remove_vertex v0) (last ?P_new'') v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "interpret G: ProofStepInductOptimalPaths G v0 v1 paths' P_new' sep_size"], ["proof (prove)\ngoal (1 subgoal):\n 1. ProofStepInductOptimalPaths G v0 v1 paths' P_new' sep_size", "using optimal_paths_good optimal_paths_min"], ["proof (prove)\nusing this:\n  ProofStepInduct G v0 v1 paths' P_new' sep_size\n  ProofStepInduct G v0 v1 ?paths'' ?P_new'' sep_size \\<Longrightarrow>\n  Digraph.distance (remove_vertex v0) (last P_new') v1\n  \\<le> Digraph.distance (remove_vertex v0) (last ?P_new'') v1\n\ngoal (1 subgoal):\n 1. ProofStepInductOptimalPaths G v0 v1 paths' P_new' sep_size", "by (simp add: ProofStepInductOptimalPaths.intro ProofStepInductOptimalPaths_axioms.intro)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "using G.one_more_paths_exists"], ["proof (prove)\nusing this:\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size", "by blast"], ["proof (state)\nthis:\n  \\<exists>paths.\n     DisjointPaths G v0 v1 paths \\<and> card paths = Suc sep_size\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Menger's Theorem\\<close>"], ["", "theorem (in v0_v1_Digraph) menger:\n  assumes \"\\<And>S. Separation G v0 v1 S \\<Longrightarrow> card S \\<ge> n\"\n  shows \"\\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = n", "using assms v0_v1_Digraph_axioms"], ["proof (prove)\nusing this:\n  Separation G v0 v1 ?S \\<Longrightarrow> n \\<le> card ?S\n  v0_v1_Digraph G v0 v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = n", "proof (induct n arbitrary: G)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>\\<And>S.\n                   Separation G v0 v1 S \\<Longrightarrow> 0 \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = 0\n 2. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "case (0 G)"], ["proof (state)\nthis:\n  Separation G v0 v1 ?S \\<Longrightarrow> 0 \\<le> card ?S\n  v0_v1_Digraph G v0 v1\n\ngoal (2 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>\\<And>S.\n                   Separation G v0 v1 S \\<Longrightarrow> 0 \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = 0\n 2. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "then"], ["proof (chain)\npicking this:\n  Separation G v0 v1 ?S \\<Longrightarrow> 0 \\<le> card ?S\n  v0_v1_Digraph G v0 v1", "show ?case"], ["proof (prove)\nusing this:\n  Separation G v0 v1 ?S \\<Longrightarrow> 0 \\<le> card ?S\n  v0_v1_Digraph G v0 v1\n\ngoal (1 subgoal):\n 1. \\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = 0", "using v0_v1_Digraph.DisjointPaths_empty[of G] card.empty"], ["proof (prove)\nusing this:\n  Separation G v0 v1 ?S \\<Longrightarrow> 0 \\<le> card ?S\n  v0_v1_Digraph G v0 v1\n  v0_v1_Digraph G ?v0.0 ?v1.0 \\<Longrightarrow>\n  DisjointPaths G ?v0.0 ?v1.0 {}\n  card {} = 0\n\ngoal (1 subgoal):\n 1. \\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = 0\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "case (Suc n G)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>S. Separation ?G v0 v1 S \\<Longrightarrow> n \\<le> card S;\n   v0_v1_Digraph ?G v0 v1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths ?G v0 v1 paths \\<and> card paths = n\n  Separation G v0 v1 ?S \\<Longrightarrow> Suc n \\<le> card ?S\n  v0_v1_Digraph G v0 v1\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "interpret G: v0_v1_Digraph G v0 v1"], ["proof (prove)\ngoal (1 subgoal):\n 1. v0_v1_Digraph G v0 v1", "using Suc(3)"], ["proof (prove)\nusing this:\n  v0_v1_Digraph G v0 v1\n\ngoal (1 subgoal):\n 1. v0_v1_Digraph G v0 v1", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "have \"\\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "using Suc.prems Suc_leD"], ["proof (prove)\nusing this:\n  Separation G v0 v1 ?S \\<Longrightarrow> Suc n \\<le> card ?S\n  v0_v1_Digraph G v0 v1\n  Suc ?m \\<le> ?n \\<Longrightarrow> ?m \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "by blast"], ["proof (state)\nthis:\n  Separation G v0 v1 ?S \\<Longrightarrow> n \\<le> card ?S\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "then"], ["proof (chain)\npicking this:\n  Separation G v0 v1 ?S \\<Longrightarrow> n \\<le> card ?S", "obtain paths where P: \"DisjointPaths G v0 v1 paths\" \"card paths = n\""], ["proof (prove)\nusing this:\n  Separation G v0 v1 ?S \\<Longrightarrow> n \\<le> card ?S\n\ngoal (1 subgoal):\n 1. (\\<And>paths.\n        \\<lbrakk>DisjointPaths G v0 v1 paths; card paths = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc(1,3)"], ["proof (prove)\nusing this:\n  Separation G v0 v1 ?S \\<Longrightarrow> n \\<le> card ?S\n  \\<lbrakk>\\<And>S. Separation ?G v0 v1 S \\<Longrightarrow> n \\<le> card S;\n   v0_v1_Digraph ?G v0 v1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>paths.\n                       DisjointPaths ?G v0 v1 paths \\<and> card paths = n\n  v0_v1_Digraph G v0 v1\n\ngoal (1 subgoal):\n 1. (\\<And>paths.\n        \\<lbrakk>DisjointPaths G v0 v1 paths; card paths = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  DisjointPaths G v0 v1 paths\n  card paths = n\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "interpret G: DisjointPaths G v0 v1 paths"], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 paths", "using P(1)"], ["proof (prove)\nusing this:\n  DisjointPaths G v0 v1 paths\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 paths", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "obtain P_new where\n    P_new: \"v0 \\<leadsto>P_new\\<leadsto>\\<^bsub>G\\<^esub> v1\" \"set P_new \\<inter> G.second_vertices = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P_new.\n        \\<lbrakk>v0 \\<leadsto>P_new\\<leadsto>\\<^bsub>G\\<^esub> v1;\n         set P_new \\<inter> G.second_vertices = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using G.disjoint_paths_new_path P(2) Suc.prems(1)"], ["proof (prove)\nusing this:\n  (\\<And>S.\n      Separation G v0 v1 S \\<Longrightarrow>\n      Suc (card paths) \\<le> card S) \\<Longrightarrow>\n  \\<exists>P_new.\n     v0 \\<leadsto>P_new\\<leadsto>\\<^bsub>G\\<^esub> v1 \\<and>\n     set P_new \\<inter> G.second_vertices = {}\n  card paths = n\n  Separation G v0 v1 ?S \\<Longrightarrow> Suc n \\<le> card ?S\n\ngoal (1 subgoal):\n 1. (\\<And>P_new.\n        \\<lbrakk>v0 \\<leadsto>P_new\\<leadsto>\\<^bsub>G\\<^esub> v1;\n         set P_new \\<inter> G.second_vertices = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v0 \\<leadsto>P_new\\<leadsto>\\<^bsub>G\\<^esub> v1\n  set P_new \\<inter> G.second_vertices = {}\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "have P_new_new: \"P_new \\<notin> paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_new \\<notin> paths", "by (metis G.paths_tl_notnil G.second_vertex_def G.second_vertices_def G.path_from_toE IntI\n        P_new empty_iff image_eqI list.set_sel(1) list.set_sel(2))"], ["proof (state)\nthis:\n  P_new \\<notin> paths\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "have \"G.hitting_paths v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G.hitting_paths v1", "unfolding G.hitting_paths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v0 \\<and>\n    ((\\<exists>xs\\<in>paths. v1 \\<in> set xs) \\<or> v1 = v1)", "using v0_neq_v1"], ["proof (prove)\nusing this:\n  v0 \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v0 \\<and>\n    ((\\<exists>xs\\<in>paths. v1 \\<in> set xs) \\<or> v1 = v1)", "by blast"], ["proof (state)\nthis:\n  G.hitting_paths v1\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "then"], ["proof (chain)\npicking this:\n  G.hitting_paths v1", "have \"\\<exists>x \\<in> set P_new. G.hitting_paths x\""], ["proof (prove)\nusing this:\n  G.hitting_paths v1\n\ngoal (1 subgoal):\n 1. Bex (set P_new) G.hitting_paths", "using P_new(1)"], ["proof (prove)\nusing this:\n  G.hitting_paths v1\n  v0 \\<leadsto>P_new\\<leadsto>\\<^bsub>G\\<^esub> v1\n\ngoal (1 subgoal):\n 1. Bex (set P_new) G.hitting_paths", "by fastforce"], ["proof (state)\nthis:\n  Bex (set P_new) G.hitting_paths\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "then"], ["proof (chain)\npicking this:\n  Bex (set P_new) G.hitting_paths", "obtain new_pre x new_post where\n    P_new_decomp: \"P_new = new_pre @ x # new_post\"\n    and x: \"G.hitting_paths x\"\n           \"\\<And>y. y \\<in> set new_pre \\<Longrightarrow> \\<not>G.hitting_paths y\""], ["proof (prove)\nusing this:\n  Bex (set P_new) G.hitting_paths\n\ngoal (1 subgoal):\n 1. (\\<And>new_pre x new_post.\n        \\<lbrakk>P_new = new_pre @ x # new_post; G.hitting_paths x;\n         \\<And>y.\n            y \\<in> set new_pre \\<Longrightarrow>\n            \\<not> G.hitting_paths y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis split_list_first_prop)"], ["proof (state)\nthis:\n  P_new = new_pre @ x # new_post\n  G.hitting_paths x\n  ?y \\<in> set new_pre \\<Longrightarrow> \\<not> G.hitting_paths ?y\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "have 1: \"DisjointPathsPlusOne G v0 v1 paths (new_pre @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPathsPlusOne G v0 v1 paths (new_pre @ [x])", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. v0 \\<leadsto>(new_pre @\n                  [x])\\<leadsto>\\<^bsub>G\\<^esub> last (new_pre @ [x])\n 2. tl (new_pre @ [x]) \\<noteq> []\n 3. hd (tl (new_pre @ [x])) \\<notin> G.second_vertices\n 4. G.hitting_paths (last (new_pre @ [x]))\n 5. \\<And>v.\n       v \\<in> set (butlast (new_pre @ [x])) \\<Longrightarrow>\n       \\<not> G.hitting_paths v", "show \"v0 \\<leadsto>(new_pre @ [x])\\<leadsto>\\<^bsub>G\\<^esub> last (new_pre @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(new_pre @\n                  [x])\\<leadsto>\\<^bsub>G\\<^esub> last (new_pre @ [x])", "using P_new(1)"], ["proof (prove)\nusing this:\n  v0 \\<leadsto>P_new\\<leadsto>\\<^bsub>G\\<^esub> v1\n\ngoal (1 subgoal):\n 1. v0 \\<leadsto>(new_pre @\n                  [x])\\<leadsto>\\<^bsub>G\\<^esub> last (new_pre @ [x])", "by (metis G.path_decomp' P_new_decomp append_is_Nil_conv hd_append2 list.distinct(1)\n          list.sel(1) path_from_to_def self_append_conv2)"], ["proof (state)\nthis:\n  v0 \\<leadsto>(new_pre @\n                [x])\\<leadsto>\\<^bsub>G\\<^esub> last (new_pre @ [x])\n\ngoal (4 subgoals):\n 1. tl (new_pre @ [x]) \\<noteq> []\n 2. hd (tl (new_pre @ [x])) \\<notin> G.second_vertices\n 3. G.hitting_paths (last (new_pre @ [x]))\n 4. \\<And>v.\n       v \\<in> set (butlast (new_pre @ [x])) \\<Longrightarrow>\n       \\<not> G.hitting_paths v", "then"], ["proof (chain)\npicking this:\n  v0 \\<leadsto>(new_pre @\n                [x])\\<leadsto>\\<^bsub>G\\<^esub> last (new_pre @ [x])", "show \"tl (new_pre @ [x]) \\<noteq> []\""], ["proof (prove)\nusing this:\n  v0 \\<leadsto>(new_pre @\n                [x])\\<leadsto>\\<^bsub>G\\<^esub> last (new_pre @ [x])\n\ngoal (1 subgoal):\n 1. tl (new_pre @ [x]) \\<noteq> []", "by (metis DisjointPaths.hitting_paths_def G.DisjointPaths_axioms G.path_from_toE\n          butlast.simps(1) butlast_snoc list.distinct(1) list.sel(1) self_append_conv2\n          tl_append2 x(1))"], ["proof (state)\nthis:\n  tl (new_pre @ [x]) \\<noteq> []\n\ngoal (3 subgoals):\n 1. hd (tl (new_pre @ [x])) \\<notin> G.second_vertices\n 2. G.hitting_paths (last (new_pre @ [x]))\n 3. \\<And>v.\n       v \\<in> set (butlast (new_pre @ [x])) \\<Longrightarrow>\n       \\<not> G.hitting_paths v", "have \"new_pre \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_pre \\<noteq> []", "using G.hitting_paths_def P_new(1) P_new_decomp x(1)"], ["proof (prove)\nusing this:\n  G.hitting_paths \\<equiv>\n  \\<lambda>x.\n     x \\<noteq> v0 \\<and>\n     ((\\<exists>xs\\<in>paths. x \\<in> set xs) \\<or> x = v1)\n  v0 \\<leadsto>P_new\\<leadsto>\\<^bsub>G\\<^esub> v1\n  P_new = new_pre @ x # new_post\n  G.hitting_paths x\n\ngoal (1 subgoal):\n 1. new_pre \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  new_pre \\<noteq> []\n\ngoal (3 subgoals):\n 1. hd (tl (new_pre @ [x])) \\<notin> G.second_vertices\n 2. G.hitting_paths (last (new_pre @ [x]))\n 3. \\<And>v.\n       v \\<in> set (butlast (new_pre @ [x])) \\<Longrightarrow>\n       \\<not> G.hitting_paths v", "then"], ["proof (chain)\npicking this:\n  new_pre \\<noteq> []", "have \"hd (tl (new_pre @ [x])) = hd (tl P_new)\""], ["proof (prove)\nusing this:\n  new_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (tl (new_pre @ [x])) = hd (tl P_new)", "by (simp add: P_new_decomp hd_append)"], ["proof (state)\nthis:\n  hd (tl (new_pre @ [x])) = hd (tl P_new)\n\ngoal (3 subgoals):\n 1. hd (tl (new_pre @ [x])) \\<notin> G.second_vertices\n 2. G.hitting_paths (last (new_pre @ [x]))\n 3. \\<And>v.\n       v \\<in> set (butlast (new_pre @ [x])) \\<Longrightarrow>\n       \\<not> G.hitting_paths v", "then"], ["proof (chain)\npicking this:\n  hd (tl (new_pre @ [x])) = hd (tl P_new)", "show \"hd (tl (new_pre @ [x])) \\<notin> G.second_vertices\""], ["proof (prove)\nusing this:\n  hd (tl (new_pre @ [x])) = hd (tl P_new)\n\ngoal (1 subgoal):\n 1. hd (tl (new_pre @ [x])) \\<notin> G.second_vertices", "by (metis P_new(2) P_new_decomp \\<open>new_pre \\<noteq> []\\<close> append_is_Nil_conv disjoint_iff_not_equal\n          list.distinct(1) list.set_sel(1) list.set_sel(2) tl_append2)"], ["proof (state)\nthis:\n  hd (tl (new_pre @ [x])) \\<notin> G.second_vertices\n\ngoal (2 subgoals):\n 1. G.hitting_paths (last (new_pre @ [x]))\n 2. \\<And>v.\n       v \\<in> set (butlast (new_pre @ [x])) \\<Longrightarrow>\n       \\<not> G.hitting_paths v", "show \"G.hitting_paths (last (new_pre @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G.hitting_paths (last (new_pre @ [x]))", "using x(1)"], ["proof (prove)\nusing this:\n  G.hitting_paths x\n\ngoal (1 subgoal):\n 1. G.hitting_paths (last (new_pre @ [x]))", "by auto"], ["proof (state)\nthis:\n  G.hitting_paths (last (new_pre @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (butlast (new_pre @ [x])) \\<Longrightarrow>\n       \\<not> G.hitting_paths v", "show \"\\<And>v. v \\<in> set (butlast (new_pre @ [x])) \\<Longrightarrow> \\<not>G.hitting_paths v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (butlast (new_pre @ [x])) \\<Longrightarrow>\n       \\<not> G.hitting_paths v", "by (simp add: x(2))"], ["proof (state)\nthis:\n  ?v \\<in> set (butlast (new_pre @ [x])) \\<Longrightarrow>\n  \\<not> G.hitting_paths ?v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DisjointPathsPlusOne G v0 v1 paths (new_pre @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "have 2: \"NoSmallSeparationsInduct G v0 v1 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NoSmallSeparationsInduct G v0 v1 n", "by (simp add: G.v0_v1_Digraph_axioms NoSmallSeparationsInduct.intro\n        NoSmallSeparationsInduct_axioms_def Suc.hyps Suc.prems(1))"], ["proof (state)\nthis:\n  NoSmallSeparationsInduct G v0 v1 n\n\ngoal (1 subgoal):\n 1. \\<And>n G.\n       \\<lbrakk>\\<And>G.\n                   \\<lbrakk>\\<And>S.\n                               Separation G v0 v1 S \\<Longrightarrow>\n                               n \\<le> card S;\n                    v0_v1_Digraph G v0 v1\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>paths.\n  DisjointPaths G v0 v1 paths \\<and> card paths = n;\n        \\<And>S. Separation G v0 v1 S \\<Longrightarrow> Suc n \\<le> card S;\n        v0_v1_Digraph G v0 v1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>paths.\n                            DisjointPaths G v0 v1 paths \\<and>\n                            card paths = Suc n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc n", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>paths.\n       DisjointPaths G v0 v1 paths \\<and>\n       card paths = Suc n \\<Longrightarrow>\n    False", "assume not_case: \"\\<not>?case\""], ["proof (state)\nthis:\n  \\<nexists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc n\n\ngoal (1 subgoal):\n 1. \\<nexists>paths.\n       DisjointPaths G v0 v1 paths \\<and>\n       card paths = Suc n \\<Longrightarrow>\n    False", "have \"x \\<noteq> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> v1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "assume \"x = v1\""], ["proof (state)\nthis:\n  x = v1\n\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "define paths' where \"paths' = insert P_new paths\""], ["proof (state)\nthis:\n  paths' = insert P_new paths\n\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  paths' = insert P_new paths\n\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "fix xs v"], ["proof (state)\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "assume *: \"xs \\<in> paths\" \"v \\<in> set xs\" \"v \\<in> set P_new\" \"v \\<noteq> v0\" \"v \\<noteq> v1\""], ["proof (state)\nthis:\n  xs \\<in> paths\n  v \\<in> set xs\n  v \\<in> set P_new\n  v \\<noteq> v0\n  v \\<noteq> v1\n\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "have \"v \\<in> set new_pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set new_pre", "by (metis *(3,5) G.path_from_to_ends G.path_from_toE P_new(1) P_new_decomp\n              \\<open>x = v1\\<close> butlast_snoc set_butlast)"], ["proof (state)\nthis:\n  v \\<in> set new_pre\n\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v \\<in> set new_pre", "have False"], ["proof (prove)\nusing this:\n  v \\<in> set new_pre\n\ngoal (1 subgoal):\n 1. False", "using *(1,2,4) G.hitting_paths_def x(2)"], ["proof (prove)\nusing this:\n  v \\<in> set new_pre\n  xs \\<in> paths\n  v \\<in> set xs\n  v \\<noteq> v0\n  G.hitting_paths \\<equiv>\n  \\<lambda>x.\n     x \\<noteq> v0 \\<and>\n     ((\\<exists>xs\\<in>paths. x \\<in> set xs) \\<or> x = v1)\n  ?y \\<in> set new_pre \\<Longrightarrow> \\<not> G.hitting_paths ?y\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xs2 \\<in> paths; ?v2 \\<in> set ?xs2; ?v2 \\<in> set P_new;\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xs2 \\<in> paths; ?v2 \\<in> set ?xs2; ?v2 \\<in> set P_new;\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False", "have \"DisjointPaths G v0 v1 paths'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs2 \\<in> paths; ?v2 \\<in> set ?xs2; ?v2 \\<in> set P_new;\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 paths'", "unfolding paths'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs2 \\<in> paths; ?v2 \\<in> set ?xs2; ?v2 \\<in> set P_new;\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 (insert P_new paths)", "using G.DisjointPaths_extend P_new(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs2 \\<in> paths; ?v2 \\<in> set ?xs2; ?v2 \\<in> set P_new;\n   ?v2 \\<noteq> v0; ?v2 \\<noteq> v1\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>v0 \\<leadsto>?P\\<leadsto>\\<^bsub>G\\<^esub> v1;\n   \\<And>xs v.\n      \\<lbrakk>xs \\<in> paths; xs \\<noteq> ?P; v \\<in> set xs;\n       v \\<in> set ?P\\<rbrakk>\n      \\<Longrightarrow> v = v0 \\<or> v = v1\\<rbrakk>\n  \\<Longrightarrow> DisjointPaths G v0 v1 (insert ?P paths)\n  v0 \\<leadsto>P_new\\<leadsto>\\<^bsub>G\\<^esub> v1\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 (insert P_new paths)", "by blast"], ["proof (state)\nthis:\n  DisjointPaths G v0 v1 paths'\n\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  DisjointPaths G v0 v1 paths'\n\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "have \"card paths' = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card paths' = Suc n", "using P_new_new"], ["proof (prove)\nusing this:\n  P_new \\<notin> paths\n\ngoal (1 subgoal):\n 1. card paths' = Suc n", "by (simp add: G.finite_paths P(2) paths'_def)"], ["proof (state)\nthis:\n  card paths' = Suc n\n\ngoal (1 subgoal):\n 1. x = v1 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  DisjointPaths G v0 v1 paths'\n  card paths' = Suc n", "show False"], ["proof (prove)\nusing this:\n  DisjointPaths G v0 v1 paths'\n  card paths' = Suc n\n\ngoal (1 subgoal):\n 1. False", "using not_case"], ["proof (prove)\nusing this:\n  DisjointPaths G v0 v1 paths'\n  card paths' = Suc n\n  \\<nexists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc n\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> v1\n\ngoal (1 subgoal):\n 1. \\<nexists>paths.\n       DisjointPaths G v0 v1 paths \\<and>\n       card paths = Suc n \\<Longrightarrow>\n    False", "have \"ProofStepInduct_axioms paths n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ProofStepInduct_axioms paths n", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<noteq> 0\n 2. card paths = n", "show \"n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "using G.DisjointPaths_extend G.finite_paths P(2) P_new(1) not_case card_insert_disjoint"], ["proof (prove)\nusing this:\n  \\<lbrakk>v0 \\<leadsto>?P\\<leadsto>\\<^bsub>G\\<^esub> v1;\n   \\<And>xs v.\n      \\<lbrakk>xs \\<in> paths; xs \\<noteq> ?P; v \\<in> set xs;\n       v \\<in> set ?P\\<rbrakk>\n      \\<Longrightarrow> v = v0 \\<or> v = v1\\<rbrakk>\n  \\<Longrightarrow> DisjointPaths G v0 v1 (insert ?P paths)\n  finite paths\n  card paths = n\n  v0 \\<leadsto>P_new\\<leadsto>\\<^bsub>G\\<^esub> v1\n  \\<nexists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc n\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> card (insert ?x ?A) = Suc (card ?A)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card paths = n", "qed (insert P(2))"], ["proof (state)\nthis:\n  ProofStepInduct_axioms paths n\n\ngoal (1 subgoal):\n 1. \\<nexists>paths.\n       DisjointPaths G v0 v1 paths \\<and>\n       card paths = Suc n \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  ProofStepInduct_axioms paths n", "have \"ProofStepInduct G v0 v1 paths (new_pre @ [x]) n\""], ["proof (prove)\nusing this:\n  ProofStepInduct_axioms paths n\n\ngoal (1 subgoal):\n 1. ProofStepInduct G v0 v1 paths (new_pre @ [x]) n", "using 1 2"], ["proof (prove)\nusing this:\n  ProofStepInduct_axioms paths n\n  DisjointPathsPlusOne G v0 v1 paths (new_pre @ [x])\n  NoSmallSeparationsInduct G v0 v1 n\n\ngoal (1 subgoal):\n 1. ProofStepInduct G v0 v1 paths (new_pre @ [x]) n", "by (simp add: ProofStepInduct.intro)"], ["proof (state)\nthis:\n  ProofStepInduct G v0 v1 paths (new_pre @ [x]) n\n\ngoal (1 subgoal):\n 1. \\<nexists>paths.\n       DisjointPaths G v0 v1 paths \\<and>\n       card paths = Suc n \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  ProofStepInduct G v0 v1 paths (new_pre @ [x]) n", "show False"], ["proof (prove)\nusing this:\n  ProofStepInduct G v0 v1 paths (new_pre @ [x]) n\n\ngoal (1 subgoal):\n 1. False", "using ProofStepInduct.one_more_paths_exists not_case"], ["proof (prove)\nusing this:\n  ProofStepInduct G v0 v1 paths (new_pre @ [x]) n\n  ProofStepInduct ?G ?v0.0 ?v1.0 ?paths ?P_new ?sep_size \\<Longrightarrow>\n  \\<exists>paths.\n     DisjointPaths ?G ?v0.0 ?v1.0 paths \\<and> card paths = Suc ?sep_size\n  \\<nexists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc n\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The previous theorem was the difficult direction of Menger's Theorem.  Let us now prove the other\n  direction: If we have @{term n} disjoint paths, than every separator must contain at least\n  @{term n} vertices.  This direction is rather trivial because every separator needs to separate\n  at least the @{term n} paths, so we do not need induction or an elaborate setup to prove this.\n\\<close>"], ["", "theorem (in v0_v1_Digraph) menger_trivial:\n  assumes \"DisjointPaths G v0 v1 paths\" \"card paths = n\"\n  shows \"\\<And>S. Separation G v0 v1 S \\<Longrightarrow> card S \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "interpret DisjointPaths G v0 v1 paths"], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 paths", "using assms(1)"], ["proof (prove)\nusing this:\n  DisjointPaths G v0 v1 paths\n\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 paths", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "fix S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "assume \"Separation G v0 v1 S\""], ["proof (state)\nthis:\n  Separation G v0 v1 S\n\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "then"], ["proof (chain)\npicking this:\n  Separation G v0 v1 S", "interpret S: Separation G v0 v1 S"], ["proof (prove)\nusing this:\n  Separation G v0 v1 S\n\ngoal (1 subgoal):\n 1. Separation G v0 v1 S", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "text \\<open>\n    Our plan is to show @{term \"card S \\<ge> n\"} by defining an injective function from @{term paths}\n    into @{term S}.  Because we have @{term \"card paths = n\"}, the result follows.\n\n    For the injective function, we simply use the observation stated above: Every path needs to\n    be separated by @{term S} at some vertex, so we can choose such a vertex.\n\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "define f where \"f \\<equiv> \\<lambda>xs. SOME v. v \\<in> S \\<and> v \\<in> set xs\""], ["proof (state)\nthis:\n  f \\<equiv> \\<lambda>xs. SOME v. v \\<in> S \\<and> v \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "have f_good: \"\\<And>xs. xs \\<in> paths \\<Longrightarrow> f xs \\<in> S \\<and> f xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths \\<Longrightarrow>\n       f xs \\<in> S \\<and> f xs \\<in> set xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths \\<Longrightarrow>\n       f xs \\<in> S \\<and> f xs \\<in> set xs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths \\<Longrightarrow>\n       f xs \\<in> S \\<and> f xs \\<in> set xs", "assume \"xs \\<in> paths\""], ["proof (state)\nthis:\n  xs \\<in> paths\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths \\<Longrightarrow>\n       f xs \\<in> S \\<and> f xs \\<in> set xs", "then"], ["proof (chain)\npicking this:\n  xs \\<in> paths", "obtain v where \"v \\<in> set xs \\<inter> S\""], ["proof (prove)\nusing this:\n  xs \\<in> paths\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> set xs \\<inter> S \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using S.S_separates paths"], ["proof (prove)\nusing this:\n  xs \\<in> paths\n  v0 \\<leadsto>?xs\\<leadsto> v1 \\<Longrightarrow>\n  set ?xs \\<inter> S \\<noteq> {}\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> set xs \\<inter> S \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> set xs \\<inter> S\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> paths \\<Longrightarrow>\n       f xs \\<in> S \\<and> f xs \\<in> set xs", "then"], ["proof (chain)\npicking this:\n  v \\<in> set xs \\<inter> S", "show \"f xs \\<in> S \\<and> f xs \\<in> set xs\""], ["proof (prove)\nusing this:\n  v \\<in> set xs \\<inter> S\n\ngoal (1 subgoal):\n 1. f xs \\<in> S \\<and> f xs \\<in> set xs", "unfolding f_def"], ["proof (prove)\nusing this:\n  v \\<in> set xs \\<inter> S\n\ngoal (1 subgoal):\n 1. (SOME v. v \\<in> S \\<and> v \\<in> set xs) \\<in> S \\<and>\n    (SOME v. v \\<in> S \\<and> v \\<in> set xs) \\<in> set xs", "using someI[of \"\\<lambda>v. v \\<in> S \\<and> v \\<in> set xs\" v]"], ["proof (prove)\nusing this:\n  v \\<in> set xs \\<inter> S\n  v \\<in> S \\<and> v \\<in> set xs \\<Longrightarrow>\n  (SOME v. v \\<in> S \\<and> v \\<in> set xs) \\<in> S \\<and>\n  (SOME v. v \\<in> S \\<and> v \\<in> set xs) \\<in> set xs\n\ngoal (1 subgoal):\n 1. (SOME v. v \\<in> S \\<and> v \\<in> set xs) \\<in> S \\<and>\n    (SOME v. v \\<in> S \\<and> v \\<in> set xs) \\<in> set xs", "by blast"], ["proof (state)\nthis:\n  f xs \\<in> S \\<and> f xs \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?xs \\<in> paths \\<Longrightarrow> f ?xs \\<in> S \\<and> f ?xs \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "text \\<open>This @{term f} is injective because no two paths intersect in the same vertex.\\<close>"], ["proof (state)\nthis:\n  ?xs \\<in> paths \\<Longrightarrow> f ?xs \\<in> S \\<and> f ?xs \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "have \"inj_on f paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f paths", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> paths; y \\<in> paths; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> paths; y \\<in> paths; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume *: \"xs \\<in> paths\" \"ys \\<in> paths\" \"f xs = f ys\""], ["proof (state)\nthis:\n  xs \\<in> paths\n  ys \\<in> paths\n  f xs = f ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> paths; y \\<in> paths; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  xs \\<in> paths\n  ys \\<in> paths\n  f xs = f ys", "obtain v where \"v \\<in> S\" \"v \\<in> set xs\" \"v \\<in> set ys\""], ["proof (prove)\nusing this:\n  xs \\<in> paths\n  ys \\<in> paths\n  f xs = f ys\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> S; v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using f_good"], ["proof (prove)\nusing this:\n  xs \\<in> paths\n  ys \\<in> paths\n  f xs = f ys\n  ?xs \\<in> paths \\<Longrightarrow> f ?xs \\<in> S \\<and> f ?xs \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> S; v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> S\n  v \\<in> set xs\n  v \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> paths; y \\<in> paths; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  v \\<in> S\n  v \\<in> set xs\n  v \\<in> set ys", "show \"xs = ys\""], ["proof (prove)\nusing this:\n  v \\<in> S\n  v \\<in> set xs\n  v \\<in> set ys\n\ngoal (1 subgoal):\n 1. xs = ys", "using *(1,2) paths_disjoint S.v0_notin_S S.v1_notin_S"], ["proof (prove)\nusing this:\n  v \\<in> S\n  v \\<in> set xs\n  v \\<in> set ys\n  xs \\<in> paths\n  ys \\<in> paths\n  \\<lbrakk>?xs \\<in> paths; ?ys \\<in> paths; ?xs \\<noteq> ?ys;\n   ?v \\<in> set ?xs; ?v \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?v = v0 \\<or> ?v = v1\n  v0 \\<notin> S\n  v1 \\<notin> S\n\ngoal (1 subgoal):\n 1. xs = ys", "by fastforce"], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on f paths\n\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "then"], ["proof (chain)\npicking this:\n  inj_on f paths", "show \"card S \\<ge> n\""], ["proof (prove)\nusing this:\n  inj_on f paths\n\ngoal (1 subgoal):\n 1. n \\<le> card S", "using assms(2) f_good"], ["proof (prove)\nusing this:\n  inj_on f paths\n  card paths = n\n  ?xs \\<in> paths \\<Longrightarrow> f ?xs \\<in> S \\<and> f ?xs \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. n \\<le> card S", "by (metis S.finite_S finite_paths image_subsetI inj_on_iff_card_le)"], ["proof (state)\nthis:\n  n \\<le> card S\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Self-contained Statement of the Main Theorem\\<close>"], ["", "text \\<open>\n  Let us state both directions of Menger's Theorem again in a more self-contained way in the\n  @{locale Digraph} locale. Stating the theorems in a self-contained way helps avoiding mistakes\n  due to wrong definitions hidden in one of the numerous locales we used and also significantly\n  reduces the work needed to review this formalization.\n\n  With the statements below, all you need to do in order to verify that this formalization\n  actually expresses Menger's Theorem (and not something else), is to look into the assumptions\n  and definitions of the @{locale Digraph} locale.\n\\<close>"], ["", "theorem (in Digraph) menger:\n  fixes v0 v1 :: 'a and n :: nat\n  assumes v0_V: \"v0 \\<in> V\"\n      and v1_V: \"v1 \\<in> V\"\n      and v0_nonadj_v1: \"\\<not>v0\\<rightarrow>v1\"\n      and v0_neq_v1: \"v0 \\<noteq> v1\"\n      and no_small_separators: \"\\<And>S.\n        \\<lbrakk> S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S; \\<And>xs. v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow> set xs \\<inter> S \\<noteq> {} \\<rbrakk> \\<Longrightarrow> card S \\<ge> n\"\n  shows \"\\<exists>paths. card paths = n \\<and> (\\<forall>xs \\<in> paths.\n    v0 \\<leadsto>xs\\<leadsto> v1 \\<and> (\\<forall>ys \\<in> paths - {xs}. (\\<forall>v \\<in> set xs \\<inter> set ys. v = v0 \\<or> v = v1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       card paths = n \\<and>\n       (\\<forall>xs\\<in>paths.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<and>\n           (\\<forall>ys\\<in>paths - {xs}.\n               \\<forall>v\\<in>set xs \\<inter> set ys. v = v0 \\<or> v = v1))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       card paths = n \\<and>\n       (\\<forall>xs\\<in>paths.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<and>\n           (\\<forall>ys\\<in>paths - {xs}.\n               \\<forall>v\\<in>set xs \\<inter> set ys. v = v0 \\<or> v = v1))", "interpret v0_v1_Digraph G v0 v1"], ["proof (prove)\ngoal (1 subgoal):\n 1. v0_v1_Digraph G v0 v1", "using v0_V v1_V v0_nonadj_v1 v0_neq_v1"], ["proof (prove)\nusing this:\n  v0 \\<in> V\n  v1 \\<in> V\n  (v0, v1) \\<notin> E\n  v0 \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v0_v1_Digraph G v0 v1", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       card paths = n \\<and>\n       (\\<forall>xs\\<in>paths.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<and>\n           (\\<forall>ys\\<in>paths - {xs}.\n               \\<forall>v\\<in>set xs \\<inter> set ys. v = v0 \\<or> v = v1))", "have \"\\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "using no_small_separators"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> V; v0 \\<notin> ?S; v1 \\<notin> ?S;\n   \\<And>xs.\n      v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow>\n      set xs \\<inter> ?S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> n \\<le> card ?S\n\ngoal (1 subgoal):\n 1. \\<And>S. Separation G v0 v1 S \\<Longrightarrow> n \\<le> card S", "by (simp add: Separation.S_V Separation.S_separates Separation.v0_notin_S Separation.v1_notin_S)"], ["proof (state)\nthis:\n  Separation G v0 v1 ?S \\<Longrightarrow> n \\<le> card ?S\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       card paths = n \\<and>\n       (\\<forall>xs\\<in>paths.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<and>\n           (\\<forall>ys\\<in>paths - {xs}.\n               \\<forall>v\\<in>set xs \\<inter> set ys. v = v0 \\<or> v = v1))", "then"], ["proof (chain)\npicking this:\n  Separation G v0 v1 ?S \\<Longrightarrow> n \\<le> card ?S", "obtain paths where\n    paths: \"DisjointPaths G v0 v1 paths\" \"card paths = n\""], ["proof (prove)\nusing this:\n  Separation G v0 v1 ?S \\<Longrightarrow> n \\<le> card ?S\n\ngoal (1 subgoal):\n 1. (\\<And>paths.\n        \\<lbrakk>DisjointPaths G v0 v1 paths; card paths = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using no_small_separators menger"], ["proof (prove)\nusing this:\n  Separation G v0 v1 ?S \\<Longrightarrow> n \\<le> card ?S\n  \\<lbrakk>?S \\<subseteq> V; v0 \\<notin> ?S; v1 \\<notin> ?S;\n   \\<And>xs.\n      v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow>\n      set xs \\<inter> ?S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> n \\<le> card ?S\n  (\\<And>S.\n      Separation G v0 v1 S \\<Longrightarrow>\n      ?n \\<le> card S) \\<Longrightarrow>\n  \\<exists>paths. DisjointPaths G v0 v1 paths \\<and> card paths = ?n\n\ngoal (1 subgoal):\n 1. (\\<And>paths.\n        \\<lbrakk>DisjointPaths G v0 v1 paths; card paths = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  DisjointPaths G v0 v1 paths\n  card paths = n\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       card paths = n \\<and>\n       (\\<forall>xs\\<in>paths.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<and>\n           (\\<forall>ys\\<in>paths - {xs}.\n               \\<forall>v\\<in>set xs \\<inter> set ys. v = v0 \\<or> v = v1))", "then"], ["proof (chain)\npicking this:\n  DisjointPaths G v0 v1 paths\n  card paths = n", "show ?thesis"], ["proof (prove)\nusing this:\n  DisjointPaths G v0 v1 paths\n  card paths = n\n\ngoal (1 subgoal):\n 1. \\<exists>paths.\n       card paths = n \\<and>\n       (\\<forall>xs\\<in>paths.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<and>\n           (\\<forall>ys\\<in>paths - {xs}.\n               \\<forall>v\\<in>set xs \\<inter> set ys. v = v0 \\<or> v = v1))", "by (metis DiffD1 DiffD2 DisjointPaths.paths DisjointPaths.paths_disjoint IntD1 IntD2 singletonI)"], ["proof (state)\nthis:\n  \\<exists>paths.\n     card paths = n \\<and>\n     (\\<forall>xs\\<in>paths.\n         v0 \\<leadsto>xs\\<leadsto> v1 \\<and>\n         (\\<forall>ys\\<in>paths - {xs}.\n             \\<forall>v\\<in>set xs \\<inter> set ys. v = v0 \\<or> v = v1))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in Digraph) menger_trivial:\n  fixes v0 v1 :: 'a and n :: nat\n  assumes v0_V: \"v0 \\<in> V\"\n      and v1_V: \"v1 \\<in> V\"\n      and v0_nonadj_v1: \"\\<not>v0\\<rightarrow>v1\"\n      and v0_neq_v1: \"v0 \\<noteq> v1\"\n      and n_paths: \"card paths = n\"\n      and paths_disjoint: \"\\<forall>xs \\<in> paths.\n        v0 \\<leadsto>xs\\<leadsto> v1 \\<and> (\\<forall>ys \\<in> paths - {xs}. (\\<forall>v \\<in> set xs \\<inter> set ys. v = v0 \\<or> v = v1))\"\n  shows \"\\<And>S. \\<lbrakk> S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S; \\<And>xs. v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow> set xs \\<inter> S \\<noteq> {} \\<rbrakk> \\<Longrightarrow> card S \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S;\n        \\<And>xs.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow>\n           set xs \\<inter> S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> n \\<le> card S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S;\n        \\<And>xs.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow>\n           set xs \\<inter> S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> n \\<le> card S", "interpret v0_v1_Digraph G v0 v1"], ["proof (prove)\ngoal (1 subgoal):\n 1. v0_v1_Digraph G v0 v1", "using v0_V v1_V v0_nonadj_v1 v0_neq_v1"], ["proof (prove)\nusing this:\n  v0 \\<in> V\n  v1 \\<in> V\n  (v0, v1) \\<notin> E\n  v0 \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v0_v1_Digraph G v0 v1", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S;\n        \\<And>xs.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow>\n           set xs \\<inter> S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> n \\<le> card S", "interpret DisjointPaths G v0 v1 paths"], ["proof (prove)\ngoal (1 subgoal):\n 1. DisjointPaths G v0 v1 paths", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1\n 2. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "show \"\\<And>xs. xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1", "using paths_disjoint"], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>paths.\n     v0 \\<leadsto>xs\\<leadsto> v1 \\<and>\n     (\\<forall>ys\\<in>paths - {xs}.\n         \\<forall>v\\<in>set xs \\<inter> set ys. v = v0 \\<or> v = v1)\n\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>xs\\<leadsto> v1", "by simp"], ["proof (state)\nthis:\n  ?xs \\<in> paths \\<Longrightarrow> v0 \\<leadsto>?xs\\<leadsto> v1\n\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "fix xs ys v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "assume \"xs \\<in> paths\" \"ys \\<in> paths\" \"xs \\<noteq> ys\" \"v \\<in> set xs\" \"v \\<in> set ys\""], ["proof (state)\nthis:\n  xs \\<in> paths\n  ys \\<in> paths\n  xs \\<noteq> ys\n  v \\<in> set xs\n  v \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "then"], ["proof (chain)\npicking this:\n  xs \\<in> paths\n  ys \\<in> paths\n  xs \\<noteq> ys\n  v \\<in> set xs\n  v \\<in> set ys", "have \"xs \\<in> paths\" \"ys \\<in> paths - {xs}\" \"v \\<in> set xs \\<inter> set ys\""], ["proof (prove)\nusing this:\n  xs \\<in> paths\n  ys \\<in> paths\n  xs \\<noteq> ys\n  v \\<in> set xs\n  v \\<in> set ys\n\ngoal (1 subgoal):\n 1. xs \\<in> paths &&&\n    ys \\<in> paths - {xs} &&& v \\<in> set xs \\<inter> set ys", "by blast+"], ["proof (state)\nthis:\n  xs \\<in> paths\n  ys \\<in> paths - {xs}\n  v \\<in> set xs \\<inter> set ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys v.\n       \\<lbrakk>xs \\<in> paths; ys \\<in> paths; xs \\<noteq> ys;\n        v \\<in> set xs; v \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> v = v0 \\<or> v = v1", "then"], ["proof (chain)\npicking this:\n  xs \\<in> paths\n  ys \\<in> paths - {xs}\n  v \\<in> set xs \\<inter> set ys", "show \"v = v0 \\<or> v = v1\""], ["proof (prove)\nusing this:\n  xs \\<in> paths\n  ys \\<in> paths - {xs}\n  v \\<in> set xs \\<inter> set ys\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1", "using paths_disjoint"], ["proof (prove)\nusing this:\n  xs \\<in> paths\n  ys \\<in> paths - {xs}\n  v \\<in> set xs \\<inter> set ys\n  \\<forall>xs\\<in>paths.\n     v0 \\<leadsto>xs\\<leadsto> v1 \\<and>\n     (\\<forall>ys\\<in>paths - {xs}.\n         \\<forall>v\\<in>set xs \\<inter> set ys. v = v0 \\<or> v = v1)\n\ngoal (1 subgoal):\n 1. v = v0 \\<or> v = v1", "by blast"], ["proof (state)\nthis:\n  v = v0 \\<or> v = v1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S;\n        \\<And>xs.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow>\n           set xs \\<inter> S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> n \\<le> card S", "fix S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S;\n        \\<And>xs.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow>\n           set xs \\<inter> S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> n \\<le> card S", "assume \"S \\<subseteq> V\" \"v0 \\<notin> S\" \"v1 \\<notin> S\" \"\\<And>xs. v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow> set xs \\<inter> S \\<noteq> {}\""], ["proof (state)\nthis:\n  S \\<subseteq> V\n  v0 \\<notin> S\n  v1 \\<notin> S\n  v0 \\<leadsto>?xs\\<leadsto> v1 \\<Longrightarrow>\n  set ?xs \\<inter> S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S;\n        \\<And>xs.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow>\n           set xs \\<inter> S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> n \\<le> card S", "then"], ["proof (chain)\npicking this:\n  S \\<subseteq> V\n  v0 \\<notin> S\n  v1 \\<notin> S\n  v0 \\<leadsto>?xs\\<leadsto> v1 \\<Longrightarrow>\n  set ?xs \\<inter> S \\<noteq> {}", "interpret Separation G v0 v1 S"], ["proof (prove)\nusing this:\n  S \\<subseteq> V\n  v0 \\<notin> S\n  v1 \\<notin> S\n  v0 \\<leadsto>?xs\\<leadsto> v1 \\<Longrightarrow>\n  set ?xs \\<inter> S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Separation G v0 v1 S", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>S \\<subseteq> V; v0 \\<notin> S; v1 \\<notin> S;\n        \\<And>xs.\n           v0 \\<leadsto>xs\\<leadsto> v1 \\<Longrightarrow>\n           set xs \\<inter> S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> n \\<le> card S", "show \"card S \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> card S", "using menger_trivial DisjointPaths_axioms Separation_axioms n_paths"], ["proof (prove)\nusing this:\n  \\<lbrakk>DisjointPaths G v0 v1 ?paths; card ?paths = ?n;\n   Separation G v0 v1 ?S\\<rbrakk>\n  \\<Longrightarrow> ?n \\<le> card ?S\n  DisjointPaths G v0 v1 paths\n  Separation G v0 v1 S\n  card paths = n\n\ngoal (1 subgoal):\n 1. n \\<le> card S", "by blast"], ["proof (state)\nthis:\n  n \\<le> card S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}