{"file_name": "/home/qj213/afp-2021-10-22/thys/Menger/Graph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Menger", "problem_names": ["lemma finite_edge_set [simp]: \"finite E\"", "lemma edges_are_in_V: assumes \"v\\<rightarrow>w\" shows \"v \\<in> V\" \"w \\<in> V\"", "lemma walk_2 [simp]: \"v\\<rightarrow>w \\<Longrightarrow> walk [v,w]\"", "lemma walk_comp: \"\\<lbrakk> walk xs; walk ys; xs = Nil \\<or> ys = Nil \\<or> last xs\\<rightarrow>hd ys \\<rbrakk> \\<Longrightarrow> walk (xs @ ys)\"", "lemma walk_tl: \"walk xs \\<Longrightarrow> walk (tl xs)\"", "lemma walk_drop: \"walk xs \\<Longrightarrow> walk (drop n xs)\"", "lemma walk_take: \"walk xs \\<Longrightarrow> walk (take n xs)\"", "lemma walk_decomp: assumes \"walk (xs @ ys)\" shows \"walk xs\" \"walk ys\"", "lemma walk_in_V: \"walk xs \\<Longrightarrow> set xs \\<subseteq> V\"", "lemma walk_first_edge: \"walk (v # w # xs) \\<Longrightarrow> v\\<rightarrow>w\"", "lemma walk_first_edge': \"\\<lbrakk> walk (v # xs); xs \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>hd xs\"", "lemma walk_middle_edge: \"walk (xs @ v # w # ys) \\<Longrightarrow> v\\<rightarrow>w\"", "lemma walk_last_edge: \"\\<lbrakk> walk (xs @ ys); xs \\<noteq> Nil; ys \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> last xs\\<rightarrow>hd ys\"", "lemma path_singleton [simp]: \"v \\<in> V \\<Longrightarrow> path [v]\"", "lemma path_2 [simp]: \"\\<lbrakk> v\\<rightarrow>w; v \\<noteq> w \\<rbrakk> \\<Longrightarrow> path [v,w]\"", "lemma path_cons: \"\\<lbrakk> path xs; xs \\<noteq> Nil; v\\<rightarrow>hd xs; v \\<notin> set xs \\<rbrakk> \\<Longrightarrow> path (v # xs)\"", "lemma path_comp: \"\\<lbrakk> walk xs; walk ys; xs = Nil \\<or> ys = Nil \\<or> last xs\\<rightarrow>hd ys; distinct (xs @ ys) \\<rbrakk>\n  \\<Longrightarrow> path (xs @ ys)\"", "lemma path_tl: \"path xs \\<Longrightarrow> path (tl xs)\"", "lemma path_drop: \"path xs \\<Longrightarrow> path (drop n xs)\"", "lemma path_take: \"path xs \\<Longrightarrow> path (take n xs)\"", "lemma path_decomp: assumes \"path (xs @ ys)\" shows \"path xs\" \"path ys\"", "lemma path_decomp': \"path (xs @ x # ys) \\<Longrightarrow> path (xs @ [x])\"", "lemma path_in_V: \"path xs \\<Longrightarrow> set xs \\<subseteq> V\"", "lemma path_length: \"path xs \\<Longrightarrow> length xs \\<le> card V\"", "lemma path_first_edge: \"path (v # w # xs) \\<Longrightarrow> v\\<rightarrow>w\"", "lemma path_first_edge': \"\\<lbrakk> path (v # xs); xs \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>hd xs\"", "lemma path_middle_edge: \"path (xs @ v # w # ys) \\<Longrightarrow> v \\<rightarrow> w\"", "lemma path_first_vertex: \"path (x # xs) \\<Longrightarrow> x \\<notin> set xs\"", "lemma path_disjoint: \"\\<lbrakk> path (xs @ ys); xs \\<noteq> Nil; x \\<in> set xs \\<rbrakk> \\<Longrightarrow> x \\<notin> set ys\"", "lemma finitely_many_paths: \"finite all_paths\"", "lemma path_from_toI [intro]: \"\\<lbrakk> path xs; xs \\<noteq> Nil; hd xs = v; last xs = w \\<rbrakk> \\<Longrightarrow> v \\<leadsto>xs\\<leadsto> w\"\n  and path_from_toE [dest]: \"v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow> path xs \\<and> xs \\<noteq> Nil \\<and> hd xs = v \\<and> last xs = w\"", "lemma path_from_to_ends: \"v \\<leadsto>(xs @ w # ys)\\<leadsto> w \\<Longrightarrow> ys = Nil\"", "lemma path_from_to_combine:\n  assumes \"v \\<leadsto>(xs @ x # xs')\\<leadsto> w\" \"v' \\<leadsto>(ys @ x # ys')\\<leadsto> w'\" \"set xs \\<inter> set ys' = {}\"\n  shows \"v \\<leadsto>(xs @ x # ys') \\<leadsto> w'\"", "lemma path_from_to_first: \"v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow> v \\<notin> set (tl xs)\"", "lemma path_from_to_first': \"v \\<leadsto>(xs @ x # xs')\\<leadsto> w \\<Longrightarrow> v \\<notin> set xs'\"", "lemma path_from_to_last: \"v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow> w \\<notin> set (butlast xs)\"", "lemma path_from_to_last': \"v \\<leadsto>(xs @ x # xs')\\<leadsto> w \\<Longrightarrow> w \\<notin> set xs\"", "lemma walk_to_path:\n  assumes \"walk xs\" \"xs \\<noteq> Nil\" \"hd xs = v\" \"last xs = w\"\n  shows \"\\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs\"", "lemma edges_of_walkE: \"(v,w) \\<in> edges_of_walk xs \\<Longrightarrow> \\<exists>xs_pre xs_post. xs = xs_pre @ v # w # xs_post\"", "lemma edges_of_walk_in_E: \"walk xs \\<Longrightarrow> edges_of_walk xs \\<subseteq> E\"", "lemma edges_of_walk_finite: \"walk xs \\<Longrightarrow> finite (edges_of_walk xs)\"", "lemma edges_of_walk_empty: \"edges_of_walk [] = {}\" \"edges_of_walk [v] = {}\"", "lemma edges_of_walk_2: \"edges_of_walk [v,w] = {(v,w)}\"", "lemma edges_of_walk_edge: \"\\<lbrakk> walk xs; (v,w) \\<in> edges_of_walk xs \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>w\"", "lemma edges_of_walk_middle [simp]: \"(v,w) \\<in> edges_of_walk (xs @ v # w # xs')\"", "lemma edges_of_comp1: \"edges_of_walk xs \\<subseteq> edges_of_walk (xs @ ys)\"", "lemma edges_of_comp2: \"edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)\"", "lemma walk_edges_decomp_simple:\n  \"edges_of_walk (v # w # xs) = {(v,w)} \\<union> edges_of_walk (w # xs)\" (is \"?A = ?B\")", "lemma walk_edges_decomp:\n  \"edges_of_walk (xs @ x # xs') = edges_of_walk (xs @ [x]) \\<union> edges_of_walk (x # xs')\"", "lemma walk_edges_decomp':\n  \"edges_of_walk (xs @ v # w # xs') = edges_of_walk (xs @ [v]) \\<union> {(v,w)} \\<union> edges_of_walk (w # xs')\"", "lemma walk_edges_vertices: assumes \"(v, w) \\<in> edges_of_walk xs\" shows \"v \\<in> set xs\" \"w \\<in> set xs\"", "lemma walk_edges_subset:\n  assumes edges_subsets: \"edges_of_walk xs \\<subseteq> edges_of_walk ys\"\n    and non_trivial: \"tl xs \\<noteq> Nil\"\n  shows \"set xs \\<subseteq> set ys\"", "lemma path_edges:\n  assumes \"path xs\" \"(v,w) \\<in> edges_of_walk xs\"\n  shows \"\\<exists>xs_pre xs_post. xs = xs_pre @ v # w # xs_post\n    \\<and> (v,w) \\<notin> edges_of_walk (xs_pre @ [v])\n    \\<and> (v,w) \\<notin> edges_of_walk (w # xs_post)\"", "lemma path_edges_remove_prefix:\n  assumes \"path (xs @ x # xs')\"\n  shows \"edges_of_walk (xs @ [x]) = edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')\"", "lemma first_edge_in_edges: \"tl xs \\<noteq> Nil \\<Longrightarrow> first_edge_of_walk xs \\<in> edges_of_walk xs\"", "lemma first_edge_hd_tl: \"\\<lbrakk> v \\<leadsto>xs\\<leadsto> w; tl xs \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> first_edge_of_walk xs = (v, hd (tl xs))\"", "lemma first_edge_first:\n  assumes \"v \\<leadsto>xs\\<leadsto> w\" \"(v,w') \\<in> edges_of_walk xs\"\n  shows \"first_edge_of_walk xs = (v,w')\"", "lemma distance_lengths_finite: \"finite { length xs | xs. v\\<leadsto>xs\\<leadsto>w }\"", "lemma distance_upper_bound: \"v\\<leadsto>xs\\<leadsto>w \\<Longrightarrow> distance v w \\<le> length xs\"", "lemma distance_witness:\n  assumes xs: \"v \\<leadsto>xs\\<leadsto> w\"\n      and xs_min: \"\\<And>xs'. v \\<leadsto>xs'\\<leadsto> w \\<Longrightarrow> length xs \\<le> length xs'\"\n  shows \"distance v w = length xs\"", "lemma remove_vertex_V: \"V\\<^bsub>remove_vertex x\\<^esub> = V - {x}\"", "lemma remove_vertex_V': \"V\\<^bsub>remove_vertex x\\<^esub> \\<subseteq> V\"", "lemma remove_vertex_E: \"E\\<^bsub>remove_vertex x\\<^esub> = Restr E (V - {x})\"", "lemma remove_vertex_E': \"v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w \\<Longrightarrow> v\\<rightarrow>w\"", "lemma remove_vertex_E'': \"\\<lbrakk> v\\<rightarrow>w; v \\<noteq> x; w \\<noteq> x \\<rbrakk> \\<Longrightarrow> v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w\"", "lemma remove_vertex_Digraph: \"Digraph (remove_vertex v)\"", "lemma remove_vertex_walk:\n  assumes \"walk xs\" \"x \\<notin> set xs\"\n  shows \"Digraph.walk (remove_vertex x) xs\"", "lemma remove_vertex_path_from_to:\n  \"\\<lbrakk> v \\<leadsto>xs\\<leadsto> w; x \\<in> V; x \\<notin> set xs \\<rbrakk> \\<Longrightarrow> v \\<leadsto>xs\\<leadsto>\\<^bsub>remove_vertex x\\<^esub> w\"", "lemma remove_vertex_walk_add:\n  assumes \"Digraph.walk (remove_vertex x) xs\"\n  shows \"walk xs\"", "lemma remove_vertex_path_from_to_add: \"v \\<leadsto>xs\\<leadsto>\\<^bsub>remove_vertex x\\<^esub> w \\<Longrightarrow> v \\<leadsto>xs\\<leadsto> w\"", "lemma (in v0_v1_Digraph) remove_vertices_v0_v1_Digraph:\n  assumes \"v \\<noteq> v0\" \"v \\<noteq> v1\"\n  shows \"v0_v1_Digraph (remove_vertex v) v0 v1\""], "translations": [["", "lemma finite_edge_set [simp]: \"finite E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E", "using finite_vertex_set valid_edge_set"], ["proof (prove)\nusing this:\n  finite V\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. finite E", "by (simp add: finite_subset)"], ["", "lemma edges_are_in_V: assumes \"v\\<rightarrow>w\" shows \"v \\<in> V\" \"w \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V &&& w \\<in> V", "using assms valid_edge_set"], ["proof (prove)\nusing this:\n  v \\<rightarrow> w\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. v \\<in> V &&& w \\<in> V", "by blast+"], ["", "subsection \\<open>Walks\\<close>"], ["", "text \\<open>A walk is sequence of vertices connected by edges.\\<close>"], ["", "inductive walk :: \"'a Walk \\<Rightarrow> bool\" where\nNil [simp]: \"walk []\"\n| Singleton [simp]: \"v \\<in> V \\<Longrightarrow> walk [v]\"\n| Cons: \"v\\<rightarrow>w \\<Longrightarrow> walk (w # vs) \\<Longrightarrow> walk (v # w # vs)\""], ["", "text \\<open>\n  Show a few composition/decomposition lemmas for walks.  These will greatly simplify the proofs\n  that follow.\\<close>"], ["", "lemma walk_2 [simp]: \"v\\<rightarrow>w \\<Longrightarrow> walk [v,w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<Longrightarrow> walk [v, w]", "by (simp add: edges_are_in_V(2) walk.intros(3))"], ["", "lemma walk_comp: \"\\<lbrakk> walk xs; walk ys; xs = Nil \\<or> ys = Nil \\<or> last xs\\<rightarrow>hd ys \\<rbrakk> \\<Longrightarrow> walk (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk xs; walk ys;\n     xs = [] \\<or> ys = [] \\<or> last xs \\<rightarrow> hd ys\\<rbrakk>\n    \\<Longrightarrow> walk (xs @ ys)", "by (induct rule: walk.induct, simp_all add: walk.intros(3))\n     (metis list.exhaust_sel walk.intros(2) walk.intros(3))"], ["", "lemma walk_tl: \"walk xs \\<Longrightarrow> walk (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> walk (tl xs)", "by (induct rule: walk.induct) simp_all"], ["", "lemma walk_drop: \"walk xs \\<Longrightarrow> walk (drop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> walk (drop n xs)", "by (induct n, simp) (metis drop_Suc tl_drop walk_tl)"], ["", "lemma walk_take: \"walk xs \\<Longrightarrow> walk (take n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> walk (take n xs)", "by (induct arbitrary: n rule: walk.induct)\n     (simp, metis Digraph.walk.simps Digraph_axioms take_Cons' take_eq_Nil,\n      metis Digraph.walk.simps Digraph_axioms edges_are_in_V(1) take_Cons')"], ["", "lemma walk_decomp: assumes \"walk (xs @ ys)\" shows \"walk xs\" \"walk ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs &&& walk ys", "using assms append_eq_conv_conj[of xs ys \"xs @ ys\"] walk_take walk_drop"], ["proof (prove)\nusing this:\n  walk (xs @ ys)\n  (xs @ ys = xs @ ys) =\n  (xs = take (length xs) (xs @ ys) \\<and> ys = drop (length xs) (xs @ ys))\n  walk ?xs \\<Longrightarrow> walk (take ?n ?xs)\n  walk ?xs \\<Longrightarrow> walk (drop ?n ?xs)\n\ngoal (1 subgoal):\n 1. walk xs &&& walk ys", "by metis+"], ["", "lemma walk_in_V: \"walk xs \\<Longrightarrow> set xs \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> set xs \\<subseteq> V", "by (induct rule: walk.induct; simp add: edges_are_in_V)"], ["", "lemma walk_first_edge: \"walk (v # w # xs) \\<Longrightarrow> v\\<rightarrow>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk (v # w # xs) \\<Longrightarrow> v \\<rightarrow> w", "using walk.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>walk ?a; ?a = [] \\<Longrightarrow> ?P;\n   \\<And>v. \\<lbrakk>?a = [v]; v \\<in> V\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v w vs.\n      \\<lbrakk>?a = v # w # vs; v \\<rightarrow> w; walk (w # vs)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. walk (v # w # xs) \\<Longrightarrow> v \\<rightarrow> w", "by fastforce"], ["", "lemma walk_first_edge': \"\\<lbrakk> walk (v # xs); xs \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk (v # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> hd xs", "using walk_first_edge"], ["proof (prove)\nusing this:\n  walk (?v # ?w # ?xs) \\<Longrightarrow> ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>walk (v # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> hd xs", "by (metis list.exhaust_sel)"], ["", "lemma walk_middle_edge: \"walk (xs @ v # w # ys) \\<Longrightarrow> v\\<rightarrow>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk (xs @ v # w # ys) \\<Longrightarrow> v \\<rightarrow> w", "by (induct \"xs @ v # w # ys\" arbitrary: xs rule: walk.induct, simp, simp)\n     (metis list.sel(1,3) self_append_conv2 tl_append2)"], ["", "lemma walk_last_edge: \"\\<lbrakk> walk (xs @ ys); xs \\<noteq> Nil; ys \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> last xs\\<rightarrow>hd ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk (xs @ ys); xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last xs \\<rightarrow> hd ys", "using walk_middle_edge[of \"butlast xs\" \"last xs\" \"hd ys\" \"tl ys\"]"], ["proof (prove)\nusing this:\n  walk (butlast xs @ last xs # hd ys # tl ys) \\<Longrightarrow>\n  last xs \\<rightarrow> hd ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>walk (xs @ ys); xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last xs \\<rightarrow> hd ys", "by (metis Cons_eq_appendI append_butlast_last_id append_eq_append_conv2 list.exhaust_sel self_append_conv)"], ["", "subsection \\<open>Paths\\<close>"], ["", "text \\<open>\n  A path is a walk without repeated vertices.  This is simple enough, so most of the above lemmas\n  transfer directly to paths.\n\\<close>"], ["", "abbreviation path :: \"'a Walk \\<Rightarrow> bool\" where \"path xs \\<equiv> walk xs \\<and> distinct xs\""], ["", "lemma path_singleton [simp]: \"v \\<in> V \\<Longrightarrow> path [v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V \\<Longrightarrow> path [v]", "by simp"], ["", "lemma path_2 [simp]: \"\\<lbrakk> v\\<rightarrow>w; v \\<noteq> w \\<rbrakk> \\<Longrightarrow> path [v,w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<rightarrow> w; v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> path [v, w]", "by simp"], ["", "lemma path_cons: \"\\<lbrakk> path xs; xs \\<noteq> Nil; v\\<rightarrow>hd xs; v \\<notin> set xs \\<rbrakk> \\<Longrightarrow> path (v # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path xs; xs \\<noteq> []; v \\<rightarrow> hd xs;\n     v \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> path (v # xs)", "by (metis distinct.simps(2) list.exhaust_sel walk.Cons)"], ["", "lemma path_comp: \"\\<lbrakk> walk xs; walk ys; xs = Nil \\<or> ys = Nil \\<or> last xs\\<rightarrow>hd ys; distinct (xs @ ys) \\<rbrakk>\n  \\<Longrightarrow> path (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk xs; walk ys;\n     xs = [] \\<or> ys = [] \\<or> last xs \\<rightarrow> hd ys;\n     distinct (xs @ ys)\\<rbrakk>\n    \\<Longrightarrow> path (xs @ ys)", "using walk_comp"], ["proof (prove)\nusing this:\n  \\<lbrakk>walk ?xs; walk ?ys;\n   ?xs = [] \\<or> ?ys = [] \\<or> last ?xs \\<rightarrow> hd ?ys\\<rbrakk>\n  \\<Longrightarrow> walk (?xs @ ?ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>walk xs; walk ys;\n     xs = [] \\<or> ys = [] \\<or> last xs \\<rightarrow> hd ys;\n     distinct (xs @ ys)\\<rbrakk>\n    \\<Longrightarrow> path (xs @ ys)", "by blast"], ["", "lemma path_tl: \"path xs \\<Longrightarrow> path (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> path (tl xs)", "by (simp add: distinct_tl walk_tl)"], ["", "lemma path_drop: \"path xs \\<Longrightarrow> path (drop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> path (drop n xs)", "by (simp add: walk_drop)"], ["", "lemma path_take: \"path xs \\<Longrightarrow> path (take n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> path (take n xs)", "by (simp add: walk_take)"], ["", "lemma path_decomp: assumes \"path (xs @ ys)\" shows \"path xs\" \"path ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs &&& path ys", "using walk_decomp assms distinct_append"], ["proof (prove)\nusing this:\n  walk (?xs @ ?ys) \\<Longrightarrow> walk ?xs\n  walk (?xs @ ?ys) \\<Longrightarrow> walk ?ys\n  path (xs @ ys)\n  distinct (?xs @ ?ys) =\n  (distinct ?xs \\<and> distinct ?ys \\<and> set ?xs \\<inter> set ?ys = {})\n\ngoal (1 subgoal):\n 1. path xs &&& path ys", "by blast+"], ["", "lemma path_decomp': \"path (xs @ x # ys) \\<Longrightarrow> path (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (xs @ x # ys) \\<Longrightarrow> path (xs @ [x])", "by (metis Singleton distinct.simps(2) distinct1_rotate edges_are_in_V(1) list.discI list.sel(1)\n      not_distinct_conv_prefix path_decomp(1) rotate1.simps(2) walk_comp walk_decomp(2)\n      walk_first_edge' walk_last_edge)"], ["", "lemma path_in_V: \"path xs \\<Longrightarrow> set xs \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> set xs \\<subseteq> V", "by (simp add: walk_in_V)"], ["", "lemma path_length: \"path xs \\<Longrightarrow> length xs \\<le> card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> length xs \\<le> card V", "by (metis card_mono distinct_card finite_vertex_set path_in_V)"], ["", "lemma path_first_edge: \"path (v # w # xs) \\<Longrightarrow> v\\<rightarrow>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (v # w # xs) \\<Longrightarrow> v \\<rightarrow> w", "using walk_first_edge"], ["proof (prove)\nusing this:\n  walk (?v # ?w # ?xs) \\<Longrightarrow> ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. path (v # w # xs) \\<Longrightarrow> v \\<rightarrow> w", "by blast"], ["", "lemma path_first_edge': \"\\<lbrakk> path (v # xs); xs \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path (v # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> hd xs", "using walk_first_edge'"], ["proof (prove)\nusing this:\n  \\<lbrakk>walk (?v # ?xs); ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?v \\<rightarrow> hd ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path (v # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> hd xs", "by blast"], ["", "lemma path_middle_edge: \"path (xs @ v # w # ys) \\<Longrightarrow> v \\<rightarrow> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (xs @ v # w # ys) \\<Longrightarrow> v \\<rightarrow> w", "using walk_middle_edge"], ["proof (prove)\nusing this:\n  walk (?xs @ ?v # ?w # ?ys) \\<Longrightarrow> ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. path (xs @ v # w # ys) \\<Longrightarrow> v \\<rightarrow> w", "by blast"], ["", "lemma path_first_vertex: \"path (x # xs) \\<Longrightarrow> x \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (x # xs) \\<Longrightarrow> x \\<notin> set xs", "by simp"], ["", "lemma path_disjoint: \"\\<lbrakk> path (xs @ ys); xs \\<noteq> Nil; x \\<in> set xs \\<rbrakk> \\<Longrightarrow> x \\<notin> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path (xs @ ys); xs \\<noteq> []; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set ys", "by auto"], ["", "subsection \\<open>The Set of All Paths\\<close>"], ["", "definition all_paths where \"all_paths \\<equiv> { xs | xs. path xs }\""], ["", "text \\<open>\n  Because paths have no repeated vertices, every graph has at most finitely many distinct paths.\n  This will be useful later to easily derive that any set of paths is finite.\n\\<close>"], ["", "lemma finitely_many_paths: \"finite all_paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite all_paths", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite all_paths", "have \"all_paths \\<subseteq> {xs. set xs \\<subseteq> V \\<and> length xs \\<le> card V}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_paths\n    \\<subseteq> {xs. set xs \\<subseteq> V \\<and> length xs \\<le> card V}", "unfolding all_paths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs |xs. path xs}\n    \\<subseteq> {xs. set xs \\<subseteq> V \\<and> length xs \\<le> card V}", "using path_length"], ["proof (prove)\nusing this:\n  path ?xs \\<Longrightarrow> length ?xs \\<le> card V\n\ngoal (1 subgoal):\n 1. {xs |xs. path xs}\n    \\<subseteq> {xs. set xs \\<subseteq> V \\<and> length xs \\<le> card V}", "by (simp add: Collect_mono path_in_V)"], ["proof (state)\nthis:\n  all_paths\n  \\<subseteq> {xs. set xs \\<subseteq> V \\<and> length xs \\<le> card V}\n\ngoal (1 subgoal):\n 1. finite all_paths", "thus ?thesis"], ["proof (prove)\nusing this:\n  all_paths\n  \\<subseteq> {xs. set xs \\<subseteq> V \\<and> length xs \\<le> card V}\n\ngoal (1 subgoal):\n 1. finite all_paths", "using finite_lists_length_le[OF finite_vertex_set] walk_in_V infinite_super"], ["proof (prove)\nusing this:\n  all_paths\n  \\<subseteq> {xs. set xs \\<subseteq> V \\<and> length xs \\<le> card V}\n  finite {xs. set xs \\<subseteq> V \\<and> length xs \\<le> ?n}\n  walk ?xs \\<Longrightarrow> set ?xs \\<subseteq> V\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. finite all_paths", "by blast"], ["proof (state)\nthis:\n  finite all_paths\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>context Digraph\\<close>"], ["", "text \\<open>We introduce shorthand notation for a path connecting two vertices.\\<close>"], ["", "definition path_from_to :: \"('a, 'b) Graph_scheme \\<Rightarrow> 'a \\<Rightarrow> 'a Walk \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  (\"_ \\<leadsto>_\\<leadsto>\\<index> _\" [71, 71, 71] 70) where\n  \"path_from_to G v xs w \\<equiv> Digraph.path G xs \\<and> xs \\<noteq> Nil \\<and> hd xs = v \\<and> last xs = w\""], ["", "context Digraph begin"], ["", "lemma path_from_toI [intro]: \"\\<lbrakk> path xs; xs \\<noteq> Nil; hd xs = v; last xs = w \\<rbrakk> \\<Longrightarrow> v \\<leadsto>xs\\<leadsto> w\"\n  and path_from_toE [dest]: \"v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow> path xs \\<and> xs \\<noteq> Nil \\<and> hd xs = v \\<and> last xs = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>path xs; xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n     \\<Longrightarrow> v \\<leadsto>xs\\<leadsto> w) &&&\n    (v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow>\n     path xs \\<and> xs \\<noteq> [] \\<and> hd xs = v \\<and> last xs = w)", "unfolding path_from_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>path xs; xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n     \\<Longrightarrow> path xs \\<and>\n                       xs \\<noteq> [] \\<and>\n                       hd xs = v \\<and> last xs = w) &&&\n    (path xs \\<and>\n     xs \\<noteq> [] \\<and> hd xs = v \\<and> last xs = w \\<Longrightarrow>\n     path xs \\<and> xs \\<noteq> [] \\<and> hd xs = v \\<and> last xs = w)", "by blast+"], ["", "lemma path_from_to_ends: \"v \\<leadsto>(xs @ w # ys)\\<leadsto> w \\<Longrightarrow> ys = Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto>(xs @ w # ys)\\<leadsto> w \\<Longrightarrow> ys = []", "by (metis path_from_toE distinct.simps(2) last.simps last_appendR last_in_set list.discI path_decomp(2))"], ["", "lemma path_from_to_combine:\n  assumes \"v \\<leadsto>(xs @ x # xs')\\<leadsto> w\" \"v' \\<leadsto>(ys @ x # ys')\\<leadsto> w'\" \"set xs \\<inter> set ys' = {}\"\n  shows \"v \\<leadsto>(xs @ x # ys') \\<leadsto> w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto>(xs @ x # ys')\\<leadsto> w'", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. path (xs @ x # ys')\n 2. xs @ x # ys' \\<noteq> []\n 3. hd (xs @ x # ys') = v\n 4. last (xs @ x # ys') = w'", "show \"path (xs @ x # ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (xs @ x # ys')", "by (metis path_from_toE assms(1,2,3) disjoint_insert(1) distinct_append list.sel(1) list.set(2)\n        list.simps(3) path_decomp(2) walk_comp walk_decomp(1) walk_last_edge)"], ["proof (state)\nthis:\n  path (xs @ x # ys')\n\ngoal (3 subgoals):\n 1. xs @ x # ys' \\<noteq> []\n 2. hd (xs @ x # ys') = v\n 3. last (xs @ x # ys') = w'", "show \"hd (xs @ x # ys') = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (xs @ x # ys') = v", "by (metis path_from_toE assms(1) hd_append list.sel(1))"], ["proof (state)\nthis:\n  hd (xs @ x # ys') = v\n\ngoal (2 subgoals):\n 1. xs @ x # ys' \\<noteq> []\n 2. last (xs @ x # ys') = w'", "show \"last (xs @ x # ys') = w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (xs @ x # ys') = w'", "using assms(2)"], ["proof (prove)\nusing this:\n  v' \\<leadsto>(ys @ x # ys')\\<leadsto> w'\n\ngoal (1 subgoal):\n 1. last (xs @ x # ys') = w'", "by auto"], ["proof (state)\nthis:\n  last (xs @ x # ys') = w'\n\ngoal (1 subgoal):\n 1. xs @ x # ys' \\<noteq> []", "qed simp"], ["", "lemma path_from_to_first: \"v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow> v \\<notin> set (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow> v \\<notin> set (tl xs)", "by (metis path_from_toE list.collapse path_first_vertex)"], ["", "lemma path_from_to_first': \"v \\<leadsto>(xs @ x # xs')\\<leadsto> w \\<Longrightarrow> v \\<notin> set xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto>(xs @ x # xs')\\<leadsto> w \\<Longrightarrow>\n    v \\<notin> set xs'", "by (metis path_from_toE append_eq_append_conv2 distinct.simps(2) hd_append list.exhaust_sel\n      list.sel(3) list.set_sel(1,2) list.simps(3) path_disjoint self_append_conv)"], ["", "lemma path_from_to_last: \"v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow> w \\<notin> set (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow> w \\<notin> set (butlast xs)", "by (metis path_from_toE append_butlast_last_id distinct_append not_distinct_conv_prefix)"], ["", "lemma path_from_to_last': \"v \\<leadsto>(xs @ x # xs')\\<leadsto> w \\<Longrightarrow> w \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto>(xs @ x # xs')\\<leadsto> w \\<Longrightarrow>\n    w \\<notin> set xs", "by (metis path_from_toE bex_empty last_appendR last_in_set list.set(1) list.simps(3) path_disjoint)"], ["", "text \\<open>Every walk contains a path connecting the same vertices.\\<close>"], ["", "lemma walk_to_path:\n  assumes \"walk xs\" \"xs \\<noteq> Nil\" \"hd xs = v\" \"last xs = w\"\n  shows \"\\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs", "text \\<open>We prove this by removing loops from @{term xs} until @{term xs} is a path.\n    We want to perform induction over @{term \"length xs\"}, but @{term xs} in\n    @{term \"set ys \\<subseteq> set xs\"} should not be part of the induction hypothesis. To accomplish this,\n    we hide @{term \"set xs\"} behind a definition for this specific part of the goal.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs", "define target_set where \"target_set \\<equiv> set xs\""], ["proof (state)\nthis:\n  target_set \\<equiv> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs", "hence \"set xs \\<subseteq> target_set\""], ["proof (prove)\nusing this:\n  target_set \\<equiv> set xs\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> target_set", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> target_set\n\ngoal (1 subgoal):\n 1. \\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs", "thus \"\\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> target_set\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> target_set\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set", "proof (induct \"length xs\" arbitrary: xs rule: infinite_descent0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "case (smaller n)"], ["proof (state)\nthis:\n  0 < n\n  \\<not> (\\<forall>x.\n             n = length x \\<longrightarrow>\n             set x \\<subseteq> target_set \\<longrightarrow>\n             walk x \\<longrightarrow>\n             x \\<noteq> [] \\<longrightarrow>\n             hd x = v \\<longrightarrow>\n             last x = w \\<longrightarrow>\n             (\\<exists>ys.\n                 v \\<leadsto>ys\\<leadsto> w \\<and>\n                 set ys \\<subseteq> target_set))\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "then"], ["proof (chain)\npicking this:\n  0 < n\n  \\<not> (\\<forall>x.\n             n = length x \\<longrightarrow>\n             set x \\<subseteq> target_set \\<longrightarrow>\n             walk x \\<longrightarrow>\n             x \\<noteq> [] \\<longrightarrow>\n             hd x = v \\<longrightarrow>\n             last x = w \\<longrightarrow>\n             (\\<exists>ys.\n                 v \\<leadsto>ys\\<leadsto> w \\<and>\n                 set ys \\<subseteq> target_set))", "obtain xs where\n      xs: \"n = length xs\" \"walk xs\" \"xs \\<noteq> Nil\" \"hd xs = v\" \"last xs = w\" \"set xs \\<subseteq> target_set\" and\n      hyp: \"\\<not>(\\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set)\""], ["proof (prove)\nusing this:\n  0 < n\n  \\<not> (\\<forall>x.\n             n = length x \\<longrightarrow>\n             set x \\<subseteq> target_set \\<longrightarrow>\n             walk x \\<longrightarrow>\n             x \\<noteq> [] \\<longrightarrow>\n             hd x = v \\<longrightarrow>\n             last x = w \\<longrightarrow>\n             (\\<exists>ys.\n                 v \\<leadsto>ys\\<leadsto> w \\<and>\n                 set ys \\<subseteq> target_set))\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>n = length xs; walk xs; xs \\<noteq> []; hd xs = v;\n         last xs = w; set xs \\<subseteq> target_set;\n         \\<nexists>ys.\n            v \\<leadsto>ys\\<leadsto> w \\<and>\n            set ys \\<subseteq> target_set\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = length xs\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  set xs \\<subseteq> target_set\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "text \\<open>If @{term xs} is not a path, then @{term xs} is not distinct and we can decompose it.\\<close>"], ["proof (state)\nthis:\n  n = length xs\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  set xs \\<subseteq> target_set\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "then"], ["proof (chain)\npicking this:\n  n = length xs\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  set xs \\<subseteq> target_set\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set", "obtain ys rest u\n      where xs_decomp: \"u \\<in> set ys\" \"distinct ys\" \"xs = ys @ u # rest\""], ["proof (prove)\nusing this:\n  n = length xs\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  set xs \\<subseteq> target_set\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n\ngoal (1 subgoal):\n 1. (\\<And>u ys rest.\n        \\<lbrakk>u \\<in> set ys; distinct ys; xs = ys @ u # rest\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_distinct_conv_prefix"], ["proof (prove)\nusing this:\n  n = length xs\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  set xs \\<subseteq> target_set\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n  (\\<not> distinct ?as) =\n  (\\<exists>xs y ys.\n      y \\<in> set xs \\<and> distinct xs \\<and> ?as = xs @ y # ys)\n\ngoal (1 subgoal):\n 1. (\\<And>u ys rest.\n        \\<lbrakk>u \\<in> set ys; distinct ys; xs = ys @ u # rest\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis path_from_toI)"], ["proof (state)\nthis:\n  u \\<in> set ys\n  distinct ys\n  xs = ys @ u # rest\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "text \\<open>@{term u} appears in @{term ys}, so we have a loop in @{term xs} starting from an\n      occurrence of @{term u} in @{term ys} ending in the vertex @{term u} in @{term \"u # rest\"}.\n      We define @{term zs} as @{term xs} without this loop.\\<close>"], ["proof (state)\nthis:\n  u \\<in> set ys\n  distinct ys\n  xs = ys @ u # rest\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "obtain ys' ys_suffix where\n      ys_decomp: \"ys = ys' @ u # ys_suffix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys' ys_suffix.\n        ys = ys' @ u # ys_suffix \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list xs_decomp(1))"], ["proof (state)\nthis:\n  ys = ys' @ u # ys_suffix\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "define zs where \"zs \\<equiv> ys' @ u # rest\""], ["proof (state)\nthis:\n  zs \\<equiv> ys' @ u # rest\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "have \"walk zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk zs", "unfolding zs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. walk (ys' @ u # rest)", "using xs(2) xs_decomp(3) ys_decomp"], ["proof (prove)\nusing this:\n  walk xs\n  xs = ys @ u # rest\n  ys = ys' @ u # ys_suffix\n\ngoal (1 subgoal):\n 1. walk (ys' @ u # rest)", "by (metis walk_decomp list.sel(1) list.simps(3) walk_comp walk_last_edge)"], ["proof (state)\nthis:\n  walk zs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "moreover"], ["proof (state)\nthis:\n  walk zs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "have \"length zs < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length zs < n", "unfolding zs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ys' @ u # rest) < n", "by (simp add: xs(1) xs_decomp(3) ys_decomp)"], ["proof (state)\nthis:\n  length zs < n\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "moreover"], ["proof (state)\nthis:\n  length zs < n\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "have \"hd zs = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd zs = v", "unfolding zs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (ys' @ u # rest) = v", "by (metis append_is_Nil_conv hd_append list.sel(1) xs(4) xs_decomp(3) ys_decomp)"], ["proof (state)\nthis:\n  hd zs = v\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "moreover"], ["proof (state)\nthis:\n  hd zs = v\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "have \"last zs = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last zs = w", "unfolding zs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (ys' @ u # rest) = w", "using xs(5) xs_decomp(3)"], ["proof (prove)\nusing this:\n  last xs = w\n  xs = ys @ u # rest\n\ngoal (1 subgoal):\n 1. last (ys' @ u # rest) = w", "by auto"], ["proof (state)\nthis:\n  last zs = w\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "moreover"], ["proof (state)\nthis:\n  last zs = w\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "have \"set zs \\<subseteq> target_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set zs \\<subseteq> target_set", "unfolding zs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ys' @ u # rest) \\<subseteq> target_set", "using xs(6) xs_decomp(3) ys_decomp"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> target_set\n  xs = ys @ u # rest\n  ys = ys' @ u # ys_suffix\n\ngoal (1 subgoal):\n 1. set (ys' @ u # rest) \\<subseteq> target_set", "by auto"], ["proof (state)\nthis:\n  set zs \\<subseteq> target_set\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "ultimately"], ["proof (chain)\npicking this:\n  walk zs\n  length zs < n\n  hd zs = v\n  last zs = w\n  set zs \\<subseteq> target_set", "show ?case"], ["proof (prove)\nusing this:\n  walk zs\n  length zs < n\n  hd zs = v\n  last zs = w\n  set zs \\<subseteq> target_set\n\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       \\<not> (\\<forall>x.\n                  m = length x \\<longrightarrow>\n                  set x \\<subseteq> target_set \\<longrightarrow>\n                  walk x \\<longrightarrow>\n                  x \\<noteq> [] \\<longrightarrow>\n                  hd x = v \\<longrightarrow>\n                  last x = w \\<longrightarrow>\n                  (\\<exists>ys.\n                      v \\<leadsto>ys\\<leadsto> w \\<and>\n                      set ys \\<subseteq> target_set))", "using zs_def hyp"], ["proof (prove)\nusing this:\n  walk zs\n  length zs < n\n  hd zs = v\n  last zs = w\n  set zs \\<subseteq> target_set\n  zs \\<equiv> ys' @ u # rest\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       \\<not> (\\<forall>x.\n                  m = length x \\<longrightarrow>\n                  set x \\<subseteq> target_set \\<longrightarrow>\n                  walk x \\<longrightarrow>\n                  x \\<noteq> [] \\<longrightarrow>\n                  hd x = v \\<longrightarrow>\n                  last x = w \\<longrightarrow>\n                  (\\<exists>ys.\n                      v \\<leadsto>ys\\<leadsto> w \\<and>\n                      set ys \\<subseteq> target_set))", "by blast"], ["proof (state)\nthis:\n  \\<exists>m<n.\n     \\<not> (\\<forall>x.\n                m = length x \\<longrightarrow>\n                set x \\<subseteq> target_set \\<longrightarrow>\n                walk x \\<longrightarrow>\n                x \\<noteq> [] \\<longrightarrow>\n                hd x = v \\<longrightarrow>\n                last x = w \\<longrightarrow>\n                (\\<exists>ys.\n                    v \\<leadsto>ys\\<leadsto> w \\<and>\n                    set ys \\<subseteq> target_set))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set", "qed simp"], ["proof (state)\nthis:\n  \\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Edges of Walks\\<close>"], ["", "text \\<open>The set of edges on a walk.  Note that this is empty for walks of length 0 or 1.\\<close>"], ["", "definition edges_of_walk :: \"'a Walk \\<Rightarrow> 'a Edge set\" where\n  \"edges_of_walk xs = { (v,w) | v w xs_pre xs_post. xs = xs_pre @ v # w # xs_post }\""], ["", "lemma edges_of_walkE: \"(v,w) \\<in> edges_of_walk xs \\<Longrightarrow> \\<exists>xs_pre xs_post. xs = xs_pre @ v # w # xs_post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk xs \\<Longrightarrow>\n    \\<exists>xs_pre xs_post. xs = xs_pre @ v # w # xs_post", "unfolding edges_of_walk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w)\n    \\<in> {uu_.\n           \\<exists>v w xs_pre xs_post.\n              uu_ = (v, w) \\<and>\n              xs = xs_pre @ v # w # xs_post} \\<Longrightarrow>\n    \\<exists>xs_pre xs_post. xs = xs_pre @ v # w # xs_post", "by blast"], ["", "lemma edges_of_walk_in_E: \"walk xs \\<Longrightarrow> edges_of_walk xs \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> edges_of_walk xs \\<subseteq> E", "unfolding edges_of_walk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow>\n    {uu_.\n     \\<exists>v w xs_pre xs_post.\n        uu_ = (v, w) \\<and> xs = xs_pre @ v # w # xs_post}\n    \\<subseteq> E", "using walk_middle_edge"], ["proof (prove)\nusing this:\n  walk (?xs @ ?v # ?w # ?ys) \\<Longrightarrow> ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow>\n    {uu_.\n     \\<exists>v w xs_pre xs_post.\n        uu_ = (v, w) \\<and> xs = xs_pre @ v # w # xs_post}\n    \\<subseteq> E", "by auto"], ["", "lemma edges_of_walk_finite: \"walk xs \\<Longrightarrow> finite (edges_of_walk xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> finite (edges_of_walk xs)", "using edges_of_walk_in_E finite_edge_set finite_subset"], ["proof (prove)\nusing this:\n  walk ?xs \\<Longrightarrow> edges_of_walk ?xs \\<subseteq> E\n  finite E\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> finite (edges_of_walk xs)", "by blast"], ["", "lemma edges_of_walk_empty: \"edges_of_walk [] = {}\" \"edges_of_walk [v] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk [] = {} &&& edges_of_walk [v] = {}", "unfolding edges_of_walk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>v w xs_pre xs_post.\n        uu_ = (v, w) \\<and> [] = xs_pre @ v # w # xs_post} =\n    {} &&&\n    {uu_.\n     \\<exists>va w xs_pre xs_post.\n        uu_ = (va, w) \\<and> [v] = xs_pre @ va # w # xs_post} =\n    {}", "by simp_all"], ["", "lemma edges_of_walk_2: \"edges_of_walk [v,w] = {(v,w)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk [v, w] = {(v, w)}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. edges_of_walk [v, w] \\<subseteq> {(v, w)}\n 2. {(v, w)} \\<subseteq> edges_of_walk [v, w]", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. edges_of_walk [v, w] \\<subseteq> {(v, w)}\n 2. {(v, w)} \\<subseteq> edges_of_walk [v, w]", "fix v' w'"], ["proof (state)\ngoal (2 subgoals):\n 1. edges_of_walk [v, w] \\<subseteq> {(v, w)}\n 2. {(v, w)} \\<subseteq> edges_of_walk [v, w]", "assume \"(v', w') \\<in> edges_of_walk [v,w]\""], ["proof (state)\nthis:\n  (v', w') \\<in> edges_of_walk [v, w]\n\ngoal (2 subgoals):\n 1. edges_of_walk [v, w] \\<subseteq> {(v, w)}\n 2. {(v, w)} \\<subseteq> edges_of_walk [v, w]", "then"], ["proof (chain)\npicking this:\n  (v', w') \\<in> edges_of_walk [v, w]", "obtain xs_pre xs_post where xs_decomp: \"[v,w] = xs_pre @ v' # w' # xs_post\""], ["proof (prove)\nusing this:\n  (v', w') \\<in> edges_of_walk [v, w]\n\ngoal (1 subgoal):\n 1. (\\<And>xs_pre xs_post.\n        [v, w] = xs_pre @ v' # w' # xs_post \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using edges_of_walkE[of v' w' \"[v,w]\"]"], ["proof (prove)\nusing this:\n  (v', w') \\<in> edges_of_walk [v, w]\n  (v', w') \\<in> edges_of_walk [v, w] \\<Longrightarrow>\n  \\<exists>xs_pre xs_post. [v, w] = xs_pre @ v' # w' # xs_post\n\ngoal (1 subgoal):\n 1. (\\<And>xs_pre xs_post.\n        [v, w] = xs_pre @ v' # w' # xs_post \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  [v, w] = xs_pre @ v' # w' # xs_post\n\ngoal (2 subgoals):\n 1. edges_of_walk [v, w] \\<subseteq> {(v, w)}\n 2. {(v, w)} \\<subseteq> edges_of_walk [v, w]", "then"], ["proof (chain)\npicking this:\n  [v, w] = xs_pre @ v' # w' # xs_post", "have \"xs_pre = Nil\""], ["proof (prove)\nusing this:\n  [v, w] = xs_pre @ v' # w' # xs_post\n\ngoal (1 subgoal):\n 1. xs_pre = []", "by (metis Nil_is_append_conv butlast.simps(2) butlast_append list.discI)"], ["proof (state)\nthis:\n  xs_pre = []\n\ngoal (2 subgoals):\n 1. edges_of_walk [v, w] \\<subseteq> {(v, w)}\n 2. {(v, w)} \\<subseteq> edges_of_walk [v, w]", "then"], ["proof (chain)\npicking this:\n  xs_pre = []", "have \"(v',w') \\<in> {(v,w)}\""], ["proof (prove)\nusing this:\n  xs_pre = []\n\ngoal (1 subgoal):\n 1. (v', w') \\<in> {(v, w)}", "using xs_decomp"], ["proof (prove)\nusing this:\n  xs_pre = []\n  [v, w] = xs_pre @ v' # w' # xs_post\n\ngoal (1 subgoal):\n 1. (v', w') \\<in> {(v, w)}", "by simp"], ["proof (state)\nthis:\n  (v', w') \\<in> {(v, w)}\n\ngoal (2 subgoals):\n 1. edges_of_walk [v, w] \\<subseteq> {(v, w)}\n 2. {(v, w)} \\<subseteq> edges_of_walk [v, w]", "}"], ["proof (state)\nthis:\n  (?v'2, ?w'2) \\<in> edges_of_walk [v, w] \\<Longrightarrow>\n  (?v'2, ?w'2) \\<in> {(v, w)}\n\ngoal (2 subgoals):\n 1. edges_of_walk [v, w] \\<subseteq> {(v, w)}\n 2. {(v, w)} \\<subseteq> edges_of_walk [v, w]", "then"], ["proof (chain)\npicking this:\n  (?v'2, ?w'2) \\<in> edges_of_walk [v, w] \\<Longrightarrow>\n  (?v'2, ?w'2) \\<in> {(v, w)}", "show \"edges_of_walk [v, w] \\<subseteq> {(v, w)}\""], ["proof (prove)\nusing this:\n  (?v'2, ?w'2) \\<in> edges_of_walk [v, w] \\<Longrightarrow>\n  (?v'2, ?w'2) \\<in> {(v, w)}\n\ngoal (1 subgoal):\n 1. edges_of_walk [v, w] \\<subseteq> {(v, w)}", "by (simp add: subrelI)"], ["proof (state)\nthis:\n  edges_of_walk [v, w] \\<subseteq> {(v, w)}\n\ngoal (1 subgoal):\n 1. {(v, w)} \\<subseteq> edges_of_walk [v, w]", "show \"{(v, w)} \\<subseteq> edges_of_walk [v, w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(v, w)} \\<subseteq> edges_of_walk [v, w]", "unfolding edges_of_walk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(v, w)}\n    \\<subseteq> {uu_.\n                 \\<exists>va wa xs_pre xs_post.\n                    uu_ = (va, wa) \\<and>\n                    [v, w] = xs_pre @ va # wa # xs_post}", "by blast"], ["proof (state)\nthis:\n  {(v, w)} \\<subseteq> edges_of_walk [v, w]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma edges_of_walk_edge: \"\\<lbrakk> walk xs; (v,w) \\<in> edges_of_walk xs \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk xs; (v, w) \\<in> edges_of_walk xs\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> w", "using edges_of_walkE walk_middle_edge"], ["proof (prove)\nusing this:\n  (?v, ?w) \\<in> edges_of_walk ?xs \\<Longrightarrow>\n  \\<exists>xs_pre xs_post. ?xs = xs_pre @ ?v # ?w # xs_post\n  walk (?xs @ ?v # ?w # ?ys) \\<Longrightarrow> ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>walk xs; (v, w) \\<in> edges_of_walk xs\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> w", "by fastforce"], ["", "lemma edges_of_walk_middle [simp]: \"(v,w) \\<in> edges_of_walk (xs @ v # w # xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (xs @ v # w # xs')", "unfolding edges_of_walk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w)\n    \\<in> {uu_.\n           \\<exists>va wa xs_pre xs_post.\n              uu_ = (va, wa) \\<and>\n              xs @ v # w # xs' = xs_pre @ va # wa # xs_post}", "by blast"], ["", "lemma edges_of_comp1: \"edges_of_walk xs \\<subseteq> edges_of_walk (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk xs \\<subseteq> edges_of_walk (xs @ ys)", "unfolding edges_of_walk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>v w xs_pre xs_post.\n        uu_ = (v, w) \\<and> xs = xs_pre @ v # w # xs_post}\n    \\<subseteq> {uu_.\n                 \\<exists>v w xs_pre xs_post.\n                    uu_ = (v, w) \\<and> xs @ ys = xs_pre @ v # w # xs_post}", "by force"], ["", "lemma edges_of_comp2: \"edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)", "fix v w"], ["proof (state)\ngoal (1 subgoal):\n 1. edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)", "assume \"(v,w) \\<in> edges_of_walk ys\""], ["proof (state)\nthis:\n  (v, w) \\<in> edges_of_walk ys\n\ngoal (1 subgoal):\n 1. edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> edges_of_walk ys", "have \"\\<exists>ys_pre ys_post. ys = ys_pre @ v # w # ys_post\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> edges_of_walk ys\n\ngoal (1 subgoal):\n 1. \\<exists>ys_pre ys_post. ys = ys_pre @ v # w # ys_post", "by (meson edges_of_walkE)"], ["proof (state)\nthis:\n  \\<exists>ys_pre ys_post. ys = ys_pre @ v # w # ys_post\n\ngoal (1 subgoal):\n 1. edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys_pre ys_post. ys = ys_pre @ v # w # ys_post", "have \"(v,w) \\<in> edges_of_walk (xs @ ys)\""], ["proof (prove)\nusing this:\n  \\<exists>ys_pre ys_post. ys = ys_pre @ v # w # ys_post\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (xs @ ys)", "by (metis (mono_tags, lifting) append.assoc edges_of_walk_def mem_Collect_eq)"], ["proof (state)\nthis:\n  (v, w) \\<in> edges_of_walk (xs @ ys)\n\ngoal (1 subgoal):\n 1. edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)", "}"], ["proof (state)\nthis:\n  (?v2, ?w2) \\<in> edges_of_walk ys \\<Longrightarrow>\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ ys)\n\ngoal (1 subgoal):\n 1. edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)", "then"], ["proof (chain)\npicking this:\n  (?v2, ?w2) \\<in> edges_of_walk ys \\<Longrightarrow>\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  (?v2, ?w2) \\<in> edges_of_walk ys \\<Longrightarrow>\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ ys)\n\ngoal (1 subgoal):\n 1. edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)", "by (simp add: subrelI)"], ["proof (state)\nthis:\n  edges_of_walk ys \\<subseteq> edges_of_walk (xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma walk_edges_decomp_simple:\n  \"edges_of_walk (v # w # xs) = {(v,w)} \\<union> edges_of_walk (w # xs)\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk (v # w # xs) = {(v, w)} \\<union> edges_of_walk (w # xs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)\n 2. {(v, w)} \\<union> edges_of_walk (w # xs)\n    \\<subseteq> edges_of_walk (v # w # xs)", "have \"edges_of_walk (w # xs) \\<subseteq> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk (w # xs) \\<subseteq> edges_of_walk (v # w # xs)", "using edges_of_comp2[of \"w # xs\" \"[v]\"]"], ["proof (prove)\nusing this:\n  edges_of_walk (w # xs) \\<subseteq> edges_of_walk ([v] @ w # xs)\n\ngoal (1 subgoal):\n 1. edges_of_walk (w # xs) \\<subseteq> edges_of_walk (v # w # xs)", "by simp"], ["proof (state)\nthis:\n  edges_of_walk (w # xs) \\<subseteq> edges_of_walk (v # w # xs)\n\ngoal (2 subgoals):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)\n 2. {(v, w)} \\<union> edges_of_walk (w # xs)\n    \\<subseteq> edges_of_walk (v # w # xs)", "moreover"], ["proof (state)\nthis:\n  edges_of_walk (w # xs) \\<subseteq> edges_of_walk (v # w # xs)\n\ngoal (2 subgoals):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)\n 2. {(v, w)} \\<union> edges_of_walk (w # xs)\n    \\<subseteq> edges_of_walk (v # w # xs)", "have \"(v,w) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (v # w # xs)", "by (metis append_eq_Cons_conv edges_of_walk_middle)"], ["proof (state)\nthis:\n  (v, w) \\<in> edges_of_walk (v # w # xs)\n\ngoal (2 subgoals):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)\n 2. {(v, w)} \\<union> edges_of_walk (w # xs)\n    \\<subseteq> edges_of_walk (v # w # xs)", "ultimately"], ["proof (chain)\npicking this:\n  edges_of_walk (w # xs) \\<subseteq> edges_of_walk (v # w # xs)\n  (v, w) \\<in> edges_of_walk (v # w # xs)", "show \"?B \\<subseteq> ?A\""], ["proof (prove)\nusing this:\n  edges_of_walk (w # xs) \\<subseteq> edges_of_walk (v # w # xs)\n  (v, w) \\<in> edges_of_walk (v # w # xs)\n\ngoal (1 subgoal):\n 1. {(v, w)} \\<union> edges_of_walk (w # xs)\n    \\<subseteq> edges_of_walk (v # w # xs)", "by blast"], ["proof (state)\nthis:\n  {(v, w)} \\<union> edges_of_walk (w # xs)\n  \\<subseteq> edges_of_walk (v # w # xs)\n\ngoal (1 subgoal):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)", "{"], ["proof (state)\nthis:\n  {(v, w)} \\<union> edges_of_walk (w # xs)\n  \\<subseteq> edges_of_walk (v # w # xs)\n\ngoal (1 subgoal):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)", "fix v' w'"], ["proof (state)\ngoal (1 subgoal):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)", "assume \"(v',w') \\<in> ?A\""], ["proof (state)\nthis:\n  (v', w') \\<in> edges_of_walk (v # w # xs)\n\ngoal (1 subgoal):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)", "then"], ["proof (chain)\npicking this:\n  (v', w') \\<in> edges_of_walk (v # w # xs)", "obtain xs_pre xs_post where xs_decomp: \"v # w # xs = xs_pre @ v' # w' # xs_post\""], ["proof (prove)\nusing this:\n  (v', w') \\<in> edges_of_walk (v # w # xs)\n\ngoal (1 subgoal):\n 1. (\\<And>xs_pre xs_post.\n        v # w # xs = xs_pre @ v' # w' # xs_post \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using edges_of_walkE"], ["proof (prove)\nusing this:\n  (v', w') \\<in> edges_of_walk (v # w # xs)\n  (?v, ?w) \\<in> edges_of_walk ?xs \\<Longrightarrow>\n  \\<exists>xs_pre xs_post. ?xs = xs_pre @ ?v # ?w # xs_post\n\ngoal (1 subgoal):\n 1. (\\<And>xs_pre xs_post.\n        v # w # xs = xs_pre @ v' # w' # xs_post \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v # w # xs = xs_pre @ v' # w' # xs_post\n\ngoal (1 subgoal):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)", "have \"(v',w') \\<in> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)\n 2. \\<not> ?P \\<Longrightarrow>\n    (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)", "assume \"xs_pre = Nil\""], ["proof (state)\nthis:\n  xs_pre = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)\n 2. \\<not> ?P \\<Longrightarrow>\n    (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)", "then"], ["proof (chain)\npicking this:\n  xs_pre = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs_pre = []\n\ngoal (1 subgoal):\n 1. (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)", "using xs_decomp"], ["proof (prove)\nusing this:\n  xs_pre = []\n  v # w # xs = xs_pre @ v' # w' # xs_post\n\ngoal (1 subgoal):\n 1. (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)", "by auto"], ["proof (state)\nthis:\n  (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)\n\ngoal (1 subgoal):\n 1. xs_pre \\<noteq> [] \\<Longrightarrow>\n    (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs_pre \\<noteq> [] \\<Longrightarrow>\n    (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)", "assume \"xs_pre \\<noteq> Nil\""], ["proof (state)\nthis:\n  xs_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs_pre \\<noteq> [] \\<Longrightarrow>\n    (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)", "then"], ["proof (chain)\npicking this:\n  xs_pre \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)", "by (metis Cons_eq_append_conv UnI2 edges_of_walk_middle xs_decomp)"], ["proof (state)\nthis:\n  (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v', w') \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)\n\ngoal (1 subgoal):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)", "}"], ["proof (state)\nthis:\n  (?v'2, ?w'2) \\<in> edges_of_walk (v # w # xs) \\<Longrightarrow>\n  (?v'2, ?w'2) \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)\n\ngoal (1 subgoal):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)", "then"], ["proof (chain)\npicking this:\n  (?v'2, ?w'2) \\<in> edges_of_walk (v # w # xs) \\<Longrightarrow>\n  (?v'2, ?w'2) \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)", "show \"?A \\<subseteq> ?B\""], ["proof (prove)\nusing this:\n  (?v'2, ?w'2) \\<in> edges_of_walk (v # w # xs) \\<Longrightarrow>\n  (?v'2, ?w'2) \\<in> {(v, w)} \\<union> edges_of_walk (w # xs)\n\ngoal (1 subgoal):\n 1. edges_of_walk (v # w # xs)\n    \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)", "by auto"], ["proof (state)\nthis:\n  edges_of_walk (v # w # xs)\n  \\<subseteq> {(v, w)} \\<union> edges_of_walk (w # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma walk_edges_decomp:\n  \"edges_of_walk (xs @ x # xs') = edges_of_walk (xs @ [x]) \\<union> edges_of_walk (x # xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ x # xs') =\n    edges_of_walk (xs @ [x]) \\<union> edges_of_walk (x # xs')", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. edges_of_walk ([] @ x # xs') =\n    edges_of_walk ([] @ [x]) \\<union> edges_of_walk (x # xs')\n 2. \\<And>a xs.\n       edges_of_walk (xs @ x # xs') =\n       edges_of_walk (xs @ [x]) \\<union>\n       edges_of_walk (x # xs') \\<Longrightarrow>\n       edges_of_walk ((a # xs) @ x # xs') =\n       edges_of_walk ((a # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "case (Cons v xs)"], ["proof (state)\nthis:\n  edges_of_walk (xs @ x # xs') =\n  edges_of_walk (xs @ [x]) \\<union> edges_of_walk (x # xs')\n\ngoal (2 subgoals):\n 1. edges_of_walk ([] @ x # xs') =\n    edges_of_walk ([] @ [x]) \\<union> edges_of_walk (x # xs')\n 2. \\<And>a xs.\n       edges_of_walk (xs @ x # xs') =\n       edges_of_walk (xs @ [x]) \\<union>\n       edges_of_walk (x # xs') \\<Longrightarrow>\n       edges_of_walk ((a # xs) @ x # xs') =\n       edges_of_walk ((a # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')\n 2. \\<not> ?P \\<Longrightarrow>\n    edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "assume \"xs = Nil\""], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')\n 2. \\<not> ?P \\<Longrightarrow>\n    edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "then"], ["proof (chain)\npicking this:\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "using edges_of_walk_2 walk_edges_decomp_simple"], ["proof (prove)\nusing this:\n  xs = []\n  edges_of_walk [?v, ?w] = {(?v, ?w)}\n  edges_of_walk (?v # ?w # ?xs) =\n  {(?v, ?w)} \\<union> edges_of_walk (?w # ?xs)\n\ngoal (1 subgoal):\n 1. edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "by auto"], ["proof (state)\nthis:\n  edges_of_walk ((v # xs) @ x # xs') =\n  edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "assume \"xs \\<noteq> Nil\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain w xs_post where \"xs = w # xs_post\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>w xs_post.\n        xs = w # xs_post \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using list.exhaust_sel"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  \\<lbrakk>?list = [] \\<Longrightarrow> ?P;\n   ?list = hd ?list # tl ?list \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>w xs_post.\n        xs = w # xs_post \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = w # xs_post\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "then"], ["proof (chain)\npicking this:\n  xs = w # xs_post", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = w # xs_post\n\ngoal (1 subgoal):\n 1. edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "using Cons.hyps walk_edges_decomp_simple"], ["proof (prove)\nusing this:\n  xs = w # xs_post\n  edges_of_walk (xs @ x # xs') =\n  edges_of_walk (xs @ [x]) \\<union> edges_of_walk (x # xs')\n  edges_of_walk (?v # ?w # ?xs) =\n  {(?v, ?w)} \\<union> edges_of_walk (?w # ?xs)\n\ngoal (1 subgoal):\n 1. edges_of_walk ((v # xs) @ x # xs') =\n    edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')", "by auto"], ["proof (state)\nthis:\n  edges_of_walk ((v # xs) @ x # xs') =\n  edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  edges_of_walk ((v # xs) @ x # xs') =\n  edges_of_walk ((v # xs) @ [x]) \\<union> edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. edges_of_walk ([] @ x # xs') =\n    edges_of_walk ([] @ [x]) \\<union> edges_of_walk (x # xs')", "qed (simp add: edges_of_walk_empty(2))"], ["", "lemma walk_edges_decomp':\n  \"edges_of_walk (xs @ v # w # xs') = edges_of_walk (xs @ [v]) \\<union> {(v,w)} \\<union> edges_of_walk (w # xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ v # w # xs') =\n    edges_of_walk (xs @ [v]) \\<union> {(v, w)} \\<union>\n    edges_of_walk (w # xs')", "using walk_edges_decomp walk_edges_decomp_simple"], ["proof (prove)\nusing this:\n  edges_of_walk (?xs @ ?x # ?xs') =\n  edges_of_walk (?xs @ [?x]) \\<union> edges_of_walk (?x # ?xs')\n  edges_of_walk (?v # ?w # ?xs) =\n  {(?v, ?w)} \\<union> edges_of_walk (?w # ?xs)\n\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ v # w # xs') =\n    edges_of_walk (xs @ [v]) \\<union> {(v, w)} \\<union>\n    edges_of_walk (w # xs')", "by (metis sup.assoc)"], ["", "lemma walk_edges_vertices: assumes \"(v, w) \\<in> edges_of_walk xs\" shows \"v \\<in> set xs\" \"w \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set xs &&& w \\<in> set xs", "using assms edges_of_walkE"], ["proof (prove)\nusing this:\n  (v, w) \\<in> edges_of_walk xs\n  (?v, ?w) \\<in> edges_of_walk ?xs \\<Longrightarrow>\n  \\<exists>xs_pre xs_post. ?xs = xs_pre @ ?v # ?w # xs_post\n\ngoal (1 subgoal):\n 1. v \\<in> set xs &&& w \\<in> set xs", "by force+"], ["", "lemma walk_edges_subset:\n  assumes edges_subsets: \"edges_of_walk xs \\<subseteq> edges_of_walk ys\"\n    and non_trivial: \"tl xs \\<noteq> Nil\"\n  shows \"set xs \\<subseteq> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ys", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> set ys", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> set ys", "assume \"v \\<in> set xs\""], ["proof (state)\nthis:\n  v \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> set ys", "then"], ["proof (chain)\npicking this:\n  v \\<in> set xs", "obtain xs_pre xs_post where\n    xs_decomp: \"xs = xs_pre @ v # xs_post\""], ["proof (prove)\nusing this:\n  v \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs_pre xs_post.\n        xs = xs_pre @ v # xs_post \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = xs_pre @ v # xs_post\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> set ys", "show \"v \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set ys", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> set ys\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> set ys", "assume \"xs_pre = Nil\""], ["proof (state)\nthis:\n  xs_pre = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> set ys\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> set ys", "then"], ["proof (chain)\npicking this:\n  xs_pre = []", "have \"xs_post \\<noteq> Nil\""], ["proof (prove)\nusing this:\n  xs_pre = []\n\ngoal (1 subgoal):\n 1. xs_post \\<noteq> []", "using xs_decomp non_trivial"], ["proof (prove)\nusing this:\n  xs_pre = []\n  xs = xs_pre @ v # xs_post\n  tl xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs_post \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs_post \\<noteq> []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> set ys\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> set ys", "then"], ["proof (chain)\npicking this:\n  xs_post \\<noteq> []", "have \"xs = xs_pre @ v # hd xs_post # tl xs_post\""], ["proof (prove)\nusing this:\n  xs_post \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs = xs_pre @ v # hd xs_post # tl xs_post", "by (simp add: xs_decomp)"], ["proof (state)\nthis:\n  xs = xs_pre @ v # hd xs_post # tl xs_post\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> set ys\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> set ys", "then"], ["proof (chain)\npicking this:\n  xs = xs_pre @ v # hd xs_post # tl xs_post", "have \"(v, hd xs_post) \\<in> edges_of_walk xs\""], ["proof (prove)\nusing this:\n  xs = xs_pre @ v # hd xs_post # tl xs_post\n\ngoal (1 subgoal):\n 1. (v, hd xs_post) \\<in> edges_of_walk xs", "using edges_of_walk_def"], ["proof (prove)\nusing this:\n  xs = xs_pre @ v # hd xs_post # tl xs_post\n  edges_of_walk ?xs =\n  {uu_.\n   \\<exists>v w xs_pre xs_post.\n      uu_ = (v, w) \\<and> ?xs = xs_pre @ v # w # xs_post}\n\ngoal (1 subgoal):\n 1. (v, hd xs_post) \\<in> edges_of_walk xs", "by auto"], ["proof (state)\nthis:\n  (v, hd xs_post) \\<in> edges_of_walk xs\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> v \\<in> set ys\n 2. \\<not> ?P \\<Longrightarrow> v \\<in> set ys", "then"], ["proof (chain)\npicking this:\n  (v, hd xs_post) \\<in> edges_of_walk xs", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, hd xs_post) \\<in> edges_of_walk xs\n\ngoal (1 subgoal):\n 1. v \\<in> set ys", "using walk_edges_vertices(1) edges_subsets"], ["proof (prove)\nusing this:\n  (v, hd xs_post) \\<in> edges_of_walk xs\n  (?v, ?w) \\<in> edges_of_walk ?xs \\<Longrightarrow> ?v \\<in> set ?xs\n  edges_of_walk xs \\<subseteq> edges_of_walk ys\n\ngoal (1 subgoal):\n 1. v \\<in> set ys", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> set ys\n\ngoal (1 subgoal):\n 1. xs_pre \\<noteq> [] \\<Longrightarrow> v \\<in> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs_pre \\<noteq> [] \\<Longrightarrow> v \\<in> set ys", "assume \"xs_pre \\<noteq> Nil\""], ["proof (state)\nthis:\n  xs_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs_pre \\<noteq> [] \\<Longrightarrow> v \\<in> set ys", "then"], ["proof (chain)\npicking this:\n  xs_pre \\<noteq> []", "have \"xs = butlast xs_pre @ last xs_pre # v # xs_post\""], ["proof (prove)\nusing this:\n  xs_pre \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs = butlast xs_pre @ last xs_pre # v # xs_post", "by (simp add: xs_decomp)"], ["proof (state)\nthis:\n  xs = butlast xs_pre @ last xs_pre # v # xs_post\n\ngoal (1 subgoal):\n 1. xs_pre \\<noteq> [] \\<Longrightarrow> v \\<in> set ys", "then"], ["proof (chain)\npicking this:\n  xs = butlast xs_pre @ last xs_pre # v # xs_post", "have \"(last xs_pre, v) \\<in> edges_of_walk xs\""], ["proof (prove)\nusing this:\n  xs = butlast xs_pre @ last xs_pre # v # xs_post\n\ngoal (1 subgoal):\n 1. (last xs_pre, v) \\<in> edges_of_walk xs", "using edges_of_walk_def"], ["proof (prove)\nusing this:\n  xs = butlast xs_pre @ last xs_pre # v # xs_post\n  edges_of_walk ?xs =\n  {uu_.\n   \\<exists>v w xs_pre xs_post.\n      uu_ = (v, w) \\<and> ?xs = xs_pre @ v # w # xs_post}\n\ngoal (1 subgoal):\n 1. (last xs_pre, v) \\<in> edges_of_walk xs", "by auto"], ["proof (state)\nthis:\n  (last xs_pre, v) \\<in> edges_of_walk xs\n\ngoal (1 subgoal):\n 1. xs_pre \\<noteq> [] \\<Longrightarrow> v \\<in> set ys", "then"], ["proof (chain)\npicking this:\n  (last xs_pre, v) \\<in> edges_of_walk xs", "show ?thesis"], ["proof (prove)\nusing this:\n  (last xs_pre, v) \\<in> edges_of_walk xs\n\ngoal (1 subgoal):\n 1. v \\<in> set ys", "using walk_edges_vertices(2) edges_subsets"], ["proof (prove)\nusing this:\n  (last xs_pre, v) \\<in> edges_of_walk xs\n  (?v, ?w) \\<in> edges_of_walk ?xs \\<Longrightarrow> ?w \\<in> set ?xs\n  edges_of_walk xs \\<subseteq> edges_of_walk ys\n\ngoal (1 subgoal):\n 1. v \\<in> set ys", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> set ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> set ys\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A path has no repeated vertices, so if we split a path at an edge we find that the two pieces\n  do not contain this edge any more.\n\\<close>"], ["", "lemma path_edges:\n  assumes \"path xs\" \"(v,w) \\<in> edges_of_walk xs\"\n  shows \"\\<exists>xs_pre xs_post. xs = xs_pre @ v # w # xs_post\n    \\<and> (v,w) \\<notin> edges_of_walk (xs_pre @ [v])\n    \\<and> (v,w) \\<notin> edges_of_walk (w # xs_post)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs_pre xs_post.\n       xs = xs_pre @ v # w # xs_post \\<and>\n       (v, w) \\<notin> edges_of_walk (xs_pre @ [v]) \\<and>\n       (v, w) \\<notin> edges_of_walk (w # xs_post)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs_pre xs_post.\n       xs = xs_pre @ v # w # xs_post \\<and>\n       (v, w) \\<notin> edges_of_walk (xs_pre @ [v]) \\<and>\n       (v, w) \\<notin> edges_of_walk (w # xs_post)", "obtain xs_pre xs_post where\n    xs_decomp: \"xs = xs_pre @ v # w # xs_post\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs_pre xs_post.\n        xs = xs_pre @ v # w # xs_post \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(2) edges_of_walkE)"], ["proof (state)\nthis:\n  xs = xs_pre @ v # w # xs_post\n\ngoal (1 subgoal):\n 1. \\<exists>xs_pre xs_post.\n       xs = xs_pre @ v # w # xs_post \\<and>\n       (v, w) \\<notin> edges_of_walk (xs_pre @ [v]) \\<and>\n       (v, w) \\<notin> edges_of_walk (w # xs_post)", "then"], ["proof (chain)\npicking this:\n  xs = xs_pre @ v # w # xs_post", "have \"(v,w) \\<notin> edges_of_walk (xs_pre @ [v])\""], ["proof (prove)\nusing this:\n  xs = xs_pre @ v # w # xs_post\n\ngoal (1 subgoal):\n 1. (v, w) \\<notin> edges_of_walk (xs_pre @ [v])", "using assms(1) edges_of_walkE"], ["proof (prove)\nusing this:\n  xs = xs_pre @ v # w # xs_post\n  path xs\n  (?v, ?w) \\<in> edges_of_walk ?xs \\<Longrightarrow>\n  \\<exists>xs_pre xs_post. ?xs = xs_pre @ ?v # ?w # xs_post\n\ngoal (1 subgoal):\n 1. (v, w) \\<notin> edges_of_walk (xs_pre @ [v])", "by (metis path_from_to_ends list.discI path_decomp' path_from_toI snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  (v, w) \\<notin> edges_of_walk (xs_pre @ [v])\n\ngoal (1 subgoal):\n 1. \\<exists>xs_pre xs_post.\n       xs = xs_pre @ v # w # xs_post \\<and>\n       (v, w) \\<notin> edges_of_walk (xs_pre @ [v]) \\<and>\n       (v, w) \\<notin> edges_of_walk (w # xs_post)", "moreover"], ["proof (state)\nthis:\n  (v, w) \\<notin> edges_of_walk (xs_pre @ [v])\n\ngoal (1 subgoal):\n 1. \\<exists>xs_pre xs_post.\n       xs = xs_pre @ v # w # xs_post \\<and>\n       (v, w) \\<notin> edges_of_walk (xs_pre @ [v]) \\<and>\n       (v, w) \\<notin> edges_of_walk (w # xs_post)", "have \"(v,w) \\<notin> edges_of_walk (w # xs_post)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<notin> edges_of_walk (w # xs_post)", "using  assms(1)"], ["proof (prove)\nusing this:\n  path xs\n\ngoal (1 subgoal):\n 1. (v, w) \\<notin> edges_of_walk (w # xs_post)", "by (metis edges_of_walkE in_set_conv_decomp path_decomp(2) path_first_vertex xs_decomp)"], ["proof (state)\nthis:\n  (v, w) \\<notin> edges_of_walk (w # xs_post)\n\ngoal (1 subgoal):\n 1. \\<exists>xs_pre xs_post.\n       xs = xs_pre @ v # w # xs_post \\<and>\n       (v, w) \\<notin> edges_of_walk (xs_pre @ [v]) \\<and>\n       (v, w) \\<notin> edges_of_walk (w # xs_post)", "ultimately"], ["proof (chain)\npicking this:\n  (v, w) \\<notin> edges_of_walk (xs_pre @ [v])\n  (v, w) \\<notin> edges_of_walk (w # xs_post)", "show ?thesis"], ["proof (prove)\nusing this:\n  (v, w) \\<notin> edges_of_walk (xs_pre @ [v])\n  (v, w) \\<notin> edges_of_walk (w # xs_post)\n\ngoal (1 subgoal):\n 1. \\<exists>xs_pre xs_post.\n       xs = xs_pre @ v # w # xs_post \\<and>\n       (v, w) \\<notin> edges_of_walk (xs_pre @ [v]) \\<and>\n       (v, w) \\<notin> edges_of_walk (w # xs_post)", "using xs_decomp"], ["proof (prove)\nusing this:\n  (v, w) \\<notin> edges_of_walk (xs_pre @ [v])\n  (v, w) \\<notin> edges_of_walk (w # xs_post)\n  xs = xs_pre @ v # w # xs_post\n\ngoal (1 subgoal):\n 1. \\<exists>xs_pre xs_post.\n       xs = xs_pre @ v # w # xs_post \\<and>\n       (v, w) \\<notin> edges_of_walk (xs_pre @ [v]) \\<and>\n       (v, w) \\<notin> edges_of_walk (w # xs_post)", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs_pre xs_post.\n     xs = xs_pre @ v # w # xs_post \\<and>\n     (v, w) \\<notin> edges_of_walk (xs_pre @ [v]) \\<and>\n     (v, w) \\<notin> edges_of_walk (w # xs_post)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_edges_remove_prefix:\n  assumes \"path (xs @ x # xs')\"\n  shows \"edges_of_walk (xs @ [x]) = edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "fix v w"], ["proof (state)\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "assume *: \"(v,w) \\<in> edges_of_walk (xs @ [x])\""], ["proof (state)\nthis:\n  (v, w) \\<in> edges_of_walk (xs @ [x])\n\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> edges_of_walk (xs @ [x])", "have 1: \"(v,w) \\<in> edges_of_walk (xs @ x # xs')\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> edges_of_walk (xs @ [x])\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (xs @ x # xs')", "using walk_edges_decomp[of xs x xs']"], ["proof (prove)\nusing this:\n  (v, w) \\<in> edges_of_walk (xs @ [x])\n  edges_of_walk (xs @ x # xs') =\n  edges_of_walk (xs @ [x]) \\<union> edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (xs @ x # xs')", "by force"], ["proof (state)\nthis:\n  (v, w) \\<in> edges_of_walk (xs @ x # xs')\n\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "moreover"], ["proof (state)\nthis:\n  (v, w) \\<in> edges_of_walk (xs @ x # xs')\n\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "have \"(v,w) \\<notin> edges_of_walk (x # xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, w) \\<notin> edges_of_walk (x # xs')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (x # xs') \\<Longrightarrow> False", "assume contra: \"(v,w) \\<in> edges_of_walk (x # xs')\""], ["proof (state)\nthis:\n  (v, w) \\<in> edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (x # xs') \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> edges_of_walk (x # xs')", "have \"w \\<in> set (x # xs')\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. w \\<in> set (x # xs')", "by (meson walk_edges_vertices(2))"], ["proof (state)\nthis:\n  w \\<in> set (x # xs')\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (x # xs') \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  w \\<in> set (x # xs')\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (x # xs') \\<Longrightarrow> False", "have \"w \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> x", "using assms contra * 1"], ["proof (prove)\nusing this:\n  path (xs @ x # xs')\n  (v, w) \\<in> edges_of_walk (x # xs')\n  (v, w) \\<in> edges_of_walk (xs @ [x])\n  (v, w) \\<in> edges_of_walk (xs @ x # xs')\n\ngoal (1 subgoal):\n 1. w \\<noteq> x", "by (metis path_decomp(2) UnE edges_of_walkE edges_of_walk_edge list.set_intros(1)\n            path_2 path_disjoint path_first_vertex self_append_conv2 set_append walk_edges_vertices(1))"], ["proof (state)\nthis:\n  w \\<noteq> x\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (x # xs') \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  w \\<noteq> x\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (x # xs') \\<Longrightarrow> False", "have \"w \\<in> set (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> set (xs @ [x])", "by (meson * walk_edges_vertices(2))"], ["proof (state)\nthis:\n  w \\<in> set (xs @ [x])\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (x # xs') \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  w \\<in> set (x # xs')\n  w \\<noteq> x\n  w \\<in> set (xs @ [x])", "show False"], ["proof (prove)\nusing this:\n  w \\<in> set (x # xs')\n  w \\<noteq> x\n  w \\<in> set (xs @ [x])\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  w \\<in> set (x # xs')\n  w \\<noteq> x\n  w \\<in> set (xs @ [x])\n  path (xs @ x # xs')\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v, w) \\<notin> edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "ultimately"], ["proof (chain)\npicking this:\n  (v, w) \\<in> edges_of_walk (xs @ x # xs')\n  (v, w) \\<notin> edges_of_walk (x # xs')", "have \"(v,w) \\<in> edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> edges_of_walk (xs @ x # xs')\n  (v, w) \\<notin> edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "by blast"], ["proof (state)\nthis:\n  (v, w) \\<in> edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "}"], ["proof (state)\nthis:\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ [x]) \\<Longrightarrow>\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "then"], ["proof (chain)\npicking this:\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ [x]) \\<Longrightarrow>\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "show ?thesis"], ["proof (prove)\nusing this:\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ [x]) \\<Longrightarrow>\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "using walk_edges_decomp[of xs x xs']"], ["proof (prove)\nusing this:\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ [x]) \\<Longrightarrow>\n  (?v2, ?w2) \\<in> edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')\n  edges_of_walk (xs @ x # xs') =\n  edges_of_walk (xs @ [x]) \\<union> edges_of_walk (x # xs')\n\ngoal (1 subgoal):\n 1. edges_of_walk (xs @ [x]) =\n    edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')", "by auto"], ["proof (state)\nthis:\n  edges_of_walk (xs @ [x]) =\n  edges_of_walk (xs @ x # xs') - edges_of_walk (x # xs')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The First Edge of a Walk\\<close>"], ["", "text \\<open>\n  In the proof of Menger's Theorem, we will often talk about the first edge of a path.  Let us\n  define this concept.\n\\<close>"], ["", "fun first_edge_of_walk where\n  \"first_edge_of_walk (v # w # xs) = (v, w)\"\n| \"first_edge_of_walk [v] = undefined\"\n| \"first_edge_of_walk [] = undefined\""], ["", "lemma first_edge_in_edges: \"tl xs \\<noteq> Nil \\<Longrightarrow> first_edge_of_walk xs \\<in> edges_of_walk xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl xs \\<noteq> [] \\<Longrightarrow>\n    first_edge_of_walk xs \\<in> edges_of_walk xs", "unfolding edges_of_walk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tl xs \\<noteq> [] \\<Longrightarrow>\n    first_edge_of_walk xs\n    \\<in> {uu_.\n           \\<exists>v w xs_pre xs_post.\n              uu_ = (v, w) \\<and> xs = xs_pre @ v # w # xs_post}", "by (induct rule: first_edge_of_walk.induct) auto"], ["", "lemma first_edge_hd_tl: \"\\<lbrakk> v \\<leadsto>xs\\<leadsto> w; tl xs \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> first_edge_of_walk xs = (v, hd (tl xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<leadsto>xs\\<leadsto> w; tl xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> first_edge_of_walk xs = (v, hd (tl xs))", "by (induct \"xs\" rule: first_edge_of_walk.induct) auto"], ["", "lemma first_edge_first:\n  assumes \"v \\<leadsto>xs\\<leadsto> w\" \"(v,w') \\<in> edges_of_walk xs\"\n  shows \"first_edge_of_walk xs = (v,w')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first_edge_of_walk xs = (v, w')", "using assms"], ["proof (prove)\nusing this:\n  v \\<leadsto>xs\\<leadsto> w\n  (v, w') \\<in> edges_of_walk xs\n\ngoal (1 subgoal):\n 1. first_edge_of_walk xs = (v, w')", "proof (induct rule: first_edge_of_walk.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>va wa xs.\n       \\<lbrakk>v \\<leadsto>(va # wa # xs)\\<leadsto> w;\n        (v, w') \\<in> edges_of_walk (va # wa # xs)\\<rbrakk>\n       \\<Longrightarrow> first_edge_of_walk (va # wa # xs) = (v, w')\n 2. \\<And>va.\n       \\<lbrakk>v \\<leadsto>[va]\\<leadsto> w;\n        (v, w') \\<in> edges_of_walk [va]\\<rbrakk>\n       \\<Longrightarrow> first_edge_of_walk [va] = (v, w')\n 3. \\<lbrakk>v \\<leadsto>[]\\<leadsto> w;\n     (v, w') \\<in> edges_of_walk []\\<rbrakk>\n    \\<Longrightarrow> first_edge_of_walk [] = (v, w')", "case (1 v w xs)"], ["proof (state)\nthis:\n  v \\<leadsto>(v # w # xs)\\<leadsto> w\n  (v, w') \\<in> edges_of_walk (v # w # xs)\n\ngoal (3 subgoals):\n 1. \\<And>va wa xs.\n       \\<lbrakk>v \\<leadsto>(va # wa # xs)\\<leadsto> w;\n        (v, w') \\<in> edges_of_walk (va # wa # xs)\\<rbrakk>\n       \\<Longrightarrow> first_edge_of_walk (va # wa # xs) = (v, w')\n 2. \\<And>va.\n       \\<lbrakk>v \\<leadsto>[va]\\<leadsto> w;\n        (v, w') \\<in> edges_of_walk [va]\\<rbrakk>\n       \\<Longrightarrow> first_edge_of_walk [va] = (v, w')\n 3. \\<lbrakk>v \\<leadsto>[]\\<leadsto> w;\n     (v, w') \\<in> edges_of_walk []\\<rbrakk>\n    \\<Longrightarrow> first_edge_of_walk [] = (v, w')", "then"], ["proof (chain)\npicking this:\n  v \\<leadsto>(v # w # xs)\\<leadsto> w\n  (v, w') \\<in> edges_of_walk (v # w # xs)", "show ?case"], ["proof (prove)\nusing this:\n  v \\<leadsto>(v # w # xs)\\<leadsto> w\n  (v, w') \\<in> edges_of_walk (v # w # xs)\n\ngoal (1 subgoal):\n 1. first_edge_of_walk (v # w # xs) = (v, w')", "by (metis path_decomp(1) append_self_conv2 edges_of_walkE first_edge_of_walk.simps(1)\n        hd_append hd_in_set not_distinct_conv_prefix path_from_toE)"], ["proof (state)\nthis:\n  first_edge_of_walk (v # w # xs) = (v, w')\n\ngoal (2 subgoals):\n 1. \\<And>va.\n       \\<lbrakk>v \\<leadsto>[va]\\<leadsto> w;\n        (v, w') \\<in> edges_of_walk [va]\\<rbrakk>\n       \\<Longrightarrow> first_edge_of_walk [va] = (v, w')\n 2. \\<lbrakk>v \\<leadsto>[]\\<leadsto> w;\n     (v, w') \\<in> edges_of_walk []\\<rbrakk>\n    \\<Longrightarrow> first_edge_of_walk [] = (v, w')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>va.\n       \\<lbrakk>v \\<leadsto>[va]\\<leadsto> w;\n        (v, w') \\<in> edges_of_walk [va]\\<rbrakk>\n       \\<Longrightarrow> first_edge_of_walk [va] = (v, w')\n 2. \\<lbrakk>v \\<leadsto>[]\\<leadsto> w;\n     (v, w') \\<in> edges_of_walk []\\<rbrakk>\n    \\<Longrightarrow> first_edge_of_walk [] = (v, w')", "case (2 v)"], ["proof (state)\nthis:\n  v \\<leadsto>[v]\\<leadsto> w\n  (v, w') \\<in> edges_of_walk [v]\n\ngoal (2 subgoals):\n 1. \\<And>va.\n       \\<lbrakk>v \\<leadsto>[va]\\<leadsto> w;\n        (v, w') \\<in> edges_of_walk [va]\\<rbrakk>\n       \\<Longrightarrow> first_edge_of_walk [va] = (v, w')\n 2. \\<lbrakk>v \\<leadsto>[]\\<leadsto> w;\n     (v, w') \\<in> edges_of_walk []\\<rbrakk>\n    \\<Longrightarrow> first_edge_of_walk [] = (v, w')", "then"], ["proof (chain)\npicking this:\n  v \\<leadsto>[v]\\<leadsto> w\n  (v, w') \\<in> edges_of_walk [v]", "show ?case"], ["proof (prove)\nusing this:\n  v \\<leadsto>[v]\\<leadsto> w\n  (v, w') \\<in> edges_of_walk [v]\n\ngoal (1 subgoal):\n 1. first_edge_of_walk [v] = (v, w')", "using path_edges"], ["proof (prove)\nusing this:\n  v \\<leadsto>[v]\\<leadsto> w\n  (v, w') \\<in> edges_of_walk [v]\n  \\<lbrakk>path ?xs; (?v, ?w) \\<in> edges_of_walk ?xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs_pre xs_post.\n                       ?xs = xs_pre @ ?v # ?w # xs_post \\<and>\n                       (?v, ?w)\n                       \\<notin> edges_of_walk (xs_pre @ [?v]) \\<and>\n                       (?v, ?w) \\<notin> edges_of_walk (?w # xs_post)\n\ngoal (1 subgoal):\n 1. first_edge_of_walk [v] = (v, w')", "by fastforce"], ["proof (state)\nthis:\n  first_edge_of_walk [v] = (v, w')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<leadsto>[]\\<leadsto> w;\n     (v, w') \\<in> edges_of_walk []\\<rbrakk>\n    \\<Longrightarrow> first_edge_of_walk [] = (v, w')", "qed blast"], ["", "subsection \\<open>Distance\\<close>"], ["", "text \\<open>\n  The distance between two vertices is the minimum length of a path.  Note that this is not a\n  symmetric function because we are on digraphs.\n\\<close>"], ["", "definition distance :: \"'a \\<Rightarrow> 'a \\<Rightarrow> nat\" where\n  \"distance v w \\<equiv> Min { length xs | xs. v\\<leadsto>xs\\<leadsto>w }\""], ["", "text \\<open>\n  The @{const Min} operator applies only to finite sets, so let us prove that this is the case.\n\\<close>"], ["", "lemma distance_lengths_finite: \"finite { length xs | xs. v\\<leadsto>xs\\<leadsto>w }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {length xs |xs. v \\<leadsto>xs\\<leadsto> w}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {length xs |xs. v \\<leadsto>xs\\<leadsto> w}", "have \"{ length xs | xs. v\\<leadsto>xs\\<leadsto>w } \\<subseteq> { n | n. n \\<le> card V }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length xs |xs. v \\<leadsto>xs\\<leadsto> w}\n    \\<subseteq> {n |n. n \\<le> card V}", "using path_length"], ["proof (prove)\nusing this:\n  path ?xs \\<Longrightarrow> length ?xs \\<le> card V\n\ngoal (1 subgoal):\n 1. {length xs |xs. v \\<leadsto>xs\\<leadsto> w}\n    \\<subseteq> {n |n. n \\<le> card V}", "by blast"], ["proof (state)\nthis:\n  {length xs |xs. v \\<leadsto>xs\\<leadsto> w}\n  \\<subseteq> {n |n. n \\<le> card V}\n\ngoal (1 subgoal):\n 1. finite {length xs |xs. v \\<leadsto>xs\\<leadsto> w}", "then"], ["proof (chain)\npicking this:\n  {length xs |xs. v \\<leadsto>xs\\<leadsto> w}\n  \\<subseteq> {n |n. n \\<le> card V}", "show ?thesis"], ["proof (prove)\nusing this:\n  {length xs |xs. v \\<leadsto>xs\\<leadsto> w}\n  \\<subseteq> {n |n. n \\<le> card V}\n\ngoal (1 subgoal):\n 1. finite {length xs |xs. v \\<leadsto>xs\\<leadsto> w}", "using finite_Collect_le_nat"], ["proof (prove)\nusing this:\n  {length xs |xs. v \\<leadsto>xs\\<leadsto> w}\n  \\<subseteq> {n |n. n \\<le> card V}\n  finite {n. n \\<le> ?k}\n\ngoal (1 subgoal):\n 1. finite {length xs |xs. v \\<leadsto>xs\\<leadsto> w}", "by (meson finite_subset)"], ["proof (state)\nthis:\n  finite {length xs |xs. v \\<leadsto>xs\\<leadsto> w}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If we have a concrete path from @{term v} to @{term w}, then the length of this path bounds the\n  distance from @{term v} to @{term w}.\n\\<close>"], ["", "lemma distance_upper_bound: \"v\\<leadsto>xs\\<leadsto>w \\<Longrightarrow> distance v w \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow>\n    distance v w \\<le> length xs", "unfolding distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow>\n    Min {length xs |xs. v \\<leadsto>xs\\<leadsto> w} \\<le> length xs", "using Min_le[OF distance_lengths_finite]"], ["proof (prove)\nusing this:\n  ?x \\<in> {length xs |xs. ?v1 \\<leadsto>xs\\<leadsto> ?w1} \\<Longrightarrow>\n  Min {length xs |xs. ?v1 \\<leadsto>xs\\<leadsto> ?w1} \\<le> ?x\n\ngoal (1 subgoal):\n 1. v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow>\n    Min {length xs |xs. v \\<leadsto>xs\\<leadsto> w} \\<le> length xs", "by blast"], ["", "text \\<open>\n  Another characterization of @{const distance}: If we have a concrete minimal path from @{term v}\n  to @{term w}, this defines the distance.\n\\<close>"], ["", "lemma distance_witness:\n  assumes xs: \"v \\<leadsto>xs\\<leadsto> w\"\n      and xs_min: \"\\<And>xs'. v \\<leadsto>xs'\\<leadsto> w \\<Longrightarrow> length xs \\<le> length xs'\"\n  shows \"distance v w = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distance v w = length xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. distance v w = length xs", "have \"\\<And>d. d \\<in> {length xs | xs. v \\<leadsto>xs\\<leadsto> w} \\<Longrightarrow> length xs \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> {length xs |xs. v \\<leadsto>xs\\<leadsto> w} \\<Longrightarrow>\n       length xs \\<le> d", "using xs_min"], ["proof (prove)\nusing this:\n  v \\<leadsto>?xs'\\<leadsto> w \\<Longrightarrow> length xs \\<le> length ?xs'\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       d \\<in> {length xs |xs. v \\<leadsto>xs\\<leadsto> w} \\<Longrightarrow>\n       length xs \\<le> d", "by blast"], ["proof (state)\nthis:\n  ?d \\<in> {length xs |xs. v \\<leadsto>xs\\<leadsto> w} \\<Longrightarrow>\n  length xs \\<le> ?d\n\ngoal (1 subgoal):\n 1. distance v w = length xs", "then"], ["proof (chain)\npicking this:\n  ?d \\<in> {length xs |xs. v \\<leadsto>xs\\<leadsto> w} \\<Longrightarrow>\n  length xs \\<le> ?d", "show ?thesis"], ["proof (prove)\nusing this:\n  ?d \\<in> {length xs |xs. v \\<leadsto>xs\\<leadsto> w} \\<Longrightarrow>\n  length xs \\<le> ?d\n\ngoal (1 subgoal):\n 1. distance v w = length xs", "unfolding distance_def"], ["proof (prove)\nusing this:\n  ?d \\<in> {length xs |xs. v \\<leadsto>xs\\<leadsto> w} \\<Longrightarrow>\n  length xs \\<le> ?d\n\ngoal (1 subgoal):\n 1. Min {length xs |xs. v \\<leadsto>xs\\<leadsto> w} = length xs", "using Min_eqI"], ["proof (prove)\nusing this:\n  ?d \\<in> {length xs |xs. v \\<leadsto>xs\\<leadsto> w} \\<Longrightarrow>\n  length xs \\<le> ?d\n  \\<lbrakk>finite ?A; \\<And>y. y \\<in> ?A \\<Longrightarrow> ?x \\<le> y;\n   ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> Min ?A = ?x\n\ngoal (1 subgoal):\n 1. Min {length xs |xs. v \\<leadsto>xs\\<leadsto> w} = length xs", "by (metis (mono_tags, lifting) distance_lengths_finite xs mem_Collect_eq)"], ["proof (state)\nthis:\n  distance v w = length xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Subgraphs\\<close>"], ["", "text \\<open>We only need one kind of subgraph: The subgraph obtained by removing a single vertex.\\<close>"], ["", "definition remove_vertex :: \"'a \\<Rightarrow> ('a, 'b) Graph_scheme\" where\n  \"remove_vertex x \\<equiv> G\\<lparr> verts := V - {x}, arcs := Restr E (V - {x}) \\<rparr>\""], ["", "lemma remove_vertex_V: \"V\\<^bsub>remove_vertex x\\<^esub> = V - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^bsub>remove_vertex x\\<^esub> = V - {x}", "unfolding remove_vertex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^bsub>G\\<lparr>verts := V - {x}, arcs := Restr E (V - {x})\\<rparr>\\<^esub> =\n    V - {x}", "by auto"], ["", "lemma remove_vertex_V': \"V\\<^bsub>remove_vertex x\\<^esub> \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^bsub>remove_vertex x\\<^esub> \\<subseteq> V", "unfolding remove_vertex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^bsub>G\\<lparr>verts := V - {x}, arcs := Restr E (V - {x})\\<rparr>\\<^esub>\n    \\<subseteq> V", "by auto"], ["", "lemma remove_vertex_E: \"E\\<^bsub>remove_vertex x\\<^esub> = Restr E (V - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^bsub>remove_vertex x\\<^esub> = Restr E (V - {x})", "unfolding remove_vertex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^bsub>G\\<lparr>verts := V - {x}, arcs := Restr E (V - {x})\\<rparr>\\<^esub> =\n    Restr E (V - {x})", "by simp"], ["", "lemma remove_vertex_E': \"v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w \\<Longrightarrow> v\\<rightarrow>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w \\<Longrightarrow>\n    v \\<rightarrow> w", "by (simp add: remove_vertex_E)"], ["", "lemma remove_vertex_E'': \"\\<lbrakk> v\\<rightarrow>w; v \\<noteq> x; w \\<noteq> x \\<rbrakk> \\<Longrightarrow> v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<rightarrow> w; v \\<noteq> x; w \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w", "by (simp add: edges_are_in_V remove_vertex_E)"], ["", "text \\<open>Of course, this is still a digraph.\\<close>"], ["", "lemma remove_vertex_Digraph: \"Digraph (remove_vertex v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph (remove_vertex v)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite V\\<^bsub>remove_vertex v\\<^esub>\n 2. E\\<^bsub>remove_vertex v\\<^esub>\n    \\<subseteq> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n                V\\<^bsub>remove_vertex v\\<^esub>", "let ?V = \"V\\<^bsub>remove_vertex v\\<^esub>\""], ["proof (state)\ngoal (2 subgoals):\n 1. finite V\\<^bsub>remove_vertex v\\<^esub>\n 2. E\\<^bsub>remove_vertex v\\<^esub>\n    \\<subseteq> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n                V\\<^bsub>remove_vertex v\\<^esub>", "let ?E = \"E\\<^bsub>remove_vertex v\\<^esub>\""], ["proof (state)\ngoal (2 subgoals):\n 1. finite V\\<^bsub>remove_vertex v\\<^esub>\n 2. E\\<^bsub>remove_vertex v\\<^esub>\n    \\<subseteq> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n                V\\<^bsub>remove_vertex v\\<^esub>", "show \"finite ?V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V\\<^bsub>remove_vertex v\\<^esub>", "unfolding remove_vertex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     V\\<^bsub>G\\<lparr>verts := V - {v}, arcs := Restr E (V - {v})\\<rparr>\\<^esub>", "using finite_vertex_set"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. finite\n     V\\<^bsub>G\\<lparr>verts := V - {v}, arcs := Restr E (V - {v})\\<rparr>\\<^esub>", "by simp"], ["proof (state)\nthis:\n  finite V\\<^bsub>remove_vertex v\\<^esub>\n\ngoal (1 subgoal):\n 1. E\\<^bsub>remove_vertex v\\<^esub>\n    \\<subseteq> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n                V\\<^bsub>remove_vertex v\\<^esub>", "show \"?E \\<subseteq> ?V \\<times> ?V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^bsub>remove_vertex v\\<^esub>\n    \\<subseteq> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n                V\\<^bsub>remove_vertex v\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> E\\<^bsub>remove_vertex v\\<^esub> \\<Longrightarrow>\n       x \\<in> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n               V\\<^bsub>remove_vertex v\\<^esub>", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> E\\<^bsub>remove_vertex v\\<^esub> \\<Longrightarrow>\n       x \\<in> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n               V\\<^bsub>remove_vertex v\\<^esub>", "assume \"e \\<in> ?E\""], ["proof (state)\nthis:\n  e \\<in> E\\<^bsub>remove_vertex v\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> E\\<^bsub>remove_vertex v\\<^esub> \\<Longrightarrow>\n       x \\<in> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n               V\\<^bsub>remove_vertex v\\<^esub>", "then"], ["proof (chain)\npicking this:\n  e \\<in> E\\<^bsub>remove_vertex v\\<^esub>", "have \"e \\<in> (V - {v}) \\<times> (V - {v})\""], ["proof (prove)\nusing this:\n  e \\<in> E\\<^bsub>remove_vertex v\\<^esub>\n\ngoal (1 subgoal):\n 1. e \\<in> (V - {v}) \\<times> (V - {v})", "by (metis Int_iff remove_vertex_E)"], ["proof (state)\nthis:\n  e \\<in> (V - {v}) \\<times> (V - {v})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> E\\<^bsub>remove_vertex v\\<^esub> \\<Longrightarrow>\n       x \\<in> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n               V\\<^bsub>remove_vertex v\\<^esub>", "then"], ["proof (chain)\npicking this:\n  e \\<in> (V - {v}) \\<times> (V - {v})", "show \"e \\<in> ?V \\<times> ?V\""], ["proof (prove)\nusing this:\n  e \\<in> (V - {v}) \\<times> (V - {v})\n\ngoal (1 subgoal):\n 1. e \\<in> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n            V\\<^bsub>remove_vertex v\\<^esub>", "using remove_vertex_V"], ["proof (prove)\nusing this:\n  e \\<in> (V - {v}) \\<times> (V - {v})\n  V\\<^bsub>remove_vertex ?x\\<^esub> = V - {?x}\n\ngoal (1 subgoal):\n 1. e \\<in> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n            V\\<^bsub>remove_vertex v\\<^esub>", "by auto"], ["proof (state)\nthis:\n  e \\<in> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n          V\\<^bsub>remove_vertex v\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E\\<^bsub>remove_vertex v\\<^esub>\n  \\<subseteq> V\\<^bsub>remove_vertex v\\<^esub> \\<times>\n              V\\<^bsub>remove_vertex v\\<^esub>\n\ngoal:\nNo subgoals!", "have \"\\<And>x y. \\<lbrakk> (x,y) \\<in> ?E; (x,y) \\<notin> E \\<rbrakk> \\<Longrightarrow> (y,x) \\<in> ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>remove_vertex v\\<^esub> y;\n        (x, y) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> y \\<rightarrow>\\<^bsub>remove_vertex v\\<^esub> x", "unfolding remove_vertex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<lparr>verts := V - {v}, arcs := Restr E (V - {v})\\<rparr>\\<^esub>\n                y;\n        (x, y) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> y \\<rightarrow>\\<^bsub>G\\<lparr>verts := V - {v}, arcs := Restr E (V - {v})\\<rparr>\\<^esub>\n                         x", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<rightarrow>\\<^bsub>remove_vertex v\\<^esub> ?y;\n   (?x, ?y) \\<notin> E\\<rbrakk>\n  \\<Longrightarrow> ?y \\<rightarrow>\\<^bsub>remove_vertex v\\<^esub> ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We are also going to need a few lemmas about how walks and paths behave when we remove a vertex.\n\n  First, if we remove a vertex that is not on a walk @{term xs}, then @{term xs} is still a walk\n  after removing this vertex.\n\\<close>"], ["", "lemma remove_vertex_walk:\n  assumes \"walk xs\" \"x \\<notin> set xs\"\n  shows \"Digraph.walk (remove_vertex x) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph.walk (remove_vertex x) xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Digraph.walk (remove_vertex x) xs", "interpret H: Digraph \"remove_vertex x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph (remove_vertex x)", "using remove_vertex_Digraph"], ["proof (prove)\nusing this:\n  Digraph (remove_vertex ?v)\n\ngoal (1 subgoal):\n 1. Digraph (remove_vertex x)", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. H.walk xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H.walk xs", "using assms"], ["proof (prove)\nusing this:\n  walk xs\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. H.walk xs", "proof (induct rule: walk.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<notin> set [] \\<Longrightarrow> H.walk []\n 2. \\<And>v.\n       \\<lbrakk>v \\<in> V; x \\<notin> set [v]\\<rbrakk>\n       \\<Longrightarrow> H.walk [v]\n 3. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow> w; walk (w # vs);\n        x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs);\n        x \\<notin> set (v # w # vs)\\<rbrakk>\n       \\<Longrightarrow> H.walk (v # w # vs)", "case (Singleton v)"], ["proof (state)\nthis:\n  v \\<in> V\n  x \\<notin> set [v]\n\ngoal (3 subgoals):\n 1. x \\<notin> set [] \\<Longrightarrow> H.walk []\n 2. \\<And>v.\n       \\<lbrakk>v \\<in> V; x \\<notin> set [v]\\<rbrakk>\n       \\<Longrightarrow> H.walk [v]\n 3. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow> w; walk (w # vs);\n        x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs);\n        x \\<notin> set (v # w # vs)\\<rbrakk>\n       \\<Longrightarrow> H.walk (v # w # vs)", "then"], ["proof (chain)\npicking this:\n  v \\<in> V\n  x \\<notin> set [v]", "have \"v \\<in> V - {x}\""], ["proof (prove)\nusing this:\n  v \\<in> V\n  x \\<notin> set [v]\n\ngoal (1 subgoal):\n 1. v \\<in> V - {x}", "by simp"], ["proof (state)\nthis:\n  v \\<in> V - {x}\n\ngoal (3 subgoals):\n 1. x \\<notin> set [] \\<Longrightarrow> H.walk []\n 2. \\<And>v.\n       \\<lbrakk>v \\<in> V; x \\<notin> set [v]\\<rbrakk>\n       \\<Longrightarrow> H.walk [v]\n 3. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow> w; walk (w # vs);\n        x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs);\n        x \\<notin> set (v # w # vs)\\<rbrakk>\n       \\<Longrightarrow> H.walk (v # w # vs)", "then"], ["proof (chain)\npicking this:\n  v \\<in> V - {x}", "show ?case"], ["proof (prove)\nusing this:\n  v \\<in> V - {x}\n\ngoal (1 subgoal):\n 1. H.walk [v]", "using remove_vertex_V"], ["proof (prove)\nusing this:\n  v \\<in> V - {x}\n  V\\<^bsub>remove_vertex ?x\\<^esub> = V - {?x}\n\ngoal (1 subgoal):\n 1. H.walk [v]", "by simp"], ["proof (state)\nthis:\n  H.walk [v]\n\ngoal (2 subgoals):\n 1. x \\<notin> set [] \\<Longrightarrow> H.walk []\n 2. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow> w; walk (w # vs);\n        x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs);\n        x \\<notin> set (v # w # vs)\\<rbrakk>\n       \\<Longrightarrow> H.walk (v # w # vs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<notin> set [] \\<Longrightarrow> H.walk []\n 2. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow> w; walk (w # vs);\n        x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs);\n        x \\<notin> set (v # w # vs)\\<rbrakk>\n       \\<Longrightarrow> H.walk (v # w # vs)", "case (Cons v w vs)"], ["proof (state)\nthis:\n  v \\<rightarrow> w\n  walk (w # vs)\n  x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs)\n  x \\<notin> set (v # w # vs)\n\ngoal (2 subgoals):\n 1. x \\<notin> set [] \\<Longrightarrow> H.walk []\n 2. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow> w; walk (w # vs);\n        x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs);\n        x \\<notin> set (v # w # vs)\\<rbrakk>\n       \\<Longrightarrow> H.walk (v # w # vs)", "then"], ["proof (chain)\npicking this:\n  v \\<rightarrow> w\n  walk (w # vs)\n  x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs)\n  x \\<notin> set (v # w # vs)", "have \"v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w\""], ["proof (prove)\nusing this:\n  v \\<rightarrow> w\n  walk (w # vs)\n  x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs)\n  x \\<notin> set (v # w # vs)\n\ngoal (1 subgoal):\n 1. v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w", "using remove_vertex_E''"], ["proof (prove)\nusing this:\n  v \\<rightarrow> w\n  walk (w # vs)\n  x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs)\n  x \\<notin> set (v # w # vs)\n  \\<lbrakk>?v \\<rightarrow> ?w; ?v \\<noteq> ?x; ?w \\<noteq> ?x\\<rbrakk>\n  \\<Longrightarrow> ?v \\<rightarrow>\\<^bsub>remove_vertex ?x\\<^esub> ?w\n\ngoal (1 subgoal):\n 1. v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w", "by auto"], ["proof (state)\nthis:\n  v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w\n\ngoal (2 subgoals):\n 1. x \\<notin> set [] \\<Longrightarrow> H.walk []\n 2. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow> w; walk (w # vs);\n        x \\<notin> set (w # vs) \\<Longrightarrow> H.walk (w # vs);\n        x \\<notin> set (v # w # vs)\\<rbrakk>\n       \\<Longrightarrow> H.walk (v # w # vs)", "then"], ["proof (chain)\npicking this:\n  v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w", "show ?case"], ["proof (prove)\nusing this:\n  v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w\n\ngoal (1 subgoal):\n 1. H.walk (v # w # vs)", "by (meson Cons.hyps(3) Cons.prems(1) H.Cons assms(2) list.set_intros(2))"], ["proof (state)\nthis:\n  H.walk (v # w # vs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set [] \\<Longrightarrow> H.walk []", "qed simp"], ["proof (state)\nthis:\n  H.walk xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The same holds for paths.\\<close>"], ["", "lemma remove_vertex_path_from_to:\n  \"\\<lbrakk> v \\<leadsto>xs\\<leadsto> w; x \\<in> V; x \\<notin> set xs \\<rbrakk> \\<Longrightarrow> v \\<leadsto>xs\\<leadsto>\\<^bsub>remove_vertex x\\<^esub> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<leadsto>xs\\<leadsto> w; x \\<in> V;\n     x \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> v \\<leadsto>xs\\<leadsto>\\<^bsub>remove_vertex x\\<^esub> w", "using path_from_to_def remove_vertex_walk"], ["proof (prove)\nusing this:\n  ?v \\<leadsto>?xs\\<leadsto>\\<^bsub>?G\\<^esub> ?w \\<equiv>\n  (Digraph.walk ?G ?xs \\<and> distinct ?xs) \\<and>\n  ?xs \\<noteq> [] \\<and> hd ?xs = ?v \\<and> last ?xs = ?w\n  \\<lbrakk>walk ?xs; ?x \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> Digraph.walk (remove_vertex ?x) ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<leadsto>xs\\<leadsto> w; x \\<in> V;\n     x \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> v \\<leadsto>xs\\<leadsto>\\<^bsub>remove_vertex x\\<^esub> w", "by fastforce"], ["", "text \\<open>\n  Conversely, if something was a walk or a path in the subgraph, then it is also a walk or a path\n  in the supergraph.\n\\<close>"], ["", "lemma remove_vertex_walk_add:\n  assumes \"Digraph.walk (remove_vertex x) xs\"\n  shows \"walk xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. walk xs", "interpret H: Digraph \"remove_vertex x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph (remove_vertex x)", "using remove_vertex_Digraph"], ["proof (prove)\nusing this:\n  Digraph (remove_vertex ?v)\n\ngoal (1 subgoal):\n 1. Digraph (remove_vertex x)", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. walk xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs", "using assms"], ["proof (prove)\nusing this:\n  H.walk xs\n\ngoal (1 subgoal):\n 1. walk xs", "proof (induct rule: H.walk.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. walk []\n 2. \\<And>v.\n       v \\<in> V\\<^bsub>remove_vertex x\\<^esub> \\<Longrightarrow> walk [v]\n 3. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w;\n        H.walk (w # vs); walk (w # vs)\\<rbrakk>\n       \\<Longrightarrow> walk (v # w # vs)", "case (Singleton v)"], ["proof (state)\nthis:\n  v \\<in> V\\<^bsub>remove_vertex x\\<^esub>\n\ngoal (3 subgoals):\n 1. walk []\n 2. \\<And>v.\n       v \\<in> V\\<^bsub>remove_vertex x\\<^esub> \\<Longrightarrow> walk [v]\n 3. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w;\n        H.walk (w # vs); walk (w # vs)\\<rbrakk>\n       \\<Longrightarrow> walk (v # w # vs)", "then"], ["proof (chain)\npicking this:\n  v \\<in> V\\<^bsub>remove_vertex x\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  v \\<in> V\\<^bsub>remove_vertex x\\<^esub>\n\ngoal (1 subgoal):\n 1. walk [v]", "by (meson Digraph.Singleton Digraph_axioms remove_vertex_V' subsetD)"], ["proof (state)\nthis:\n  walk [v]\n\ngoal (2 subgoals):\n 1. walk []\n 2. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w;\n        H.walk (w # vs); walk (w # vs)\\<rbrakk>\n       \\<Longrightarrow> walk (v # w # vs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. walk []\n 2. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w;\n        H.walk (w # vs); walk (w # vs)\\<rbrakk>\n       \\<Longrightarrow> walk (v # w # vs)", "case (Cons v w vs)"], ["proof (state)\nthis:\n  v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w\n  H.walk (w # vs)\n  walk (w # vs)\n\ngoal (2 subgoals):\n 1. walk []\n 2. \\<And>v w vs.\n       \\<lbrakk>v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w;\n        H.walk (w # vs); walk (w # vs)\\<rbrakk>\n       \\<Longrightarrow> walk (v # w # vs)", "then"], ["proof (chain)\npicking this:\n  v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w\n  H.walk (w # vs)\n  walk (w # vs)", "show ?case"], ["proof (prove)\nusing this:\n  v \\<rightarrow>\\<^bsub>remove_vertex x\\<^esub> w\n  H.walk (w # vs)\n  walk (w # vs)\n\ngoal (1 subgoal):\n 1. walk (v # w # vs)", "by (meson Digraph.Cons Digraph_axioms remove_vertex_E')"], ["proof (state)\nthis:\n  walk (v # w # vs)\n\ngoal (1 subgoal):\n 1. walk []", "qed simp"], ["proof (state)\nthis:\n  walk xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_vertex_path_from_to_add: \"v \\<leadsto>xs\\<leadsto>\\<^bsub>remove_vertex x\\<^esub> w \\<Longrightarrow> v \\<leadsto>xs\\<leadsto> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto>xs\\<leadsto>\\<^bsub>remove_vertex x\\<^esub> w \\<Longrightarrow>\n    v \\<leadsto>xs\\<leadsto> w", "using path_from_to_def remove_vertex_walk_add"], ["proof (prove)\nusing this:\n  ?v \\<leadsto>?xs\\<leadsto>\\<^bsub>?G\\<^esub> ?w \\<equiv>\n  (Digraph.walk ?G ?xs \\<and> distinct ?xs) \\<and>\n  ?xs \\<noteq> [] \\<and> hd ?xs = ?v \\<and> last ?xs = ?w\n  Digraph.walk (remove_vertex ?x) ?xs \\<Longrightarrow> walk ?xs\n\ngoal (1 subgoal):\n 1. v \\<leadsto>xs\\<leadsto>\\<^bsub>remove_vertex x\\<^esub> w \\<Longrightarrow>\n    v \\<leadsto>xs\\<leadsto> w", "by fastforce"], ["", "end \\<comment> \\<open>context Digraph\\<close>"], ["", "subsection \\<open>Two Distinguished Distinct Non-adjacent Vertices.\\<close>"], ["", "text \\<open>\n  The setup for Menger's Theorem requires two distinguished distinct non-adjacent vertices\n  @{term v0} and @{term v1}.  Let us pin down this concept with the following locale.\n\\<close>"], ["", "locale v0_v1_Digraph = Digraph +\n  fixes v0 v1 :: \"'a\"\n  assumes v0_V: \"v0 \\<in> V\" and v1_V: \"v1 \\<in> V\"\n    and v0_nonadj_v1: \"\\<not>v0\\<rightarrow>v1\"\n    and v0_neq_v1: \"v0 \\<noteq> v1\""], ["", "text \\<open>\n  The only lemma we need about @{locale v0_v1_Digraph} for now is that it is closed under removing\n  a vertex that is not @{term v0} or @{term v1}.\n\\<close>"], ["", "lemma (in v0_v1_Digraph) remove_vertices_v0_v1_Digraph:\n  assumes \"v \\<noteq> v0\" \"v \\<noteq> v1\"\n  shows \"v0_v1_Digraph (remove_vertex v) v0 v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0_v1_Digraph (remove_vertex v) v0 v1", "proof (rule v0_v1_Digraph.intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. Digraph (remove_vertex v)\n 2. v0_v1_Digraph_axioms (remove_vertex v) v0 v1", "show \"v0_v1_Digraph_axioms (remove_vertex v) v0 v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v0_v1_Digraph_axioms (remove_vertex v) v0 v1", "using assms v0_nonadj_v1 v0_neq_v1 v0_V v1_V remove_vertex_V remove_vertex_E'"], ["proof (prove)\nusing this:\n  v \\<noteq> v0\n  v \\<noteq> v1\n  (v0, v1) \\<notin> E\n  v0 \\<noteq> v1\n  v0 \\<in> V\n  v1 \\<in> V\n  V\\<^bsub>remove_vertex ?x\\<^esub> = V - {?x}\n  ?v \\<rightarrow>\\<^bsub>remove_vertex ?x\\<^esub> ?w \\<Longrightarrow>\n  ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. v0_v1_Digraph_axioms (remove_vertex v) v0 v1", "by unfold_locales blast+"], ["proof (state)\nthis:\n  v0_v1_Digraph_axioms (remove_vertex v) v0 v1\n\ngoal (1 subgoal):\n 1. Digraph (remove_vertex v)", "qed (simp add: remove_vertex_Digraph)"], ["", "subsection \\<open>Undirected Graphs\\<close>"], ["", "text \\<open>\n  We represent undirecteded graphs as a special case of digraphs where every undirected edge\n  is represented as an edge in both directions.  We also exclude loops because loops are uncommon\n  in undirected graphs.\n\n  As we will explain in the next paragraph, all of this has no bearing on the validity of\n  Menger's Theorem for undirected graphs.\n\\<close>"], ["", "locale Graph = Digraph +\n  assumes undirected: \"v\\<rightarrow>w = w\\<rightarrow>v\"\n      and no_loops: \"\\<not>v\\<rightarrow>v\""], ["", "text \\<open>\n  We observe that this makes @{locale Digraph} a sublocale of @{locale Graph}, meaning that every\n  theorem we prove for digraphs automatically holds for undirected graphs, although it may not make\n  sense because for example ``connectedness'' (if we were to define it) would need different\n  definitions for directed and undirected graphs.\n\n  Fortunately, the notions of ``separator'' and ``internally vertex-disjoint paths'' on directed\n  graphs are the same for undirected graphs.  So Menger's Theorem, when we eventually prove it in\n  the @{locale Digraph} locale, will apply automatically to the @{locale Graph} locale without\n  any additional work.\n\n  For this reason we will not use the @{term Graph} locale again in this proof development and it\n  exists merely to show that undirected graphs are covered as a special case by our definitions.\n\\<close>"], ["", "end"]]}