{"file_name": "/home/qj213/afp-2021-10-22/thys/ComponentDependencies/DataDependencies.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ComponentDependencies", "problem_names": ["lemma correctDeCompositionVARempty:\n  assumes \"correctCompositionVAR S\" \n          and \"VAR S = {}\"\n  shows    \"\\<forall> C \\<in>  subcomp S. VAR C = {}\"", "lemma\n  OUTfromV_VARto_lemma: \n assumes \"OUTfromV x \\<noteq> {}\"  and \"OUTfromV_VARto\"\n shows    \"\\<exists> v::varID. x \\<in> (VARto v)\"", "lemma DSourcesLevelX:\n\"(DSources i X)  \\<subseteq> (AbstrLevel i)\"", "lemma Acc_SourcesNOT: \"(X \\<notin> Acc i C) = (C \\<notin> Sources i X)\"", "lemma isNotSource_isNotSourceX:\n\"isNotDSource i S = (\\<forall> C. isNotDSourceX i S C)\"", "lemma DAcc_DSources:\n\"(X \\<in> DAcc i C) = (C \\<in> DSources i X)\"", "lemma DAcc_DSourcesNOT:\n\"(X \\<notin> DAcc i C) = (C \\<notin> DSources i X)\"", "lemma DSource_level:\n  assumes \"S \\<in> (DSources i C)\"\n  shows    \"C  \\<in> (AbstrLevel i)\"", "lemma SourceExistsDSource_level:\n  assumes \"S \\<in> (Sources i C)\"\n  shows    \"\\<exists> Z  \\<in> (AbstrLevel i). (S \\<in> (DSources i Z))\"", "lemma Sources_DSources:\n \"(DSources i C) \\<subseteq> (Sources i C)\"", "lemma NoDSourceNoSource:\n  assumes \"S \\<notin> (Sources i C)\"\n  shows     \"S \\<notin> (DSources i C)\"", "lemma DSourcesEmptySources:\n  assumes \"DSources i C = {}\"\n  shows    \"Sources i C = {}\"", "lemma DSource_Sources:\n  assumes  \"S \\<in> (DSources i C)\"\n  shows     \"(Sources i S)  \\<subseteq> (Sources i C)\"", "lemma SourcesOnlyDSources:\n  assumes \"\\<forall> X. (X \\<in> (DSources i C) \\<longrightarrow> (DSources i X) = {})\"\n  shows    \"Sources i C = DSources i C\"", "lemma SourcesEmptyDSources:\n assumes \"Sources i C = {}\"\n shows \"DSources i C = {}\"", "lemma NotDSource:\n assumes \"\\<forall> x \\<in> (OUT S). (\\<forall> Z \\<in> (AbstrLevel i). (x \\<notin> (IN Z)))\"\n shows    \"\\<forall> C \\<in> (AbstrLevel i) . S \\<notin> (DSources i C)\"", "lemma allNotDSource_NotSource:\n assumes \"\\<forall> C . S \\<notin> (DSources i C)\" \n shows    \"\\<forall> Z. S \\<notin> (Sources i Z)\"", "lemma NotDSource_NotSource:\n assumes \"\\<forall> C \\<in> (AbstrLevel i). S \\<notin> (DSources i C)\" \n shows    \"\\<forall> Z \\<in> (AbstrLevel i). S \\<notin> (Sources i Z)\"", "lemma isNotSource_Sources: \n assumes \"isNotDSource i S\"\n shows \"\\<forall> C  \\<in> (AbstrLevel i). S \\<notin> (Sources i C)\"", "lemma SourcesAbstrLevel:\nassumes \"x \\<in> Sources i S\"\nshows \"x \\<in> AbstrLevel i\"", "lemma DSourceIsSource:\n  assumes  \"C \\<in> DSources i S\" \n     shows  \"C \\<in> Sources i S\"", "lemma DSourceOfDSource:\n  assumes  \"Z \\<in> DSources i S\" \n         and  \"S \\<in> DSources i C\"\n  shows     \"Z \\<in> Sources i C\"", "lemma SourceOfDSource:\n  assumes  \"Z \\<in> Sources i S\" \n         and  \"S \\<in> DSources i C\"\n  shows     \"Z \\<in> Sources i C\"", "lemma DSourceOfSource:\n  assumes  cDS:\"C \\<in> DSources i S\" \n         and  sS:\"S \\<in> Sources i Z\"  \n  shows     \"C \\<in> Sources i Z\"", "lemma Sources_singleDSource:\n  assumes \"DSources i S = {C}\" \n  shows    \"Sources i S = {C} \\<union> Sources i C\"", "lemma Sources_2DSources:\n  assumes \"DSources i S = {C1, C2}\" \n  shows    \"Sources i S = {C1, C2} \\<union> Sources i C1  \\<union> Sources i C2\"", "lemma Sources_3DSources:\n  assumes \"DSources i S = {C1, C2, C3}\" \n  shows    \"Sources i S = {C1, C2, C3} \\<union> Sources i C1  \\<union> Sources i C2  \\<union> Sources i C3\"", "lemma singleDSourceEmpty4isNotDSource:\n  assumes \"DAcc i C = {S}\" \n         and \"Z \\<noteq> S\"\n  shows \"C \\<notin> (DSources i Z)\"", "lemma singleDSourceEmpty4isNotDSourceLevel:\n  assumes \"DAcc i C = {S}\"\n  shows \"\\<forall> Z \\<in> (AbstrLevel i). Z \\<noteq> S \\<longrightarrow> C \\<notin> (DSources i Z)\"", "lemma \"isNotDSource_EmptyDAcc\":\n  assumes \"isNotDSource i S\" \n  shows    \"DAcc i S ={}\"", "lemma \"isNotDSource_EmptyAcc\":\n  assumes \"isNotDSource i S\" \n  shows    \"Acc i S = {}\"", "lemma singleDSourceEmpty_Acc:\n  assumes \"DAcc i C = {S}\" \n         and \"isNotDSource i S\" \n  shows  \"Acc i C = {S}\"", "lemma singleDSourceEmpty4isNotSource:\n  assumes \"DAcc i C = {S}\"\n         and nSourcS:\"isNotDSource i S\"\n         and \"Z \\<noteq> S\"\n  shows \"C \\<notin> (Sources i Z)\"", "lemma singleDSourceEmpty4isNotSourceLevel:\n  assumes \"DAcc i C = {S}\"\n         and nSourcS:\"isNotDSource i S\" \n  shows \"\\<forall> Z \\<in> (AbstrLevel i). Z \\<noteq> S \\<longrightarrow> C \\<notin> (Sources i Z)\"", "lemma singleDSourceLoop:\n  assumes \"DAcc i C = {S}\"\n         and \"DAcc i S = {C}\"\n  shows \"\\<forall> Z \\<in> (AbstrLevel i). (Z \\<noteq> S \\<and> Z \\<noteq> C \\<longrightarrow> C \\<notin> (Sources i Z))\"", "lemma outSetCorelatedEmpty1:\n assumes \"OUTfromV x = {}\"\n shows \"outSetCorelated x = {}\"", "lemma outSetCorelatedNonemptyX:\n assumes \"OUTfromV x  \\<noteq> {}\" and correct3:\"OUTfromV_VARto\"\n shows \"x \\<in> outSetCorelated x\"", "lemma outSetCorelatedEmpty2:\n assumes \"outSetCorelated x = {}\"   and correct3:\"OUTfromV_VARto\"\n shows  \"OUTfromV x = {}\"", "lemma systemIN_noOUT:\n  assumes \"systemIN x i\"\n  shows    \"\\<not> systemOUT x i\"", "lemma systemOUT_noIN:\n  assumes \"systemOUT x i\"\n  shows    \"\\<not> systemIN x i\"", "lemma systemIN_noLOC:\n  assumes \"systemIN x i\"\n  shows    \"\\<not> systemLOC x i\"", "lemma systemLOC_noIN:\n  assumes \"systemLOC x i\"\n  shows    \"\\<not> systemIN x i\"", "lemma systemOUT_noLOC:\n  assumes \"systemOUT x i\"\n  shows    \"\\<not> systemLOC x i\"", "lemma systemLOC_noOUT:\n  assumes \"systemLOC x i\"\n  shows    \"\\<not> systemOUT x i\"", "lemma outSetOfComponentsLimit:\n\"outSetOfComponents i chSet \\<subseteq> AbstrLevel i\"", "lemma inSetOfComponentsLimit:\n\"inSetOfComponents i chSet \\<subseteq> AbstrLevel i\"", "lemma SourcesLevelLimit:\n\"(\\<Union> S \\<in> (outSetOfComponents i chSet). (Sources i S)) \\<subseteq> AbstrLevel i\"", "lemma minSetOfComponentsLimit:\n\"minSetOfComponents i chSet \\<subseteq> AbstrLevel i\""], "translations": [["", "lemma correctDeCompositionVARempty:\n  assumes \"correctCompositionVAR S\" \n          and \"VAR S = {}\"\n  shows    \"\\<forall> C \\<in>  subcomp S. VAR C = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>subcomp S. VAR C = {}", "using assms"], ["proof (prove)\nusing this:\n  correctCompositionVAR S\n  VAR S = {}\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>subcomp S. VAR C = {}", "by (metis all_not_in_conv correctCompositionVAR_def)\n\n\n\\<comment> \\<open>function OUTfrom maps channel ID to the set of input channels it depends from,\\<close>\n\\<comment> \\<open>directly (OUTfromCh) or via local variables (VARfrom)\\<close> \n\\<comment> \\<open>an empty set means that the channel is either input of the system or\\<close>\n\\<comment> \\<open>its values are generated within some component independently\\<close>"], ["", "definition OUTfrom ::  \"chanID \\<Rightarrow> chanID set\"\nwhere\n \"OUTfrom x \\<equiv> (OUTfromCh x) \\<union> {y. \\<exists> v. v \\<in> (OUTfromV x) \\<and> y \\<in> (VARfrom v)}\"\n \n\\<comment> \\<open>if x depends from some input channel(s) directly, then exists\\<close>\n\\<comment> \\<open>a component which has them as input channels and x as an output channel\\<close>"], ["", "definition\n  OUTfromChCorrect :: \"chanID \\<Rightarrow> bool\"\nwhere\n  \"OUTfromChCorrect x \\<equiv>\n   (OUTfromCh x \\<noteq> {} \\<longrightarrow> \n      (\\<exists> Z . (x \\<in> (OUT Z) \\<and> (\\<forall> y \\<in> (OUTfromCh x). y \\<in> IN Z) )))\"\n\n\\<comment> \\<open>General system's property: for channels in the system should hold:\\<close>\n\\<comment> \\<open>if x depends from some input channel(s) directly, then exists\\<close>\n\\<comment> \\<open>a component which has them as input channels and x as an output channel\\<close>"], ["", "definition\n  OUTfromChCorrectSYSTEM :: \"bool\"\nwhere\n  \"OUTfromChCorrectSYSTEM \\<equiv> (\\<forall> x::chanID. (OUTfromChCorrect x))\"\n\n\n\\<comment> \\<open>if x depends from some local variables, then exists a component\\<close>\n\\<comment> \\<open>to which these variables belong and which has  x as an output channel\\<close>"], ["", "definition\n  OUTfromVCorrect1 :: \"chanID \\<Rightarrow> bool\"\nwhere\n  \"OUTfromVCorrect1 x \\<equiv>\n   (OUTfromV x \\<noteq> {} \\<longrightarrow> \n      (\\<exists> Z . (x \\<in> (OUT Z) \\<and> (\\<forall> v \\<in> (OUTfromV x). v \\<in> VAR Z) )))\"\n\n\\<comment> \\<open>General system's property: for channels in the system should hold the above property:\\<close>"], ["", "definition\n  OUTfromVCorrect1SYSTEM :: \"bool\"\nwhere\n  \"OUTfromVCorrect1SYSTEM \\<equiv> (\\<forall> x::chanID. (OUTfromVCorrect1 x))\"\n\n\\<comment> \\<open>if x does not depend from any local variables, then it does not belong to any set VARfrom\\<close>"], ["", "definition\n  OUTfromVCorrect2 :: \"chanID \\<Rightarrow> bool\"\nwhere\n  \"OUTfromVCorrect2 x \\<equiv>\n   (OUTfromV x = {} \\<longrightarrow> (\\<forall> v::varID. x \\<notin> (VARto v)) )\"\n\n\\<comment> \\<open>General system's property: for channels in the system should hold the above property:\\<close>"], ["", "definition\n  OUTfromVCorrect2SYSTEM :: \"bool\"\nwhere\n  \"OUTfromVCorrect2SYSTEM \\<equiv>  (\\<forall> x::chanID. (OUTfromVCorrect2 x))\"\n\n\\<comment> \\<open>General system's property:\\<close>\n\\<comment> \\<open>definitions OUTfromV and VARto should give equivalent mappings\\<close>"], ["", "definition\n  OUTfromV_VARto :: \"bool\"\nwhere\n  \"OUTfromV_VARto \\<equiv>\n   (\\<forall> x::chanID. \\<forall> v::varID. (v \\<in> OUTfromV x \\<longleftrightarrow> x \\<in> (VARto v)) )\"\n\n\\<comment> \\<open>General system's property for abstraction levels 0 and 1\\<close>\n\\<comment> \\<open>if a variable v belongs to a component, then all the channels v\\<close>\n\\<comment> \\<open>depends from should be input channels of this component\\<close>"], ["", "definition\n  VARfromCorrectSYSTEM :: \"bool\"\nwhere\n  \"VARfromCorrectSYSTEM \\<equiv>\n   (\\<forall> v::varID. \\<forall> Z\\<in> ((AbstrLevel level0) \\<union> (AbstrLevel level1)). \n     ( (v \\<in> VAR Z) \\<longrightarrow>  (\\<forall> x \\<in> VARfrom v. x \\<in> IN Z) ))\"\n\n\\<comment> \\<open>General system's property for abstraction levels 0 and 1\\<close>\n\\<comment> \\<open>if a variable v belongs to a component, then all the channels v\\<close>\n\\<comment> \\<open>provides value to should be input channels of this component\\<close>"], ["", "definition\n  VARtoCorrectSYSTEM :: \"bool\"\nwhere\n  \"VARtoCorrectSYSTEM \\<equiv>\n   (\\<forall> v::varID. \\<forall> Z \\<in> ((AbstrLevel level0) \\<union> (AbstrLevel level1)). \n     ( (v \\<in> VAR Z) \\<longrightarrow>   (\\<forall> x \\<in> VARto v. x \\<in> OUT Z)))\"\n\n\\<comment> \\<open>to detect local variables, unused for computation of any output\\<close>"], ["", "definition\n  VARusefulSYSTEM :: \"bool\"\nwhere\n  \"VARusefulSYSTEM \\<equiv> (\\<forall> v::varID. (VARto v \\<noteq> {}))\""], ["", "lemma\n  OUTfromV_VARto_lemma: \n assumes \"OUTfromV x \\<noteq> {}\"  and \"OUTfromV_VARto\"\n shows    \"\\<exists> v::varID. x \\<in> (VARto v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. x \\<in> VARto v", "using assms"], ["proof (prove)\nusing this:\n  OUTfromV x \\<noteq> {}\n  OUTfromV_VARto\n\ngoal (1 subgoal):\n 1. \\<exists>v. x \\<in> VARto v", "by (simp add: OUTfromV_VARto_def, auto)"], ["", "(*<*)\n(*>*)"], ["", "subsection \\<open>Direct and indirect data dependencies between components\\<close>\n\n\\<comment> \\<open>The component C should be defined on the same abstraction\\<close>\n\\<comment> \\<open>level we are seaching for its direct or indirect sources,\\<close>\n\\<comment> \\<open>otherwise we get an empty set as result\\<close>"], ["", "definition\n  DSources :: \"AbstrLevelsID \\<Rightarrow> CSet \\<Rightarrow> CSet set\"\nwhere\n \"DSources i C \\<equiv> {Z.  \\<exists> x. x \\<in> (IN C) \\<and> x \\<in> (OUT Z) \\<and> Z \\<in> (AbstrLevel i) \\<and> C \\<in> (AbstrLevel i)}\""], ["", "lemma DSourcesLevelX:\n\"(DSources i X)  \\<subseteq> (AbstrLevel i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DSources i X \\<subseteq> AbstrLevel i", "by (simp add: DSources_def, auto)\n\n\\<comment> \\<open>The component C should be defined on the same abstraction level we are\\<close> \n\\<comment> \\<open>seaching for its direct or indirect acceptors (coponents, for which C is a source),\\<close>\n\\<comment> \\<open>otherwise we get an empty set as result\\<close>"], ["", "definition\n  DAcc :: \"AbstrLevelsID \\<Rightarrow> CSet \\<Rightarrow> CSet set\"\nwhere\n \"DAcc i C \\<equiv> {Z.  \\<exists> x. x \\<in> (OUT C) \\<and> x \\<in> (IN Z) \\<and> Z \\<in> (AbstrLevel i) \\<and> C \\<in> (AbstrLevel i)}\""], ["", "axiomatization\n  Sources :: \"AbstrLevelsID \\<Rightarrow> CSet \\<Rightarrow> CSet set\"\nwhere \nSourcesDef:\n\"(Sources i C) = (DSources i C) \\<union> (\\<Union> S \\<in> (DSources i C). (Sources i S))\" \nand\nSourceExistsDSource:\n\"S \\<in> (Sources i C) \\<longrightarrow> (\\<exists> Z. S \\<in> (DSources i Z))\"\nand\nNDSourceExistsDSource:\n\"S \\<in> (Sources i C) \\<and> S \\<notin> (DSources i C) \\<longrightarrow> \n (\\<exists> Z. S \\<in> (DSources i Z) \\<and> Z \\<in> (Sources i C))\"\nand\nSourcesTrans:\n\"(C \\<in> Sources i S \\<and> S \\<in> Sources i Z) \\<longrightarrow> C \\<in> Sources i Z\"\nand \nSourcesLevelX:\n\"(Sources i X)  \\<subseteq> (AbstrLevel i)\" \nand\nSourcesLoop:\n\"(Sources i C) = (XS \\<union> (Sources i S)) \\<and> (Sources i S) = (ZS \\<union> (Sources i C)) \n\\<longrightarrow> (Sources i C) = XS  \\<union> ZS \\<union> { C, S}\" \n\\<comment> \\<open>if we have a loop in the dependencies we need to cut it for counting the sources\\<close>"], ["", "axiomatization\n  Acc :: \"AbstrLevelsID \\<Rightarrow> CSet \\<Rightarrow> CSet set\"\nwhere \nAccDef:\n\"(Acc i C) = (DAcc i C) \\<union> (\\<Union> S \\<in> (DAcc i C). (Acc i S))\" \nand\nAcc_Sources:\n\"(X \\<in> Acc i C) = (C \\<in> Sources i X)\"\nand\nAccSigleLoop:\n\"DAcc i C = {S} \\<and> DAcc i S = {C} \\<longrightarrow> Acc i C = {C, S}\" \nand\nAccLoop:\n\"(Acc i C) = (XS \\<union> (Acc i S)) \\<and> (Acc i S) = (ZS \\<union> (Acc i C)) \n\\<longrightarrow> (Acc i C) = XS  \\<union> ZS \\<union> { C, S}\" \n\\<comment> \\<open>if we have a loop in the dependencies we need to cut it for counting the accessors\\<close>"], ["", "lemma Acc_SourcesNOT: \"(X \\<notin> Acc i C) = (C \\<notin> Sources i X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<notin> Acc i C) = (C \\<notin> Sources i X)", "by (metis Acc_Sources)\n\n\\<comment> \\<open>component S is not a source for any component on the abstraction level i\\<close>"], ["", "definition\n  isNotDSource :: \"AbstrLevelsID \\<Rightarrow> CSet \\<Rightarrow> bool\"\nwhere\n \"isNotDSource i S \\<equiv> (\\<forall> x \\<in> (OUT S). (\\<forall> Z \\<in> (AbstrLevel i). (x \\<notin> (IN Z))))\"\n\n\\<comment> \\<open>component S is not a source for a component Z on the abstraction level i\\<close>"], ["", "definition\n  isNotDSourceX :: \"AbstrLevelsID \\<Rightarrow> CSet \\<Rightarrow> CSet \\<Rightarrow> bool\"\nwhere\n \"isNotDSourceX i S C \\<equiv> (\\<forall> x \\<in> (OUT S). (C \\<notin> (AbstrLevel i) \\<or> (x \\<notin> (IN C))))\""], ["", "lemma isNotSource_isNotSourceX:\n\"isNotDSource i S = (\\<forall> C. isNotDSourceX i S C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isNotDSource i S = (\\<forall>C. isNotDSourceX i S C)", "by (auto, (simp add: isNotDSource_def isNotDSourceX_def)+)"], ["", "lemma DAcc_DSources:\n\"(X \\<in> DAcc i C) = (C \\<in> DSources i X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> DAcc i C) = (C \\<in> DSources i X)", "by (auto, (simp add: DAcc_def DSources_def, auto)+)"], ["", "lemma DAcc_DSourcesNOT:\n\"(X \\<notin> DAcc i C) = (C \\<notin> DSources i X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<notin> DAcc i C) = (C \\<notin> DSources i X)", "by (auto, (simp add: DAcc_def DSources_def, auto)+)"], ["", "lemma DSource_level:\n  assumes \"S \\<in> (DSources i C)\"\n  shows    \"C  \\<in> (AbstrLevel i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> AbstrLevel i", "using assms"], ["proof (prove)\nusing this:\n  S \\<in> DSources i C\n\ngoal (1 subgoal):\n 1. C \\<in> AbstrLevel i", "by (simp add: DSources_def, auto)"], ["", "lemma SourceExistsDSource_level:\n  assumes \"S \\<in> (Sources i C)\"\n  shows    \"\\<exists> Z  \\<in> (AbstrLevel i). (S \\<in> (DSources i Z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Z\\<in>AbstrLevel i. S \\<in> DSources i Z", "using assms"], ["proof (prove)\nusing this:\n  S \\<in> Sources i C\n\ngoal (1 subgoal):\n 1. \\<exists>Z\\<in>AbstrLevel i. S \\<in> DSources i Z", "by (metis DSource_level SourceExistsDSource)"], ["", "lemma Sources_DSources:\n \"(DSources i C) \\<subseteq> (Sources i C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DSources i C \\<subseteq> Sources i C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DSources i C \\<subseteq> Sources i C", "have \"(Sources i C) = (DSources i C) \\<union> (\\<Union> S \\<in> (DSources i C). (Sources i S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)", "by (rule SourcesDef)"], ["proof (state)\nthis:\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)\n\ngoal (1 subgoal):\n 1. DSources i C \\<subseteq> Sources i C", "thus ?thesis"], ["proof (prove)\nusing this:\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)\n\ngoal (1 subgoal):\n 1. DSources i C \\<subseteq> Sources i C", "by auto"], ["proof (state)\nthis:\n  DSources i C \\<subseteq> Sources i C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NoDSourceNoSource:\n  assumes \"S \\<notin> (Sources i C)\"\n  shows     \"S \\<notin> (DSources i C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<notin> DSources i C", "using assms"], ["proof (prove)\nusing this:\n  S \\<notin> Sources i C\n\ngoal (1 subgoal):\n 1. S \\<notin> DSources i C", "by (metis (full_types) Sources_DSources rev_subsetD)"], ["", "lemma DSourcesEmptySources:\n  assumes \"DSources i C = {}\"\n  shows    \"Sources i C = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i C = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sources i C = {}", "have \"(Sources i C) = (DSources i C) \\<union> (\\<Union> S \\<in> (DSources i C). (Sources i S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)", "by (rule SourcesDef)"], ["proof (state)\nthis:\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)\n\ngoal (1 subgoal):\n 1. Sources i C = {}", "with assms"], ["proof (chain)\npicking this:\n  DSources i C = {}\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)", "show ?thesis"], ["proof (prove)\nusing this:\n  DSources i C = {}\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)\n\ngoal (1 subgoal):\n 1. Sources i C = {}", "by auto"], ["proof (state)\nthis:\n  Sources i C = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DSource_Sources:\n  assumes  \"S \\<in> (DSources i C)\"\n  shows     \"(Sources i S)  \\<subseteq> (Sources i C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i S \\<subseteq> Sources i C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sources i S \\<subseteq> Sources i C", "have  \"(Sources i C) = (DSources i C) \\<union> (\\<Union> S \\<in> (DSources i C). (Sources i S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)", "by (rule SourcesDef)"], ["proof (state)\nthis:\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)\n\ngoal (1 subgoal):\n 1. Sources i S \\<subseteq> Sources i C", "with assms"], ["proof (chain)\npicking this:\n  S \\<in> DSources i C\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)", "show ?thesis"], ["proof (prove)\nusing this:\n  S \\<in> DSources i C\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)\n\ngoal (1 subgoal):\n 1. Sources i S \\<subseteq> Sources i C", "by auto"], ["proof (state)\nthis:\n  Sources i S \\<subseteq> Sources i C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SourcesOnlyDSources:\n  assumes \"\\<forall> X. (X \\<in> (DSources i C) \\<longrightarrow> (DSources i X) = {})\"\n  shows    \"Sources i C = DSources i C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i C = DSources i C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sources i C = DSources i C", "have sDef:  \"(Sources i C) = (DSources i C) \\<union> (\\<Union> S \\<in> (DSources i C). (Sources i S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)", "by (rule SourcesDef)"], ["proof (state)\nthis:\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)\n\ngoal (1 subgoal):\n 1. Sources i C = DSources i C", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>X. X \\<in> DSources i C \\<longrightarrow> DSources i X = {}", "have  \"\\<forall> X. (X \\<in> (DSources i C) \\<longrightarrow> (Sources i X) = {})\""], ["proof (prove)\nusing this:\n  \\<forall>X. X \\<in> DSources i C \\<longrightarrow> DSources i X = {}\n\ngoal (1 subgoal):\n 1. \\<forall>X. X \\<in> DSources i C \\<longrightarrow> Sources i X = {}", "by (simp add: DSourcesEmptySources)"], ["proof (state)\nthis:\n  \\<forall>X. X \\<in> DSources i C \\<longrightarrow> Sources i X = {}\n\ngoal (1 subgoal):\n 1. Sources i C = DSources i C", "hence \"(\\<Union> S \\<in> (DSources i C). (Sources i S)) = {}\""], ["proof (prove)\nusing this:\n  \\<forall>X. X \\<in> DSources i C \\<longrightarrow> Sources i X = {}\n\ngoal (1 subgoal):\n 1. \\<Union> (Sources i ` DSources i C) = {}", "by auto"], ["proof (state)\nthis:\n  \\<Union> (Sources i ` DSources i C) = {}\n\ngoal (1 subgoal):\n 1. Sources i C = DSources i C", "with sDef"], ["proof (chain)\npicking this:\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)\n  \\<Union> (Sources i ` DSources i C) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Sources i C = DSources i C \\<union> \\<Union> (Sources i ` DSources i C)\n  \\<Union> (Sources i ` DSources i C) = {}\n\ngoal (1 subgoal):\n 1. Sources i C = DSources i C", "by simp"], ["proof (state)\nthis:\n  Sources i C = DSources i C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SourcesEmptyDSources:\n assumes \"Sources i C = {}\"\n shows \"DSources i C = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DSources i C = {}", "using assms"], ["proof (prove)\nusing this:\n  Sources i C = {}\n\ngoal (1 subgoal):\n 1. DSources i C = {}", "by (metis Sources_DSources bot.extremum_uniqueI)"], ["", "lemma NotDSource:\n assumes \"\\<forall> x \\<in> (OUT S). (\\<forall> Z \\<in> (AbstrLevel i). (x \\<notin> (IN Z)))\"\n shows    \"\\<forall> C \\<in> (AbstrLevel i) . S \\<notin> (DSources i C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>AbstrLevel i. S \\<notin> DSources i C", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>OUT S. \\<forall>Z\\<in>AbstrLevel i. x \\<notin> IN Z\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>AbstrLevel i. S \\<notin> DSources i C", "by (simp add: AbstrLevel0 DSources_def)"], ["", "lemma allNotDSource_NotSource:\n assumes \"\\<forall> C . S \\<notin> (DSources i C)\" \n shows    \"\\<forall> Z. S \\<notin> (Sources i Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Z. S \\<notin> Sources i Z", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>C. S \\<notin> DSources i C\n\ngoal (1 subgoal):\n 1. \\<forall>Z. S \\<notin> Sources i Z", "by (metis SourceExistsDSource)"], ["", "lemma NotDSource_NotSource:\n assumes \"\\<forall> C \\<in> (AbstrLevel i). S \\<notin> (DSources i C)\" \n shows    \"\\<forall> Z \\<in> (AbstrLevel i). S \\<notin> (Sources i Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Z\\<in>AbstrLevel i. S \\<notin> Sources i Z", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>AbstrLevel i. S \\<notin> DSources i C\n\ngoal (1 subgoal):\n 1. \\<forall>Z\\<in>AbstrLevel i. S \\<notin> Sources i Z", "by (metis SourceExistsDSource_level)"], ["", "lemma isNotSource_Sources: \n assumes \"isNotDSource i S\"\n shows \"\\<forall> C  \\<in> (AbstrLevel i). S \\<notin> (Sources i C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>AbstrLevel i. S \\<notin> Sources i C", "using assms"], ["proof (prove)\nusing this:\n  isNotDSource i S\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>AbstrLevel i. S \\<notin> Sources i C", "by (simp add: isNotDSource_def, metis (full_types) NotDSource NotDSource_NotSource)"], ["", "lemma SourcesAbstrLevel:\nassumes \"x \\<in> Sources i S\"\nshows \"x \\<in> AbstrLevel i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> AbstrLevel i", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Sources i S\n\ngoal (1 subgoal):\n 1. x \\<in> AbstrLevel i", "by (metis SourcesLevelX in_mono)"], ["", "lemma DSourceIsSource:\n  assumes  \"C \\<in> DSources i S\" \n     shows  \"C \\<in> Sources i S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> Sources i S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<in> Sources i S", "have \"(Sources i S) = (DSources i S) \\<union> (\\<Union> Z \\<in> (DSources i S). (Sources i Z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)", "by (rule SourcesDef)"], ["proof (state)\nthis:\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n\ngoal (1 subgoal):\n 1. C \\<in> Sources i S", "with assms"], ["proof (chain)\npicking this:\n  C \\<in> DSources i S\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> DSources i S\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n\ngoal (1 subgoal):\n 1. C \\<in> Sources i S", "by simp"], ["proof (state)\nthis:\n  C \\<in> Sources i S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DSourceOfDSource:\n  assumes  \"Z \\<in> DSources i S\" \n         and  \"S \\<in> DSources i C\"\n  shows     \"Z \\<in> Sources i C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<in> Sources i C", "using assms"], ["proof (prove)\nusing this:\n  Z \\<in> DSources i S\n  S \\<in> DSources i C\n\ngoal (1 subgoal):\n 1. Z \\<in> Sources i C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z \\<in> DSources i S; S \\<in> DSources i C\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> Sources i C", "from assms"], ["proof (chain)\npicking this:\n  Z \\<in> DSources i S\n  S \\<in> DSources i C", "have src:\"Sources i S \\<subseteq> Sources i C\""], ["proof (prove)\nusing this:\n  Z \\<in> DSources i S\n  S \\<in> DSources i C\n\ngoal (1 subgoal):\n 1. Sources i S \\<subseteq> Sources i C", "by (simp add: DSource_Sources)"], ["proof (state)\nthis:\n  Sources i S \\<subseteq> Sources i C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Z \\<in> DSources i S; S \\<in> DSources i C\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> Sources i C", "from assms"], ["proof (chain)\npicking this:\n  Z \\<in> DSources i S\n  S \\<in> DSources i C", "have  \"Z \\<in> Sources i S\""], ["proof (prove)\nusing this:\n  Z \\<in> DSources i S\n  S \\<in> DSources i C\n\ngoal (1 subgoal):\n 1. Z \\<in> Sources i S", "by (simp add: DSourceIsSource)"], ["proof (state)\nthis:\n  Z \\<in> Sources i S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Z \\<in> DSources i S; S \\<in> DSources i C\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> Sources i C", "with src"], ["proof (chain)\npicking this:\n  Sources i S \\<subseteq> Sources i C\n  Z \\<in> Sources i S", "show ?thesis"], ["proof (prove)\nusing this:\n  Sources i S \\<subseteq> Sources i C\n  Z \\<in> Sources i S\n\ngoal (1 subgoal):\n 1. Z \\<in> Sources i C", "by auto"], ["proof (state)\nthis:\n  Z \\<in> Sources i C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SourceOfDSource:\n  assumes  \"Z \\<in> Sources i S\" \n         and  \"S \\<in> DSources i C\"\n  shows     \"Z \\<in> Sources i C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<in> Sources i C", "using assms"], ["proof (prove)\nusing this:\n  Z \\<in> Sources i S\n  S \\<in> DSources i C\n\ngoal (1 subgoal):\n 1. Z \\<in> Sources i C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z \\<in> Sources i S; S \\<in> DSources i C\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> Sources i C", "from assms"], ["proof (chain)\npicking this:\n  Z \\<in> Sources i S\n  S \\<in> DSources i C", "have \"Sources i S \\<subseteq> Sources i C\""], ["proof (prove)\nusing this:\n  Z \\<in> Sources i S\n  S \\<in> DSources i C\n\ngoal (1 subgoal):\n 1. Sources i S \\<subseteq> Sources i C", "by (simp add: DSource_Sources)"], ["proof (state)\nthis:\n  Sources i S \\<subseteq> Sources i C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Z \\<in> Sources i S; S \\<in> DSources i C\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> Sources i C", "thus ?thesis"], ["proof (prove)\nusing this:\n  Sources i S \\<subseteq> Sources i C\n\ngoal (1 subgoal):\n 1. Z \\<in> Sources i C", "by (metis (full_types) assms(1) rev_subsetD)"], ["proof (state)\nthis:\n  Z \\<in> Sources i C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DSourceOfSource:\n  assumes  cDS:\"C \\<in> DSources i S\" \n         and  sS:\"S \\<in> Sources i Z\"  \n  shows     \"C \\<in> Sources i Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> Sources i Z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<in> Sources i Z", "from cDS"], ["proof (chain)\npicking this:\n  C \\<in> DSources i S", "have  \"C \\<in> Sources i S\""], ["proof (prove)\nusing this:\n  C \\<in> DSources i S\n\ngoal (1 subgoal):\n 1. C \\<in> Sources i S", "by (simp add: DSourceIsSource)"], ["proof (state)\nthis:\n  C \\<in> Sources i S\n\ngoal (1 subgoal):\n 1. C \\<in> Sources i Z", "from this and sS"], ["proof (chain)\npicking this:\n  C \\<in> Sources i S\n  S \\<in> Sources i Z", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> Sources i S\n  S \\<in> Sources i Z\n\ngoal (1 subgoal):\n 1. C \\<in> Sources i Z", "by (metis (full_types) SourcesTrans)"], ["proof (state)\nthis:\n  C \\<in> Sources i Z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sources_singleDSource:\n  assumes \"DSources i S = {C}\" \n  shows    \"Sources i S = {C} \\<union> Sources i C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i S = {C} \\<union> Sources i C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sources i S = {C} \\<union> Sources i C", "have sDef:  \"(Sources i S) = (DSources i S) \\<union> (\\<Union> Z \\<in> (DSources i S). (Sources i Z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)", "by (rule SourcesDef)"], ["proof (state)\nthis:\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n\ngoal (1 subgoal):\n 1. Sources i S = {C} \\<union> Sources i C", "from assms"], ["proof (chain)\npicking this:\n  DSources i S = {C}", "have \"(\\<Union> Z \\<in> (DSources i S). (Sources i Z)) = Sources i C\""], ["proof (prove)\nusing this:\n  DSources i S = {C}\n\ngoal (1 subgoal):\n 1. \\<Union> (Sources i ` DSources i S) = Sources i C", "by auto"], ["proof (state)\nthis:\n  \\<Union> (Sources i ` DSources i S) = Sources i C\n\ngoal (1 subgoal):\n 1. Sources i S = {C} \\<union> Sources i C", "with sDef assms"], ["proof (chain)\npicking this:\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n  DSources i S = {C}\n  \\<Union> (Sources i ` DSources i S) = Sources i C", "show ?thesis"], ["proof (prove)\nusing this:\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n  DSources i S = {C}\n  \\<Union> (Sources i ` DSources i S) = Sources i C\n\ngoal (1 subgoal):\n 1. Sources i S = {C} \\<union> Sources i C", "by simp"], ["proof (state)\nthis:\n  Sources i S = {C} \\<union> Sources i C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sources_2DSources:\n  assumes \"DSources i S = {C1, C2}\" \n  shows    \"Sources i S = {C1, C2} \\<union> Sources i C1  \\<union> Sources i C2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i S = {C1, C2} \\<union> Sources i C1 \\<union> Sources i C2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sources i S = {C1, C2} \\<union> Sources i C1 \\<union> Sources i C2", "have sDef:  \"(Sources i S) = (DSources i S) \\<union> (\\<Union> Z \\<in> (DSources i S). (Sources i Z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)", "by (rule SourcesDef)"], ["proof (state)\nthis:\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n\ngoal (1 subgoal):\n 1. Sources i S = {C1, C2} \\<union> Sources i C1 \\<union> Sources i C2", "from assms"], ["proof (chain)\npicking this:\n  DSources i S = {C1, C2}", "have \"(\\<Union> Z \\<in> (DSources i S). (Sources i Z)) = Sources i C1  \\<union> Sources i C2\""], ["proof (prove)\nusing this:\n  DSources i S = {C1, C2}\n\ngoal (1 subgoal):\n 1. \\<Union> (Sources i ` DSources i S) = Sources i C1 \\<union> Sources i C2", "by auto"], ["proof (state)\nthis:\n  \\<Union> (Sources i ` DSources i S) = Sources i C1 \\<union> Sources i C2\n\ngoal (1 subgoal):\n 1. Sources i S = {C1, C2} \\<union> Sources i C1 \\<union> Sources i C2", "with sDef and assms"], ["proof (chain)\npicking this:\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n  DSources i S = {C1, C2}\n  \\<Union> (Sources i ` DSources i S) = Sources i C1 \\<union> Sources i C2", "show ?thesis"], ["proof (prove)\nusing this:\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n  DSources i S = {C1, C2}\n  \\<Union> (Sources i ` DSources i S) = Sources i C1 \\<union> Sources i C2\n\ngoal (1 subgoal):\n 1. Sources i S = {C1, C2} \\<union> Sources i C1 \\<union> Sources i C2", "by simp"], ["proof (state)\nthis:\n  Sources i S = {C1, C2} \\<union> Sources i C1 \\<union> Sources i C2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sources_3DSources:\n  assumes \"DSources i S = {C1, C2, C3}\" \n  shows    \"Sources i S = {C1, C2, C3} \\<union> Sources i C1  \\<union> Sources i C2  \\<union> Sources i C3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i S =\n    {C1, C2, C3} \\<union> Sources i C1 \\<union> Sources i C2 \\<union>\n    Sources i C3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sources i S =\n    {C1, C2, C3} \\<union> Sources i C1 \\<union> Sources i C2 \\<union>\n    Sources i C3", "have sDef: \"(Sources i S) = (DSources i S) \\<union> (\\<Union> Z \\<in> (DSources i S). (Sources i Z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)", "by (rule SourcesDef)"], ["proof (state)\nthis:\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n\ngoal (1 subgoal):\n 1. Sources i S =\n    {C1, C2, C3} \\<union> Sources i C1 \\<union> Sources i C2 \\<union>\n    Sources i C3", "from assms"], ["proof (chain)\npicking this:\n  DSources i S = {C1, C2, C3}", "have \"(\\<Union> Z \\<in> (DSources i S). (Sources i Z)) = Sources i C1  \\<union> Sources i C2  \\<union> Sources i C3\""], ["proof (prove)\nusing this:\n  DSources i S = {C1, C2, C3}\n\ngoal (1 subgoal):\n 1. \\<Union> (Sources i ` DSources i S) =\n    Sources i C1 \\<union> Sources i C2 \\<union> Sources i C3", "by auto"], ["proof (state)\nthis:\n  \\<Union> (Sources i ` DSources i S) =\n  Sources i C1 \\<union> Sources i C2 \\<union> Sources i C3\n\ngoal (1 subgoal):\n 1. Sources i S =\n    {C1, C2, C3} \\<union> Sources i C1 \\<union> Sources i C2 \\<union>\n    Sources i C3", "with sDef and assms"], ["proof (chain)\npicking this:\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n  DSources i S = {C1, C2, C3}\n  \\<Union> (Sources i ` DSources i S) =\n  Sources i C1 \\<union> Sources i C2 \\<union> Sources i C3", "show ?thesis"], ["proof (prove)\nusing this:\n  Sources i S = DSources i S \\<union> \\<Union> (Sources i ` DSources i S)\n  DSources i S = {C1, C2, C3}\n  \\<Union> (Sources i ` DSources i S) =\n  Sources i C1 \\<union> Sources i C2 \\<union> Sources i C3\n\ngoal (1 subgoal):\n 1. Sources i S =\n    {C1, C2, C3} \\<union> Sources i C1 \\<union> Sources i C2 \\<union>\n    Sources i C3", "by simp"], ["proof (state)\nthis:\n  Sources i S =\n  {C1, C2, C3} \\<union> Sources i C1 \\<union> Sources i C2 \\<union>\n  Sources i C3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleDSourceEmpty4isNotDSource:\n  assumes \"DAcc i C = {S}\" \n         and \"Z \\<noteq> S\"\n  shows \"C \\<notin> (DSources i Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<notin> DSources i Z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<notin> DSources i Z", "from assms"], ["proof (chain)\npicking this:\n  DAcc i C = {S}\n  Z \\<noteq> S", "have \"(Z \\<notin> DAcc i C)\""], ["proof (prove)\nusing this:\n  DAcc i C = {S}\n  Z \\<noteq> S\n\ngoal (1 subgoal):\n 1. Z \\<notin> DAcc i C", "by simp"], ["proof (state)\nthis:\n  Z \\<notin> DAcc i C\n\ngoal (1 subgoal):\n 1. C \\<notin> DSources i Z", "thus ?thesis"], ["proof (prove)\nusing this:\n  Z \\<notin> DAcc i C\n\ngoal (1 subgoal):\n 1. C \\<notin> DSources i Z", "by (simp add: DAcc_DSourcesNOT)"], ["proof (state)\nthis:\n  C \\<notin> DSources i Z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleDSourceEmpty4isNotDSourceLevel:\n  assumes \"DAcc i C = {S}\"\n  shows \"\\<forall> Z \\<in> (AbstrLevel i). Z \\<noteq> S \\<longrightarrow> C \\<notin> (DSources i Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Z\\<in>AbstrLevel i.\n       Z \\<noteq> S \\<longrightarrow> C \\<notin> DSources i Z", "using assms"], ["proof (prove)\nusing this:\n  DAcc i C = {S}\n\ngoal (1 subgoal):\n 1. \\<forall>Z\\<in>AbstrLevel i.\n       Z \\<noteq> S \\<longrightarrow> C \\<notin> DSources i Z", "by (metis singleDSourceEmpty4isNotDSource)"], ["", "lemma \"isNotDSource_EmptyDAcc\":\n  assumes \"isNotDSource i S\" \n  shows    \"DAcc i S ={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DAcc i S = {}", "using assms"], ["proof (prove)\nusing this:\n  isNotDSource i S\n\ngoal (1 subgoal):\n 1. DAcc i S = {}", "by (simp add: DAcc_def isNotDSource_def, auto)"], ["", "lemma \"isNotDSource_EmptyAcc\":\n  assumes \"isNotDSource i S\" \n  shows    \"Acc i S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Acc i S = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Acc i S = {}", "have \"(Acc i S) = (DAcc i S) \\<union> (\\<Union> X \\<in> (DAcc i S). (Acc i X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Acc i S = DAcc i S \\<union> \\<Union> (Acc i ` DAcc i S)", "by (rule AccDef)"], ["proof (state)\nthis:\n  Acc i S = DAcc i S \\<union> \\<Union> (Acc i ` DAcc i S)\n\ngoal (1 subgoal):\n 1. Acc i S = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  Acc i S = DAcc i S \\<union> \\<Union> (Acc i ` DAcc i S)\n\ngoal (1 subgoal):\n 1. Acc i S = {}", "by (metis SUP_empty Un_absorb assms isNotDSource_EmptyDAcc)"], ["proof (state)\nthis:\n  Acc i S = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleDSourceEmpty_Acc:\n  assumes \"DAcc i C = {S}\" \n         and \"isNotDSource i S\" \n  shows  \"Acc i C = {S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Acc i C = {S}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Acc i C = {S}", "have AccC:\"(Acc i C) = (DAcc i C) \\<union> (\\<Union> S \\<in> (DAcc i C). (Acc i S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Acc i C = DAcc i C \\<union> \\<Union> (Acc i ` DAcc i C)", "by (rule AccDef)"], ["proof (state)\nthis:\n  Acc i C = DAcc i C \\<union> \\<Union> (Acc i ` DAcc i C)\n\ngoal (1 subgoal):\n 1. Acc i C = {S}", "from assms"], ["proof (chain)\npicking this:\n  DAcc i C = {S}\n  isNotDSource i S", "have \"Acc i S = {}\""], ["proof (prove)\nusing this:\n  DAcc i C = {S}\n  isNotDSource i S\n\ngoal (1 subgoal):\n 1. Acc i S = {}", "by (simp add: isNotDSource_EmptyAcc)"], ["proof (state)\nthis:\n  Acc i S = {}\n\ngoal (1 subgoal):\n 1. Acc i C = {S}", "with AccC"], ["proof (chain)\npicking this:\n  Acc i C = DAcc i C \\<union> \\<Union> (Acc i ` DAcc i C)\n  Acc i S = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Acc i C = DAcc i C \\<union> \\<Union> (Acc i ` DAcc i C)\n  Acc i S = {}\n\ngoal (1 subgoal):\n 1. Acc i C = {S}", "by (metis SUP_empty UN_insert Un_commute Un_empty_left assms(1))"], ["proof (state)\nthis:\n  Acc i C = {S}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleDSourceEmpty4isNotSource:\n  assumes \"DAcc i C = {S}\"\n         and nSourcS:\"isNotDSource i S\"\n         and \"Z \\<noteq> S\"\n  shows \"C \\<notin> (Sources i Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<notin> Sources i Z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<notin> Sources i Z", "from assms"], ["proof (chain)\npicking this:\n  DAcc i C = {S}\n  isNotDSource i S\n  Z \\<noteq> S", "have  \"Acc i C = {S}\""], ["proof (prove)\nusing this:\n  DAcc i C = {S}\n  isNotDSource i S\n  Z \\<noteq> S\n\ngoal (1 subgoal):\n 1. Acc i C = {S}", "by (simp add: singleDSourceEmpty_Acc)"], ["proof (state)\nthis:\n  Acc i C = {S}\n\ngoal (1 subgoal):\n 1. C \\<notin> Sources i Z", "with assms"], ["proof (chain)\npicking this:\n  DAcc i C = {S}\n  isNotDSource i S\n  Z \\<noteq> S\n  Acc i C = {S}", "have \"Z \\<notin> Acc i C\""], ["proof (prove)\nusing this:\n  DAcc i C = {S}\n  isNotDSource i S\n  Z \\<noteq> S\n  Acc i C = {S}\n\ngoal (1 subgoal):\n 1. Z \\<notin> Acc i C", "by simp"], ["proof (state)\nthis:\n  Z \\<notin> Acc i C\n\ngoal (1 subgoal):\n 1. C \\<notin> Sources i Z", "thus ?thesis"], ["proof (prove)\nusing this:\n  Z \\<notin> Acc i C\n\ngoal (1 subgoal):\n 1. C \\<notin> Sources i Z", "by (simp add: Acc_SourcesNOT)"], ["proof (state)\nthis:\n  C \\<notin> Sources i Z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleDSourceEmpty4isNotSourceLevel:\n  assumes \"DAcc i C = {S}\"\n         and nSourcS:\"isNotDSource i S\" \n  shows \"\\<forall> Z \\<in> (AbstrLevel i). Z \\<noteq> S \\<longrightarrow> C \\<notin> (Sources i Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Z\\<in>AbstrLevel i.\n       Z \\<noteq> S \\<longrightarrow> C \\<notin> Sources i Z", "using assms"], ["proof (prove)\nusing this:\n  DAcc i C = {S}\n  isNotDSource i S\n\ngoal (1 subgoal):\n 1. \\<forall>Z\\<in>AbstrLevel i.\n       Z \\<noteq> S \\<longrightarrow> C \\<notin> Sources i Z", "by (metis singleDSourceEmpty4isNotSource)"], ["", "lemma singleDSourceLoop:\n  assumes \"DAcc i C = {S}\"\n         and \"DAcc i S = {C}\"\n  shows \"\\<forall> Z \\<in> (AbstrLevel i). (Z \\<noteq> S \\<and> Z \\<noteq> C \\<longrightarrow> C \\<notin> (Sources i Z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Z\\<in>AbstrLevel i.\n       Z \\<noteq> S \\<and> Z \\<noteq> C \\<longrightarrow>\n       C \\<notin> Sources i Z", "using assms"], ["proof (prove)\nusing this:\n  DAcc i C = {S}\n  DAcc i S = {C}\n\ngoal (1 subgoal):\n 1. \\<forall>Z\\<in>AbstrLevel i.\n       Z \\<noteq> S \\<and> Z \\<noteq> C \\<longrightarrow>\n       C \\<notin> Sources i Z", "by (metis AccSigleLoop Acc_SourcesNOT empty_iff insert_iff)"], ["", "(*<*)\n(*>*)"], ["", "subsection \\<open>Components that are elementary wrt. data dependencies\\<close>\n\n\\<comment> \\<open>two output channels of a component C are corelated, if they mutually depend on the same local variable(s)\\<close>"], ["", "definition\n   outPairCorelated :: \"CSet \\<Rightarrow> chanID \\<Rightarrow> chanID \\<Rightarrow> bool\"\nwhere\n  \"outPairCorelated C x y \\<equiv>\n  (x \\<in> OUT C) \\<and>   (y \\<in> OUT C) \\<and> \n  (OUTfromV x) \\<inter> (OUTfromV y) \\<noteq> {}\"\n\n\\<comment> \\<open>We call a set of output channels of a conponent correlated to it output channel x,\\<close>\n\\<comment> \\<open>if they mutually depend on the same local variable(s)\\<close>"], ["", "definition\n   outSetCorelated :: \"chanID \\<Rightarrow> chanID set\"\nwhere\n  \"outSetCorelated x  \\<equiv> \n  { y::chanID . \\<exists> v::varID. (v \\<in> (OUTfromV x) \\<and> (y \\<in> VARto v)) }\"\n\n\\<comment> \\<open>Elementary component according to the data dependencies.\\<close>\n\\<comment> \\<open>This constraint should hold for all components on the abstraction level 1\\<close>"], ["", "definition\nelementaryCompDD :: \"CSet \\<Rightarrow> bool\"\nwhere\n  \"elementaryCompDD C \\<equiv> \n  ((\\<exists> x. (OUT C) = {x} ) \\<or> \n   (\\<forall> x \\<in> (OUT C). \\<forall> y \\<in> (OUT C). ((outSetCorelated x) \\<inter> (outSetCorelated y) \\<noteq> {}) ))\"\n\n\\<comment> \\<open>the set (outSetCorelated x) is empty if x does not depend from any variable\\<close>"], ["", "lemma outSetCorelatedEmpty1:\n assumes \"OUTfromV x = {}\"\n shows \"outSetCorelated x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outSetCorelated x = {}", "using assms"], ["proof (prove)\nusing this:\n  OUTfromV x = {}\n\ngoal (1 subgoal):\n 1. outSetCorelated x = {}", "by (simp add: outSetCorelated_def)\n\n\\<comment> \\<open>if x depends from at least one variable and the predicates OUTfromV and VARto are defined correctly,\\<close>\n\\<comment> \\<open>the set (outSetCorelated x) contains x itself\\<close>"], ["", "lemma outSetCorelatedNonemptyX:\n assumes \"OUTfromV x  \\<noteq> {}\" and correct3:\"OUTfromV_VARto\"\n shows \"x \\<in> outSetCorelated x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> outSetCorelated x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> outSetCorelated x", "from assms"], ["proof (chain)\npicking this:\n  OUTfromV x \\<noteq> {}\n  OUTfromV_VARto", "have \"\\<exists> v::varID. x \\<in> (VARto v)\""], ["proof (prove)\nusing this:\n  OUTfromV x \\<noteq> {}\n  OUTfromV_VARto\n\ngoal (1 subgoal):\n 1. \\<exists>v. x \\<in> VARto v", "by (rule OUTfromV_VARto_lemma)"], ["proof (state)\nthis:\n  \\<exists>v. x \\<in> VARto v\n\ngoal (1 subgoal):\n 1. x \\<in> outSetCorelated x", "from this and assms"], ["proof (chain)\npicking this:\n  \\<exists>v. x \\<in> VARto v\n  OUTfromV x \\<noteq> {}\n  OUTfromV_VARto", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v. x \\<in> VARto v\n  OUTfromV x \\<noteq> {}\n  OUTfromV_VARto\n\ngoal (1 subgoal):\n 1. x \\<in> outSetCorelated x", "by (simp add:  outSetCorelated_def OUTfromV_VARto_def)"], ["proof (state)\nthis:\n  x \\<in> outSetCorelated x\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>if the set (outSetCorelated x) is empty, this means that x does not depend from any variable\\<close>"], ["", "lemma outSetCorelatedEmpty2:\n assumes \"outSetCorelated x = {}\"   and correct3:\"OUTfromV_VARto\"\n shows  \"OUTfromV x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OUTfromV x = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. OUTfromV x \\<noteq> {} \\<Longrightarrow> False", "assume OUTfromVNonempty:\"OUTfromV x \\<noteq> {}\""], ["proof (state)\nthis:\n  OUTfromV x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. OUTfromV x \\<noteq> {} \\<Longrightarrow> False", "from this and correct3"], ["proof (chain)\npicking this:\n  OUTfromV x \\<noteq> {}\n  OUTfromV_VARto", "have \"x \\<in> outSetCorelated x\""], ["proof (prove)\nusing this:\n  OUTfromV x \\<noteq> {}\n  OUTfromV_VARto\n\ngoal (1 subgoal):\n 1. x \\<in> outSetCorelated x", "by (rule outSetCorelatedNonemptyX)"], ["proof (state)\nthis:\n  x \\<in> outSetCorelated x\n\ngoal (1 subgoal):\n 1. OUTfromV x \\<noteq> {} \\<Longrightarrow> False", "from this and assms"], ["proof (chain)\npicking this:\n  x \\<in> outSetCorelated x\n  outSetCorelated x = {}\n  OUTfromV_VARto", "show False"], ["proof (prove)\nusing this:\n  x \\<in> outSetCorelated x\n  outSetCorelated x = {}\n  OUTfromV_VARto\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)\n(*>*)"], ["", "subsection \\<open>Set of components needed to check a specific property\\<close>\n\n\\<comment> \\<open>set of components specified on abstreaction level i, which input channels belong to the set chSet\\<close>"], ["", "definition\n  inSetOfComponents :: \"AbstrLevelsID \\<Rightarrow> chanID set \\<Rightarrow> CSet set\"\nwhere\n \"inSetOfComponents i chSet \\<equiv>\n  {X. (((IN X) \\<inter> chSet \\<noteq> {})  \\<and> X \\<in> (AbstrLevel i))}\"\n\n\\<comment> \\<open>Set of components from the abstraction level i, which output channels belong to the set chSet\\<close>"], ["", "definition\n  outSetOfComponents :: \"AbstrLevelsID \\<Rightarrow> chanID set \\<Rightarrow> CSet set\"\nwhere\n \"outSetOfComponents i chSet \\<equiv>\n  {Y. (((OUT Y) \\<inter> chSet \\<noteq> {}) \\<and> Y \\<in> (AbstrLevel i))}\"\n\n\\<comment> \\<open>Set of components from the abstraction level i,\\<close>\n\\<comment> \\<open>which have output channels from the set chSet or are sources for such components\\<close>"], ["", "definition\n  minSetOfComponents ::  \"AbstrLevelsID \\<Rightarrow> chanID set \\<Rightarrow> CSet set\"\nwhere\n \"minSetOfComponents i chSet \\<equiv>\n  (outSetOfComponents i chSet) \\<union>\n  (\\<Union> S \\<in> (outSetOfComponents i chSet). (Sources i S))\"\n\n\\<comment> \\<open>Please note that a system output cannot beat the same time a local chanel.\\<close>\n\n\\<comment> \\<open>channel x is a system input on an abstraction level i\\<close>"], ["", "definition systemIN ::\"chanID \\<Rightarrow> AbstrLevelsID \\<Rightarrow> bool\"\nwhere\n  \"systemIN x i \\<equiv> (\\<exists> C1 \\<in> (AbstrLevel i). x \\<in> (IN C1)) \\<and> (\\<forall> C2 \\<in> (AbstrLevel i). x \\<notin> (OUT C2))\"\n\n\\<comment> \\<open>channel x is a system input on an abstraction level i\\<close>"], ["", "definition systemOUT ::\"chanID \\<Rightarrow> AbstrLevelsID \\<Rightarrow> bool\"\nwhere\n  \"systemOUT x i \\<equiv> (\\<forall> C1 \\<in> (AbstrLevel i). x \\<notin> (IN C1)) \\<and> (\\<exists> C2 \\<in> (AbstrLevel i). x \\<in> (OUT C2))\"\n\n\\<comment> \\<open>channel x is a system local channel on an abstraction level i\\<close>"], ["", "definition systemLOC ::\"chanID \\<Rightarrow> AbstrLevelsID \\<Rightarrow> bool\"\nwhere\n  \"systemLOC x i \\<equiv> (\\<exists> C1 \\<in> (AbstrLevel i). x \\<in> (IN C1)) \\<and> (\\<exists> C2 \\<in> (AbstrLevel i). x \\<in> (OUT C2))\""], ["", "lemma systemIN_noOUT:\n  assumes \"systemIN x i\"\n  shows    \"\\<not> systemOUT x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> systemOUT x i", "using assms"], ["proof (prove)\nusing this:\n  systemIN x i\n\ngoal (1 subgoal):\n 1. \\<not> systemOUT x i", "by (simp add: systemIN_def systemOUT_def)"], ["", "lemma systemOUT_noIN:\n  assumes \"systemOUT x i\"\n  shows    \"\\<not> systemIN x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> systemIN x i", "using assms"], ["proof (prove)\nusing this:\n  systemOUT x i\n\ngoal (1 subgoal):\n 1. \\<not> systemIN x i", "by (simp add: systemIN_def systemOUT_def)"], ["", "lemma systemIN_noLOC:\n  assumes \"systemIN x i\"\n  shows    \"\\<not> systemLOC x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> systemLOC x i", "using assms"], ["proof (prove)\nusing this:\n  systemIN x i\n\ngoal (1 subgoal):\n 1. \\<not> systemLOC x i", "by (simp add: systemIN_def systemLOC_def)"], ["", "lemma systemLOC_noIN:\n  assumes \"systemLOC x i\"\n  shows    \"\\<not> systemIN x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> systemIN x i", "using assms"], ["proof (prove)\nusing this:\n  systemLOC x i\n\ngoal (1 subgoal):\n 1. \\<not> systemIN x i", "by (simp add: systemIN_def systemLOC_def)"], ["", "lemma systemOUT_noLOC:\n  assumes \"systemOUT x i\"\n  shows    \"\\<not> systemLOC x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> systemLOC x i", "using assms"], ["proof (prove)\nusing this:\n  systemOUT x i\n\ngoal (1 subgoal):\n 1. \\<not> systemLOC x i", "by (simp add: systemOUT_def systemLOC_def)"], ["", "lemma systemLOC_noOUT:\n  assumes \"systemLOC x i\"\n  shows    \"\\<not> systemOUT x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> systemOUT x i", "using assms"], ["proof (prove)\nusing this:\n  systemLOC x i\n\ngoal (1 subgoal):\n 1. \\<not> systemOUT x i", "by (simp add: systemLOC_def systemOUT_def)"], ["", "definition\n  noIrrelevantChannels ::  \"AbstrLevelsID \\<Rightarrow> chanID set \\<Rightarrow> bool\"\nwhere\n \"noIrrelevantChannels i chSet \\<equiv>\n  \\<forall> x \\<in> chSet. ((systemIN x i) \\<longrightarrow>\n   (\\<exists> Z \\<in> (minSetOfComponents i chSet). x \\<in> (IN Z)))\""], ["", "definition\n  allNeededINChannels ::  \"AbstrLevelsID \\<Rightarrow> chanID set \\<Rightarrow> bool\"\nwhere\n \"allNeededINChannels i chSet \\<equiv>\n  (\\<forall> Z \\<in> (minSetOfComponents i chSet). \\<exists> x \\<in> (IN Z). ((systemIN x i) \\<longrightarrow> (x \\<in> chSet)))\"\n\n\\<comment> \\<open>the set (outSetOfComponents i chSet) should be a subset of all components specified on the abstraction level i\\<close>"], ["", "lemma outSetOfComponentsLimit:\n\"outSetOfComponents i chSet \\<subseteq> AbstrLevel i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outSetOfComponents i chSet \\<subseteq> AbstrLevel i", "by (metis (lifting) mem_Collect_eq outSetOfComponents_def subsetI)\n\n\\<comment> \\<open>the set (inSetOfComponents i chSet) should be a subset of all components specified on the abstraction level i\\<close>"], ["", "lemma inSetOfComponentsLimit:\n\"inSetOfComponents i chSet \\<subseteq> AbstrLevel i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inSetOfComponents i chSet \\<subseteq> AbstrLevel i", "by (metis (lifting) inSetOfComponents_def mem_Collect_eq subsetI)\n\n\\<comment> \\<open>the set of components, which are sources for the components\\<close>\n\\<comment> \\<open>out of (inSetOfComponents i chSet), should be a subset of\\<close> \n\\<comment> \\<open>all components specified on the abstraction level i\\<close>"], ["", "lemma SourcesLevelLimit:\n\"(\\<Union> S \\<in> (outSetOfComponents i chSet). (Sources i S)) \\<subseteq> AbstrLevel i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (Sources i ` outSetOfComponents i chSet)\n    \\<subseteq> AbstrLevel i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (Sources i ` outSetOfComponents i chSet)\n    \\<subseteq> AbstrLevel i", "have sg1:\"outSetOfComponents i chSet \\<subseteq> AbstrLevel i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outSetOfComponents i chSet \\<subseteq> AbstrLevel i", "by (simp add: outSetOfComponentsLimit)"], ["proof (state)\nthis:\n  outSetOfComponents i chSet \\<subseteq> AbstrLevel i\n\ngoal (1 subgoal):\n 1. \\<Union> (Sources i ` outSetOfComponents i chSet)\n    \\<subseteq> AbstrLevel i", "have \"\\<forall> S. S \\<in> (outSetOfComponents i chSet) \\<longrightarrow> Sources i S \\<subseteq> AbstrLevel i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<in> outSetOfComponents i chSet \\<longrightarrow>\n       Sources i S \\<subseteq> AbstrLevel i", "by (metis SourcesLevelX)"], ["proof (state)\nthis:\n  \\<forall>S.\n     S \\<in> outSetOfComponents i chSet \\<longrightarrow>\n     Sources i S \\<subseteq> AbstrLevel i\n\ngoal (1 subgoal):\n 1. \\<Union> (Sources i ` outSetOfComponents i chSet)\n    \\<subseteq> AbstrLevel i", "from this and sg1"], ["proof (chain)\npicking this:\n  \\<forall>S.\n     S \\<in> outSetOfComponents i chSet \\<longrightarrow>\n     Sources i S \\<subseteq> AbstrLevel i\n  outSetOfComponents i chSet \\<subseteq> AbstrLevel i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>S.\n     S \\<in> outSetOfComponents i chSet \\<longrightarrow>\n     Sources i S \\<subseteq> AbstrLevel i\n  outSetOfComponents i chSet \\<subseteq> AbstrLevel i\n\ngoal (1 subgoal):\n 1. \\<Union> (Sources i ` outSetOfComponents i chSet)\n    \\<subseteq> AbstrLevel i", "by auto"], ["proof (state)\nthis:\n  \\<Union> (Sources i ` outSetOfComponents i chSet) \\<subseteq> AbstrLevel i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minSetOfComponentsLimit:\n\"minSetOfComponents i chSet \\<subseteq> AbstrLevel i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minSetOfComponents i chSet \\<subseteq> AbstrLevel i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. minSetOfComponents i chSet \\<subseteq> AbstrLevel i", "have sg1: \"outSetOfComponents i chSet \\<subseteq> AbstrLevel i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outSetOfComponents i chSet \\<subseteq> AbstrLevel i", "by (simp add: outSetOfComponentsLimit)"], ["proof (state)\nthis:\n  outSetOfComponents i chSet \\<subseteq> AbstrLevel i\n\ngoal (1 subgoal):\n 1. minSetOfComponents i chSet \\<subseteq> AbstrLevel i", "have \"(\\<Union> S \\<in> (outSetOfComponents i chSet). (Sources i S)) \\<subseteq> AbstrLevel i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (Sources i ` outSetOfComponents i chSet)\n    \\<subseteq> AbstrLevel i", "by (simp add:  SourcesLevelLimit)"], ["proof (state)\nthis:\n  \\<Union> (Sources i ` outSetOfComponents i chSet) \\<subseteq> AbstrLevel i\n\ngoal (1 subgoal):\n 1. minSetOfComponents i chSet \\<subseteq> AbstrLevel i", "with sg1"], ["proof (chain)\npicking this:\n  outSetOfComponents i chSet \\<subseteq> AbstrLevel i\n  \\<Union> (Sources i ` outSetOfComponents i chSet) \\<subseteq> AbstrLevel i", "show ?thesis"], ["proof (prove)\nusing this:\n  outSetOfComponents i chSet \\<subseteq> AbstrLevel i\n  \\<Union> (Sources i ` outSetOfComponents i chSet) \\<subseteq> AbstrLevel i\n\ngoal (1 subgoal):\n 1. minSetOfComponents i chSet \\<subseteq> AbstrLevel i", "by (simp add: minSetOfComponents_def)"], ["proof (state)\nthis:\n  minSetOfComponents i chSet \\<subseteq> AbstrLevel i\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)\n(*>*)"], ["", "subsection \\<open>Additional properties: Remote Computation\\<close>\n\n\\<comment> \\<open>The value of  $UplSizeHighLoad$ $x$ is True if its $UplSize$ measure is greather that a predifined value\\<close>"], ["", "definition UplSizeHighLoadCh ::  \"chanID \\<Rightarrow> bool\"\nwhere\n   \"UplSizeHighLoadCh x \\<equiv> (x \\<in> UplSizeHighLoad)\"\n\n\\<comment> \\<open>if the $Perf$ measure of at least one subcomponent is greather than a predifined value,\\<close>\n\\<comment> \\<open>the $Perf$ measure of this component is greather than $HighPerf$ too\\<close>"], ["", "axiomatization HighPerfComp ::  \"CSet \\<Rightarrow> bool\"\nwhere\nHighPerfComDef:\n   \"HighPerfComp C =\n   ((C \\<in> HighPerfSet) \\<or> (\\<exists> Z \\<in> subcomp C. (HighPerfComp Z)))\""], ["", "end"]]}