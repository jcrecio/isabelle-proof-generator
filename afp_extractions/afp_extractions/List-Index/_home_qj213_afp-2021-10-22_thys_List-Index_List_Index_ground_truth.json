{"file_name": "/home/qj213/afp-2021-10-22/thys/List-Index/List_Index.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List-Index", "problem_names": ["lemma find_index_append: \"find_index P (xs @ ys) =\n  (if \\<exists>x\\<in>set xs. P x then find_index P xs else size xs + find_index P ys)\"", "lemma find_index_le_size: \"find_index P xs <= size xs\"", "lemma index_le_size: \"index xs x <= size xs\"", "lemma last_index_le_size: \"last_index xs x <= size xs\"", "lemma index_Nil[simp]: \"index [] a = 0\"", "lemma index_Cons[simp]: \"index (x#xs) a = (if x=a then 0 else index xs a + 1)\"", "lemma index_append: \"index (xs @ ys) x =\n  (if x : set xs then index xs x else size xs + index ys x)\"", "lemma index_conv_size_if_notin[simp]: \"x \\<notin> set xs \\<Longrightarrow> index xs x = size xs\"", "lemma find_index_eq_size_conv:\n  \"size xs = n \\<Longrightarrow> (find_index P xs = n) = (\\<forall>x \\<in> set xs. ~ P x)\"", "lemma size_eq_find_index_conv:\n  \"size xs = n \\<Longrightarrow> (n = find_index P xs) = (\\<forall>x \\<in> set xs. ~ P x)\"", "lemma index_size_conv: \"size xs = n \\<Longrightarrow> (index xs x = n) = (x \\<notin> set xs)\"", "lemma size_index_conv: \"size xs = n \\<Longrightarrow> (n = index xs x) = (x \\<notin> set xs)\"", "lemma last_index_size_conv:\n  \"size xs = n \\<Longrightarrow> (last_index xs x = n) = (x \\<notin> set xs)\"", "lemma size_last_index_conv:\n  \"size xs = n \\<Longrightarrow> (n = last_index xs x) = (x \\<notin> set xs)\"", "lemma find_index_less_size_conv:\n  \"(find_index P xs < size xs) = (\\<exists>x \\<in> set xs. P x)\"", "lemma index_less_size_conv:\n  \"(index xs x < size xs) = (x \\<in> set xs)\"", "lemma last_index_less_size_conv:\n  \"(last_index xs x < size xs) = (x : set xs)\"", "lemma index_less[simp]:\n  \"x : set xs \\<Longrightarrow> size xs <= n \\<Longrightarrow> index xs x < n\"", "lemma last_index_less[simp]:\n  \"x : set xs \\<Longrightarrow> size xs <= n \\<Longrightarrow> last_index xs x < n\"", "lemma last_index_Cons: \"last_index (x#xs) y =\n  (if x=y then\n      if x \\<in> set xs then last_index xs y + 1 else 0\n   else last_index xs y + 1)\"", "lemma last_index_append: \"last_index (xs @ ys) x =\n  (if x : set ys then size xs + last_index ys x\n   else if x : set xs then last_index xs x else size xs + size ys)\"", "lemma last_index_Snoc[simp]:\n  \"last_index (xs @ [x]) y =\n  (if x=y then size xs\n   else if y : set xs then last_index xs y else size xs + 1)\"", "lemma nth_find_index: \"find_index P xs < size xs \\<Longrightarrow> P(xs ! find_index P xs)\"", "lemma nth_index[simp]: \"x \\<in> set xs \\<Longrightarrow> xs ! index xs x = x\"", "lemma nth_last_index[simp]: \"x \\<in> set xs \\<Longrightarrow> xs ! last_index xs x = x\"", "lemma index_rev: \"\\<lbrakk> distinct xs; x \\<in> set xs \\<rbrakk> \\<Longrightarrow>\n  index (rev xs) x = length xs - index xs x - 1\"", "lemma index_nth_id:\n  \"\\<lbrakk> distinct xs;  n < length xs \\<rbrakk> \\<Longrightarrow> index xs (xs ! n) = n\"", "lemma index_upt[simp]: \"m \\<le> i \\<Longrightarrow> i < n \\<Longrightarrow> index [m..<n] i = i-m\"", "lemma index_eq_index_conv[simp]: \"x \\<in> set xs \\<or> y \\<in> set xs \\<Longrightarrow>\n  (index xs x = index xs y) = (x = y)\"", "lemma last_index_eq_index_conv[simp]: \"x \\<in> set xs \\<or> y \\<in> set xs \\<Longrightarrow>\n  (last_index xs x = last_index xs y) = (x = y)\"", "lemma inj_on_index: \"inj_on (index xs) (set xs)\"", "lemma inj_on_index2: \"I \\<subseteq> set xs \\<Longrightarrow> inj_on (index xs) I\"", "lemma inj_on_last_index: \"inj_on (last_index xs) (set xs)\"", "lemma find_index_conv_takeWhile: \n  \"find_index P xs = size(takeWhile (Not o P) xs)\"", "lemma index_conv_takeWhile: \"index xs x = size(takeWhile (\\<lambda>y. x\\<noteq>y) xs)\"", "lemma find_index_first: \"i < find_index P xs \\<Longrightarrow> \\<not>P (xs!i)\"", "lemma index_first: \"i<index xs x \\<Longrightarrow> x\\<noteq>xs!i\"", "lemma find_index_eqI:\n  assumes \"i\\<le>length xs\"  \n  assumes \"\\<forall>j<i. \\<not>P (xs!j)\"\n  assumes \"i<length xs \\<Longrightarrow> P (xs!i)\"\n  shows \"find_index P xs = i\"", "lemma find_index_eq_iff:\n  \"find_index P xs = i \n  \\<longleftrightarrow> (i\\<le>length xs \\<and> (\\<forall>j<i. \\<not>P (xs!j)) \\<and> (i<length xs \\<longrightarrow> P (xs!i)))\"", "lemma index_eqI:\n  assumes \"i\\<le>length xs\"  \n  assumes \"\\<forall>j<i. xs!j \\<noteq> x\"\n  assumes \"i<length xs \\<Longrightarrow> xs!i = x\"\n  shows \"index xs x = i\"", "lemma index_eq_iff:\n  \"index xs x = i \n  \\<longleftrightarrow> (i\\<le>length xs \\<and> (\\<forall>j<i. xs!j \\<noteq> x) \\<and> (i<length xs \\<longrightarrow> xs!i = x))\"", "lemma index_take: \"index xs x >= i \\<Longrightarrow> x \\<notin> set(take i xs)\"", "lemma last_index_drop:\n  \"last_index xs x < i \\<Longrightarrow> x \\<notin> set(drop i xs)\"", "lemma set_take_if_index: assumes \"index xs x < i\" and \"i \\<le> length xs\"\nshows \"x \\<in> set (take i xs)\"", "lemma index_take_if_index:\nassumes \"index xs x \\<le> n\" shows \"index (take n xs) x = index xs x\"", "lemma index_take_if_set:\n  \"x : set(take n xs) \\<Longrightarrow> index (take n xs) x = index xs x\"", "lemma index_last[simp]:\n  \"xs \\<noteq> [] \\<Longrightarrow> distinct xs \\<Longrightarrow> index xs (last xs) = length xs - 1\"", "lemma index_update_if_diff2:\n  \"n < length xs \\<Longrightarrow> x \\<noteq> xs!n \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> index (xs[n := y]) x = index xs x\"", "lemma set_drop_if_index: \"distinct xs \\<Longrightarrow> index xs x < i \\<Longrightarrow> x \\<notin> set(drop i xs)\"", "lemma index_swap_if_distinct: assumes \"distinct xs\" \"i < size xs\" \"j < size xs\"\nshows \"index (xs[i := xs!j, j := xs!i]) x =\n  (if x = xs!i then j else if x = xs!j then i else index xs x)\"", "lemma bij_betw_index:\n  \"distinct xs \\<Longrightarrow> X = set xs \\<Longrightarrow> l = size xs \\<Longrightarrow> bij_betw (index xs) X {0..<l}\"", "lemma index_image: \"distinct xs \\<Longrightarrow> set xs = X \\<Longrightarrow> index xs ` X = {0..<size xs}\"", "lemma index_map_inj_on:\n  \"\\<lbrakk> inj_on f S; y \\<in> S; set xs \\<subseteq> S \\<rbrakk> \\<Longrightarrow> index (map f xs) (f y) = index xs y\"", "lemma index_map_inj: \"inj f \\<Longrightarrow> index (map f xs) (f y) = index xs y\"", "lemma length_map_index'[simp]: \"length (map_index' n f xs) = length xs\"", "lemma map_index'_map_zip: \"map_index' n f xs = map (case_prod f) (zip [n ..< n + length xs] xs)\"", "lemmas map_index = map_index'_map_zip[of 0, simplified]", "lemma take_map_index: \"take p (map_index f xs) = map_index f (take p xs)\"", "lemma drop_map_index: \"drop p (map_index f xs) = map_index' p f (drop p xs)\"", "lemma map_map_index[simp]: \"map g (map_index f xs) = map_index (\\<lambda>n x. g (f n x)) xs\"", "lemma map_index_map[simp]: \"map_index f (map g xs) = map_index (\\<lambda>n x. f n (g x)) xs\"", "lemma set_map_index[simp]: \"x \\<in> set (map_index f xs) = (\\<exists>i < length xs. f i (xs ! i) = x)\"", "lemma set_map_index'[simp]: \"x\\<in>set (map_index' n f xs)\n  \\<longleftrightarrow> (\\<exists>i<length xs. f (n+i) (xs!i) = x) \"", "lemma nth_map_index[simp]: \"p < length xs \\<Longrightarrow> map_index f xs ! p = f p (xs ! p)\"", "lemma map_index_cong:\n  \"\\<forall>p < length xs. f p (xs ! p) = g p (xs ! p) \\<Longrightarrow> map_index f xs = map_index g xs\"", "lemma map_index_id: \"map_index (curry snd) xs = xs\"", "lemma map_index_no_index[simp]: \"map_index (\\<lambda>n x. f x) xs = map f xs\"", "lemma map_index_congL:\n  \"\\<forall>p < length xs. f p (xs ! p) = xs ! p \\<Longrightarrow> map_index f xs = xs\"", "lemma map_index'_is_NilD: \"map_index' n f xs = [] \\<Longrightarrow> xs = []\"", "lemma map_index'_is_ConsD:\n  \"map_index' n f xs = y # ys \\<Longrightarrow> \\<exists>z zs. xs = z # zs \\<and> f n z = y \\<and> map_index' (n + 1) f zs = ys\"", "lemma map_index'_eq_imp_length_eq: \"map_index' n f xs = map_index' n g ys \\<Longrightarrow> length xs = length ys\"", "lemmas map_index_eq_imp_length_eq = map_index'_eq_imp_length_eq[of 0]", "lemma map_index'_comp[simp]: \"map_index' n f (map_index' n g xs) = map_index' n (\\<lambda>n. f n o g n) xs\"", "lemma map_index'_append[simp]: \"map_index' n f (a @ b)\n  = map_index' n f a @ map_index' (n + length a) f b\"", "lemma map_index_append[simp]: \"map_index f (a @ b)\n  = map_index f a @ map_index' (length a) f b\"", "lemma insert_nth_take_drop[simp]: \"insert_nth n x xs = take n xs @ [x] @ drop n xs\"", "lemma length_insert_nth: \"length (insert_nth n x xs) = Suc (length xs)\"", "lemma set_insert_nth:\n  \"set (insert_nth i x xs) = insert x (set xs)\"", "lemma distinct_insert_nth:\n  assumes \"distinct xs\"\n  assumes \"x \\<notin> set xs\"\n  shows \"distinct (insert_nth i x xs)\"", "lemma nth_insert_nth_front:\n  assumes \"i < j\" \"j \\<le> length xs\"\n  shows \"insert_nth j x xs ! i = xs ! i\"", "lemma nth_insert_nth_index_eq:\n  assumes \"i \\<le> length xs\"\n  shows \"insert_nth i x xs ! i = x\"", "lemma nth_insert_nth_back:\n  assumes \"j < i\" \"i \\<le> length xs\"\n  shows \"insert_nth j x xs ! i = xs ! (i - 1)\"", "lemma nth_insert_nth:\n  assumes \"i \\<le> length xs\" \"j \\<le> length xs\"\n  shows \"insert_nth j x xs ! i = (if i = j then x else if i < j then xs ! i else xs ! (i - 1))\"", "lemma insert_nth_inverse:\n  assumes \"j \\<le> length xs\" \"j' \\<le> length xs'\"\n  assumes \"x \\<notin> set xs\" \"x \\<notin> set xs'\"\n  assumes \"insert_nth j x xs = insert_nth j' x xs'\"\n  shows \"j = j'\"", "lemma length_fold_insert_nth:\n  \"length (fold (\\<lambda>(p, b). insert_nth p b) pxs xs) = length xs + length pxs\"", "lemma invar_fold_insert_nth:\n  \"\\<lbrakk>\\<forall>x\\<in>set pxs. p < fst x; p < length xs; xs ! p = b\\<rbrakk> \\<Longrightarrow>\n    fold (\\<lambda>(x, y). insert_nth x y) pxs xs ! p = b\"", "lemma nth_fold_insert_nth:\n  \"\\<lbrakk>sorted (map fst pxs); distinct (map fst pxs); \\<forall>(p, b) \\<in> set pxs. p < length xs + length pxs;\n    i < length pxs; pxs ! i = (p, b)\\<rbrakk> \\<Longrightarrow>\n  fold (\\<lambda>(p, b). insert_nth p b) pxs xs ! p = b\"", "lemma remove_nth_take_drop:\n  \"remove_nth i xs = take i xs @ drop (Suc i) xs\"", "lemma remove_nth_insert_nth:\n  assumes \"i \\<le> length xs\"\n  shows \"remove_nth i (insert_nth i x xs) = xs\"", "lemma insert_nth_remove_nth:\n  assumes \"i < length xs\"\n  shows \"insert_nth i (xs ! i) (remove_nth i xs) = xs\"", "lemma length_remove_nth:\n  assumes \"i < length xs\"\n  shows \"length (remove_nth i xs) = length xs - 1\"", "lemma set_remove_nth_subset:\n  \"set (remove_nth j xs) \\<subseteq> set xs\"", "lemma set_remove_nth:\n  assumes \"distinct xs\" \"j < length xs\"\n  shows \"set (remove_nth j xs) = set xs - {xs ! j}\"", "lemma distinct_remove_nth:\n  assumes \"distinct xs\"\n  shows \"distinct (remove_nth i xs)\""], "translations": [["", "lemma find_index_append: \"find_index P (xs @ ys) =\n  (if \\<exists>x\\<in>set xs. P x then find_index P xs else size xs + find_index P ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_index P (xs @ ys) =\n    (if \\<exists>x\\<in>set xs. P x then find_index P xs\n     else length xs + find_index P ys)", "by (induct xs) simp_all"], ["", "lemma find_index_le_size: \"find_index P xs <= size xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_index P xs \\<le> length xs", "by(induct xs) simp_all"], ["", "lemma index_le_size: \"index xs x <= size xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs x \\<le> length xs", "by(simp add: index_def find_index_le_size)"], ["", "lemma last_index_le_size: \"last_index xs x <= size xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_index xs x \\<le> length xs", "by(simp add: last_index_def Let_def index_le_size)"], ["", "lemma index_Nil[simp]: \"index [] a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index [] a = 0", "by(simp add: index_def)"], ["", "lemma index_Cons[simp]: \"index (x#xs) a = (if x=a then 0 else index xs a + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (x # xs) a = (if x = a then 0 else index xs a + 1)", "by(simp add: index_def)"], ["", "lemma index_append: \"index (xs @ ys) x =\n  (if x : set xs then index xs x else size xs + index ys x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (xs @ ys) x =\n    (if x \\<in> set xs then index xs x else length xs + index ys x)", "by (induct xs) simp_all"], ["", "lemma index_conv_size_if_notin[simp]: \"x \\<notin> set xs \\<Longrightarrow> index xs x = size xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> index xs x = length xs", "by (induct xs) auto"], ["", "lemma find_index_eq_size_conv:\n  \"size xs = n \\<Longrightarrow> (find_index P xs = n) = (\\<forall>x \\<in> set xs. ~ P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow>\n    (find_index P xs = n) = (\\<forall>x\\<in>set xs. \\<not> P x)", "by(induct xs arbitrary: n) auto"], ["", "lemma size_eq_find_index_conv:\n  \"size xs = n \\<Longrightarrow> (n = find_index P xs) = (\\<forall>x \\<in> set xs. ~ P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow>\n    (n = find_index P xs) = (\\<forall>x\\<in>set xs. \\<not> P x)", "by(metis find_index_eq_size_conv)"], ["", "lemma index_size_conv: \"size xs = n \\<Longrightarrow> (index xs x = n) = (x \\<notin> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow> (index xs x = n) = (x \\<notin> set xs)", "by(auto simp: index_def find_index_eq_size_conv)"], ["", "lemma size_index_conv: \"size xs = n \\<Longrightarrow> (n = index xs x) = (x \\<notin> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow> (n = index xs x) = (x \\<notin> set xs)", "by (metis index_size_conv)"], ["", "lemma last_index_size_conv:\n  \"size xs = n \\<Longrightarrow> (last_index xs x = n) = (x \\<notin> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow>\n    (last_index xs x = n) = (x \\<notin> set xs)", "apply(auto simp: last_index_def index_size_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = length xs; length xs - Suc (index (rev xs) x) = length xs;\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> False", "apply(drule length_pos_if_in_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = length xs; length xs - Suc (index (rev xs) x) = length xs;\n     0 < length xs\\<rbrakk>\n    \\<Longrightarrow> False", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_last_index_conv:\n  \"size xs = n \\<Longrightarrow> (n = last_index xs x) = (x \\<notin> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = n \\<Longrightarrow>\n    (n = last_index xs x) = (x \\<notin> set xs)", "by (metis last_index_size_conv)"], ["", "lemma find_index_less_size_conv:\n  \"(find_index P xs < size xs) = (\\<exists>x \\<in> set xs. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_index P xs < length xs) = (\\<exists>x\\<in>set xs. P x)", "by (induct xs) auto"], ["", "lemma index_less_size_conv:\n  \"(index xs x < size xs) = (x \\<in> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index xs x < length xs) = (x \\<in> set xs)", "by(auto simp: index_def find_index_less_size_conv)"], ["", "lemma last_index_less_size_conv:\n  \"(last_index xs x < size xs) = (x : set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (last_index xs x < length xs) = (x \\<in> set xs)", "by(simp add: last_index_def Let_def index_size_conv length_pos_if_in_set\n        del:length_greater_0_conv)"], ["", "lemma index_less[simp]:\n  \"x : set xs \\<Longrightarrow> size xs <= n \\<Longrightarrow> index xs x < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; length xs \\<le> n\\<rbrakk>\n    \\<Longrightarrow> index xs x < n", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set []; length [] \\<le> n\\<rbrakk>\n    \\<Longrightarrow> index [] x < n\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set xs; length xs \\<le> n\\<rbrakk>\n                \\<Longrightarrow> index xs x < n;\n        x \\<in> set (a # xs); length (a # xs) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> index (a # xs) x < n", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>index xs x < n; Suc (length xs) \\<le> n; a \\<noteq> x;\n        x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> Suc (index xs x) < n", "apply (metis index_less_size_conv less_eq_Suc_le less_trans_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma last_index_less[simp]:\n  \"x : set xs \\<Longrightarrow> size xs <= n \\<Longrightarrow> last_index xs x < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; length xs \\<le> n\\<rbrakk>\n    \\<Longrightarrow> last_index xs x < n", "by(simp add: last_index_less_size_conv[symmetric])"], ["", "lemma last_index_Cons: \"last_index (x#xs) y =\n  (if x=y then\n      if x \\<in> set xs then last_index xs y + 1 else 0\n   else last_index xs y + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_index (x # xs) y =\n    (if x = y then if x \\<in> set xs then last_index xs y + 1 else 0\n     else last_index xs y + 1)", "using index_le_size[of \"rev xs\" y]"], ["proof (prove)\nusing this:\n  index (rev xs) y \\<le> length (rev xs)\n\ngoal (1 subgoal):\n 1. last_index (x # xs) y =\n    (if x = y then if x \\<in> set xs then last_index xs y + 1 else 0\n     else last_index xs y + 1)", "apply(auto simp add: last_index_def index_append Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>index (rev xs) y = length xs; y \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> False", "apply(simp add: index_size_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma last_index_append: \"last_index (xs @ ys) x =\n  (if x : set ys then size xs + last_index ys x\n   else if x : set xs then last_index xs x else size xs + size ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_index (xs @ ys) x =\n    (if x \\<in> set ys then length xs + last_index ys x\n     else if x \\<in> set xs then last_index xs x else length xs + length ys)", "by (induct xs) (simp_all add: last_index_Cons last_index_size_conv)"], ["", "lemma last_index_Snoc[simp]:\n  \"last_index (xs @ [x]) y =\n  (if x=y then size xs\n   else if y : set xs then last_index xs y else size xs + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_index (xs @ [x]) y =\n    (if x = y then length xs\n     else if y \\<in> set xs then last_index xs y else length xs + 1)", "by(simp add: last_index_append last_index_Cons)"], ["", "lemma nth_find_index: \"find_index P xs < size xs \\<Longrightarrow> P(xs ! find_index P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_index P xs < length xs \\<Longrightarrow> P (xs ! find_index P xs)", "by (induct xs) auto"], ["", "lemma nth_index[simp]: \"x \\<in> set xs \\<Longrightarrow> xs ! index xs x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs ! index xs x = x", "by (induct xs) auto"], ["", "lemma nth_last_index[simp]: \"x \\<in> set xs \\<Longrightarrow> xs ! last_index xs x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs ! last_index xs x = x", "by(simp add:last_index_def index_size_conv Let_def rev_nth[symmetric])"], ["", "lemma index_rev: \"\\<lbrakk> distinct xs; x \\<in> set xs \\<rbrakk> \\<Longrightarrow>\n  index (rev xs) x = length xs - index xs x - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> index (rev xs) x = length xs - index xs x - 1", "by (induct xs) (auto simp: index_append)"], ["", "lemma index_nth_id:\n  \"\\<lbrakk> distinct xs;  n < length xs \\<rbrakk> \\<Longrightarrow> index xs (xs ! n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n    \\<Longrightarrow> index xs (xs ! n) = n", "by (metis in_set_conv_nth index_less_size_conv nth_eq_iff_index_eq nth_index)"], ["", "lemma index_upt[simp]: \"m \\<le> i \\<Longrightarrow> i < n \\<Longrightarrow> index [m..<n] i = i-m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> i; i < n\\<rbrakk>\n    \\<Longrightarrow> index [m..<n] i = i - m", "by (induction n) (auto simp add: index_append)"], ["", "lemma index_eq_index_conv[simp]: \"x \\<in> set xs \\<or> y \\<in> set xs \\<Longrightarrow>\n  (index xs x = index xs y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<or> y \\<in> set xs \\<Longrightarrow>\n    (index xs x = index xs y) = (x = y)", "by (induct xs) auto"], ["", "lemma last_index_eq_index_conv[simp]: \"x \\<in> set xs \\<or> y \\<in> set xs \\<Longrightarrow>\n  (last_index xs x = last_index xs y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<or> y \\<in> set xs \\<Longrightarrow>\n    (last_index xs x = last_index xs y) = (x = y)", "by (induct xs) (auto simp:last_index_Cons)"], ["", "lemma inj_on_index: \"inj_on (index xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (index xs) (set xs)", "by (simp add:inj_on_def)"], ["", "lemma inj_on_index2: \"I \\<subseteq> set xs \\<Longrightarrow> inj_on (index xs) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> set xs \\<Longrightarrow> inj_on (index xs) I", "by (rule inj_onI) auto"], ["", "lemma inj_on_last_index: \"inj_on (last_index xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (last_index xs) (set xs)", "by (simp add:inj_on_def)"], ["", "lemma find_index_conv_takeWhile: \n  \"find_index P xs = size(takeWhile (Not o P) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_index P xs = length (takeWhile (Not \\<circ> P) xs)", "by(induct xs) auto"], ["", "lemma index_conv_takeWhile: \"index xs x = size(takeWhile (\\<lambda>y. x\\<noteq>y) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs x = length (takeWhile ((\\<noteq>) x) xs)", "by(induct xs) auto"], ["", "lemma find_index_first: \"i < find_index P xs \\<Longrightarrow> \\<not>P (xs!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < find_index P xs \\<Longrightarrow> \\<not> P (xs ! i)", "unfolding find_index_conv_takeWhile"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (takeWhile (Not \\<circ> P) xs) \\<Longrightarrow>\n    \\<not> P (xs ! i)", "by (metis comp_apply nth_mem set_takeWhileD takeWhile_nth)"], ["", "lemma index_first: \"i<index xs x \\<Longrightarrow> x\\<noteq>xs!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < index xs x \\<Longrightarrow> x \\<noteq> xs ! i", "using find_index_first"], ["proof (prove)\nusing this:\n  ?i < find_index ?P ?xs \\<Longrightarrow> \\<not> ?P (?xs ! ?i)\n\ngoal (1 subgoal):\n 1. i < index xs x \\<Longrightarrow> x \\<noteq> xs ! i", "unfolding index_def"], ["proof (prove)\nusing this:\n  ?i < find_index ?P ?xs \\<Longrightarrow> \\<not> ?P (?xs ! ?i)\n\ngoal (1 subgoal):\n 1. i < find_index (\\<lambda>xa. xa = x) xs \\<Longrightarrow>\n    x \\<noteq> xs ! i", "by blast"], ["", "lemma find_index_eqI:\n  assumes \"i\\<le>length xs\"  \n  assumes \"\\<forall>j<i. \\<not>P (xs!j)\"\n  assumes \"i<length xs \\<Longrightarrow> P (xs!i)\"\n  shows \"find_index P xs = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_index P xs = i", "by (metis (mono_tags, lifting) antisym_conv2 assms find_index_eq_size_conv \n  find_index_first find_index_less_size_conv linorder_neqE_nat nth_find_index)"], ["", "lemma find_index_eq_iff:\n  \"find_index P xs = i \n  \\<longleftrightarrow> (i\\<le>length xs \\<and> (\\<forall>j<i. \\<not>P (xs!j)) \\<and> (i<length xs \\<longrightarrow> P (xs!i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_index P xs = i) =\n    (i \\<le> length xs \\<and>\n     (\\<forall>j<i. \\<not> P (xs ! j)) \\<and>\n     (i < length xs \\<longrightarrow> P (xs ! i)))", "by (auto intro: find_index_eqI \n         simp: nth_find_index find_index_le_size find_index_first)"], ["", "lemma index_eqI:\n  assumes \"i\\<le>length xs\"  \n  assumes \"\\<forall>j<i. xs!j \\<noteq> x\"\n  assumes \"i<length xs \\<Longrightarrow> xs!i = x\"\n  shows \"index xs x = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index xs x = i", "unfolding index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_index (\\<lambda>xa. xa = x) xs = i", "by (simp add: find_index_eqI assms)"], ["", "lemma index_eq_iff:\n  \"index xs x = i \n  \\<longleftrightarrow> (i\\<le>length xs \\<and> (\\<forall>j<i. xs!j \\<noteq> x) \\<and> (i<length xs \\<longrightarrow> xs!i = x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index xs x = i) =\n    (i \\<le> length xs \\<and>\n     (\\<forall>j<i. xs ! j \\<noteq> x) \\<and>\n     (i < length xs \\<longrightarrow> xs ! i = x))", "by (auto intro: index_eqI \n         simp: index_le_size index_less_size_conv \n         dest: index_first)"], ["", "lemma index_take: \"index xs x >= i \\<Longrightarrow> x \\<notin> set(take i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> index xs x \\<Longrightarrow> x \\<notin> set (take i xs)", "apply(subst (asm) index_conv_takeWhile)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length (takeWhile ((\\<noteq>) x) xs) \\<Longrightarrow>\n    x \\<notin> set (take i xs)", "apply(subgoal_tac \"set(take i xs) <= set(takeWhile ((\\<noteq>) x) xs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<le> length (takeWhile ((\\<noteq>) x) xs);\n     set (take i xs) \\<subseteq> set (takeWhile ((\\<noteq>) x) xs)\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (take i xs)\n 2. i \\<le> length (takeWhile ((\\<noteq>) x) xs) \\<Longrightarrow>\n    set (take i xs) \\<subseteq> set (takeWhile ((\\<noteq>) x) xs)", "apply(blast dest: set_takeWhileD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length (takeWhile ((\\<noteq>) x) xs) \\<Longrightarrow>\n    set (take i xs) \\<subseteq> set (takeWhile ((\\<noteq>) x) xs)", "apply(metis set_take_subset_set_take takeWhile_eq_take)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma last_index_drop:\n  \"last_index xs x < i \\<Longrightarrow> x \\<notin> set(drop i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_index xs x < i \\<Longrightarrow> x \\<notin> set (drop i xs)", "apply(subgoal_tac \"set(drop i xs) = set(take (size xs - i) (rev xs))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>last_index xs x < i;\n     set (drop i xs) = set (take (length xs - i) (rev xs))\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (drop i xs)\n 2. last_index xs x < i \\<Longrightarrow>\n    set (drop i xs) = set (take (length xs - i) (rev xs))", "apply(simp add: last_index_def index_take Let_def split:if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. last_index xs x < i \\<Longrightarrow>\n    set (drop i xs) = set (take (length xs - i) (rev xs))", "apply (metis rev_drop set_rev)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_take_if_index: assumes \"index xs x < i\" and \"i \\<le> length xs\"\nshows \"x \\<in> set (take i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (take i xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set (take i xs)", "have \"index (take i xs @ drop i xs) x < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (take i xs @ drop i xs) x < i", "using append_take_drop_id[of i xs] assms(1)"], ["proof (prove)\nusing this:\n  take i xs @ drop i xs = xs\n  index xs x < i\n\ngoal (1 subgoal):\n 1. index (take i xs @ drop i xs) x < i", "by simp"], ["proof (state)\nthis:\n  index (take i xs @ drop i xs) x < i\n\ngoal (1 subgoal):\n 1. x \\<in> set (take i xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  index (take i xs @ drop i xs) x < i\n\ngoal (1 subgoal):\n 1. x \\<in> set (take i xs)", "using assms(2)"], ["proof (prove)\nusing this:\n  index (take i xs @ drop i xs) x < i\n  i \\<le> length xs\n\ngoal (1 subgoal):\n 1. x \\<in> set (take i xs)", "by(simp add:index_append del:append_take_drop_id split: if_splits)"], ["proof (state)\nthis:\n  x \\<in> set (take i xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_take_if_index:\nassumes \"index xs x \\<le> n\" shows \"index (take n xs) x = index xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (take n xs) x = index xs x", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> index (take n xs) x = index xs x\n 2. \\<not> ?P \\<Longrightarrow> index (take n xs) x = index xs x", "assume \"x : set(take n xs)\""], ["proof (state)\nthis:\n  x \\<in> set (take n xs)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> index (take n xs) x = index xs x\n 2. \\<not> ?P \\<Longrightarrow> index (take n xs) x = index xs x", "with assms"], ["proof (chain)\npicking this:\n  index xs x \\<le> n\n  x \\<in> set (take n xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  index xs x \\<le> n\n  x \\<in> set (take n xs)\n\ngoal (1 subgoal):\n 1. index (take n xs) x = index xs x", "by (metis append_take_drop_id index_append)"], ["proof (state)\nthis:\n  index (take n xs) x = index xs x\n\ngoal (1 subgoal):\n 1. x \\<notin> set (take n xs) \\<Longrightarrow>\n    index (take n xs) x = index xs x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set (take n xs) \\<Longrightarrow>\n    index (take n xs) x = index xs x", "assume \"x \\<notin> set(take n xs)\""], ["proof (state)\nthis:\n  x \\<notin> set (take n xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set (take n xs) \\<Longrightarrow>\n    index (take n xs) x = index xs x", "with assms"], ["proof (chain)\npicking this:\n  index xs x \\<le> n\n  x \\<notin> set (take n xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  index xs x \\<le> n\n  x \\<notin> set (take n xs)\n\ngoal (1 subgoal):\n 1. index (take n xs) x = index xs x", "by (metis order_le_less set_take_if_index le_cases length_take min_def size_index_conv take_all)"], ["proof (state)\nthis:\n  index (take n xs) x = index xs x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_take_if_set:\n  \"x : set(take n xs) \\<Longrightarrow> index (take n xs) x = index xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (take n xs) \\<Longrightarrow>\n    index (take n xs) x = index xs x", "by (metis index_take index_take_if_index linear)"], ["", "lemma index_last[simp]:\n  \"xs \\<noteq> [] \\<Longrightarrow> distinct xs \\<Longrightarrow> index xs (last xs) = length xs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; distinct xs\\<rbrakk>\n    \\<Longrightarrow> index xs (last xs) = length xs - 1", "by (induction xs) auto"], ["", "lemma index_update_if_diff2:\n  \"n < length xs \\<Longrightarrow> x \\<noteq> xs!n \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> index (xs[n := y]) x = index xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length xs; x \\<noteq> xs ! n; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> index (xs[n := y]) x = index xs x", "by(subst (2) id_take_nth_drop[of n xs])\n  (auto simp: upd_conv_take_nth_drop index_append min_def)"], ["", "lemma set_drop_if_index: \"distinct xs \\<Longrightarrow> index xs x < i \\<Longrightarrow> x \\<notin> set(drop i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; index xs x < i\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set (drop i xs)", "by (metis in_set_dropD index_nth_id last_index_drop last_index_less_size_conv nth_last_index)"], ["", "lemma index_swap_if_distinct: assumes \"distinct xs\" \"i < size xs\" \"j < size xs\"\nshows \"index (xs[i := xs!j, j := xs!i]) x =\n  (if x = xs!i then j else if x = xs!j then i else index xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index (xs[i := xs ! j, j := xs ! i]) x =\n    (if x = xs ! i then j else if x = xs ! j then i else index xs x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. index (xs[i := xs ! j, j := xs ! i]) x =\n    (if x = xs ! i then j else if x = xs ! j then i else index xs x)", "have \"distinct(xs[i := xs!j, j := xs!i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xs[i := xs ! j, j := xs ! i])", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  i < length xs\n  j < length xs\n\ngoal (1 subgoal):\n 1. distinct (xs[i := xs ! j, j := xs ! i])", "by simp"], ["proof (state)\nthis:\n  distinct (xs[i := xs ! j, j := xs ! i])\n\ngoal (1 subgoal):\n 1. index (xs[i := xs ! j, j := xs ! i]) x =\n    (if x = xs ! i then j else if x = xs ! j then i else index xs x)", "with assms"], ["proof (chain)\npicking this:\n  distinct xs\n  i < length xs\n  j < length xs\n  distinct (xs[i := xs ! j, j := xs ! i])", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct xs\n  i < length xs\n  j < length xs\n  distinct (xs[i := xs ! j, j := xs ! i])\n\ngoal (1 subgoal):\n 1. index (xs[i := xs ! j, j := xs ! i]) x =\n    (if x = xs ! i then j else if x = xs ! j then i else index xs x)", "apply (auto simp: swap_def simp del: distinct_swap)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>distinct xs; i < length xs; j < length xs;\n     distinct (xs[j := xs ! i]); x = xs ! i; xs ! j = xs ! i\\<rbrakk>\n    \\<Longrightarrow> index (xs[j := xs ! i]) (xs ! i) = j\n 2. \\<lbrakk>distinct xs; i < length xs; j < length xs;\n     distinct (xs[i := xs ! j, j := xs ! i]); x = xs ! j;\n     xs ! j \\<noteq> xs ! i\\<rbrakk>\n    \\<Longrightarrow> index (xs[i := xs ! j, j := xs ! i]) (xs ! j) = i\n 3. \\<lbrakk>distinct xs; i < length xs; j < length xs;\n     distinct (xs[i := xs ! j, j := xs ! i]); xs ! i \\<noteq> xs ! j;\n     x = xs ! i\\<rbrakk>\n    \\<Longrightarrow> index (xs[i := xs ! j, j := xs ! i]) (xs ! i) = j\n 4. \\<lbrakk>distinct xs; i < length xs; j < length xs;\n     distinct (xs[i := xs ! j, j := xs ! i]); x \\<noteq> xs ! j;\n     x \\<noteq> xs ! i\\<rbrakk>\n    \\<Longrightarrow> index (xs[i := xs ! j, j := xs ! i]) x = index xs x", "apply (metis index_nth_id list_update_same_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct xs; i < length xs; j < length xs;\n     distinct (xs[i := xs ! j, j := xs ! i]); x = xs ! j;\n     xs ! j \\<noteq> xs ! i\\<rbrakk>\n    \\<Longrightarrow> index (xs[i := xs ! j, j := xs ! i]) (xs ! j) = i\n 2. \\<lbrakk>distinct xs; i < length xs; j < length xs;\n     distinct (xs[i := xs ! j, j := xs ! i]); xs ! i \\<noteq> xs ! j;\n     x = xs ! i\\<rbrakk>\n    \\<Longrightarrow> index (xs[i := xs ! j, j := xs ! i]) (xs ! i) = j\n 3. \\<lbrakk>distinct xs; i < length xs; j < length xs;\n     distinct (xs[i := xs ! j, j := xs ! i]); x \\<noteq> xs ! j;\n     x \\<noteq> xs ! i\\<rbrakk>\n    \\<Longrightarrow> index (xs[i := xs ! j, j := xs ! i]) x = index xs x", "apply (metis (erased, hide_lams) index_nth_id length_list_update list_update_swap nth_list_update_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; i < length xs; j < length xs;\n     distinct (xs[i := xs ! j, j := xs ! i]); xs ! i \\<noteq> xs ! j;\n     x = xs ! i\\<rbrakk>\n    \\<Longrightarrow> index (xs[i := xs ! j, j := xs ! i]) (xs ! i) = j\n 2. \\<lbrakk>distinct xs; i < length xs; j < length xs;\n     distinct (xs[i := xs ! j, j := xs ! i]); x \\<noteq> xs ! j;\n     x \\<noteq> xs ! i\\<rbrakk>\n    \\<Longrightarrow> index (xs[i := xs ! j, j := xs ! i]) x = index xs x", "apply (metis index_nth_id length_list_update nth_list_update_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; i < length xs; j < length xs;\n     distinct (xs[i := xs ! j, j := xs ! i]); x \\<noteq> xs ! j;\n     x \\<noteq> xs ! i\\<rbrakk>\n    \\<Longrightarrow> index (xs[i := xs ! j, j := xs ! i]) x = index xs x", "by (metis index_update_if_diff2 length_list_update nth_list_update)"], ["proof (state)\nthis:\n  index (xs[i := xs ! j, j := xs ! i]) x =\n  (if x = xs ! i then j else if x = xs ! j then i else index xs x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_index:\n  \"distinct xs \\<Longrightarrow> X = set xs \\<Longrightarrow> l = size xs \\<Longrightarrow> bij_betw (index xs) X {0..<l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; X = set xs; l = length xs\\<rbrakk>\n    \\<Longrightarrow> bij_betw (index xs) X {0..<l}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; X = set xs; l = length xs\\<rbrakk>\n    \\<Longrightarrow> bij_betw (index xs) (set xs) {0..<length xs}", "apply(rule bij_betw_imageI[OF inj_on_index])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; X = set xs; l = length xs\\<rbrakk>\n    \\<Longrightarrow> index xs ` set xs = {0..<length xs}", "by (auto simp: image_def) (metis index_nth_id nth_mem)"], ["", "lemma index_image: \"distinct xs \\<Longrightarrow> set xs = X \\<Longrightarrow> index xs ` X = {0..<size xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; set xs = X\\<rbrakk>\n    \\<Longrightarrow> index xs ` X = {0..<length xs}", "by (simp add: bij_betw_imp_surj_on bij_betw_index)"], ["", "lemma index_map_inj_on:\n  \"\\<lbrakk> inj_on f S; y \\<in> S; set xs \\<subseteq> S \\<rbrakk> \\<Longrightarrow> index (map f xs) (f y) = index xs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f S; y \\<in> S; set xs \\<subseteq> S\\<rbrakk>\n    \\<Longrightarrow> index (map f xs) (f y) = index xs y", "by (induct xs) (auto simp: inj_on_eq_iff)"], ["", "lemma index_map_inj: \"inj f \\<Longrightarrow> index (map f xs) (f y) = index xs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f \\<Longrightarrow> index (map f xs) (f y) = index xs y", "by (simp add: index_map_inj_on[where S=UNIV])"], ["", "subsection \\<open>Map with index\\<close>"], ["", "primrec map_index' :: \"nat \\<Rightarrow> (nat \\<Rightarrow> 'a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> 'b list\" where\n  \"map_index' n f [] = []\"\n| \"map_index' n f (x#xs) = f n x # map_index' (Suc n) f xs\""], ["", "lemma length_map_index'[simp]: \"length (map_index' n f xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map_index' n f xs) = length xs", "by (induct xs arbitrary: n) auto"], ["", "lemma map_index'_map_zip: \"map_index' n f xs = map (case_prod f) (zip [n ..< n + length xs] xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index' n f xs = map2 f [n..<n + length xs] xs", "proof (induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. map_index' n f [] = map2 f [n..<n + length []] []\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_index' n f xs =\n           map2 f [n..<n + length xs] xs) \\<Longrightarrow>\n       map_index' n f (a # xs) = map2 f [n..<n + length (a # xs)] (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  map_index' ?n f xs = map2 f [?n..<?n + length xs] xs\n\ngoal (2 subgoals):\n 1. \\<And>n. map_index' n f [] = map2 f [n..<n + length []] []\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_index' n f xs =\n           map2 f [n..<n + length xs] xs) \\<Longrightarrow>\n       map_index' n f (a # xs) = map2 f [n..<n + length (a # xs)] (a # xs)", "hence \"map_index' n f (x#xs) = f n x # map (case_prod f) (zip [Suc n ..< n + length (x # xs)] xs)\""], ["proof (prove)\nusing this:\n  map_index' ?n f xs = map2 f [?n..<?n + length xs] xs\n\ngoal (1 subgoal):\n 1. map_index' n f (x # xs) =\n    f n x # map2 f [Suc n..<n + length (x # xs)] xs", "by simp"], ["proof (state)\nthis:\n  map_index' n f (x # xs) = f n x # map2 f [Suc n..<n + length (x # xs)] xs\n\ngoal (2 subgoals):\n 1. \\<And>n. map_index' n f [] = map2 f [n..<n + length []] []\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_index' n f xs =\n           map2 f [n..<n + length xs] xs) \\<Longrightarrow>\n       map_index' n f (a # xs) = map2 f [n..<n + length (a # xs)] (a # xs)", "also"], ["proof (state)\nthis:\n  map_index' n f (x # xs) = f n x # map2 f [Suc n..<n + length (x # xs)] xs\n\ngoal (2 subgoals):\n 1. \\<And>n. map_index' n f [] = map2 f [n..<n + length []] []\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_index' n f xs =\n           map2 f [n..<n + length xs] xs) \\<Longrightarrow>\n       map_index' n f (a # xs) = map2 f [n..<n + length (a # xs)] (a # xs)", "have \"\\<dots> =  map (case_prod f) (zip (n # [Suc n ..< n + length (x # xs)]) (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n x # map2 f [Suc n..<n + length (x # xs)] xs =\n    map2 f (n # [Suc n..<n + length (x # xs)]) (x # xs)", "by simp"], ["proof (state)\nthis:\n  f n x # map2 f [Suc n..<n + length (x # xs)] xs =\n  map2 f (n # [Suc n..<n + length (x # xs)]) (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>n. map_index' n f [] = map2 f [n..<n + length []] []\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_index' n f xs =\n           map2 f [n..<n + length xs] xs) \\<Longrightarrow>\n       map_index' n f (a # xs) = map2 f [n..<n + length (a # xs)] (a # xs)", "also"], ["proof (state)\nthis:\n  f n x # map2 f [Suc n..<n + length (x # xs)] xs =\n  map2 f (n # [Suc n..<n + length (x # xs)]) (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>n. map_index' n f [] = map2 f [n..<n + length []] []\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_index' n f xs =\n           map2 f [n..<n + length xs] xs) \\<Longrightarrow>\n       map_index' n f (a # xs) = map2 f [n..<n + length (a # xs)] (a # xs)", "have \"(n # [Suc n ..< n + length (x # xs)]) = [n ..< n + length (x # xs)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n # [Suc n..<n + length (x # xs)] = [n..<n + length (x # xs)]", "by (induct xs) auto"], ["proof (state)\nthis:\n  n # [Suc n..<n + length (x # xs)] = [n..<n + length (x # xs)]\n\ngoal (2 subgoals):\n 1. \\<And>n. map_index' n f [] = map2 f [n..<n + length []] []\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_index' n f xs =\n           map2 f [n..<n + length xs] xs) \\<Longrightarrow>\n       map_index' n f (a # xs) = map2 f [n..<n + length (a # xs)] (a # xs)", "finally"], ["proof (chain)\npicking this:\n  map_index' n f (x # xs) = map2 f [n..<n + length (x # xs)] (x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  map_index' n f (x # xs) = map2 f [n..<n + length (x # xs)] (x # xs)\n\ngoal (1 subgoal):\n 1. map_index' n f (x # xs) = map2 f [n..<n + length (x # xs)] (x # xs)", "by simp"], ["proof (state)\nthis:\n  map_index' n f (x # xs) = map2 f [n..<n + length (x # xs)] (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>n. map_index' n f [] = map2 f [n..<n + length []] []", "qed simp"], ["", "abbreviation \"map_index \\<equiv> map_index' 0\""], ["", "lemmas map_index = map_index'_map_zip[of 0, simplified]"], ["", "lemma take_map_index: \"take p (map_index f xs) = map_index f (take p xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take p (map_index f xs) = map_index f (take p xs)", "unfolding map_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. take p (map2 f [0..<length xs] xs) =\n    map2 f [0..<length (take p xs)] (take p xs)", "by (auto simp: min_def take_map take_zip)"], ["", "lemma drop_map_index: \"drop p (map_index f xs) = map_index' p f (drop p xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop p (map_index f xs) = map_index' p f (drop p xs)", "unfolding map_index'_map_zip"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop p (map2 f [0..<0 + length xs] xs) =\n    map2 f [p..<p + length (drop p xs)] (drop p xs)", "by (cases \"p < length xs\") (auto simp: drop_map drop_zip)"], ["", "lemma map_map_index[simp]: \"map g (map_index f xs) = map_index (\\<lambda>n x. g (f n x)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map g (map_index f xs) = map_index (\\<lambda>n x. g (f n x)) xs", "unfolding map_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. map g (map2 f [0..<length xs] xs) =\n    map2 (\\<lambda>n x. g (f n x)) [0..<length xs] xs", "by auto"], ["", "lemma map_index_map[simp]: \"map_index f (map g xs) = map_index (\\<lambda>n x. f n (g x)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index f (map g xs) = map_index (\\<lambda>n x. f n (g x)) xs", "unfolding map_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 f [0..<length (map g xs)] (map g xs) =\n    map2 (\\<lambda>n x. f n (g x)) [0..<length xs] xs", "by (auto simp: map_zip_map2)"], ["", "lemma set_map_index[simp]: \"x \\<in> set (map_index f xs) = (\\<exists>i < length xs. f i (xs ! i) = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (map_index f xs)) =\n    (\\<exists>i<length xs. f i (xs ! i) = x)", "unfolding map_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (map2 f [0..<length xs] xs)) =\n    (\\<exists>i<length xs. f i (xs ! i) = x)", "by (auto simp: set_zip intro!: image_eqI[of _ \"case_prod f\"])"], ["", "lemma set_map_index'[simp]: \"x\\<in>set (map_index' n f xs)\n  \\<longleftrightarrow> (\\<exists>i<length xs. f (n+i) (xs!i) = x) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (map_index' n f xs)) =\n    (\\<exists>i<length xs. f (n + i) (xs ! i) = x)", "unfolding map_index'_map_zip"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (map2 f [n..<n + length xs] xs)) =\n    (\\<exists>i<length xs. f (n + i) (xs ! i) = x)", "by (auto simp: set_zip intro!: image_eqI[of _ \"case_prod f\"])"], ["", "lemma nth_map_index[simp]: \"p < length xs \\<Longrightarrow> map_index f xs ! p = f p (xs ! p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p < length xs \\<Longrightarrow> map_index f xs ! p = f p (xs ! p)", "unfolding map_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. p < length xs \\<Longrightarrow>\n    map2 f [0..<length xs] xs ! p = f p (xs ! p)", "by auto"], ["", "lemma map_index_cong:\n  \"\\<forall>p < length xs. f p (xs ! p) = g p (xs ! p) \\<Longrightarrow> map_index f xs = map_index g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p<length xs. f p (xs ! p) = g p (xs ! p) \\<Longrightarrow>\n    map_index f xs = map_index g xs", "unfolding map_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p<length xs. f p (xs ! p) = g p (xs ! p) \\<Longrightarrow>\n    map2 f [0..<length xs] xs = map2 g [0..<length xs] xs", "by (auto simp: set_zip)"], ["", "lemma map_index_id: \"map_index (curry snd) xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index (curry snd) xs = xs", "unfolding map_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (curry snd) [0..<length xs] xs = xs", "by auto"], ["", "lemma map_index_no_index[simp]: \"map_index (\\<lambda>n x. f x) xs = map f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index (\\<lambda>n. f) xs = map f xs", "unfolding map_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<lambda>n. f) [0..<length xs] xs = map f xs", "by (induct xs rule: rev_induct) auto"], ["", "lemma map_index_congL:\n  \"\\<forall>p < length xs. f p (xs ! p) = xs ! p \\<Longrightarrow> map_index f xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p<length xs. f p (xs ! p) = xs ! p \\<Longrightarrow>\n    map_index f xs = xs", "by (rule trans[OF map_index_cong map_index_id]) auto"], ["", "lemma map_index'_is_NilD: \"map_index' n f xs = [] \\<Longrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index' n f xs = [] \\<Longrightarrow> xs = []", "by (induct xs) auto"], ["", "declare map_index'_is_NilD[of 0, dest!]"], ["", "lemma map_index'_is_ConsD:\n  \"map_index' n f xs = y # ys \\<Longrightarrow> \\<exists>z zs. xs = z # zs \\<and> f n z = y \\<and> map_index' (n + 1) f zs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index' n f xs = y # ys \\<Longrightarrow>\n    \\<exists>z zs.\n       xs = z # zs \\<and> f n z = y \\<and> map_index' (n + 1) f zs = ys", "by (induct xs arbitrary: n) auto"], ["", "lemma map_index'_eq_imp_length_eq: \"map_index' n f xs = map_index' n g ys \\<Longrightarrow> length xs = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index' n f xs = map_index' n g ys \\<Longrightarrow>\n    length xs = length ys", "proof (induct ys arbitrary: xs n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs n.\n       map_index' n f xs = map_index' n g [] \\<Longrightarrow>\n       length xs = length []\n 2. \\<And>a ys xs n.\n       \\<lbrakk>\\<And>xs n.\n                   map_index' n f xs = map_index' n g ys \\<Longrightarrow>\n                   length xs = length ys;\n        map_index' n f xs = map_index' n g (a # ys)\\<rbrakk>\n       \\<Longrightarrow> length xs = length (a # ys)", "case (Cons y ys)"], ["proof (state)\nthis:\n  map_index' ?n f ?xs = map_index' ?n g ys \\<Longrightarrow>\n  length ?xs = length ys\n  map_index' n f xs = map_index' n g (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>xs n.\n       map_index' n f xs = map_index' n g [] \\<Longrightarrow>\n       length xs = length []\n 2. \\<And>a ys xs n.\n       \\<lbrakk>\\<And>xs n.\n                   map_index' n f xs = map_index' n g ys \\<Longrightarrow>\n                   length xs = length ys;\n        map_index' n f xs = map_index' n g (a # ys)\\<rbrakk>\n       \\<Longrightarrow> length xs = length (a # ys)", "thus ?case"], ["proof (prove)\nusing this:\n  map_index' ?n f ?xs = map_index' ?n g ys \\<Longrightarrow>\n  length ?xs = length ys\n  map_index' n f xs = map_index' n g (y # ys)\n\ngoal (1 subgoal):\n 1. length xs = length (y # ys)", "by (cases xs) auto"], ["proof (state)\nthis:\n  length xs = length (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       map_index' n f xs = map_index' n g [] \\<Longrightarrow>\n       length xs = length []", "qed (auto dest!: map_index'_is_NilD)"], ["", "lemmas map_index_eq_imp_length_eq = map_index'_eq_imp_length_eq[of 0]"], ["", "lemma map_index'_comp[simp]: \"map_index' n f (map_index' n g xs) = map_index' n (\\<lambda>n. f n o g n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index' n f (map_index' n g xs) =\n    map_index' n (\\<lambda>n. f n \\<circ> g n) xs", "by (induct xs arbitrary: n) auto"], ["", "lemma map_index'_append[simp]: \"map_index' n f (a @ b)\n  = map_index' n f a @ map_index' (n + length a) f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index' n f (a @ b) =\n    map_index' n f a @ map_index' (n + length a) f b", "by (induct a arbitrary: n) auto"], ["", "lemma map_index_append[simp]: \"map_index f (a @ b)\n  = map_index f a @ map_index' (length a) f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_index f (a @ b) = map_index f a @ map_index' (length a) f b", "using map_index'_append[where n=0]"], ["proof (prove)\nusing this:\n  map_index ?f (?a @ ?b) =\n  map_index ?f ?a @ map_index' (0 + length ?a) ?f ?b\n\ngoal (1 subgoal):\n 1. map_index f (a @ b) = map_index f a @ map_index' (length a) f b", "by (simp del: map_index'_append)"], ["", "subsection \\<open>Insert at position\\<close>"], ["", "primrec insert_nth :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"insert_nth 0 x xs = x # xs\"\n| \"insert_nth (Suc n) x xs = (case xs of [] \\<Rightarrow> [x] | y # ys \\<Rightarrow> y # insert_nth n x ys)\""], ["", "lemma insert_nth_take_drop[simp]: \"insert_nth n x xs = take n xs @ [x] @ drop n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_nth n x xs = take n xs @ [x] @ drop n xs", "proof (induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. insert_nth 0 x xs = take 0 xs @ [x] @ drop 0 xs\n 2. \\<And>n xs.\n       (\\<And>xs.\n           insert_nth n x xs =\n           take n xs @ [x] @ drop n xs) \\<Longrightarrow>\n       insert_nth (Suc n) x xs = take (Suc n) xs @ [x] @ drop (Suc n) xs", "case Suc"], ["proof (state)\nthis:\n  insert_nth n_ x ?xs = take n_ ?xs @ [x] @ drop n_ ?xs\n\ngoal (2 subgoals):\n 1. \\<And>xs. insert_nth 0 x xs = take 0 xs @ [x] @ drop 0 xs\n 2. \\<And>n xs.\n       (\\<And>xs.\n           insert_nth n x xs =\n           take n xs @ [x] @ drop n xs) \\<Longrightarrow>\n       insert_nth (Suc n) x xs = take (Suc n) xs @ [x] @ drop (Suc n) xs", "thus ?case"], ["proof (prove)\nusing this:\n  insert_nth n_ x ?xs = take n_ ?xs @ [x] @ drop n_ ?xs\n\ngoal (1 subgoal):\n 1. insert_nth (Suc n_) x xs = take (Suc n_) xs @ [x] @ drop (Suc n_) xs", "by (cases xs) auto"], ["proof (state)\nthis:\n  insert_nth (Suc n_) x xs = take (Suc n_) xs @ [x] @ drop (Suc n_) xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. insert_nth 0 x xs = take 0 xs @ [x] @ drop 0 xs", "qed simp"], ["", "lemma length_insert_nth: \"length (insert_nth n x xs) = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (insert_nth n x xs) = Suc (length xs)", "by (induct xs) auto"], ["", "lemma set_insert_nth:\n  \"set (insert_nth i x xs) = insert x (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insert_nth i x xs) = insert x (set xs)", "by (simp add: set_append[symmetric])"], ["", "lemma distinct_insert_nth:\n  assumes \"distinct xs\"\n  assumes \"x \\<notin> set xs\"\n  shows \"distinct (insert_nth i x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (insert_nth i x xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. distinct (insert_nth i x xs)", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>distinct []; x \\<notin> set []\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_nth i x [])\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>distinct xs; x \\<notin> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (insert_nth i x xs);\n        distinct (a # xs); x \\<notin> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_nth i x (a # xs))", "case Nil"], ["proof (state)\nthis:\n  distinct []\n  x \\<notin> set []\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>distinct []; x \\<notin> set []\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_nth i x [])\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>distinct xs; x \\<notin> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (insert_nth i x xs);\n        distinct (a # xs); x \\<notin> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_nth i x (a # xs))", "then"], ["proof (chain)\npicking this:\n  distinct []\n  x \\<notin> set []", "show ?case"], ["proof (prove)\nusing this:\n  distinct []\n  x \\<notin> set []\n\ngoal (1 subgoal):\n 1. distinct (insert_nth i x [])", "by (cases i) auto"], ["proof (state)\nthis:\n  distinct (insert_nth i x [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>distinct xs; x \\<notin> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (insert_nth i x xs);\n        distinct (a # xs); x \\<notin> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_nth i x (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>distinct xs; x \\<notin> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (insert_nth i x xs);\n        distinct (a # xs); x \\<notin> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_nth i x (a # xs))", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs; x \\<notin> set xs\\<rbrakk>\n  \\<Longrightarrow> distinct (insert_nth ?i x xs)\n  distinct (a # xs)\n  x \\<notin> set (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>distinct xs; x \\<notin> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (insert_nth i x xs);\n        distinct (a # xs); x \\<notin> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_nth i x (a # xs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct xs; x \\<notin> set xs\\<rbrakk>\n  \\<Longrightarrow> distinct (insert_nth ?i x xs)\n  distinct (a # xs)\n  x \\<notin> set (a # xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct xs; x \\<notin> set xs\\<rbrakk>\n  \\<Longrightarrow> distinct (insert_nth ?i x xs)\n  distinct (a # xs)\n  x \\<notin> set (a # xs)\n\ngoal (1 subgoal):\n 1. distinct (insert_nth i x (a # xs))", "by (cases i) (auto simp add: set_insert_nth simp del: insert_nth_take_drop)"], ["proof (state)\nthis:\n  distinct (insert_nth i x (a # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_insert_nth_front:\n  assumes \"i < j\" \"j \\<le> length xs\"\n  shows \"insert_nth j x xs ! i = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_nth j x xs ! i = xs ! i", "using assms"], ["proof (prove)\nusing this:\n  i < j\n  j \\<le> length xs\n\ngoal (1 subgoal):\n 1. insert_nth j x xs ! i = xs ! i", "by (simp add: nth_append)"], ["", "lemma nth_insert_nth_index_eq:\n  assumes \"i \\<le> length xs\"\n  shows \"insert_nth i x xs ! i = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_nth i x xs ! i = x", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> length xs\n\ngoal (1 subgoal):\n 1. insert_nth i x xs ! i = x", "by (simp add: nth_append)"], ["", "lemma nth_insert_nth_back:\n  assumes \"j < i\" \"i \\<le> length xs\"\n  shows \"insert_nth j x xs ! i = xs ! (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_nth j x xs ! i = xs ! (i - 1)", "using assms"], ["proof (prove)\nusing this:\n  j < i\n  i \\<le> length xs\n\ngoal (1 subgoal):\n 1. insert_nth j x xs ! i = xs ! (i - 1)", "by (cases i) (auto simp add: nth_append min_def)"], ["", "lemma nth_insert_nth:\n  assumes \"i \\<le> length xs\" \"j \\<le> length xs\"\n  shows \"insert_nth j x xs ! i = (if i = j then x else if i < j then xs ! i else xs ! (i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_nth j x xs ! i =\n    (if i = j then x else if i < j then xs ! i else xs ! (i - 1))", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> length xs\n  j \\<le> length xs\n\ngoal (1 subgoal):\n 1. insert_nth j x xs ! i =\n    (if i = j then x else if i < j then xs ! i else xs ! (i - 1))", "by (simp add: nth_insert_nth_front nth_insert_nth_index_eq nth_insert_nth_back del: insert_nth_take_drop)"], ["", "lemma insert_nth_inverse:\n  assumes \"j \\<le> length xs\" \"j' \\<le> length xs'\"\n  assumes \"x \\<notin> set xs\" \"x \\<notin> set xs'\"\n  assumes \"insert_nth j x xs = insert_nth j' x xs'\"\n  shows \"j = j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = j'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j = j'", "from assms(1,3)"], ["proof (chain)\npicking this:\n  j \\<le> length xs\n  x \\<notin> set xs", "have \"\\<forall>i\\<le>length xs. insert_nth j x xs ! i = x \\<longleftrightarrow> i = j\""], ["proof (prove)\nusing this:\n  j \\<le> length xs\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>length xs. (insert_nth j x xs ! i = x) = (i = j)", "by (auto simp add: nth_insert_nth simp del: insert_nth_take_drop)"], ["proof (state)\nthis:\n  \\<forall>i\\<le>length xs. (insert_nth j x xs ! i = x) = (i = j)\n\ngoal (1 subgoal):\n 1. j = j'", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<le>length xs. (insert_nth j x xs ! i = x) = (i = j)\n\ngoal (1 subgoal):\n 1. j = j'", "from assms(2,4)"], ["proof (chain)\npicking this:\n  j' \\<le> length xs'\n  x \\<notin> set xs'", "have \"\\<forall>i\\<le>length xs'. insert_nth j' x xs' ! i = x \\<longleftrightarrow> i = j'\""], ["proof (prove)\nusing this:\n  j' \\<le> length xs'\n  x \\<notin> set xs'\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>length xs'. (insert_nth j' x xs' ! i = x) = (i = j')", "by (auto simp add: nth_insert_nth simp del: insert_nth_take_drop)"], ["proof (state)\nthis:\n  \\<forall>i\\<le>length xs'. (insert_nth j' x xs' ! i = x) = (i = j')\n\ngoal (1 subgoal):\n 1. j = j'", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>length xs. (insert_nth j x xs ! i = x) = (i = j)\n  \\<forall>i\\<le>length xs'. (insert_nth j' x xs' ! i = x) = (i = j')", "show \"j = j'\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>length xs. (insert_nth j x xs ! i = x) = (i = j)\n  \\<forall>i\\<le>length xs'. (insert_nth j' x xs' ! i = x) = (i = j')\n\ngoal (1 subgoal):\n 1. j = j'", "using assms(1,2,5)"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>length xs. (insert_nth j x xs ! i = x) = (i = j)\n  \\<forall>i\\<le>length xs'. (insert_nth j' x xs' ! i = x) = (i = j')\n  j \\<le> length xs\n  j' \\<le> length xs'\n  insert_nth j x xs = insert_nth j' x xs'\n\ngoal (1 subgoal):\n 1. j = j'", "by (metis dual_order.trans nat_le_linear)"], ["proof (state)\nthis:\n  j = j'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Insert several elements at given (ascending) positions\\<close>"], ["", "lemma length_fold_insert_nth:\n  \"length (fold (\\<lambda>(p, b). insert_nth p b) pxs xs) = length xs + length pxs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fold (\\<lambda>(p, b). insert_nth p b) pxs xs) =\n    length xs + length pxs", "by (induct pxs arbitrary: xs) auto"], ["", "lemma invar_fold_insert_nth:\n  \"\\<lbrakk>\\<forall>x\\<in>set pxs. p < fst x; p < length xs; xs ! p = b\\<rbrakk> \\<Longrightarrow>\n    fold (\\<lambda>(x, y). insert_nth x y) pxs xs ! p = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set pxs. p < fst x; p < length xs;\n     xs ! p = b\\<rbrakk>\n    \\<Longrightarrow> fold (\\<lambda>(x, y). insert_nth x y) pxs xs ! p = b", "by (induct pxs arbitrary: xs) (auto simp: nth_append)"], ["", "lemma nth_fold_insert_nth:\n  \"\\<lbrakk>sorted (map fst pxs); distinct (map fst pxs); \\<forall>(p, b) \\<in> set pxs. p < length xs + length pxs;\n    i < length pxs; pxs ! i = (p, b)\\<rbrakk> \\<Longrightarrow>\n  fold (\\<lambda>(p, b). insert_nth p b) pxs xs ! p = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted (map fst pxs); distinct (map fst pxs);\n     \\<forall>(p, b)\\<in>set pxs. p < length xs + length pxs;\n     i < length pxs; pxs ! i = (p, b)\\<rbrakk>\n    \\<Longrightarrow> fold (\\<lambda>(p, b). insert_nth p b) pxs xs ! p = b", "proof (induct pxs arbitrary: xs i p b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs i p b.\n       \\<lbrakk>sorted (map fst []); distinct (map fst []);\n        \\<forall>(p, b)\\<in>set []. p < length xs + length [];\n        i < length []; [] ! i = (p, b)\\<rbrakk>\n       \\<Longrightarrow> fold (\\<lambda>(x, y). insert_nth x y) [] xs ! p =\n                         b\n 2. \\<And>a pxs xs i p b.\n       \\<lbrakk>\\<And>xs i p b.\n                   \\<lbrakk>sorted (map fst pxs); distinct (map fst pxs);\n                    \\<forall>(p, b)\\<in>set pxs. p < length xs + length pxs;\n                    i < length pxs; pxs ! i = (p, b)\\<rbrakk>\n                   \\<Longrightarrow> fold (\\<lambda>(x, y). insert_nth x y)\npxs xs !\n                                     p =\n                                     b;\n        sorted (map fst (a # pxs)); distinct (map fst (a # pxs));\n        \\<forall>(p, b)\\<in>set (a # pxs). p < length xs + length (a # pxs);\n        i < length (a # pxs); (a # pxs) ! i = (p, b)\\<rbrakk>\n       \\<Longrightarrow> fold (\\<lambda>(x, y). insert_nth x y) (a # pxs)\n                          xs !\n                         p =\n                         b", "case (Cons pb pxs)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted (map fst pxs); distinct (map fst pxs);\n   \\<forall>a\\<in>set pxs.\n      case a of (p, b) \\<Rightarrow> p < length ?xs + length pxs;\n   ?i < length pxs; pxs ! ?i = (?p, ?b)\\<rbrakk>\n  \\<Longrightarrow> fold\n                     (\\<lambda>a.\n                         case a of (a, b) \\<Rightarrow> insert_nth a b)\n                     pxs ?xs !\n                    ?p =\n                    ?b\n  sorted (map fst (pb # pxs))\n  distinct (map fst (pb # pxs))\n  \\<forall>a\\<in>set (pb # pxs).\n     case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs)\n  i < length (pb # pxs)\n  (pb # pxs) ! i = (p, b)\n\ngoal (2 subgoals):\n 1. \\<And>xs i p b.\n       \\<lbrakk>sorted (map fst []); distinct (map fst []);\n        \\<forall>(p, b)\\<in>set []. p < length xs + length [];\n        i < length []; [] ! i = (p, b)\\<rbrakk>\n       \\<Longrightarrow> fold (\\<lambda>(x, y). insert_nth x y) [] xs ! p =\n                         b\n 2. \\<And>a pxs xs i p b.\n       \\<lbrakk>\\<And>xs i p b.\n                   \\<lbrakk>sorted (map fst pxs); distinct (map fst pxs);\n                    \\<forall>(p, b)\\<in>set pxs. p < length xs + length pxs;\n                    i < length pxs; pxs ! i = (p, b)\\<rbrakk>\n                   \\<Longrightarrow> fold (\\<lambda>(x, y). insert_nth x y)\npxs xs !\n                                     p =\n                                     b;\n        sorted (map fst (a # pxs)); distinct (map fst (a # pxs));\n        \\<forall>(p, b)\\<in>set (a # pxs). p < length xs + length (a # pxs);\n        i < length (a # pxs); (a # pxs) ! i = (p, b)\\<rbrakk>\n       \\<Longrightarrow> fold (\\<lambda>(x, y). insert_nth x y) (a # pxs)\n                          xs !\n                         p =\n                         b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n     (pb # pxs) xs !\n    p =\n    b", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n     (pb # pxs) xs !\n    p =\n    b\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n        (pb # pxs) xs !\n       p =\n       b", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n     (pb # pxs) xs !\n    p =\n    b\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n        (pb # pxs) xs !\n       p =\n       b", "with Cons.prems"], ["proof (chain)\npicking this:\n  sorted (map fst (pb # pxs))\n  distinct (map fst (pb # pxs))\n  \\<forall>a\\<in>set (pb # pxs).\n     case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs)\n  i < length (pb # pxs)\n  (pb # pxs) ! i = (p, b)\n  i = 0", "have \"p < Suc (length xs)\""], ["proof (prove)\nusing this:\n  sorted (map fst (pb # pxs))\n  distinct (map fst (pb # pxs))\n  \\<forall>a\\<in>set (pb # pxs).\n     case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs)\n  i < length (pb # pxs)\n  (pb # pxs) ! i = (p, b)\n  i = 0\n\ngoal (1 subgoal):\n 1. p < Suc (length xs)", "proof (induct pxs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (map fst [pb]); distinct (map fst [pb]);\n     \\<forall>(p, b)\\<in>set [pb]. p < length xs + length [pb];\n     i < length [pb]; [pb] ! i = (p, b); i = 0\\<rbrakk>\n    \\<Longrightarrow> p < Suc (length xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>sorted (map fst (pb # xs));\n                 distinct (map fst (pb # xs));\n                 \\<forall>(p, b)\\<in>set (pb # xs).\n                    p < length xs + length (pb # xs);\n                 i < length (pb # xs); (pb # xs) ! i = (p, b);\n                 i = 0\\<rbrakk>\n                \\<Longrightarrow> p < Suc (length xs);\n        sorted (map fst (pb # xs @ [x]));\n        distinct (map fst (pb # xs @ [x]));\n        \\<forall>(p, b)\\<in>set (pb # xs @ [x]).\n           p < length xs + length (pb # xs @ [x]);\n        i < length (pb # xs @ [x]); (pb # xs @ [x]) ! i = (p, b);\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> p < Suc (length xs)", "case (snoc pb' pxs)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted (map fst (pb # pxs)); distinct (map fst (pb # pxs));\n   \\<forall>a\\<in>set (pb # pxs).\n      case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs);\n   i < length (pb # pxs); (pb # pxs) ! i = (p, b); i = 0\\<rbrakk>\n  \\<Longrightarrow> p < Suc (length xs)\n  sorted (map fst (pb # pxs @ [pb']))\n  distinct (map fst (pb # pxs @ [pb']))\n  \\<forall>a\\<in>set (pb # pxs @ [pb']).\n     case a of\n     (p, b) \\<Rightarrow> p < length xs + length (pb # pxs @ [pb'])\n  i < length (pb # pxs @ [pb'])\n  (pb # pxs @ [pb']) ! i = (p, b)\n  i = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (map fst [pb]); distinct (map fst [pb]);\n     \\<forall>(p, b)\\<in>set [pb]. p < length xs + length [pb];\n     i < length [pb]; [pb] ! i = (p, b); i = 0\\<rbrakk>\n    \\<Longrightarrow> p < Suc (length xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>sorted (map fst (pb # xs));\n                 distinct (map fst (pb # xs));\n                 \\<forall>(p, b)\\<in>set (pb # xs).\n                    p < length xs + length (pb # xs);\n                 i < length (pb # xs); (pb # xs) ! i = (p, b);\n                 i = 0\\<rbrakk>\n                \\<Longrightarrow> p < Suc (length xs);\n        sorted (map fst (pb # xs @ [x]));\n        distinct (map fst (pb # xs @ [x]));\n        \\<forall>(p, b)\\<in>set (pb # xs @ [x]).\n           p < length xs + length (pb # xs @ [x]);\n        i < length (pb # xs @ [x]); (pb # xs @ [x]) ! i = (p, b);\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> p < Suc (length xs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sorted (map fst (pb # pxs)); distinct (map fst (pb # pxs));\n   \\<forall>a\\<in>set (pb # pxs).\n      case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs);\n   i < length (pb # pxs); (pb # pxs) ! i = (p, b); i = 0\\<rbrakk>\n  \\<Longrightarrow> p < Suc (length xs)\n  sorted (map fst (pb # pxs @ [pb']))\n  distinct (map fst (pb # pxs @ [pb']))\n  \\<forall>a\\<in>set (pb # pxs @ [pb']).\n     case a of\n     (p, b) \\<Rightarrow> p < length xs + length (pb # pxs @ [pb'])\n  i < length (pb # pxs @ [pb'])\n  (pb # pxs @ [pb']) ! i = (p, b)\n  i = 0", "obtain p' b' where \"pb' = (p', b')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted (map fst (pb # pxs)); distinct (map fst (pb # pxs));\n   \\<forall>a\\<in>set (pb # pxs).\n      case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs);\n   i < length (pb # pxs); (pb # pxs) ! i = (p, b); i = 0\\<rbrakk>\n  \\<Longrightarrow> p < Suc (length xs)\n  sorted (map fst (pb # pxs @ [pb']))\n  distinct (map fst (pb # pxs @ [pb']))\n  \\<forall>a\\<in>set (pb # pxs @ [pb']).\n     case a of\n     (p, b) \\<Rightarrow> p < length xs + length (pb # pxs @ [pb'])\n  i < length (pb # pxs @ [pb'])\n  (pb # pxs @ [pb']) ! i = (p, b)\n  i = 0\n\ngoal (1 subgoal):\n 1. (\\<And>p' b'. pb' = (p', b') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pb' = (p', b')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (map fst [pb]); distinct (map fst [pb]);\n     \\<forall>(p, b)\\<in>set [pb]. p < length xs + length [pb];\n     i < length [pb]; [pb] ! i = (p, b); i = 0\\<rbrakk>\n    \\<Longrightarrow> p < Suc (length xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>sorted (map fst (pb # xs));\n                 distinct (map fst (pb # xs));\n                 \\<forall>(p, b)\\<in>set (pb # xs).\n                    p < length xs + length (pb # xs);\n                 i < length (pb # xs); (pb # xs) ! i = (p, b);\n                 i = 0\\<rbrakk>\n                \\<Longrightarrow> p < Suc (length xs);\n        sorted (map fst (pb # xs @ [x]));\n        distinct (map fst (pb # xs @ [x]));\n        \\<forall>(p, b)\\<in>set (pb # xs @ [x]).\n           p < length xs + length (pb # xs @ [x]);\n        i < length (pb # xs @ [x]); (pb # xs @ [x]) ! i = (p, b);\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> p < Suc (length xs)", "with snoc.prems"], ["proof (chain)\npicking this:\n  sorted (map fst (pb # pxs @ [pb']))\n  distinct (map fst (pb # pxs @ [pb']))\n  \\<forall>a\\<in>set (pb # pxs @ [pb']).\n     case a of\n     (p, b) \\<Rightarrow> p < length xs + length (pb # pxs @ [pb'])\n  i < length (pb # pxs @ [pb'])\n  (pb # pxs @ [pb']) ! i = (p, b)\n  i = 0\n  pb' = (p', b')", "have \"\\<forall>p \\<in> fst ` set pxs. p < p'\" \"p' \\<le> Suc (length xs + length pxs)\""], ["proof (prove)\nusing this:\n  sorted (map fst (pb # pxs @ [pb']))\n  distinct (map fst (pb # pxs @ [pb']))\n  \\<forall>a\\<in>set (pb # pxs @ [pb']).\n     case a of\n     (p, b) \\<Rightarrow> p < length xs + length (pb # pxs @ [pb'])\n  i < length (pb # pxs @ [pb'])\n  (pb # pxs @ [pb']) ! i = (p, b)\n  i = 0\n  pb' = (p', b')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>fst ` set pxs. p < p' &&&\n    p' \\<le> Suc (length xs + length pxs)", "by (auto simp: image_iff sorted_append le_eq_less_or_eq)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>fst ` set pxs. p < p'\n  p' \\<le> Suc (length xs + length pxs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (map fst [pb]); distinct (map fst [pb]);\n     \\<forall>(p, b)\\<in>set [pb]. p < length xs + length [pb];\n     i < length [pb]; [pb] ! i = (p, b); i = 0\\<rbrakk>\n    \\<Longrightarrow> p < Suc (length xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>sorted (map fst (pb # xs));\n                 distinct (map fst (pb # xs));\n                 \\<forall>(p, b)\\<in>set (pb # xs).\n                    p < length xs + length (pb # xs);\n                 i < length (pb # xs); (pb # xs) ! i = (p, b);\n                 i = 0\\<rbrakk>\n                \\<Longrightarrow> p < Suc (length xs);\n        sorted (map fst (pb # xs @ [x]));\n        distinct (map fst (pb # xs @ [x]));\n        \\<forall>(p, b)\\<in>set (pb # xs @ [x]).\n           p < length xs + length (pb # xs @ [x]);\n        i < length (pb # xs @ [x]); (pb # xs @ [x]) ! i = (p, b);\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> p < Suc (length xs)", "with snoc.prems"], ["proof (chain)\npicking this:\n  sorted (map fst (pb # pxs @ [pb']))\n  distinct (map fst (pb # pxs @ [pb']))\n  \\<forall>a\\<in>set (pb # pxs @ [pb']).\n     case a of\n     (p, b) \\<Rightarrow> p < length xs + length (pb # pxs @ [pb'])\n  i < length (pb # pxs @ [pb'])\n  (pb # pxs @ [pb']) ! i = (p, b)\n  i = 0\n  \\<forall>p\\<in>fst ` set pxs. p < p'\n  p' \\<le> Suc (length xs + length pxs)", "show ?case"], ["proof (prove)\nusing this:\n  sorted (map fst (pb # pxs @ [pb']))\n  distinct (map fst (pb # pxs @ [pb']))\n  \\<forall>a\\<in>set (pb # pxs @ [pb']).\n     case a of\n     (p, b) \\<Rightarrow> p < length xs + length (pb # pxs @ [pb'])\n  i < length (pb # pxs @ [pb'])\n  (pb # pxs @ [pb']) ! i = (p, b)\n  i = 0\n  \\<forall>p\\<in>fst ` set pxs. p < p'\n  p' \\<le> Suc (length xs + length pxs)\n\ngoal (1 subgoal):\n 1. p < Suc (length xs)", "by (intro snoc(1)) (auto simp: sorted_append)"], ["proof (state)\nthis:\n  p < Suc (length xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted (map fst [pb]); distinct (map fst [pb]);\n     \\<forall>(p, b)\\<in>set [pb]. p < length xs + length [pb];\n     i < length [pb]; [pb] ! i = (p, b); i = 0\\<rbrakk>\n    \\<Longrightarrow> p < Suc (length xs)", "qed auto"], ["proof (state)\nthis:\n  p < Suc (length xs)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n     (pb # pxs) xs !\n    p =\n    b\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n        (pb # pxs) xs !\n       p =\n       b", "with 0 Cons.prems"], ["proof (chain)\npicking this:\n  i = 0\n  sorted (map fst (pb # pxs))\n  distinct (map fst (pb # pxs))\n  \\<forall>a\\<in>set (pb # pxs).\n     case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs)\n  i < length (pb # pxs)\n  (pb # pxs) ! i = (p, b)\n  p < Suc (length xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n  sorted (map fst (pb # pxs))\n  distinct (map fst (pb # pxs))\n  \\<forall>a\\<in>set (pb # pxs).\n     case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs)\n  i < length (pb # pxs)\n  (pb # pxs) ! i = (p, b)\n  p < Suc (length xs)\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n     (pb # pxs) xs !\n    p =\n    b", "unfolding fold.simps o_apply"], ["proof (prove)\nusing this:\n  i = 0\n  sorted (map fst (pb # pxs))\n  distinct (map fst (pb # pxs))\n  \\<forall>a\\<in>set (pb # pxs).\n     case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs)\n  i < length (pb # pxs)\n  (pb # pxs) ! i = (p, b)\n  p < Suc (length xs)\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y). insert_nth x y) pxs\n     ((case pb of (x, xa) \\<Rightarrow> insert_nth x xa) xs) !\n    p =\n    b", "by (intro invar_fold_insert_nth) (auto simp: image_iff le_eq_less_or_eq nth_append)"], ["proof (state)\nthis:\n  fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n   (pb # pxs) xs !\n  p =\n  b\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n        (pb # pxs) xs !\n       p =\n       b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n        (pb # pxs) xs !\n       p =\n       b", "case (Suc n)"], ["proof (state)\nthis:\n  i = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n        (pb # pxs) xs !\n       p =\n       b", "with Cons.prems"], ["proof (chain)\npicking this:\n  sorted (map fst (pb # pxs))\n  distinct (map fst (pb # pxs))\n  \\<forall>a\\<in>set (pb # pxs).\n     case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs)\n  i < length (pb # pxs)\n  (pb # pxs) ! i = (p, b)\n  i = Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted (map fst (pb # pxs))\n  distinct (map fst (pb # pxs))\n  \\<forall>a\\<in>set (pb # pxs).\n     case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs)\n  i < length (pb # pxs)\n  (pb # pxs) ! i = (p, b)\n  i = Suc n\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n     (pb # pxs) xs !\n    p =\n    b", "unfolding fold.simps"], ["proof (prove)\nusing this:\n  sorted (map fst (pb # pxs))\n  distinct (map fst (pb # pxs))\n  \\<forall>a\\<in>set (pb # pxs).\n     case a of (p, b) \\<Rightarrow> p < length xs + length (pb # pxs)\n  i < length (pb # pxs)\n  (pb # pxs) ! i = (p, b)\n  i = Suc n\n\ngoal (1 subgoal):\n 1. (fold (\\<lambda>(x, y). insert_nth x y) pxs \\<circ>\n     (case pb of (x, xa) \\<Rightarrow> insert_nth x xa))\n     xs !\n    p =\n    b", "by (auto intro!: Cons(1))"], ["proof (state)\nthis:\n  fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n   (pb # pxs) xs !\n  p =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fold (\\<lambda>a. case a of (a, b) \\<Rightarrow> insert_nth a b)\n   (pb # pxs) xs !\n  p =\n  b\n\ngoal (1 subgoal):\n 1. \\<And>xs i p b.\n       \\<lbrakk>sorted (map fst []); distinct (map fst []);\n        \\<forall>(p, b)\\<in>set []. p < length xs + length [];\n        i < length []; [] ! i = (p, b)\\<rbrakk>\n       \\<Longrightarrow> fold (\\<lambda>(x, y). insert_nth x y) [] xs ! p =\n                         b", "qed simp"], ["", "subsection \\<open>Remove at position\\<close>"], ["", "fun remove_nth :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"remove_nth i [] = []\"\n| \"remove_nth 0 (x # xs) = xs\"\n| \"remove_nth (Suc i) (x # xs) = x # remove_nth i xs\""], ["", "lemma remove_nth_take_drop:\n  \"remove_nth i xs = take i xs @ drop (Suc i) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i xs = take i xs @ drop (Suc i) xs", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. remove_nth i [] = take i [] @ drop (Suc i) []\n 2. \\<And>a xs i.\n       (\\<And>i.\n           remove_nth i xs = take i xs @ drop (Suc i) xs) \\<Longrightarrow>\n       remove_nth i (a # xs) = take i (a # xs) @ drop (Suc i) (a # xs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>i. remove_nth i [] = take i [] @ drop (Suc i) []\n 2. \\<And>a xs i.\n       (\\<And>i.\n           remove_nth i xs = take i xs @ drop (Suc i) xs) \\<Longrightarrow>\n       remove_nth i (a # xs) = take i (a # xs) @ drop (Suc i) (a # xs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i [] = take i [] @ drop (Suc i) []", "by simp"], ["proof (state)\nthis:\n  remove_nth i [] = take i [] @ drop (Suc i) []\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       (\\<And>i.\n           remove_nth i xs = take i xs @ drop (Suc i) xs) \\<Longrightarrow>\n       remove_nth i (a # xs) = take i (a # xs) @ drop (Suc i) (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       (\\<And>i.\n           remove_nth i xs = take i xs @ drop (Suc i) xs) \\<Longrightarrow>\n       remove_nth i (a # xs) = take i (a # xs) @ drop (Suc i) (a # xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  remove_nth ?i xs = take ?i xs @ drop (Suc ?i) xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       (\\<And>i.\n           remove_nth i xs = take i xs @ drop (Suc i) xs) \\<Longrightarrow>\n       remove_nth i (a # xs) = take i (a # xs) @ drop (Suc i) (a # xs)", "then"], ["proof (chain)\npicking this:\n  remove_nth ?i xs = take ?i xs @ drop (Suc ?i) xs", "show ?case"], ["proof (prove)\nusing this:\n  remove_nth ?i xs = take ?i xs @ drop (Suc ?i) xs\n\ngoal (1 subgoal):\n 1. remove_nth i (a # xs) = take i (a # xs) @ drop (Suc i) (a # xs)", "by (cases i) auto"], ["proof (state)\nthis:\n  remove_nth i (a # xs) = take i (a # xs) @ drop (Suc i) (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_nth_insert_nth:\n  assumes \"i \\<le> length xs\"\n  shows \"remove_nth i (insert_nth i x xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_nth i (insert_nth i x xs) = xs", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> length xs\n\ngoal (1 subgoal):\n 1. remove_nth i (insert_nth i x xs) = xs", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> length [] \\<Longrightarrow>\n       remove_nth i (insert_nth i x []) = []\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   remove_nth i (insert_nth i x xs) = xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> remove_nth i (insert_nth i x (a # xs)) = a # xs", "case Nil"], ["proof (state)\nthis:\n  i \\<le> length []\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<le> length [] \\<Longrightarrow>\n       remove_nth i (insert_nth i x []) = []\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   remove_nth i (insert_nth i x xs) = xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> remove_nth i (insert_nth i x (a # xs)) = a # xs", "then"], ["proof (chain)\npicking this:\n  i \\<le> length []", "show ?case"], ["proof (prove)\nusing this:\n  i \\<le> length []\n\ngoal (1 subgoal):\n 1. remove_nth i (insert_nth i x []) = []", "by simp"], ["proof (state)\nthis:\n  remove_nth i (insert_nth i x []) = []\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   remove_nth i (insert_nth i x xs) = xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> remove_nth i (insert_nth i x (a # xs)) = a # xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   remove_nth i (insert_nth i x xs) = xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> remove_nth i (insert_nth i x (a # xs)) = a # xs", "case (Cons a xs)"], ["proof (state)\nthis:\n  ?i \\<le> length xs \\<Longrightarrow>\n  remove_nth ?i (insert_nth ?i x xs) = xs\n  i \\<le> length (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length xs \\<Longrightarrow>\n                   remove_nth i (insert_nth i x xs) = xs;\n        i \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> remove_nth i (insert_nth i x (a # xs)) = a # xs", "then"], ["proof (chain)\npicking this:\n  ?i \\<le> length xs \\<Longrightarrow>\n  remove_nth ?i (insert_nth ?i x xs) = xs\n  i \\<le> length (a # xs)", "show ?case"], ["proof (prove)\nusing this:\n  ?i \\<le> length xs \\<Longrightarrow>\n  remove_nth ?i (insert_nth ?i x xs) = xs\n  i \\<le> length (a # xs)\n\ngoal (1 subgoal):\n 1. remove_nth i (insert_nth i x (a # xs)) = a # xs", "by (cases i) auto"], ["proof (state)\nthis:\n  remove_nth i (insert_nth i x (a # xs)) = a # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_nth_remove_nth:\n  assumes \"i < length xs\"\n  shows \"insert_nth i (xs ! i) (remove_nth i xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_nth i (xs ! i) (remove_nth i xs) = xs", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. insert_nth i (xs ! i) (remove_nth i xs) = xs", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow>\n       insert_nth i ([] ! i) (remove_nth i []) = []\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   insert_nth i (xs ! i) (remove_nth i xs) = xs;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_nth i ((a # xs) ! i)\n                          (remove_nth i (a # xs)) =\n                         a # xs", "case Nil"], ["proof (state)\nthis:\n  i < length []\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow>\n       insert_nth i ([] ! i) (remove_nth i []) = []\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   insert_nth i (xs ! i) (remove_nth i xs) = xs;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_nth i ((a # xs) ! i)\n                          (remove_nth i (a # xs)) =\n                         a # xs", "then"], ["proof (chain)\npicking this:\n  i < length []", "show ?case"], ["proof (prove)\nusing this:\n  i < length []\n\ngoal (1 subgoal):\n 1. insert_nth i ([] ! i) (remove_nth i []) = []", "by simp"], ["proof (state)\nthis:\n  insert_nth i ([] ! i) (remove_nth i []) = []\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   insert_nth i (xs ! i) (remove_nth i xs) = xs;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_nth i ((a # xs) ! i)\n                          (remove_nth i (a # xs)) =\n                         a # xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   insert_nth i (xs ! i) (remove_nth i xs) = xs;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_nth i ((a # xs) ! i)\n                          (remove_nth i (a # xs)) =\n                         a # xs", "case (Cons a xs)"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow>\n  insert_nth ?i (xs ! ?i) (remove_nth ?i xs) = xs\n  i < length (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   i < length xs \\<Longrightarrow>\n                   insert_nth i (xs ! i) (remove_nth i xs) = xs;\n        i < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_nth i ((a # xs) ! i)\n                          (remove_nth i (a # xs)) =\n                         a # xs", "then"], ["proof (chain)\npicking this:\n  ?i < length xs \\<Longrightarrow>\n  insert_nth ?i (xs ! ?i) (remove_nth ?i xs) = xs\n  i < length (a # xs)", "show ?case"], ["proof (prove)\nusing this:\n  ?i < length xs \\<Longrightarrow>\n  insert_nth ?i (xs ! ?i) (remove_nth ?i xs) = xs\n  i < length (a # xs)\n\ngoal (1 subgoal):\n 1. insert_nth i ((a # xs) ! i) (remove_nth i (a # xs)) = a # xs", "by (cases i) auto"], ["proof (state)\nthis:\n  insert_nth i ((a # xs) ! i) (remove_nth i (a # xs)) = a # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_remove_nth:\n  assumes \"i < length xs\"\n  shows \"length (remove_nth i xs) = length xs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remove_nth i xs) = length xs - 1", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (remove_nth i xs) = length xs - 1", "unfolding remove_nth_take_drop"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (take i xs @ drop (Suc i) xs) = length xs - 1", "by simp"], ["", "lemma set_remove_nth_subset:\n  \"set (remove_nth j xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove_nth j xs) \\<subseteq> set xs", "proof (induct xs arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j. set (remove_nth j []) \\<subseteq> set []\n 2. \\<And>a xs j.\n       (\\<And>j. set (remove_nth j xs) \\<subseteq> set xs) \\<Longrightarrow>\n       set (remove_nth j (a # xs)) \\<subseteq> set (a # xs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>j. set (remove_nth j []) \\<subseteq> set []\n 2. \\<And>a xs j.\n       (\\<And>j. set (remove_nth j xs) \\<subseteq> set xs) \\<Longrightarrow>\n       set (remove_nth j (a # xs)) \\<subseteq> set (a # xs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove_nth j []) \\<subseteq> set []", "by simp"], ["proof (state)\nthis:\n  set (remove_nth j []) \\<subseteq> set []\n\ngoal (1 subgoal):\n 1. \\<And>a xs j.\n       (\\<And>j. set (remove_nth j xs) \\<subseteq> set xs) \\<Longrightarrow>\n       set (remove_nth j (a # xs)) \\<subseteq> set (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs j.\n       (\\<And>j. set (remove_nth j xs) \\<subseteq> set xs) \\<Longrightarrow>\n       set (remove_nth j (a # xs)) \\<subseteq> set (a # xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  set (remove_nth ?j xs) \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs j.\n       (\\<And>j. set (remove_nth j xs) \\<subseteq> set xs) \\<Longrightarrow>\n       set (remove_nth j (a # xs)) \\<subseteq> set (a # xs)", "then"], ["proof (chain)\npicking this:\n  set (remove_nth ?j xs) \\<subseteq> set xs", "show ?case"], ["proof (prove)\nusing this:\n  set (remove_nth ?j xs) \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. set (remove_nth j (a # xs)) \\<subseteq> set (a # xs)", "by (cases j) auto"], ["proof (state)\nthis:\n  set (remove_nth j (a # xs)) \\<subseteq> set (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_remove_nth:\n  assumes \"distinct xs\" \"j < length xs\"\n  shows \"set (remove_nth j xs) = set xs - {xs ! j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove_nth j xs) = set xs - {xs ! j}", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  j < length xs\n\ngoal (1 subgoal):\n 1. set (remove_nth j xs) = set xs - {xs ! j}", "proof (induct xs arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>distinct []; j < length []\\<rbrakk>\n       \\<Longrightarrow> set (remove_nth j []) = set [] - {[] ! j}\n 2. \\<And>a xs j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>distinct xs; j < length xs\\<rbrakk>\n                   \\<Longrightarrow> set (remove_nth j xs) =\n                                     set xs - {xs ! j};\n        distinct (a # xs); j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (remove_nth j (a # xs)) =\n                         set (a # xs) - {(a # xs) ! j}", "case Nil"], ["proof (state)\nthis:\n  distinct []\n  j < length []\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>distinct []; j < length []\\<rbrakk>\n       \\<Longrightarrow> set (remove_nth j []) = set [] - {[] ! j}\n 2. \\<And>a xs j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>distinct xs; j < length xs\\<rbrakk>\n                   \\<Longrightarrow> set (remove_nth j xs) =\n                                     set xs - {xs ! j};\n        distinct (a # xs); j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (remove_nth j (a # xs)) =\n                         set (a # xs) - {(a # xs) ! j}", "then"], ["proof (chain)\npicking this:\n  distinct []\n  j < length []", "show ?case"], ["proof (prove)\nusing this:\n  distinct []\n  j < length []\n\ngoal (1 subgoal):\n 1. set (remove_nth j []) = set [] - {[] ! j}", "by simp"], ["proof (state)\nthis:\n  set (remove_nth j []) = set [] - {[] ! j}\n\ngoal (1 subgoal):\n 1. \\<And>a xs j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>distinct xs; j < length xs\\<rbrakk>\n                   \\<Longrightarrow> set (remove_nth j xs) =\n                                     set xs - {xs ! j};\n        distinct (a # xs); j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (remove_nth j (a # xs)) =\n                         set (a # xs) - {(a # xs) ! j}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>distinct xs; j < length xs\\<rbrakk>\n                   \\<Longrightarrow> set (remove_nth j xs) =\n                                     set xs - {xs ! j};\n        distinct (a # xs); j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (remove_nth j (a # xs)) =\n                         set (a # xs) - {(a # xs) ! j}", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> set (remove_nth ?j xs) = set xs - {xs ! ?j}\n  distinct (a # xs)\n  j < length (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>distinct xs; j < length xs\\<rbrakk>\n                   \\<Longrightarrow> set (remove_nth j xs) =\n                                     set xs - {xs ! j};\n        distinct (a # xs); j < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (remove_nth j (a # xs)) =\n                         set (a # xs) - {(a # xs) ! j}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct xs; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> set (remove_nth ?j xs) = set xs - {xs ! ?j}\n  distinct (a # xs)\n  j < length (a # xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct xs; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> set (remove_nth ?j xs) = set xs - {xs ! ?j}\n  distinct (a # xs)\n  j < length (a # xs)\n\ngoal (1 subgoal):\n 1. set (remove_nth j (a # xs)) = set (a # xs) - {(a # xs) ! j}", "by (cases j) auto"], ["proof (state)\nthis:\n  set (remove_nth j (a # xs)) = set (a # xs) - {(a # xs) ! j}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_remove_nth:\n  assumes \"distinct xs\"\n  shows \"distinct (remove_nth i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (remove_nth i xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct (remove_nth i xs)", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. distinct [] \\<Longrightarrow> distinct (remove_nth i [])\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   distinct xs \\<Longrightarrow> distinct (remove_nth i xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (remove_nth i (a # xs))", "case Nil"], ["proof (state)\nthis:\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<And>i. distinct [] \\<Longrightarrow> distinct (remove_nth i [])\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   distinct xs \\<Longrightarrow> distinct (remove_nth i xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (remove_nth i (a # xs))", "then"], ["proof (chain)\npicking this:\n  distinct []", "show ?case"], ["proof (prove)\nusing this:\n  distinct []\n\ngoal (1 subgoal):\n 1. distinct (remove_nth i [])", "by simp"], ["proof (state)\nthis:\n  distinct (remove_nth i [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   distinct xs \\<Longrightarrow> distinct (remove_nth i xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (remove_nth i (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   distinct xs \\<Longrightarrow> distinct (remove_nth i xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (remove_nth i (a # xs))", "case (Cons a xs)"], ["proof (state)\nthis:\n  distinct xs \\<Longrightarrow> distinct (remove_nth ?i xs)\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   distinct xs \\<Longrightarrow> distinct (remove_nth i xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (remove_nth i (a # xs))", "then"], ["proof (chain)\npicking this:\n  distinct xs \\<Longrightarrow> distinct (remove_nth ?i xs)\n  distinct (a # xs)", "show ?case"], ["proof (prove)\nusing this:\n  distinct xs \\<Longrightarrow> distinct (remove_nth ?i xs)\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. distinct (remove_nth i (a # xs))", "by (cases i) (auto simp add: set_remove_nth_subset rev_subsetD)"], ["proof (state)\nthis:\n  distinct (remove_nth i (a # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}