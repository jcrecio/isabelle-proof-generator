{"file_name": "/home/qj213/afp-2021-10-22/thys/Myhill-Nerode/Closures.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Myhill-Nerode", "problem_names": ["lemma closure_union [intro]:\n  assumes \"regular A\" \"regular B\" \n  shows \"regular (A \\<union> B)\"", "lemma closure_seq [intro]:\n  assumes \"regular A\" \"regular B\" \n  shows \"regular (A \\<cdot> B)\"", "lemma closure_star [intro]:\n  assumes \"regular A\"\n  shows \"regular (A\\<star>)\"", "lemma closure_complement [intro]:\n  fixes A::\"('a::finite) lang\"\n  assumes \"regular A\"\n  shows \"regular (- A)\"", "lemma closure_difference [intro]:\n  fixes A::\"('a::finite) lang\"\n  assumes \"regular A\" \"regular B\" \n  shows \"regular (A - B)\"", "lemma closure_intersection [intro]:\n  fixes A::\"('a::finite) lang\"\n  assumes \"regular A\" \"regular B\" \n  shows \"regular (A \\<inter> B)\"", "lemma rev_seq[simp]:\n  shows \"rev ` (B \\<cdot> A) = (rev ` A) \\<cdot> (rev ` B)\"", "lemma rev_star1:\n  assumes a: \"s \\<in> (rev ` A)\\<star>\"\n  shows \"s \\<in> rev ` (A\\<star>)\"", "lemma rev_star2:\n  assumes a: \"s \\<in> A\\<star>\"\n  shows \"rev s \\<in> (rev ` A)\\<star>\"", "lemma rev_star [simp]:\n  shows \" rev ` (A\\<star>) = (rev ` A)\\<star>\"", "lemma rev_lang:\n  shows \"rev ` (lang r) = lang (Rev r)\"", "lemma closure_reversal [intro]:\n  assumes \"regular A\"\n  shows \"regular (rev ` A)\"", "lemma closure_left_quotient:\n  assumes \"regular A\"\n  shows \"regular (Deriv_lang B A)\"", "lemma singleton_regular:\n  shows \"regular {s}\"", "lemma finite_regular:\n  assumes \"finite A\"\n  shows \"regular A\"", "lemma cofinite_regular:\n  fixes A::\"'a::finite lang\"\n  assumes \"finite (- A)\"\n  shows \"regular A\"", "lemma continuation_lemma:\n  fixes A B::\"'a::finite lang\"\n  assumes reg: \"regular A\"\n  and     inf: \"infinite B\"\n  shows \"\\<exists>x \\<in> B. \\<exists>y \\<in> B. x \\<noteq> y \\<and> x \\<approx>A y\"", "lemma an_bn_not_regular:\n  shows \"\\<not> regular (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n})\""], "translations": [["", "lemma closure_union [intro]:\n  assumes \"regular A\" \"regular B\" \n  shows \"regular (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (A \\<union> B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (A \\<union> B)", "from assms"], ["proof (chain)\npicking this:\n  regular A\n  regular B", "obtain r1 r2::\"'a rexp\" where \"lang r1 = A\" \"lang r2 = B\""], ["proof (prove)\nusing this:\n  regular A\n  regular B\n\ngoal (1 subgoal):\n 1. (\\<And>r1 r2.\n        \\<lbrakk>lang r1 = A; lang r2 = B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lang r1 = A\n  lang r2 = B\n\ngoal (1 subgoal):\n 1. regular (A \\<union> B)", "then"], ["proof (chain)\npicking this:\n  lang r1 = A\n  lang r2 = B", "have \"A \\<union> B = lang (Plus r1 r2)\""], ["proof (prove)\nusing this:\n  lang r1 = A\n  lang r2 = B\n\ngoal (1 subgoal):\n 1. A \\<union> B = lang (Plus r1 r2)", "by simp"], ["proof (state)\nthis:\n  A \\<union> B = lang (Plus r1 r2)\n\ngoal (1 subgoal):\n 1. regular (A \\<union> B)", "then"], ["proof (chain)\npicking this:\n  A \\<union> B = lang (Plus r1 r2)", "show \"regular (A \\<union> B)\""], ["proof (prove)\nusing this:\n  A \\<union> B = lang (Plus r1 r2)\n\ngoal (1 subgoal):\n 1. regular (A \\<union> B)", "by blast"], ["proof (state)\nthis:\n  regular (A \\<union> B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closure_seq [intro]:\n  assumes \"regular A\" \"regular B\" \n  shows \"regular (A \\<cdot> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (A \\<cdot> B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (A \\<cdot> B)", "from assms"], ["proof (chain)\npicking this:\n  regular A\n  regular B", "obtain r1 r2::\"'a rexp\" where \"lang r1 = A\" \"lang r2 = B\""], ["proof (prove)\nusing this:\n  regular A\n  regular B\n\ngoal (1 subgoal):\n 1. (\\<And>r1 r2.\n        \\<lbrakk>lang r1 = A; lang r2 = B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lang r1 = A\n  lang r2 = B\n\ngoal (1 subgoal):\n 1. regular (A \\<cdot> B)", "then"], ["proof (chain)\npicking this:\n  lang r1 = A\n  lang r2 = B", "have \"A \\<cdot> B = lang (Times r1 r2)\""], ["proof (prove)\nusing this:\n  lang r1 = A\n  lang r2 = B\n\ngoal (1 subgoal):\n 1. A \\<cdot> B = lang (Times r1 r2)", "by simp"], ["proof (state)\nthis:\n  A \\<cdot> B = lang (Times r1 r2)\n\ngoal (1 subgoal):\n 1. regular (A \\<cdot> B)", "then"], ["proof (chain)\npicking this:\n  A \\<cdot> B = lang (Times r1 r2)", "show \"regular (A \\<cdot> B)\""], ["proof (prove)\nusing this:\n  A \\<cdot> B = lang (Times r1 r2)\n\ngoal (1 subgoal):\n 1. regular (A \\<cdot> B)", "by blast"], ["proof (state)\nthis:\n  regular (A \\<cdot> B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closure_star [intro]:\n  assumes \"regular A\"\n  shows \"regular (A\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (A\\<star>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (A\\<star>)", "from assms"], ["proof (chain)\npicking this:\n  regular A", "obtain r::\"'a rexp\" where \"lang r = A\""], ["proof (prove)\nusing this:\n  regular A\n\ngoal (1 subgoal):\n 1. (\\<And>r. lang r = A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  lang r = A\n\ngoal (1 subgoal):\n 1. regular (A\\<star>)", "then"], ["proof (chain)\npicking this:\n  lang r = A", "have \"A\\<star> = lang (Star r)\""], ["proof (prove)\nusing this:\n  lang r = A\n\ngoal (1 subgoal):\n 1. A\\<star> = lang (Star r)", "by simp"], ["proof (state)\nthis:\n  A\\<star> = lang (Star r)\n\ngoal (1 subgoal):\n 1. regular (A\\<star>)", "then"], ["proof (chain)\npicking this:\n  A\\<star> = lang (Star r)", "show \"regular (A\\<star>)\""], ["proof (prove)\nusing this:\n  A\\<star> = lang (Star r)\n\ngoal (1 subgoal):\n 1. regular (A\\<star>)", "by blast"], ["proof (state)\nthis:\n  regular (A\\<star>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closure under complementation\\<close>"], ["", "text \\<open>Closure under complementation is proved via the \n  Myhill-Nerode theorem\\<close>"], ["", "lemma closure_complement [intro]:\n  fixes A::\"('a::finite) lang\"\n  assumes \"regular A\"\n  shows \"regular (- A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (- A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (- A)", "from assms"], ["proof (chain)\npicking this:\n  regular A", "have \"finite (UNIV // \\<approx>A)\""], ["proof (prove)\nusing this:\n  regular A\n\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>A)", "by (simp add: Myhill_Nerode)"], ["proof (state)\nthis:\n  finite (UNIV // \\<approx>A)\n\ngoal (1 subgoal):\n 1. regular (- A)", "then"], ["proof (chain)\npicking this:\n  finite (UNIV // \\<approx>A)", "have \"finite (UNIV // \\<approx>(-A))\""], ["proof (prove)\nusing this:\n  finite (UNIV // \\<approx>A)\n\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>(- A))", "by (simp add: str_eq_def)"], ["proof (state)\nthis:\n  finite (UNIV // \\<approx>(- A))\n\ngoal (1 subgoal):\n 1. regular (- A)", "then"], ["proof (chain)\npicking this:\n  finite (UNIV // \\<approx>(- A))", "show \"regular (- A)\""], ["proof (prove)\nusing this:\n  finite (UNIV // \\<approx>(- A))\n\ngoal (1 subgoal):\n 1. regular (- A)", "by (simp add: Myhill_Nerode)"], ["proof (state)\nthis:\n  regular (- A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closure under \\<open>-\\<close> and \\<open>\\<inter>\\<close>\\<close>"], ["", "lemma closure_difference [intro]:\n  fixes A::\"('a::finite) lang\"\n  assumes \"regular A\" \"regular B\" \n  shows \"regular (A - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (A - B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (A - B)", "have \"A - B = - (- A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B = - (- A \\<union> B)", "by blast"], ["proof (state)\nthis:\n  A - B = - (- A \\<union> B)\n\ngoal (1 subgoal):\n 1. regular (A - B)", "moreover"], ["proof (state)\nthis:\n  A - B = - (- A \\<union> B)\n\ngoal (1 subgoal):\n 1. regular (A - B)", "have \"regular (- (- A \\<union> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (- (- A \\<union> B))", "using assms"], ["proof (prove)\nusing this:\n  regular A\n  regular B\n\ngoal (1 subgoal):\n 1. regular (- (- A \\<union> B))", "by blast"], ["proof (state)\nthis:\n  regular (- (- A \\<union> B))\n\ngoal (1 subgoal):\n 1. regular (A - B)", "ultimately"], ["proof (chain)\npicking this:\n  A - B = - (- A \\<union> B)\n  regular (- (- A \\<union> B))", "show \"regular (A - B)\""], ["proof (prove)\nusing this:\n  A - B = - (- A \\<union> B)\n  regular (- (- A \\<union> B))\n\ngoal (1 subgoal):\n 1. regular (A - B)", "by simp"], ["proof (state)\nthis:\n  regular (A - B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closure_intersection [intro]:\n  fixes A::\"('a::finite) lang\"\n  assumes \"regular A\" \"regular B\" \n  shows \"regular (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (A \\<inter> B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (A \\<inter> B)", "have \"A \\<inter> B = - (- A \\<union> - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B = - (- A \\<union> - B)", "by blast"], ["proof (state)\nthis:\n  A \\<inter> B = - (- A \\<union> - B)\n\ngoal (1 subgoal):\n 1. regular (A \\<inter> B)", "moreover"], ["proof (state)\nthis:\n  A \\<inter> B = - (- A \\<union> - B)\n\ngoal (1 subgoal):\n 1. regular (A \\<inter> B)", "have \"regular (- (- A \\<union> - B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (- (- A \\<union> - B))", "using assms"], ["proof (prove)\nusing this:\n  regular A\n  regular B\n\ngoal (1 subgoal):\n 1. regular (- (- A \\<union> - B))", "by blast"], ["proof (state)\nthis:\n  regular (- (- A \\<union> - B))\n\ngoal (1 subgoal):\n 1. regular (A \\<inter> B)", "ultimately"], ["proof (chain)\npicking this:\n  A \\<inter> B = - (- A \\<union> - B)\n  regular (- (- A \\<union> - B))", "show \"regular (A \\<inter> B)\""], ["proof (prove)\nusing this:\n  A \\<inter> B = - (- A \\<union> - B)\n  regular (- (- A \\<union> - B))\n\ngoal (1 subgoal):\n 1. regular (A \\<inter> B)", "by simp"], ["proof (state)\nthis:\n  regular (A \\<inter> B)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closure under string reversal\\<close>"], ["", "fun\n  Rev :: \"'a rexp \\<Rightarrow> 'a rexp\"\nwhere\n  \"Rev Zero = Zero\"\n| \"Rev One = One\"\n| \"Rev (Atom c) = Atom c\"\n| \"Rev (Plus r1 r2) = Plus (Rev r1) (Rev r2)\"\n| \"Rev (Times r1 r2) = Times (Rev r2) (Rev r1)\"\n| \"Rev (Star r) = Star (Rev r)\""], ["", "lemma rev_seq[simp]:\n  shows \"rev ` (B \\<cdot> A) = (rev ` A) \\<cdot> (rev ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev ` B \\<cdot> A = (rev ` A) \\<cdot> (rev ` B)", "unfolding conc_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{xs @ ys |xs ys. xs \\<in> B \\<and> ys \\<in> A}.\n           y = rev x} =\n    {xs @ ys |xs ys.\n     xs \\<in> {y. \\<exists>x\\<in>A. y = rev x} \\<and>\n     ys \\<in> {y. \\<exists>x\\<in>B. y = rev x}}", "by (auto) (metis rev_append)+"], ["", "lemma rev_star1:\n  assumes a: \"s \\<in> (rev ` A)\\<star>\"\n  shows \"s \\<in> rev ` (A\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> rev ` A\\<star>", "using a"], ["proof (prove)\nusing this:\n  s \\<in> (rev ` A)\\<star>\n\ngoal (1 subgoal):\n 1. s \\<in> rev ` A\\<star>", "proof(induct rule: star_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> rev ` A\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> rev ` A; v \\<in> (rev ` A)\\<star>;\n        v \\<in> rev ` A\\<star>\\<rbrakk>\n       \\<Longrightarrow> u @ v \\<in> rev ` A\\<star>", "case (append s1 s2)"], ["proof (state)\nthis:\n  s1 \\<in> rev ` A\n  s2 \\<in> (rev ` A)\\<star>\n  s2 \\<in> rev ` A\\<star>\n\ngoal (2 subgoals):\n 1. [] \\<in> rev ` A\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> rev ` A; v \\<in> (rev ` A)\\<star>;\n        v \\<in> rev ` A\\<star>\\<rbrakk>\n       \\<Longrightarrow> u @ v \\<in> rev ` A\\<star>", "have inj: \"inj (rev::'a list \\<Rightarrow> 'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj rev", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV. rev x = rev y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj rev\n\ngoal (2 subgoals):\n 1. [] \\<in> rev ` A\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> rev ` A; v \\<in> (rev ` A)\\<star>;\n        v \\<in> rev ` A\\<star>\\<rbrakk>\n       \\<Longrightarrow> u @ v \\<in> rev ` A\\<star>", "have \"s1 \\<in> rev ` A\" \"s2 \\<in> rev ` (A\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<in> rev ` A &&& s2 \\<in> rev ` A\\<star>", "by fact+"], ["proof (state)\nthis:\n  s1 \\<in> rev ` A\n  s2 \\<in> rev ` A\\<star>\n\ngoal (2 subgoals):\n 1. [] \\<in> rev ` A\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> rev ` A; v \\<in> (rev ` A)\\<star>;\n        v \\<in> rev ` A\\<star>\\<rbrakk>\n       \\<Longrightarrow> u @ v \\<in> rev ` A\\<star>", "then"], ["proof (chain)\npicking this:\n  s1 \\<in> rev ` A\n  s2 \\<in> rev ` A\\<star>", "obtain x1 x2 where \"x1 \\<in> A\" \"x2 \\<in> A\\<star>\" and eqs: \"s1 = rev x1\" \"s2 = rev x2\""], ["proof (prove)\nusing this:\n  s1 \\<in> rev ` A\n  s2 \\<in> rev ` A\\<star>\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 \\<in> A; x2 \\<in> A\\<star>; s1 = rev x1;\n         s2 = rev x2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x1 \\<in> A\n  x2 \\<in> A\\<star>\n  s1 = rev x1\n  s2 = rev x2\n\ngoal (2 subgoals):\n 1. [] \\<in> rev ` A\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> rev ` A; v \\<in> (rev ` A)\\<star>;\n        v \\<in> rev ` A\\<star>\\<rbrakk>\n       \\<Longrightarrow> u @ v \\<in> rev ` A\\<star>", "then"], ["proof (chain)\npicking this:\n  x1 \\<in> A\n  x2 \\<in> A\\<star>\n  s1 = rev x1\n  s2 = rev x2", "have \"x1 \\<in> A\\<star>\" \"x2 \\<in> A\\<star>\""], ["proof (prove)\nusing this:\n  x1 \\<in> A\n  x2 \\<in> A\\<star>\n  s1 = rev x1\n  s2 = rev x2\n\ngoal (1 subgoal):\n 1. x1 \\<in> A\\<star> &&& x2 \\<in> A\\<star>", "by (auto)"], ["proof (state)\nthis:\n  x1 \\<in> A\\<star>\n  x2 \\<in> A\\<star>\n\ngoal (2 subgoals):\n 1. [] \\<in> rev ` A\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> rev ` A; v \\<in> (rev ` A)\\<star>;\n        v \\<in> rev ` A\\<star>\\<rbrakk>\n       \\<Longrightarrow> u @ v \\<in> rev ` A\\<star>", "then"], ["proof (chain)\npicking this:\n  x1 \\<in> A\\<star>\n  x2 \\<in> A\\<star>", "have \"x2 @ x1 \\<in> A\\<star>\""], ["proof (prove)\nusing this:\n  x1 \\<in> A\\<star>\n  x2 \\<in> A\\<star>\n\ngoal (1 subgoal):\n 1. x2 @ x1 \\<in> A\\<star>", "by (auto)"], ["proof (state)\nthis:\n  x2 @ x1 \\<in> A\\<star>\n\ngoal (2 subgoals):\n 1. [] \\<in> rev ` A\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> rev ` A; v \\<in> (rev ` A)\\<star>;\n        v \\<in> rev ` A\\<star>\\<rbrakk>\n       \\<Longrightarrow> u @ v \\<in> rev ` A\\<star>", "then"], ["proof (chain)\npicking this:\n  x2 @ x1 \\<in> A\\<star>", "have \"rev (x2 @ x1) \\<in> rev ` A\\<star>\""], ["proof (prove)\nusing this:\n  x2 @ x1 \\<in> A\\<star>\n\ngoal (1 subgoal):\n 1. rev (x2 @ x1) \\<in> rev ` A\\<star>", "using inj"], ["proof (prove)\nusing this:\n  x2 @ x1 \\<in> A\\<star>\n  inj rev\n\ngoal (1 subgoal):\n 1. rev (x2 @ x1) \\<in> rev ` A\\<star>", "by (simp only: inj_image_mem_iff)"], ["proof (state)\nthis:\n  rev (x2 @ x1) \\<in> rev ` A\\<star>\n\ngoal (2 subgoals):\n 1. [] \\<in> rev ` A\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> rev ` A; v \\<in> (rev ` A)\\<star>;\n        v \\<in> rev ` A\\<star>\\<rbrakk>\n       \\<Longrightarrow> u @ v \\<in> rev ` A\\<star>", "then"], ["proof (chain)\npicking this:\n  rev (x2 @ x1) \\<in> rev ` A\\<star>", "show \"s1 @ s2 \\<in>  rev ` A\\<star>\""], ["proof (prove)\nusing this:\n  rev (x2 @ x1) \\<in> rev ` A\\<star>\n\ngoal (1 subgoal):\n 1. s1 @ s2 \\<in> rev ` A\\<star>", "using eqs"], ["proof (prove)\nusing this:\n  rev (x2 @ x1) \\<in> rev ` A\\<star>\n  s1 = rev x1\n  s2 = rev x2\n\ngoal (1 subgoal):\n 1. s1 @ s2 \\<in> rev ` A\\<star>", "by simp"], ["proof (state)\nthis:\n  s1 @ s2 \\<in> rev ` A\\<star>\n\ngoal (1 subgoal):\n 1. [] \\<in> rev ` A\\<star>", "qed (auto)"], ["", "lemma rev_star2:\n  assumes a: \"s \\<in> A\\<star>\"\n  shows \"rev s \\<in> (rev ` A)\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev s \\<in> (rev ` A)\\<star>", "using a"], ["proof (prove)\nusing this:\n  s \\<in> A\\<star>\n\ngoal (1 subgoal):\n 1. rev s \\<in> (rev ` A)\\<star>", "proof(induct rule: star_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. rev [] \\<in> (rev ` A)\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> A; v \\<in> A\\<star>;\n        rev v \\<in> (rev ` A)\\<star>\\<rbrakk>\n       \\<Longrightarrow> rev (u @ v) \\<in> (rev ` A)\\<star>", "case (append s1 s2)"], ["proof (state)\nthis:\n  s1 \\<in> A\n  s2 \\<in> A\\<star>\n  rev s2 \\<in> (rev ` A)\\<star>\n\ngoal (2 subgoals):\n 1. rev [] \\<in> (rev ` A)\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> A; v \\<in> A\\<star>;\n        rev v \\<in> (rev ` A)\\<star>\\<rbrakk>\n       \\<Longrightarrow> rev (u @ v) \\<in> (rev ` A)\\<star>", "have inj: \"inj (rev::'a list \\<Rightarrow> 'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj rev", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV. rev x = rev y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj rev\n\ngoal (2 subgoals):\n 1. rev [] \\<in> (rev ` A)\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> A; v \\<in> A\\<star>;\n        rev v \\<in> (rev ` A)\\<star>\\<rbrakk>\n       \\<Longrightarrow> rev (u @ v) \\<in> (rev ` A)\\<star>", "have \"s1 \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<in> A", "by fact"], ["proof (state)\nthis:\n  s1 \\<in> A\n\ngoal (2 subgoals):\n 1. rev [] \\<in> (rev ` A)\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> A; v \\<in> A\\<star>;\n        rev v \\<in> (rev ` A)\\<star>\\<rbrakk>\n       \\<Longrightarrow> rev (u @ v) \\<in> (rev ` A)\\<star>", "then"], ["proof (chain)\npicking this:\n  s1 \\<in> A", "have \"rev s1 \\<in> rev ` A\""], ["proof (prove)\nusing this:\n  s1 \\<in> A\n\ngoal (1 subgoal):\n 1. rev s1 \\<in> rev ` A", "using inj"], ["proof (prove)\nusing this:\n  s1 \\<in> A\n  inj rev\n\ngoal (1 subgoal):\n 1. rev s1 \\<in> rev ` A", "by (simp only: inj_image_mem_iff)"], ["proof (state)\nthis:\n  rev s1 \\<in> rev ` A\n\ngoal (2 subgoals):\n 1. rev [] \\<in> (rev ` A)\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> A; v \\<in> A\\<star>;\n        rev v \\<in> (rev ` A)\\<star>\\<rbrakk>\n       \\<Longrightarrow> rev (u @ v) \\<in> (rev ` A)\\<star>", "then"], ["proof (chain)\npicking this:\n  rev s1 \\<in> rev ` A", "have \"rev s1 \\<in> (rev ` A)\\<star>\""], ["proof (prove)\nusing this:\n  rev s1 \\<in> rev ` A\n\ngoal (1 subgoal):\n 1. rev s1 \\<in> (rev ` A)\\<star>", "by (auto)"], ["proof (state)\nthis:\n  rev s1 \\<in> (rev ` A)\\<star>\n\ngoal (2 subgoals):\n 1. rev [] \\<in> (rev ` A)\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> A; v \\<in> A\\<star>;\n        rev v \\<in> (rev ` A)\\<star>\\<rbrakk>\n       \\<Longrightarrow> rev (u @ v) \\<in> (rev ` A)\\<star>", "moreover"], ["proof (state)\nthis:\n  rev s1 \\<in> (rev ` A)\\<star>\n\ngoal (2 subgoals):\n 1. rev [] \\<in> (rev ` A)\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> A; v \\<in> A\\<star>;\n        rev v \\<in> (rev ` A)\\<star>\\<rbrakk>\n       \\<Longrightarrow> rev (u @ v) \\<in> (rev ` A)\\<star>", "have \"rev s2 \\<in> (rev ` A)\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev s2 \\<in> (rev ` A)\\<star>", "by fact"], ["proof (state)\nthis:\n  rev s2 \\<in> (rev ` A)\\<star>\n\ngoal (2 subgoals):\n 1. rev [] \\<in> (rev ` A)\\<star>\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> A; v \\<in> A\\<star>;\n        rev v \\<in> (rev ` A)\\<star>\\<rbrakk>\n       \\<Longrightarrow> rev (u @ v) \\<in> (rev ` A)\\<star>", "ultimately"], ["proof (chain)\npicking this:\n  rev s1 \\<in> (rev ` A)\\<star>\n  rev s2 \\<in> (rev ` A)\\<star>", "show \"rev (s1 @ s2) \\<in>  (rev ` A)\\<star>\""], ["proof (prove)\nusing this:\n  rev s1 \\<in> (rev ` A)\\<star>\n  rev s2 \\<in> (rev ` A)\\<star>\n\ngoal (1 subgoal):\n 1. rev (s1 @ s2) \\<in> (rev ` A)\\<star>", "by (auto)"], ["proof (state)\nthis:\n  rev (s1 @ s2) \\<in> (rev ` A)\\<star>\n\ngoal (1 subgoal):\n 1. rev [] \\<in> (rev ` A)\\<star>", "qed (auto)"], ["", "lemma rev_star [simp]:\n  shows \" rev ` (A\\<star>) = (rev ` A)\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev ` A\\<star> = (rev ` A)\\<star>", "using rev_star1 rev_star2"], ["proof (prove)\nusing this:\n  ?s \\<in> (rev ` ?A)\\<star> \\<Longrightarrow> ?s \\<in> rev ` ?A\\<star>\n  ?s \\<in> ?A\\<star> \\<Longrightarrow> rev ?s \\<in> (rev ` ?A)\\<star>\n\ngoal (1 subgoal):\n 1. rev ` A\\<star> = (rev ` A)\\<star>", "by auto"], ["", "lemma rev_lang:\n  shows \"rev ` (lang r) = lang (Rev r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev ` lang r = lang (Rev r)", "by (induct r) (simp_all add: image_Un)"], ["", "lemma closure_reversal [intro]:\n  assumes \"regular A\"\n  shows \"regular (rev ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (rev ` A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (rev ` A)", "from assms"], ["proof (chain)\npicking this:\n  regular A", "obtain r::\"'a rexp\" where \"A = lang r\""], ["proof (prove)\nusing this:\n  regular A\n\ngoal (1 subgoal):\n 1. (\\<And>r. A = lang r \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  A = lang r\n\ngoal (1 subgoal):\n 1. regular (rev ` A)", "then"], ["proof (chain)\npicking this:\n  A = lang r", "have \"lang (Rev r) = rev ` A\""], ["proof (prove)\nusing this:\n  A = lang r\n\ngoal (1 subgoal):\n 1. lang (Rev r) = rev ` A", "by (simp add: rev_lang)"], ["proof (state)\nthis:\n  lang (Rev r) = rev ` A\n\ngoal (1 subgoal):\n 1. regular (rev ` A)", "then"], ["proof (chain)\npicking this:\n  lang (Rev r) = rev ` A", "show \"regular (rev` A)\""], ["proof (prove)\nusing this:\n  lang (Rev r) = rev ` A\n\ngoal (1 subgoal):\n 1. regular (rev ` A)", "by blast"], ["proof (state)\nthis:\n  regular (rev ` A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closure under left-quotients\\<close>"], ["", "abbreviation\n  \"Deriv_lang A B \\<equiv> \\<Union>x \\<in> A. Derivs x B\""], ["", "lemma closure_left_quotient:\n  assumes \"regular A\"\n  shows \"regular (Deriv_lang B A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (Deriv_lang B A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (Deriv_lang B A)", "from assms"], ["proof (chain)\npicking this:\n  regular A", "obtain r::\"'a rexp\" where eq: \"lang r = A\""], ["proof (prove)\nusing this:\n  regular A\n\ngoal (1 subgoal):\n 1. (\\<And>r. lang r = A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  lang r = A\n\ngoal (1 subgoal):\n 1. regular (Deriv_lang B A)", "have fin: \"finite (pderivs_lang B r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (pderivs_lang B r)", "by (rule finite_pderivs_lang)"], ["proof (state)\nthis:\n  finite (pderivs_lang B r)\n\ngoal (1 subgoal):\n 1. regular (Deriv_lang B A)", "have \"Deriv_lang B (lang r) = (\\<Union> (lang ` pderivs_lang B r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Deriv_lang B (lang r) = \\<Union> (lang ` pderivs_lang B r)", "by (simp add: Derivs_pderivs pderivs_lang_def)"], ["proof (state)\nthis:\n  Deriv_lang B (lang r) = \\<Union> (lang ` pderivs_lang B r)\n\ngoal (1 subgoal):\n 1. regular (Deriv_lang B A)", "also"], ["proof (state)\nthis:\n  Deriv_lang B (lang r) = \\<Union> (lang ` pderivs_lang B r)\n\ngoal (1 subgoal):\n 1. regular (Deriv_lang B A)", "have \"\\<dots> = lang (\\<Uplus>(pderivs_lang B r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (lang ` pderivs_lang B r) = lang (\\<Uplus>(pderivs_lang B r))", "using fin"], ["proof (prove)\nusing this:\n  finite (pderivs_lang B r)\n\ngoal (1 subgoal):\n 1. \\<Union> (lang ` pderivs_lang B r) = lang (\\<Uplus>(pderivs_lang B r))", "by simp"], ["proof (state)\nthis:\n  \\<Union> (lang ` pderivs_lang B r) = lang (\\<Uplus>(pderivs_lang B r))\n\ngoal (1 subgoal):\n 1. regular (Deriv_lang B A)", "finally"], ["proof (chain)\npicking this:\n  Deriv_lang B (lang r) = lang (\\<Uplus>(pderivs_lang B r))", "have \"Deriv_lang B A = lang (\\<Uplus>(pderivs_lang B r))\""], ["proof (prove)\nusing this:\n  Deriv_lang B (lang r) = lang (\\<Uplus>(pderivs_lang B r))\n\ngoal (1 subgoal):\n 1. Deriv_lang B A = lang (\\<Uplus>(pderivs_lang B r))", "using eq"], ["proof (prove)\nusing this:\n  Deriv_lang B (lang r) = lang (\\<Uplus>(pderivs_lang B r))\n  lang r = A\n\ngoal (1 subgoal):\n 1. Deriv_lang B A = lang (\\<Uplus>(pderivs_lang B r))", "by simp"], ["proof (state)\nthis:\n  Deriv_lang B A = lang (\\<Uplus>(pderivs_lang B r))\n\ngoal (1 subgoal):\n 1. regular (Deriv_lang B A)", "then"], ["proof (chain)\npicking this:\n  Deriv_lang B A = lang (\\<Uplus>(pderivs_lang B r))", "show \"regular (Deriv_lang B A)\""], ["proof (prove)\nusing this:\n  Deriv_lang B A = lang (\\<Uplus>(pderivs_lang B r))\n\ngoal (1 subgoal):\n 1. regular (Deriv_lang B A)", "by auto"], ["proof (state)\nthis:\n  regular (Deriv_lang B A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Finite and co-finite sets are regular\\<close>"], ["", "lemma singleton_regular:\n  shows \"regular {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {s}", "proof (induct s)"], ["proof (state)\ngoal (2 subgoals):\n 1. regular {[]}\n 2. \\<And>a s. regular {s} \\<Longrightarrow> regular {a # s}", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. regular {[]}\n 2. \\<And>a s. regular {s} \\<Longrightarrow> regular {a # s}", "have \"{[]} = lang (One)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {[]} = lang One", "by simp"], ["proof (state)\nthis:\n  {[]} = lang One\n\ngoal (2 subgoals):\n 1. regular {[]}\n 2. \\<And>a s. regular {s} \\<Longrightarrow> regular {a # s}", "then"], ["proof (chain)\npicking this:\n  {[]} = lang One", "show \"regular {[]}\""], ["proof (prove)\nusing this:\n  {[]} = lang One\n\ngoal (1 subgoal):\n 1. regular {[]}", "by blast"], ["proof (state)\nthis:\n  regular {[]}\n\ngoal (1 subgoal):\n 1. \\<And>a s. regular {s} \\<Longrightarrow> regular {a # s}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a s. regular {s} \\<Longrightarrow> regular {a # s}", "case (Cons c s)"], ["proof (state)\nthis:\n  regular {s}\n\ngoal (1 subgoal):\n 1. \\<And>a s. regular {s} \\<Longrightarrow> regular {a # s}", "have \"regular {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {s}", "by fact"], ["proof (state)\nthis:\n  regular {s}\n\ngoal (1 subgoal):\n 1. \\<And>a s. regular {s} \\<Longrightarrow> regular {a # s}", "then"], ["proof (chain)\npicking this:\n  regular {s}", "obtain r where \"{s} = lang r\""], ["proof (prove)\nusing this:\n  regular {s}\n\ngoal (1 subgoal):\n 1. (\\<And>r. {s} = lang r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  {s} = lang r\n\ngoal (1 subgoal):\n 1. \\<And>a s. regular {s} \\<Longrightarrow> regular {a # s}", "then"], ["proof (chain)\npicking this:\n  {s} = lang r", "have \"{c # s} = lang (Times (Atom c) r)\""], ["proof (prove)\nusing this:\n  {s} = lang r\n\ngoal (1 subgoal):\n 1. {c # s} = lang (Times (Atom c) r)", "by (auto simp add: conc_def)"], ["proof (state)\nthis:\n  {c # s} = lang (Times (Atom c) r)\n\ngoal (1 subgoal):\n 1. \\<And>a s. regular {s} \\<Longrightarrow> regular {a # s}", "then"], ["proof (chain)\npicking this:\n  {c # s} = lang (Times (Atom c) r)", "show \"regular {c # s}\""], ["proof (prove)\nusing this:\n  {c # s} = lang (Times (Atom c) r)\n\ngoal (1 subgoal):\n 1. regular {c # s}", "by blast"], ["proof (state)\nthis:\n  regular {c # s}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_regular:\n  assumes \"finite A\"\n  shows \"regular A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. regular A", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. regular {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; regular F\\<rbrakk>\n       \\<Longrightarrow> regular (insert x F)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. regular {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; regular F\\<rbrakk>\n       \\<Longrightarrow> regular (insert x F)", "have \"{} = lang (Zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} = lang Zero", "by simp"], ["proof (state)\nthis:\n  {} = lang Zero\n\ngoal (2 subgoals):\n 1. regular {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; regular F\\<rbrakk>\n       \\<Longrightarrow> regular (insert x F)", "then"], ["proof (chain)\npicking this:\n  {} = lang Zero", "show \"regular {}\""], ["proof (prove)\nusing this:\n  {} = lang Zero\n\ngoal (1 subgoal):\n 1. regular {}", "by blast"], ["proof (state)\nthis:\n  regular {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; regular F\\<rbrakk>\n       \\<Longrightarrow> regular (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; regular F\\<rbrakk>\n       \\<Longrightarrow> regular (insert x F)", "case (insert s A)"], ["proof (state)\nthis:\n  finite A\n  s \\<notin> A\n  regular A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; regular F\\<rbrakk>\n       \\<Longrightarrow> regular (insert x F)", "have \"regular {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {s}", "by (simp add: singleton_regular)"], ["proof (state)\nthis:\n  regular {s}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; regular F\\<rbrakk>\n       \\<Longrightarrow> regular (insert x F)", "moreover"], ["proof (state)\nthis:\n  regular {s}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; regular F\\<rbrakk>\n       \\<Longrightarrow> regular (insert x F)", "have \"regular A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular A", "by fact"], ["proof (state)\nthis:\n  regular A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; regular F\\<rbrakk>\n       \\<Longrightarrow> regular (insert x F)", "ultimately"], ["proof (chain)\npicking this:\n  regular {s}\n  regular A", "have \"regular ({s} \\<union> A)\""], ["proof (prove)\nusing this:\n  regular {s}\n  regular A\n\ngoal (1 subgoal):\n 1. regular ({s} \\<union> A)", "by (rule closure_union)"], ["proof (state)\nthis:\n  regular ({s} \\<union> A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; regular F\\<rbrakk>\n       \\<Longrightarrow> regular (insert x F)", "then"], ["proof (chain)\npicking this:\n  regular ({s} \\<union> A)", "show \"regular (insert s A)\""], ["proof (prove)\nusing this:\n  regular ({s} \\<union> A)\n\ngoal (1 subgoal):\n 1. regular (insert s A)", "by simp"], ["proof (state)\nthis:\n  regular (insert s A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cofinite_regular:\n  fixes A::\"'a::finite lang\"\n  assumes \"finite (- A)\"\n  shows \"regular A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular A", "from assms"], ["proof (chain)\npicking this:\n  finite (- A)", "have \"regular (- A)\""], ["proof (prove)\nusing this:\n  finite (- A)\n\ngoal (1 subgoal):\n 1. regular (- A)", "by (simp add: finite_regular)"], ["proof (state)\nthis:\n  regular (- A)\n\ngoal (1 subgoal):\n 1. regular A", "then"], ["proof (chain)\npicking this:\n  regular (- A)", "have \"regular (-(- A))\""], ["proof (prove)\nusing this:\n  regular (- A)\n\ngoal (1 subgoal):\n 1. regular (- (- A))", "by (rule closure_complement)"], ["proof (state)\nthis:\n  regular (- (- A))\n\ngoal (1 subgoal):\n 1. regular A", "then"], ["proof (chain)\npicking this:\n  regular (- (- A))", "show \"regular A\""], ["proof (prove)\nusing this:\n  regular (- (- A))\n\ngoal (1 subgoal):\n 1. regular A", "by simp"], ["proof (state)\nthis:\n  regular A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Continuation lemma for showing non-regularity of languages\\<close>"], ["", "lemma continuation_lemma:\n  fixes A B::\"'a::finite lang\"\n  assumes reg: \"regular A\"\n  and     inf: \"infinite B\"\n  shows \"\\<exists>x \\<in> B. \\<exists>y \\<in> B. x \\<noteq> y \\<and> x \\<approx>A y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "define eqfun where \"eqfun = (\\<lambda>A x::('a::finite list). (\\<approx>A) `` {x})\""], ["proof (state)\nthis:\n  eqfun = (\\<lambda>A x. \\<approx>A `` {x})\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "have \"finite (UNIV // \\<approx>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>A)", "using reg"], ["proof (prove)\nusing this:\n  regular A\n\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>A)", "by (simp add: Myhill_Nerode)"], ["proof (state)\nthis:\n  finite (UNIV // \\<approx>A)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "moreover"], ["proof (state)\nthis:\n  finite (UNIV // \\<approx>A)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "have \"(eqfun A) ` B \\<subseteq> UNIV // (\\<approx>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqfun A ` B \\<subseteq> UNIV // \\<approx>A", "unfolding eqfun_def quotient_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<approx>A `` {x}) ` B\n    \\<subseteq> (\\<Union>x. {\\<approx>A `` {x}})", "by auto"], ["proof (state)\nthis:\n  eqfun A ` B \\<subseteq> UNIV // \\<approx>A\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "ultimately"], ["proof (chain)\npicking this:\n  finite (UNIV // \\<approx>A)\n  eqfun A ` B \\<subseteq> UNIV // \\<approx>A", "have \"finite ((eqfun A) ` B)\""], ["proof (prove)\nusing this:\n  finite (UNIV // \\<approx>A)\n  eqfun A ` B \\<subseteq> UNIV // \\<approx>A\n\ngoal (1 subgoal):\n 1. finite (eqfun A ` B)", "by (rule rev_finite_subset)"], ["proof (state)\nthis:\n  finite (eqfun A ` B)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "with inf"], ["proof (chain)\npicking this:\n  infinite B\n  finite (eqfun A ` B)", "have \"\\<exists>a \\<in> B. infinite {b \\<in> B. eqfun A b = eqfun A a}\""], ["proof (prove)\nusing this:\n  infinite B\n  finite (eqfun A ` B)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>B. infinite {b \\<in> B. eqfun A b = eqfun A a}", "by (rule pigeonhole_infinite)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>B. infinite {b \\<in> B. eqfun A b = eqfun A a}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "then"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>B. infinite {b \\<in> B. eqfun A b = eqfun A a}", "obtain a where in_a: \"a \\<in> B\" and \"infinite {b \\<in> B. eqfun A b = eqfun A a}\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>B. infinite {b \\<in> B. eqfun A b = eqfun A a}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> B;\n         infinite {b \\<in> B. eqfun A b = eqfun A a}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> B\n  infinite {b \\<in> B. eqfun A b = eqfun A a}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "moreover"], ["proof (state)\nthis:\n  a \\<in> B\n  infinite {b \\<in> B. eqfun A b = eqfun A a}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "have \"{b \\<in> B. eqfun A b = eqfun A a} = {b \\<in> B. b \\<approx>A a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {b \\<in> B. eqfun A b = eqfun A a} = {b \\<in> B. b \\<approx>A a}", "unfolding eqfun_def Image_def str_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {b \\<in> B.\n     {y. \\<exists>x\\<in>{b}.\n            (x, y)\n            \\<in> {(x, y). \\<forall>z. (x @ z \\<in> A) = (y @ z \\<in> A)}} =\n     {y. \\<exists>x\\<in>{a}.\n            (x, y)\n            \\<in> {(x, y).\n                   \\<forall>z. (x @ z \\<in> A) = (y @ z \\<in> A)}}} =\n    {b \\<in> B.\n     (b, a) \\<in> {(x, y). \\<forall>z. (x @ z \\<in> A) = (y @ z \\<in> A)}}", "by auto"], ["proof (state)\nthis:\n  {b \\<in> B. eqfun A b = eqfun A a} = {b \\<in> B. b \\<approx>A a}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> B\n  infinite {b \\<in> B. eqfun A b = eqfun A a}\n  {b \\<in> B. eqfun A b = eqfun A a} = {b \\<in> B. b \\<approx>A a}", "have \"infinite {b \\<in> B. b \\<approx>A a}\""], ["proof (prove)\nusing this:\n  a \\<in> B\n  infinite {b \\<in> B. eqfun A b = eqfun A a}\n  {b \\<in> B. eqfun A b = eqfun A a} = {b \\<in> B. b \\<approx>A a}\n\ngoal (1 subgoal):\n 1. infinite {b \\<in> B. b \\<approx>A a}", "by simp"], ["proof (state)\nthis:\n  infinite {b \\<in> B. b \\<approx>A a}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "then"], ["proof (chain)\npicking this:\n  infinite {b \\<in> B. b \\<approx>A a}", "have \"infinite ({b \\<in> B. b \\<approx>A a} - {a})\""], ["proof (prove)\nusing this:\n  infinite {b \\<in> B. b \\<approx>A a}\n\ngoal (1 subgoal):\n 1. infinite ({b \\<in> B. b \\<approx>A a} - {a})", "by simp"], ["proof (state)\nthis:\n  infinite ({b \\<in> B. b \\<approx>A a} - {a})\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "moreover"], ["proof (state)\nthis:\n  infinite ({b \\<in> B. b \\<approx>A a} - {a})\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "have \"{b \\<in> B. b \\<approx>A a} - {a} = {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {b \\<in> B. b \\<approx>A a} - {a} =\n    {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a}", "by auto"], ["proof (state)\nthis:\n  {b \\<in> B. b \\<approx>A a} - {a} =\n  {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "ultimately"], ["proof (chain)\npicking this:\n  infinite ({b \\<in> B. b \\<approx>A a} - {a})\n  {b \\<in> B. b \\<approx>A a} - {a} =\n  {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a}", "have \"infinite {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a}\""], ["proof (prove)\nusing this:\n  infinite ({b \\<in> B. b \\<approx>A a} - {a})\n  {b \\<in> B. b \\<approx>A a} - {a} =\n  {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a}\n\ngoal (1 subgoal):\n 1. infinite {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a}", "by simp"], ["proof (state)\nthis:\n  infinite {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "then"], ["proof (chain)\npicking this:\n  infinite {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a}", "have \"{b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  infinite {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a}\n\ngoal (1 subgoal):\n 1. {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a} \\<noteq> {}", "by (metis finite.emptyI)"], ["proof (state)\nthis:\n  {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "then"], ["proof (chain)\npicking this:\n  {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a} \\<noteq> {}", "obtain b where \"b \\<in> B\" \"b \\<noteq> a\" \"b \\<approx>A a\""], ["proof (prove)\nusing this:\n  {b \\<in> B. b \\<approx>A a \\<and> b \\<noteq> a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> B; b \\<noteq> a; b \\<approx>A a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b \\<in> B\n  b \\<noteq> a\n  b \\<approx>A a\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "with in_a"], ["proof (chain)\npicking this:\n  a \\<in> B\n  b \\<in> B\n  b \\<noteq> a\n  b \\<approx>A a", "show \"\\<exists>x \\<in> B. \\<exists>y \\<in> B. x \\<noteq> y \\<and> x \\<approx>A y\""], ["proof (prove)\nusing this:\n  a \\<in> B\n  b \\<in> B\n  b \\<noteq> a\n  b \\<approx>A a\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<in>B. \\<exists>y\\<in>B. x \\<noteq> y \\<and> x \\<approx>A y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The language \\<open>a\\<^sup>n b\\<^sup>n\\<close> is not regular\\<close>"], ["", "abbreviation\n  replicate_rev (\"_ ^^^ _\" [100, 100] 100)\nwhere\n  \"a ^^^ n \\<equiv> replicate n a\""], ["", "lemma an_bn_not_regular:\n  shows \"\\<not> regular (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> regular (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. regular\n     (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n}) \\<Longrightarrow>\n    False", "define A where \"A = (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n})\""], ["proof (state)\nthis:\n  A = (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n})\n\ngoal (1 subgoal):\n 1. regular\n     (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n}) \\<Longrightarrow>\n    False", "assume as: \"regular A\""], ["proof (state)\nthis:\n  regular A\n\ngoal (1 subgoal):\n 1. regular\n     (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n}) \\<Longrightarrow>\n    False", "define B where \"B = (\\<Union>n. {CHR ''a'' ^^^ n})\""], ["proof (state)\nthis:\n  B = (\\<Union>n. {CHR ''a'' ^^^ n})\n\ngoal (1 subgoal):\n 1. regular\n     (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n}) \\<Longrightarrow>\n    False", "have sameness: \"\\<And>i j. CHR ''a'' ^^^ i @ CHR ''b'' ^^^ j \\<in> A \\<longleftrightarrow> i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j. (CHR ''a'' ^^^ i @ CHR ''b'' ^^^ j \\<in> A) = (i = j)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (CHR ''a'' ^^^ i @ CHR ''b'' ^^^ j\n        \\<in> (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n})) =\n       (i = j)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j x.\n       CHR ''a'' ^^^ i @ CHR ''b'' ^^^ j =\n       CHR ''a'' ^^^ x @ CHR ''b'' ^^^ x \\<Longrightarrow>\n       i = j", "apply(drule_tac f=\"\\<lambda>s. length (filter ((=) (CHR ''a'')) s) = length (filter ((=) (CHR ''b'')) s)\" \n      in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j x.\n       (length\n         (filter ((=) CHR ''a'') (CHR ''a'' ^^^ i @ CHR ''b'' ^^^ j)) =\n        length\n         (filter ((=) CHR ''b'') (CHR ''a'' ^^^ i @ CHR ''b'' ^^^ j))) =\n       (length\n         (filter ((=) CHR ''a'') (CHR ''a'' ^^^ x @ CHR ''b'' ^^^ x)) =\n        length\n         (filter ((=) CHR ''b'')\n           (CHR ''a'' ^^^ x @ CHR ''b'' ^^^ x))) \\<Longrightarrow>\n       i = j", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (CHR ''a'' ^^^ ?i @ CHR ''b'' ^^^ ?j \\<in> A) = (?i = ?j)\n\ngoal (1 subgoal):\n 1. regular\n     (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n}) \\<Longrightarrow>\n    False", "have b: \"infinite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite B", "unfolding infinite_iff_countable_subset"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. inj f \\<and> range f \\<subseteq> B", "unfolding inj_on_def B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (\\<forall>x\\<in>UNIV.\n           \\<forall>y\\<in>UNIV. f x = f y \\<longrightarrow> x = y) \\<and>\n       range f \\<subseteq> (\\<Union>n. {CHR ''a'' ^^^ n})", "by (rule_tac x=\"\\<lambda>n. CHR ''a'' ^^^ n\" in exI) (auto)"], ["proof (state)\nthis:\n  infinite B\n\ngoal (1 subgoal):\n 1. regular\n     (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n}) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  infinite B\n\ngoal (1 subgoal):\n 1. regular\n     (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n}) \\<Longrightarrow>\n    False", "have \"\\<forall>x \\<in> B. \\<forall>y \\<in> B. x \\<noteq> y \\<longrightarrow> \\<not> (x \\<approx>A y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>B.\n       \\<forall>y\\<in>B.\n          x \\<noteq> y \\<longrightarrow> (x, y) \\<notin> \\<approx>A", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> B; y \\<in> B; x \\<noteq> y; x \\<approx>A y\\<rbrakk>\n       \\<Longrightarrow> False", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>n. {CHR ''a'' ^^^ n});\n        y \\<in> (\\<Union>n. {CHR ''a'' ^^^ n}); x \\<noteq> y;\n        x \\<approx>A y\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>xa \\<noteq> xb;\n        CHR ''a'' ^^^ xa \\<approx>A CHR ''a'' ^^^ xb\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: str_eq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>xa \\<noteq> xb;\n        \\<forall>z.\n           (CHR ''a'' ^^^ xa @ z \\<in> A) =\n           (CHR ''a'' ^^^ xb @ z \\<in> A)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule_tac x=\"CHR ''b'' ^^^ xa\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>xa \\<noteq> xb;\n        (CHR ''a'' ^^^ xa @ CHR ''b'' ^^^ xa \\<in> A) =\n        (CHR ''a'' ^^^ xb @ CHR ''b'' ^^^ xa \\<in> A)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: sameness)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>x\\<in>B.\n     \\<forall>y\\<in>B.\n        x \\<noteq> y \\<longrightarrow> (x, y) \\<notin> \\<approx>A\n\ngoal (1 subgoal):\n 1. regular\n     (\\<Union>n. {CHR ''a'' ^^^ n @ CHR ''b'' ^^^ n}) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  infinite B\n  \\<forall>x\\<in>B.\n     \\<forall>y\\<in>B.\n        x \\<noteq> y \\<longrightarrow> (x, y) \\<notin> \\<approx>A", "show \"False\""], ["proof (prove)\nusing this:\n  infinite B\n  \\<forall>x\\<in>B.\n     \\<forall>y\\<in>B.\n        x \\<noteq> y \\<longrightarrow> (x, y) \\<notin> \\<approx>A\n\ngoal (1 subgoal):\n 1. False", "using continuation_lemma[OF as]"], ["proof (prove)\nusing this:\n  infinite B\n  \\<forall>x\\<in>B.\n     \\<forall>y\\<in>B.\n        x \\<noteq> y \\<longrightarrow> (x, y) \\<notin> \\<approx>A\n  infinite ?B \\<Longrightarrow>\n  \\<exists>x\\<in>?B. \\<exists>y\\<in>?B. x \\<noteq> y \\<and> x \\<approx>A y\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}