{"file_name": "/home/qj213/afp-2021-10-22/thys/Myhill-Nerode/Myhill_1.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Myhill-Nerode", "problem_names": ["lemma Pair_Collect [simp]:\n  shows \"(x, y) \\<in> {(x, y). P x y} \\<longleftrightarrow> P x y\"", "lemma str_eq_conv_Derivs:\n  \"str_eq A = {(u,v). Derivs u A = Derivs v A}\"", "lemma lang_is_union_of_finals: \n  shows \"A = \\<Union>(finals A)\"", "lemma finals_in_partitions:\n  shows \"finals A \\<subseteq> (UNIV // \\<approx>A)\"", "lemma lang_rhs_set:\n  shows \"lang_rhs {Trn X r | r. P r} = \\<Union>{lang_trm (Trn X r) | r. P r}\"", "lemma lang_rhs_union_distrib:\n  shows \"lang_rhs A \\<union> lang_rhs B = lang_rhs (A \\<union> B)\"", "lemma IterI2:\n  assumes \"(Y, yrhs) \\<in> ES\"\n  and     \"X \\<noteq> Y\"\n  and     \"\\<And>Y yrhs. \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk> \\<Longrightarrow> Q (Remove ES Y yrhs)\"\n  shows \"Q (Iter X ES)\"", "lemma finite_rhs_def2:\n  \"finite_rhs ES = (\\<forall> X rhs. (X, rhs) \\<in> ES \\<longrightarrow> finite rhs)\"", "lemma rhss_union_distrib:\n  shows \"rhss (A \\<union> B) = rhss A \\<union> rhss B\"", "lemma lhss_union_distrib:\n  shows \"lhss (A \\<union> B) = lhss A \\<union> lhss B\"", "lemma invariantI:\n  assumes \"soundness ES\" \"finite ES\" \"distinctness ES\" \"ardenable_all ES\" \n          \"finite_rhs ES\" \"validity ES\"\n  shows \"invariant ES\"", "lemma finite_Trn:\n  assumes fin: \"finite rhs\"\n  shows \"finite {r. Trn Y r \\<in> rhs}\"", "lemma finite_Lam:\n  assumes fin: \"finite rhs\"\n  shows \"finite {r. Lam r \\<in> rhs}\"", "lemma trm_soundness:\n  assumes finite:\"finite rhs\"\n  shows \"lang_rhs ({Trn X r| r. Trn X r \\<in> rhs}) = X \\<cdot> (lang (\\<Uplus>{r. Trn X r \\<in> rhs}))\"", "lemma lang_of_append_rexp:\n  \"lang_trm (Append_rexp r trm) = lang_trm trm \\<cdot> lang r\"", "lemma lang_of_append_rexp_rhs:\n  \"lang_rhs (Append_rexp_rhs rhs r) = lang_rhs rhs \\<cdot> lang r\"", "lemma defined_by_str:\n  assumes \"s \\<in> X\" \"X \\<in> UNIV // \\<approx>A\" \n  shows \"X = \\<approx>A `` {s}\"", "lemma every_eqclass_has_transition:\n  assumes has_str: \"s @ [c] \\<in> X\"\n  and     in_CS:   \"X \\<in> UNIV // \\<approx>A\"\n  obtains Y where \"Y \\<in> UNIV // \\<approx>A\" and \"Y \\<cdot> {[c]} \\<subseteq> X\" and \"s \\<in> Y\"", "lemma l_eq_r_in_eqs:\n  assumes X_in_eqs: \"(X, rhs) \\<in> Init (UNIV // \\<approx>A)\"\n  shows \"X = lang_rhs rhs\"", "lemma finite_Init_rhs: \n  fixes CS::\"(('a::finite) lang) set\"\n  assumes finite: \"finite CS\"\n  shows \"finite (Init_rhs CS X)\"", "lemma Init_ES_satisfies_invariant:\n  fixes A::\"(('a::finite) lang)\"\n  assumes finite_CS: \"finite (UNIV // \\<approx>A)\"\n  shows \"invariant (Init (UNIV // \\<approx>A))\"", "lemma Arden_preserves_soundness:\n  assumes l_eq_r: \"X = lang_rhs rhs\"\n  and not_empty: \"ardenable rhs\"\n  and finite: \"finite rhs\"\n  shows \"X = lang_rhs (Arden X rhs)\"", "lemma Append_preserves_finite:\n  \"finite rhs \\<Longrightarrow> finite (Append_rexp_rhs rhs r)\"", "lemma Arden_preserves_finite:\n  \"finite rhs \\<Longrightarrow> finite (Arden X rhs)\"", "lemma Append_preserves_ardenable:\n  \"ardenable rhs \\<Longrightarrow> ardenable (Append_rexp_rhs rhs r)\"", "lemma ardenable_set_sub:\n  \"ardenable rhs \\<Longrightarrow> ardenable (rhs - A)\"", "lemma ardenable_set_union:\n  \"\\<lbrakk>ardenable rhs; ardenable rhs'\\<rbrakk> \\<Longrightarrow> ardenable (rhs \\<union> rhs')\"", "lemma Arden_preserves_ardenable:\n  \"ardenable rhs \\<Longrightarrow> ardenable (Arden X rhs)\"", "lemma Subst_preserves_ardenable:\n  \"\\<lbrakk>ardenable rhs; ardenable xrhs\\<rbrakk> \\<Longrightarrow> ardenable (Subst rhs X xrhs)\"", "lemma Subst_preserves_soundness:\n  assumes substor: \"X = lang_rhs xrhs\"\n  and finite: \"finite rhs\"\n  shows \"lang_rhs (Subst rhs X xrhs) = lang_rhs rhs\" (is \"?Left = ?Right\")", "lemma Subst_preserves_finite_rhs:\n  \"\\<lbrakk>finite rhs; finite yrhs\\<rbrakk> \\<Longrightarrow> finite (Subst rhs Y yrhs)\"", "lemma Subst_all_preserves_finite:\n  assumes finite: \"finite ES\"\n  shows \"finite (Subst_all ES Y yrhs)\"", "lemma Subst_all_preserves_finite_rhs:\n  \"\\<lbrakk>finite_rhs ES; finite yrhs\\<rbrakk> \\<Longrightarrow> finite_rhs (Subst_all ES Y yrhs)\"", "lemma append_rhs_preserves_cls:\n  \"rhss (Append_rexp_rhs rhs r) = rhss rhs\"", "lemma Arden_removes_cl:\n  \"rhss (Arden Y yrhs) = rhss yrhs - {Y}\"", "lemma lhss_preserves_cls:\n  \"lhss (Subst_all ES Y yrhs) = lhss ES\"", "lemma Subst_updates_cls:\n  \"X \\<notin> rhss xrhs \\<Longrightarrow> \n      rhss (Subst rhs X xrhs) = rhss rhs \\<union> rhss xrhs - {X}\"", "lemma Subst_all_preserves_validity:\n  assumes sc: \"validity (ES \\<union> {(Y, yrhs)})\"        (is \"validity ?A\")\n  shows \"validity (Subst_all ES Y (Arden Y yrhs))\"  (is \"validity ?B\")", "lemma Subst_all_satisfies_invariant:\n  assumes invariant_ES: \"invariant (ES \\<union> {(Y, yrhs)})\"\n  shows \"invariant (Subst_all ES Y (Arden Y yrhs))\"", "lemma Remove_in_card_measure:\n  assumes finite: \"finite ES\"\n  and     in_ES: \"(X, rhs) \\<in> ES\"\n  shows \"(Remove ES X rhs, ES) \\<in> measure card\"", "lemma Subst_all_cls_remains: \n  \"(X, xrhs) \\<in> ES \\<Longrightarrow> \\<exists> xrhs'. (X, xrhs') \\<in> (Subst_all ES Y yrhs)\"", "lemma card_noteq_1_has_more:\n  assumes card:\"Cond ES\"\n  and e_in: \"(X, xrhs) \\<in> ES\"\n  and finite: \"finite ES\"\n  shows \"\\<exists>(Y, yrhs) \\<in> ES. (X, xrhs) \\<noteq> (Y, yrhs)\"", "lemma iteration_step_measure:\n  assumes Inv_ES: \"invariant ES\"\n  and    X_in_ES: \"(X, xrhs) \\<in> ES\"\n  and    Cnd:     \"Cond ES \"\n  shows \"(Iter X ES, ES) \\<in> measure card\"", "lemma iteration_step_invariant:\n  assumes Inv_ES: \"invariant ES\"\n  and    X_in_ES: \"(X, xrhs) \\<in> ES\"\n  and    Cnd: \"Cond ES\"\n  shows \"invariant (Iter X ES)\"", "lemma iteration_step_ex:\n  assumes Inv_ES: \"invariant ES\"\n  and    X_in_ES: \"(X, xrhs) \\<in> ES\"\n  and    Cnd: \"Cond ES\"\n  shows \"\\<exists>xrhs'. (X, xrhs') \\<in> (Iter X ES)\"", "lemma Solve:\n  fixes A::\"('a::finite) lang\"\n  assumes fin: \"finite (UNIV // \\<approx>A)\"\n  and     X_in: \"X \\<in> (UNIV // \\<approx>A)\"\n  shows \"\\<exists>rhs. Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and> invariant {(X, rhs)}\"", "lemma every_eqcl_has_reg:\n  fixes A::\"('a::finite) lang\"\n  assumes finite_CS: \"finite (UNIV // \\<approx>A)\"\n  and X_in_CS: \"X \\<in> (UNIV // \\<approx>A)\"\n  shows \"\\<exists>r. X = lang r\"", "lemma bchoice_finite_set:\n  assumes a: \"\\<forall>x \\<in> S. \\<exists>y. x = f y\" \n  and     b: \"finite S\"\n  shows \"\\<exists>ys. (\\<Union> S) = \\<Union>(f ` ys) \\<and> finite ys\"", "theorem Myhill_Nerode1:\n  fixes A::\"('a::finite) lang\"\n  assumes finite_CS: \"finite (UNIV // \\<approx>A)\"\n  shows   \"\\<exists>r. A = lang r\""], "translations": [["", "lemma Pair_Collect [simp]:\n  shows \"(x, y) \\<in> {(x, y). P x y} \\<longleftrightarrow> P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> {(x, y). P x y}) = P x y", "by simp"], ["", "text \\<open>Myhill-Nerode relation\\<close>"], ["", "definition\n  str_eq :: \"'a lang \\<Rightarrow> ('a list \\<times> 'a list) set\" (\"\\<approx>_\" [100] 100)\nwhere\n  \"\\<approx>A \\<equiv> {(x, y).  (\\<forall>z. x @ z \\<in> A \\<longleftrightarrow> y @ z \\<in> A)}\""], ["", "abbreviation\n  str_eq_applied :: \"'a list \\<Rightarrow> 'a lang \\<Rightarrow> 'a list \\<Rightarrow> bool\" (\"_ \\<approx>_ _\")\nwhere\n  \"x \\<approx>A y \\<equiv> (x, y) \\<in> \\<approx>A\""], ["", "lemma str_eq_conv_Derivs:\n  \"str_eq A = {(u,v). Derivs u A = Derivs v A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<approx>A = {(u, v). Derivs u A = Derivs v A}", "by (auto simp: str_eq_def Derivs_def)"], ["", "definition \n  finals :: \"'a lang \\<Rightarrow> 'a lang set\"\nwhere\n  \"finals A \\<equiv> {\\<approx>A `` {s} | s . s \\<in> A}\""], ["", "lemma lang_is_union_of_finals: \n  shows \"A = \\<Union>(finals A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = \\<Union> (finals A)", "unfolding finals_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = \\<Union> {\\<approx>A `` {s} |s. s \\<in> A}", "unfolding Image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = \\<Union> {{y. \\<exists>x\\<in>{s}. x \\<approx>A y} |s. s \\<in> A}", "unfolding str_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A =\n    \\<Union>\n     {{y. \\<exists>x\\<in>{s}.\n             (x, y)\n             \\<in> {(x, y).\n                    \\<forall>z. (x @ z \\<in> A) = (y @ z \\<in> A)}} |\n      s. s \\<in> A}", "by (auto) (metis append_Nil2)"], ["", "lemma finals_in_partitions:\n  shows \"finals A \\<subseteq> (UNIV // \\<approx>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finals A \\<subseteq> UNIV // \\<approx>A", "unfolding finals_def quotient_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<approx>A `` {s} |s. s \\<in> A}\n    \\<subseteq> (\\<Union>x. {\\<approx>A `` {x}})", "by auto"], ["", "subsection \\<open>Equational systems\\<close>"], ["", "text \\<open>The two kinds of terms in the rhs of equations.\\<close>"], ["", "datatype 'a trm = \n   Lam \"'a rexp\"            (* Lambda-marker *)\n | Trn \"'a lang\" \"'a rexp\""], ["", "(* Transition *)"], ["", "fun \n  lang_trm::\"'a trm \\<Rightarrow> 'a lang\"\nwhere\n  \"lang_trm (Lam r) = lang r\" \n| \"lang_trm (Trn X r) = X \\<cdot> lang r\""], ["", "fun \n  lang_rhs::\"('a trm) set \\<Rightarrow> 'a lang\"\nwhere \n  \"lang_rhs rhs = \\<Union> (lang_trm ` rhs)\""], ["", "lemma lang_rhs_set:\n  shows \"lang_rhs {Trn X r | r. P r} = \\<Union>{lang_trm (Trn X r) | r. P r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs {Trn X r |r. P r} = \\<Union> {lang_trm (Trn X r) |r. P r}", "by (auto)"], ["", "lemma lang_rhs_union_distrib:\n  shows \"lang_rhs A \\<union> lang_rhs B = lang_rhs (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs A \\<union> lang_rhs B = lang_rhs (A \\<union> B)", "by simp"], ["", "text \\<open>Transitions between equivalence classes\\<close>"], ["", "definition \n  transition :: \"'a lang \\<Rightarrow> 'a \\<Rightarrow> 'a lang \\<Rightarrow> bool\" (\"_ \\<Turnstile>_\\<Rightarrow>_\" [100,100,100] 100)\nwhere\n  \"Y \\<Turnstile>c\\<Rightarrow> X \\<equiv> Y \\<cdot> {[c]} \\<subseteq> X\""], ["", "text \\<open>Initial equational system\\<close>"], ["", "definition\n  \"Init_rhs CS X \\<equiv>  \n      if ([] \\<in> X) then \n          {Lam One} \\<union> {Trn Y (Atom c) | Y c. Y \\<in> CS \\<and> Y \\<Turnstile>c\\<Rightarrow> X}\n      else \n          {Trn Y (Atom c)| Y c. Y \\<in> CS \\<and> Y \\<Turnstile>c\\<Rightarrow> X}\""], ["", "definition \n  \"Init CS \\<equiv> {(X, Init_rhs CS X) | X.  X \\<in> CS}\""], ["", "subsection \\<open>Arden Operation on equations\\<close>"], ["", "fun \n  Append_rexp :: \"'a rexp \\<Rightarrow> 'a trm \\<Rightarrow> 'a trm\"\nwhere\n  \"Append_rexp r (Lam rexp)   = Lam (Times rexp r)\"\n| \"Append_rexp r (Trn X rexp) = Trn X (Times rexp r)\""], ["", "definition\n  \"Append_rexp_rhs rhs rexp \\<equiv> (Append_rexp rexp) ` rhs\""], ["", "definition \n  \"Arden X rhs \\<equiv> \n     Append_rexp_rhs (rhs - {Trn X r | r. Trn X r \\<in> rhs}) (Star (\\<Uplus> {r. Trn X r \\<in> rhs}))\""], ["", "subsection \\<open>Substitution Operation on equations\\<close>"], ["", "definition \n  \"Subst rhs X xrhs \\<equiv> \n        (rhs - {Trn X r | r. Trn X r \\<in> rhs}) \\<union> (Append_rexp_rhs xrhs (\\<Uplus> {r. Trn X r \\<in> rhs}))\""], ["", "definition\n  Subst_all :: \"('a lang \\<times> ('a trm) set) set \\<Rightarrow> 'a lang \\<Rightarrow> ('a trm) set \\<Rightarrow> ('a lang \\<times> ('a trm) set) set\"\nwhere\n  \"Subst_all ES X xrhs \\<equiv> {(Y, Subst yrhs X xrhs) | Y yrhs. (Y, yrhs) \\<in> ES}\""], ["", "definition\n  \"Remove ES X xrhs \\<equiv> \n      Subst_all  (ES - {(X, xrhs)}) X (Arden X xrhs)\""], ["", "subsection \\<open>While-combinator and invariants\\<close>"], ["", "definition \n  \"Iter X ES \\<equiv> (let (Y, yrhs) = SOME (Y, yrhs). (Y, yrhs) \\<in> ES \\<and> X \\<noteq> Y\n                in Remove ES Y yrhs)\""], ["", "lemma IterI2:\n  assumes \"(Y, yrhs) \\<in> ES\"\n  and     \"X \\<noteq> Y\"\n  and     \"\\<And>Y yrhs. \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk> \\<Longrightarrow> Q (Remove ES Y yrhs)\"\n  shows \"Q (Iter X ES)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (Iter X ES)", "unfolding Iter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (let (Y, yrhs) =\n             SOME (Y, yrhs). (Y, yrhs) \\<in> ES \\<and> X \\<noteq> Y\n       in Remove ES Y yrhs)", "using assms"], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y\n  \\<lbrakk>(?Y, ?yrhs) \\<in> ES; X \\<noteq> ?Y\\<rbrakk>\n  \\<Longrightarrow> Q (Remove ES ?Y ?yrhs)\n\ngoal (1 subgoal):\n 1. Q (let (Y, yrhs) =\n             SOME (Y, yrhs). (Y, yrhs) \\<in> ES \\<and> X \\<noteq> Y\n       in Remove ES Y yrhs)", "by (rule_tac a=\"(Y, yrhs)\" in someI2) (auto)"], ["", "abbreviation\n  \"Cond ES \\<equiv> card ES \\<noteq> 1\""], ["", "definition \n  \"Solve X ES \\<equiv> while Cond (Iter X) ES\""], ["", "definition \n  \"distinctness ES \\<equiv> \n     \\<forall> X rhs rhs'. (X, rhs) \\<in> ES \\<and> (X, rhs') \\<in> ES \\<longrightarrow> rhs = rhs'\""], ["", "definition \n  \"soundness ES \\<equiv> \\<forall>(X, rhs) \\<in> ES. X = lang_rhs rhs\""], ["", "definition \n  \"ardenable rhs \\<equiv> (\\<forall> Y r. Trn Y r \\<in> rhs \\<longrightarrow> [] \\<notin> lang r)\""], ["", "definition \n  \"ardenable_all ES \\<equiv> \\<forall>(X, rhs) \\<in> ES. ardenable rhs\""], ["", "definition\n  \"finite_rhs ES \\<equiv> \\<forall>(X, rhs) \\<in> ES. finite rhs\""], ["", "lemma finite_rhs_def2:\n  \"finite_rhs ES = (\\<forall> X rhs. (X, rhs) \\<in> ES \\<longrightarrow> finite rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_rhs ES =\n    (\\<forall>X rhs. (X, rhs) \\<in> ES \\<longrightarrow> finite rhs)", "unfolding finite_rhs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(X, rhs)\\<in>ES. finite rhs) =\n    (\\<forall>X rhs. (X, rhs) \\<in> ES \\<longrightarrow> finite rhs)", "by auto"], ["", "definition \n  \"rhss rhs \\<equiv> {X | X r. Trn X r \\<in> rhs}\""], ["", "definition\n  \"lhss ES \\<equiv> {Y | Y yrhs. (Y, yrhs) \\<in> ES}\""], ["", "definition \n  \"validity ES \\<equiv> \\<forall>(X, rhs) \\<in> ES. rhss rhs \\<subseteq> lhss ES\""], ["", "lemma rhss_union_distrib:\n  shows \"rhss (A \\<union> B) = rhss A \\<union> rhss B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhss (A \\<union> B) = rhss A \\<union> rhss B", "by (auto simp add: rhss_def)"], ["", "lemma lhss_union_distrib:\n  shows \"lhss (A \\<union> B) = lhss A \\<union> lhss B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhss (A \\<union> B) = lhss A \\<union> lhss B", "by (auto simp add: lhss_def)"], ["", "definition \n  \"invariant ES \\<equiv> finite ES\n                \\<and> finite_rhs ES\n                \\<and> soundness ES \n                \\<and> distinctness ES \n                \\<and> ardenable_all ES \n                \\<and> validity ES\""], ["", "lemma invariantI:\n  assumes \"soundness ES\" \"finite ES\" \"distinctness ES\" \"ardenable_all ES\" \n          \"finite_rhs ES\" \"validity ES\"\n  shows \"invariant ES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant ES", "using assms"], ["proof (prove)\nusing this:\n  soundness ES\n  finite ES\n  distinctness ES\n  ardenable_all ES\n  finite_rhs ES\n  validity ES\n\ngoal (1 subgoal):\n 1. invariant ES", "by (simp add: invariant_def)"], ["", "declare [[simproc add: finite_Collect]]"], ["", "lemma finite_Trn:\n  assumes fin: \"finite rhs\"\n  shows \"finite {r. Trn Y r \\<in> rhs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {r. Trn Y r \\<in> rhs}", "using assms"], ["proof (prove)\nusing this:\n  finite rhs\n\ngoal (1 subgoal):\n 1. finite {r. Trn Y r \\<in> rhs}", "by (auto intro!: finite_vimageI simp add: inj_on_def)"], ["", "lemma finite_Lam:\n  assumes fin: \"finite rhs\"\n  shows \"finite {r. Lam r \\<in> rhs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {r. Lam r \\<in> rhs}", "using assms"], ["proof (prove)\nusing this:\n  finite rhs\n\ngoal (1 subgoal):\n 1. finite {r. Lam r \\<in> rhs}", "by (auto intro!: finite_vimageI simp add: inj_on_def)"], ["", "lemma trm_soundness:\n  assumes finite:\"finite rhs\"\n  shows \"lang_rhs ({Trn X r| r. Trn X r \\<in> rhs}) = X \\<cdot> (lang (\\<Uplus>{r. Trn X r \\<in> rhs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs {Trn X r |r. Trn X r \\<in> rhs} =\n    X \\<cdot> lang (\\<Uplus>{r. Trn X r \\<in> rhs})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lang_rhs {Trn X r |r. Trn X r \\<in> rhs} =\n    X \\<cdot> lang (\\<Uplus>{r. Trn X r \\<in> rhs})", "have \"finite {r. Trn X r \\<in> rhs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {r. Trn X r \\<in> rhs}", "by (rule finite_Trn[OF finite])"], ["proof (state)\nthis:\n  finite {r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. lang_rhs {Trn X r |r. Trn X r \\<in> rhs} =\n    X \\<cdot> lang (\\<Uplus>{r. Trn X r \\<in> rhs})", "then"], ["proof (chain)\npicking this:\n  finite {r. Trn X r \\<in> rhs}", "show \"lang_rhs ({Trn X r| r. Trn X r \\<in> rhs}) = X \\<cdot> (lang (\\<Uplus>{r. Trn X r \\<in> rhs}))\""], ["proof (prove)\nusing this:\n  finite {r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. lang_rhs {Trn X r |r. Trn X r \\<in> rhs} =\n    X \\<cdot> lang (\\<Uplus>{r. Trn X r \\<in> rhs})", "by (simp only: lang_rhs_set lang_trm.simps) (auto simp add: conc_def)"], ["proof (state)\nthis:\n  lang_rhs {Trn X r |r. Trn X r \\<in> rhs} =\n  X \\<cdot> lang (\\<Uplus>{r. Trn X r \\<in> rhs})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lang_of_append_rexp:\n  \"lang_trm (Append_rexp r trm) = lang_trm trm \\<cdot> lang r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_trm (Append_rexp r trm) = lang_trm trm \\<cdot> lang r", "by (induct rule: Append_rexp.induct)\n   (auto simp add: conc_assoc)"], ["", "lemma lang_of_append_rexp_rhs:\n  \"lang_rhs (Append_rexp_rhs rhs r) = lang_rhs rhs \\<cdot> lang r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs (Append_rexp_rhs rhs r) = lang_rhs rhs \\<cdot> lang r", "unfolding Append_rexp_rhs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs (Append_rexp r ` rhs) = lang_rhs rhs \\<cdot> lang r", "by (auto simp add: conc_def lang_of_append_rexp)"], ["", "subsection \\<open>Intial Equational Systems\\<close>"], ["", "lemma defined_by_str:\n  assumes \"s \\<in> X\" \"X \\<in> UNIV // \\<approx>A\" \n  shows \"X = \\<approx>A `` {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = \\<approx>A `` {s}", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> X\n  X \\<in> UNIV // \\<approx>A\n\ngoal (1 subgoal):\n 1. X = \\<approx>A `` {s}", "unfolding quotient_def Image_def str_eq_def"], ["proof (prove)\nusing this:\n  s \\<in> X\n  X \\<in> (\\<Union>x.\n              {{y. \\<exists>x\\<in>{x}.\n                      (x, y)\n                      \\<in> {(x, y).\n                             \\<forall>z.\n                                (x @ z \\<in> A) = (y @ z \\<in> A)}}})\n\ngoal (1 subgoal):\n 1. X =\n    {y. \\<exists>x\\<in>{s}.\n           (x, y)\n           \\<in> {(x, y). \\<forall>z. (x @ z \\<in> A) = (y @ z \\<in> A)}}", "by auto"], ["", "lemma every_eqclass_has_transition:\n  assumes has_str: \"s @ [c] \\<in> X\"\n  and     in_CS:   \"X \\<in> UNIV // \\<approx>A\"\n  obtains Y where \"Y \\<in> UNIV // \\<approx>A\" and \"Y \\<cdot> {[c]} \\<subseteq> X\" and \"s \\<in> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define Y where \"Y = \\<approx>A `` {s}\""], ["proof (state)\nthis:\n  Y = \\<approx>A `` {s}\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"Y \\<in> UNIV // \\<approx>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<in> UNIV // \\<approx>A", "unfolding Y_def quotient_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<approx>A `` {s} \\<in> (\\<Union>x. {\\<approx>A `` {x}})", "by auto"], ["proof (state)\nthis:\n  Y \\<in> UNIV // \\<approx>A\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  Y \\<in> UNIV // \\<approx>A\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"X = \\<approx>A `` {s @ [c]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = \\<approx>A `` {s @ [c]}", "using has_str in_CS defined_by_str"], ["proof (prove)\nusing this:\n  s @ [c] \\<in> X\n  X \\<in> UNIV // \\<approx>A\n  \\<lbrakk>?s \\<in> ?X; ?X \\<in> UNIV // \\<approx>?A\\<rbrakk>\n  \\<Longrightarrow> ?X = \\<approx>?A `` {?s}\n\ngoal (1 subgoal):\n 1. X = \\<approx>A `` {s @ [c]}", "by blast"], ["proof (state)\nthis:\n  X = \\<approx>A `` {s @ [c]}\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  X = \\<approx>A `` {s @ [c]}", "have \"Y \\<cdot> {[c]} \\<subseteq> X\""], ["proof (prove)\nusing this:\n  X = \\<approx>A `` {s @ [c]}\n\ngoal (1 subgoal):\n 1. Y \\<cdot> {[c]} \\<subseteq> X", "unfolding Y_def Image_def conc_def"], ["proof (prove)\nusing this:\n  X = {y. \\<exists>x\\<in>{s @ [c]}. x \\<approx>A y}\n\ngoal (1 subgoal):\n 1. {xs @ ys |xs ys.\n     xs \\<in> {y. \\<exists>x\\<in>{s}. x \\<approx>A y} \\<and> ys \\<in> {[c]}}\n    \\<subseteq> X", "unfolding str_eq_def"], ["proof (prove)\nusing this:\n  X =\n  {y. \\<exists>x\\<in>{s @ [c]}.\n         (x, y)\n         \\<in> {(x, y). \\<forall>z. (x @ z \\<in> A) = (y @ z \\<in> A)}}\n\ngoal (1 subgoal):\n 1. {xs @ ys |xs ys.\n     xs \\<in> {y. \\<exists>x\\<in>{s}.\n                     (x, y)\n                     \\<in> {(x, y).\n                            \\<forall>z.\n                               (x @ z \\<in> A) = (y @ z \\<in> A)}} \\<and>\n     ys \\<in> {[c]}}\n    \\<subseteq> X", "by clarsimp"], ["proof (state)\nthis:\n  Y \\<cdot> {[c]} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  Y \\<cdot> {[c]} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"s \\<in> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> Y", "unfolding Y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> \\<approx>A `` {s}", "unfolding Image_def str_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {y. \\<exists>x\\<in>{s}.\n                   (x, y)\n                   \\<in> {(x, y).\n                          \\<forall>z. (x @ z \\<in> A) = (y @ z \\<in> A)}}", "by simp"], ["proof (state)\nthis:\n  s \\<in> Y\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  Y \\<in> UNIV // \\<approx>A\n  Y \\<cdot> {[c]} \\<subseteq> X\n  s \\<in> Y", "show thesis"], ["proof (prove)\nusing this:\n  Y \\<in> UNIV // \\<approx>A\n  Y \\<cdot> {[c]} \\<subseteq> X\n  s \\<in> Y\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  Y \\<in> UNIV // \\<approx>A\n  Y \\<cdot> {[c]} \\<subseteq> X\n  s \\<in> Y\n  \\<lbrakk>?Y \\<in> UNIV // \\<approx>A; ?Y \\<cdot> {[c]} \\<subseteq> X;\n   s \\<in> ?Y\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l_eq_r_in_eqs:\n  assumes X_in_eqs: \"(X, rhs) \\<in> Init (UNIV // \\<approx>A)\"\n  shows \"X = lang_rhs rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = lang_rhs rhs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. X \\<subseteq> lang_rhs rhs\n 2. lang_rhs rhs \\<subseteq> X", "show \"X \\<subseteq> lang_rhs rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> lang_rhs rhs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "assume in_X: \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "{"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "assume empty: \"x = []\""], ["proof (state)\nthis:\n  x = []\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "then"], ["proof (chain)\npicking this:\n  x = []", "have \"x \\<in> lang_rhs rhs\""], ["proof (prove)\nusing this:\n  x = []\n\ngoal (1 subgoal):\n 1. x \\<in> lang_rhs rhs", "using X_in_eqs in_X"], ["proof (prove)\nusing this:\n  x = []\n  (X, rhs) \\<in> Init (UNIV // \\<approx>A)\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> lang_rhs rhs", "unfolding Init_def Init_rhs_def"], ["proof (prove)\nusing this:\n  x = []\n  (X, rhs)\n  \\<in> {(X, if [] \\<in> X\n             then {Lam One} \\<union>\n                  {Trn Y (Atom c) |Y c.\n                   Y \\<in> UNIV // \\<approx>A \\<and>\n                   Y \\<Turnstile>c\\<Rightarrow>X}\n             else {Trn Y (Atom c) |Y c.\n                   Y \\<in> UNIV // \\<approx>A \\<and>\n                   Y \\<Turnstile>c\\<Rightarrow>X}) |\n         X. X \\<in> UNIV // \\<approx>A}\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> lang_rhs rhs", "by auto"], ["proof (state)\nthis:\n  x \\<in> lang_rhs rhs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "}"], ["proof (state)\nthis:\n  x = [] \\<Longrightarrow> x \\<in> lang_rhs rhs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "moreover"], ["proof (state)\nthis:\n  x = [] \\<Longrightarrow> x \\<in> lang_rhs rhs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "{"], ["proof (state)\nthis:\n  x = [] \\<Longrightarrow> x \\<in> lang_rhs rhs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "assume not_empty: \"x \\<noteq> []\""], ["proof (state)\nthis:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> []", "obtain s c where decom: \"x = s @ [c]\""], ["proof (prove)\nusing this:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>s c. x = s @ [c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rev_cases"], ["proof (prove)\nusing this:\n  x \\<noteq> []\n  \\<lbrakk>?xs = [] \\<Longrightarrow> ?P;\n   \\<And>ys y. ?xs = ys @ [y] \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>s c. x = s @ [c] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = s @ [c]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "have \"X \\<in> UNIV // \\<approx>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> UNIV // \\<approx>A", "using X_in_eqs"], ["proof (prove)\nusing this:\n  (X, rhs) \\<in> Init (UNIV // \\<approx>A)\n\ngoal (1 subgoal):\n 1. X \\<in> UNIV // \\<approx>A", "unfolding Init_def"], ["proof (prove)\nusing this:\n  (X, rhs)\n  \\<in> {(X, Init_rhs (UNIV // \\<approx>A) X) |X.\n         X \\<in> UNIV // \\<approx>A}\n\ngoal (1 subgoal):\n 1. X \\<in> UNIV // \\<approx>A", "by auto"], ["proof (state)\nthis:\n  X \\<in> UNIV // \\<approx>A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "then"], ["proof (chain)\npicking this:\n  X \\<in> UNIV // \\<approx>A", "obtain Y where \"Y \\<in> UNIV // \\<approx>A\" \"Y \\<cdot> {[c]} \\<subseteq> X\" \"s \\<in> Y\""], ["proof (prove)\nusing this:\n  X \\<in> UNIV // \\<approx>A\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using decom in_X every_eqclass_has_transition"], ["proof (prove)\nusing this:\n  X \\<in> UNIV // \\<approx>A\n  x = s @ [c]\n  x \\<in> X\n  \\<lbrakk>?s @ [?c] \\<in> ?X; ?X \\<in> UNIV // \\<approx>?A;\n   \\<And>Y.\n      \\<lbrakk>Y \\<in> UNIV // \\<approx>?A; Y \\<cdot> {[?c]} \\<subseteq> ?X;\n       ?s \\<in> Y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> UNIV // \\<approx>A; Y \\<cdot> {[c]} \\<subseteq> X;\n         s \\<in> Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  Y \\<in> UNIV // \\<approx>A\n  Y \\<cdot> {[c]} \\<subseteq> X\n  s \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "then"], ["proof (chain)\npicking this:\n  Y \\<in> UNIV // \\<approx>A\n  Y \\<cdot> {[c]} \\<subseteq> X\n  s \\<in> Y", "have \"x \\<in> lang_rhs {Trn Y (Atom c)| Y c. Y \\<in> UNIV // \\<approx>A \\<and> Y \\<Turnstile>c\\<Rightarrow> X}\""], ["proof (prove)\nusing this:\n  Y \\<in> UNIV // \\<approx>A\n  Y \\<cdot> {[c]} \\<subseteq> X\n  s \\<in> Y\n\ngoal (1 subgoal):\n 1. x \\<in> lang_rhs\n             {Trn Y (Atom c) |Y c.\n              Y \\<in> UNIV // \\<approx>A \\<and>\n              Y \\<Turnstile>c\\<Rightarrow>X}", "unfolding transition_def"], ["proof (prove)\nusing this:\n  Y \\<in> UNIV // \\<approx>A\n  Y \\<cdot> {[c]} \\<subseteq> X\n  s \\<in> Y\n\ngoal (1 subgoal):\n 1. x \\<in> lang_rhs\n             {Trn Y (Atom c) |Y c.\n              Y \\<in> UNIV // \\<approx>A \\<and>\n              Y \\<cdot> {[c]} \\<subseteq> X}", "using decom"], ["proof (prove)\nusing this:\n  Y \\<in> UNIV // \\<approx>A\n  Y \\<cdot> {[c]} \\<subseteq> X\n  s \\<in> Y\n  x = s @ [c]\n\ngoal (1 subgoal):\n 1. x \\<in> lang_rhs\n             {Trn Y (Atom c) |Y c.\n              Y \\<in> UNIV // \\<approx>A \\<and>\n              Y \\<cdot> {[c]} \\<subseteq> X}", "by (force simp add: conc_def)"], ["proof (state)\nthis:\n  x \\<in> lang_rhs\n           {Trn Y (Atom c) |Y c.\n            Y \\<in> UNIV // \\<approx>A \\<and> Y \\<Turnstile>c\\<Rightarrow>X}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "then"], ["proof (chain)\npicking this:\n  x \\<in> lang_rhs\n           {Trn Y (Atom c) |Y c.\n            Y \\<in> UNIV // \\<approx>A \\<and> Y \\<Turnstile>c\\<Rightarrow>X}", "have \"x \\<in> lang_rhs rhs\""], ["proof (prove)\nusing this:\n  x \\<in> lang_rhs\n           {Trn Y (Atom c) |Y c.\n            Y \\<in> UNIV // \\<approx>A \\<and> Y \\<Turnstile>c\\<Rightarrow>X}\n\ngoal (1 subgoal):\n 1. x \\<in> lang_rhs rhs", "using X_in_eqs in_X"], ["proof (prove)\nusing this:\n  x \\<in> lang_rhs\n           {Trn Y (Atom c) |Y c.\n            Y \\<in> UNIV // \\<approx>A \\<and> Y \\<Turnstile>c\\<Rightarrow>X}\n  (X, rhs) \\<in> Init (UNIV // \\<approx>A)\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> lang_rhs rhs", "unfolding Init_def Init_rhs_def"], ["proof (prove)\nusing this:\n  x \\<in> lang_rhs\n           {Trn Y (Atom c) |Y c.\n            Y \\<in> UNIV // \\<approx>A \\<and> Y \\<Turnstile>c\\<Rightarrow>X}\n  (X, rhs)\n  \\<in> {(X, if [] \\<in> X\n             then {Lam One} \\<union>\n                  {Trn Y (Atom c) |Y c.\n                   Y \\<in> UNIV // \\<approx>A \\<and>\n                   Y \\<Turnstile>c\\<Rightarrow>X}\n             else {Trn Y (Atom c) |Y c.\n                   Y \\<in> UNIV // \\<approx>A \\<and>\n                   Y \\<Turnstile>c\\<Rightarrow>X}) |\n         X. X \\<in> UNIV // \\<approx>A}\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> lang_rhs rhs", "by simp"], ["proof (state)\nthis:\n  x \\<in> lang_rhs rhs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "}"], ["proof (state)\nthis:\n  x \\<noteq> [] \\<Longrightarrow> x \\<in> lang_rhs rhs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> lang_rhs rhs", "ultimately"], ["proof (chain)\npicking this:\n  x = [] \\<Longrightarrow> x \\<in> lang_rhs rhs\n  x \\<noteq> [] \\<Longrightarrow> x \\<in> lang_rhs rhs", "show \"x \\<in> lang_rhs rhs\""], ["proof (prove)\nusing this:\n  x = [] \\<Longrightarrow> x \\<in> lang_rhs rhs\n  x \\<noteq> [] \\<Longrightarrow> x \\<in> lang_rhs rhs\n\ngoal (1 subgoal):\n 1. x \\<in> lang_rhs rhs", "by blast"], ["proof (state)\nthis:\n  x \\<in> lang_rhs rhs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X \\<subseteq> lang_rhs rhs\n\ngoal (1 subgoal):\n 1. lang_rhs rhs \\<subseteq> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lang_rhs rhs \\<subseteq> X", "show \"lang_rhs rhs \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs rhs \\<subseteq> X", "using X_in_eqs"], ["proof (prove)\nusing this:\n  (X, rhs) \\<in> Init (UNIV // \\<approx>A)\n\ngoal (1 subgoal):\n 1. lang_rhs rhs \\<subseteq> X", "unfolding Init_def Init_rhs_def transition_def"], ["proof (prove)\nusing this:\n  (X, rhs)\n  \\<in> {(X, if [] \\<in> X\n             then {Lam One} \\<union>\n                  {Trn Y (Atom c) |Y c.\n                   Y \\<in> UNIV // \\<approx>A \\<and>\n                   Y \\<cdot> {[c]} \\<subseteq> X}\n             else {Trn Y (Atom c) |Y c.\n                   Y \\<in> UNIV // \\<approx>A \\<and>\n                   Y \\<cdot> {[c]} \\<subseteq> X}) |\n         X. X \\<in> UNIV // \\<approx>A}\n\ngoal (1 subgoal):\n 1. lang_rhs rhs \\<subseteq> X", "by auto"], ["proof (state)\nthis:\n  lang_rhs rhs \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_Init_rhs: \n  fixes CS::\"(('a::finite) lang) set\"\n  assumes finite: \"finite CS\"\n  shows \"finite (Init_rhs CS X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Init_rhs CS X)", "using assms"], ["proof (prove)\nusing this:\n  finite CS\n\ngoal (1 subgoal):\n 1. finite (Init_rhs CS X)", "unfolding Init_rhs_def transition_def"], ["proof (prove)\nusing this:\n  finite CS\n\ngoal (1 subgoal):\n 1. finite\n     (if [] \\<in> X\n      then {Lam One} \\<union>\n           {Trn Y (Atom c) |Y c.\n            Y \\<in> CS \\<and> Y \\<cdot> {[c]} \\<subseteq> X}\n      else {Trn Y (Atom c) |Y c.\n            Y \\<in> CS \\<and> Y \\<cdot> {[c]} \\<subseteq> X})", "by simp"], ["", "lemma Init_ES_satisfies_invariant:\n  fixes A::\"(('a::finite) lang)\"\n  assumes finite_CS: \"finite (UNIV // \\<approx>A)\"\n  shows \"invariant (Init (UNIV // \\<approx>A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (Init (UNIV // \\<approx>A))", "proof (rule invariantI)"], ["proof (state)\ngoal (6 subgoals):\n 1. soundness (Init (UNIV // \\<approx>A))\n 2. finite (Init (UNIV // \\<approx>A))\n 3. distinctness (Init (UNIV // \\<approx>A))\n 4. ardenable_all (Init (UNIV // \\<approx>A))\n 5. finite_rhs (Init (UNIV // \\<approx>A))\n 6. validity (Init (UNIV // \\<approx>A))", "show \"soundness (Init (UNIV // \\<approx>A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. soundness (Init (UNIV // \\<approx>A))", "unfolding soundness_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(X, rhs)\\<in>Init (UNIV // \\<approx>A). X = lang_rhs rhs", "using l_eq_r_in_eqs"], ["proof (prove)\nusing this:\n  (?X, ?rhs) \\<in> Init (UNIV // \\<approx>?A) \\<Longrightarrow>\n  ?X = lang_rhs ?rhs\n\ngoal (1 subgoal):\n 1. \\<forall>(X, rhs)\\<in>Init (UNIV // \\<approx>A). X = lang_rhs rhs", "by auto"], ["proof (state)\nthis:\n  soundness (Init (UNIV // \\<approx>A))\n\ngoal (5 subgoals):\n 1. finite (Init (UNIV // \\<approx>A))\n 2. distinctness (Init (UNIV // \\<approx>A))\n 3. ardenable_all (Init (UNIV // \\<approx>A))\n 4. finite_rhs (Init (UNIV // \\<approx>A))\n 5. validity (Init (UNIV // \\<approx>A))", "show \"finite (Init (UNIV // \\<approx>A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Init (UNIV // \\<approx>A))", "using finite_CS"], ["proof (prove)\nusing this:\n  finite (UNIV // \\<approx>A)\n\ngoal (1 subgoal):\n 1. finite (Init (UNIV // \\<approx>A))", "unfolding Init_def"], ["proof (prove)\nusing this:\n  finite (UNIV // \\<approx>A)\n\ngoal (1 subgoal):\n 1. finite\n     {(X, Init_rhs (UNIV // \\<approx>A) X) |X. X \\<in> UNIV // \\<approx>A}", "by simp"], ["proof (state)\nthis:\n  finite (Init (UNIV // \\<approx>A))\n\ngoal (4 subgoals):\n 1. distinctness (Init (UNIV // \\<approx>A))\n 2. ardenable_all (Init (UNIV // \\<approx>A))\n 3. finite_rhs (Init (UNIV // \\<approx>A))\n 4. validity (Init (UNIV // \\<approx>A))", "show \"distinctness (Init (UNIV // \\<approx>A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinctness (Init (UNIV // \\<approx>A))", "unfolding distinctness_def Init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X rhs rhs'.\n       (X, rhs)\n       \\<in> {(X, Init_rhs (UNIV // \\<approx>A) X) |X.\n              X \\<in> UNIV // \\<approx>A} \\<and>\n       (X, rhs')\n       \\<in> {(X, Init_rhs (UNIV // \\<approx>A) X) |X.\n              X \\<in> UNIV // \\<approx>A} \\<longrightarrow>\n       rhs = rhs'", "by simp"], ["proof (state)\nthis:\n  distinctness (Init (UNIV // \\<approx>A))\n\ngoal (3 subgoals):\n 1. ardenable_all (Init (UNIV // \\<approx>A))\n 2. finite_rhs (Init (UNIV // \\<approx>A))\n 3. validity (Init (UNIV // \\<approx>A))", "show \"ardenable_all (Init (UNIV // \\<approx>A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ardenable_all (Init (UNIV // \\<approx>A))", "unfolding ardenable_all_def Init_def Init_rhs_def ardenable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(X, rhs)\n             \\<in>{(X, if [] \\<in> X\n                       then {Lam One} \\<union>\n                            {Trn Y (Atom c) |Y c.\n                             Y \\<in> UNIV // \\<approx>A \\<and>\n                             Y \\<Turnstile>c\\<Rightarrow>X}\n                       else {Trn Y (Atom c) |Y c.\n                             Y \\<in> UNIV // \\<approx>A \\<and>\n                             Y \\<Turnstile>c\\<Rightarrow>X}) |\n                   X. X \\<in> UNIV // \\<approx>A}.\n       \\<forall>Y r. Trn Y r \\<in> rhs \\<longrightarrow> [] \\<notin> lang r", "by auto"], ["proof (state)\nthis:\n  ardenable_all (Init (UNIV // \\<approx>A))\n\ngoal (2 subgoals):\n 1. finite_rhs (Init (UNIV // \\<approx>A))\n 2. validity (Init (UNIV // \\<approx>A))", "show \"finite_rhs (Init (UNIV // \\<approx>A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_rhs (Init (UNIV // \\<approx>A))", "using finite_Init_rhs[OF finite_CS]"], ["proof (prove)\nusing this:\n  finite (Init_rhs (UNIV // \\<approx>A) ?X)\n\ngoal (1 subgoal):\n 1. finite_rhs (Init (UNIV // \\<approx>A))", "unfolding finite_rhs_def Init_def"], ["proof (prove)\nusing this:\n  finite (Init_rhs (UNIV // \\<approx>A) ?X)\n\ngoal (1 subgoal):\n 1. \\<forall>(X, rhs)\n             \\<in>{(X, Init_rhs (UNIV // \\<approx>A) X) |X.\n                   X \\<in> UNIV // \\<approx>A}.\n       finite rhs", "by auto"], ["proof (state)\nthis:\n  finite_rhs (Init (UNIV // \\<approx>A))\n\ngoal (1 subgoal):\n 1. validity (Init (UNIV // \\<approx>A))", "show \"validity (Init (UNIV // \\<approx>A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validity (Init (UNIV // \\<approx>A))", "unfolding validity_def Init_def Init_rhs_def rhss_def lhss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(X, rhs)\n             \\<in>{(X, if [] \\<in> X\n                       then {Lam One} \\<union>\n                            {Trn Y (Atom c) |Y c.\n                             Y \\<in> UNIV // \\<approx>A \\<and>\n                             Y \\<Turnstile>c\\<Rightarrow>X}\n                       else {Trn Y (Atom c) |Y c.\n                             Y \\<in> UNIV // \\<approx>A \\<and>\n                             Y \\<Turnstile>c\\<Rightarrow>X}) |\n                   X. X \\<in> UNIV // \\<approx>A}.\n       {uu_. \\<exists>X r. uu_ = X \\<and> Trn X r \\<in> rhs}\n       \\<subseteq> {uu_.\n                    \\<exists>Y yrhs.\n                       uu_ = Y \\<and>\n                       (Y, yrhs)\n                       \\<in> {(X, if [] \\<in> X\n                                  then {Lam One} \\<union>\n {Trn Y (Atom c) |Y c.\n  Y \\<in> UNIV // \\<approx>A \\<and> Y \\<Turnstile>c\\<Rightarrow>X}\n                                  else {Trn Y (Atom c) |Y c.\n  Y \\<in> UNIV // \\<approx>A \\<and> Y \\<Turnstile>c\\<Rightarrow>X}) |\n                              X. X \\<in> UNIV // \\<approx>A}}", "by auto"], ["proof (state)\nthis:\n  validity (Init (UNIV // \\<approx>A))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Interations\\<close>"], ["", "lemma Arden_preserves_soundness:\n  assumes l_eq_r: \"X = lang_rhs rhs\"\n  and not_empty: \"ardenable rhs\"\n  and finite: \"finite rhs\"\n  shows \"X = lang_rhs (Arden X rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "define A where \"A = lang (\\<Uplus>{r. Trn X r \\<in> rhs})\""], ["proof (state)\nthis:\n  A = lang (\\<Uplus>{r. Trn X r \\<in> rhs})\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "define b where \"b = {Trn X r | r. Trn X r \\<in> rhs}\""], ["proof (state)\nthis:\n  b = {Trn X r |r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "define B where \"B = lang_rhs (rhs - b)\""], ["proof (state)\nthis:\n  B = lang_rhs (rhs - b)\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "have not_empty2: \"[] \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<notin> A", "using finite_Trn[OF finite] not_empty"], ["proof (prove)\nusing this:\n  finite {r. Trn ?Y r \\<in> rhs}\n  ardenable rhs\n\ngoal (1 subgoal):\n 1. [] \\<notin> A", "unfolding A_def ardenable_def"], ["proof (prove)\nusing this:\n  finite {r. Trn ?Y r \\<in> rhs}\n  \\<forall>Y r. Trn Y r \\<in> rhs \\<longrightarrow> [] \\<notin> lang r\n\ngoal (1 subgoal):\n 1. [] \\<notin> lang (\\<Uplus>{r. Trn X r \\<in> rhs})", "by simp"], ["proof (state)\nthis:\n  [] \\<notin> A\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "have \"X = lang_rhs rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = lang_rhs rhs", "using l_eq_r"], ["proof (prove)\nusing this:\n  X = lang_rhs rhs\n\ngoal (1 subgoal):\n 1. X = lang_rhs rhs", "by simp"], ["proof (state)\nthis:\n  X = lang_rhs rhs\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "also"], ["proof (state)\nthis:\n  X = lang_rhs rhs\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "have \"\\<dots> = lang_rhs (b \\<union> (rhs - b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs rhs = lang_rhs (b \\<union> (rhs - b))", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs rhs =\n    lang_rhs\n     ({Trn X r |r. Trn X r \\<in> rhs} \\<union>\n      (rhs - {Trn X r |r. Trn X r \\<in> rhs}))", "by auto"], ["proof (state)\nthis:\n  lang_rhs rhs = lang_rhs (b \\<union> (rhs - b))\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "also"], ["proof (state)\nthis:\n  lang_rhs rhs = lang_rhs (b \\<union> (rhs - b))\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "have \"\\<dots> = lang_rhs b \\<union> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs (b \\<union> (rhs - b)) = lang_rhs b \\<union> B", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs (b \\<union> (rhs - b)) = lang_rhs b \\<union> lang_rhs (rhs - b)", "by (simp only: lang_rhs_union_distrib)"], ["proof (state)\nthis:\n  lang_rhs (b \\<union> (rhs - b)) = lang_rhs b \\<union> B\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "also"], ["proof (state)\nthis:\n  lang_rhs (b \\<union> (rhs - b)) = lang_rhs b \\<union> B\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "have \"\\<dots> = X \\<cdot> A \\<union> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs b \\<union> B = X \\<cdot> A \\<union> B", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs {Trn X r |r. Trn X r \\<in> rhs} \\<union> B =\n    X \\<cdot> A \\<union> B", "unfolding trm_soundness[OF finite]"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<cdot> lang (\\<Uplus>{r. Trn X r \\<in> rhs}) \\<union> B =\n    X \\<cdot> A \\<union> B", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<cdot> lang (\\<Uplus>{r. Trn X r \\<in> rhs}) \\<union> B =\n    X \\<cdot> lang (\\<Uplus>{r. Trn X r \\<in> rhs}) \\<union> B", "by blast"], ["proof (state)\nthis:\n  lang_rhs b \\<union> B = X \\<cdot> A \\<union> B\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "finally"], ["proof (chain)\npicking this:\n  X = X \\<cdot> A \\<union> B", "have \"X = X \\<cdot> A \\<union> B\""], ["proof (prove)\nusing this:\n  X = X \\<cdot> A \\<union> B\n\ngoal (1 subgoal):\n 1. X = X \\<cdot> A \\<union> B", "."], ["proof (state)\nthis:\n  X = X \\<cdot> A \\<union> B\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "then"], ["proof (chain)\npicking this:\n  X = X \\<cdot> A \\<union> B", "have \"X = B \\<cdot> A\\<star>\""], ["proof (prove)\nusing this:\n  X = X \\<cdot> A \\<union> B\n\ngoal (1 subgoal):\n 1. X = B \\<cdot> A\\<star>", "by (simp add: reversed_Arden[OF not_empty2])"], ["proof (state)\nthis:\n  X = B \\<cdot> A\\<star>\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "also"], ["proof (state)\nthis:\n  X = B \\<cdot> A\\<star>\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "have \"\\<dots> = lang_rhs (Arden X rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<cdot> A\\<star> = lang_rhs (Arden X rhs)", "unfolding Arden_def A_def B_def b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs (rhs - {Trn X r |r. Trn X r \\<in> rhs}) \\<cdot>\n    lang (\\<Uplus>{r. Trn X r \\<in> rhs})\\<star> =\n    lang_rhs\n     (Append_rexp_rhs (rhs - {Trn X r |r. Trn X r \\<in> rhs})\n       (Star (\\<Uplus>{r. Trn X r \\<in> rhs})))", "by (simp only: lang_of_append_rexp_rhs lang.simps)"], ["proof (state)\nthis:\n  B \\<cdot> A\\<star> = lang_rhs (Arden X rhs)\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "finally"], ["proof (chain)\npicking this:\n  X = lang_rhs (Arden X rhs)", "show \"X = lang_rhs (Arden X rhs)\""], ["proof (prove)\nusing this:\n  X = lang_rhs (Arden X rhs)\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X rhs)", "by simp"], ["proof (state)\nthis:\n  X = lang_rhs (Arden X rhs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Append_preserves_finite:\n  \"finite rhs \\<Longrightarrow> finite (Append_rexp_rhs rhs r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite rhs \\<Longrightarrow> finite (Append_rexp_rhs rhs r)", "by (auto simp: Append_rexp_rhs_def)"], ["", "lemma Arden_preserves_finite:\n  \"finite rhs \\<Longrightarrow> finite (Arden X rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite rhs \\<Longrightarrow> finite (Arden X rhs)", "by (auto simp: Arden_def Append_preserves_finite)"], ["", "lemma Append_preserves_ardenable:\n  \"ardenable rhs \\<Longrightarrow> ardenable (Append_rexp_rhs rhs r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ardenable rhs \\<Longrightarrow> ardenable (Append_rexp_rhs rhs r)", "apply (auto simp: ardenable_def Append_rexp_rhs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y ra x.\n       \\<lbrakk>\\<forall>Y r.\n                   Trn Y r \\<in> rhs \\<longrightarrow> [] \\<notin> lang r;\n        Trn Y ra = Append_rexp r x; x \\<in> rhs; [] \\<in> lang ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (case_tac x, auto simp: conc_def)"], ["", "lemma ardenable_set_sub:\n  \"ardenable rhs \\<Longrightarrow> ardenable (rhs - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ardenable rhs \\<Longrightarrow> ardenable (rhs - A)", "by (auto simp:ardenable_def)"], ["", "lemma ardenable_set_union:\n  \"\\<lbrakk>ardenable rhs; ardenable rhs'\\<rbrakk> \\<Longrightarrow> ardenable (rhs \\<union> rhs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ardenable rhs; ardenable rhs'\\<rbrakk>\n    \\<Longrightarrow> ardenable (rhs \\<union> rhs')", "by (auto simp:ardenable_def)"], ["", "lemma Arden_preserves_ardenable:\n  \"ardenable rhs \\<Longrightarrow> ardenable (Arden X rhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ardenable rhs \\<Longrightarrow> ardenable (Arden X rhs)", "by (simp only:Arden_def Append_preserves_ardenable ardenable_set_sub)"], ["", "lemma Subst_preserves_ardenable:\n  \"\\<lbrakk>ardenable rhs; ardenable xrhs\\<rbrakk> \\<Longrightarrow> ardenable (Subst rhs X xrhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ardenable rhs; ardenable xrhs\\<rbrakk>\n    \\<Longrightarrow> ardenable (Subst rhs X xrhs)", "by (simp only: Subst_def Append_preserves_ardenable ardenable_set_union ardenable_set_sub)"], ["", "lemma Subst_preserves_soundness:\n  assumes substor: \"X = lang_rhs xrhs\"\n  and finite: \"finite rhs\"\n  shows \"lang_rhs (Subst rhs X xrhs) = lang_rhs rhs\" (is \"?Left = ?Right\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs (Subst rhs X xrhs) = lang_rhs rhs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lang_rhs (Subst rhs X xrhs) = lang_rhs rhs", "define A where \"A = lang_rhs (rhs - {Trn X r | r. Trn X r \\<in> rhs})\""], ["proof (state)\nthis:\n  A = lang_rhs (rhs - {Trn X r |r. Trn X r \\<in> rhs})\n\ngoal (1 subgoal):\n 1. lang_rhs (Subst rhs X xrhs) = lang_rhs rhs", "have \"?Left = A \\<union> lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs (Subst rhs X xrhs) =\n    A \\<union>\n    lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs}))", "unfolding Subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs\n     (rhs - {Trn X r |r. Trn X r \\<in> rhs} \\<union>\n      Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs})) =\n    A \\<union>\n    lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs}))", "unfolding lang_rhs_union_distrib[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs (rhs - {Trn X r |r. Trn X r \\<in> rhs}) \\<union>\n    lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs})) =\n    A \\<union>\n    lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs}))", "by (simp add: A_def)"], ["proof (state)\nthis:\n  lang_rhs (Subst rhs X xrhs) =\n  A \\<union>\n  lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs}))\n\ngoal (1 subgoal):\n 1. lang_rhs (Subst rhs X xrhs) = lang_rhs rhs", "moreover"], ["proof (state)\nthis:\n  lang_rhs (Subst rhs X xrhs) =\n  A \\<union>\n  lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs}))\n\ngoal (1 subgoal):\n 1. lang_rhs (Subst rhs X xrhs) = lang_rhs rhs", "have \"?Right = A \\<union> lang_rhs {Trn X r | r. Trn X r \\<in> rhs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs rhs = A \\<union> lang_rhs {Trn X r |r. Trn X r \\<in> rhs}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lang_rhs rhs = A \\<union> lang_rhs {Trn X r |r. Trn X r \\<in> rhs}", "have \"rhs = (rhs - {Trn X r | r. Trn X r \\<in> rhs}) \\<union> ({Trn X r | r. Trn X r \\<in> rhs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs =\n    rhs - {Trn X r |r. Trn X r \\<in> rhs} \\<union>\n    {Trn X r |r. Trn X r \\<in> rhs}", "by auto"], ["proof (state)\nthis:\n  rhs =\n  rhs - {Trn X r |r. Trn X r \\<in> rhs} \\<union>\n  {Trn X r |r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. lang_rhs rhs = A \\<union> lang_rhs {Trn X r |r. Trn X r \\<in> rhs}", "thus ?thesis"], ["proof (prove)\nusing this:\n  rhs =\n  rhs - {Trn X r |r. Trn X r \\<in> rhs} \\<union>\n  {Trn X r |r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. lang_rhs rhs = A \\<union> lang_rhs {Trn X r |r. Trn X r \\<in> rhs}", "unfolding A_def"], ["proof (prove)\nusing this:\n  rhs =\n  rhs - {Trn X r |r. Trn X r \\<in> rhs} \\<union>\n  {Trn X r |r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. lang_rhs rhs =\n    lang_rhs (rhs - {Trn X r |r. Trn X r \\<in> rhs}) \\<union>\n    lang_rhs {Trn X r |r. Trn X r \\<in> rhs}", "unfolding lang_rhs_union_distrib"], ["proof (prove)\nusing this:\n  rhs =\n  rhs - {Trn X r |r. Trn X r \\<in> rhs} \\<union>\n  {Trn X r |r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. lang_rhs rhs =\n    lang_rhs\n     (rhs - {Trn X r |r. Trn X r \\<in> rhs} \\<union>\n      {Trn X r |r. Trn X r \\<in> rhs})", "by simp"], ["proof (state)\nthis:\n  lang_rhs rhs = A \\<union> lang_rhs {Trn X r |r. Trn X r \\<in> rhs}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lang_rhs rhs = A \\<union> lang_rhs {Trn X r |r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. lang_rhs (Subst rhs X xrhs) = lang_rhs rhs", "moreover"], ["proof (state)\nthis:\n  lang_rhs rhs = A \\<union> lang_rhs {Trn X r |r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. lang_rhs (Subst rhs X xrhs) = lang_rhs rhs", "have \"lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs})) = lang_rhs {Trn X r | r. Trn X r \\<in> rhs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs})) =\n    lang_rhs {Trn X r |r. Trn X r \\<in> rhs}", "using finite substor"], ["proof (prove)\nusing this:\n  finite rhs\n  X = lang_rhs xrhs\n\ngoal (1 subgoal):\n 1. lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs})) =\n    lang_rhs {Trn X r |r. Trn X r \\<in> rhs}", "by (simp only: lang_of_append_rexp_rhs trm_soundness)"], ["proof (state)\nthis:\n  lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs})) =\n  lang_rhs {Trn X r |r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. lang_rhs (Subst rhs X xrhs) = lang_rhs rhs", "ultimately"], ["proof (chain)\npicking this:\n  lang_rhs (Subst rhs X xrhs) =\n  A \\<union>\n  lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs}))\n  lang_rhs rhs = A \\<union> lang_rhs {Trn X r |r. Trn X r \\<in> rhs}\n  lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs})) =\n  lang_rhs {Trn X r |r. Trn X r \\<in> rhs}", "show ?thesis"], ["proof (prove)\nusing this:\n  lang_rhs (Subst rhs X xrhs) =\n  A \\<union>\n  lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs}))\n  lang_rhs rhs = A \\<union> lang_rhs {Trn X r |r. Trn X r \\<in> rhs}\n  lang_rhs (Append_rexp_rhs xrhs (\\<Uplus>{r. Trn X r \\<in> rhs})) =\n  lang_rhs {Trn X r |r. Trn X r \\<in> rhs}\n\ngoal (1 subgoal):\n 1. lang_rhs (Subst rhs X xrhs) = lang_rhs rhs", "by simp"], ["proof (state)\nthis:\n  lang_rhs (Subst rhs X xrhs) = lang_rhs rhs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Subst_preserves_finite_rhs:\n  \"\\<lbrakk>finite rhs; finite yrhs\\<rbrakk> \\<Longrightarrow> finite (Subst rhs Y yrhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite rhs; finite yrhs\\<rbrakk>\n    \\<Longrightarrow> finite (Subst rhs Y yrhs)", "by (auto simp: Subst_def Append_preserves_finite)"], ["", "lemma Subst_all_preserves_finite:\n  assumes finite: \"finite ES\"\n  shows \"finite (Subst_all ES Y yrhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Subst_all ES Y yrhs)", "using assms"], ["proof (prove)\nusing this:\n  finite ES\n\ngoal (1 subgoal):\n 1. finite (Subst_all ES Y yrhs)", "unfolding Subst_all_def"], ["proof (prove)\nusing this:\n  finite ES\n\ngoal (1 subgoal):\n 1. finite {(Ya, Subst yrhsa Y yrhs) |Ya yrhsa. (Ya, yrhsa) \\<in> ES}", "by simp"], ["", "declare [[simproc del: finite_Collect]]"], ["", "lemma Subst_all_preserves_finite_rhs:\n  \"\\<lbrakk>finite_rhs ES; finite yrhs\\<rbrakk> \\<Longrightarrow> finite_rhs (Subst_all ES Y yrhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite_rhs ES; finite yrhs\\<rbrakk>\n    \\<Longrightarrow> finite_rhs (Subst_all ES Y yrhs)", "by (auto intro:Subst_preserves_finite_rhs simp add:Subst_all_def finite_rhs_def)"], ["", "lemma append_rhs_preserves_cls:\n  \"rhss (Append_rexp_rhs rhs r) = rhss rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhss (Append_rexp_rhs rhs r) = rhss rhs", "apply (auto simp: rhss_def Append_rexp_rhs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x ra xa.\n       \\<lbrakk>Trn x ra = Append_rexp r xa; xa \\<in> rhs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. Trn x r \\<in> rhs\n 2. \\<And>x ra.\n       Trn x ra \\<in> rhs \\<Longrightarrow>\n       \\<exists>ra. Trn x ra \\<in> Append_rexp r ` rhs", "apply (case_tac xa, auto simp: image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ra.\n       Trn x ra \\<in> rhs \\<Longrightarrow>\n       \\<exists>ra. \\<exists>xa\\<in>rhs. Trn x ra = Append_rexp r xa", "by (rule_tac x = \"Times ra r\" in exI, rule_tac x = \"Trn x ra\" in bexI, simp+)"], ["", "lemma Arden_removes_cl:\n  \"rhss (Arden Y yrhs) = rhss yrhs - {Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhss (Arden Y yrhs) = rhss yrhs - {Y}", "apply (simp add:Arden_def append_rhs_preserves_cls)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rhss (yrhs - {Trn Y r |r. Trn Y r \\<in> yrhs}) = rhss yrhs - {Y}", "by (auto simp: rhss_def)"], ["", "lemma lhss_preserves_cls:\n  \"lhss (Subst_all ES Y yrhs) = lhss ES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhss (Subst_all ES Y yrhs) = lhss ES", "by (auto simp: lhss_def Subst_all_def)"], ["", "lemma Subst_updates_cls:\n  \"X \\<notin> rhss xrhs \\<Longrightarrow> \n      rhss (Subst rhs X xrhs) = rhss rhs \\<union> rhss xrhs - {X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<notin> rhss xrhs \\<Longrightarrow>\n    rhss (Subst rhs X xrhs) = rhss rhs \\<union> rhss xrhs - {X}", "apply (simp only:Subst_def append_rhs_preserves_cls rhss_union_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<notin> rhss xrhs \\<Longrightarrow>\n    rhss (rhs - {Trn X r |r. Trn X r \\<in> rhs}) \\<union> rhss xrhs =\n    rhss rhs \\<union> rhss xrhs - {X}", "by (auto simp: rhss_def)"], ["", "lemma Subst_all_preserves_validity:\n  assumes sc: \"validity (ES \\<union> {(Y, yrhs)})\"        (is \"validity ?A\")\n  shows \"validity (Subst_all ES Y (Arden Y yrhs))\"  (is \"validity ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "fix X xrhs'"], ["proof (state)\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "assume \"(X, xrhs') \\<in> ?B\""], ["proof (state)\nthis:\n  (X, xrhs') \\<in> Subst_all ES Y (Arden Y yrhs)\n\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "then"], ["proof (chain)\npicking this:\n  (X, xrhs') \\<in> Subst_all ES Y (Arden Y yrhs)", "obtain xrhs \n      where xrhs_xrhs': \"xrhs' = Subst xrhs Y (Arden Y yrhs)\"\n      and X_in: \"(X, xrhs) \\<in> ES\""], ["proof (prove)\nusing this:\n  (X, xrhs') \\<in> Subst_all ES Y (Arden Y yrhs)\n\ngoal (1 subgoal):\n 1. (\\<And>xrhs.\n        \\<lbrakk>xrhs' = Subst xrhs Y (Arden Y yrhs);\n         (X, xrhs) \\<in> ES\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add:Subst_all_def, blast)"], ["proof (state)\nthis:\n  xrhs' = Subst xrhs Y (Arden Y yrhs)\n  (X, xrhs) \\<in> ES\n\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "have \"rhss xrhs' \\<subseteq> lhss ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss (Subst_all ES Y (Arden Y yrhs))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss (Subst_all ES Y (Arden Y yrhs))", "have \"lhss ?B = lhss ES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhss (Subst_all ES Y (Arden Y yrhs)) = lhss ES", "by (auto simp add:lhss_def Subst_all_def)"], ["proof (state)\nthis:\n  lhss (Subst_all ES Y (Arden Y yrhs)) = lhss ES\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss (Subst_all ES Y (Arden Y yrhs))", "moreover"], ["proof (state)\nthis:\n  lhss (Subst_all ES Y (Arden Y yrhs)) = lhss ES\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss (Subst_all ES Y (Arden Y yrhs))", "have \"rhss xrhs' \\<subseteq> lhss ES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss ES", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss ES", "have \"rhss xrhs' \\<subseteq>  rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}", "have \"Y \\<notin> rhss (Arden Y yrhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<notin> rhss (Arden Y yrhs)", "using Arden_removes_cl"], ["proof (prove)\nusing this:\n  rhss (Arden ?Y ?yrhs) = rhss ?yrhs - {?Y}\n\ngoal (1 subgoal):\n 1. Y \\<notin> rhss (Arden Y yrhs)", "by auto"], ["proof (state)\nthis:\n  Y \\<notin> rhss (Arden Y yrhs)\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}", "thus ?thesis"], ["proof (prove)\nusing this:\n  Y \\<notin> rhss (Arden Y yrhs)\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}", "using xrhs_xrhs'"], ["proof (prove)\nusing this:\n  Y \\<notin> rhss (Arden Y yrhs)\n  xrhs' = Subst xrhs Y (Arden Y yrhs)\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}", "by (auto simp: Subst_updates_cls)"], ["proof (state)\nthis:\n  rhss xrhs' \\<subseteq> rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rhss xrhs' \\<subseteq> rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss ES", "moreover"], ["proof (state)\nthis:\n  rhss xrhs' \\<subseteq> rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss ES", "have \"rhss xrhs \\<subseteq> lhss ES \\<union> {Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhss xrhs \\<subseteq> lhss ES \\<union> {Y}", "using X_in sc"], ["proof (prove)\nusing this:\n  (X, xrhs) \\<in> ES\n  validity (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. rhss xrhs \\<subseteq> lhss ES \\<union> {Y}", "apply (simp only:validity_def lhss_union_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(X, xrhs) \\<in> ES;\n     \\<forall>(X, rhs)\\<in>ES \\<union> {(Y, yrhs)}.\n        rhss rhs \\<subseteq> lhss ES \\<union> lhss {(Y, yrhs)}\\<rbrakk>\n    \\<Longrightarrow> rhss xrhs \\<subseteq> lhss ES \\<union> {Y}", "by (drule_tac x = \"(X, xrhs)\" in bspec, auto simp:lhss_def)"], ["proof (state)\nthis:\n  rhss xrhs \\<subseteq> lhss ES \\<union> {Y}\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss ES", "moreover"], ["proof (state)\nthis:\n  rhss xrhs \\<subseteq> lhss ES \\<union> {Y}\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss ES", "have \"rhss (Arden Y yrhs) \\<subseteq> lhss ES \\<union> {Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhss (Arden Y yrhs) \\<subseteq> lhss ES \\<union> {Y}", "using sc"], ["proof (prove)\nusing this:\n  validity (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. rhss (Arden Y yrhs) \\<subseteq> lhss ES \\<union> {Y}", "by (auto simp add: Arden_removes_cl validity_def lhss_def)"], ["proof (state)\nthis:\n  rhss (Arden Y yrhs) \\<subseteq> lhss ES \\<union> {Y}\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss ES", "ultimately"], ["proof (chain)\npicking this:\n  rhss xrhs' \\<subseteq> rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}\n  rhss xrhs \\<subseteq> lhss ES \\<union> {Y}\n  rhss (Arden Y yrhs) \\<subseteq> lhss ES \\<union> {Y}", "show ?thesis"], ["proof (prove)\nusing this:\n  rhss xrhs' \\<subseteq> rhss xrhs \\<union> rhss (Arden Y yrhs) - {Y}\n  rhss xrhs \\<subseteq> lhss ES \\<union> {Y}\n  rhss (Arden Y yrhs) \\<subseteq> lhss ES \\<union> {Y}\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss ES", "by auto"], ["proof (state)\nthis:\n  rhss xrhs' \\<subseteq> lhss ES\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rhss xrhs' \\<subseteq> lhss ES\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss (Subst_all ES Y (Arden Y yrhs))", "ultimately"], ["proof (chain)\npicking this:\n  lhss (Subst_all ES Y (Arden Y yrhs)) = lhss ES\n  rhss xrhs' \\<subseteq> lhss ES", "show ?thesis"], ["proof (prove)\nusing this:\n  lhss (Subst_all ES Y (Arden Y yrhs)) = lhss ES\n  rhss xrhs' \\<subseteq> lhss ES\n\ngoal (1 subgoal):\n 1. rhss xrhs' \\<subseteq> lhss (Subst_all ES Y (Arden Y yrhs))", "by simp"], ["proof (state)\nthis:\n  rhss xrhs' \\<subseteq> lhss (Subst_all ES Y (Arden Y yrhs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rhss xrhs' \\<subseteq> lhss (Subst_all ES Y (Arden Y yrhs))\n\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "}"], ["proof (state)\nthis:\n  (?X2, ?xrhs'2) \\<in> Subst_all ES Y (Arden Y yrhs) \\<Longrightarrow>\n  rhss ?xrhs'2 \\<subseteq> lhss (Subst_all ES Y (Arden Y yrhs))\n\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?X2, ?xrhs'2) \\<in> Subst_all ES Y (Arden Y yrhs) \\<Longrightarrow>\n  rhss ?xrhs'2 \\<subseteq> lhss (Subst_all ES Y (Arden Y yrhs))\n\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "by (auto simp only:Subst_all_def validity_def)"], ["proof (state)\nthis:\n  validity (Subst_all ES Y (Arden Y yrhs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Subst_all_satisfies_invariant:\n  assumes invariant_ES: \"invariant (ES \\<union> {(Y, yrhs)})\"\n  shows \"invariant (Subst_all ES Y (Arden Y yrhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (Subst_all ES Y (Arden Y yrhs))", "proof (rule invariantI)"], ["proof (state)\ngoal (6 subgoals):\n 1. soundness (Subst_all ES Y (Arden Y yrhs))\n 2. finite (Subst_all ES Y (Arden Y yrhs))\n 3. distinctness (Subst_all ES Y (Arden Y yrhs))\n 4. ardenable_all (Subst_all ES Y (Arden Y yrhs))\n 5. finite_rhs (Subst_all ES Y (Arden Y yrhs))\n 6. validity (Subst_all ES Y (Arden Y yrhs))", "have Y_eq_yrhs: \"Y = lang_rhs yrhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y = lang_rhs yrhs", "using invariant_ES"], ["proof (prove)\nusing this:\n  invariant (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. Y = lang_rhs yrhs", "by (simp only:invariant_def soundness_def, blast)"], ["proof (state)\nthis:\n  Y = lang_rhs yrhs\n\ngoal (6 subgoals):\n 1. soundness (Subst_all ES Y (Arden Y yrhs))\n 2. finite (Subst_all ES Y (Arden Y yrhs))\n 3. distinctness (Subst_all ES Y (Arden Y yrhs))\n 4. ardenable_all (Subst_all ES Y (Arden Y yrhs))\n 5. finite_rhs (Subst_all ES Y (Arden Y yrhs))\n 6. validity (Subst_all ES Y (Arden Y yrhs))", "have finite_yrhs: \"finite yrhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite yrhs", "using invariant_ES"], ["proof (prove)\nusing this:\n  invariant (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. finite yrhs", "by (auto simp:invariant_def finite_rhs_def)"], ["proof (state)\nthis:\n  finite yrhs\n\ngoal (6 subgoals):\n 1. soundness (Subst_all ES Y (Arden Y yrhs))\n 2. finite (Subst_all ES Y (Arden Y yrhs))\n 3. distinctness (Subst_all ES Y (Arden Y yrhs))\n 4. ardenable_all (Subst_all ES Y (Arden Y yrhs))\n 5. finite_rhs (Subst_all ES Y (Arden Y yrhs))\n 6. validity (Subst_all ES Y (Arden Y yrhs))", "have ardenable_yrhs: \"ardenable yrhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ardenable yrhs", "using invariant_ES"], ["proof (prove)\nusing this:\n  invariant (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. ardenable yrhs", "by (auto simp:invariant_def ardenable_all_def)"], ["proof (state)\nthis:\n  ardenable yrhs\n\ngoal (6 subgoals):\n 1. soundness (Subst_all ES Y (Arden Y yrhs))\n 2. finite (Subst_all ES Y (Arden Y yrhs))\n 3. distinctness (Subst_all ES Y (Arden Y yrhs))\n 4. ardenable_all (Subst_all ES Y (Arden Y yrhs))\n 5. finite_rhs (Subst_all ES Y (Arden Y yrhs))\n 6. validity (Subst_all ES Y (Arden Y yrhs))", "show \"soundness (Subst_all ES Y (Arden Y yrhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. soundness (Subst_all ES Y (Arden Y yrhs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. soundness (Subst_all ES Y (Arden Y yrhs))", "have \"Y = lang_rhs (Arden Y yrhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y = lang_rhs (Arden Y yrhs)", "using Y_eq_yrhs invariant_ES finite_yrhs"], ["proof (prove)\nusing this:\n  Y = lang_rhs yrhs\n  invariant (ES \\<union> {(Y, yrhs)})\n  finite yrhs\n\ngoal (1 subgoal):\n 1. Y = lang_rhs (Arden Y yrhs)", "using finite_Trn[OF finite_yrhs]"], ["proof (prove)\nusing this:\n  Y = lang_rhs yrhs\n  invariant (ES \\<union> {(Y, yrhs)})\n  finite yrhs\n  finite {r. Trn ?Y r \\<in> yrhs}\n\ngoal (1 subgoal):\n 1. Y = lang_rhs (Arden Y yrhs)", "apply(rule_tac Arden_preserves_soundness)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Y = lang_rhs yrhs; invariant (ES \\<union> {(Y, yrhs)});\n     finite yrhs; \\<And>Y. finite {r. Trn Y r \\<in> yrhs}\\<rbrakk>\n    \\<Longrightarrow> Y = lang_rhs yrhs\n 2. \\<lbrakk>Y = lang_rhs yrhs; invariant (ES \\<union> {(Y, yrhs)});\n     finite yrhs; \\<And>Y. finite {r. Trn Y r \\<in> yrhs}\\<rbrakk>\n    \\<Longrightarrow> ardenable yrhs\n 3. \\<lbrakk>Y = lang_rhs yrhs; invariant (ES \\<union> {(Y, yrhs)});\n     finite yrhs; \\<And>Y. finite {r. Trn Y r \\<in> yrhs}\\<rbrakk>\n    \\<Longrightarrow> finite yrhs", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Y = \\<Union> (lang_trm ` yrhs);\n     invariant (insert (\\<Union> (lang_trm ` yrhs), yrhs) ES); finite yrhs;\n     \\<And>Y. finite {r. Trn Y r \\<in> yrhs}\\<rbrakk>\n    \\<Longrightarrow> ardenable yrhs", "unfolding invariant_def ardenable_all_def ardenable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Y = \\<Union> (lang_trm ` yrhs);\n     finite (insert (\\<Union> (lang_trm ` yrhs), yrhs) ES) \\<and>\n     finite_rhs (insert (\\<Union> (lang_trm ` yrhs), yrhs) ES) \\<and>\n     soundness (insert (\\<Union> (lang_trm ` yrhs), yrhs) ES) \\<and>\n     distinctness (insert (\\<Union> (lang_trm ` yrhs), yrhs) ES) \\<and>\n     (\\<forall>(X, rhs)\\<in>insert (\\<Union> (lang_trm ` yrhs), yrhs) ES.\n         \\<forall>Y r.\n            Trn Y r \\<in> rhs \\<longrightarrow> [] \\<notin> lang r) \\<and>\n     validity (insert (\\<Union> (lang_trm ` yrhs), yrhs) ES);\n     finite yrhs; \\<And>Y. finite {r. Trn Y r \\<in> yrhs}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>Y r.\n                         Trn Y r \\<in> yrhs \\<longrightarrow>\n                         [] \\<notin> lang r", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Y = lang_rhs (Arden Y yrhs)\n\ngoal (1 subgoal):\n 1. soundness (Subst_all ES Y (Arden Y yrhs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Y = lang_rhs (Arden Y yrhs)\n\ngoal (1 subgoal):\n 1. soundness (Subst_all ES Y (Arden Y yrhs))", "using invariant_ES"], ["proof (prove)\nusing this:\n  Y = lang_rhs (Arden Y yrhs)\n  invariant (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. soundness (Subst_all ES Y (Arden Y yrhs))", "unfolding invariant_def finite_rhs_def2 soundness_def Subst_all_def"], ["proof (prove)\nusing this:\n  Y = lang_rhs (Arden Y yrhs)\n  finite (ES \\<union> {(Y, yrhs)}) \\<and>\n  (\\<forall>X rhs.\n      (X, rhs) \\<in> ES \\<union> {(Y, yrhs)} \\<longrightarrow>\n      finite rhs) \\<and>\n  (\\<forall>(X, rhs)\\<in>ES \\<union> {(Y, yrhs)}. X = lang_rhs rhs) \\<and>\n  distinctness (ES \\<union> {(Y, yrhs)}) \\<and>\n  ardenable_all (ES \\<union> {(Y, yrhs)}) \\<and>\n  validity (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. \\<forall>(X, rhs)\n             \\<in>{(Ya, Subst yrhsa Y (Arden Y yrhs)) |Ya yrhsa.\n                   (Ya, yrhsa) \\<in> ES}.\n       X = lang_rhs rhs", "by (auto simp add: Subst_preserves_soundness simp del: lang_rhs.simps)"], ["proof (state)\nthis:\n  soundness (Subst_all ES Y (Arden Y yrhs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  soundness (Subst_all ES Y (Arden Y yrhs))\n\ngoal (5 subgoals):\n 1. finite (Subst_all ES Y (Arden Y yrhs))\n 2. distinctness (Subst_all ES Y (Arden Y yrhs))\n 3. ardenable_all (Subst_all ES Y (Arden Y yrhs))\n 4. finite_rhs (Subst_all ES Y (Arden Y yrhs))\n 5. validity (Subst_all ES Y (Arden Y yrhs))", "show \"finite (Subst_all ES Y (Arden Y yrhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Subst_all ES Y (Arden Y yrhs))", "using invariant_ES"], ["proof (prove)\nusing this:\n  invariant (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. finite (Subst_all ES Y (Arden Y yrhs))", "by (simp add:invariant_def Subst_all_preserves_finite)"], ["proof (state)\nthis:\n  finite (Subst_all ES Y (Arden Y yrhs))\n\ngoal (4 subgoals):\n 1. distinctness (Subst_all ES Y (Arden Y yrhs))\n 2. ardenable_all (Subst_all ES Y (Arden Y yrhs))\n 3. finite_rhs (Subst_all ES Y (Arden Y yrhs))\n 4. validity (Subst_all ES Y (Arden Y yrhs))", "show \"distinctness (Subst_all ES Y (Arden Y yrhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinctness (Subst_all ES Y (Arden Y yrhs))", "using invariant_ES"], ["proof (prove)\nusing this:\n  invariant (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. distinctness (Subst_all ES Y (Arden Y yrhs))", "unfolding distinctness_def Subst_all_def invariant_def"], ["proof (prove)\nusing this:\n  finite (ES \\<union> {(Y, yrhs)}) \\<and>\n  finite_rhs (ES \\<union> {(Y, yrhs)}) \\<and>\n  soundness (ES \\<union> {(Y, yrhs)}) \\<and>\n  (\\<forall>X rhs rhs'.\n      (X, rhs) \\<in> ES \\<union> {(Y, yrhs)} \\<and>\n      (X, rhs') \\<in> ES \\<union> {(Y, yrhs)} \\<longrightarrow>\n      rhs = rhs') \\<and>\n  ardenable_all (ES \\<union> {(Y, yrhs)}) \\<and>\n  validity (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. \\<forall>X rhs rhs'.\n       (X, rhs)\n       \\<in> {(Ya, Subst yrhsa Y (Arden Y yrhs)) |Ya yrhsa.\n              (Ya, yrhsa) \\<in> ES} \\<and>\n       (X, rhs')\n       \\<in> {(Ya, Subst yrhsa Y (Arden Y yrhs)) |Ya yrhsa.\n              (Ya, yrhsa) \\<in> ES} \\<longrightarrow>\n       rhs = rhs'", "by auto"], ["proof (state)\nthis:\n  distinctness (Subst_all ES Y (Arden Y yrhs))\n\ngoal (3 subgoals):\n 1. ardenable_all (Subst_all ES Y (Arden Y yrhs))\n 2. finite_rhs (Subst_all ES Y (Arden Y yrhs))\n 3. validity (Subst_all ES Y (Arden Y yrhs))", "show \"ardenable_all (Subst_all ES Y (Arden Y yrhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ardenable_all (Subst_all ES Y (Arden Y yrhs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ardenable_all (Subst_all ES Y (Arden Y yrhs))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ardenable_all (Subst_all ES Y (Arden Y yrhs))", "fix X rhs"], ["proof (state)\ngoal (1 subgoal):\n 1. ardenable_all (Subst_all ES Y (Arden Y yrhs))", "assume \"(X, rhs) \\<in> ES\""], ["proof (state)\nthis:\n  (X, rhs) \\<in> ES\n\ngoal (1 subgoal):\n 1. ardenable_all (Subst_all ES Y (Arden Y yrhs))", "hence \"ardenable rhs\""], ["proof (prove)\nusing this:\n  (X, rhs) \\<in> ES\n\ngoal (1 subgoal):\n 1. ardenable rhs", "using invariant_ES"], ["proof (prove)\nusing this:\n  (X, rhs) \\<in> ES\n  invariant (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. ardenable rhs", "by (auto simp add:invariant_def ardenable_all_def)"], ["proof (state)\nthis:\n  ardenable rhs\n\ngoal (1 subgoal):\n 1. ardenable_all (Subst_all ES Y (Arden Y yrhs))", "with ardenable_yrhs"], ["proof (chain)\npicking this:\n  ardenable yrhs\n  ardenable rhs", "have \"ardenable (Subst rhs Y (Arden Y yrhs))\""], ["proof (prove)\nusing this:\n  ardenable yrhs\n  ardenable rhs\n\ngoal (1 subgoal):\n 1. ardenable (Subst rhs Y (Arden Y yrhs))", "by (simp add:ardenable_yrhs \n               Subst_preserves_ardenable Arden_preserves_ardenable)"], ["proof (state)\nthis:\n  ardenable (Subst rhs Y (Arden Y yrhs))\n\ngoal (1 subgoal):\n 1. ardenable_all (Subst_all ES Y (Arden Y yrhs))", "}"], ["proof (state)\nthis:\n  (?X2, ?rhs2) \\<in> ES \\<Longrightarrow>\n  ardenable (Subst ?rhs2 Y (Arden Y yrhs))\n\ngoal (1 subgoal):\n 1. ardenable_all (Subst_all ES Y (Arden Y yrhs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?X2, ?rhs2) \\<in> ES \\<Longrightarrow>\n  ardenable (Subst ?rhs2 Y (Arden Y yrhs))\n\ngoal (1 subgoal):\n 1. ardenable_all (Subst_all ES Y (Arden Y yrhs))", "by (auto simp add:ardenable_all_def Subst_all_def)"], ["proof (state)\nthis:\n  ardenable_all (Subst_all ES Y (Arden Y yrhs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ardenable_all (Subst_all ES Y (Arden Y yrhs))\n\ngoal (2 subgoals):\n 1. finite_rhs (Subst_all ES Y (Arden Y yrhs))\n 2. validity (Subst_all ES Y (Arden Y yrhs))", "show \"finite_rhs (Subst_all ES Y (Arden Y yrhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_rhs (Subst_all ES Y (Arden Y yrhs))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_rhs (Subst_all ES Y (Arden Y yrhs))", "have \"finite_rhs ES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_rhs ES", "using invariant_ES"], ["proof (prove)\nusing this:\n  invariant (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. finite_rhs ES", "by (simp add:invariant_def finite_rhs_def)"], ["proof (state)\nthis:\n  finite_rhs ES\n\ngoal (1 subgoal):\n 1. finite_rhs (Subst_all ES Y (Arden Y yrhs))", "moreover"], ["proof (state)\nthis:\n  finite_rhs ES\n\ngoal (1 subgoal):\n 1. finite_rhs (Subst_all ES Y (Arden Y yrhs))", "have \"finite (Arden Y yrhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Arden Y yrhs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Arden Y yrhs)", "have \"finite yrhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite yrhs", "using invariant_ES"], ["proof (prove)\nusing this:\n  invariant (ES \\<union> {(Y, yrhs)})\n\ngoal (1 subgoal):\n 1. finite yrhs", "by (auto simp:invariant_def finite_rhs_def)"], ["proof (state)\nthis:\n  finite yrhs\n\ngoal (1 subgoal):\n 1. finite (Arden Y yrhs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite yrhs\n\ngoal (1 subgoal):\n 1. finite (Arden Y yrhs)", "using Arden_preserves_finite"], ["proof (prove)\nusing this:\n  finite yrhs\n  finite ?rhs \\<Longrightarrow> finite (Arden ?X ?rhs)\n\ngoal (1 subgoal):\n 1. finite (Arden Y yrhs)", "by auto"], ["proof (state)\nthis:\n  finite (Arden Y yrhs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (Arden Y yrhs)\n\ngoal (1 subgoal):\n 1. finite_rhs (Subst_all ES Y (Arden Y yrhs))", "ultimately"], ["proof (chain)\npicking this:\n  finite_rhs ES\n  finite (Arden Y yrhs)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_rhs ES\n  finite (Arden Y yrhs)\n\ngoal (1 subgoal):\n 1. finite_rhs (Subst_all ES Y (Arden Y yrhs))", "by (simp add:Subst_all_preserves_finite_rhs)"], ["proof (state)\nthis:\n  finite_rhs (Subst_all ES Y (Arden Y yrhs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_rhs (Subst_all ES Y (Arden Y yrhs))\n\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "show \"validity (Subst_all ES Y (Arden Y yrhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "using invariant_ES Subst_all_preserves_validity"], ["proof (prove)\nusing this:\n  invariant (ES \\<union> {(Y, yrhs)})\n  validity (?ES \\<union> {(?Y, ?yrhs)}) \\<Longrightarrow>\n  validity (Subst_all ?ES ?Y (Arden ?Y ?yrhs))\n\ngoal (1 subgoal):\n 1. validity (Subst_all ES Y (Arden Y yrhs))", "by (auto simp add: invariant_def)"], ["proof (state)\nthis:\n  validity (Subst_all ES Y (Arden Y yrhs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Remove_in_card_measure:\n  assumes finite: \"finite ES\"\n  and     in_ES: \"(X, rhs) \\<in> ES\"\n  shows \"(Remove ES X rhs, ES) \\<in> measure card\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Remove ES X rhs, ES) \\<in> measure card", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Remove ES X rhs, ES) \\<in> measure card", "define f where \"f x = ((fst x)::'a lang, Subst (snd x) X (Arden X rhs))\" for x"], ["proof (state)\nthis:\n  f ?x = (fst ?x, Subst (snd ?x) X (Arden X rhs))\n\ngoal (1 subgoal):\n 1. (Remove ES X rhs, ES) \\<in> measure card", "define ES' where \"ES' = ES - {(X, rhs)}\""], ["proof (state)\nthis:\n  ES' = ES - {(X, rhs)}\n\ngoal (1 subgoal):\n 1. (Remove ES X rhs, ES) \\<in> measure card", "have \"Subst_all ES' X (Arden X rhs) = f ` ES'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subst_all ES' X (Arden X rhs) = f ` ES'", "apply (auto simp: Subst_all_def f_def image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y yrhs.\n       (Y, yrhs) \\<in> ES' \\<Longrightarrow>\n       \\<exists>x\\<in>ES'.\n          Y = fst x \\<and>\n          Subst yrhs X (Arden X rhs) = Subst (snd x) X (Arden X rhs)", "by (rule_tac x = \"(Y, yrhs)\" in bexI, simp+)"], ["proof (state)\nthis:\n  Subst_all ES' X (Arden X rhs) = f ` ES'\n\ngoal (1 subgoal):\n 1. (Remove ES X rhs, ES) \\<in> measure card", "then"], ["proof (chain)\npicking this:\n  Subst_all ES' X (Arden X rhs) = f ` ES'", "have \"card (Subst_all ES' X (Arden X rhs)) \\<le> card ES'\""], ["proof (prove)\nusing this:\n  Subst_all ES' X (Arden X rhs) = f ` ES'\n\ngoal (1 subgoal):\n 1. card (Subst_all ES' X (Arden X rhs)) \\<le> card ES'", "unfolding ES'_def"], ["proof (prove)\nusing this:\n  Subst_all (ES - {(X, rhs)}) X (Arden X rhs) = f ` (ES - {(X, rhs)})\n\ngoal (1 subgoal):\n 1. card (Subst_all (ES - {(X, rhs)}) X (Arden X rhs))\n    \\<le> card (ES - {(X, rhs)})", "using finite"], ["proof (prove)\nusing this:\n  Subst_all (ES - {(X, rhs)}) X (Arden X rhs) = f ` (ES - {(X, rhs)})\n  finite ES\n\ngoal (1 subgoal):\n 1. card (Subst_all (ES - {(X, rhs)}) X (Arden X rhs))\n    \\<le> card (ES - {(X, rhs)})", "by (auto intro: card_image_le)"], ["proof (state)\nthis:\n  card (Subst_all ES' X (Arden X rhs)) \\<le> card ES'\n\ngoal (1 subgoal):\n 1. (Remove ES X rhs, ES) \\<in> measure card", "also"], ["proof (state)\nthis:\n  card (Subst_all ES' X (Arden X rhs)) \\<le> card ES'\n\ngoal (1 subgoal):\n 1. (Remove ES X rhs, ES) \\<in> measure card", "have \"\\<dots> < card ES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ES' < card ES", "unfolding ES'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (ES - {(X, rhs)}) < card ES", "using in_ES finite"], ["proof (prove)\nusing this:\n  (X, rhs) \\<in> ES\n  finite ES\n\ngoal (1 subgoal):\n 1. card (ES - {(X, rhs)}) < card ES", "by (rule_tac card_Diff1_less)"], ["proof (state)\nthis:\n  card ES' < card ES\n\ngoal (1 subgoal):\n 1. (Remove ES X rhs, ES) \\<in> measure card", "finally"], ["proof (chain)\npicking this:\n  card (Subst_all ES' X (Arden X rhs)) < card ES", "show \"(Remove ES X rhs, ES) \\<in> measure card\""], ["proof (prove)\nusing this:\n  card (Subst_all ES' X (Arden X rhs)) < card ES\n\ngoal (1 subgoal):\n 1. (Remove ES X rhs, ES) \\<in> measure card", "unfolding Remove_def ES'_def"], ["proof (prove)\nusing this:\n  card (Subst_all (ES - {(X, rhs)}) X (Arden X rhs)) < card ES\n\ngoal (1 subgoal):\n 1. (Subst_all (ES - {(X, rhs)}) X (Arden X rhs), ES) \\<in> measure card", "by simp"], ["proof (state)\nthis:\n  (Remove ES X rhs, ES) \\<in> measure card\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Subst_all_cls_remains: \n  \"(X, xrhs) \\<in> ES \\<Longrightarrow> \\<exists> xrhs'. (X, xrhs') \\<in> (Subst_all ES Y yrhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X, xrhs) \\<in> ES \\<Longrightarrow>\n    \\<exists>xrhs'. (X, xrhs') \\<in> Subst_all ES Y yrhs", "by (auto simp: Subst_all_def)"], ["", "lemma card_noteq_1_has_more:\n  assumes card:\"Cond ES\"\n  and e_in: \"(X, xrhs) \\<in> ES\"\n  and finite: \"finite ES\"\n  shows \"\\<exists>(Y, yrhs) \\<in> ES. (X, xrhs) \\<noteq> (Y, yrhs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(Y, yrhs)\\<in>ES. (X, xrhs) \\<noteq> (Y, yrhs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>(Y, yrhs)\\<in>ES. (X, xrhs) \\<noteq> (Y, yrhs)", "have \"card ES > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < card ES", "using card e_in finite"], ["proof (prove)\nusing this:\n  Cond ES\n  (X, xrhs) \\<in> ES\n  finite ES\n\ngoal (1 subgoal):\n 1. 1 < card ES", "by (cases \"card ES\") (auto)"], ["proof (state)\nthis:\n  1 < card ES\n\ngoal (1 subgoal):\n 1. \\<exists>(Y, yrhs)\\<in>ES. (X, xrhs) \\<noteq> (Y, yrhs)", "then"], ["proof (chain)\npicking this:\n  1 < card ES", "have \"card (ES - {(X, xrhs)}) > 0\""], ["proof (prove)\nusing this:\n  1 < card ES\n\ngoal (1 subgoal):\n 1. 0 < card (ES - {(X, xrhs)})", "using finite e_in"], ["proof (prove)\nusing this:\n  1 < card ES\n  finite ES\n  (X, xrhs) \\<in> ES\n\ngoal (1 subgoal):\n 1. 0 < card (ES - {(X, xrhs)})", "by auto"], ["proof (state)\nthis:\n  0 < card (ES - {(X, xrhs)})\n\ngoal (1 subgoal):\n 1. \\<exists>(Y, yrhs)\\<in>ES. (X, xrhs) \\<noteq> (Y, yrhs)", "then"], ["proof (chain)\npicking this:\n  0 < card (ES - {(X, xrhs)})", "have \"(ES - {(X, xrhs)}) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  0 < card (ES - {(X, xrhs)})\n\ngoal (1 subgoal):\n 1. ES - {(X, xrhs)} \\<noteq> {}", "using finite"], ["proof (prove)\nusing this:\n  0 < card (ES - {(X, xrhs)})\n  finite ES\n\ngoal (1 subgoal):\n 1. ES - {(X, xrhs)} \\<noteq> {}", "by (rule_tac notI, simp)"], ["proof (state)\nthis:\n  ES - {(X, xrhs)} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>(Y, yrhs)\\<in>ES. (X, xrhs) \\<noteq> (Y, yrhs)", "then"], ["proof (chain)\npicking this:\n  ES - {(X, xrhs)} \\<noteq> {}", "show \"\\<exists>(Y, yrhs) \\<in> ES. (X, xrhs) \\<noteq> (Y, yrhs)\""], ["proof (prove)\nusing this:\n  ES - {(X, xrhs)} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>(Y, yrhs)\\<in>ES. (X, xrhs) \\<noteq> (Y, yrhs)", "by auto"], ["proof (state)\nthis:\n  \\<exists>(Y, yrhs)\\<in>ES. (X, xrhs) \\<noteq> (Y, yrhs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iteration_step_measure:\n  assumes Inv_ES: \"invariant ES\"\n  and    X_in_ES: \"(X, xrhs) \\<in> ES\"\n  and    Cnd:     \"Cond ES \"\n  shows \"(Iter X ES, ES) \\<in> measure card\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Iter X ES, ES) \\<in> measure card", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Iter X ES, ES) \\<in> measure card", "have fin: \"finite ES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ES", "using Inv_ES"], ["proof (prove)\nusing this:\n  invariant ES\n\ngoal (1 subgoal):\n 1. finite ES", "unfolding invariant_def"], ["proof (prove)\nusing this:\n  finite ES \\<and>\n  finite_rhs ES \\<and>\n  soundness ES \\<and>\n  distinctness ES \\<and> ardenable_all ES \\<and> validity ES\n\ngoal (1 subgoal):\n 1. finite ES", "by simp"], ["proof (state)\nthis:\n  finite ES\n\ngoal (1 subgoal):\n 1. (Iter X ES, ES) \\<in> measure card", "then"], ["proof (chain)\npicking this:\n  finite ES", "obtain Y yrhs \n    where Y_in_ES: \"(Y, yrhs) \\<in> ES\" and not_eq: \"(X, xrhs) \\<noteq> (Y, yrhs)\""], ["proof (prove)\nusing this:\n  finite ES\n\ngoal (1 subgoal):\n 1. (\\<And>Y yrhs.\n        \\<lbrakk>(Y, yrhs) \\<in> ES; (X, xrhs) \\<noteq> (Y, yrhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cnd X_in_ES"], ["proof (prove)\nusing this:\n  finite ES\n  Cond ES\n  (X, xrhs) \\<in> ES\n\ngoal (1 subgoal):\n 1. (\\<And>Y yrhs.\n        \\<lbrakk>(Y, yrhs) \\<in> ES; (X, xrhs) \\<noteq> (Y, yrhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (drule_tac card_noteq_1_has_more) (auto)"], ["proof (state)\nthis:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n\ngoal (1 subgoal):\n 1. (Iter X ES, ES) \\<in> measure card", "then"], ["proof (chain)\npicking this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)", "have \"(Y, yrhs) \\<in> ES \" \"X \\<noteq> Y\""], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n\ngoal (1 subgoal):\n 1. (Y, yrhs) \\<in> ES &&& X \\<noteq> Y", "using X_in_ES Inv_ES"], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n  (X, xrhs) \\<in> ES\n  invariant ES\n\ngoal (1 subgoal):\n 1. (Y, yrhs) \\<in> ES &&& X \\<noteq> Y", "unfolding invariant_def distinctness_def"], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n  (X, xrhs) \\<in> ES\n  finite ES \\<and>\n  finite_rhs ES \\<and>\n  soundness ES \\<and>\n  (\\<forall>X rhs rhs'.\n      (X, rhs) \\<in> ES \\<and> (X, rhs') \\<in> ES \\<longrightarrow>\n      rhs = rhs') \\<and>\n  ardenable_all ES \\<and> validity ES\n\ngoal (1 subgoal):\n 1. (Y, yrhs) \\<in> ES &&& X \\<noteq> Y", "by auto"], ["proof (state)\nthis:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y\n\ngoal (1 subgoal):\n 1. (Iter X ES, ES) \\<in> measure card", "then"], ["proof (chain)\npicking this:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y", "show \"(Iter X ES, ES) \\<in> measure card\""], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y\n\ngoal (1 subgoal):\n 1. (Iter X ES, ES) \\<in> measure card", "apply(rule IterI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> (Remove ES Y yrhs, ES) \\<in> measure card", "apply(rule Remove_in_card_measure)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> finite ES\n 2. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> (Y, yrhs) \\<in> ES", "apply(simp_all add: fin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (Iter X ES, ES) \\<in> measure card\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iteration_step_invariant:\n  assumes Inv_ES: \"invariant ES\"\n  and    X_in_ES: \"(X, xrhs) \\<in> ES\"\n  and    Cnd: \"Cond ES\"\n  shows \"invariant (Iter X ES)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (Iter X ES)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant (Iter X ES)", "have finite_ES: \"finite ES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ES", "using Inv_ES"], ["proof (prove)\nusing this:\n  invariant ES\n\ngoal (1 subgoal):\n 1. finite ES", "by (simp add: invariant_def)"], ["proof (state)\nthis:\n  finite ES\n\ngoal (1 subgoal):\n 1. invariant (Iter X ES)", "then"], ["proof (chain)\npicking this:\n  finite ES", "obtain Y yrhs \n    where Y_in_ES: \"(Y, yrhs) \\<in> ES\" and not_eq: \"(X, xrhs) \\<noteq> (Y, yrhs)\""], ["proof (prove)\nusing this:\n  finite ES\n\ngoal (1 subgoal):\n 1. (\\<And>Y yrhs.\n        \\<lbrakk>(Y, yrhs) \\<in> ES; (X, xrhs) \\<noteq> (Y, yrhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cnd X_in_ES"], ["proof (prove)\nusing this:\n  finite ES\n  Cond ES\n  (X, xrhs) \\<in> ES\n\ngoal (1 subgoal):\n 1. (\\<And>Y yrhs.\n        \\<lbrakk>(Y, yrhs) \\<in> ES; (X, xrhs) \\<noteq> (Y, yrhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (drule_tac card_noteq_1_has_more) (auto)"], ["proof (state)\nthis:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n\ngoal (1 subgoal):\n 1. invariant (Iter X ES)", "then"], ["proof (chain)\npicking this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)", "have \"(Y, yrhs) \\<in> ES\" \"X \\<noteq> Y\""], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n\ngoal (1 subgoal):\n 1. (Y, yrhs) \\<in> ES &&& X \\<noteq> Y", "using X_in_ES Inv_ES"], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n  (X, xrhs) \\<in> ES\n  invariant ES\n\ngoal (1 subgoal):\n 1. (Y, yrhs) \\<in> ES &&& X \\<noteq> Y", "unfolding invariant_def distinctness_def"], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n  (X, xrhs) \\<in> ES\n  finite ES \\<and>\n  finite_rhs ES \\<and>\n  soundness ES \\<and>\n  (\\<forall>X rhs rhs'.\n      (X, rhs) \\<in> ES \\<and> (X, rhs') \\<in> ES \\<longrightarrow>\n      rhs = rhs') \\<and>\n  ardenable_all ES \\<and> validity ES\n\ngoal (1 subgoal):\n 1. (Y, yrhs) \\<in> ES &&& X \\<noteq> Y", "by auto"], ["proof (state)\nthis:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y\n\ngoal (1 subgoal):\n 1. invariant (Iter X ES)", "then"], ["proof (chain)\npicking this:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y", "show \"invariant (Iter X ES)\""], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y\n\ngoal (1 subgoal):\n 1. invariant (Iter X ES)", "proof(rule IterI2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> invariant (Remove ES Y yrhs)", "fix Y yrhs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> invariant (Remove ES Y yrhs)", "assume h: \"(Y, yrhs) \\<in> ES\" \"X \\<noteq> Y\""], ["proof (state)\nthis:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y\n\ngoal (1 subgoal):\n 1. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> invariant (Remove ES Y yrhs)", "then"], ["proof (chain)\npicking this:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y", "have \"ES - {(Y, yrhs)} \\<union> {(Y, yrhs)} = ES\""], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y\n\ngoal (1 subgoal):\n 1. ES - {(Y, yrhs)} \\<union> {(Y, yrhs)} = ES", "by auto"], ["proof (state)\nthis:\n  ES - {(Y, yrhs)} \\<union> {(Y, yrhs)} = ES\n\ngoal (1 subgoal):\n 1. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> invariant (Remove ES Y yrhs)", "then"], ["proof (chain)\npicking this:\n  ES - {(Y, yrhs)} \\<union> {(Y, yrhs)} = ES", "show \"invariant (Remove ES Y yrhs)\""], ["proof (prove)\nusing this:\n  ES - {(Y, yrhs)} \\<union> {(Y, yrhs)} = ES\n\ngoal (1 subgoal):\n 1. invariant (Remove ES Y yrhs)", "unfolding Remove_def"], ["proof (prove)\nusing this:\n  ES - {(Y, yrhs)} \\<union> {(Y, yrhs)} = ES\n\ngoal (1 subgoal):\n 1. invariant (Subst_all (ES - {(Y, yrhs)}) Y (Arden Y yrhs))", "using Inv_ES"], ["proof (prove)\nusing this:\n  ES - {(Y, yrhs)} \\<union> {(Y, yrhs)} = ES\n  invariant ES\n\ngoal (1 subgoal):\n 1. invariant (Subst_all (ES - {(Y, yrhs)}) Y (Arden Y yrhs))", "by (rule_tac Subst_all_satisfies_invariant) (simp)"], ["proof (state)\nthis:\n  invariant (Remove ES Y yrhs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant (Iter X ES)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iteration_step_ex:\n  assumes Inv_ES: \"invariant ES\"\n  and    X_in_ES: \"(X, xrhs) \\<in> ES\"\n  and    Cnd: \"Cond ES\"\n  shows \"\\<exists>xrhs'. (X, xrhs') \\<in> (Iter X ES)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xrhs'. (X, xrhs') \\<in> Iter X ES", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xrhs'. (X, xrhs') \\<in> Iter X ES", "have finite_ES: \"finite ES\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ES", "using Inv_ES"], ["proof (prove)\nusing this:\n  invariant ES\n\ngoal (1 subgoal):\n 1. finite ES", "by (simp add: invariant_def)"], ["proof (state)\nthis:\n  finite ES\n\ngoal (1 subgoal):\n 1. \\<exists>xrhs'. (X, xrhs') \\<in> Iter X ES", "then"], ["proof (chain)\npicking this:\n  finite ES", "obtain Y yrhs \n    where \"(Y, yrhs) \\<in> ES\" \"(X, xrhs) \\<noteq> (Y, yrhs)\""], ["proof (prove)\nusing this:\n  finite ES\n\ngoal (1 subgoal):\n 1. (\\<And>Y yrhs.\n        \\<lbrakk>(Y, yrhs) \\<in> ES; (X, xrhs) \\<noteq> (Y, yrhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cnd X_in_ES"], ["proof (prove)\nusing this:\n  finite ES\n  Cond ES\n  (X, xrhs) \\<in> ES\n\ngoal (1 subgoal):\n 1. (\\<And>Y yrhs.\n        \\<lbrakk>(Y, yrhs) \\<in> ES; (X, xrhs) \\<noteq> (Y, yrhs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (drule_tac card_noteq_1_has_more) (auto)"], ["proof (state)\nthis:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n\ngoal (1 subgoal):\n 1. \\<exists>xrhs'. (X, xrhs') \\<in> Iter X ES", "then"], ["proof (chain)\npicking this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)", "have \"(Y, yrhs) \\<in> ES \" \"X \\<noteq> Y\""], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n\ngoal (1 subgoal):\n 1. (Y, yrhs) \\<in> ES &&& X \\<noteq> Y", "using X_in_ES Inv_ES"], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n  (X, xrhs) \\<in> ES\n  invariant ES\n\ngoal (1 subgoal):\n 1. (Y, yrhs) \\<in> ES &&& X \\<noteq> Y", "unfolding invariant_def distinctness_def"], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  (X, xrhs) \\<noteq> (Y, yrhs)\n  (X, xrhs) \\<in> ES\n  finite ES \\<and>\n  finite_rhs ES \\<and>\n  soundness ES \\<and>\n  (\\<forall>X rhs rhs'.\n      (X, rhs) \\<in> ES \\<and> (X, rhs') \\<in> ES \\<longrightarrow>\n      rhs = rhs') \\<and>\n  ardenable_all ES \\<and> validity ES\n\ngoal (1 subgoal):\n 1. (Y, yrhs) \\<in> ES &&& X \\<noteq> Y", "by auto"], ["proof (state)\nthis:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y\n\ngoal (1 subgoal):\n 1. \\<exists>xrhs'. (X, xrhs') \\<in> Iter X ES", "then"], ["proof (chain)\npicking this:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y", "show \"\\<exists>xrhs'. (X, xrhs') \\<in> (Iter X ES)\""], ["proof (prove)\nusing this:\n  (Y, yrhs) \\<in> ES\n  X \\<noteq> Y\n\ngoal (1 subgoal):\n 1. \\<exists>xrhs'. (X, xrhs') \\<in> Iter X ES", "apply(rule IterI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xrhs'. (X, xrhs') \\<in> Remove ES Y yrhs", "unfolding Remove_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xrhs'.\n                            (X, xrhs')\n                            \\<in> Subst_all (ES - {(Y, yrhs)}) Y\n                                   (Arden Y yrhs)", "apply(rule Subst_all_cls_remains)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> (X, ?xrhs2 Y yrhs) \\<in> ES - {(Y, yrhs)}", "using X_in_ES"], ["proof (prove)\nusing this:\n  (X, xrhs) \\<in> ES\n\ngoal (1 subgoal):\n 1. \\<And>Y yrhs.\n       \\<lbrakk>(Y, yrhs) \\<in> ES; X \\<noteq> Y\\<rbrakk>\n       \\<Longrightarrow> (X, ?xrhs2 Y yrhs) \\<in> ES - {(Y, yrhs)}", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>xrhs'. (X, xrhs') \\<in> Iter X ES\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The conclusion of the first direction\\<close>"], ["", "lemma Solve:\n  fixes A::\"('a::finite) lang\"\n  assumes fin: \"finite (UNIV // \\<approx>A)\"\n  and     X_in: \"X \\<in> (UNIV // \\<approx>A)\"\n  shows \"\\<exists>rhs. Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and> invariant {(X, rhs)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "define Inv where \"Inv ES \\<longleftrightarrow> invariant ES \\<and> (\\<exists>rhs. (X, rhs) \\<in> ES)\" for ES"], ["proof (state)\nthis:\n  Inv ?ES = (invariant ?ES \\<and> (\\<exists>rhs. (X, rhs) \\<in> ?ES))\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "have \"Inv (Init (UNIV // \\<approx>A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inv (Init (UNIV // \\<approx>A))", "unfolding Inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (Init (UNIV // \\<approx>A)) \\<and>\n    (\\<exists>rhs. (X, rhs) \\<in> Init (UNIV // \\<approx>A))", "using fin X_in"], ["proof (prove)\nusing this:\n  finite (UNIV // \\<approx>A)\n  X \\<in> UNIV // \\<approx>A\n\ngoal (1 subgoal):\n 1. invariant (Init (UNIV // \\<approx>A)) \\<and>\n    (\\<exists>rhs. (X, rhs) \\<in> Init (UNIV // \\<approx>A))", "by (simp add: Init_ES_satisfies_invariant, simp add: Init_def)"], ["proof (state)\nthis:\n  Inv (Init (UNIV // \\<approx>A))\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "moreover"], ["proof (state)\nthis:\n  Inv (Init (UNIV // \\<approx>A))\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "{"], ["proof (state)\nthis:\n  Inv (Init (UNIV // \\<approx>A))\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "fix ES"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "assume inv: \"Inv ES\" and crd: \"Cond ES\""], ["proof (state)\nthis:\n  Inv ES\n  Cond ES\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "then"], ["proof (chain)\npicking this:\n  Inv ES\n  Cond ES", "have \"Inv (Iter X ES)\""], ["proof (prove)\nusing this:\n  Inv ES\n  Cond ES\n\ngoal (1 subgoal):\n 1. Inv (Iter X ES)", "unfolding Inv_def"], ["proof (prove)\nusing this:\n  invariant ES \\<and> (\\<exists>rhs. (X, rhs) \\<in> ES)\n  Cond ES\n\ngoal (1 subgoal):\n 1. invariant (Iter X ES) \\<and> (\\<exists>rhs. (X, rhs) \\<in> Iter X ES)", "by (auto simp add: iteration_step_invariant iteration_step_ex)"], ["proof (state)\nthis:\n  Inv (Iter X ES)\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Inv ?ES2; Cond ?ES2\\<rbrakk> \\<Longrightarrow> Inv (Iter X ?ES2)\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Inv ?ES2; Cond ?ES2\\<rbrakk> \\<Longrightarrow> Inv (Iter X ?ES2)\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>Inv ?ES2; Cond ?ES2\\<rbrakk> \\<Longrightarrow> Inv (Iter X ?ES2)\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "fix ES"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "assume inv: \"Inv ES\" and not_crd: \"\\<not>Cond ES\""], ["proof (state)\nthis:\n  Inv ES\n  \\<not> Cond ES\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "from inv"], ["proof (chain)\npicking this:\n  Inv ES", "obtain rhs where \"(X, rhs) \\<in> ES\""], ["proof (prove)\nusing this:\n  Inv ES\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        (X, rhs) \\<in> ES \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Inv_def"], ["proof (prove)\nusing this:\n  invariant ES \\<and> (\\<exists>rhs. (X, rhs) \\<in> ES)\n\ngoal (1 subgoal):\n 1. (\\<And>rhs.\n        (X, rhs) \\<in> ES \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (X, rhs) \\<in> ES\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "moreover"], ["proof (state)\nthis:\n  (X, rhs) \\<in> ES\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "from not_crd"], ["proof (chain)\npicking this:\n  \\<not> Cond ES", "have \"card ES = 1\""], ["proof (prove)\nusing this:\n  \\<not> Cond ES\n\ngoal (1 subgoal):\n 1. card ES = 1", "by simp"], ["proof (state)\nthis:\n  card ES = 1\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "ultimately"], ["proof (chain)\npicking this:\n  (X, rhs) \\<in> ES\n  card ES = 1", "have \"ES = {(X, rhs)}\""], ["proof (prove)\nusing this:\n  (X, rhs) \\<in> ES\n  card ES = 1\n\ngoal (1 subgoal):\n 1. ES = {(X, rhs)}", "by (auto simp add: card_Suc_eq)"], ["proof (state)\nthis:\n  ES = {(X, rhs)}\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "then"], ["proof (chain)\npicking this:\n  ES = {(X, rhs)}", "have \"\\<exists>rhs'. ES = {(X, rhs')} \\<and> invariant {(X, rhs')}\""], ["proof (prove)\nusing this:\n  ES = {(X, rhs)}\n\ngoal (1 subgoal):\n 1. \\<exists>rhs'. ES = {(X, rhs')} \\<and> invariant {(X, rhs')}", "using inv"], ["proof (prove)\nusing this:\n  ES = {(X, rhs)}\n  Inv ES\n\ngoal (1 subgoal):\n 1. \\<exists>rhs'. ES = {(X, rhs')} \\<and> invariant {(X, rhs')}", "unfolding Inv_def"], ["proof (prove)\nusing this:\n  ES = {(X, rhs)}\n  invariant ES \\<and> (\\<exists>rhs. (X, rhs) \\<in> ES)\n\ngoal (1 subgoal):\n 1. \\<exists>rhs'. ES = {(X, rhs')} \\<and> invariant {(X, rhs')}", "by auto"], ["proof (state)\nthis:\n  \\<exists>rhs'. ES = {(X, rhs')} \\<and> invariant {(X, rhs')}\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Inv ?ES2; \\<not> Cond ?ES2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rhs'.\n                       ?ES2 = {(X, rhs')} \\<and> invariant {(X, rhs')}\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Inv ?ES2; \\<not> Cond ?ES2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rhs'.\n                       ?ES2 = {(X, rhs')} \\<and> invariant {(X, rhs')}\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "have \"wf (measure card)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure card)", "by simp"], ["proof (state)\nthis:\n  wf (measure card)\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "moreover"], ["proof (state)\nthis:\n  wf (measure card)\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "{"], ["proof (state)\nthis:\n  wf (measure card)\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "fix ES"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "assume inv: \"Inv ES\" and crd: \"Cond ES\""], ["proof (state)\nthis:\n  Inv ES\n  Cond ES\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "then"], ["proof (chain)\npicking this:\n  Inv ES\n  Cond ES", "have \"(Iter X ES, ES) \\<in> measure card\""], ["proof (prove)\nusing this:\n  Inv ES\n  Cond ES\n\ngoal (1 subgoal):\n 1. (Iter X ES, ES) \\<in> measure card", "unfolding Inv_def"], ["proof (prove)\nusing this:\n  invariant ES \\<and> (\\<exists>rhs. (X, rhs) \\<in> ES)\n  Cond ES\n\ngoal (1 subgoal):\n 1. (Iter X ES, ES) \\<in> measure card", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rhs.\n       \\<lbrakk>Cond ES; invariant ES; (X, rhs) \\<in> ES\\<rbrakk>\n       \\<Longrightarrow> (Iter X ES, ES) \\<in> measure card", "apply(rule_tac iteration_step_measure)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>rhs.\n       \\<lbrakk>Cond ES; invariant ES; (X, rhs) \\<in> ES\\<rbrakk>\n       \\<Longrightarrow> invariant ES\n 2. \\<And>rhs.\n       \\<lbrakk>Cond ES; invariant ES; (X, rhs) \\<in> ES\\<rbrakk>\n       \\<Longrightarrow> (X, ?xrhs4 rhs) \\<in> ES\n 3. \\<And>rhs.\n       \\<lbrakk>Cond ES; invariant ES; (X, rhs) \\<in> ES\\<rbrakk>\n       \\<Longrightarrow> Cond ES", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (Iter X ES, ES) \\<in> measure card\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Inv ?ES3; Cond ?ES3\\<rbrakk>\n  \\<Longrightarrow> (Iter X ?ES3, ?ES3) \\<in> measure card\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "ultimately"], ["proof (chain)\npicking this:\n  Inv (Init (UNIV // \\<approx>A))\n  \\<lbrakk>Inv ?ES2; Cond ?ES2\\<rbrakk> \\<Longrightarrow> Inv (Iter X ?ES2)\n  \\<lbrakk>Inv ?ES2; \\<not> Cond ?ES2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rhs'.\n                       ?ES2 = {(X, rhs')} \\<and> invariant {(X, rhs')}\n  wf (measure card)\n  \\<lbrakk>Inv ?ES3; Cond ?ES3\\<rbrakk>\n  \\<Longrightarrow> (Iter X ?ES3, ?ES3) \\<in> measure card", "show \"\\<exists>rhs. Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and> invariant {(X, rhs)}\""], ["proof (prove)\nusing this:\n  Inv (Init (UNIV // \\<approx>A))\n  \\<lbrakk>Inv ?ES2; Cond ?ES2\\<rbrakk> \\<Longrightarrow> Inv (Iter X ?ES2)\n  \\<lbrakk>Inv ?ES2; \\<not> Cond ?ES2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rhs'.\n                       ?ES2 = {(X, rhs')} \\<and> invariant {(X, rhs')}\n  wf (measure card)\n  \\<lbrakk>Inv ?ES3; Cond ?ES3\\<rbrakk>\n  \\<Longrightarrow> (Iter X ?ES3, ?ES3) \\<in> measure card\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "unfolding Solve_def"], ["proof (prove)\nusing this:\n  Inv (Init (UNIV // \\<approx>A))\n  \\<lbrakk>Inv ?ES2; Cond ?ES2\\<rbrakk> \\<Longrightarrow> Inv (Iter X ?ES2)\n  \\<lbrakk>Inv ?ES2; \\<not> Cond ?ES2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rhs'.\n                       ?ES2 = {(X, rhs')} \\<and> invariant {(X, rhs')}\n  wf (measure card)\n  \\<lbrakk>Inv ?ES3; Cond ?ES3\\<rbrakk>\n  \\<Longrightarrow> (Iter X ?ES3, ?ES3) \\<in> measure card\n\ngoal (1 subgoal):\n 1. \\<exists>rhs.\n       while Cond (Iter X) (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n       invariant {(X, rhs)}", "by (rule while_rule)"], ["proof (state)\nthis:\n  \\<exists>rhs.\n     Solve X (Init (UNIV // \\<approx>A)) = {(X, rhs)} \\<and>\n     invariant {(X, rhs)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma every_eqcl_has_reg:\n  fixes A::\"('a::finite) lang\"\n  assumes finite_CS: \"finite (UNIV // \\<approx>A)\"\n  and X_in_CS: \"X \\<in> (UNIV // \\<approx>A)\"\n  shows \"\\<exists>r. X = lang r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "from finite_CS X_in_CS"], ["proof (chain)\npicking this:\n  finite (UNIV // \\<approx>A)\n  X \\<in> UNIV // \\<approx>A", "obtain xrhs where Inv_ES: \"invariant {(X, xrhs)}\""], ["proof (prove)\nusing this:\n  finite (UNIV // \\<approx>A)\n  X \\<in> UNIV // \\<approx>A\n\ngoal (1 subgoal):\n 1. (\\<And>xrhs.\n        invariant {(X, xrhs)} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Solve"], ["proof (prove)\nusing this:\n  finite (UNIV // \\<approx>A)\n  X \\<in> UNIV // \\<approx>A\n  \\<lbrakk>finite (UNIV // \\<approx>?A);\n   ?X \\<in> UNIV // \\<approx>?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rhs.\n                       Solve ?X (Init (UNIV // \\<approx>?A)) =\n                       {(?X, rhs)} \\<and>\n                       invariant {(?X, rhs)}\n\ngoal (1 subgoal):\n 1. (\\<And>xrhs.\n        invariant {(X, xrhs)} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  invariant {(X, xrhs)}\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "define A where \"A = Arden X xrhs\""], ["proof (state)\nthis:\n  A = Arden X xrhs\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "have \"rhss xrhs \\<subseteq> {X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhss xrhs \\<subseteq> {X}", "using Inv_ES"], ["proof (prove)\nusing this:\n  invariant {(X, xrhs)}\n\ngoal (1 subgoal):\n 1. rhss xrhs \\<subseteq> {X}", "unfolding validity_def invariant_def rhss_def lhss_def"], ["proof (prove)\nusing this:\n  finite {(X, xrhs)} \\<and>\n  finite_rhs {(X, xrhs)} \\<and>\n  soundness {(X, xrhs)} \\<and>\n  distinctness {(X, xrhs)} \\<and>\n  ardenable_all {(X, xrhs)} \\<and>\n  (\\<forall>(Xa, rhs)\\<in>{(X, xrhs)}.\n      {uu_. \\<exists>X r. uu_ = X \\<and> Trn X r \\<in> rhs}\n      \\<subseteq> {uu_.\n                   \\<exists>Y yrhs.\n                      uu_ = Y \\<and> (Y, yrhs) \\<in> {(X, xrhs)}})\n\ngoal (1 subgoal):\n 1. {uu_. \\<exists>X r. uu_ = X \\<and> Trn X r \\<in> xrhs} \\<subseteq> {X}", "by auto"], ["proof (state)\nthis:\n  rhss xrhs \\<subseteq> {X}\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "then"], ["proof (chain)\npicking this:\n  rhss xrhs \\<subseteq> {X}", "have \"rhss A = {}\""], ["proof (prove)\nusing this:\n  rhss xrhs \\<subseteq> {X}\n\ngoal (1 subgoal):\n 1. rhss A = {}", "unfolding A_def"], ["proof (prove)\nusing this:\n  rhss xrhs \\<subseteq> {X}\n\ngoal (1 subgoal):\n 1. rhss (Arden X xrhs) = {}", "by (simp add: Arden_removes_cl)"], ["proof (state)\nthis:\n  rhss A = {}\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "then"], ["proof (chain)\npicking this:\n  rhss A = {}", "have eq: \"{Lam r | r. Lam r \\<in> A} = A\""], ["proof (prove)\nusing this:\n  rhss A = {}\n\ngoal (1 subgoal):\n 1. {Lam r |r. Lam r \\<in> A} = A", "unfolding rhss_def"], ["proof (prove)\nusing this:\n  {uu_. \\<exists>X r. uu_ = X \\<and> Trn X r \\<in> A} = {}\n\ngoal (1 subgoal):\n 1. {Lam r |r. Lam r \\<in> A} = A", "by (auto, case_tac x, auto)"], ["proof (state)\nthis:\n  {Lam r |r. Lam r \\<in> A} = A\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "have \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "using Inv_ES"], ["proof (prove)\nusing this:\n  invariant {(X, xrhs)}\n\ngoal (1 subgoal):\n 1. finite A", "unfolding A_def invariant_def finite_rhs_def"], ["proof (prove)\nusing this:\n  finite {(X, xrhs)} \\<and>\n  (\\<forall>(X, rhs)\\<in>{(X, xrhs)}. finite rhs) \\<and>\n  soundness {(X, xrhs)} \\<and>\n  distinctness {(X, xrhs)} \\<and>\n  ardenable_all {(X, xrhs)} \\<and> validity {(X, xrhs)}\n\ngoal (1 subgoal):\n 1. finite (Arden X xrhs)", "using Arden_preserves_finite"], ["proof (prove)\nusing this:\n  finite {(X, xrhs)} \\<and>\n  (\\<forall>(X, rhs)\\<in>{(X, xrhs)}. finite rhs) \\<and>\n  soundness {(X, xrhs)} \\<and>\n  distinctness {(X, xrhs)} \\<and>\n  ardenable_all {(X, xrhs)} \\<and> validity {(X, xrhs)}\n  finite ?rhs \\<Longrightarrow> finite (Arden ?X ?rhs)\n\ngoal (1 subgoal):\n 1. finite (Arden X xrhs)", "by auto"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "then"], ["proof (chain)\npicking this:\n  finite A", "have fin: \"finite {r. Lam r \\<in> A}\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite {r. Lam r \\<in> A}", "by (rule finite_Lam)"], ["proof (state)\nthis:\n  finite {r. Lam r \\<in> A}\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "have \"X = lang_rhs xrhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = lang_rhs xrhs", "using Inv_ES"], ["proof (prove)\nusing this:\n  invariant {(X, xrhs)}\n\ngoal (1 subgoal):\n 1. X = lang_rhs xrhs", "unfolding invariant_def soundness_def"], ["proof (prove)\nusing this:\n  finite {(X, xrhs)} \\<and>\n  finite_rhs {(X, xrhs)} \\<and>\n  (\\<forall>(X, rhs)\\<in>{(X, xrhs)}. X = lang_rhs rhs) \\<and>\n  distinctness {(X, xrhs)} \\<and>\n  ardenable_all {(X, xrhs)} \\<and> validity {(X, xrhs)}\n\ngoal (1 subgoal):\n 1. X = lang_rhs xrhs", "by simp"], ["proof (state)\nthis:\n  X = lang_rhs xrhs\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "then"], ["proof (chain)\npicking this:\n  X = lang_rhs xrhs", "have \"X = lang_rhs A\""], ["proof (prove)\nusing this:\n  X = lang_rhs xrhs\n\ngoal (1 subgoal):\n 1. X = lang_rhs A", "using Inv_ES"], ["proof (prove)\nusing this:\n  X = lang_rhs xrhs\n  invariant {(X, xrhs)}\n\ngoal (1 subgoal):\n 1. X = lang_rhs A", "unfolding A_def invariant_def ardenable_all_def finite_rhs_def"], ["proof (prove)\nusing this:\n  X = lang_rhs xrhs\n  finite {(X, xrhs)} \\<and>\n  (\\<forall>(X, rhs)\\<in>{(X, xrhs)}. finite rhs) \\<and>\n  soundness {(X, xrhs)} \\<and>\n  distinctness {(X, xrhs)} \\<and>\n  (\\<forall>(X, rhs)\\<in>{(X, xrhs)}. ardenable rhs) \\<and>\n  validity {(X, xrhs)}\n\ngoal (1 subgoal):\n 1. X = lang_rhs (Arden X xrhs)", "by (rule_tac Arden_preserves_soundness) (simp_all add: finite_Trn)"], ["proof (state)\nthis:\n  X = lang_rhs A\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "then"], ["proof (chain)\npicking this:\n  X = lang_rhs A", "have \"X = lang_rhs {Lam r | r. Lam r \\<in> A}\""], ["proof (prove)\nusing this:\n  X = lang_rhs A\n\ngoal (1 subgoal):\n 1. X = lang_rhs {Lam r |r. Lam r \\<in> A}", "using eq"], ["proof (prove)\nusing this:\n  X = lang_rhs A\n  {Lam r |r. Lam r \\<in> A} = A\n\ngoal (1 subgoal):\n 1. X = lang_rhs {Lam r |r. Lam r \\<in> A}", "by simp"], ["proof (state)\nthis:\n  X = lang_rhs {Lam r |r. Lam r \\<in> A}\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "then"], ["proof (chain)\npicking this:\n  X = lang_rhs {Lam r |r. Lam r \\<in> A}", "have \"X = lang (\\<Uplus>{r. Lam r \\<in> A})\""], ["proof (prove)\nusing this:\n  X = lang_rhs {Lam r |r. Lam r \\<in> A}\n\ngoal (1 subgoal):\n 1. X = lang (\\<Uplus>{r. Lam r \\<in> A})", "using fin"], ["proof (prove)\nusing this:\n  X = lang_rhs {Lam r |r. Lam r \\<in> A}\n  finite {r. Lam r \\<in> A}\n\ngoal (1 subgoal):\n 1. X = lang (\\<Uplus>{r. Lam r \\<in> A})", "by auto"], ["proof (state)\nthis:\n  X = lang (\\<Uplus>{r. Lam r \\<in> A})\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "then"], ["proof (chain)\npicking this:\n  X = lang (\\<Uplus>{r. Lam r \\<in> A})", "show \"\\<exists>r. X = lang r\""], ["proof (prove)\nusing this:\n  X = lang (\\<Uplus>{r. Lam r \\<in> A})\n\ngoal (1 subgoal):\n 1. \\<exists>r. X = lang r", "by blast"], ["proof (state)\nthis:\n  \\<exists>r. X = lang r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bchoice_finite_set:\n  assumes a: \"\\<forall>x \\<in> S. \\<exists>y. x = f y\" \n  and     b: \"finite S\"\n  shows \"\\<exists>ys. (\\<Union> S) = \\<Union>(f ` ys) \\<and> finite ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys. \\<Union> S = \\<Union> (f ` ys) \\<and> finite ys", "using bchoice[OF a] b"], ["proof (prove)\nusing this:\n  \\<exists>fa. \\<forall>x\\<in>S. x = f (fa x)\n  finite S\n\ngoal (1 subgoal):\n 1. \\<exists>ys. \\<Union> S = \\<Union> (f ` ys) \\<and> finite ys", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>finite S; \\<forall>x\\<in>S. x = f (fa x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            \\<Union> S = \\<Union> (f ` ys) \\<and> finite ys", "apply(rule_tac x=\"fa ` S\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>finite S; \\<forall>x\\<in>S. x = f (fa x)\\<rbrakk>\n       \\<Longrightarrow> \\<Union> S = \\<Union> (f ` fa ` S) \\<and>\n                         finite (fa ` S)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem Myhill_Nerode1:\n  fixes A::\"('a::finite) lang\"\n  assumes finite_CS: \"finite (UNIV // \\<approx>A)\"\n  shows   \"\\<exists>r. A = lang r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. A = lang r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. A = lang r", "have fin: \"finite (finals A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (finals A)", "using finals_in_partitions finite_CS"], ["proof (prove)\nusing this:\n  finals ?A \\<subseteq> UNIV // \\<approx>?A\n  finite (UNIV // \\<approx>A)\n\ngoal (1 subgoal):\n 1. finite (finals A)", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite (finals A)\n\ngoal (1 subgoal):\n 1. \\<exists>r. A = lang r", "have \"\\<forall>X \\<in> (UNIV // \\<approx>A). \\<exists>r. X = lang r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>UNIV // \\<approx>A. \\<exists>r. X = lang r", "using finite_CS every_eqcl_has_reg"], ["proof (prove)\nusing this:\n  finite (UNIV // \\<approx>A)\n  \\<lbrakk>finite (UNIV // \\<approx>?A);\n   ?X \\<in> UNIV // \\<approx>?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r. ?X = lang r\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>UNIV // \\<approx>A. \\<exists>r. X = lang r", "by blast"], ["proof (state)\nthis:\n  \\<forall>X\\<in>UNIV // \\<approx>A. \\<exists>r. X = lang r\n\ngoal (1 subgoal):\n 1. \\<exists>r. A = lang r", "then"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>UNIV // \\<approx>A. \\<exists>r. X = lang r", "have a: \"\\<forall>X \\<in> finals A. \\<exists>r. X = lang r\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>UNIV // \\<approx>A. \\<exists>r. X = lang r\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>finals A. \\<exists>r. X = lang r", "using finals_in_partitions"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>UNIV // \\<approx>A. \\<exists>r. X = lang r\n  finals ?A \\<subseteq> UNIV // \\<approx>?A\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>finals A. \\<exists>r. X = lang r", "by auto"], ["proof (state)\nthis:\n  \\<forall>X\\<in>finals A. \\<exists>r. X = lang r\n\ngoal (1 subgoal):\n 1. \\<exists>r. A = lang r", "then"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>finals A. \\<exists>r. X = lang r", "obtain rs::\"('a rexp) set\" where \"\\<Union> (finals A) = \\<Union>(lang ` rs)\" \"finite rs\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>finals A. \\<exists>r. X = lang r\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>\\<Union> (finals A) = \\<Union> (lang ` rs);\n         finite rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fin"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>finals A. \\<exists>r. X = lang r\n  finite (finals A)\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>\\<Union> (finals A) = \\<Union> (lang ` rs);\n         finite rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: bchoice_finite_set)"], ["proof (state)\nthis:\n  \\<Union> (finals A) = \\<Union> (lang ` rs)\n  finite rs\n\ngoal (1 subgoal):\n 1. \\<exists>r. A = lang r", "then"], ["proof (chain)\npicking this:\n  \\<Union> (finals A) = \\<Union> (lang ` rs)\n  finite rs", "have \"A = lang (\\<Uplus>rs)\""], ["proof (prove)\nusing this:\n  \\<Union> (finals A) = \\<Union> (lang ` rs)\n  finite rs\n\ngoal (1 subgoal):\n 1. A = lang (\\<Uplus>rs)", "unfolding lang_is_union_of_finals[symmetric]"], ["proof (prove)\nusing this:\n  A = \\<Union> (lang ` rs)\n  finite rs\n\ngoal (1 subgoal):\n 1. A = lang (\\<Uplus>rs)", "by simp"], ["proof (state)\nthis:\n  A = lang (\\<Uplus>rs)\n\ngoal (1 subgoal):\n 1. \\<exists>r. A = lang r", "then"], ["proof (chain)\npicking this:\n  A = lang (\\<Uplus>rs)", "show \"\\<exists>r. A = lang r\""], ["proof (prove)\nusing this:\n  A = lang (\\<Uplus>rs)\n\ngoal (1 subgoal):\n 1. \\<exists>r. A = lang r", "by blast"], ["proof (state)\nthis:\n  \\<exists>r. A = lang r\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}