{"file_name": "/home/qj213/afp-2021-10-22/thys/Myhill-Nerode/Myhill.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Myhill-Nerode", "problem_names": ["theorem Myhill_Nerode:\n  fixes A::\"('a::finite) lang\"\n  shows \"(\\<exists>r. A = lang r) \\<longleftrightarrow> finite (UNIV // \\<approx>A)\"", "lemma MN_Rel_Derivs:\n  shows \"x \\<approx>A y \\<longleftrightarrow> Derivs x A = Derivs y A\"", "lemma Myhill_Nerode3:\n  fixes r::\"'a rexp\"\n  shows \"finite (UNIV // \\<approx>(lang r))\""], "translations": [["", "theorem Myhill_Nerode:\n  fixes A::\"('a::finite) lang\"\n  shows \"(\\<exists>r. A = lang r) \\<longleftrightarrow> finite (UNIV // \\<approx>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r. A = lang r) = finite (UNIV // \\<approx>A)", "using Myhill_Nerode1 Myhill_Nerode2"], ["proof (prove)\nusing this:\n  finite (UNIV // \\<approx>?A) \\<Longrightarrow> \\<exists>r. ?A = lang r\n  finite (UNIV // \\<approx>lang ?r)\n\ngoal (1 subgoal):\n 1. (\\<exists>r. A = lang r) = finite (UNIV // \\<approx>A)", "by auto"], ["", "subsection \\<open>Second direction proved using partial derivatives\\<close>"], ["", "text \\<open>\n  An alternaive proof using the notion of partial derivatives for regular \n  expressions due to Antimirov \\cite{Antimirov95}.\n\\<close>"], ["", "lemma MN_Rel_Derivs:\n  shows \"x \\<approx>A y \\<longleftrightarrow> Derivs x A = Derivs y A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<approx>A y = (Derivs x A = Derivs y A)", "unfolding Derivs_def str_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> {(x, y). \\<forall>z. (x @ z \\<in> A) = (y @ z \\<in> A)}) =\n    ({ys. x @ ys \\<in> A} = {ys. y @ ys \\<in> A})", "by auto"], ["", "lemma Myhill_Nerode3:\n  fixes r::\"'a rexp\"\n  shows \"finite (UNIV // \\<approx>(lang r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>lang r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>lang r)", "have \"finite (UNIV // =(\\<lambda>x. pderivs x r)=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UNIV // =\\<lambda>x. pderivs x r=)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (UNIV // =\\<lambda>x. pderivs x r=)", "have \"range (\\<lambda>x. pderivs x r) \\<subseteq> Pow (pderivs_lang UNIV r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>x. pderivs x r) \\<subseteq> Pow (pderivs_lang UNIV r)", "unfolding pderivs_lang_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>x. pderivs x r) \\<subseteq> Pow (\\<Union>x. pderivs x r)", "by auto"], ["proof (state)\nthis:\n  range (\\<lambda>x. pderivs x r) \\<subseteq> Pow (pderivs_lang UNIV r)\n\ngoal (1 subgoal):\n 1. finite (UNIV // =\\<lambda>x. pderivs x r=)", "moreover"], ["proof (state)\nthis:\n  range (\\<lambda>x. pderivs x r) \\<subseteq> Pow (pderivs_lang UNIV r)\n\ngoal (1 subgoal):\n 1. finite (UNIV // =\\<lambda>x. pderivs x r=)", "have \"finite (Pow (pderivs_lang UNIV r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Pow (pderivs_lang UNIV r))", "by (simp add: finite_pderivs_lang)"], ["proof (state)\nthis:\n  finite (Pow (pderivs_lang UNIV r))\n\ngoal (1 subgoal):\n 1. finite (UNIV // =\\<lambda>x. pderivs x r=)", "ultimately"], ["proof (chain)\npicking this:\n  range (\\<lambda>x. pderivs x r) \\<subseteq> Pow (pderivs_lang UNIV r)\n  finite (Pow (pderivs_lang UNIV r))", "have \"finite (range (\\<lambda>x. pderivs x r))\""], ["proof (prove)\nusing this:\n  range (\\<lambda>x. pderivs x r) \\<subseteq> Pow (pderivs_lang UNIV r)\n  finite (Pow (pderivs_lang UNIV r))\n\ngoal (1 subgoal):\n 1. finite (range (\\<lambda>x. pderivs x r))", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  finite (range (\\<lambda>x. pderivs x r))\n\ngoal (1 subgoal):\n 1. finite (UNIV // =\\<lambda>x. pderivs x r=)", "then"], ["proof (chain)\npicking this:\n  finite (range (\\<lambda>x. pderivs x r))", "show \"finite (UNIV // =(\\<lambda>x. pderivs x r)=)\""], ["proof (prove)\nusing this:\n  finite (range (\\<lambda>x. pderivs x r))\n\ngoal (1 subgoal):\n 1. finite (UNIV // =\\<lambda>x. pderivs x r=)", "by (rule finite_eq_tag_rel)"], ["proof (state)\nthis:\n  finite (UNIV // =\\<lambda>x. pderivs x r=)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (UNIV // =\\<lambda>x. pderivs x r=)\n\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>lang r)", "moreover"], ["proof (state)\nthis:\n  finite (UNIV // =\\<lambda>x. pderivs x r=)\n\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>lang r)", "have \"=(\\<lambda>x. pderivs x r)= \\<subseteq> \\<approx>(lang r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. =\\<lambda>x. pderivs x r= \\<subseteq> \\<approx>lang r", "unfolding tag_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). pderivs x r = pderivs y r} \\<subseteq> \\<approx>lang r", "by (auto simp add: MN_Rel_Derivs Derivs_pderivs)"], ["proof (state)\nthis:\n  =\\<lambda>x. pderivs x r= \\<subseteq> \\<approx>lang r\n\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>lang r)", "moreover"], ["proof (state)\nthis:\n  =\\<lambda>x. pderivs x r= \\<subseteq> \\<approx>lang r\n\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>lang r)", "have \"equiv UNIV =(\\<lambda>x. pderivs x r)=\"\n  and  \"equiv UNIV (\\<approx>(lang r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV =\\<lambda>x. pderivs x r= &&& equiv UNIV (\\<approx>lang r)", "unfolding equiv_def refl_on_def sym_def trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (=\\<lambda>x. pderivs x r= \\<subseteq> UNIV \\<times> UNIV \\<and>\n     (\\<forall>x\\<in>UNIV. x =\\<lambda>x. pderivs x r= x)) \\<and>\n    (\\<forall>x y.\n        x =\\<lambda>x. pderivs x r= y \\<longrightarrow>\n        y =\\<lambda>x. pderivs x r= x) \\<and>\n    (\\<forall>x y z.\n        x =\\<lambda>x. pderivs x r= y \\<longrightarrow>\n        y =\\<lambda>x. pderivs x r= z \\<longrightarrow>\n        x =\\<lambda>x. pderivs x r= z) &&&\n    (\\<approx>lang r \\<subseteq> UNIV \\<times> UNIV \\<and>\n     (\\<forall>x\\<in>UNIV. x \\<approx>lang r x)) \\<and>\n    (\\<forall>x y.\n        x \\<approx>lang r y \\<longrightarrow> y \\<approx>lang r x) \\<and>\n    (\\<forall>x y z.\n        x \\<approx>lang r y \\<longrightarrow>\n        y \\<approx>lang r z \\<longrightarrow> x \\<approx>lang r z)", "unfolding tag_eq_def str_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({(x, y). pderivs x r = pderivs y r}\n     \\<subseteq> UNIV \\<times> UNIV \\<and>\n     (\\<forall>x\\<in>UNIV.\n         (x, x) \\<in> {(x, y). pderivs x r = pderivs y r})) \\<and>\n    (\\<forall>x y.\n        (x, y) \\<in> {(x, y). pderivs x r = pderivs y r} \\<longrightarrow>\n        (y, x) \\<in> {(x, y). pderivs x r = pderivs y r}) \\<and>\n    (\\<forall>x y z.\n        (x, y) \\<in> {(x, y). pderivs x r = pderivs y r} \\<longrightarrow>\n        (y, z) \\<in> {(x, y). pderivs x r = pderivs y r} \\<longrightarrow>\n        (x, z) \\<in> {(x, y). pderivs x r = pderivs y r}) &&&\n    ({(x, y). \\<forall>z. (x @ z \\<in> lang r) = (y @ z \\<in> lang r)}\n     \\<subseteq> UNIV \\<times> UNIV \\<and>\n     (\\<forall>x\\<in>UNIV.\n         (x, x)\n         \\<in> {(x, y).\n                \\<forall>z.\n                   (x @ z \\<in> lang r) = (y @ z \\<in> lang r)})) \\<and>\n    (\\<forall>x y.\n        (x, y)\n        \\<in> {(x, y).\n               \\<forall>z.\n                  (x @ z \\<in> lang r) =\n                  (y @ z \\<in> lang r)} \\<longrightarrow>\n        (y, x)\n        \\<in> {(x, y).\n               \\<forall>z.\n                  (x @ z \\<in> lang r) = (y @ z \\<in> lang r)}) \\<and>\n    (\\<forall>x y z.\n        (x, y)\n        \\<in> {(x, y).\n               \\<forall>z.\n                  (x @ z \\<in> lang r) =\n                  (y @ z \\<in> lang r)} \\<longrightarrow>\n        (y, z)\n        \\<in> {(x, y).\n               \\<forall>z.\n                  (x @ z \\<in> lang r) =\n                  (y @ z \\<in> lang r)} \\<longrightarrow>\n        (x, z)\n        \\<in> {(x, y).\n               \\<forall>z. (x @ z \\<in> lang r) = (y @ z \\<in> lang r)})", "by auto"], ["proof (state)\nthis:\n  equiv UNIV =\\<lambda>x. pderivs x r=\n  equiv UNIV (\\<approx>lang r)\n\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>lang r)", "ultimately"], ["proof (chain)\npicking this:\n  finite (UNIV // =\\<lambda>x. pderivs x r=)\n  =\\<lambda>x. pderivs x r= \\<subseteq> \\<approx>lang r\n  equiv UNIV =\\<lambda>x. pderivs x r=\n  equiv UNIV (\\<approx>lang r)", "show \"finite (UNIV // \\<approx>(lang r))\""], ["proof (prove)\nusing this:\n  finite (UNIV // =\\<lambda>x. pderivs x r=)\n  =\\<lambda>x. pderivs x r= \\<subseteq> \\<approx>lang r\n  equiv UNIV =\\<lambda>x. pderivs x r=\n  equiv UNIV (\\<approx>lang r)\n\ngoal (1 subgoal):\n 1. finite (UNIV // \\<approx>lang r)", "by (rule refined_partition_finite)"], ["proof (state)\nthis:\n  finite (UNIV // \\<approx>lang r)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}