{"file_name": "/home/qj213/afp-2021-10-22/thys/Possibilistic_Noninterference/Concrete.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Possibilistic_Noninterference", "problem_names": ["lemma (in PL_Indis) WbisT_If_cross:\n  assumes \"c1 \\<approx>wT c2\" \"c1 \\<approx>wT c1\" \"c2 \\<approx>wT c2\"\n  shows \"(If tst c1 c2) \\<approx>wT (If tst c1 c2)\"", "lemma [simp]: \"\\<And> l. l \\<noteq> Hi \\<longleftrightarrow> l = Lo\" and \n      [simp]: \"\\<And> l. Hi \\<noteq> l \\<longleftrightarrow> Lo = l\" and \n      [simp]: \"\\<And> l. l \\<noteq> Lo \\<longleftrightarrow> l = Hi\" and \n      [simp]: \"\\<And> l. Lo \\<noteq> l \\<longleftrightarrow> Hi = l\"", "lemma [dest]: \"\\<And> l A. \\<lbrakk>l \\<in> A; Lo \\<notin> A\\<rbrakk> \\<Longrightarrow> l = Hi\" and \n      [dest]: \"\\<And> l A. \\<lbrakk>l \\<in> A; Hi \\<notin> A\\<rbrakk> \\<Longrightarrow> l = Lo\"", "lemma sup_eq_Lo[simp]: \"sup a b = Lo \\<longleftrightarrow> a = Lo \\<and> b = Lo\"", "lemma exprSec_Lo_eval_eq: \"exprSec expr = Lo \\<Longrightarrow> (s, t) \\<in> indis \\<Longrightarrow> eval expr s = eval expr t\"", "lemma compatAtmSyntactic[simp]: \"exprSec expr = Lo \\<or> sec v = Hi \\<Longrightarrow> Example_PL.compatAtm (Assign v expr)\"", "lemma presAtmSyntactic[simp]: \"sec v = Hi \\<Longrightarrow> Example_PL.presAtm (Assign v expr)\"", "lemma compatTstSyntactic[simp]: \"tstSec tst = Lo \\<Longrightarrow> Example_PL.compatTst tst\"", "lemma \"Example_PL.SC_discr (h ::= Ct 0)\"", "theorem c0: \"siso c0\" \"discr c0\"", "theorem c1: \"siso c1\" \"c1 \\<approx>s c1\"", "theorem c2: \"discr c2\"", "theorem Sbis_c2: \"c2 \\<approx>s c2\"", "theorem c3: \"discr c3\"", "theorem c4: \"c4 \\<approx>01 c4\"", "theorem c5: \"c5 \\<approx>w c5\"", "theorem \"c3 \\<approx>wT c3\"", "theorem \"c5 \\<approx>wT c5\"", "lemma c13_inner:\n  \"(h ::= Ct 1 ;; l ::= Ct 2) \\<approx>wT (l ::= Ct 2)\"", "theorem \"c13 \\<approx>wT c13\""], "translations": [["", "lemma (in PL_Indis) WbisT_If_cross:\n  assumes \"c1 \\<approx>wT c2\" \"c1 \\<approx>wT c1\" \"c2 \\<approx>wT c2\"\n  shows \"(If tst c1 c2) \\<approx>wT (If tst c1 c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if tst then c1 else c2 \\<approx>wT if tst then c1 else c2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. if tst then c1 else c2 \\<approx>wT if tst then c1 else c2", "define \\<phi>\n    where \"\\<phi> c d \\<longleftrightarrow> (\\<exists>c1' c2'. c = If tst c1' c2' \\<and> d = If tst c1' c2' \\<and> c1' \\<approx>wT c2' \\<and> c1' \\<approx>wT c1' \\<and> c2' \\<approx>wT c2')\"\n    for c d"], ["proof (state)\nthis:\n  \\<phi> ?c ?d =\n  (\\<exists>c1' c2'.\n      ?c = if tst then c1' else c2' \\<and>\n      ?d = if tst then c1' else c2' \\<and>\n      c1' \\<approx>wT c2' \\<and>\n      c1' \\<approx>wT c1' \\<and> c2' \\<approx>wT c2')\n\ngoal (1 subgoal):\n 1. if tst then c1 else c2 \\<approx>wT if tst then c1 else c2", "with assms"], ["proof (chain)\npicking this:\n  c1 \\<approx>wT c2\n  c1 \\<approx>wT c1\n  c2 \\<approx>wT c2\n  \\<phi> ?c ?d =\n  (\\<exists>c1' c2'.\n      ?c = if tst then c1' else c2' \\<and>\n      ?d = if tst then c1' else c2' \\<and>\n      c1' \\<approx>wT c2' \\<and>\n      c1' \\<approx>wT c1' \\<and> c2' \\<approx>wT c2')", "have \"\\<phi> (If tst c1 c2) (If tst c1 c2)\""], ["proof (prove)\nusing this:\n  c1 \\<approx>wT c2\n  c1 \\<approx>wT c1\n  c2 \\<approx>wT c2\n  \\<phi> ?c ?d =\n  (\\<exists>c1' c2'.\n      ?c = if tst then c1' else c2' \\<and>\n      ?d = if tst then c1' else c2' \\<and>\n      c1' \\<approx>wT c2' \\<and>\n      c1' \\<approx>wT c1' \\<and> c2' \\<approx>wT c2')\n\ngoal (1 subgoal):\n 1. \\<phi> (if tst then c1 else c2) (if tst then c1 else c2)", "by auto"], ["proof (state)\nthis:\n  \\<phi> (if tst then c1 else c2) (if tst then c1 else c2)\n\ngoal (1 subgoal):\n 1. if tst then c1 else c2 \\<approx>wT if tst then c1 else c2", "then"], ["proof (chain)\npicking this:\n  \\<phi> (if tst then c1 else c2) (if tst then c1 else c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> (if tst then c1 else c2) (if tst then c1 else c2)\n\ngoal (1 subgoal):\n 1. if tst then c1 else c2 \\<approx>wT if tst then c1 else c2", "proof (induct rule: WbisT_coinduct[where \\<phi>=\\<phi>])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t;\n        (c, s) \\<rightarrow>c (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            (d, t) \\<rightarrow>*c (d', t') \\<and>\n                            s' \\<approx> t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 3. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t; (c, s) \\<rightarrow>t s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            (d, t) \\<rightarrow>*t t' \\<and> s' \\<approx> t'", "case (cont c s d t c' s')"], ["proof (state)\nthis:\n  \\<phi> c d\n  s \\<approx> t\n  (c, s) \\<rightarrow>c (c', s')\n\ngoal (3 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t;\n        (c, s) \\<rightarrow>c (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            (d, t) \\<rightarrow>*c (d', t') \\<and>\n                            s' \\<approx> t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 3. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t; (c, s) \\<rightarrow>t s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            (d, t) \\<rightarrow>*t t' \\<and> s' \\<approx> t'", "note cont(2,3)"], ["proof (state)\nthis:\n  s \\<approx> t\n  (c, s) \\<rightarrow>c (c', s')\n\ngoal (3 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t;\n        (c, s) \\<rightarrow>c (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            (d, t) \\<rightarrow>*c (d', t') \\<and>\n                            s' \\<approx> t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 3. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t; (c, s) \\<rightarrow>t s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            (d, t) \\<rightarrow>*t t' \\<and> s' \\<approx> t'", "moreover"], ["proof (state)\nthis:\n  s \\<approx> t\n  (c, s) \\<rightarrow>c (c', s')\n\ngoal (3 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t;\n        (c, s) \\<rightarrow>c (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            (d, t) \\<rightarrow>*c (d', t') \\<and>\n                            s' \\<approx> t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 3. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t; (c, s) \\<rightarrow>t s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            (d, t) \\<rightarrow>*t t' \\<and> s' \\<approx> t'", "from cont"], ["proof (chain)\npicking this:\n  \\<phi> c d\n  s \\<approx> t\n  (c, s) \\<rightarrow>c (c', s')", "obtain c1 c2\n      where \\<phi>: \"c = If tst c1 c2\" \"d = If tst c1 c2\" \"c1 \\<approx>wT c2\" \"c1 \\<approx>wT c1\" \"c2 \\<approx>wT c2\""], ["proof (prove)\nusing this:\n  \\<phi> c d\n  s \\<approx> t\n  (c, s) \\<rightarrow>c (c', s')\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>c = if tst then c1 else c2; d = if tst then c1 else c2;\n         c1 \\<approx>wT c2; c1 \\<approx>wT c1; c2 \\<approx>wT c2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: \\<phi>_def)"], ["proof (state)\nthis:\n  c = if tst then c1 else c2\n  d = if tst then c1 else c2\n  c1 \\<approx>wT c2\n  c1 \\<approx>wT c1\n  c2 \\<approx>wT c2\n\ngoal (3 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t;\n        (c, s) \\<rightarrow>c (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            (d, t) \\<rightarrow>*c (d', t') \\<and>\n                            s' \\<approx> t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 3. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t; (c, s) \\<rightarrow>t s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            (d, t) \\<rightarrow>*t t' \\<and> s' \\<approx> t'", "moreover"], ["proof (state)\nthis:\n  c = if tst then c1 else c2\n  d = if tst then c1 else c2\n  c1 \\<approx>wT c2\n  c1 \\<approx>wT c1\n  c2 \\<approx>wT c2\n\ngoal (3 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t;\n        (c, s) \\<rightarrow>c (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            (d, t) \\<rightarrow>*c (d', t') \\<and>\n                            s' \\<approx> t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 3. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t; (c, s) \\<rightarrow>t s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            (d, t) \\<rightarrow>*t t' \\<and> s' \\<approx> t'", "then"], ["proof (chain)\npicking this:\n  c = if tst then c1 else c2\n  d = if tst then c1 else c2\n  c1 \\<approx>wT c2\n  c1 \\<approx>wT c1\n  c2 \\<approx>wT c2", "have \"c2 \\<approx>wT c1\""], ["proof (prove)\nusing this:\n  c = if tst then c1 else c2\n  d = if tst then c1 else c2\n  c1 \\<approx>wT c2\n  c1 \\<approx>wT c1\n  c2 \\<approx>wT c2\n\ngoal (1 subgoal):\n 1. c2 \\<approx>wT c1", "using WbisT_sym"], ["proof (prove)\nusing this:\n  c = if tst then c1 else c2\n  d = if tst then c1 else c2\n  c1 \\<approx>wT c2\n  c1 \\<approx>wT c1\n  c2 \\<approx>wT c2\n  sym WbisT\n\ngoal (1 subgoal):\n 1. c2 \\<approx>wT c1", "unfolding sym_def"], ["proof (prove)\nusing this:\n  c = if tst then c1 else c2\n  d = if tst then c1 else c2\n  c1 \\<approx>wT c2\n  c1 \\<approx>wT c1\n  c2 \\<approx>wT c2\n  \\<forall>x y. x \\<approx>wT y \\<longrightarrow> y \\<approx>wT x\n\ngoal (1 subgoal):\n 1. c2 \\<approx>wT c1", "by blast"], ["proof (state)\nthis:\n  c2 \\<approx>wT c1\n\ngoal (3 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t;\n        (c, s) \\<rightarrow>c (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            (d, t) \\<rightarrow>*c (d', t') \\<and>\n                            s' \\<approx> t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 3. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t; (c, s) \\<rightarrow>t s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            (d, t) \\<rightarrow>*t t' \\<and> s' \\<approx> t'", "ultimately"], ["proof (chain)\npicking this:\n  s \\<approx> t\n  (c, s) \\<rightarrow>c (c', s')\n  c = if tst then c1 else c2\n  d = if tst then c1 else c2\n  c1 \\<approx>wT c2\n  c1 \\<approx>wT c1\n  c2 \\<approx>wT c2\n  c2 \\<approx>wT c1", "have \"(d, t) \\<rightarrow>*c (if tval tst t then c1 else c2, t) \\<and> s' \\<approx> t \\<and>\n      (\\<phi> c' (if tval tst t then c1 else c2) \\<or> c' \\<approx>wT (if tval tst t then c1 else c2))\""], ["proof (prove)\nusing this:\n  s \\<approx> t\n  (c, s) \\<rightarrow>c (c', s')\n  c = if tst then c1 else c2\n  d = if tst then c1 else c2\n  c1 \\<approx>wT c2\n  c1 \\<approx>wT c1\n  c2 \\<approx>wT c2\n  c2 \\<approx>wT c1\n\ngoal (1 subgoal):\n 1. (d, t) \\<rightarrow>*c (if tval tst t then c1 else c2, t) \\<and>\n    s' \\<approx> t \\<and>\n    (\\<phi> c' (if tval tst t then c1 else c2) \\<or>\n     c' \\<approx>wT (if tval tst t then c1 else c2))", "by (auto simp: \\<phi>_def)"], ["proof (state)\nthis:\n  (d, t) \\<rightarrow>*c (if tval tst t then c1 else c2, t) \\<and>\n  s' \\<approx> t \\<and>\n  (\\<phi> c' (if tval tst t then c1 else c2) \\<or>\n   c' \\<approx>wT (if tval tst t then c1 else c2))\n\ngoal (3 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t;\n        (c, s) \\<rightarrow>c (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            (d, t) \\<rightarrow>*c (d', t') \\<and>\n                            s' \\<approx> t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 3. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t; (c, s) \\<rightarrow>t s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            (d, t) \\<rightarrow>*t t' \\<and> s' \\<approx> t'", "then"], ["proof (chain)\npicking this:\n  (d, t) \\<rightarrow>*c (if tval tst t then c1 else c2, t) \\<and>\n  s' \\<approx> t \\<and>\n  (\\<phi> c' (if tval tst t then c1 else c2) \\<or>\n   c' \\<approx>wT (if tval tst t then c1 else c2))", "show ?case"], ["proof (prove)\nusing this:\n  (d, t) \\<rightarrow>*c (if tval tst t then c1 else c2, t) \\<and>\n  s' \\<approx> t \\<and>\n  (\\<phi> c' (if tval tst t then c1 else c2) \\<or>\n   c' \\<approx>wT (if tval tst t then c1 else c2))\n\ngoal (1 subgoal):\n 1. \\<exists>d' t'.\n       (d, t) \\<rightarrow>*c (d', t') \\<and>\n       s' \\<approx> t' \\<and> (\\<phi> c' d' \\<or> c' \\<approx>wT d')", "by auto"], ["proof (state)\nthis:\n  \\<exists>d' t'.\n     (d, t) \\<rightarrow>*c (d', t') \\<and>\n     s' \\<approx> t' \\<and> (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n\ngoal (2 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; s \\<approx> t; (c, s) \\<rightarrow>t s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            (d, t) \\<rightarrow>*t t' \\<and> s' \\<approx> t'", "qed (auto simp: \\<phi>_def)"], ["proof (state)\nthis:\n  if tst then c1 else c2 \\<approx>wT if tst then c1 else c2\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nWe instatiate the following notions, kept generic so far:\n\n\\begin{itemize}\n  \\item On the language syntax: \n  \\begin{itemize}\n    \\item atoms, tests and states just like at the possibilistic case; \n    \\item choices, to either if-choices (based on tests) or binary fixed-probability choices; \n    \\item the schedulers, to the uniform one\n  \\end{itemize}\n  \\item On the security semantics, the lattice of levels and the indis relation, again, just like at the possibilistic case. \n\\end{itemize}\n\\<close>"], ["", "datatype level = Lo | Hi"], ["", "lemma [simp]: \"\\<And> l. l \\<noteq> Hi \\<longleftrightarrow> l = Lo\" and \n      [simp]: \"\\<And> l. Hi \\<noteq> l \\<longleftrightarrow> Lo = l\" and \n      [simp]: \"\\<And> l. l \\<noteq> Lo \\<longleftrightarrow> l = Hi\" and \n      [simp]: \"\\<And> l. Lo \\<noteq> l \\<longleftrightarrow> Hi = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>l. (l \\<noteq> Hi) = (l = Lo)) &&&\n     (\\<And>l. (Hi \\<noteq> l) = (Lo = l))) &&&\n    (\\<And>l. (l \\<noteq> Lo) = (l = Hi)) &&&\n    (\\<And>l. (Lo \\<noteq> l) = (Hi = l))", "by (metis level.exhaust level.simps(2))+"], ["", "lemma [dest]: \"\\<And> l A. \\<lbrakk>l \\<in> A; Lo \\<notin> A\\<rbrakk> \\<Longrightarrow> l = Hi\" and \n      [dest]: \"\\<And> l A. \\<lbrakk>l \\<in> A; Hi \\<notin> A\\<rbrakk> \\<Longrightarrow> l = Lo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l A.\n        \\<lbrakk>l \\<in> A; Lo \\<notin> A\\<rbrakk>\n        \\<Longrightarrow> l = Hi) &&&\n    (\\<And>l A.\n        \\<lbrakk>l \\<in> A; Hi \\<notin> A\\<rbrakk> \\<Longrightarrow> l = Lo)", "by (metis level.exhaust)+"], ["", "declare level.split[split]"], ["", "instantiation level :: complete_lattice\nbegin"], ["", "definition top_level: \"top \\<equiv> Hi\""], ["", "definition bot_level: \"bot \\<equiv> Lo\""], ["", "definition inf_level: \"inf l1 l2 \\<equiv> if Lo \\<in> {l1,l2} then Lo else Hi\""], ["", "definition sup_level: \"sup l1 l2 \\<equiv> if Hi \\<in> {l1,l2} then Hi else Lo\""], ["", "definition less_eq_level: \"less_eq l1 l2 \\<equiv> (l1 = Lo \\<or> l2 = Hi)\""], ["", "definition less_level: \"less l1 l2 \\<equiv> l1 = Lo \\<and> l2 = Hi\""], ["", "definition Inf_level: \"Inf L \\<equiv> if Lo \\<in> L then Lo else Hi\""], ["", "definition Sup_level: \"Sup L \\<equiv> if Hi \\<in> L then Hi else Lo\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(level, complete_lattice_class)", "proof"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. inf x y \\<le> x\n 6. \\<And>x y. inf x y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 8. \\<And>x y. x \\<le> sup x y\n 9. \\<And>y x. y \\<le> sup x y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> sup y z \\<le> x\nA total of 16 subgoals...", "qed (auto simp: top_level bot_level inf_level sup_level\n                        less_eq_level less_level Inf_level Sup_level)"], ["", "end"], ["", "lemma sup_eq_Lo[simp]: \"sup a b = Lo \\<longleftrightarrow> a = Lo \\<and> b = Lo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sup a b = Lo) = (a = Lo \\<and> b = Lo)", "by (auto simp: sup_level)"], ["", "datatype var = h | h' | l | l'"], ["", "datatype exp = Ct nat | Var var | Plus exp exp | Minus exp exp"], ["", "datatype test = Tr | Eq exp exp | Gt exp exp | Non test"], ["", "datatype atom = Assign var exp"], ["", "type_synonym state = \"var \\<Rightarrow> nat\""], ["", "syntax\n \"_assign\" :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"  (\"_ ::= _\" [1000, 61] 61)"], ["", "translations\n  \"x ::= expr\" == \"CONST Atm (CONST Assign x expr)\""], ["", "primrec sec where\n  \"sec h  = Hi\"\n| \"sec h' = Hi\"\n| \"sec l  = Lo\"\n| \"sec l' = Lo\""], ["", "fun eval where \n \"eval (Ct n) s = n\"\n|\"eval (Var x) s = s x\"\n|\"eval (Plus e1 e2) s = eval e1 s + eval e2 s\"\n|\"eval (Minus e1 e2) s = eval e1 s - eval e2 s\""], ["", "fun tval where \n \"tval Tr s = True\"\n|\"tval (Eq e1 e2) s = (eval e1 s = eval e2 s)\"\n|\"tval (Gt e1 e2) s = (eval e1 s > eval e2 s)\"\n|\"tval (Non e) s = (\\<not> tval e s)\""], ["", "fun aval where \n\"aval (Assign x e) s = (s (x := eval e s))\""], ["", "definition indis :: \"(state * state) set\"where \n\"indis \\<equiv> {(s,t). ALL x. sec x = Lo \\<longrightarrow> s x = t x}\""], ["", "interpretation Example_PL: PL_Indis tval aval indis"], ["proof (prove)\ngoal (1 subgoal):\n 1. PL_Indis indis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. equiv UNIV indis", "show \"equiv UNIV indis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV indis", "unfolding refl_on_def sym_def trans_def equiv_def indis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({(s, t). \\<forall>x. sec x = Lo \\<longrightarrow> s x = t x}\n     \\<subseteq> UNIV \\<times> UNIV \\<and>\n     (\\<forall>x\\<in>UNIV.\n         (x, x)\n         \\<in> {(s, t).\n                \\<forall>x. sec x = Lo \\<longrightarrow> s x = t x})) \\<and>\n    (\\<forall>x y.\n        (x, y)\n        \\<in> {(s, t).\n               \\<forall>x.\n                  sec x = Lo \\<longrightarrow> s x = t x} \\<longrightarrow>\n        (y, x)\n        \\<in> {(s, t).\n               \\<forall>x. sec x = Lo \\<longrightarrow> s x = t x}) \\<and>\n    (\\<forall>x y z.\n        (x, y)\n        \\<in> {(s, t).\n               \\<forall>x.\n                  sec x = Lo \\<longrightarrow> s x = t x} \\<longrightarrow>\n        (y, z)\n        \\<in> {(s, t).\n               \\<forall>x.\n                  sec x = Lo \\<longrightarrow> s x = t x} \\<longrightarrow>\n        (x, z)\n        \\<in> {(s, t). \\<forall>x. sec x = Lo \\<longrightarrow> s x = t x})", "by auto"], ["proof (state)\nthis:\n  equiv UNIV indis\n\ngoal:\nNo subgoals!", "qed"], ["", "fun exprSec where \n \"exprSec (Ct n) = bot\"\n|\"exprSec (Var x) = sec x\"\n|\"exprSec (Plus e1 e2) = sup (exprSec e1) (exprSec e2)\"\n|\"exprSec (Minus e1 e2) = sup (exprSec e1) (exprSec e2)\""], ["", "fun tstSec where \n \"tstSec Tr = bot\"\n|\"tstSec (Eq e1 e2) = sup (exprSec e1) (exprSec e2)\"\n|\"tstSec (Gt e1 e2) = sup (exprSec e1) (exprSec e2)\"\n|\"tstSec (Non e) = tstSec e\""], ["", "lemma exprSec_Lo_eval_eq: \"exprSec expr = Lo \\<Longrightarrow> (s, t) \\<in> indis \\<Longrightarrow> eval expr s = eval expr t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exprSec expr = Lo; Example_PL.indisAbbrev s t\\<rbrakk>\n    \\<Longrightarrow> eval expr s = eval expr t", "by (induct expr) (auto simp: indis_def)"], ["", "lemma compatAtmSyntactic[simp]: \"exprSec expr = Lo \\<or> sec v = Hi \\<Longrightarrow> Example_PL.compatAtm (Assign v expr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exprSec expr = Lo \\<or> sec v = Hi \\<Longrightarrow>\n    Example_PL.compatAtm (Assign v expr)", "unfolding Example_PL.compatAtm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exprSec expr = Lo \\<or> sec v = Hi \\<Longrightarrow>\n    \\<forall>s t.\n       Example_PL.indisAbbrev s t \\<longrightarrow>\n       Example_PL.indisAbbrev (aval (Assign v expr) s)\n        (aval (Assign v expr) t)", "by (induct expr)\n     (auto simp: indis_def intro!: arg_cong2[where f=\"(+)\"] arg_cong2[where f=\"(-)\"] exprSec_Lo_eval_eq)"], ["", "lemma presAtmSyntactic[simp]: \"sec v = Hi \\<Longrightarrow> Example_PL.presAtm (Assign v expr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sec v = Hi \\<Longrightarrow> Example_PL.presAtm (Assign v expr)", "unfolding Example_PL.presAtm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sec v = Hi \\<Longrightarrow>\n    \\<forall>s. Example_PL.indisAbbrev s (aval (Assign v expr) s)", "by (simp add: indis_def)"], ["", "lemma compatTstSyntactic[simp]: \"tstSec tst = Lo \\<Longrightarrow> Example_PL.compatTst tst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tstSec tst = Lo \\<Longrightarrow> Example_PL.compatTst tst", "unfolding Example_PL.compatTst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tstSec tst = Lo \\<Longrightarrow>\n    \\<forall>s t.\n       Example_PL.indisAbbrev s t \\<longrightarrow> tval tst s = tval tst t", "by (induct tst)\n     (simp_all, safe del: iffI\n              intro!: arg_cong2[where f=\"(=)\"] arg_cong2[where f=\"(<) :: nat \\<Rightarrow> nat \\<Rightarrow> bool\"] exprSec_Lo_eval_eq)"], ["", "lemma \"Example_PL.SC_discr (h ::= Ct 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Example_PL.SC_discr (h ::= Ct 0)", "by (simp add: Example_PL.SC_discr.simps)"], ["", "abbreviation \"siso c \\<equiv> Example_PL.siso c\""], ["", "abbreviation \"siso0 c \\<equiv> Example_PL.siso0 c\""], ["", "abbreviation \"discr c \\<equiv> Example_PL.discr c\""], ["", "abbreviation \"discr0 c \\<equiv> Example_PL.discr0 c\""], ["", "abbreviation Sbis_abbrev (infix \"\\<approx>s\" 55) where \"c1 \\<approx>s c2 \\<equiv> (c1,c2) \\<in> Example_PL.Sbis\""], ["", "abbreviation ZObis_abbrev (infix \"\\<approx>01\" 55) where \"c1 \\<approx>01 c2 \\<equiv> (c1,c2) \\<in> Example_PL.ZObis\""], ["", "abbreviation ZObisT_abbrev (infix \"\\<approx>01T\" 55) where \"c1 \\<approx>01T c2 \\<equiv> (c1,c2) \\<in> Example_PL.ZObisT\""], ["", "abbreviation Wbis_abbrev (infix \"\\<approx>w\" 55) where \"c1 \\<approx>w c2 \\<equiv> (c1,c2) \\<in> Example_PL.Wbis\""], ["", "abbreviation WbisT_abbrev (infix \"\\<approx>wT\" 55) where \"c1 \\<approx>wT c2 \\<equiv> (c1,c2) \\<in> Example_PL.WbisT\""], ["", "abbreviation BisT_abbrev (infix \"\\<approx>T\" 55) where \"c1 \\<approx>T c2 \\<equiv> (c1,c2) \\<in> Example_PL.BisT\""], ["", "subsection \\<open>Programs from EXAMPLE 1\\<close>"], ["", "definition [simp]: \"c0 = (h ::= Ct 0)\""], ["", "definition [simp]: \"c1 = (if Eq (Var l) (Ct 0) then h ::= Ct 1 else l ::= Ct 2)\""], ["", "definition [simp]: \"c2 = (if Eq (Var h) (Ct 0) then h ::= Ct 1 else h ::= Ct 2)\""], ["", "definition [simp]: \"c3 = (if Eq (Var h) (Ct 0) then h ::= Ct 1 ;; h ::= Ct 2\n                                         else h ::= Ct 3)\""], ["", "definition [simp]: \"c4 = l ::= Ct 4 ;; c3\""], ["", "definition [simp]: \"c5 = c3 ;; l ::= Ct 4\""], ["", "definition [simp]: \"c6 = l ::= Var h\""], ["", "definition [simp]: \"c7 = l ::= Var h ;; l ::= Ct 0\""], ["", "definition [simp]: \"c8 = h' ::= Var h ;;\n  while Gt (Var h) (Ct 0) do (h ::= Minus (Var h) (Ct 1) ;; h' ::= Plus (Var h') (Ct 1)) ;;\n  l ::= Ct 4\""], ["", "definition [simp]: \"c9 = c7 | l' ::= Var l\""], ["", "definition [simp]: \"c10 = c5 | l ::= Ct 5\""], ["", "definition [simp]: \"c11 = c8 | l ::= Ct 5\""], ["", "declare bot_level[iff]"], ["", "theorem c0: \"siso c0\" \"discr c0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. siso c0 &&& discr c0", "by auto"], ["", "theorem c1: \"siso c1\" \"c1 \\<approx>s c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. siso c1 &&& c1 \\<approx>s c1", "by auto"], ["", "theorem c2: \"discr c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discr c2", "by auto"], ["", "theorem Sbis_c2: \"c2 \\<approx>s c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 \\<approx>s c2", "oops"], ["", "theorem c3: \"discr c3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discr c3", "by auto"], ["", "theorem c4: \"c4 \\<approx>01 c4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c4 \\<approx>01 c4", "by auto"], ["", "theorem c5: \"c5 \\<approx>w c5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c5 \\<approx>w c5", "by auto"], ["", "text\\<open>Example 4 from the paper\\<close>"], ["", "theorem \"c3 \\<approx>wT c3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c3 \\<approx>wT c3", "by auto"], ["", "theorem \"c5 \\<approx>wT c5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c5 \\<approx>wT c5", "by auto"], ["", "corollary \"discr (while Eq (Var h) (Ct 0)  do h ::= Ct 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discr (while Eq (Var h) (Ct 0) do h ::= Ct 0)", "by auto"], ["", "text\\<open>Example 5 from the paper\\<close>"], ["", "definition [simp]: \"c12 \\<equiv> h ::= Ct 4 ;;\n  while Gt (Var h) (Ct 0)\n    do (h ::= Minus (Var h) (Ct 1) ;; h' ::= Plus (Var h') (Ct 1)) ;;\n  l ::= Ct 1\""], ["", "corollary \"(c12 | l ::= Ct 2) \\<approx>T (c12 | l ::= Ct 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c12 | l ::= Ct 2 \\<approx>T c12 | l ::= Ct 2", "by auto"], ["", "definition [simp]: \"c13 =\n  (if Eq (Var h) (Ct 0) then h ::= Ct 1 ;; l ::= Ct 2 else l ::= Ct 2) ;; l' ::= Ct 4\""], ["", "lemma c13_inner:\n  \"(h ::= Ct 1 ;; l ::= Ct 2) \\<approx>wT (l ::= Ct 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ::= Ct 1 ;; l ::= Ct 2 \\<approx>wT l ::= Ct 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h ::= Ct 1 ;; l ::= Ct 2 \\<approx>wT l ::= Ct 2", "define \\<phi> where \"\\<phi> =\n    (\\<lambda>(c :: (test, atom) com) (d :: (test, atom) com).\n      c = h ::= Ct 1 ;; l ::= Ct 2 \\<and> d = l ::= Ct 2 \\<or>\n      d = h ::= Ct 1 ;; l ::= Ct 2 \\<and> c = l ::= Ct 2)\""], ["proof (state)\nthis:\n  \\<phi> =\n  (\\<lambda>c d.\n      c = h ::= Ct 1 ;; l ::= Ct 2 \\<and> d = l ::= Ct 2 \\<or>\n      d = h ::= Ct 1 ;; l ::= Ct 2 \\<and> c = l ::= Ct 2)\n\ngoal (1 subgoal):\n 1. h ::= Ct 1 ;; l ::= Ct 2 \\<approx>wT l ::= Ct 2", "then"], ["proof (chain)\npicking this:\n  \\<phi> =\n  (\\<lambda>c d.\n      c = h ::= Ct 1 ;; l ::= Ct 2 \\<and> d = l ::= Ct 2 \\<or>\n      d = h ::= Ct 1 ;; l ::= Ct 2 \\<and> c = l ::= Ct 2)", "have \"\\<phi> (h ::= Ct 1 ;; l ::= Ct 2) (l ::= Ct 2)\""], ["proof (prove)\nusing this:\n  \\<phi> =\n  (\\<lambda>c d.\n      c = h ::= Ct 1 ;; l ::= Ct 2 \\<and> d = l ::= Ct 2 \\<or>\n      d = h ::= Ct 1 ;; l ::= Ct 2 \\<and> c = l ::= Ct 2)\n\ngoal (1 subgoal):\n 1. \\<phi> (h ::= Ct 1 ;; l ::= Ct 2) (l ::= Ct 2)", "by auto"], ["proof (state)\nthis:\n  \\<phi> (h ::= Ct 1 ;; l ::= Ct 2) (l ::= Ct 2)\n\ngoal (1 subgoal):\n 1. h ::= Ct 1 ;; l ::= Ct 2 \\<approx>wT l ::= Ct 2", "then"], ["proof (chain)\npicking this:\n  \\<phi> (h ::= Ct 1 ;; l ::= Ct 2) (l ::= Ct 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> (h ::= Ct 1 ;; l ::= Ct 2) (l ::= Ct 2)\n\ngoal (1 subgoal):\n 1. h ::= Ct 1 ;; l ::= Ct 2 \\<approx>wT l ::= Ct 2", "proof (induct rule: Example_PL.WbisT_coinduct[where \\<phi>=\\<phi>])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transC (c, s) (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            Example_PL.MtransC (d, t) (d', t') \\<and>\n                            Example_PL.indisAbbrev s' t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 3. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transT (c, s) s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            Example_PL.MtransT (d, t) t' \\<and>\n                            Example_PL.indisAbbrev s' t'", "case sym"], ["proof (state)\nthis:\n  \\<phi> c_ d_\n\ngoal (3 subgoals):\n 1. \\<And>c d. \\<phi> c d \\<Longrightarrow> \\<phi> d c\n 2. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transC (c, s) (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            Example_PL.MtransC (d, t) (d', t') \\<and>\n                            Example_PL.indisAbbrev s' t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 3. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transT (c, s) s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            Example_PL.MtransT (d, t) t' \\<and>\n                            Example_PL.indisAbbrev s' t'", "then"], ["proof (chain)\npicking this:\n  \\<phi> c_ d_", "show ?case"], ["proof (prove)\nusing this:\n  \\<phi> c_ d_\n\ngoal (1 subgoal):\n 1. \\<phi> d_ c_", "by (auto simp add: \\<phi>_def)"], ["proof (state)\nthis:\n  \\<phi> d_ c_\n\ngoal (2 subgoals):\n 1. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transC (c, s) (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            Example_PL.MtransC (d, t) (d', t') \\<and>\n                            Example_PL.indisAbbrev s' t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 2. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transT (c, s) s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            Example_PL.MtransT (d, t) t' \\<and>\n                            Example_PL.indisAbbrev s' t'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transC (c, s) (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            Example_PL.MtransC (d, t) (d', t') \\<and>\n                            Example_PL.indisAbbrev s' t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 2. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transT (c, s) s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            Example_PL.MtransT (d, t) t' \\<and>\n                            Example_PL.indisAbbrev s' t'", "case (cont c s d t c' s')"], ["proof (state)\nthis:\n  \\<phi> c d\n  Example_PL.indisAbbrev s t\n  Example_PL.transC (c, s) (c', s')\n\ngoal (2 subgoals):\n 1. \\<And>c s d t c' s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transC (c, s) (c', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d' t'.\n                            Example_PL.MtransC (d, t) (d', t') \\<and>\n                            Example_PL.indisAbbrev s' t' \\<and>\n                            (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n 2. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transT (c, s) s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            Example_PL.MtransT (d, t) t' \\<and>\n                            Example_PL.indisAbbrev s' t'", "then"], ["proof (chain)\npicking this:\n  \\<phi> c d\n  Example_PL.indisAbbrev s t\n  Example_PL.transC (c, s) (c', s')", "show ?case"], ["proof (prove)\nusing this:\n  \\<phi> c d\n  Example_PL.indisAbbrev s t\n  Example_PL.transC (c, s) (c', s')\n\ngoal (1 subgoal):\n 1. \\<exists>d' t'.\n       Example_PL.MtransC (d, t) (d', t') \\<and>\n       Example_PL.indisAbbrev s' t' \\<and>\n       (\\<phi> c' d' \\<or> c' \\<approx>wT d')", "by (auto simp add: \\<phi>_def intro!: exI[of _ \"l ::= Ct 2\"] exI[of _ t])\n         (auto simp: indis_def)"], ["proof (state)\nthis:\n  \\<exists>d' t'.\n     Example_PL.MtransC (d, t) (d', t') \\<and>\n     Example_PL.indisAbbrev s' t' \\<and>\n     (\\<phi> c' d' \\<or> c' \\<approx>wT d')\n\ngoal (1 subgoal):\n 1. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transT (c, s) s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            Example_PL.MtransT (d, t) t' \\<and>\n                            Example_PL.indisAbbrev s' t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transT (c, s) s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            Example_PL.MtransT (d, t) t' \\<and>\n                            Example_PL.indisAbbrev s' t'", "have exec:\n        \"\\<And>t. Example_PL.MtransT (h ::= Ct 1 ;; l ::= Ct 2, t) (aval (Assign l (Ct 2)) (aval (Assign h (Ct 1)) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       Example_PL.MtransT (h ::= Ct 1 ;; l ::= Ct 2, t)\n        (aval (Assign l (Ct 2)) (aval (Assign h (Ct 1)) t))", "by (simp del: aval.simps)\n           (blast intro: Example_PL.transC_MtransT Example_PL.transC_MtransC.SeqT Example_PL.transT.Atm Example_PL.transT_MtransT)"], ["proof (state)\nthis:\n  Example_PL.MtransT (h ::= Ct 1 ;; l ::= Ct 2, ?t)\n   (aval (Assign l (Ct 2)) (aval (Assign h (Ct 1)) ?t))\n\ngoal (1 subgoal):\n 1. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transT (c, s) s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            Example_PL.MtransT (d, t) t' \\<and>\n                            Example_PL.indisAbbrev s' t'", "case (termi c s d t s')"], ["proof (state)\nthis:\n  \\<phi> c d\n  Example_PL.indisAbbrev s t\n  Example_PL.transT (c, s) s'\n\ngoal (1 subgoal):\n 1. \\<And>c s d t s'.\n       \\<lbrakk>\\<phi> c d; Example_PL.indisAbbrev s t;\n        Example_PL.transT (c, s) s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            Example_PL.MtransT (d, t) t' \\<and>\n                            Example_PL.indisAbbrev s' t'", "with exec"], ["proof (chain)\npicking this:\n  Example_PL.MtransT (h ::= Ct 1 ;; l ::= Ct 2, ?t)\n   (aval (Assign l (Ct 2)) (aval (Assign h (Ct 1)) ?t))\n  \\<phi> c d\n  Example_PL.indisAbbrev s t\n  Example_PL.transT (c, s) s'", "show ?case"], ["proof (prove)\nusing this:\n  Example_PL.MtransT (h ::= Ct 1 ;; l ::= Ct 2, ?t)\n   (aval (Assign l (Ct 2)) (aval (Assign h (Ct 1)) ?t))\n  \\<phi> c d\n  Example_PL.indisAbbrev s t\n  Example_PL.transT (c, s) s'\n\ngoal (1 subgoal):\n 1. \\<exists>t'.\n       Example_PL.MtransT (d, t) t' \\<and> Example_PL.indisAbbrev s' t'", "by (auto simp add: \\<phi>_def intro!: exI[of _ \"t (h := 1, l := 2)\"])\n         (auto simp: indis_def)"], ["proof (state)\nthis:\n  \\<exists>t'.\n     Example_PL.MtransT (d, t) t' \\<and> Example_PL.indisAbbrev s' t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h ::= Ct 1 ;; l ::= Ct 2 \\<approx>wT l ::= Ct 2\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem \"c13 \\<approx>wT c13\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c13 \\<approx>wT c13", "using c13_inner"], ["proof (prove)\nusing this:\n  h ::= Ct 1 ;; l ::= Ct 2 \\<approx>wT l ::= Ct 2\n\ngoal (1 subgoal):\n 1. c13 \\<approx>wT c13", "by (auto intro!: Example_PL.Seq_WbisT Example_PL.WbisT_If_cross)"], ["", "end"]]}