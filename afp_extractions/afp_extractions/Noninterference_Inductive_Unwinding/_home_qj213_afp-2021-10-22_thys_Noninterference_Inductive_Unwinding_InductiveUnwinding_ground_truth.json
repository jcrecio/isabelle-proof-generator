{"file_name": "/home/qj213/afp-2021-10-22/thys/Noninterference_Inductive_Unwinding/InductiveUnwinding.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Noninterference_Inductive_Unwinding", "problem_names": ["lemma sources_aux_single_dom:\n \"sources_aux I D {u} xs = insert u (sources I D u xs)\"", "lemma sources_interference_eq:\n \"((D x, u) \\<in> I \\<or> (\\<exists>v \\<in> sources I D u xs. (D x, v) \\<in> I)) =\n  (D x \\<in> sources I D u (x # xs))\"", "lemma ex_sinks_sources_aux_1 [rule_format]:\n \"(\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D V xs. (u, v) \\<in> I)\"", "lemma ex_sinks_sources_aux_2 [rule_format]:\n \"(\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D V xs. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I)\"", "lemma ex_sinks_sources_aux:\n \"(\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I) =\n  (\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D V xs. (u, v) \\<in> I)\"", "lemma ipurge_tr_rev_ipurge_tr_sources_aux_1 [rule_format]:\n \"\\<not> (\\<exists>v \\<in> D ` set ys. \\<exists>u \\<in> sources_aux I D U zs. (v, u) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\"", "lemma ipurge_tr_rev_ipurge_tr_sources_1:\n  assumes A: \"D y \\<notin> sources I D u (y # zs)\"\n  shows\n   \"ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)\"", "lemma ipurge_tr_length:\n \"length (ipurge_tr I D u xs) \\<le> length xs\"", "lemma sources_idem:\n \"sources I D u (ipurge_tr_rev I D u xs) = sources I D u xs\"", "lemma ipurge_tr_rev_idem:\n \"ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs\"", "lemma ipurge_tr_rev_t_subset:\n  assumes A: \"Y \\<in> ipurge_tr_rev_t_set X\"\n  shows \"ipurge_tr_rev_t_set Y \\<subseteq> ipurge_tr_rev_t_set X\"", "lemma ipurge_tr_rev_t_aux_set:\n \"ipurge_tr_rev_t_aux X \\<in> ipurge_tr_rev_t_set X\"", "lemma ipurge_tr_rev_t_input_1:\n \"ipurge_tr_rev_t_inv_1 I D u xs \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\"", "lemma ipurge_tr_rev_t_input_2:\n \"ipurge_tr_rev_t_inv_2 P I D xs \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\"", "lemma ipurge_tr_rev_t_intro_1:\n \"\\<lbrakk>ipurge_tr_rev_t_inv_1 I D u xs X; ipurge_tr_rev_t_form X\\<rbrakk> \\<Longrightarrow>\n  ipurge_tr_rev_t_out X = ipurge_tr_rev I D u xs\"", "lemma ipurge_tr_rev_t_intro_2:\n \"\\<lbrakk>ipurge_tr_rev_t_inv_2 P I D xs X; ipurge_tr_rev_t_form X\\<rbrakk> \\<Longrightarrow>\n  secure P I D \\<longrightarrow> xs \\<in> traces P \\<longrightarrow> ipurge_tr_rev_t_out X \\<in> traces P\"", "lemma ipurge_tr_rev_t_form_aux:\n \"ipurge_tr_rev_t_form (ipurge_tr_rev_t_aux X)\"", "lemma ipurge_tr_rev_t_invariance_aux:\n \"Y \\<in> ipurge_tr_rev_t_set X \\<Longrightarrow>\n  Pol Y = Pol X \\<and> Map Y = Map X \\<and> Dom Y = Dom X\"", "lemma ipurge_tr_rev_t_invariance_1:\n \"\\<lbrakk>Y \\<in> ipurge_tr_rev_t_set (X\\<lparr>Pol := I, Map := D, Dom := u\\<rparr>);\n    ipurge_tr_rev_t_inv_1 I D u ws (X\\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\\<rbrakk> \\<Longrightarrow>\n  ipurge_tr_rev_t_inv_1 I D u ws Y\"", "lemma ipurge_tr_rev_t_invariance_2:\n \"\\<lbrakk>Y \\<in> ipurge_tr_rev_t_set (X\\<lparr>Pol := I, Map := D\\<rparr>);\n    ipurge_tr_rev_t_inv_2 P I D ws (X\\<lparr>Pol := I, Map := D\\<rparr>)\\<rbrakk> \\<Longrightarrow>\n  ipurge_tr_rev_t_inv_2 P I D ws Y\"", "lemma ipurge_tr_rev_t_equiv:\n \"ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs\"", "lemma ipurge_tr_rev_t_trace [rule_format]:\n \"secure P I D \\<longrightarrow> xs \\<in> traces P \\<longrightarrow> ipurge_tr_rev_t I D u xs \\<in> traces P\"", "lemma ipurge_tr_rev_trace:\n \"secure P I D \\<Longrightarrow> xs \\<in> traces P \\<Longrightarrow> ipurge_tr_rev I D u xs \\<in> traces P\"", "lemma inductive_unwinding_1:\n  assumes\n    R: \"ref_union_closed P\" and\n    S: \"secure P I D\"\n  shows \"\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\"", "lemma inductive_unwinding_2:\n  assumes\n    R: \"ref_union_closed P\" and\n    S: \"\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n      next_dom_events P D u (ipurge_tr_rev I D u xs) =\n        next_dom_events P D u xs \\<and>\n      ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n        ref_dom_events P D u xs\"\n  shows \"secure P I D\"", "theorem inductive_unwinding:\n \"ref_union_closed P \\<Longrightarrow>\n  secure P I D =\n  (\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs)\"", "lemma d_inductive_unwinding_1:\n  assumes\n    D: \"deterministic P\" and\n    S: \"secure P I D\"\n  shows \"\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\"", "lemma d_inductive_unwinding_2:\n  assumes\n    D: \"deterministic P\" and\n    S: \"\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n      next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\"\n  shows \"secure P I D\"", "theorem d_inductive_unwinding:\n \"deterministic P \\<Longrightarrow>\n  secure P I D =\n  (\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs)\"", "theorem ts_inductive_unwinding:\n  assumes T: \"trace_set T\"\n  shows \"secure (ts_process T) I D =\n    (\\<forall>xs \\<in> T. \\<forall>u \\<in> range D \\<inter> (-I) `` range D. \\<forall>x \\<in> D -` {u}.\n      (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T))\"\n    (is \"secure ?P I D = _\")"], "translations": [["", "lemma sources_aux_single_dom:\n \"sources_aux I D {u} xs = insert u (sources I D u xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sources_aux I D {u} xs = insert u (sources I D u xs)", "by (simp add: sources_sinks sources_sinks_aux sinks_aux_single_dom)"], ["", "lemma sources_interference_eq:\n \"((D x, u) \\<in> I \\<or> (\\<exists>v \\<in> sources I D u xs. (D x, v) \\<in> I)) =\n  (D x \\<in> sources I D u (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((D x, u) \\<in> I \\<or>\n     (\\<exists>v\\<in>sources I D u xs. (D x, v) \\<in> I)) =\n    (D x \\<in> sources I D u (x # xs))", "proof (simp only: sources_sinks rev.simps, subst (1 2) converse_iff [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. ((u, D x) \\<in> I\\<inverse> \\<or>\n     (\\<exists>v\\<in>sinks (I\\<inverse>) D u (rev xs).\n         (v, D x) \\<in> I\\<inverse>)) =\n    (D x \\<in> sinks (I\\<inverse>) D u (rev xs @ [x]))", "qed (rule sinks_interference_eq)"], ["", "lemma ex_sinks_sources_aux_1 [rule_format]:\n \"(\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D V xs. (u, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>sinks_aux I D U xs.\n        \\<exists>v\\<in>V. (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I)", "proof (induction xs arbitrary: V rule: rev_induct, simp, subst sources_aux_append,\n rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs V.\n       \\<lbrakk>\\<And>V.\n                   (\\<exists>u\\<in>sinks_aux I D U xs.\n                       \\<exists>v\\<in>V. (u, v) \\<in> I) \\<longrightarrow>\n                   (\\<exists>u\\<in>U.\n                       \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I);\n        \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n           \\<exists>v\\<in>V. (u, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>U.\n                            \\<exists>v\\<in>sources_aux I D\n      (sources_aux I D V [x]) xs.\n                               (u, v) \\<in> I", "fix x xs V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs V.\n       \\<lbrakk>\\<And>V.\n                   (\\<exists>u\\<in>sinks_aux I D U xs.\n                       \\<exists>v\\<in>V. (u, v) \\<in> I) \\<longrightarrow>\n                   (\\<exists>u\\<in>U.\n                       \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I);\n        \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n           \\<exists>v\\<in>V. (u, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>U.\n                            \\<exists>v\\<in>sources_aux I D\n      (sources_aux I D V [x]) xs.\n                               (u, v) \\<in> I", "let\n    ?V = \"sources_aux I D V [x]\" and\n    ?V' = \"insert (D x) V\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs V.\n       \\<lbrakk>\\<And>V.\n                   (\\<exists>u\\<in>sinks_aux I D U xs.\n                       \\<exists>v\\<in>V. (u, v) \\<in> I) \\<longrightarrow>\n                   (\\<exists>u\\<in>U.\n                       \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I);\n        \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n           \\<exists>v\\<in>V. (u, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>U.\n                            \\<exists>v\\<in>sources_aux I D\n      (sources_aux I D V [x]) xs.\n                               (u, v) \\<in> I", "assume\n    A: \"\\<And>V. (\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I) \\<longrightarrow>\n      (\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D V xs. (u, v) \\<in> I)\" and\n    B: \"\\<exists>u \\<in> sinks_aux I D U (xs @ [x]). \\<exists>v \\<in> V. (u, v) \\<in> I\""], ["proof (state)\nthis:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>?V. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D ?V xs. (u, v) \\<in> I)\n  \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n     \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>x xs V.\n       \\<lbrakk>\\<And>V.\n                   (\\<exists>u\\<in>sinks_aux I D U xs.\n                       \\<exists>v\\<in>V. (u, v) \\<in> I) \\<longrightarrow>\n                   (\\<exists>u\\<in>U.\n                       \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I);\n        \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n           \\<exists>v\\<in>V. (u, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>U.\n                            \\<exists>v\\<in>sources_aux I D\n      (sources_aux I D V [x]) xs.\n                               (u, v) \\<in> I", "show \"\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D ?V xs. (u, v) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "proof (cases \"\\<exists>u \\<in> sinks_aux I D U xs. (u, D x) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "hence \"(\\<exists>v \\<in> V. (D x, v) \\<in> I) \\<or>\n      (\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I)\"\n     (is \"?A \\<or> ?B\")"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<exists>v\\<in>V. (D x, v) \\<in> I) \\<or>\n    (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)", "using B"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n  \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n     \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<exists>v\\<in>V. (D x, v) \\<in> I) \\<or>\n    (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>v\\<in>V. (D x, v) \\<in> I) \\<or>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "moreover"], ["proof (state)\nthis:\n  (\\<exists>v\\<in>V. (D x, v) \\<in> I) \\<or>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "{"], ["proof (state)\nthis:\n  (\\<exists>v\\<in>V. (D x, v) \\<in> I) \\<or>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "assume ?A"], ["proof (state)\nthis:\n  \\<exists>v\\<in>V. (D x, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "have \"(\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> ?V'. (u, v) \\<in> I) \\<longrightarrow>\n        (\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D ?V' xs. (u, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>sinks_aux I D U xs.\n        \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D (insert (D x) V) xs. (u, v) \\<in> I)", "using A"], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>?V. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D ?V xs. (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>sinks_aux I D U xs.\n        \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D (insert (D x) V) xs. (u, v) \\<in> I)", "."], ["proof (state)\nthis:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (insert (D x) V) xs. (u, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "moreover"], ["proof (state)\nthis:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (insert (D x) V) xs. (u, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "obtain u where\n        C: \"u \\<in> sinks_aux I D U xs\" and D: \"(u, D x) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux I D U xs; (u, D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using True"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux I D U xs; (u, D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U xs\n  (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "have \"D x \\<in> ?V'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x \\<in> insert (D x) V", "by simp"], ["proof (state)\nthis:\n  D x \\<in> insert (D x) V\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "with D"], ["proof (chain)\npicking this:\n  (u, D x) \\<in> I\n  D x \\<in> insert (D x) V", "have \"\\<exists>v \\<in> ?V'. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I\n  D x \\<in> insert (D x) V\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "hence \"\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> ?V'. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs.\n       \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs.\n       \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "ultimately"], ["proof (chain)\npicking this:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (insert (D x) V) xs. (u, v) \\<in> I)\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I", "have \"\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D ?V' xs. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (insert (D x) V) xs. (u, v) \\<in> I)\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>insert (D x) V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (insert (D x) V) xs. (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (insert (D x) V) xs. (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "hence ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (insert (D x) V) xs. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "using \\<open>?A\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (insert (D x) V) xs. (u, v) \\<in> I\n  \\<exists>v\\<in>V. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "}"], ["proof (state)\nthis:\n  \\<exists>v\\<in>V. (D x, v) \\<in> I \\<Longrightarrow>\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "moreover"], ["proof (state)\nthis:\n  \\<exists>v\\<in>V. (D x, v) \\<in> I \\<Longrightarrow>\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "{"], ["proof (state)\nthis:\n  \\<exists>v\\<in>V. (D x, v) \\<in> I \\<Longrightarrow>\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "assume ?B"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "have \"(\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> ?V. (u, v) \\<in> I) \\<longrightarrow>\n        (\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D ?V xs. (u, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>sinks_aux I D U xs.\n        \\<exists>v\\<in>sources_aux I D V [x].\n           (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n           (u, v) \\<in> I)", "using A"], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>?V. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D ?V xs. (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>sinks_aux I D U xs.\n        \\<exists>v\\<in>sources_aux I D V [x].\n           (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n           (u, v) \\<in> I)", "."], ["proof (state)\nthis:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x].\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "moreover"], ["proof (state)\nthis:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x].\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "obtain u where\n        C: \"u \\<in> sinks_aux I D U xs\" and D: \"\\<exists>v \\<in> V. (u, v) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux I D U xs;\n         \\<exists>v\\<in>V. (u, v) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>?B\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux I D U xs;\n         \\<exists>v\\<in>V. (u, v) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U xs\n  \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "have \"V \\<subseteq> ?V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> sources_aux I D V [x]", "by (rule sources_aux_subset)"], ["proof (state)\nthis:\n  V \\<subseteq> sources_aux I D V [x]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "hence \"\\<exists>v \\<in> ?V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  V \\<subseteq> sources_aux I D V [x]\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", "using D"], ["proof (prove)\nusing this:\n  V \\<subseteq> sources_aux I D V [x]\n  \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "hence \"\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> ?V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs.\n       \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs.\n       \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "ultimately"], ["proof (chain)\npicking this:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x].\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I)\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", "have ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x].\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I)\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "}"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>V. (u, v) \\<in> I \\<Longrightarrow>\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "ultimately"], ["proof (chain)\npicking this:\n  (\\<exists>v\\<in>V. (D x, v) \\<in> I) \\<or>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)\n  \\<exists>v\\<in>V. (D x, v) \\<in> I \\<Longrightarrow>\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>V. (u, v) \\<in> I \\<Longrightarrow>\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>v\\<in>V. (D x, v) \\<in> I) \\<or>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)\n  \\<exists>v\\<in>V. (D x, v) \\<in> I \\<Longrightarrow>\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>V. (u, v) \\<in> I \\<Longrightarrow>\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "have \"(\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> ?V. (u, v) \\<in> I) \\<longrightarrow>\n      (\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D ?V xs. (u, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>sinks_aux I D U xs.\n        \\<exists>v\\<in>sources_aux I D V [x].\n           (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n           (u, v) \\<in> I)", "using A"], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>?V. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D ?V xs. (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>sinks_aux I D U xs.\n        \\<exists>v\\<in>sources_aux I D V [x].\n           (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n           (u, v) \\<in> I)", "."], ["proof (state)\nthis:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x].\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "moreover"], ["proof (state)\nthis:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x].\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "have \"\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "using B and False"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n     \\<exists>v\\<in>V. (u, v) \\<in> I\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "obtain u where\n      C: \"u \\<in> sinks_aux I D U xs\" and D: \"\\<exists>v \\<in> V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux I D U xs;\n         \\<exists>v\\<in>V. (u, v) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U xs\n  \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "have \"V \\<subseteq> ?V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> sources_aux I D V [x]", "by (rule sources_aux_subset)"], ["proof (state)\nthis:\n  V \\<subseteq> sources_aux I D V [x]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "hence \"\\<exists>v \\<in> ?V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  V \\<subseteq> sources_aux I D V [x]\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", "using D"], ["proof (prove)\nusing this:\n  V \\<subseteq> sources_aux I D V [x]\n  \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "hence \"\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> ?V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs.\n       \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs.\n       \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", "ultimately"], ["proof (chain)\npicking this:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x].\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I)\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x].\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I)\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U.\n       \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n          (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_sinks_sources_aux_2 [rule_format]:\n \"(\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D V xs. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D V xs.\n           (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)", "proof (induction xs arbitrary: V rule: rev_induct, simp, subst sources_aux_append,\n rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs V.\n       \\<lbrakk>\\<And>V.\n                   (\\<exists>u\\<in>U.\n                       \\<exists>v\\<in>sources_aux I D V xs.\n                          (u, v) \\<in> I) \\<longrightarrow>\n                   (\\<exists>u\\<in>sinks_aux I D U xs.\n                       \\<exists>v\\<in>V. (u, v) \\<in> I);\n        \\<exists>u\\<in>U.\n           \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n              (u, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n                            \\<exists>v\\<in>V. (u, v) \\<in> I", "fix x xs V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs V.\n       \\<lbrakk>\\<And>V.\n                   (\\<exists>u\\<in>U.\n                       \\<exists>v\\<in>sources_aux I D V xs.\n                          (u, v) \\<in> I) \\<longrightarrow>\n                   (\\<exists>u\\<in>sinks_aux I D U xs.\n                       \\<exists>v\\<in>V. (u, v) \\<in> I);\n        \\<exists>u\\<in>U.\n           \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n              (u, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n                            \\<exists>v\\<in>V. (u, v) \\<in> I", "let\n    ?V = \"sources_aux I D V [x]\" and\n    ?V' = \"insert (D x) V\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs V.\n       \\<lbrakk>\\<And>V.\n                   (\\<exists>u\\<in>U.\n                       \\<exists>v\\<in>sources_aux I D V xs.\n                          (u, v) \\<in> I) \\<longrightarrow>\n                   (\\<exists>u\\<in>sinks_aux I D U xs.\n                       \\<exists>v\\<in>V. (u, v) \\<in> I);\n        \\<exists>u\\<in>U.\n           \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n              (u, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n                            \\<exists>v\\<in>V. (u, v) \\<in> I", "assume\n    A: \"\\<And>V. (\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D V xs. (u, v) \\<in> I) \\<longrightarrow>\n      (\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I)\" and\n    B: \"\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D ?V xs. (u, v) \\<in> I\""], ["proof (state)\nthis:\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D ?V xs.\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>?V. (u, v) \\<in> I)\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>x xs V.\n       \\<lbrakk>\\<And>V.\n                   (\\<exists>u\\<in>U.\n                       \\<exists>v\\<in>sources_aux I D V xs.\n                          (u, v) \\<in> I) \\<longrightarrow>\n                   (\\<exists>u\\<in>sinks_aux I D U xs.\n                       \\<exists>v\\<in>V. (u, v) \\<in> I);\n        \\<exists>u\\<in>U.\n           \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n              (u, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n                            \\<exists>v\\<in>V. (u, v) \\<in> I", "show \"\\<exists>u \\<in> sinks_aux I D U (xs @ [x]). \\<exists>v \\<in> V. (u, v) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n       \\<exists>v\\<in>V. (u, v) \\<in> I", "proof (cases \"\\<exists>u \\<in> sinks_aux I D U xs. (u, D x) \\<in> I\",\n   cases \"\\<exists>v \\<in> V. (D x, v) \\<in> I\", simp_all (no_asm_simp))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I;\n     \\<not> (\\<exists>v\\<in>V. (D x, v) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>sinks_aux I D U xs.\n                         \\<exists>v\\<in>V. (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "have \"(\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D V xs. (u, v) \\<in> I) \\<longrightarrow>\n      (\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D V xs.\n           (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)", "using A"], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D ?V xs.\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>?V. (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D V xs.\n           (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)", "."], ["proof (state)\nthis:\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I;\n     \\<not> (\\<exists>v\\<in>V. (D x, v) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>sinks_aux I D U xs.\n                         \\<exists>v\\<in>V. (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "moreover"], ["proof (state)\nthis:\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I;\n     \\<not> (\\<exists>v\\<in>V. (D x, v) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>sinks_aux I D U xs.\n                         \\<exists>v\\<in>V. (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "assume \"\\<not> (\\<exists>v \\<in> V. (D x, v) \\<in> I)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>V. (D x, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I;\n     \\<not> (\\<exists>v\\<in>V. (D x, v) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>sinks_aux I D U xs.\n                         \\<exists>v\\<in>V. (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "hence \"\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D V xs. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>V. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I", "using B"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>V. (D x, v) \\<in> I)\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I;\n     \\<not> (\\<exists>v\\<in>V. (D x, v) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>sinks_aux I D U xs.\n                         \\<exists>v\\<in>V. (u, v) \\<in> I\n 2. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "ultimately"], ["proof (chain)\npicking this:\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)\n  \\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I", "show \"\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I)\n  \\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "assume C: \"\\<not> (\\<exists>u \\<in> sinks_aux I D U xs. (u, D x) \\<in> I)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "have \"(\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D ?V xs. (u, v) \\<in> I) \\<longrightarrow>\n      (\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> ?V. (u, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n           (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>sinks_aux I D U xs.\n        \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I)", "using A"], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D ?V xs.\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>?V. (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>U.\n        \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n           (u, v) \\<in> I) \\<longrightarrow>\n    (\\<exists>u\\<in>sinks_aux I D U xs.\n        \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I)", "."], ["proof (state)\nthis:\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "hence \"\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> ?V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs.\n       \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", "using B"], ["proof (prove)\nusing this:\n  (\\<exists>u\\<in>U.\n      \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n         (u, v) \\<in> I) \\<longrightarrow>\n  (\\<exists>u\\<in>sinks_aux I D U xs.\n      \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I)\n  \\<exists>u\\<in>U.\n     \\<exists>v\\<in>sources_aux I D (sources_aux I D V [x]) xs.\n        (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs.\n       \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I", "obtain u where\n      D: \"u \\<in> sinks_aux I D U xs\" and E: \"\\<exists>v \\<in> ?V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs.\n     \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> sinks_aux I D U xs;\n         \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> sinks_aux I D U xs\n  \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "obtain v where F: \"v \\<in> ?V\" and G: \"(u, v) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sources_aux I D V [x]; (u, v) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using E"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D V [x]. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sources_aux I D V [x]; (u, v) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sources_aux I D V [x]\n  (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "have \"v = D x \\<or> v \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = D x \\<or> v \\<in> V", "using F"], ["proof (prove)\nusing this:\n  v \\<in> sources_aux I D V [x]\n\ngoal (1 subgoal):\n 1. v = D x \\<or> v \\<in> V", "by (cases \"\\<exists>v \\<in> V. (D x, v) \\<in> I\", simp_all)"], ["proof (state)\nthis:\n  v = D x \\<or> v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "moreover"], ["proof (state)\nthis:\n  v = D x \\<or> v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "{"], ["proof (state)\nthis:\n  v = D x \\<or> v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "assume \"v = D x\""], ["proof (state)\nthis:\n  v = D x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "hence \"(u, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  v = D x\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I", "using G"], ["proof (prove)\nusing this:\n  v = D x\n  (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I", "by simp"], ["proof (state)\nthis:\n  (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "hence \"\\<exists>u \\<in> sinks_aux I D U xs. (u, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I", "using D"], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "hence \"\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "using C"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I\n  \\<not> (\\<exists>u\\<in>sinks_aux I D U xs. (u, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "by contradiction"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "}"], ["proof (state)\nthis:\n  v = D x \\<Longrightarrow>\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "moreover"], ["proof (state)\nthis:\n  v = D x \\<Longrightarrow>\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "{"], ["proof (state)\nthis:\n  v = D x \\<Longrightarrow>\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "assume \"v \\<in> V\""], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "with G"], ["proof (chain)\npicking this:\n  (u, v) \\<in> I\n  v \\<in> V", "have \"\\<exists>v \\<in> V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> I\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>V. (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "hence \"\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "using D"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>V. (u, v) \\<in> I\n  u \\<in> sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "}"], ["proof (state)\nthis:\n  v \\<in> V \\<Longrightarrow>\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>sinks_aux I D U xs.\n               (u, D x) \\<in> I) \\<Longrightarrow>\n    \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "ultimately"], ["proof (chain)\npicking this:\n  v = D x \\<or> v \\<in> V\n  v = D x \\<Longrightarrow>\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n  v \\<in> V \\<Longrightarrow>\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", "show \"\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I\""], ["proof (prove)\nusing this:\n  v = D x \\<or> v \\<in> V\n  v = D x \\<Longrightarrow>\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n  v \\<in> V \\<Longrightarrow>\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u\\<in>sinks_aux I D U (xs @ [x]).\n     \\<exists>v\\<in>V. (u, v) \\<in> I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_sinks_sources_aux:\n \"(\\<exists>u \\<in> sinks_aux I D U xs. \\<exists>v \\<in> V. (u, v) \\<in> I) =\n  (\\<exists>u \\<in> U. \\<exists>v \\<in> sources_aux I D V xs. (u, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u\\<in>sinks_aux I D U xs. \\<exists>v\\<in>V. (u, v) \\<in> I) =\n    (\\<exists>u\\<in>U. \\<exists>v\\<in>sources_aux I D V xs. (u, v) \\<in> I)", "by (rule iffI, erule ex_sinks_sources_aux_1, rule ex_sinks_sources_aux_2)"], ["", "lemma ipurge_tr_rev_ipurge_tr_sources_aux_1 [rule_format]:\n \"\\<not> (\\<exists>v \\<in> D ` set ys. \\<exists>u \\<in> sources_aux I D U zs. (v, u) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` set ys.\n               \\<exists>u\\<in>sources_aux I D U zs.\n                  (v, u) \\<in> I) \\<longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "proof (induction zs arbitrary: U rule: rev_induct, rule_tac [!] impI,\n simp del: bex_simps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U.\n       \\<not> (\\<exists>v\\<in>D ` set ys.\n                  \\<exists>u\\<in>U. (v, u) \\<in> I) \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "fix U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U.\n       \\<not> (\\<exists>v\\<in>D ` set ys.\n                  \\<exists>u\\<in>U. (v, u) \\<in> I) \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "assume \"\\<not> (\\<exists>v \\<in> D ` set ys. \\<exists>u \\<in> U. (v, u) \\<in> I)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>D ` set ys. \\<exists>u\\<in>U. (v, u) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       \\<not> (\\<exists>v\\<in>D ` set ys.\n                  \\<exists>u\\<in>U. (v, u) \\<in> I) \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "hence \"ipurge_tr_rev_aux I D U ys = []\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` set ys. \\<exists>u\\<in>U. (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ys = []", "by (simp add: ipurge_tr_rev_aux_nil)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ys = []\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       \\<not> (\\<exists>v\\<in>D ` set ys.\n                  \\<exists>u\\<in>U. (v, u) \\<in> I) \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "thus \"ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U ys = []\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs", "by (simp add: ipurge_tr_rev_aux_append_nil)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "fix z zs U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "let\n    ?U = \"sources_aux I D U [z]\" and\n    ?U' = \"insert (D z) U\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "assume \"\\<And>U. \\<not> (\\<exists>v \\<in> D ` set ys. \\<exists>u \\<in> sources_aux I D U zs. (v, u) \\<in> I) \\<longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D ?U zs.\n                (v, u) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D ?U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D ?U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "hence \"\\<not> (\\<exists>v \\<in> D ` set ys. \\<exists>u \\<in> sources_aux I D ?U zs. (v, u) \\<in> I) \\<longrightarrow>\n    ipurge_tr_rev_aux I D ?U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D ?U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D ?U zs.\n                (v, u) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D ?U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D ?U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` set ys.\n               \\<exists>u\\<in>sources_aux I D (sources_aux I D U [z]) zs.\n                  (v, u) \\<in> I) \\<longrightarrow>\n    ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (sources_aux I D U [z])\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "."], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D (sources_aux I D U [z]) zs.\n                (v, u) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D (sources_aux I D U [z]) zs.\n                (v, u) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "assume\n   \"\\<not> (\\<exists>v \\<in> D ` set ys. \\<exists>u \\<in> sources_aux I D U (zs @ [z]). (v, u) \\<in> I)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D U (zs @ [z]). (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "hence A:\n   \"\\<not> (\\<exists>v \\<in> D ` set ys. \\<exists>u \\<in> sources_aux I D ?U zs. (v, u) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D U (zs @ [z]). (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` set ys.\n               \\<exists>u\\<in>sources_aux I D (sources_aux I D U [z]) zs.\n                  (v, u) \\<in> I)", "by (subst (asm) sources_aux_append)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D (sources_aux I D U [z]) zs.\n                (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D (sources_aux I D U [z]) zs.\n                (v, u) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D (sources_aux I D U [z]) zs.\n                (v, u) \\<in> I)", "have B:\n   \"ipurge_tr_rev_aux I D ?U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D ?U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D (sources_aux I D U [z]) zs.\n                (v, u) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D (sources_aux I D U [z]) zs.\n                (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (sources_aux I D U [z])\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "have \n   \"ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "hence C:\n   \"ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D ?U (xs @ ys @ zs) @ ipurge_tr_rev_aux I D U [z]\"\n   (is \"_ = _ @ ?ws\")"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z])\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) @\n    ipurge_tr_rev_aux I D U [z]", "by (simp only: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) @\n  ipurge_tr_rev_aux I D U [z]\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>D ` set ys.\n                              \\<exists>u\\<in>sources_aux I D U xsa.\n                                 (v, u) \\<in> I) \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        \\<not> (\\<exists>v\\<in>D ` set ys.\n                   \\<exists>u\\<in>sources_aux I D U (xsa @ [x]).\n                      (v, u) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "show\n   \"ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "proof (subst C, cases \"\\<exists>u \\<in> U. (D z, u) \\<in> I\",\n   simp_all (no_asm_simp) del: ipurge_tr_aux.simps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "have \"\\<not> (\\<exists>v \\<in> sinks_aux I D (D ` set ys) zs. \\<exists>u \\<in> ?U. (v, u) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               \\<exists>u\\<in>sources_aux I D U [z]. (v, u) \\<in> I)", "using A"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` set ys.\n             \\<exists>u\\<in>sources_aux I D (sources_aux I D U [z]) zs.\n                (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               \\<exists>u\\<in>sources_aux I D U [z]. (v, u) \\<in> I)", "by (simp add: ex_sinks_sources_aux)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n             \\<exists>u\\<in>sources_aux I D U [z]. (v, u) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "hence \"\\<not> (\\<exists>v \\<in> sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n             \\<exists>u\\<in>sources_aux I D U [z]. (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)", "using True"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n             \\<exists>u\\<in>sources_aux I D U [z]. (v, u) \\<in> I)\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "hence\n     \"ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n      ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U\n     (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n    ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "have \"\\<dots> =\n      ipurge_tr_rev_aux I D ?U (xs @ ipurge_tr_aux I D (D ` set ys) zs) @ ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U\n     ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z]) =\n    ipurge_tr_rev_aux I D (sources_aux I D U [z])\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    ipurge_tr_rev_aux I D U [z]", "by (simp only: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z]) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  ipurge_tr_rev_aux I D U [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z]) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  ipurge_tr_rev_aux I D U [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "have \"\\<dots> =\n      ipurge_tr_rev_aux I D ?U' (xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (sources_aux I D U [z])\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    ipurge_tr_rev_aux I D U [z] =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z]", "using True"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (sources_aux I D U [z])\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    ipurge_tr_rev_aux I D U [z] =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  ipurge_tr_rev_aux I D U [z] =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z]", "have\n     \"ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n      ipurge_tr_rev_aux I D ?U' (xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z]\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z]\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U\n     (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z]", "."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "thus\n     \"ipurge_tr_rev_aux I D ?U' (xs @ ys @ zs) @ [z] =\n      ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z]\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "using B and True"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z]\n  ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "have\n     \"ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n      ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U\n     (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "proof (cases \"\\<exists>v \\<in> sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I\", simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<notin> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "have\n       \"ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n        ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n    ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<notin> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<notin> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "have \"\\<dots> =\n        ipurge_tr_rev_aux I D ?U (xs @ ipurge_tr_aux I D (D ` set ys) zs) @ ?ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U\n     ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z]) =\n    ipurge_tr_rev_aux I D (sources_aux I D U [z])\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    ipurge_tr_rev_aux I D U [z]", "by (simp only: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z]) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  ipurge_tr_rev_aux I D U [z]\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<notin> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z]) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  ipurge_tr_rev_aux I D U [z]\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<notin> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "have \"\\<dots> =\n        ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (sources_aux I D U [z])\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    ipurge_tr_rev_aux I D U [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (sources_aux I D U [z])\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    ipurge_tr_rev_aux I D U [z] =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  ipurge_tr_rev_aux I D U [z] =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<notin> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "show\n       \"ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n        ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "thus\n     \"ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n      ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "using B and False"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z])) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n  ipurge_tr_rev_aux I D (sources_aux I D U [z]) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (sources_aux I D U [z])\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_ipurge_tr_sources_1:\n  assumes A: \"D y \\<notin> sources I D u (y # zs)\"\n  shows\n   \"ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "have \"\\<not> ((D y, u) \\<in> I \\<or> (\\<exists>v \\<in> sources I D u zs. (D y, v) \\<in> I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ((D y, u) \\<in> I \\<or>\n            (\\<exists>v\\<in>sources I D u zs. (D y, v) \\<in> I))", "using A"], ["proof (prove)\nusing this:\n  D y \\<notin> sources I D u (y # zs)\n\ngoal (1 subgoal):\n 1. \\<not> ((D y, u) \\<in> I \\<or>\n            (\\<exists>v\\<in>sources I D u zs. (D y, v) \\<in> I))", "by (simp only: sources_interference_eq, simp)"], ["proof (state)\nthis:\n  \\<not> ((D y, u) \\<in> I \\<or>\n          (\\<exists>v\\<in>sources I D u zs. (D y, v) \\<in> I))\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "hence \"\\<not> (\\<exists>v \\<in> D ` set [y]. \\<exists>u \\<in> sources_aux I D {u} zs. (v, u) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<not> ((D y, u) \\<in> I \\<or>\n          (\\<exists>v\\<in>sources I D u zs. (D y, v) \\<in> I))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` set [y].\n               \\<exists>u\\<in>sources_aux I D {u} zs. (v, u) \\<in> I)", "by (simp add: sources_aux_single_dom)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>D ` set [y].\n             \\<exists>u\\<in>sources_aux I D {u} zs. (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "hence\n   \"ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs) =\n    ipurge_tr_rev_aux I D {u} (xs @ ipurge_tr_aux I D (D ` set [y]) zs)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` set [y].\n             \\<exists>u\\<in>sources_aux I D {u} zs. (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs) =\n    ipurge_tr_rev_aux I D {u} (xs @ ipurge_tr_aux I D (D ` set [y]) zs)", "by (rule ipurge_tr_rev_ipurge_tr_sources_aux_1)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs) =\n  ipurge_tr_rev_aux I D {u} (xs @ ipurge_tr_aux I D (D ` set [y]) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs) =\n  ipurge_tr_rev_aux I D {u} (xs @ ipurge_tr_aux I D (D ` set [y]) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "by (simp add: ipurge_tr_aux_single_dom ipurge_tr_rev_aux_single_dom)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u (xs @ y # zs) =\n  ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_length:\n \"length (ipurge_tr I D u xs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ipurge_tr I D u xs) \\<le> length xs", "by (induction xs rule: rev_induct, simp_all)"], ["", "lemma sources_idem:\n \"sources I D u (ipurge_tr_rev I D u xs) = sources I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sources I D u (ipurge_tr_rev I D u xs) = sources I D u xs", "by (induction xs, simp_all)"], ["", "lemma ipurge_tr_rev_idem:\n \"ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs", "by (induction xs, simp_all add: sources_idem)"], ["", "subsection \"Closure of the traces of a secure process under reverse intransitive purge\""], ["", "text \\<open>\nThe derivation of the Inductive Unwinding Theorem from the Ipurge Unwinding Theorem requires to\nprove that the set of the traces of a secure process is closed under reverse intransitive purge,\ni.e. function @{term ipurge_tr_rev} \\cite{R3}. This can be expressed formally by means of the\nfollowing statement:\n\n\\null\n\n@{term \"secure P I D \\<Longrightarrow> xs \\<in> traces P \\<Longrightarrow> ipurge_tr_rev I D u xs \\<in> traces P\"}\n\n\\null\n\nThe reason why such closure property holds is that the reverse intransitive purge of a list\n@{term xs} with regard to a policy @{term I}, an event-domain map @{term D}, and a domain @{term u}\ncan equivalently be computed as follows: for each item @{term x} of @{term xs}, if @{term x} may\naffect @{term u}, retain @{term x} and go on recursively using as input the sublist of @{term xs}\nfollowing @{term x}, say @{term xs'}; otherwise, discard @{term x} and go on recursively using\n@{term \"ipurge_tr I D (D x) xs'\"} \\cite{R2} as input.\n\nThe result actually matches @{term \"ipurge_tr_rev I D u xs\"}. In fact, for each @{term x} not\naffecting @{term u}, @{term \"ipurge_tr I D (D x) xs'\"} retains any item of @{term xs'} not affected\nby @{term x}, which is the case for any item of @{term xs'} affecting @{term u}, since otherwise\n@{term x} would affect @{term u}.\n\nFurthermore, if @{term xs} is a trace of a secure process, the result is still a trace. In fact, for\neach @{term x} not affecting @{term u}, if @{term ys} is the partial output for the sublist of\n@{term xs} preceding @{term x}, then @{term \"ys @ ipurge_tr I D (D x) xs'\"} is a trace provided such\nis @{term \"ys @ x # xs'\"}, by virtue of the definition of CSP noninterference security \\cite{R2}.\nHence, the property of being a trace is conserved upon each recursive call by the concatenation of\nthe partial output and the residual input, until the latter is nil and the former matches the total\noutput.\n\nThis argument shows that in order to prove by induction, under the aforesaid assumptions, that the\noutput of such a reverse intransitive purge function is a trace, the partial output has to be passed\nto the function as an argument, in addition to the residual input, in the recursive calls contained\nwithin the definition of the function. Therefore, the output of the function has to be accumulated\ninto one of its parameters, viz. the function needs to be tail-recursive. This suggests to prove the\nproperties of interest of the function by applying the ten-step proof method for theorems on\ntail-recursive functions described in \\cite{R1}.\n\nThe starting point is to formulate a naive definition of the function, which will then be refined as\nspecified by the proof method. The name of the refined function, from which the name of the naive\nfunction here below is derived, will be \\<open>ipurge_tr_rev_t\\<close>, where suffix \\emph{t} stands for\n\\emph{tail-recursive}.\n\n\\null\n\\<close>"], ["", "function (sequential) ipurge_tr_rev_t_naive ::\n  \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n\"ipurge_tr_rev_t_naive I D u (x # xs) ys =\n (if D x \\<in> sources I D u (x # xs)\n  then ipurge_tr_rev_t_naive I D u xs (ys @ [x])\n  else ipurge_tr_rev_t_naive I D u (ipurge_tr I D (D x) xs) ys)\" |\n\"ipurge_tr_rev_t_naive _ _ _ _ ys = ys\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>I D u xa xs ys.\n                   x = (I, D, u, xa # xs, ys) \\<Longrightarrow> P;\n        \\<And>uu_ uv_ uw_ ys.\n           x = (uu_, uv_, uw_, [], ys) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>I D u x xs ys Ia Da ua xa xsa ysa.\n       (I, D, u, x # xs, ys) = (Ia, Da, ua, xa # xsa, ysa) \\<Longrightarrow>\n       (if D x \\<in> sources I D u (x # xs)\n        then ipurge_tr_rev_t_naive_sumC (I, D, u, xs, ys @ [x])\n        else ipurge_tr_rev_t_naive_sumC\n              (I, D, u, ipurge_tr I D (D x) xs, ys)) =\n       (if Da xa \\<in> sources Ia Da ua (xa # xsa)\n        then ipurge_tr_rev_t_naive_sumC (Ia, Da, ua, xsa, ysa @ [xa])\n        else ipurge_tr_rev_t_naive_sumC\n              (Ia, Da, ua, ipurge_tr Ia Da (Da xa) xsa, ysa))\n 3. \\<And>I D u x xs ys uu_ uv_ uw_ ysa.\n       (I, D, u, x # xs, ys) = (uu_, uv_, uw_, [], ysa) \\<Longrightarrow>\n       (if D x \\<in> sources I D u (x # xs)\n        then ipurge_tr_rev_t_naive_sumC (I, D, u, xs, ys @ [x])\n        else ipurge_tr_rev_t_naive_sumC\n              (I, D, u, ipurge_tr I D (D x) xs, ys)) =\n       ysa\n 4. \\<And>uu_ uv_ uw_ ys uua_ uva_ uwa_ ysa.\n       (uu_, uv_, uw_, [], ys) =\n       (uua_, uva_, uwa_, [], ysa) \\<Longrightarrow>\n       ys = ysa", "oops"], ["", "text \\<open>\n\\null\n\nThe parameter into which the output is accumulated is the last one.\n\nAs shown by the previous argument, the properties of function @{term ipurge_tr_rev_t_naive} that\nwould have to be proven are the following ones:\n\n\\null\n\n@{term \"ipurge_tr_rev_t_naive I D u xs [] = ipurge_tr_rev I D u xs\"}\n\n\\null\n\n@{term \"secure P I D \\<Longrightarrow> xs \\<in> traces P \\<Longrightarrow> ipurge_tr_rev_t_naive I D u xs [] \\<in> traces P\"}\n\n\\null\n\nas they clearly entail the above formal statement of the target closure lemma.\n\\<close>"], ["", "subsubsection \"Step 1\""], ["", "text \\<open>\nIn the definition of the auxiliary tail-recursive function @{term ipurge_tr_rev_t_aux}, the\nCartesian product of the input types of function @{term ipurge_tr_rev_t_naive} will be implemented\nas a record type.\n\n\\null\n\\<close>"], ["", "record ('a, 'd) ipurge_rec =\n  Pol :: \"('d \\<times> 'd) set\"\n  Map :: \"'a \\<Rightarrow> 'd\"\n  Dom :: 'd\n  In :: \"'a list\"\n  Out :: \"'a list\""], ["", "function (sequential) ipurge_tr_rev_t_aux ::\n  \"('a, 'd) ipurge_rec \\<Rightarrow> ('a, 'd) ipurge_rec\" where\n\"ipurge_tr_rev_t_aux \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr> =\n (if D x \\<in> sources I D u (x # xs)\n  then ipurge_tr_rev_t_aux\n    \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  else ipurge_tr_rev_t_aux\n    \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs, Out = ys\\<rparr>)\" |\n\"ipurge_tr_rev_t_aux X = X\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>I D u xa xs ys.\n                   x =\n                   \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                      Out = ys\\<rparr> \\<Longrightarrow>\n                   P;\n        \\<And>v va vb vd ve.\n           x =\n           \\<lparr>Pol = v, Map = va, Dom = vb, In = [], Out = vd,\n              \\<dots> = ve\\<rparr> \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>I D u x xs ys Ia Da ua xa xsa ysa.\n       \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr> =\n       \\<lparr>Pol = Ia, Map = Da, Dom = ua, In = xa # xsa,\n          Out = ysa\\<rparr> \\<Longrightarrow>\n       (if D x \\<in> sources I D u (x # xs)\n        then ipurge_tr_rev_t_aux_sumC\n              \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                 Out = ys @ [x]\\<rparr>\n        else ipurge_tr_rev_t_aux_sumC\n              \\<lparr>Pol = I, Map = D, Dom = u,\n                 In = ipurge_tr I D (D x) xs, Out = ys\\<rparr>) =\n       (if Da xa \\<in> sources Ia Da ua (xa # xsa)\n        then ipurge_tr_rev_t_aux_sumC\n              \\<lparr>Pol = Ia, Map = Da, Dom = ua, In = xsa,\n                 Out = ysa @ [xa]\\<rparr>\n        else ipurge_tr_rev_t_aux_sumC\n              \\<lparr>Pol = Ia, Map = Da, Dom = ua,\n                 In = ipurge_tr Ia Da (Da xa) xsa, Out = ysa\\<rparr>)\n 3. \\<And>I D u x xs ys v va vb vd ve.\n       \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr> =\n       \\<lparr>Pol = v, Map = va, Dom = vb, In = [], Out = vd,\n          \\<dots> = ve\\<rparr> \\<Longrightarrow>\n       (if D x \\<in> sources I D u (x # xs)\n        then ipurge_tr_rev_t_aux_sumC\n              \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                 Out = ys @ [x]\\<rparr>\n        else ipurge_tr_rev_t_aux_sumC\n              \\<lparr>Pol = I, Map = D, Dom = u,\n                 In = ipurge_tr I D (D x) xs, Out = ys\\<rparr>) =\n       \\<lparr>Pol = v, Map = va, Dom = vb, In = [], Out = vd,\n          \\<dots> = ve\\<rparr>\n 4. \\<And>v va vb vd ve vc vaa vba vda vea.\n       \\<lparr>Pol = v, Map = va, Dom = vb, In = [], Out = vd,\n          \\<dots> = ve\\<rparr> =\n       \\<lparr>Pol = vc, Map = vaa, Dom = vba, In = [], Out = vda,\n          \\<dots> = vea\\<rparr> \\<Longrightarrow>\n       \\<lparr>Pol = v, Map = va, Dom = vb, In = [], Out = vd,\n          \\<dots> = ve\\<rparr> =\n       \\<lparr>Pol = vc, Map = vaa, Dom = vba, In = [], Out = vda,\n          \\<dots> = vea\\<rparr>", "proof (simp_all, atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>I D u xa xs ys.\n           x =\n           \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n              Out = ys\\<rparr>) \\<or>\n       (\\<exists>v va vb vd.\n           x =\n           \\<lparr>Pol = v, Map = va, Dom = vb, In = [], Out = vd\\<rparr>)", "fix X :: \"('a, 'd) ipurge_rec\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>I D u xa xs ys.\n           x =\n           \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n              Out = ys\\<rparr>) \\<or>\n       (\\<exists>v va vb vd.\n           x =\n           \\<lparr>Pol = v, Map = va, Dom = vb, In = [], Out = vd\\<rparr>)", "show\n   \"(\\<exists>I D u x xs ys.\n      X = \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>) \\<or>\n    (\\<exists>I D u ys.\n      X = \\<lparr>Pol = I, Map = D, Dom = u, In = [], Out = ys\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>I D u x xs ys.\n        X =\n        \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n           Out = ys\\<rparr>) \\<or>\n    (\\<exists>I D u ys.\n        X = \\<lparr>Pol = I, Map = D, Dom = u, In = [], Out = ys\\<rparr>)", "proof (cases X, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pol Map Dom In Out.\n       X =\n       \\<lparr>Pol = Pol, Map = Map, Dom = Dom, In = In,\n          Out = Out\\<rparr> \\<Longrightarrow>\n       (\\<exists>x xs. In = x # xs) \\<or> In = []", "qed (subst disj_commute, rule spec [OF list.nchotomy])"], ["proof (state)\nthis:\n  (\\<exists>I D u x xs ys.\n      X =\n      \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n         Out = ys\\<rparr>) \\<or>\n  (\\<exists>I D u ys.\n      X = \\<lparr>Pol = I, Map = D, Dom = u, In = [], Out = ys\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "termination ipurge_tr_rev_t_aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. All ipurge_tr_rev_t_aux_dom", "proof (relation \"measure (\\<lambda>X. length (In X))\", simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I D u x xs.\n       D x\n       \\<notin> (if (D x, u) \\<in> I \\<or>\n                    (\\<exists>v\\<in>sources I D u xs. (D x, v) \\<in> I)\n                 then insert (D x) (sources I D u xs)\n                 else sources I D u xs) \\<Longrightarrow>\n       length (ipurge_tr I D (D x) xs) < Suc (length xs)", "fix D :: \"'a \\<Rightarrow> 'd\" and I x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I D u x xs.\n       D x\n       \\<notin> (if (D x, u) \\<in> I \\<or>\n                    (\\<exists>v\\<in>sources I D u xs. (D x, v) \\<in> I)\n                 then insert (D x) (sources I D u xs)\n                 else sources I D u xs) \\<Longrightarrow>\n       length (ipurge_tr I D (D x) xs) < Suc (length xs)", "have \"length (ipurge_tr I D (D x) xs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ipurge_tr I D (D x) xs) \\<le> length xs", "by (rule ipurge_tr_length)"], ["proof (state)\nthis:\n  length (ipurge_tr I D (D x) xs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>I D u x xs.\n       D x\n       \\<notin> (if (D x, u) \\<in> I \\<or>\n                    (\\<exists>v\\<in>sources I D u xs. (D x, v) \\<in> I)\n                 then insert (D x) (sources I D u xs)\n                 else sources I D u xs) \\<Longrightarrow>\n       length (ipurge_tr I D (D x) xs) < Suc (length xs)", "thus \"length (ipurge_tr I D (D x) xs) < Suc (length xs)\""], ["proof (prove)\nusing this:\n  length (ipurge_tr I D (D x) xs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. length (ipurge_tr I D (D x) xs) < Suc (length xs)", "by simp"], ["proof (state)\nthis:\n  length (ipurge_tr I D (D x) xs) < Suc (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nAs shown by this proof, the termination of function @{term ipurge_tr_rev_t_aux} is guaranteed by the\nfact, proven previously, that the event lists output by function @{term ipurge_tr} are not longer\nthan the corresponding input ones.\n\\<close>"], ["", "subsubsection \"Step 2\""], ["", "definition ipurge_tr_rev_t_in ::\n  \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'd) ipurge_rec\" where\n\"ipurge_tr_rev_t_in I D u xs \\<equiv>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\""], ["", "definition ipurge_tr_rev_t_out ::\n  \"('a, 'd) ipurge_rec \\<Rightarrow> 'a list\" where\n\"ipurge_tr_rev_t_out \\<equiv> Out\""], ["", "definition ipurge_tr_rev_t ::\n  \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n\"ipurge_tr_rev_t I D u xs \\<equiv>\n  ipurge_tr_rev_t_out (ipurge_tr_rev_t_aux (ipurge_tr_rev_t_in I D u xs))\""], ["", "text \\<open>\n\\null\n\nSince the significant inputs of function @{term ipurge_tr_rev_t_naive} match pattern \\<open>_\\<close>,\n\\<open>_\\<close>, \\<open>_\\<close>, \\<open>_\\<close>, @{term \"[]\"}, those of function @{term ipurge_tr_rev_t_aux}, as\nreturned by function @{term ipurge_tr_rev_t_in}, match pattern\n\\<open>\\<lparr>Pol = _, Map = _, Dom = _, In = _, Out = []\\<rparr>\\<close>.\n\nIn terms of function @{term ipurge_tr_rev_t}, the statements to be proven, henceforth respectively\nnamed \\<open>ipurge_tr_rev_t_equiv\\<close> and \\<open>ipurge_tr_rev_t_trace\\<close>, take the following form:\n\n\\null\n\n@{term \"ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs\"}\n\n\\null\n\n@{term \"secure P I D \\<Longrightarrow> xs \\<in> traces P \\<Longrightarrow> ipurge_tr_rev_t I D u xs \\<in> traces P\"}\n\\<close>"], ["", "subsubsection \"Step 3\""], ["", "inductive_set ipurge_tr_rev_t_set :: \"('a, 'd) ipurge_rec \\<Rightarrow> ('a, 'd) ipurge_rec set\"\n  for X :: \"('a, 'd) ipurge_rec\" where\nR0: \"X \\<in> ipurge_tr_rev_t_set X\" |\nR1: \"\\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n      D x \\<in> sources I D u (x # xs)\\<rbrakk> \\<Longrightarrow>\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n       \\<in> ipurge_tr_rev_t_set X\" |\nR2: \"\\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n      D x \\<notin> sources I D u (x # xs)\\<rbrakk> \\<Longrightarrow>\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs, Out = ys\\<rparr>\n       \\<in> ipurge_tr_rev_t_set X\""], ["", "subsubsection \"Step 4\""], ["", "lemma ipurge_tr_rev_t_subset:\n  assumes A: \"Y \\<in> ipurge_tr_rev_t_set X\"\n  shows \"ipurge_tr_rev_t_set Y \\<subseteq> ipurge_tr_rev_t_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_set Y \\<subseteq> ipurge_tr_rev_t_set X", "proof (rule subsetI, erule ipurge_tr_rev_t_set.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. Y \\<in> ipurge_tr_rev_t_set X\n 2. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<in> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                            Out = ys @ [xa]\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X\n 3. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<notin> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u,\n                            In = ipurge_tr I D (D xa) xs, Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X", "show \"Y \\<in> ipurge_tr_rev_t_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<in> ipurge_tr_rev_t_set X", "using A"], ["proof (prove)\nusing this:\n  Y \\<in> ipurge_tr_rev_t_set X\n\ngoal (1 subgoal):\n 1. Y \\<in> ipurge_tr_rev_t_set X", "."], ["proof (state)\nthis:\n  Y \\<in> ipurge_tr_rev_t_set X\n\ngoal (2 subgoals):\n 1. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<in> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                            Out = ys @ [xa]\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X\n 2. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<notin> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u,\n                            In = ipurge_tr I D (D xa) xs, Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<in> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                            Out = ys @ [xa]\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X\n 2. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<notin> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u,\n                            In = ipurge_tr I D (D xa) xs, Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X", "fix I D u x xs ys"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<in> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                            Out = ys @ [xa]\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X\n 2. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<notin> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u,\n                            In = ipurge_tr I D (D xa) xs, Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X", "assume\n    \"\\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n       \\<in> ipurge_tr_rev_t_set X\" and\n    \"D x \\<in> sources I D u (x # xs)\""], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set X\n  D x \\<in> sources I D u (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<in> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                            Out = ys @ [xa]\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X\n 2. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<notin> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u,\n                            In = ipurge_tr I D (D xa) xs, Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X", "thus \"\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set X\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set X\n  D x \\<in> sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set X", "by (rule R1)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set X\n\ngoal (1 subgoal):\n 1. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<notin> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u,\n                            In = ipurge_tr I D (D xa) xs, Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<notin> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u,\n                            In = ipurge_tr I D (D xa) xs, Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X", "fix I D u x xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<notin> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u,\n                            In = ipurge_tr I D (D xa) xs, Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X", "assume\n    \"\\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n       \\<in> ipurge_tr_rev_t_set X\" and\n    \"D x \\<notin> sources I D u (x # xs)\""], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set X\n  D x \\<notin> sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>x I D u xa xs ys.\n       \\<lbrakk>\\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs,\n                   Out = ys\\<rparr>\n                \\<in> ipurge_tr_rev_t_set Y;\n        \\<lparr>Pol = I, Map = D, Dom = u, In = xa # xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set X;\n        D xa \\<notin> sources I D u (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>Pol = I, Map = D, Dom = u,\n                            In = ipurge_tr I D (D xa) xs, Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set X", "thus \"\\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs, Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set X\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set X\n  D x \\<notin> sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n       Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set X", "by (rule R2)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n     Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_t_aux_set:\n \"ipurge_tr_rev_t_aux X \\<in> ipurge_tr_rev_t_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_aux X \\<in> ipurge_tr_rev_t_set X", "proof (induction rule: ipurge_tr_rev_t_aux.induct,\n simp_all only: ipurge_tr_rev_t_aux.simps(2) R0)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I D u x xs ys.\n       \\<lbrakk>D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n                ipurge_tr_rev_t_aux\n                 \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                    Out = ys @ [x]\\<rparr>\n                \\<in> ipurge_tr_rev_t_set\n                       \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                          Out = ys @ [x]\\<rparr>;\n        D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n        ipurge_tr_rev_t_aux\n         \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n            Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u,\n                  In = ipurge_tr I D (D x) xs, Out = ys\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_t_aux\n                          \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                             Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set\n                                \\<lparr>Pol = I, Map = D, Dom = u,\n                                   In = x # xs, Out = ys\\<rparr>", "fix I u x xs ys and D :: \"'a \\<Rightarrow> 'd\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I D u x xs ys.\n       \\<lbrakk>D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n                ipurge_tr_rev_t_aux\n                 \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                    Out = ys @ [x]\\<rparr>\n                \\<in> ipurge_tr_rev_t_set\n                       \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                          Out = ys @ [x]\\<rparr>;\n        D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n        ipurge_tr_rev_t_aux\n         \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n            Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u,\n                  In = ipurge_tr I D (D x) xs, Out = ys\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_t_aux\n                          \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                             Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set\n                                \\<lparr>Pol = I, Map = D, Dom = u,\n                                   In = x # xs, Out = ys\\<rparr>", "assume\n    A: \"D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n        ipurge_tr_rev_t_aux\n          \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n        \\<in> ipurge_tr_rev_t_set\n          \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\"\n      (is \"_ \\<Longrightarrow> ipurge_tr_rev_t_aux ?Y \\<in> _\") and\n    B: \"D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n        ipurge_tr_rev_t_aux\n          \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs, Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set\n          \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs, Out = ys\\<rparr>\"\n      (is \"_ \\<Longrightarrow> ipurge_tr_rev_t_aux ?Z \\<in> _\")"], ["proof (state)\nthis:\n  D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n      Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n            Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>I D u x xs ys.\n       \\<lbrakk>D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n                ipurge_tr_rev_t_aux\n                 \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                    Out = ys @ [x]\\<rparr>\n                \\<in> ipurge_tr_rev_t_set\n                       \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n                          Out = ys @ [x]\\<rparr>;\n        D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n        ipurge_tr_rev_t_aux\n         \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n            Out = ys\\<rparr>\n        \\<in> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u,\n                  In = ipurge_tr I D (D x) xs, Out = ys\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_t_aux\n                          \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                             Out = ys\\<rparr>\n                         \\<in> ipurge_tr_rev_t_set\n                                \\<lparr>Pol = I, Map = D, Dom = u,\n                                   In = x # xs, Out = ys\\<rparr>", "show\n   \"ipurge_tr_rev_t_aux\n      \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n      \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\"\n    (is \"ipurge_tr_rev_t_aux ?X \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "proof (cases \"D x \\<in> sources I D u (x # xs)\", simp_all del: sources.simps)"], ["proof (state)\ngoal (2 subgoals):\n 1. D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n 2. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "case True"], ["proof (state)\nthis:\n  D x \\<in> sources I D u (x # xs)\n\ngoal (2 subgoals):\n 1. D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n 2. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "have \"?X \\<in> ipurge_tr_rev_t_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "by (rule R0)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (2 subgoals):\n 1. D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n 2. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (2 subgoals):\n 1. D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n 2. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "have \"?X \\<in> ipurge_tr_rev_t_set ?X \\<Longrightarrow> ?Y \\<in> ipurge_tr_rev_t_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n              Out = ys\\<rparr> \\<Longrightarrow>\n    \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "by (rule R1 [OF _ True])"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n            Out = ys\\<rparr> \\<Longrightarrow>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (2 subgoals):\n 1. D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n 2. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n            Out = ys\\<rparr> \\<Longrightarrow>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "have \"?Y \\<in> ipurge_tr_rev_t_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n            Out = ys\\<rparr> \\<Longrightarrow>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (2 subgoals):\n 1. D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n 2. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "hence \"ipurge_tr_rev_t_set ?Y \\<subseteq> ipurge_tr_rev_t_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_set\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<subseteq> ipurge_tr_rev_t_set\n                 \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                    Out = ys\\<rparr>", "by (rule ipurge_tr_rev_t_subset)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_set\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<subseteq> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                  Out = ys\\<rparr>\n\ngoal (2 subgoals):\n 1. D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n 2. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_set\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<subseteq> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                  Out = ys\\<rparr>\n\ngoal (2 subgoals):\n 1. D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n 2. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "have \"ipurge_tr_rev_t_aux ?Y \\<in> ipurge_tr_rev_t_set ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n              Out = ys @ [x]\\<rparr>", "using True"], ["proof (prove)\nusing this:\n  D x \\<in> sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = xs,\n              Out = ys @ [x]\\<rparr>", "by (rule A)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n\ngoal (2 subgoals):\n 1. D x \\<in> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n 2. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_t_set\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<subseteq> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                  Out = ys\\<rparr>\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>", "show \"ipurge_tr_rev_t_aux ?Y \\<in> ipurge_tr_rev_t_set ?X\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_t_set\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<subseteq> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                  Out = ys\\<rparr>\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = ys @ [x]\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "case False"], ["proof (state)\nthis:\n  D x \\<notin> sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "have \"?X \\<in> ipurge_tr_rev_t_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "by (rule R0)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "moreover"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "have \"?X \\<in> ipurge_tr_rev_t_set ?X \\<Longrightarrow> ?Z \\<in> ipurge_tr_rev_t_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n              Out = ys\\<rparr> \\<Longrightarrow>\n    \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n       Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "by (rule R2 [OF _ False])"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n            Out = ys\\<rparr> \\<Longrightarrow>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n     Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n            Out = ys\\<rparr> \\<Longrightarrow>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n     Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "have \"?Z \\<in> ipurge_tr_rev_t_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n            Out = ys\\<rparr> \\<Longrightarrow>\n  \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n     Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n       Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "by simp"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n     Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "hence \"ipurge_tr_rev_t_set ?Z \\<subseteq> ipurge_tr_rev_t_set ?X\""], ["proof (prove)\nusing this:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n     Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_set\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<subseteq> ipurge_tr_rev_t_set\n                 \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                    Out = ys\\<rparr>", "by (rule ipurge_tr_rev_t_subset)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_set\n   \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n      Out = ys\\<rparr>\n  \\<subseteq> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                  Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_set\n   \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n      Out = ys\\<rparr>\n  \\<subseteq> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                  Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "have \"ipurge_tr_rev_t_aux ?Z \\<in> ipurge_tr_rev_t_set ?Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n              Out = ys\\<rparr>", "using False"], ["proof (prove)\nusing this:\n  D x \\<notin> sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n              Out = ys\\<rparr>", "by (rule B)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n      Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n            Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. D x \\<notin> sources I D u (x # xs) \\<Longrightarrow>\n    ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_t_set\n   \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n      Out = ys\\<rparr>\n  \\<subseteq> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                  Out = ys\\<rparr>\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n      Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n            Out = ys\\<rparr>", "show \"ipurge_tr_rev_t_aux ?Z \\<in> ipurge_tr_rev_t_set ?X\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_t_set\n   \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n      Out = ys\\<rparr>\n  \\<subseteq> ipurge_tr_rev_t_set\n               \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs,\n                  Out = ys\\<rparr>\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n      Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n            Out = ys\\<rparr>\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n        Out = ys\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = ipurge_tr I D (D x) xs,\n      Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         \\<lparr>Pol = I, Map = D, Dom = u, In = x # xs, Out = ys\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Step 5\""], ["", "definition ipurge_tr_rev_t_inv_1 ::\n  \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'd) ipurge_rec \\<Rightarrow> bool\"\nwhere\n\"ipurge_tr_rev_t_inv_1 I D u xs X \\<equiv>\n  Out X @ ipurge_tr_rev I D u (In X) = ipurge_tr_rev I D u xs\""], ["", "definition ipurge_tr_rev_t_inv_2 ::\n  \"'a process \\<Rightarrow> ('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'd) ipurge_rec \\<Rightarrow> bool\"\nwhere\n\"ipurge_tr_rev_t_inv_2 P I D xs X \\<equiv>\n  secure P I D \\<longrightarrow> xs \\<in> traces P \\<longrightarrow> Out X @ In X \\<in> traces P\""], ["", "text \\<open>\n\\null\n\nTwo invariants have been defined, one for each of lemmas \\<open>ipurge_tr_rev_t_equiv\\<close>,\n\\<open>ipurge_tr_rev_t_trace\\<close>.\n\nMore precisely, the invariants are @{term \"ipurge_tr_rev_t_inv_1 I D u xs\"} and\n@{term \"ipurge_tr_rev_t_inv_2 P I D xs\"}, where the free variables are intended to match those\nappearing in the aforesaid lemmas.\n\\<close>"], ["", "subsubsection \"Step 6\""], ["", "lemma ipurge_tr_rev_t_input_1:\n \"ipurge_tr_rev_t_inv_1 I D u xs \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_inv_1 I D u xs\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>", "by (simp add: ipurge_tr_rev_t_inv_1_def)"], ["", "lemma ipurge_tr_rev_t_input_2:\n \"ipurge_tr_rev_t_inv_2 P I D xs \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_inv_2 P I D xs\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>", "by (simp add: ipurge_tr_rev_t_inv_2_def)"], ["", "subsubsection \"Step 7\""], ["", "definition ipurge_tr_rev_t_form :: \"('a, 'd) ipurge_rec \\<Rightarrow> bool\" where\n\"ipurge_tr_rev_t_form X \\<equiv> In X = []\""], ["", "lemma ipurge_tr_rev_t_intro_1:\n \"\\<lbrakk>ipurge_tr_rev_t_inv_1 I D u xs X; ipurge_tr_rev_t_form X\\<rbrakk> \\<Longrightarrow>\n  ipurge_tr_rev_t_out X = ipurge_tr_rev I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipurge_tr_rev_t_inv_1 I D u xs X;\n     ipurge_tr_rev_t_form X\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr_rev_t_out X = ipurge_tr_rev I D u xs", "by (simp add: ipurge_tr_rev_t_inv_1_def ipurge_tr_rev_t_form_def\n ipurge_tr_rev_t_out_def)"], ["", "lemma ipurge_tr_rev_t_intro_2:\n \"\\<lbrakk>ipurge_tr_rev_t_inv_2 P I D xs X; ipurge_tr_rev_t_form X\\<rbrakk> \\<Longrightarrow>\n  secure P I D \\<longrightarrow> xs \\<in> traces P \\<longrightarrow> ipurge_tr_rev_t_out X \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipurge_tr_rev_t_inv_2 P I D xs X;\n     ipurge_tr_rev_t_form X\\<rbrakk>\n    \\<Longrightarrow> secure P I D \\<longrightarrow>\n                      xs \\<in> traces P \\<longrightarrow>\n                      ipurge_tr_rev_t_out X \\<in> traces P", "by (simp add: ipurge_tr_rev_t_inv_2_def ipurge_tr_rev_t_form_def\n ipurge_tr_rev_t_out_def)"], ["", "subsubsection \"Step 8\""], ["", "lemma ipurge_tr_rev_t_form_aux:\n \"ipurge_tr_rev_t_form (ipurge_tr_rev_t_aux X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_form (ipurge_tr_rev_t_aux X)", "by (induction X rule: ipurge_tr_rev_t_aux.induct,\n simp_all add: ipurge_tr_rev_t_form_def)"], ["", "subsubsection \"Step 9\""], ["", "lemma ipurge_tr_rev_t_invariance_aux:\n \"Y \\<in> ipurge_tr_rev_t_set X \\<Longrightarrow>\n  Pol Y = Pol X \\<and> Map Y = Map X \\<and> Dom Y = Dom X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<in> ipurge_tr_rev_t_set X \\<Longrightarrow>\n    Pol Y = Pol X \\<and> Map Y = Map X \\<and> Dom Y = Dom X", "by (erule ipurge_tr_rev_t_set.induct, simp_all)"], ["", "text \\<open>\n\\null\n\nThe lemma just proven, stating the invariance of the first three record fields over inductive set\n@{term \"ipurge_tr_rev_t_set X\"}, is used in the following proofs of the invariance of predicates\n@{term \"ipurge_tr_rev_t_inv_1 I D u xs\"} and @{term \"ipurge_tr_rev_t_inv_2 P I D xs\"}.\n\nThe equality between the free variables appearing in the predicates and the corresponding fields of\nthe record generating the set, which is required for such invariance properties to hold, is asserted\nin the enunciation of the properties by means of record updates. In the subsequent proofs of lemmas\n\\<open>ipurge_tr_rev_t_equiv\\<close>, \\<open>ipurge_tr_rev_t_trace\\<close>, the enforcement of this equality will\nbe ensured by the identification of both predicate variables and record fields with the related free\nvariables appearing in the lemmas.\n\n\\null\n\\<close>"], ["", "lemma ipurge_tr_rev_t_invariance_1:\n \"\\<lbrakk>Y \\<in> ipurge_tr_rev_t_set (X\\<lparr>Pol := I, Map := D, Dom := u\\<rparr>);\n    ipurge_tr_rev_t_inv_1 I D u ws (X\\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\\<rbrakk> \\<Longrightarrow>\n  ipurge_tr_rev_t_inv_1 I D u ws Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Y \\<in> ipurge_tr_rev_t_set\n                      (X\\<lparr>Pol := I, Map := D, Dom := u\\<rparr>);\n     ipurge_tr_rev_t_inv_1 I D u ws\n      (X\\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr_rev_t_inv_1 I D u ws Y", "proof (erule ipurge_tr_rev_t_set.induct, assumption,\n drule_tac [!] ipurge_tr_rev_t_invariance_aux,\n simp_all add: ipurge_tr_rev_t_inv_1_def del: sources.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>Out X @ ipurge_tr_rev I D u (In X) = ipurge_tr_rev I D u ws;\n        ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws;\n        D x \\<notin> sources I D u (x # xs); Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) =\n                         ipurge_tr_rev I D u ws", "fix x xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>Out X @ ipurge_tr_rev I D u (In X) = ipurge_tr_rev I D u ws;\n        ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws;\n        D x \\<notin> sources I D u (x # xs); Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) =\n                         ipurge_tr_rev I D u ws", "assume A: \"D x \\<notin> sources I D u (x # xs)\""], ["proof (state)\nthis:\n  D x \\<notin> sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>Out X @ ipurge_tr_rev I D u (In X) = ipurge_tr_rev I D u ws;\n        ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws;\n        D x \\<notin> sources I D u (x # xs); Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) =\n                         ipurge_tr_rev I D u ws", "hence \"ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ([] @ x # xs)\""], ["proof (prove)\nusing this:\n  D x \\<notin> sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ([] @ x # xs)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ([] @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>Out X @ ipurge_tr_rev I D u (In X) = ipurge_tr_rev I D u ws;\n        ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws;\n        D x \\<notin> sources I D u (x # xs); Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) =\n                         ipurge_tr_rev I D u ws", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ([] @ x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>Out X @ ipurge_tr_rev I D u (In X) = ipurge_tr_rev I D u ws;\n        ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws;\n        D x \\<notin> sources I D u (x # xs); Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) =\n                         ipurge_tr_rev I D u ws", "have \"\\<dots> = ipurge_tr_rev I D u ([] @ ipurge_tr I D (D x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u ([] @ x # xs) =\n    ipurge_tr_rev I D u ([] @ ipurge_tr I D (D x) xs)", "using A"], ["proof (prove)\nusing this:\n  D x \\<notin> sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u ([] @ x # xs) =\n    ipurge_tr_rev I D u ([] @ ipurge_tr I D (D x) xs)", "by (rule ipurge_tr_rev_ipurge_tr_sources_1)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u ([] @ x # xs) =\n  ipurge_tr_rev I D u ([] @ ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>Out X @ ipurge_tr_rev I D u (In X) = ipurge_tr_rev I D u ws;\n        ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws;\n        D x \\<notin> sources I D u (x # xs); Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) =\n                         ipurge_tr_rev I D u ws", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ([] @ ipurge_tr I D (D x) xs)", "have\n   \"ipurge_tr_rev I D u xs = ipurge_tr_rev I D u (ipurge_tr I D (D x) xs)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ([] @ ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u xs = ipurge_tr_rev I D u (ipurge_tr I D (D x) xs)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u (ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>Out X @ ipurge_tr_rev I D u (In X) = ipurge_tr_rev I D u ws;\n        ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws;\n        D x \\<notin> sources I D u (x # xs); Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) =\n                         ipurge_tr_rev I D u ws", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u (ipurge_tr I D (D x) xs)\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>Out X @ ipurge_tr_rev I D u (In X) = ipurge_tr_rev I D u ws;\n        ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws;\n        D x \\<notin> sources I D u (x # xs); Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) =\n                         ipurge_tr_rev I D u ws", "assume \"ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws\""], ["proof (state)\nthis:\n  ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>Out X @ ipurge_tr_rev I D u (In X) = ipurge_tr_rev I D u ws;\n        ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws;\n        D x \\<notin> sources I D u (x # xs); Ia = I\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) =\n                         ipurge_tr_rev I D u ws", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u (ipurge_tr I D (D x) xs)\n  ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws", "show\n   \"ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) = ipurge_tr_rev I D u ws\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u (ipurge_tr I D (D x) xs)\n  ys @ ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ws\n\ngoal (1 subgoal):\n 1. ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) =\n    ipurge_tr_rev I D u ws", "by simp"], ["proof (state)\nthis:\n  ys @ ipurge_tr_rev I D u (ipurge_tr I D (D x) xs) = ipurge_tr_rev I D u ws\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_t_invariance_2:\n \"\\<lbrakk>Y \\<in> ipurge_tr_rev_t_set (X\\<lparr>Pol := I, Map := D\\<rparr>);\n    ipurge_tr_rev_t_inv_2 P I D ws (X\\<lparr>Pol := I, Map := D\\<rparr>)\\<rbrakk> \\<Longrightarrow>\n  ipurge_tr_rev_t_inv_2 P I D ws Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Y \\<in> ipurge_tr_rev_t_set\n                      (X\\<lparr>Pol := I, Map := D\\<rparr>);\n     ipurge_tr_rev_t_inv_2 P I D ws\n      (X\\<lparr>Pol := I, Map := D\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr_rev_t_inv_2 P I D ws Y", "proof (erule ipurge_tr_rev_t_set.induct, assumption,\n drule_tac [!] ipurge_tr_rev_t_invariance_aux,\n simp_all add: ipurge_tr_rev_t_inv_2_def, (rule impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                ws \\<in> traces P \\<longrightarrow>\n                Out X @ In X \\<in> traces P;\n        secure P I D \\<longrightarrow>\n        ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P;\n        D x\n        \\<notin> (if (D x, Dom X) \\<in> I \\<or>\n                     (\\<exists>v\\<in>sources I D (Dom X) xs.\n                         (D x, v) \\<in> I)\n                  then insert (D x) (sources Ia D (Dom X) xs)\n                  else sources Ia D (Dom X) xs);\n        Ia = I; secure P I D; ws \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr I D (D x) xs \\<in> traces P", "fix x xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                ws \\<in> traces P \\<longrightarrow>\n                Out X @ In X \\<in> traces P;\n        secure P I D \\<longrightarrow>\n        ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P;\n        D x\n        \\<notin> (if (D x, Dom X) \\<in> I \\<or>\n                     (\\<exists>v\\<in>sources I D (Dom X) xs.\n                         (D x, v) \\<in> I)\n                  then insert (D x) (sources Ia D (Dom X) xs)\n                  else sources Ia D (Dom X) xs);\n        Ia = I; secure P I D; ws \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr I D (D x) xs \\<in> traces P", "assume\n    S: \"secure P I D\" and\n    \"ws \\<in> traces P\" and\n    \"secure P I D \\<longrightarrow> ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P\""], ["proof (state)\nthis:\n  secure P I D\n  ws \\<in> traces P\n  secure P I D \\<longrightarrow>\n  ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                ws \\<in> traces P \\<longrightarrow>\n                Out X @ In X \\<in> traces P;\n        secure P I D \\<longrightarrow>\n        ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P;\n        D x\n        \\<notin> (if (D x, Dom X) \\<in> I \\<or>\n                     (\\<exists>v\\<in>sources I D (Dom X) xs.\n                         (D x, v) \\<in> I)\n                  then insert (D x) (sources Ia D (Dom X) xs)\n                  else sources Ia D (Dom X) xs);\n        Ia = I; secure P I D; ws \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr I D (D x) xs \\<in> traces P", "hence \"ys @ x # xs \\<in> traces P\""], ["proof (prove)\nusing this:\n  secure P I D\n  ws \\<in> traces P\n  secure P I D \\<longrightarrow>\n  ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. ys @ x # xs \\<in> traces P", "by simp"], ["proof (state)\nthis:\n  ys @ x # xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                ws \\<in> traces P \\<longrightarrow>\n                Out X @ In X \\<in> traces P;\n        secure P I D \\<longrightarrow>\n        ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P;\n        D x\n        \\<notin> (if (D x, Dom X) \\<in> I \\<or>\n                     (\\<exists>v\\<in>sources I D (Dom X) xs.\n                         (D x, v) \\<in> I)\n                  then insert (D x) (sources Ia D (Dom X) xs)\n                  else sources Ia D (Dom X) xs);\n        Ia = I; secure P I D; ws \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr I D (D x) xs \\<in> traces P", "hence \"(ys @ x # xs, {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ys @ x # xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. (ys @ x # xs, {}) \\<in> failures P", "by (rule traces_failures)"], ["proof (state)\nthis:\n  (ys @ x # xs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                ws \\<in> traces P \\<longrightarrow>\n                Out X @ In X \\<in> traces P;\n        secure P I D \\<longrightarrow>\n        ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P;\n        D x\n        \\<notin> (if (D x, Dom X) \\<in> I \\<or>\n                     (\\<exists>v\\<in>sources I D (Dom X) xs.\n                         (D x, v) \\<in> I)\n                  then insert (D x) (sources Ia D (Dom X) xs)\n                  else sources Ia D (Dom X) xs);\n        Ia = I; secure P I D; ws \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr I D (D x) xs \\<in> traces P", "hence \"(x # xs, {}) \\<in> futures P ys\""], ["proof (prove)\nusing this:\n  (ys @ x # xs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (x # xs, {}) \\<in> futures P ys", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (x # xs, {}) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                ws \\<in> traces P \\<longrightarrow>\n                Out X @ In X \\<in> traces P;\n        secure P I D \\<longrightarrow>\n        ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P;\n        D x\n        \\<notin> (if (D x, Dom X) \\<in> I \\<or>\n                     (\\<exists>v\\<in>sources I D (Dom X) xs.\n                         (D x, v) \\<in> I)\n                  then insert (D x) (sources Ia D (Dom X) xs)\n                  else sources Ia D (Dom X) xs);\n        Ia = I; secure P I D; ws \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr I D (D x) xs \\<in> traces P", "hence \"(ipurge_tr I D (D x) xs, ipurge_ref I D (D x) xs {}) \\<in> futures P ys\""], ["proof (prove)\nusing this:\n  (x # xs, {}) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. (ipurge_tr I D (D x) xs, ipurge_ref I D (D x) xs {}) \\<in> futures P ys", "using S"], ["proof (prove)\nusing this:\n  (x # xs, {}) \\<in> futures P ys\n  secure P I D\n\ngoal (1 subgoal):\n 1. (ipurge_tr I D (D x) xs, ipurge_ref I D (D x) xs {}) \\<in> futures P ys", "by (simp add: secure_def)"], ["proof (state)\nthis:\n  (ipurge_tr I D (D x) xs, ipurge_ref I D (D x) xs {}) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                ws \\<in> traces P \\<longrightarrow>\n                Out X @ In X \\<in> traces P;\n        secure P I D \\<longrightarrow>\n        ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P;\n        D x\n        \\<notin> (if (D x, Dom X) \\<in> I \\<or>\n                     (\\<exists>v\\<in>sources I D (Dom X) xs.\n                         (D x, v) \\<in> I)\n                  then insert (D x) (sources Ia D (Dom X) xs)\n                  else sources Ia D (Dom X) xs);\n        Ia = I; secure P I D; ws \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr I D (D x) xs \\<in> traces P", "hence \"(ys @ ipurge_tr I D (D x) xs, ipurge_ref I D (D x) xs {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (ipurge_tr I D (D x) xs, ipurge_ref I D (D x) xs {}) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. (ys @ ipurge_tr I D (D x) xs, ipurge_ref I D (D x) xs {})\n    \\<in> failures P", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (ys @ ipurge_tr I D (D x) xs, ipurge_ref I D (D x) xs {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>Ia x xs ys.\n       \\<lbrakk>secure P I D \\<longrightarrow>\n                ws \\<in> traces P \\<longrightarrow>\n                Out X @ In X \\<in> traces P;\n        secure P I D \\<longrightarrow>\n        ws \\<in> traces P \\<longrightarrow> ys @ x # xs \\<in> traces P;\n        D x\n        \\<notin> (if (D x, Dom X) \\<in> I \\<or>\n                     (\\<exists>v\\<in>sources I D (Dom X) xs.\n                         (D x, v) \\<in> I)\n                  then insert (D x) (sources Ia D (Dom X) xs)\n                  else sources Ia D (Dom X) xs);\n        Ia = I; secure P I D; ws \\<in> traces P\\<rbrakk>\n       \\<Longrightarrow> ys @ ipurge_tr I D (D x) xs \\<in> traces P", "thus \"ys @ ipurge_tr I D (D x) xs \\<in> traces P\""], ["proof (prove)\nusing this:\n  (ys @ ipurge_tr I D (D x) xs, ipurge_ref I D (D x) xs {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. ys @ ipurge_tr I D (D x) xs \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  ys @ ipurge_tr I D (D x) xs \\<in> traces P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Step 10\""], ["", "text \\<open>\nHere below are the proofs of lemmas \\<open>ipurge_tr_rev_t_equiv\\<close>, \\<open>ipurge_tr_rev_t_trace\\<close>,\nwhich are then applied to demonstrate the target closure lemma.\n\n\\null\n\\<close>"], ["", "lemma ipurge_tr_rev_t_equiv:\n \"ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "let ?X = \"\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "have \"ipurge_tr_rev_t_aux ?X\n    \\<in> ipurge_tr_rev_t_set (?X\\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n            \\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)", "by (simp add: ipurge_tr_rev_t_aux_set)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n          \\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n          \\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "have\n   \"ipurge_tr_rev_t_inv_1 I D u xs (?X\\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_inv_1 I D u xs\n     (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n      \\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)", "by (simp add: ipurge_tr_rev_t_input_1)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_inv_1 I D u xs\n   (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n    \\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n          \\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\n  ipurge_tr_rev_t_inv_1 I D u xs\n   (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n    \\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)", "have \"ipurge_tr_rev_t_inv_1 I D u xs (ipurge_tr_rev_t_aux ?X)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n          \\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\n  ipurge_tr_rev_t_inv_1 I D u xs\n   (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n    \\<lparr>Pol := I, Map := D, Dom := u\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_inv_1 I D u xs\n     (ipurge_tr_rev_t_aux\n       \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)", "by (rule ipurge_tr_rev_t_invariance_1)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_inv_1 I D u xs\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_inv_1 I D u xs\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "have \"ipurge_tr_rev_t_form (ipurge_tr_rev_t_aux ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_form\n     (ipurge_tr_rev_t_aux\n       \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)", "by (rule ipurge_tr_rev_t_form_aux)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_form\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_t_inv_1 I D u xs\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n  ipurge_tr_rev_t_form\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)", "have\n   \"ipurge_tr_rev_t_out (ipurge_tr_rev_t_aux ?X) = ipurge_tr_rev I D u xs\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_t_inv_1 I D u xs\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n  ipurge_tr_rev_t_form\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_out\n     (ipurge_tr_rev_t_aux\n       \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>) =\n    ipurge_tr_rev I D u xs", "by (rule ipurge_tr_rev_t_intro_1)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_out\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>) =\n  ipurge_tr_rev I D u xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_out\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>) =\n  ipurge_tr_rev I D u xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "have \"?X = ipurge_tr_rev_t_in I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr> =\n    ipurge_tr_rev_t_in I D u xs", "by (simp add: ipurge_tr_rev_t_in_def)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr> =\n  ipurge_tr_rev_t_in I D u xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_t_out\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>) =\n  ipurge_tr_rev I D u xs\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr> =\n  ipurge_tr_rev_t_in I D u xs", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_t_out\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>) =\n  ipurge_tr_rev I D u xs\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr> =\n  ipurge_tr_rev_t_in I D u xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs", "by (simp add: ipurge_tr_rev_t_def)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t I D u xs = ipurge_tr_rev I D u xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_t_trace [rule_format]:\n \"secure P I D \\<longrightarrow> xs \\<in> traces P \\<longrightarrow> ipurge_tr_rev_t I D u xs \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "let ?X = \"\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "have \"ipurge_tr_rev_t_aux ?X\n    \\<in> ipurge_tr_rev_t_set (?X\\<lparr>Pol := I, Map := D\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n    \\<in> ipurge_tr_rev_t_set\n           (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n            \\<lparr>Pol := I, Map := D\\<rparr>)", "by (simp add: ipurge_tr_rev_t_aux_set)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n          \\<lparr>Pol := I, Map := D\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n          \\<lparr>Pol := I, Map := D\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "have \"ipurge_tr_rev_t_inv_2 P I D xs (?X\\<lparr>Pol := I, Map := D\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_inv_2 P I D xs\n     (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n      \\<lparr>Pol := I, Map := D\\<rparr>)", "by (simp add: ipurge_tr_rev_t_input_2)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_inv_2 P I D xs\n   (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n    \\<lparr>Pol := I, Map := D\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n          \\<lparr>Pol := I, Map := D\\<rparr>)\n  ipurge_tr_rev_t_inv_2 P I D xs\n   (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n    \\<lparr>Pol := I, Map := D\\<rparr>)", "have \"ipurge_tr_rev_t_inv_2 P I D xs (ipurge_tr_rev_t_aux ?X)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_t_aux\n   \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n  \\<in> ipurge_tr_rev_t_set\n         (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n          \\<lparr>Pol := I, Map := D\\<rparr>)\n  ipurge_tr_rev_t_inv_2 P I D xs\n   (\\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>\n    \\<lparr>Pol := I, Map := D\\<rparr>)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_inv_2 P I D xs\n     (ipurge_tr_rev_t_aux\n       \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)", "by (rule ipurge_tr_rev_t_invariance_2)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_inv_2 P I D xs\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_inv_2 P I D xs\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "have \"ipurge_tr_rev_t_form (ipurge_tr_rev_t_aux ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_t_form\n     (ipurge_tr_rev_t_aux\n       \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)", "by (rule ipurge_tr_rev_t_form_aux)"], ["proof (state)\nthis:\n  ipurge_tr_rev_t_form\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_t_inv_2 P I D xs\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n  ipurge_tr_rev_t_form\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)", "have \"secure P I D \\<longrightarrow> xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t_out (ipurge_tr_rev_t_aux ?X) \\<in> traces P\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_t_inv_2 P I D xs\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n  ipurge_tr_rev_t_form\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t_out\n     (ipurge_tr_rev_t_aux\n       \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n    \\<in> traces P", "by (rule ipurge_tr_rev_t_intro_2)"], ["proof (state)\nthis:\n  secure P I D \\<longrightarrow>\n  xs \\<in> traces P \\<longrightarrow>\n  ipurge_tr_rev_t_out\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n  \\<in> traces P\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  secure P I D \\<longrightarrow>\n  xs \\<in> traces P \\<longrightarrow>\n  ipurge_tr_rev_t_out\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n  \\<in> traces P\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "have \"?X = ipurge_tr_rev_t_in I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr> =\n    ipurge_tr_rev_t_in I D u xs", "by (simp add: ipurge_tr_rev_t_in_def)"], ["proof (state)\nthis:\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr> =\n  ipurge_tr_rev_t_in I D u xs\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  secure P I D \\<longrightarrow>\n  xs \\<in> traces P \\<longrightarrow>\n  ipurge_tr_rev_t_out\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n  \\<in> traces P\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr> =\n  ipurge_tr_rev_t_in I D u xs", "show ?thesis"], ["proof (prove)\nusing this:\n  secure P I D \\<longrightarrow>\n  xs \\<in> traces P \\<longrightarrow>\n  ipurge_tr_rev_t_out\n   (ipurge_tr_rev_t_aux\n     \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr>)\n  \\<in> traces P\n  \\<lparr>Pol = I, Map = D, Dom = u, In = xs, Out = []\\<rparr> =\n  ipurge_tr_rev_t_in I D u xs\n\ngoal (1 subgoal):\n 1. secure P I D \\<longrightarrow>\n    xs \\<in> traces P \\<longrightarrow>\n    ipurge_tr_rev_t I D u xs \\<in> traces P", "by (simp add: ipurge_tr_rev_t_def)"], ["proof (state)\nthis:\n  secure P I D \\<longrightarrow>\n  xs \\<in> traces P \\<longrightarrow>\n  ipurge_tr_rev_t I D u xs \\<in> traces P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_trace:\n \"secure P I D \\<Longrightarrow> xs \\<in> traces P \\<Longrightarrow> ipurge_tr_rev I D u xs \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D; xs \\<in> traces P\\<rbrakk>\n    \\<Longrightarrow> ipurge_tr_rev I D u xs \\<in> traces P", "by (subst ipurge_tr_rev_t_equiv [symmetric], rule ipurge_tr_rev_t_trace)"], ["", "subsection \"The Inductive Unwinding Theorem in its general form\""], ["", "text \\<open>\nIn what follows, the Inductive Unwinding Theorem is proven, in the form applying to a generic\nprocess. The equivalence of the condition expressed by the theorem to CSP noninterference security,\nas defined in \\cite{R2}, is demonstrated by showing that it is necessary and sufficient for the\nverification of the condition expressed by the Ipurge Unwinding Theorem, under the same assumption\nthat the sets of refusals of the process be closed under union (cf. \\cite{R3}).\n\nParticularly, the closure of the traces of a secure process under function @{term ipurge_tr_rev} and\nthe idempotence of this function are used in the proof of condition necessity.\n\n\\null\n\\<close>"], ["", "lemma inductive_unwinding_1:\n  assumes\n    R: \"ref_union_closed P\" and\n    S: \"secure P I D\"\n  shows \"\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>traces P.\n       \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n          next_dom_events P D u (ipurge_tr_rev I D u xs) =\n          next_dom_events P D u xs \\<and>\n          ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n          ref_dom_events P D u xs", "proof (rule ballI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "fix xs u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "from R and S"], ["proof (chain)\npicking this:\n  ref_union_closed P\n  secure P I D", "have \"\\<forall>u \\<in> range D \\<inter> (- I) `` range D. \\<forall>xs ys.\n    xs \\<in> traces P \\<and> ys \\<in> traces P \\<and>\n      ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  ref_union_closed P\n  secure P I D\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          xs \\<in> traces P \\<and>\n          ys \\<in> traces P \\<and>\n          ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n          next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n          ref_dom_events P D u xs = ref_dom_events P D u ys", "by (simp add: ipurge_unwinding weakly_future_consistent_def rel_ipurge_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        xs \\<in> traces P \\<and>\n        ys \\<in> traces P \\<and>\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        xs \\<in> traces P \\<and>\n        ys \\<in> traces P \\<and>\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "assume \"u \\<in> range D \\<inter> (- I) `` range D\""], ["proof (state)\nthis:\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        xs \\<in> traces P \\<and>\n        ys \\<in> traces P \\<and>\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  u \\<in> range D \\<inter> (- I) `` range D", "have \"\\<forall>xs ys.\n    xs \\<in> traces P \\<and> ys \\<in> traces P \\<and>\n      ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        xs \\<in> traces P \\<and>\n        ys \\<in> traces P \\<and>\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       xs \\<in> traces P \\<and>\n       ys \\<in> traces P \\<and>\n       ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n       next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n       ref_dom_events P D u xs = ref_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     xs \\<in> traces P \\<and>\n     ys \\<in> traces P \\<and>\n     ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n     next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n     ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "hence\n   \"ipurge_tr_rev I D u xs \\<in> traces P \\<and> xs \\<in> traces P \\<and>\n      ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs \\<longrightarrow>\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     xs \\<in> traces P \\<and>\n     ys \\<in> traces P \\<and>\n     ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n     next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n     ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u xs \\<in> traces P \\<and>\n    xs \\<in> traces P \\<and>\n    ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) =\n    ipurge_tr_rev I D u xs \\<longrightarrow>\n    next_dom_events P D u (ipurge_tr_rev I D u xs) =\n    next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs", "by blast"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs \\<in> traces P \\<and>\n  xs \\<in> traces P \\<and>\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) =\n  ipurge_tr_rev I D u xs \\<longrightarrow>\n  next_dom_events P D u (ipurge_tr_rev I D u xs) =\n  next_dom_events P D u xs \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs \\<in> traces P \\<and>\n  xs \\<in> traces P \\<and>\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) =\n  ipurge_tr_rev I D u xs \\<longrightarrow>\n  next_dom_events P D u (ipurge_tr_rev I D u xs) =\n  next_dom_events P D u xs \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "assume xs: \"xs \\<in> traces P\""], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "moreover"], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "from S and xs"], ["proof (chain)\npicking this:\n  secure P I D\n  xs \\<in> traces P", "have \"ipurge_tr_rev I D u xs \\<in> traces P\""], ["proof (prove)\nusing this:\n  secure P I D\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u xs \\<in> traces P", "by (rule ipurge_tr_rev_trace)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "have\n   \"ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs", "by (rule ipurge_tr_rev_idem)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs \\<and>\n                         ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         ref_dom_events P D u xs", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D u xs \\<in> traces P \\<and>\n  xs \\<in> traces P \\<and>\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) =\n  ipurge_tr_rev I D u xs \\<longrightarrow>\n  next_dom_events P D u (ipurge_tr_rev I D u xs) =\n  next_dom_events P D u xs \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n  xs \\<in> traces P\n  ipurge_tr_rev I D u xs \\<in> traces P\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs", "show\n   \"next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D u xs \\<in> traces P \\<and>\n  xs \\<in> traces P \\<and>\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) =\n  ipurge_tr_rev I D u xs \\<longrightarrow>\n  next_dom_events P D u (ipurge_tr_rev I D u xs) =\n  next_dom_events P D u xs \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n  xs \\<in> traces P\n  ipurge_tr_rev I D u xs \\<in> traces P\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u (ipurge_tr_rev I D u xs) =\n    next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs", "by simp"], ["proof (state)\nthis:\n  next_dom_events P D u (ipurge_tr_rev I D u xs) =\n  next_dom_events P D u xs \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inductive_unwinding_2:\n  assumes\n    R: \"ref_union_closed P\" and\n    S: \"\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n      next_dom_events P D u (ipurge_tr_rev I D u xs) =\n        next_dom_events P D u xs \\<and>\n      ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n        ref_dom_events P D u xs\"\n  shows \"secure P I D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure P I D", "proof (simp add: ipurge_unwinding [OF R] weakly_future_consistent_def rel_ipurge_def,\n rule ballI, (rule allI)+, rule impI, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "fix u xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "assume \"xs \\<in> traces P\""], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "with S"], ["proof (chain)\npicking this:\n  \\<forall>xs\\<in>traces P.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        next_dom_events P D u (ipurge_tr_rev I D u xs) =\n        next_dom_events P D u xs \\<and>\n        ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n        ref_dom_events P D u xs\n  xs \\<in> traces P", "have \"\\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\""], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>traces P.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        next_dom_events P D u (ipurge_tr_rev I D u xs) =\n        next_dom_events P D u xs \\<and>\n        ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n        ref_dom_events P D u xs\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       next_dom_events P D u (ipurge_tr_rev I D u xs) =\n       next_dom_events P D u xs \\<and>\n       ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n       ref_dom_events P D u xs", ".."], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u xs) =\n     next_dom_events P D u xs \\<and>\n     ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u xs) =\n     next_dom_events P D u xs \\<and>\n     ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "assume A: \"u \\<in> range D \\<inter> (- I) `` range D\""], ["proof (state)\nthis:\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u xs) =\n     next_dom_events P D u xs \\<and>\n     ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n  u \\<in> range D \\<inter> (- I) `` range D", "have B:\n   \"next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u xs) =\n     next_dom_events P D u xs \\<and>\n     ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. next_dom_events P D u (ipurge_tr_rev I D u xs) =\n    next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs", ".."], ["proof (state)\nthis:\n  next_dom_events P D u (ipurge_tr_rev I D u xs) =\n  next_dom_events P D u xs \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "assume \"ys \\<in> traces P\""], ["proof (state)\nthis:\n  ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "with S"], ["proof (chain)\npicking this:\n  \\<forall>xs\\<in>traces P.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        next_dom_events P D u (ipurge_tr_rev I D u xs) =\n        next_dom_events P D u xs \\<and>\n        ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n        ref_dom_events P D u xs\n  ys \\<in> traces P", "have \"\\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u ys) = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>traces P.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        next_dom_events P D u (ipurge_tr_rev I D u xs) =\n        next_dom_events P D u xs \\<and>\n        ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n        ref_dom_events P D u xs\n  ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       next_dom_events P D u (ipurge_tr_rev I D u ys) =\n       next_dom_events P D u ys \\<and>\n       ref_dom_events P D u (ipurge_tr_rev I D u ys) =\n       ref_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u ys) =\n     next_dom_events P D u ys \\<and>\n     ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "hence\n   \"next_dom_events P D u (ipurge_tr_rev I D u ys) = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u ys) =\n     next_dom_events P D u ys \\<and>\n     ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. next_dom_events P D u (ipurge_tr_rev I D u ys) =\n    next_dom_events P D u ys \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys", "using A"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u ys) =\n     next_dom_events P D u ys \\<and>\n     ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. next_dom_events P D u (ipurge_tr_rev I D u ys) =\n    next_dom_events P D u ys \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  next_dom_events P D u (ipurge_tr_rev I D u ys) =\n  next_dom_events P D u ys \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "moreover"], ["proof (state)\nthis:\n  next_dom_events P D u (ipurge_tr_rev I D u ys) =\n  next_dom_events P D u ys \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "assume \"ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\""], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "ultimately"], ["proof (chain)\npicking this:\n  next_dom_events P D u (ipurge_tr_rev I D u ys) =\n  next_dom_events P D u ys \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys", "show\n   \"next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  next_dom_events P D u (ipurge_tr_rev I D u ys) =\n  next_dom_events P D u ys \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "using B"], ["proof (prove)\nusing this:\n  next_dom_events P D u (ipurge_tr_rev I D u ys) =\n  next_dom_events P D u ys \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u ys) = ref_dom_events P D u ys\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\n  next_dom_events P D u (ipurge_tr_rev I D u xs) =\n  next_dom_events P D u xs \\<and>\n  ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "by simp"], ["proof (state)\nthis:\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem inductive_unwinding:\n \"ref_union_closed P \\<Longrightarrow>\n  secure P I D =\n  (\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs \\<and>\n    ref_dom_events P D u (ipurge_tr_rev I D u xs) = ref_dom_events P D u xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref_union_closed P \\<Longrightarrow>\n    secure P I D =\n    (\\<forall>xs\\<in>traces P.\n        \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n           next_dom_events P D u (ipurge_tr_rev I D u xs) =\n           next_dom_events P D u xs \\<and>\n           ref_dom_events P D u (ipurge_tr_rev I D u xs) =\n           ref_dom_events P D u xs)", "by (rule iffI, rule inductive_unwinding_1, assumption+, rule inductive_unwinding_2)"], ["", "text \\<open>\n\\null\n\nInterestingly, this necessary and sufficient condition for the noninterference security of a process\nresembles the classical definition of noninterference security for a deterministic state machine\nwith outputs formulated in \\cite{R5}, which is formalized in \\cite{R2} as predicate\n\\<open>c_secure\\<close>.\n\nDenoting with (1) the former and with (2) the latter, the differences between them can be summarized\nas follows:\n\n\\begin{itemize}\n\n\\item\nThe event list appearing in (1) is constrained to vary over process traces, whereas the action list\nappearing in (2) is unconstrained.\n\\\\This comes as no surprise, since the state machines used as model of computation in \\cite{R5}\naccept any action list as a trace.\n\n\\item\nThe definition of function @{term ipurge_tr_rev}, used in (1), does not implicitly assume that the\nnoninterference policy be reflexive, even though any policy of practical significance will be such.\nOn the contrary, the definition of the intransitive purge function used in (2), which is formalized\nin \\cite{R2} as function \\<open>c_ipurge\\<close>, makes this implicit assumption, as shown by the\nconsideration that \\<open>c_ipurge I D (D x) [x] = [x]\\<close> regardless of whether\n@{term \"(D x, D x) \\<in> I\"} or not.\n\\\\This is the mathematical reason why the equivalence between CSP noninterference security and\nclassical noninterference security for deterministic state machines with outputs, proven in\n\\cite{R2}, is subordinated to the assumption that the noninterference policy be reflexive.\n\n\\item\nThe equality of action outputs appearing in (2) is replaced in (1) by the equality of accepted and\nrefused events.\n\n\\end{itemize}\n\nThe binding of the universal quantification over domains contained in (1) does not constitute an\nactual difference, since in (2) the purge function is only applied to domains in the range of the\nevent-domain map, and its output matches the entire input action list, thus rendering the equation\ntrivial, for domains allowed to be affected by any event domain.\n\\<close>"], ["", "subsection \"The Inductive Unwinding Theorem for deterministic and trace set processes\""], ["", "text \\<open>\nHere below are the proofs of specific variants of the Inductive Unwinding Theorem applying to\ndeterministic processes and trace set processes \\cite{R3}. The variant for deterministic processes\nis derived, following the above proof of the general form of the theorem, from the Ipurge Unwinding\nTheorem for deterministic processes \\cite{R3}. Then, the variant for trace set processes is inferred\nfrom the variant for deterministic processes.\n\nSimilarly to what happens for the Ipurge Unwinding Theorem, the refusals union closure assumption\nthat characterizes the general form of the Inductive Unwinding Theorem is replaced by the assumption\nthat the process actually be deterministic in the variant for deterministic processes, and by the\nassumption that the set of traces actually be such in the variant for trace set processes. Moreover,\nthese variants involve accepted events only, in accordance with the fact that in deterministic\nprocesses, refused events are completely specified by accepted events (cf. \\cite{R4}, \\cite{R2}).\n\n\\null\n\\<close>"], ["", "lemma d_inductive_unwinding_1:\n  assumes\n    D: \"deterministic P\" and\n    S: \"secure P I D\"\n  shows \"\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>traces P.\n       \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n          next_dom_events P D u (ipurge_tr_rev I D u xs) =\n          next_dom_events P D u xs", "proof (rule ballI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "fix xs u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "from D and S"], ["proof (chain)\npicking this:\n  deterministic P\n  secure P I D", "have \"\\<forall>u \\<in> range D \\<inter> (- I) `` range D. \\<forall>xs ys.\n    xs \\<in> traces P \\<and> ys \\<in> traces P \\<and>\n      ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  deterministic P\n  secure P I D\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          xs \\<in> traces P \\<and>\n          ys \\<in> traces P \\<and>\n          ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n          next_dom_events P D u xs = next_dom_events P D u ys", "by (simp add: d_ipurge_unwinding d_weakly_future_consistent_def rel_ipurge_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        xs \\<in> traces P \\<and>\n        ys \\<in> traces P \\<and>\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        xs \\<in> traces P \\<and>\n        ys \\<in> traces P \\<and>\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "assume \"u \\<in> range D \\<inter> (- I) `` range D\""], ["proof (state)\nthis:\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        xs \\<in> traces P \\<and>\n        ys \\<in> traces P \\<and>\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n  u \\<in> range D \\<inter> (- I) `` range D", "have \"\\<forall>xs ys.\n    xs \\<in> traces P \\<and> ys \\<in> traces P \\<and>\n      ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        xs \\<in> traces P \\<and>\n        ys \\<in> traces P \\<and>\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       xs \\<in> traces P \\<and>\n       ys \\<in> traces P \\<and>\n       ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n       next_dom_events P D u xs = next_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     xs \\<in> traces P \\<and>\n     ys \\<in> traces P \\<and>\n     ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n     next_dom_events P D u xs = next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "hence\n   \"ipurge_tr_rev I D u xs \\<in> traces P \\<and> xs \\<in> traces P \\<and>\n      ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs \\<longrightarrow>\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     xs \\<in> traces P \\<and>\n     ys \\<in> traces P \\<and>\n     ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys \\<longrightarrow>\n     next_dom_events P D u xs = next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u xs \\<in> traces P \\<and>\n    xs \\<in> traces P \\<and>\n    ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) =\n    ipurge_tr_rev I D u xs \\<longrightarrow>\n    next_dom_events P D u (ipurge_tr_rev I D u xs) =\n    next_dom_events P D u xs", "by blast"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs \\<in> traces P \\<and>\n  xs \\<in> traces P \\<and>\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) =\n  ipurge_tr_rev I D u xs \\<longrightarrow>\n  next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs \\<in> traces P \\<and>\n  xs \\<in> traces P \\<and>\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) =\n  ipurge_tr_rev I D u xs \\<longrightarrow>\n  next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "assume xs: \"xs \\<in> traces P\""], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "moreover"], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "from S and xs"], ["proof (chain)\npicking this:\n  secure P I D\n  xs \\<in> traces P", "have \"ipurge_tr_rev I D u xs \\<in> traces P\""], ["proof (prove)\nusing this:\n  secure P I D\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u xs \\<in> traces P", "by (rule ipurge_tr_rev_trace)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "have\n   \"ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs", "by (rule ipurge_tr_rev_idem)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs\n\ngoal (1 subgoal):\n 1. \\<And>xs u.\n       \\<lbrakk>xs \\<in> traces P;\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u (ipurge_tr_rev I D u xs) =\n                         next_dom_events P D u xs", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D u xs \\<in> traces P \\<and>\n  xs \\<in> traces P \\<and>\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) =\n  ipurge_tr_rev I D u xs \\<longrightarrow>\n  next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\n  xs \\<in> traces P\n  ipurge_tr_rev I D u xs \\<in> traces P\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs", "show\n   \"next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D u xs \\<in> traces P \\<and>\n  xs \\<in> traces P \\<and>\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) =\n  ipurge_tr_rev I D u xs \\<longrightarrow>\n  next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\n  xs \\<in> traces P\n  ipurge_tr_rev I D u xs \\<in> traces P\n  ipurge_tr_rev I D u (ipurge_tr_rev I D u xs) = ipurge_tr_rev I D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u (ipurge_tr_rev I D u xs) =\n    next_dom_events P D u xs", "by simp"], ["proof (state)\nthis:\n  next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_inductive_unwinding_2:\n  assumes\n    D: \"deterministic P\" and\n    S: \"\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n      next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\"\n  shows \"secure P I D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure P I D", "proof (simp add: d_ipurge_unwinding [OF D] d_weakly_future_consistent_def rel_ipurge_def,\n rule ballI, (rule allI)+, rule impI, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "fix u xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "assume \"xs \\<in> traces P\""], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "with S"], ["proof (chain)\npicking this:\n  \\<forall>xs\\<in>traces P.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        next_dom_events P D u (ipurge_tr_rev I D u xs) =\n        next_dom_events P D u xs\n  xs \\<in> traces P", "have \"\\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\""], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>traces P.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        next_dom_events P D u (ipurge_tr_rev I D u xs) =\n        next_dom_events P D u xs\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       next_dom_events P D u (ipurge_tr_rev I D u xs) =\n       next_dom_events P D u xs", ".."], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u xs) =\n     next_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u xs) =\n     next_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "assume A: \"u \\<in> range D \\<inter> (- I) `` range D\""], ["proof (state)\nthis:\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u xs) =\n     next_dom_events P D u xs\n  u \\<in> range D \\<inter> (- I) `` range D", "have B:\n   \"next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u xs) =\n     next_dom_events P D u xs\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. next_dom_events P D u (ipurge_tr_rev I D u xs) =\n    next_dom_events P D u xs", ".."], ["proof (state)\nthis:\n  next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "assume \"ys \\<in> traces P\""], ["proof (state)\nthis:\n  ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "with S"], ["proof (chain)\npicking this:\n  \\<forall>xs\\<in>traces P.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        next_dom_events P D u (ipurge_tr_rev I D u xs) =\n        next_dom_events P D u xs\n  ys \\<in> traces P", "have \"\\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u ys) = next_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>traces P.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        next_dom_events P D u (ipurge_tr_rev I D u xs) =\n        next_dom_events P D u xs\n  ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       next_dom_events P D u (ipurge_tr_rev I D u ys) =\n       next_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u ys) =\n     next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "hence\n   \"next_dom_events P D u (ipurge_tr_rev I D u ys) = next_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u ys) =\n     next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. next_dom_events P D u (ipurge_tr_rev I D u ys) =\n    next_dom_events P D u ys", "using A"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     next_dom_events P D u (ipurge_tr_rev I D u ys) =\n     next_dom_events P D u ys\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. next_dom_events P D u (ipurge_tr_rev I D u ys) =\n    next_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  next_dom_events P D u (ipurge_tr_rev I D u ys) = next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "moreover"], ["proof (state)\nthis:\n  next_dom_events P D u (ipurge_tr_rev I D u ys) = next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "assume \"ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\""], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>u \\<in> range D \\<inter> (- I) `` range D;\n        xs \\<in> traces P; ys \\<in> traces P;\n        ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs = next_dom_events P D u ys", "ultimately"], ["proof (chain)\npicking this:\n  next_dom_events P D u (ipurge_tr_rev I D u ys) = next_dom_events P D u ys\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys", "show \"next_dom_events P D u xs = next_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  next_dom_events P D u (ipurge_tr_rev I D u ys) = next_dom_events P D u ys\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys", "using B"], ["proof (prove)\nusing this:\n  next_dom_events P D u (ipurge_tr_rev I D u ys) = next_dom_events P D u ys\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\n  next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys", "by simp"], ["proof (state)\nthis:\n  next_dom_events P D u xs = next_dom_events P D u ys\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem d_inductive_unwinding:\n \"deterministic P \\<Longrightarrow>\n  secure P I D =\n  (\\<forall>xs \\<in> traces P. \\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n    next_dom_events P D u (ipurge_tr_rev I D u xs) = next_dom_events P D u xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic P \\<Longrightarrow>\n    secure P I D =\n    (\\<forall>xs\\<in>traces P.\n        \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n           next_dom_events P D u (ipurge_tr_rev I D u xs) =\n           next_dom_events P D u xs)", "by (rule iffI, rule d_inductive_unwinding_1, assumption+, rule d_inductive_unwinding_2)"], ["", "theorem ts_inductive_unwinding:\n  assumes T: \"trace_set T\"\n  shows \"secure (ts_process T) I D =\n    (\\<forall>xs \\<in> T. \\<forall>u \\<in> range D \\<inter> (-I) `` range D. \\<forall>x \\<in> D -` {u}.\n      (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T))\"\n    (is \"secure ?P I D = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure (ts_process T) I D =\n    (\\<forall>xs\\<in>T.\n        \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n           \\<forall>x\\<in>D -` {u}.\n              (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T))", "proof (subst d_inductive_unwinding, rule ts_process_d [OF T],\n simp add: next_dom_events_def ts_process_next_events [OF T] set_eq_iff,\n rule iffI, (rule ballI)+, (rule_tac [2] ballI)+, rule_tac [2] allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "fix xs u x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "assume A: \"\\<forall>xs \\<in> traces ?P. \\<forall>u \\<in> range D \\<inter> (- I) `` range D.\n    \\<forall>x. (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) = (u = D x \\<and> xs @ [x] \\<in> T)\""], ["proof (state)\nthis:\n  \\<forall>xs\\<in>traces (ts_process T).\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        \\<forall>x.\n           (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n           (u = D x \\<and> xs @ [x] \\<in> T)\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "assume \"xs \\<in> T\""], ["proof (state)\nthis:\n  xs \\<in> T\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "moreover"], ["proof (state)\nthis:\n  xs \\<in> T\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "have \"traces ?P = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traces (ts_process T) = T", "using T"], ["proof (prove)\nusing this:\n  trace_set T\n\ngoal (1 subgoal):\n 1. traces (ts_process T) = T", "by (rule ts_process_traces)"], ["proof (state)\nthis:\n  traces (ts_process T) = T\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "ultimately"], ["proof (chain)\npicking this:\n  xs \\<in> T\n  traces (ts_process T) = T", "have \"xs \\<in> traces ?P\""], ["proof (prove)\nusing this:\n  xs \\<in> T\n  traces (ts_process T) = T\n\ngoal (1 subgoal):\n 1. xs \\<in> traces (ts_process T)", "by simp"], ["proof (state)\nthis:\n  xs \\<in> traces (ts_process T)\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "with A"], ["proof (chain)\npicking this:\n  \\<forall>xs\\<in>traces (ts_process T).\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        \\<forall>x.\n           (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n           (u = D x \\<and> xs @ [x] \\<in> T)\n  xs \\<in> traces (ts_process T)", "have \"\\<forall>u \\<in> range D \\<inter> (- I) `` range D.\n    \\<forall>x. (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n      (u = D x \\<and> xs @ [x] \\<in> T)\""], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>traces (ts_process T).\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        \\<forall>x.\n           (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n           (u = D x \\<and> xs @ [x] \\<in> T)\n  xs \\<in> traces (ts_process T)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>x.\n          (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n          (u = D x \\<and> xs @ [x] \\<in> T)", ".."], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>x.\n        (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n        (u = D x \\<and> xs @ [x] \\<in> T)\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>x.\n        (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n        (u = D x \\<and> xs @ [x] \\<in> T)\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "assume \"u \\<in> range D \\<inter> (- I) `` range D\""], ["proof (state)\nthis:\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>x.\n        (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n        (u = D x \\<and> xs @ [x] \\<in> T)\n  u \\<in> range D \\<inter> (- I) `` range D", "have\n   \"\\<forall>x. (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n      (u = D x \\<and> xs @ [x] \\<in> T)\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>x.\n        (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n        (u = D x \\<and> xs @ [x] \\<in> T)\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n       (u = D x \\<and> xs @ [x] \\<in> T)", ".."], ["proof (state)\nthis:\n  \\<forall>x.\n     (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n     (u = D x \\<and> xs @ [x] \\<in> T)\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "hence \"(u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n    (u = D x \\<and> xs @ [x] \\<in> T)\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n     (u = D x \\<and> xs @ [x] \\<in> T)\n\ngoal (1 subgoal):\n 1. (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n    (u = D x \\<and> xs @ [x] \\<in> T)", ".."], ["proof (state)\nthis:\n  (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n  (u = D x \\<and> xs @ [x] \\<in> T)\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "moreover"], ["proof (state)\nthis:\n  (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n  (u = D x \\<and> xs @ [x] \\<in> T)\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "assume \"x \\<in> D -` {u}\""], ["proof (state)\nthis:\n  x \\<in> D -` {u}\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "hence \"u = D x\""], ["proof (prove)\nusing this:\n  x \\<in> D -` {u}\n\ngoal (1 subgoal):\n 1. u = D x", "by simp"], ["proof (state)\nthis:\n  u = D x\n\ngoal (2 subgoals):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>traces (ts_process T).\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x.\n                         (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T);\n        xs \\<in> T; u \\<in> range D \\<inter> (- I) `` range D;\n        x \\<in> D -` {u}\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T)\n 2. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "ultimately"], ["proof (chain)\npicking this:\n  (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n  (u = D x \\<and> xs @ [x] \\<in> T)\n  u = D x", "show \"(ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\""], ["proof (prove)\nusing this:\n  (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n  (u = D x \\<and> xs @ [x] \\<in> T)\n  u = D x\n\ngoal (1 subgoal):\n 1. (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)", "by simp"], ["proof (state)\nthis:\n  (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "fix xs u x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "assume A: \"\\<forall>xs \\<in> T. \\<forall>u \\<in> range D \\<inter> (- I) `` range D.\n    \\<forall>x \\<in> D -` {u}. (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\""], ["proof (state)\nthis:\n  \\<forall>xs\\<in>T.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        \\<forall>x\\<in>D -` {u}.\n           (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "assume \"xs \\<in> traces ?P\""], ["proof (state)\nthis:\n  xs \\<in> traces (ts_process T)\n\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "moreover"], ["proof (state)\nthis:\n  xs \\<in> traces (ts_process T)\n\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "have \"traces ?P = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traces (ts_process T) = T", "using T"], ["proof (prove)\nusing this:\n  trace_set T\n\ngoal (1 subgoal):\n 1. traces (ts_process T) = T", "by (rule ts_process_traces)"], ["proof (state)\nthis:\n  traces (ts_process T) = T\n\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "ultimately"], ["proof (chain)\npicking this:\n  xs \\<in> traces (ts_process T)\n  traces (ts_process T) = T", "have \"xs \\<in> T\""], ["proof (prove)\nusing this:\n  xs \\<in> traces (ts_process T)\n  traces (ts_process T) = T\n\ngoal (1 subgoal):\n 1. xs \\<in> T", "by simp"], ["proof (state)\nthis:\n  xs \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "with A"], ["proof (chain)\npicking this:\n  \\<forall>xs\\<in>T.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        \\<forall>x\\<in>D -` {u}.\n           (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n  xs \\<in> T", "have \"\\<forall>u \\<in> range D \\<inter> (- I) `` range D.\n    \\<forall>x \\<in> D -` {u}. (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\""], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>T.\n     \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n        \\<forall>x\\<in>D -` {u}.\n           (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n  xs \\<in> T\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>x\\<in>D -` {u}.\n          (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)", ".."], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>x\\<in>D -` {u}.\n        (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>x\\<in>D -` {u}.\n        (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "assume \"u \\<in> range D \\<inter> (- I) `` range D\""], ["proof (state)\nthis:\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>x\\<in>D -` {u}.\n        (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n  u \\<in> range D \\<inter> (- I) `` range D", "have B:\n   \"\\<forall>x \\<in> D -` {u}. (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>x\\<in>D -` {u}.\n        (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>D -` {u}.\n       (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)", ".."], ["proof (state)\nthis:\n  \\<forall>x\\<in>D -` {u}.\n     (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n\ngoal (1 subgoal):\n 1. \\<And>xs u x.\n       \\<lbrakk>\\<forall>xs\\<in>T.\n                   \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                      \\<forall>x\\<in>D -` {u}.\n                         (ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (xs @ [x] \\<in> T);\n        xs \\<in> traces (ts_process T);\n        u \\<in> range D \\<inter> (- I) `` range D\\<rbrakk>\n       \\<Longrightarrow> (u = D x \\<and>\n                          ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n                         (u = D x \\<and> xs @ [x] \\<in> T)", "show \"(u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n    (u = D x \\<and> xs @ [x] \\<in> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n    (u = D x \\<and> xs @ [x] \\<in> T)", "proof (cases \"D x = u\", simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. D x = u \\<Longrightarrow>\n    (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)", "case True"], ["proof (state)\nthis:\n  D x = u\n\ngoal (1 subgoal):\n 1. D x = u \\<Longrightarrow>\n    (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)", "hence \"x \\<in> D -` {u}\""], ["proof (prove)\nusing this:\n  D x = u\n\ngoal (1 subgoal):\n 1. x \\<in> D -` {u}", "by simp"], ["proof (state)\nthis:\n  x \\<in> D -` {u}\n\ngoal (1 subgoal):\n 1. D x = u \\<Longrightarrow>\n    (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)", "with B"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>D -` {u}.\n     (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n  x \\<in> D -` {u}", "show \"(ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>D -` {u}.\n     (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n  x \\<in> D -` {u}\n\ngoal (1 subgoal):\n 1. (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)", ".."], ["proof (state)\nthis:\n  (ipurge_tr_rev I D u xs @ [x] \\<in> T) = (xs @ [x] \\<in> T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u = D x \\<and> ipurge_tr_rev I D u xs @ [x] \\<in> T) =\n  (u = D x \\<and> xs @ [x] \\<in> T)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}