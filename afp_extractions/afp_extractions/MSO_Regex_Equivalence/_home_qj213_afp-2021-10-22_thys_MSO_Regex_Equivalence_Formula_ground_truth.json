{"file_name": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence/Formula.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence", "problem_names": ["lemma \\<pi>_\\<sigma>: \"\\<pi> ` (set o \\<sigma> \\<Sigma>) (n + 1) = (set o \\<sigma> \\<Sigma>) n\"", "lemma max_idx_vars: \"pre_wf_formula n \\<phi> \\<Longrightarrow> \\<forall>p \\<in> FOV \\<phi> \\<union> SOV \\<phi>. p < n\"", "lemma finite_FOV: \"finite (FOV \\<phi>)\"", "lemma wf_rexp_valid_ENC: \"n = 0 \\<or> p < n \\<Longrightarrow> wf n (valid_ENC n p)\"", "lemma wf_rexp_ENC: \"\\<lbrakk>finite V; n = 0 \\<or> (\\<forall>v \\<in> V. v < n)\\<rbrakk> \\<Longrightarrow> wf n (ENC n V)\"", "lemma enc_atom_\\<sigma>_eq: \"i < length w \\<Longrightarrow>\n (length I = n \\<and> p \\<in> set \\<Sigma>) \\<longleftrightarrow> enc_atom I i p \\<in> set (\\<sigma> \\<Sigma> n)\"", "lemmas enc_atom_\\<sigma> = iffD1[OF enc_atom_\\<sigma>_eq, OF _ conjI]", "lemma enc_atom_bool_take_drop_True:\n  \"\\<lbrakk>r < length I; case I ! r of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P\\<rbrakk> \\<Longrightarrow>\n    enc_atom_bool I p = take r (enc_atom_bool I p) @ True # drop (Suc r) (enc_atom_bool I p)\"", "lemma enc_atom_bool_take_drop_True2:\n  \"\\<lbrakk>r < length I; case I ! r of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P;\n    s < length I; case I ! s of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P; r < s\\<rbrakk> \\<Longrightarrow>\n    enc_atom_bool I p = take r (enc_atom_bool I p) @ True #\n      take (s - Suc r) (drop (Suc r) (enc_atom_bool I p)) @ True #\n      drop (Suc s) (enc_atom_bool I p)\"", "lemma enc_atom_bool_take_drop_False:\n  \"\\<lbrakk>r < length I; case I ! r of Inl p' \\<Rightarrow> p \\<noteq> p' | Inr P \\<Rightarrow> p \\<notin> P\\<rbrakk> \\<Longrightarrow>\n    enc_atom_bool I p = take r (enc_atom_bool I p) @ False # drop (Suc r) (enc_atom_bool I p)\"", "lemma enc_atom_lang_AQ: \"\\<lbrakk>r < length I;\n   case I ! r of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P; length I = n; a \\<in> set \\<Sigma>\\<rbrakk> \\<Longrightarrow>\n  [enc_atom I p a] \\<in> lang n (Atom (AQ r a))\"", "lemma enc_atom_lang_Arbitrary_Except_True: \"\\<lbrakk>r < length I;\n   case I ! r of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P; length I = n; a \\<in> set \\<Sigma>\\<rbrakk> \\<Longrightarrow>\n  [enc_atom I p a] \\<in> lang n (Atom (Arbitrary_Except r True))\"", "lemma enc_atom_lang_Arbitrary_Except2:\"\\<lbrakk>r < length I; s < length I; \n  case I ! r of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P;\n  case I ! s of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P; length I = n; a \\<in> set \\<Sigma>\\<rbrakk> \\<Longrightarrow>\n  [enc_atom I p a] \\<in> lang n (Atom (Arbitrary_Except2 r s))\"", "lemma enc_atom_lang_Arbitrary_Except_False: \"\\<lbrakk>r < length I;\n  case I ! r of Inl p' \\<Rightarrow> p \\<noteq> p' | Inr P \\<Rightarrow> p \\<notin> P; length I = n; a \\<in> set \\<Sigma>\\<rbrakk> \\<Longrightarrow>\n  [enc_atom I p a] \\<in> lang n (Atom (Arbitrary_Except r False))\"", "lemma AQ_D:\n  assumes \"v \\<in> lang n (Atom (AQ m a))\" \"m < n\" \"a \\<in> set \\<Sigma>\"\n  shows \"\\<exists>x. v = [x] \\<and> fst x = a \\<and> snd x ! m\"", "lemma Arbitrary_ExceptD:\n  assumes \"v \\<in> lang n (Atom (Arbitrary_Except r b))\" \"r < n\"\n  shows \"\\<exists>x. v = [x] \\<and> snd x ! r = b\"", "lemma Arbitrary_Except2D:\n  assumes \"v \\<in> lang n (Atom (Arbitrary_Except2 r s))\" \"r < n\" \"s < n\"\n  shows \"\\<exists>x. v = [x] \\<and> snd x ! r \\<and> snd x ! s\"", "lemma star_Arbitrary_ExceptD:\n  \"\\<lbrakk>v \\<in> star (lang n (Atom (Arbitrary_Except r b))); r < n; i < length v\\<rbrakk> \\<Longrightarrow>\n    snd (v ! i) ! r = b\""], "translations": [["", "lemma \\<pi>_\\<sigma>: \"\\<pi> ` (set o \\<sigma> \\<Sigma>) (n + 1) = (set o \\<sigma> \\<Sigma>) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> ` (set \\<circ> \\<sigma> \\<Sigma>) (n + 1) =\n    (set \\<circ> \\<sigma> \\<Sigma>) n", "unfolding \\<pi>_def \\<sigma>_def set_map[symmetric] o_apply map_concat"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (map (\\<lambda>(a, bs). (a, tl bs)))\n            (map (\\<lambda>bs. map (\\<lambda>a. (a, bs)) \\<Sigma>)\n              (List.n_lists (n + 1) [True, False])))) =\n    set (concat\n          (map (\\<lambda>bs. map (\\<lambda>a. (a, bs)) \\<Sigma>)\n            (List.n_lists n [True, False])))", "by auto"], ["", "locale formula = embed2 \"set o (\\<sigma> \\<Sigma>)\" \"wf_atom \\<Sigma>\" \\<pi> lookup \"\\<epsilon> \\<Sigma>\" \"case_prod Singleton\"\nfor \\<Sigma> :: \"'a :: linorder list\" +\nassumes nonempty: \"\\<Sigma> \\<noteq> []\"\nbegin"], ["", "abbreviation \"\\<Sigma>_product_lists n \\<equiv>\n   List.maps (\\<lambda>bools. map (\\<lambda>a. (a, bools)) \\<Sigma>) (bool_product_lists n)\""], ["", "(* Normal form: quantified variables are used in the body *)"], ["", "primrec pre_wf_formula :: \"nat \\<Rightarrow> 'a formula \\<Rightarrow> bool\" where\n  \"pre_wf_formula n (FQ a m) = (a \\<in> set \\<Sigma> \\<and> m < n)\"\n| \"pre_wf_formula n (FLess m1 m2) = (m1 < n \\<and> m2 < n)\"\n| \"pre_wf_formula n (FIn m M) = (m < n \\<and> M < n)\"\n| \"pre_wf_formula n (FNot \\<phi>) = pre_wf_formula n \\<phi>\"\n| \"pre_wf_formula n (FOr \\<phi>\\<^sub>1 \\<phi>\\<^sub>2) = (pre_wf_formula n \\<phi>\\<^sub>1 \\<and> pre_wf_formula n \\<phi>\\<^sub>2)\"\n| \"pre_wf_formula n (FAnd \\<phi>\\<^sub>1 \\<phi>\\<^sub>2) = (pre_wf_formula n \\<phi>\\<^sub>1 \\<and> pre_wf_formula n \\<phi>\\<^sub>2)\"\n| \"pre_wf_formula n (FExists \\<phi>) = (pre_wf_formula (n + 1) \\<phi> \\<and> 0 \\<in> FOV \\<phi> \\<and> 0 \\<notin> SOV \\<phi>)\"\n| \"pre_wf_formula n (FEXISTS \\<phi>) = (pre_wf_formula (n + 1) \\<phi> \\<and> 0 \\<notin> FOV \\<phi> \\<and> 0 \\<in> SOV \\<phi>)\""], ["", "abbreviation \"closed \\<equiv> pre_wf_formula 0\""], ["", "definition [simp]: \"wf_formula n \\<phi> \\<equiv> pre_wf_formula n \\<phi> \\<and> FOV \\<phi> \\<inter> SOV \\<phi> = {}\""], ["", "lemma max_idx_vars: \"pre_wf_formula n \\<phi> \\<Longrightarrow> \\<forall>p \\<in> FOV \\<phi> \\<union> SOV \\<phi>. p < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_wf_formula n \\<phi> \\<Longrightarrow>\n    \\<forall>p\\<in>FOV \\<phi> \\<union> SOV \\<phi>. p < n", "by (induct \\<phi> arbitrary: n)\n   (auto split: if_split_asm, (metis Un_iff diff_Suc_less less_SucE less_imp_diff_less)+)"], ["", "lemma finite_FOV: \"finite (FOV \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (FOV \\<phi>)", "by (induct \\<phi>) (auto split: if_split_asm)"], ["", "subsection \\<open>ENC\\<close>"], ["", "definition valid_ENC :: \"nat \\<Rightarrow> nat \\<Rightarrow> ('a atom) rexp\" where\n  \"valid_ENC n p = (if n = 0 then Full else\n    TIMES [\n      Star (Atom (Arbitrary_Except p False)),\n      Atom (Arbitrary_Except p True),\n      Star (Atom (Arbitrary_Except p False))])\""], ["", "lemma wf_rexp_valid_ENC: \"n = 0 \\<or> p < n \\<Longrightarrow> wf n (valid_ENC n p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<or> p < n \\<Longrightarrow> local.wf n (valid_ENC n p)", "unfolding valid_ENC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<or> p < n \\<Longrightarrow>\n    local.wf n\n     (if n = 0 then Full\n      else TIMES\n            [Star (Atom (Arbitrary_Except p False)),\n             Atom (Arbitrary_Except p True),\n             Star (Atom (Arbitrary_Except p False))])", "by auto"], ["", "definition ENC :: \"nat \\<Rightarrow> nat set \\<Rightarrow> ('a atom) rexp\" where\n  \"ENC n V = flatten INTERSECT (valid_ENC n ` V)\""], ["", "lemma wf_rexp_ENC: \"\\<lbrakk>finite V; n = 0 \\<or> (\\<forall>v \\<in> V. v < n)\\<rbrakk> \\<Longrightarrow> wf n (ENC n V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; n = 0 \\<or> (\\<forall>v\\<in>V. v < n)\\<rbrakk>\n    \\<Longrightarrow> local.wf n (ENC n V)", "unfolding ENC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; n = 0 \\<or> (\\<forall>v\\<in>V. v < n)\\<rbrakk>\n    \\<Longrightarrow> local.wf n\n                       (INTERSECT (sorted_list_of_set (valid_ENC n ` V)))", "by (intro iffD2[OF wf_flatten_INTERSECT]) (auto simp: wf_rexp_valid_ENC)"], ["", "lemma enc_atom_\\<sigma>_eq: \"i < length w \\<Longrightarrow>\n (length I = n \\<and> p \\<in> set \\<Sigma>) \\<longleftrightarrow> enc_atom I i p \\<in> set (\\<sigma> \\<Sigma> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length w \\<Longrightarrow>\n    (length I = n \\<and> p \\<in> set \\<Sigma>) =\n    (enc_atom I i p \\<in> set (\\<sigma> \\<Sigma> n))", "by (auto simp: \\<sigma>_def set_n_lists intro!: exI[of _ \"enc_atom_bool I i\"] imageI)"], ["", "lemmas enc_atom_\\<sigma> = iffD1[OF enc_atom_\\<sigma>_eq, OF _ conjI]"], ["", "lemma enc_atom_bool_take_drop_True:\n  \"\\<lbrakk>r < length I; case I ! r of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P\\<rbrakk> \\<Longrightarrow>\n    enc_atom_bool I p = take r (enc_atom_bool I p) @ True # drop (Suc r) (enc_atom_bool I p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I;\n     case I ! r of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P\\<rbrakk>\n    \\<Longrightarrow> enc_atom_bool I p =\n                      take r (enc_atom_bool I p) @\n                      True # drop (Suc r) (enc_atom_bool I p)", "by (auto intro: trans[OF id_take_nth_drop])"], ["", "lemma enc_atom_bool_take_drop_True2:\n  \"\\<lbrakk>r < length I; case I ! r of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P;\n    s < length I; case I ! s of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P; r < s\\<rbrakk> \\<Longrightarrow>\n    enc_atom_bool I p = take r (enc_atom_bool I p) @ True #\n      take (s - Suc r) (drop (Suc r) (enc_atom_bool I p)) @ True #\n      drop (Suc s) (enc_atom_bool I p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I;\n     case I ! r of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     s < length I;\n     case I ! s of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     r < s\\<rbrakk>\n    \\<Longrightarrow> enc_atom_bool I p =\n                      take r (enc_atom_bool I p) @\n                      True #\n                      take (s - Suc r) (drop (Suc r) (enc_atom_bool I p)) @\n                      True # drop (Suc s) (enc_atom_bool I p)", "using id_take_nth_drop[of r \"enc_atom_bool I p\"]\n      id_take_nth_drop[of \"s - r - 1\" \"drop (Suc r) (enc_atom_bool I p)\"]"], ["proof (prove)\nusing this:\n  r < length (enc_atom_bool I p) \\<Longrightarrow>\n  enc_atom_bool I p =\n  take r (enc_atom_bool I p) @\n  enc_atom_bool I p ! r # drop (Suc r) (enc_atom_bool I p)\n  s - r - 1 < length (drop (Suc r) (enc_atom_bool I p)) \\<Longrightarrow>\n  drop (Suc r) (enc_atom_bool I p) =\n  take (s - r - 1) (drop (Suc r) (enc_atom_bool I p)) @\n  drop (Suc r) (enc_atom_bool I p) ! (s - r - 1) #\n  drop (Suc (s - r - 1)) (drop (Suc r) (enc_atom_bool I p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I;\n     case I ! r of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     s < length I;\n     case I ! s of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     r < s\\<rbrakk>\n    \\<Longrightarrow> enc_atom_bool I p =\n                      take r (enc_atom_bool I p) @\n                      True #\n                      take (s - Suc r) (drop (Suc r) (enc_atom_bool I p)) @\n                      True # drop (Suc s) (enc_atom_bool I p)", "by auto"], ["", "lemma enc_atom_bool_take_drop_False:\n  \"\\<lbrakk>r < length I; case I ! r of Inl p' \\<Rightarrow> p \\<noteq> p' | Inr P \\<Rightarrow> p \\<notin> P\\<rbrakk> \\<Longrightarrow>\n    enc_atom_bool I p = take r (enc_atom_bool I p) @ False # drop (Suc r) (enc_atom_bool I p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I;\n     case I ! r of Inl p' \\<Rightarrow> p \\<noteq> p'\n     | Inr P \\<Rightarrow> p \\<notin> P\\<rbrakk>\n    \\<Longrightarrow> enc_atom_bool I p =\n                      take r (enc_atom_bool I p) @\n                      False # drop (Suc r) (enc_atom_bool I p)", "by (auto intro: trans[OF id_take_nth_drop] split: sum.splits)"], ["", "lemma enc_atom_lang_AQ: \"\\<lbrakk>r < length I;\n   case I ! r of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P; length I = n; a \\<in> set \\<Sigma>\\<rbrakk> \\<Longrightarrow>\n  [enc_atom I p a] \\<in> lang n (Atom (AQ r a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I;\n     case I ! r of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     length I = n; a \\<in> set \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> [enc_atom I p a] \\<in> lang n (Atom (AQ r a))", "unfolding lang.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I;\n     case I ! r of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     length I = n; a \\<in> set \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> [enc_atom I p a]\n                      \\<in> {[x] |x.\n                             lookup (AQ r a) x \\<and>\n                             x \\<in> (set \\<circ> \\<sigma> \\<Sigma>) n}", "by (force intro!: enc_atom_bool_take_drop_True\n    image_eqI[of _ _ \"(\\<lambda>J. take r J @ drop (r + 1) J) (enc_atom_bool I p)\"]\n    simp: \\<sigma>_def set_n_lists)"], ["", "lemma enc_atom_lang_Arbitrary_Except_True: \"\\<lbrakk>r < length I;\n   case I ! r of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P; length I = n; a \\<in> set \\<Sigma>\\<rbrakk> \\<Longrightarrow>\n  [enc_atom I p a] \\<in> lang n (Atom (Arbitrary_Except r True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I;\n     case I ! r of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     length I = n; a \\<in> set \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> [enc_atom I p a]\n                      \\<in> lang n (Atom (Arbitrary_Except r True))", "unfolding lang.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I;\n     case I ! r of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     length I = n; a \\<in> set \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> [enc_atom I p a]\n                      \\<in> {[x] |x.\n                             lookup (Arbitrary_Except r True) x \\<and>\n                             x \\<in> (set \\<circ> \\<sigma> \\<Sigma>) n}", "by (force intro!: enc_atom_bool_take_drop_True\n    image_eqI[of _ _ \"(\\<lambda>J. take r J @ drop (r + 1) J) (enc_atom_bool I p)\"]\n    simp: \\<sigma>_def set_n_lists)"], ["", "lemma enc_atom_lang_Arbitrary_Except2:\"\\<lbrakk>r < length I; s < length I; \n  case I ! r of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P;\n  case I ! s of Inl p' \\<Rightarrow> p = p' | Inr P \\<Rightarrow> p \\<in> P; length I = n; a \\<in> set \\<Sigma>\\<rbrakk> \\<Longrightarrow>\n  [enc_atom I p a] \\<in> lang n (Atom (Arbitrary_Except2 r s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I; s < length I;\n     case I ! r of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     case I ! s of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     length I = n; a \\<in> set \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> [enc_atom I p a]\n                      \\<in> lang n (Atom (Arbitrary_Except2 r s))", "unfolding lang.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I; s < length I;\n     case I ! r of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     case I ! s of Inl p' \\<Rightarrow> p = p'\n     | Inr P \\<Rightarrow> p \\<in> P;\n     length I = n; a \\<in> set \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> [enc_atom I p a]\n                      \\<in> {[x] |x.\n                             lookup (Arbitrary_Except2 r s) x \\<and>\n                             x \\<in> (set \\<circ> \\<sigma> \\<Sigma>) n}", "by (force intro!: enc_atom_bool_take_drop_True2\n    simp: set_n_lists \\<sigma>_def take_Cons' drop_Cons' numeral_eq_Suc)"], ["", "lemma enc_atom_lang_Arbitrary_Except_False: \"\\<lbrakk>r < length I;\n  case I ! r of Inl p' \\<Rightarrow> p \\<noteq> p' | Inr P \\<Rightarrow> p \\<notin> P; length I = n; a \\<in> set \\<Sigma>\\<rbrakk> \\<Longrightarrow>\n  [enc_atom I p a] \\<in> lang n (Atom (Arbitrary_Except r False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I;\n     case I ! r of Inl p' \\<Rightarrow> p \\<noteq> p'\n     | Inr P \\<Rightarrow> p \\<notin> P;\n     length I = n; a \\<in> set \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> [enc_atom I p a]\n                      \\<in> lang n (Atom (Arbitrary_Except r False))", "unfolding lang.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < length I;\n     case I ! r of Inl p' \\<Rightarrow> p \\<noteq> p'\n     | Inr P \\<Rightarrow> p \\<notin> P;\n     length I = n; a \\<in> set \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> [enc_atom I p a]\n                      \\<in> {[x] |x.\n                             lookup (Arbitrary_Except r False) x \\<and>\n                             x \\<in> (set \\<circ> \\<sigma> \\<Sigma>) n}", "by (force intro!: enc_atom_bool_take_drop_False\n    image_eqI[of _ _ \"(\\<lambda>J. take r J @ drop (r + 1) J) (enc_atom_bool I p)\"]\n    simp: set_n_lists \\<sigma>_def split: sum.splits)"], ["", "lemma AQ_D:\n  assumes \"v \\<in> lang n (Atom (AQ m a))\" \"m < n\" \"a \\<in> set \\<Sigma>\"\n  shows \"\\<exists>x. v = [x] \\<and> fst x = a \\<and> snd x ! m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. v = [x] \\<and> fst x = a \\<and> snd x ! m", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> lang n (Atom (AQ m a))\n  m < n\n  a \\<in> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>x. v = [x] \\<and> fst x = a \\<and> snd x ! m", "by auto"], ["", "lemma Arbitrary_ExceptD:\n  assumes \"v \\<in> lang n (Atom (Arbitrary_Except r b))\" \"r < n\"\n  shows \"\\<exists>x. v = [x] \\<and> snd x ! r = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. v = [x] \\<and> snd x ! r = b", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> lang n (Atom (Arbitrary_Except r b))\n  r < n\n\ngoal (1 subgoal):\n 1. \\<exists>x. v = [x] \\<and> snd x ! r = b", "by auto"], ["", "lemma Arbitrary_Except2D:\n  assumes \"v \\<in> lang n (Atom (Arbitrary_Except2 r s))\" \"r < n\" \"s < n\"\n  shows \"\\<exists>x. v = [x] \\<and> snd x ! r \\<and> snd x ! s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. v = [x] \\<and> snd x ! r \\<and> snd x ! s", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> lang n (Atom (Arbitrary_Except2 r s))\n  r < n\n  s < n\n\ngoal (1 subgoal):\n 1. \\<exists>x. v = [x] \\<and> snd x ! r \\<and> snd x ! s", "by auto"], ["", "lemma star_Arbitrary_ExceptD:\n  \"\\<lbrakk>v \\<in> star (lang n (Atom (Arbitrary_Except r b))); r < n; i < length v\\<rbrakk> \\<Longrightarrow>\n    snd (v ! i) ! r = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> star (lang n (Atom (Arbitrary_Except r b))); r < n;\n     i < length v\\<rbrakk>\n    \\<Longrightarrow> snd (v ! i) ! r = b", "proof (induct arbitrary: i rule: star_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>r < n; i < length []\\<rbrakk>\n       \\<Longrightarrow> snd ([] ! i) ! r = b\n 2. \\<And>u v i.\n       \\<lbrakk>u \\<in> lang n (Atom (Arbitrary_Except r b));\n        v \\<in> star (lang n (Atom (Arbitrary_Except r b)));\n        \\<And>i.\n           \\<lbrakk>r < n; i < length v\\<rbrakk>\n           \\<Longrightarrow> snd (v ! i) ! r = b;\n        r < n; i < length (u @ v)\\<rbrakk>\n       \\<Longrightarrow> snd ((u @ v) ! i) ! r = b", "case (append u v)"], ["proof (state)\nthis:\n  u \\<in> lang n (Atom (Arbitrary_Except r b))\n  v \\<in> star (lang n (Atom (Arbitrary_Except r b)))\n  \\<lbrakk>r < n; ?i < length v\\<rbrakk>\n  \\<Longrightarrow> snd (v ! ?i) ! r = b\n  r < n\n  i < length (u @ v)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>r < n; i < length []\\<rbrakk>\n       \\<Longrightarrow> snd ([] ! i) ! r = b\n 2. \\<And>u v i.\n       \\<lbrakk>u \\<in> lang n (Atom (Arbitrary_Except r b));\n        v \\<in> star (lang n (Atom (Arbitrary_Except r b)));\n        \\<And>i.\n           \\<lbrakk>r < n; i < length v\\<rbrakk>\n           \\<Longrightarrow> snd (v ! i) ! r = b;\n        r < n; i < length (u @ v)\\<rbrakk>\n       \\<Longrightarrow> snd ((u @ v) ! i) ! r = b", "thus ?case"], ["proof (prove)\nusing this:\n  u \\<in> lang n (Atom (Arbitrary_Except r b))\n  v \\<in> star (lang n (Atom (Arbitrary_Except r b)))\n  \\<lbrakk>r < n; ?i < length v\\<rbrakk>\n  \\<Longrightarrow> snd (v ! ?i) ! r = b\n  r < n\n  i < length (u @ v)\n\ngoal (1 subgoal):\n 1. snd ((u @ v) ! i) ! r = b", "by (cases i) (auto dest: Arbitrary_ExceptD)"], ["proof (state)\nthis:\n  snd ((u @ v) ! i) ! r = b\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>r < n; i < length []\\<rbrakk>\n       \\<Longrightarrow> snd ([] ! i) ! r = b", "qed simp"], ["", "end"], ["", "end"]]}