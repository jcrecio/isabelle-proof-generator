{"file_name": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence/Pi_Equivalence_Checking.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence", "problem_names": ["lemma image2p_in_rel: \"BNF_Greatest_Fixpoint.image2p f g (in_rel R) =  in_rel (map_prod f g ` R)\"", "lemma image2p_apply: \"BNF_Greatest_Fixpoint.image2p f g R x y = (\\<exists>x' y'. R x' y' \\<and> f x' = x \\<and> g y' = y)\"", "lemma rtrancl_fold_product:\nshows \"{((r, s), (f a r, f a s))| r s a. a \\<in> A}^* =\n       {((r, s), (fold f w r, fold f w s))| r s w. w \\<in> lists A}\" (is \"?L = ?R\")", "lemma in_fold_lQuot: \"v \\<in> fold lQuot w L \\<longleftrightarrow> w @ v \\<in> L\"", "lemma (in project) lang_eq_ext: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> (lang n r = lang n s) =\n  (\\<forall>w \\<in> lists(\\<Sigma> n). w \\<in> lang n r \\<longleftrightarrow> w \\<in> lang n s)\"", "lemma (in project) lang_eq_ext_Nil_fold_Deriv:\n  fixes r s n\n  assumes WF: \"wf n r\" \"wf n s\"\n  defines \"\\<BB> \\<equiv> {(fold lQuot w (lang n r), fold lQuot w (lang n s))| w. w\\<in>lists (\\<Sigma> n)}\"\n  shows \"lang n r = lang n s \\<longleftrightarrow> (\\<forall>(K, L) \\<in> \\<BB>. [] \\<in> K \\<longleftrightarrow> [] \\<in> L)\"", "lemma L_deltas[simp]: \"\\<lbrakk>wf_word n w; wf_state s\\<rbrakk> \\<Longrightarrow> L (fold delta w s) = fold lQuot w (L s)\"", "lemma SUPR_progression[intro!]: \"\\<forall>n. \\<exists>m. X n \\<rightarrow> Y m \\<Longrightarrow> (SUP n. X n) \\<rightarrow> (SUP n. Y n)\"", "lemmas bisim_def = bisimulation_def progression_def", "lemmas bisim_upto_def = bisimulation_upto_def progression_def", "lemmas compat_def = compatible_def progression_def", "lemma bisimulation_upto_bisimulation:\n  assumes \"compatible f\" \"bisimulation_upto R f\"\n  obtains S where \"bisimulation S\" \"R \\<le> S\"", "lemma bisimulation_eqL: \"bisimulation (\\<lambda>s1 s2. wf_state s1 \\<and> wf_state s2 \\<and> L s1 = L s2)\"", "lemma coinduction:\n  assumes bisim[unfolded bisim_def]: \"bisimulation R\" and\n    WF: \"wf_state s1\" \"wf_state s2\" and R: \"R s1 s2\"\n  shows \"L s1 = L s2\"", "lemma coinduction_upto:\n  assumes \"bisimulation_upto R f\" and WF: \"wf_state s1\" \"wf_state s2\" and \"R s1 s2\" \"compatible f\"\n  shows \"L s1 = L s2\"", "lemma invariant_start:\n  \"\\<lbrakk>wf_state r; wf_state s\\<rbrakk> \\<Longrightarrow> invariant r s ([([], r, s)], [], {(post r, post s)})\"", "lemma step_invariant_mono:\n  assumes \"step_invariant (ws, ps, N) = (ws', ps', N')\"\n  shows \"snd ` set ws \\<union> set ps \\<subseteq> snd ` set ws' \\<union> set ps'\"", "lemma step_invatiant_unfold: \"step_invariant (w # ws, ps, N) = (ws', ps', N') \\<Longrightarrow> (\\<exists>xs r s.\n  w = (xs, r, s) \\<and> ps' = (r, s) # ps \\<and>\n  ws' = ws @ remdups' (map_prod post post o snd) (filter (\\<lambda>(_, p). map_prod post post p \\<notin> N)\n   (map (\\<lambda>a. (a#xs, delta a r, delta a s)) (\\<sigma> n))) \\<and>\n  N' = set (map (\\<lambda>a. (post (delta a r), post (delta a s))) (\\<sigma> n)) \\<union> N)\"", "lemma invariant: \"invariant r s st \\<Longrightarrow> test_invariant st \\<Longrightarrow> invariant r s (step_invariant st)\"", "lemma step_commute: \"ws \\<noteq> [] \\<Longrightarrow>\n  (case step_invariant (ws, ps, N) of (ws', ps', N') \\<Rightarrow> (map snd ws', N')) = step (map snd ws, N)\"", "lemma closure_invariant_closure:\n  \"map_option (\\<lambda>(ws, ps, N). (map snd ws, N)) (closure_invariant (ws, ps, N)) = closure (map snd ws, N)\"", "lemma\n  assumes result: \"closure_invariant ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n    Some(ws, ps, N)\" (is \"closure_invariant ([([], ?r, ?s)], _) = _\")\n  and WF: \"wf n r\" \"wf n s\"\n  shows closure_invariant_sound: \"ws = [] \\<Longrightarrow> lang n r = lang n s\" and\n    counterexample: \"ws \\<noteq> [] \\<Longrightarrow> rev (fst (hd ws)) \\<in> lang n r \\<longleftrightarrow> rev (fst (hd ws)) \\<notin> lang n s\"", "lemma closure_sound:\n  assumes result: \"closure ([(init r, init s)], {(post (init r), post (init s))}) = Some ([], N)\"\n  and WF: \"wf n r\" \"wf n s\"\n  shows \"lang n r = lang n s\"", "lemma check_eqv_sound:\n  assumes \"check_eqv r s\" and WF: \"wf n r\" \"wf n s\"\n  shows \"lang n r = lang n s\"", "lemma counterexample_sound:\n  assumes result: \"counterexample r s = Some w\"  and WF: \"wf n r\" \"wf n s\"\n  shows \"w \\<in> lang n r \\<longleftrightarrow> w \\<notin> lang n s\"", "lemma match_correct: \"\\<lbrakk>wf_word n w; wf n s\\<rbrakk> \\<Longrightarrow> match s w \\<longleftrightarrow> w \\<in> lang n s\"", "lemma closure_invariant_termination:\n  assumes WF: \"wf n r\" \"wf n s\"\n  and result: \"closure_invariant ([([], init r, init s)], [], {(post (init r), post (init s))}) = None\"\n    (is \"closure_invariant ([([], ?r, ?s)], _) = None\" is \"?cl = None\")\n  shows \"False\"", "lemma closure_termination:\n  assumes WF: \"wf n r\" \"wf n s\"\n  and result: \"closure ([(init r, init s)], {(post (init r), post (init s))}) = None\"\n  shows \"False\"", "lemma closure_invariant_complete:\n  assumes eq: \"lang n r = lang n s\"\n  and WF:  \"wf n r\" \"wf n s\"\n  shows \"\\<exists>ps N. closure_invariant ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n    Some([], ps, N)\" (is \"\\<exists>_ _. closure_invariant ([([], ?r, ?s)], _) = _\" is \"\\<exists>_ _. ?cl = _\")", "lemma closure_complete:\n  assumes \"lang n r = lang n s\" \"wf n r\" \"wf n s\"\n  shows \"\\<exists>N. closure ([(init r, init s)], {(post (init r), post (init s))}) = Some ([], N)\"", "lemma check_eqv_complete:\n  assumes \"lang n r = lang n s\" \"wf n r\" \"wf n s\"\n  shows \"check_eqv r s\"", "lemma counterexample_complete:\n  assumes \"lang n r \\<noteq> lang n s\" and WF: \"wf n r\" \"wf n s\"\n  shows \"\\<exists>w. counterexample r s = Some w\"", "lemma step_efficient[code]: \"step (ws, N) =\n  (let\n    (r, s) = hd ws;\n    new = remdups (filter (\\<lambda>(r,s). (r,s) \\<notin> N) (map (\\<lambda>a. (delta a r, delta a s)) (\\<sigma> n)))\n  in (tl ws @ new, set new \\<union> N))\"", "lemma length_sim_delta[simp]: \"wf_state s \\<Longrightarrow> length (sim_delta s) = length (\\<sigma> n)\"", "lemma L_delta[simp]: \"\\<lbrakk>a \\<in> set (\\<sigma> n); wf_state s\\<rbrakk> \\<Longrightarrow> L (delta a s) = lQuot a (L s)\"", "lemma delta_wf_state[simp]: \"\\<lbrakk>a \\<in> set (\\<sigma> n); wf_state s\\<rbrakk> \\<Longrightarrow> wf_state (delta a s)\""], "translations": [["", "lemma image2p_in_rel: \"BNF_Greatest_Fixpoint.image2p f g (in_rel R) =  in_rel (map_prod f g ` R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BNF_Greatest_Fixpoint.image2p f g (in_rel R) = in_rel (map_prod f g ` R)", "unfolding image2p_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       (\\<exists>x' y'. in_rel R x' y' \\<and> f x' = x \\<and> g y' = xa) =\n       in_rel (map_prod f g ` R) x xa", "by auto"], ["", "lemma image2p_apply: \"BNF_Greatest_Fixpoint.image2p f g R x y = (\\<exists>x' y'. R x' y' \\<and> f x' = x \\<and> g y' = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BNF_Greatest_Fixpoint.image2p f g R x y =\n    (\\<exists>x' y'. R x' y' \\<and> f x' = x \\<and> g y' = y)", "unfolding image2p_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x' y'. R x' y' \\<and> f x' = x \\<and> g y' = y) =\n    (\\<exists>x' y'. R x' y' \\<and> f x' = x \\<and> g y' = y)", "by auto"], ["", "lemma rtrancl_fold_product:\nshows \"{((r, s), (f a r, f a s))| r s a. a \\<in> A}^* =\n       {((r, s), (fold f w r, fold f w s))| r s w. w \\<in> lists A}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "fix x :: \"('a \\<times> 'a) \\<times> 'a \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "obtain r s r' s' where x: \"x = ((r, s), (r', s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r s r' s'.\n        x = ((r, s), r', s') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x) auto"], ["proof (state)\nthis:\n  x = ((r, s), r', s')\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "have \"((r, s), (r', s')) \\<in> ?L \\<Longrightarrow> ((r, s), (r', s')) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r, s), r', s')\n    \\<in> {((r, s), f a r, f a s) |r s a.\n           a \\<in> A}\\<^sup>* \\<Longrightarrow>\n    ((r, s), r', s')\n    \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "proof(induction rule: converse_rtrancl_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((r', s'), r', s')\n    \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n               w \\<in> lists A}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n                                w \\<in> lists A}", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ((r', s'), r', s')\n    \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n               w \\<in> lists A}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n                                w \\<in> lists A}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r', s'), r', s')\n    \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "by(force intro!: fold_simps(1)[symmetric])"], ["proof (state)\nthis:\n  ((r', s'), r', s')\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n               w \\<in> lists A}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n                                w \\<in> lists A}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n               w \\<in> lists A}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n                                w \\<in> lists A}", "case step"], ["proof (state)\nthis:\n  ((a___, b___), a_, b_) \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\n  ((a_, b_), r', s')\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n  ((a_, b_), r', s')\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n               w \\<in> lists A}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n                                w \\<in> lists A}", "thus ?case"], ["proof (prove)\nusing this:\n  ((a___, b___), a_, b_) \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\n  ((a_, b_), r', s')\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n  ((a_, b_), r', s')\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. ((a___, b___), r', s')\n    \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "by(force intro!: fold_simps(2)[symmetric])"], ["proof (state)\nthis:\n  ((a___, b___), r', s')\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((r, s), r', s')\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ((r, s), r', s')\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "with x"], ["proof (chain)\npicking this:\n  x = ((r, s), r', s')\n  ((r, s), r', s')\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ((r, s), r', s')\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "have \"x \\<in> ?L \\<Longrightarrow> x \\<in> ?R\""], ["proof (prove)\nusing this:\n  x = ((r, s), r', s')\n  ((r, s), r', s')\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ((r, s), r', s')\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. x \\<in> {((r, s), f a r, f a s) |r s a.\n             a \\<in> A}\\<^sup>* \\<Longrightarrow>\n    x \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "by simp"], ["proof (state)\nthis:\n  x \\<in> {((r, s), f a r, f a s) |r s a.\n           a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  x \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "}"], ["proof (state)\nthis:\n  ?x2\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ?x2 \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "moreover"], ["proof (state)\nthis:\n  ?x2\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ?x2 \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "{"], ["proof (state)\nthis:\n  ?x2\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ?x2 \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "fix x :: \"('a \\<times> 'a) \\<times> 'a \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "obtain r s r' s' where x: \"x = ((r, s), (r', s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r s r' s'.\n        x = ((r, s), r', s') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x) auto"], ["proof (state)\nthis:\n  x = ((r, s), r', s')\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "{"], ["proof (state)\nthis:\n  x = ((r, s), r', s')\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "have \"\\<forall>x\\<in>set w. x \\<in> A \\<Longrightarrow> ((r, s), fold f w r, fold f w s) \\<in> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set w. x \\<in> A \\<Longrightarrow>\n    ((r, s), fold f w r, fold f w s)\n    \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*", "proof(induction w rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. x \\<in> A \\<Longrightarrow>\n    ((r, s), fold f [] r, fold f [] s)\n    \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n 2. \\<And>x xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x \\<in> A \\<Longrightarrow>\n                ((r, s), fold f xs r, fold f xs s)\n                \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*;\n        \\<forall>x\\<in>set (xs @ [x]). x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f (xs @ [x]) r, fold f (xs @ [x]) s)\n                         \\<in> {((r, s), f a r, f a s) |r s a.\n                                a \\<in> A}\\<^sup>*", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. x \\<in> A\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. x \\<in> A \\<Longrightarrow>\n    ((r, s), fold f [] r, fold f [] s)\n    \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n 2. \\<And>x xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x \\<in> A \\<Longrightarrow>\n                ((r, s), fold f xs r, fold f xs s)\n                \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*;\n        \\<forall>x\\<in>set (xs @ [x]). x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f (xs @ [x]) r, fold f (xs @ [x]) s)\n                         \\<in> {((r, s), f a r, f a s) |r s a.\n                                a \\<in> A}\\<^sup>*", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r, s), fold f [] r, fold f [] s)\n    \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  ((r, s), fold f [] r, fold f [] s)\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x \\<in> A \\<Longrightarrow>\n                ((r, s), fold f xs r, fold f xs s)\n                \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*;\n        \\<forall>x\\<in>set (xs @ [x]). x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f (xs @ [x]) r, fold f (xs @ [x]) s)\n                         \\<in> {((r, s), f a r, f a s) |r s a.\n                                a \\<in> A}\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x \\<in> A \\<Longrightarrow>\n                ((r, s), fold f xs r, fold f xs s)\n                \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*;\n        \\<forall>x\\<in>set (xs @ [x]). x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f (xs @ [x]) r, fold f (xs @ [x]) s)\n                         \\<in> {((r, s), f a r, f a s) |r s a.\n                                a \\<in> A}\\<^sup>*", "case snoc"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs_. x \\<in> A \\<Longrightarrow>\n  ((r, s), fold f xs_ r, fold f xs_ s)\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n  \\<forall>x\\<in>set (xs_ @ [x_]). x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x \\<in> A \\<Longrightarrow>\n                ((r, s), fold f xs r, fold f xs s)\n                \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*;\n        \\<forall>x\\<in>set (xs @ [x]). x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ((r, s), fold f (xs @ [x]) r, fold f (xs @ [x]) s)\n                         \\<in> {((r, s), f a r, f a s) |r s a.\n                                a \\<in> A}\\<^sup>*", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs_. x \\<in> A \\<Longrightarrow>\n  ((r, s), fold f xs_ r, fold f xs_ s)\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n  \\<forall>x\\<in>set (xs_ @ [x_]). x \\<in> A\n\ngoal (1 subgoal):\n 1. ((r, s), fold f (xs_ @ [x_]) r, fold f (xs_ @ [x_]) s)\n    \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*", "by (auto elim!: rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  ((r, s), fold f (xs_ @ [x_]) r, fold f (xs_ @ [x_]) s)\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set w. x \\<in> A \\<Longrightarrow>\n  ((r, s), fold f w r, fold f w s)\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "}"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ?w2. x \\<in> A \\<Longrightarrow>\n  ((r, s), fold f ?w2 r, fold f ?w2 s)\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "hence \"((r, s), (r', s')) \\<in> ?R \\<Longrightarrow> ((r, s), (r', s')) \\<in> ?L\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ?w2. x \\<in> A \\<Longrightarrow>\n  ((r, s), fold f ?w2 r, fold f ?w2 s)\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. ((r, s), r', s')\n    \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n           w \\<in> lists A} \\<Longrightarrow>\n    ((r, s), r', s')\n    \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  ((r, s), r', s')\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n         w \\<in> lists A} \\<Longrightarrow>\n  ((r, s), r', s') \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "with x"], ["proof (chain)\npicking this:\n  x = ((r, s), r', s')\n  ((r, s), r', s')\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n         w \\<in> lists A} \\<Longrightarrow>\n  ((r, s), r', s') \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*", "have \"x \\<in> ?R \\<Longrightarrow> x \\<in> ?L\""], ["proof (prove)\nusing this:\n  x = ((r, s), r', s')\n  ((r, s), r', s')\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n         w \\<in> lists A} \\<Longrightarrow>\n  ((r, s), r', s') \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n             w \\<in> lists A} \\<Longrightarrow>\n    x \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  x \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n           w \\<in> lists A} \\<Longrightarrow>\n  x \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "}"], ["proof (state)\nthis:\n  ?x2\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n         w \\<in> lists A} \\<Longrightarrow>\n  ?x2 \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "ultimately"], ["proof (chain)\npicking this:\n  ?x2\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ?x2 \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n  ?x2\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n         w \\<in> lists A} \\<Longrightarrow>\n  ?x2 \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x2\n  \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ?x2 \\<in> {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n  ?x2\n  \\<in> {((r, s), fold f w r, fold f w s) |r s w.\n         w \\<in> lists A} \\<Longrightarrow>\n  ?x2 \\<in> {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}", "by blast"], ["proof (state)\nthis:\n  {((r, s), f a r, f a s) |r s a. a \\<in> A}\\<^sup>* =\n  {((r, s), fold f w r, fold f w s) |r s w. w \\<in> lists A}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_fold_lQuot: \"v \\<in> fold lQuot w L \\<longleftrightarrow> w @ v \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> fold lQuot w L) = (w @ v \\<in> L)", "by (induct w arbitrary: L) (simp_all add: lQuot_def)"], ["", "lemma (in project) lang_eq_ext: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> (lang n r = lang n s) =\n  (\\<forall>w \\<in> lists(\\<Sigma> n). w \\<in> lang n r \\<longleftrightarrow> w \\<in> lang n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; local.wf n s\\<rbrakk>\n    \\<Longrightarrow> (lang n r = lang n s) =\n                      (\\<forall>w\\<in>lists (\\<Sigma> n).\n                          (w \\<in> lang n r) = (w \\<in> lang n s))", "by (auto dest!: lang_subset_lists)"], ["", "lemma (in project) lang_eq_ext_Nil_fold_Deriv:\n  fixes r s n\n  assumes WF: \"wf n r\" \"wf n s\"\n  defines \"\\<BB> \\<equiv> {(fold lQuot w (lang n r), fold lQuot w (lang n s))| w. w\\<in>lists (\\<Sigma> n)}\"\n  shows \"lang n r = lang n s \\<longleftrightarrow> (\\<forall>(K, L) \\<in> \\<BB>. [] \\<in> K \\<longleftrightarrow> [] \\<in> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lang n r = lang n s) =\n    (\\<forall>(K, L)\\<in>\\<BB>. ([] \\<in> K) = ([] \\<in> L))", "unfolding lang_eq_ext[OF WF] \\<BB>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>w\\<in>lists (\\<Sigma> n).\n        (w \\<in> lang n r) = (w \\<in> lang n s)) =\n    (\\<forall>(K, L)\n              \\<in>{(fold lQuot w (lang n r), fold lQuot w (lang n s)) |w.\n                    w \\<in> lists (\\<Sigma> n)}.\n        ([] \\<in> K) = ([] \\<in> L))", "by (subst (1 2) in_fold_lQuot[of \"[]\", simplified, symmetric]) auto"], ["", "locale rexp_DA = project \"set o \\<sigma>\" wf_atom project lookup\n  for \\<sigma> :: \"nat \\<Rightarrow> 'a list\"\n  and wf_atom :: \"nat \\<Rightarrow> 'b :: linorder \\<Rightarrow> bool\"\n  and project :: \"'a \\<Rightarrow> 'a\"\n  and lookup :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\" +\n  fixes init :: \"'b rexp \\<Rightarrow> 's\"\n  fixes delta :: \"'a \\<Rightarrow> 's \\<Rightarrow> 's\"\n  fixes final :: \"'s \\<Rightarrow> bool\"\n  fixes wf_state :: \"'s \\<Rightarrow> bool\"\n  fixes post :: \"'s \\<Rightarrow> 's\"\n  fixes L :: \"'s \\<Rightarrow> 'a lang\"\n  fixes n :: \"nat\"\n  assumes L_init[simp]: \"wf n r \\<Longrightarrow> L (init r) = lang n r\"\n  assumes L_delta[simp]: \"\\<lbrakk>a \\<in> set (\\<sigma> n); wf_state s\\<rbrakk> \\<Longrightarrow> L (delta a s) = lQuot a (L s)\"\n  assumes final_iff_Nil[simp]: \"final s \\<longleftrightarrow> [] \\<in> L s\"\n  assumes L_wf_state[dest]: \"wf_state s \\<Longrightarrow> L s \\<subseteq> lists (set (\\<sigma> n))\"\n  assumes init_wf_state[simp]: \"wf n r \\<Longrightarrow> wf_state (init r)\"\n  assumes delta_wf_state[simp]: \"\\<lbrakk>a \\<in> set (\\<sigma> n); wf_state s\\<rbrakk> \\<Longrightarrow> wf_state (delta a s)\"\n  assumes L_post[simp]: \"wf_state s \\<Longrightarrow> L (post s) = L s\"\n  assumes wf_state_post[simp]: \"wf_state s \\<Longrightarrow> wf_state (post s)\"\nbegin"], ["", "lemma L_deltas[simp]: \"\\<lbrakk>wf_word n w; wf_state s\\<rbrakk> \\<Longrightarrow> L (fold delta w s) = fold lQuot w (L s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_word n w; wf_state s\\<rbrakk>\n    \\<Longrightarrow> L (fold delta w s) = fold lQuot w (L s)", "by (induction w arbitrary: s) auto"], ["", "definition progression (infix \"\\<rightarrow>\" 60) where \n  \"R \\<rightarrow> S = (\\<forall>s1 s2. R s1 s2 \\<longrightarrow> wf_state s1 \\<and> wf_state s2 \\<and> final s1 = final s2 \\<and>\n     (\\<forall>x \\<in> set (\\<sigma> n). BNF_Greatest_Fixpoint.image2p post post S (post (delta x s1)) (post (delta x s2))))\""], ["", "lemma SUPR_progression[intro!]: \"\\<forall>n. \\<exists>m. X n \\<rightarrow> Y m \\<Longrightarrow> (SUP n. X n) \\<rightarrow> (SUP n. Y n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. \\<exists>m. X n \\<rightarrow> Y m \\<Longrightarrow>\n    Sup (range X) \\<rightarrow> Sup (range Y)", "unfolding progression_def image2p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>na.\n       \\<exists>m.\n          \\<forall>s1 s2.\n             X na s1 s2 \\<longrightarrow>\n             wf_state s1 \\<and>\n             wf_state s2 \\<and>\n             final s1 = final s2 \\<and>\n             (\\<forall>x\\<in>set (\\<sigma> n).\n                 \\<exists>x' y'.\n                    Y m x' y' \\<and>\n                    post x' = post (delta x s1) \\<and>\n                    post y' = post (delta x s2)) \\<Longrightarrow>\n    \\<forall>s1 s2.\n       Sup (range X) s1 s2 \\<longrightarrow>\n       wf_state s1 \\<and>\n       wf_state s2 \\<and>\n       final s1 = final s2 \\<and>\n       (\\<forall>x\\<in>set (\\<sigma> n).\n           \\<exists>x' y'.\n              Sup (range Y) x' y' \\<and>\n              post x' = post (delta x s1) \\<and>\n              post y' = post (delta x s2))", "by fastforce"], ["", "definition bisimulation where\n  \"bisimulation R = R \\<rightarrow> R\""], ["", "definition bisimulation_upto where\n  \"bisimulation_upto R f = R \\<rightarrow> f R\""], ["", "declare image2pI[intro!] image2pE[elim!]"], ["", "lemmas bisim_def = bisimulation_def progression_def"], ["", "lemmas bisim_upto_def = bisimulation_upto_def progression_def"], ["", "definition compatible where\n  \"compatible f = (mono f \\<and> (\\<forall>R S. R \\<rightarrow> S \\<longrightarrow> f R \\<rightarrow> f S))\""], ["", "lemmas compat_def = compatible_def progression_def"], ["", "lemma bisimulation_upto_bisimulation:\n  assumes \"compatible f\" \"bisimulation_upto R f\"\n  obtains S where \"bisimulation S\" \"R \\<le> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bisimulation ?S2\n 2. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    R \\<le> ?S2", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bisimulation ?S2\n 2. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    R \\<le> ?S2", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bisimulation ?S2\n 2. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    R \\<le> ?S2", "from assms"], ["proof (chain)\npicking this:\n  compatible f\n  bisimulation_upto R f", "have \"(f^^n) R \\<rightarrow> (f^^Suc n) R\""], ["proof (prove)\nusing this:\n  compatible f\n  bisimulation_upto R f\n\ngoal (1 subgoal):\n 1. (f ^^ n) R \\<rightarrow> (f ^^ Suc n) R", "by (induct n) (auto simp: bisimulation_upto_def compatible_def)"], ["proof (state)\nthis:\n  (f ^^ n) R \\<rightarrow> (f ^^ Suc n) R\n\ngoal (2 subgoals):\n 1. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bisimulation ?S2\n 2. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    R \\<le> ?S2", "}"], ["proof (state)\nthis:\n  (f ^^ ?na2) R \\<rightarrow> (f ^^ Suc ?na2) R\n\ngoal (2 subgoals):\n 1. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    bisimulation ?S2\n 2. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    R \\<le> ?S2", "then"], ["proof (chain)\npicking this:\n  (f ^^ ?na2) R \\<rightarrow> (f ^^ Suc ?na2) R", "show \"bisimulation (SUP n. (f^^n) R)\""], ["proof (prove)\nusing this:\n  (f ^^ ?na2) R \\<rightarrow> (f ^^ Suc ?na2) R\n\ngoal (1 subgoal):\n 1. bisimulation (SUP n. (f ^^ n) R)", "unfolding bisimulation_def"], ["proof (prove)\nusing this:\n  (f ^^ ?na2) R \\<rightarrow> (f ^^ Suc ?na2) R\n\ngoal (1 subgoal):\n 1. (SUP n. (f ^^ n) R) \\<rightarrow> (SUP n. (f ^^ n) R)", "by (auto simp del: funpow.simps)"], ["proof (state)\nthis:\n  bisimulation (SUP n. (f ^^ n) R)\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    R \\<le> (SUP n. (f ^^ n) R)", "show \"R \\<le> (SUP n. (f^^n) R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<le> (SUP n. (f ^^ n) R)", "by (auto intro!: exI[of _ 0])"], ["proof (state)\nthis:\n  R \\<le> (SUP n. (f ^^ n) R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimulation_eqL: \"bisimulation (\\<lambda>s1 s2. wf_state s1 \\<and> wf_state s2 \\<and> L s1 = L s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation\n     (\\<lambda>s1 s2. wf_state s1 \\<and> wf_state s2 \\<and> L s1 = L s2)", "unfolding bisim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s1 s2.\n       wf_state s1 \\<and> wf_state s2 \\<and> L s1 = L s2 \\<longrightarrow>\n       wf_state s1 \\<and>\n       wf_state s2 \\<and>\n       final s1 = final s2 \\<and>\n       (\\<forall>x\\<in>set (\\<sigma> n).\n           BNF_Greatest_Fixpoint.image2p post post\n            (\\<lambda>s1 s2.\n                wf_state s1 \\<and> wf_state s2 \\<and> L s1 = L s2)\n            (post (delta x s1)) (post (delta x s2)))", "by (auto simp: lQuot_def)"], ["", "lemma coinduction:\n  assumes bisim[unfolded bisim_def]: \"bisimulation R\" and\n    WF: \"wf_state s1\" \"wf_state s2\" and R: \"R s1 s2\"\n  shows \"L s1 = L s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L s1 = L s2", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> L s1) = (x \\<in> L s2)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> L s1) = (x \\<in> L s2)", "from R WF"], ["proof (chain)\npicking this:\n  R s1 s2\n  wf_state s1\n  wf_state s2", "show \"w \\<in> L s1 \\<longleftrightarrow> w \\<in> L s2\""], ["proof (prove)\nusing this:\n  R s1 s2\n  wf_state s1\n  wf_state s2\n\ngoal (1 subgoal):\n 1. (w \\<in> L s1) = (w \\<in> L s2)", "proof (induction w arbitrary: s1 s2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n       \\<Longrightarrow> ([] \\<in> L s1) = ([] \\<in> L s2)\n 2. \\<And>a w s1 s2.\n       \\<lbrakk>\\<And>s1 s2.\n                   \\<lbrakk>R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n                   \\<Longrightarrow> (w \\<in> L s1) = (w \\<in> L s2);\n        R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)", "case Nil"], ["proof (state)\nthis:\n  R s1 s2\n  wf_state s1\n  wf_state s2\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n       \\<Longrightarrow> ([] \\<in> L s1) = ([] \\<in> L s2)\n 2. \\<And>a w s1 s2.\n       \\<lbrakk>\\<And>s1 s2.\n                   \\<lbrakk>R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n                   \\<Longrightarrow> (w \\<in> L s1) = (w \\<in> L s2);\n        R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)", "then"], ["proof (chain)\npicking this:\n  R s1 s2\n  wf_state s1\n  wf_state s2", "show ?case"], ["proof (prove)\nusing this:\n  R s1 s2\n  wf_state s1\n  wf_state s2\n\ngoal (1 subgoal):\n 1. ([] \\<in> L s1) = ([] \\<in> L s2)", "using bisim"], ["proof (prove)\nusing this:\n  R s1 s2\n  wf_state s1\n  wf_state s2\n  \\<forall>s1 s2.\n     R s1 s2 \\<longrightarrow>\n     wf_state s1 \\<and>\n     wf_state s2 \\<and>\n     final s1 = final s2 \\<and>\n     (\\<forall>x\\<in>set (\\<sigma> n).\n         BNF_Greatest_Fixpoint.image2p post post R (post (delta x s1))\n          (post (delta x s2)))\n\ngoal (1 subgoal):\n 1. ([] \\<in> L s1) = ([] \\<in> L s2)", "by simp"], ["proof (state)\nthis:\n  ([] \\<in> L s1) = ([] \\<in> L s2)\n\ngoal (1 subgoal):\n 1. \\<And>a w s1 s2.\n       \\<lbrakk>\\<And>s1 s2.\n                   \\<lbrakk>R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n                   \\<Longrightarrow> (w \\<in> L s1) = (w \\<in> L s2);\n        R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w s1 s2.\n       \\<lbrakk>\\<And>s1 s2.\n                   \\<lbrakk>R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n                   \\<Longrightarrow> (w \\<in> L s1) = (w \\<in> L s2);\n        R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)", "case (Cons a w s1 s2)"], ["proof (state)\nthis:\n  \\<lbrakk>R ?s1.0 ?s2.0; wf_state ?s1.0; wf_state ?s2.0\\<rbrakk>\n  \\<Longrightarrow> (w \\<in> L ?s1.0) = (w \\<in> L ?s2.0)\n  R s1 s2\n  wf_state s1\n  wf_state s2\n\ngoal (1 subgoal):\n 1. \\<And>a w s1 s2.\n       \\<lbrakk>\\<And>s1 s2.\n                   \\<lbrakk>R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n                   \\<Longrightarrow> (w \\<in> L s1) = (w \\<in> L s2);\n        R s1 s2; wf_state s1; wf_state s2\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # w \\<in> L s1) = (a # w \\<in> L s2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)\n 2. \\<not> ?P \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)", "assume a: \"a \\<in> set (\\<sigma> n)\""], ["proof (state)\nthis:\n  a \\<in> set (\\<sigma> n)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)\n 2. \\<not> ?P \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)", "with \\<open>R s1 s2\\<close>"], ["proof (chain)\npicking this:\n  R s1 s2\n  a \\<in> set (\\<sigma> n)", "obtain s1' s2' where \"R s1' s2'\" \"wf_state s1'\" \"wf_state s2'\" and\n        *[symmetric]: \"post s1' = post (delta a s1)\"  \"post s2' = post (delta a s2)\""], ["proof (prove)\nusing this:\n  R s1 s2\n  a \\<in> set (\\<sigma> n)\n\ngoal (1 subgoal):\n 1. (\\<And>s1' s2'.\n        \\<lbrakk>R s1' s2'; wf_state s1'; wf_state s2';\n         post s1' = post (delta a s1); post s2' = post (delta a s2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using bisim"], ["proof (prove)\nusing this:\n  R s1 s2\n  a \\<in> set (\\<sigma> n)\n  \\<forall>s1 s2.\n     R s1 s2 \\<longrightarrow>\n     wf_state s1 \\<and>\n     wf_state s2 \\<and>\n     final s1 = final s2 \\<and>\n     (\\<forall>x\\<in>set (\\<sigma> n).\n         BNF_Greatest_Fixpoint.image2p post post R (post (delta x s1))\n          (post (delta x s2)))\n\ngoal (1 subgoal):\n 1. (\\<And>s1' s2'.\n        \\<lbrakk>R s1' s2'; wf_state s1'; wf_state s2';\n         post s1' = post (delta a s1); post s2' = post (delta a s2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding image2p_apply"], ["proof (prove)\nusing this:\n  R s1 s2\n  a \\<in> set (\\<sigma> n)\n  \\<forall>s1 s2.\n     R s1 s2 \\<longrightarrow>\n     wf_state s1 \\<and>\n     wf_state s2 \\<and>\n     final s1 = final s2 \\<and>\n     (\\<forall>x\\<in>set (\\<sigma> n).\n         \\<exists>x' y'.\n            R x' y' \\<and>\n            post x' = post (delta x s1) \\<and> post y' = post (delta x s2))\n\ngoal (1 subgoal):\n 1. (\\<And>s1' s2'.\n        \\<lbrakk>R s1' s2'; wf_state s1'; wf_state s2';\n         post s1' = post (delta a s1); post s2' = post (delta a s2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R s1' s2'\n  wf_state s1'\n  wf_state s2'\n  post (delta a s1) = post s1'\n  post (delta a s2) = post s2'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)\n 2. \\<not> ?P \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)", "then"], ["proof (chain)\npicking this:\n  R s1' s2'\n  wf_state s1'\n  wf_state s2'\n  post (delta a s1) = post s1'\n  post (delta a s2) = post s2'", "have \"w \\<in> L (post (delta a s1)) \\<longleftrightarrow> w \\<in> L (post (delta a s2))\""], ["proof (prove)\nusing this:\n  R s1' s2'\n  wf_state s1'\n  wf_state s2'\n  post (delta a s1) = post s1'\n  post (delta a s2) = post s2'\n\ngoal (1 subgoal):\n 1. (w \\<in> L (post (delta a s1))) = (w \\<in> L (post (delta a s2)))", "unfolding *"], ["proof (prove)\nusing this:\n  R s1' s2'\n  wf_state s1'\n  wf_state s2'\n  post s1' = post s1'\n  post s2' = post s2'\n\ngoal (1 subgoal):\n 1. (w \\<in> L (post s1')) = (w \\<in> L (post s2'))", "using Cons.IH[of s1' s2']"], ["proof (prove)\nusing this:\n  R s1' s2'\n  wf_state s1'\n  wf_state s2'\n  post s1' = post s1'\n  post s2' = post s2'\n  \\<lbrakk>R s1' s2'; wf_state s1'; wf_state s2'\\<rbrakk>\n  \\<Longrightarrow> (w \\<in> L s1') = (w \\<in> L s2')\n\ngoal (1 subgoal):\n 1. (w \\<in> L (post s1')) = (w \\<in> L (post s2'))", "by simp"], ["proof (state)\nthis:\n  (w \\<in> L (post (delta a s1))) = (w \\<in> L (post (delta a s2)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)\n 2. \\<not> ?P \\<Longrightarrow> (a # w \\<in> L s1) = (a # w \\<in> L s2)", "with a Cons.prems(2,3)"], ["proof (chain)\npicking this:\n  a \\<in> set (\\<sigma> n)\n  wf_state s1\n  wf_state s2\n  (w \\<in> L (post (delta a s1))) = (w \\<in> L (post (delta a s2)))", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> set (\\<sigma> n)\n  wf_state s1\n  wf_state s2\n  (w \\<in> L (post (delta a s1))) = (w \\<in> L (post (delta a s2)))\n\ngoal (1 subgoal):\n 1. (a # w \\<in> L s1) = (a # w \\<in> L s2)", "by (simp add: lQuot_def)"], ["proof (state)\nthis:\n  (a # w \\<in> L s1) = (a # w \\<in> L s2)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (\\<sigma> n) \\<Longrightarrow>\n    (a # w \\<in> L s1) = (a # w \\<in> L s2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> set (\\<sigma> n) \\<Longrightarrow>\n    (a # w \\<in> L s1) = (a # w \\<in> L s2)", "assume \"a \\<notin> set (\\<sigma> n)\""], ["proof (state)\nthis:\n  a \\<notin> set (\\<sigma> n)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (\\<sigma> n) \\<Longrightarrow>\n    (a # w \\<in> L s1) = (a # w \\<in> L s2)", "thus ?case"], ["proof (prove)\nusing this:\n  a \\<notin> set (\\<sigma> n)\n\ngoal (1 subgoal):\n 1. (a # w \\<in> L s1) = (a # w \\<in> L s2)", "using Cons.prems bisim"], ["proof (prove)\nusing this:\n  a \\<notin> set (\\<sigma> n)\n  R s1 s2\n  wf_state s1\n  wf_state s2\n  \\<forall>s1 s2.\n     R s1 s2 \\<longrightarrow>\n     wf_state s1 \\<and>\n     wf_state s2 \\<and>\n     final s1 = final s2 \\<and>\n     (\\<forall>x\\<in>set (\\<sigma> n).\n         BNF_Greatest_Fixpoint.image2p post post R (post (delta x s1))\n          (post (delta x s2)))\n\ngoal (1 subgoal):\n 1. (a # w \\<in> L s1) = (a # w \\<in> L s2)", "by force"], ["proof (state)\nthis:\n  (a # w \\<in> L s1) = (a # w \\<in> L s2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a # w \\<in> L s1) = (a # w \\<in> L s2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (w \\<in> L s1) = (w \\<in> L s2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coinduction_upto:\n  assumes \"bisimulation_upto R f\" and WF: \"wf_state s1\" \"wf_state s2\" and \"R s1 s2\" \"compatible f\"\n  shows \"L s1 = L s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L s1 = L s2", "proof (rule bisimulation_upto_bisimulation[OF assms(5,1)])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n       \\<Longrightarrow> L s1 = L s2", "fix S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n       \\<Longrightarrow> L s1 = L s2", "assume \"R \\<le> S\""], ["proof (state)\nthis:\n  R \\<le> S\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n       \\<Longrightarrow> L s1 = L s2", "assume \"bisimulation S\""], ["proof (state)\nthis:\n  bisimulation S\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>bisimulation S; R \\<le> S\\<rbrakk>\n       \\<Longrightarrow> L s1 = L s2", "then"], ["proof (chain)\npicking this:\n  bisimulation S", "show \"L s1 = L s2\""], ["proof (prove)\nusing this:\n  bisimulation S\n\ngoal (1 subgoal):\n 1. L s1 = L s2", "proof (rule coinduction[OF _ WF])"], ["proof (state)\ngoal (1 subgoal):\n 1. S s1 s2", "from \\<open>R \\<le> S\\<close> \\<open>R s1 s2\\<close>"], ["proof (chain)\npicking this:\n  R \\<le> S\n  R s1 s2", "show \"S s1 s2\""], ["proof (prove)\nusing this:\n  R \\<le> S\n  R s1 s2\n\ngoal (1 subgoal):\n 1. S s1 s2", "by blast"], ["proof (state)\nthis:\n  S s1 s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  L s1 = L s2\n\ngoal:\nNo subgoals!", "qed"], ["", "fun test_invariant where\n  \"test_invariant (ws, _ :: ('s \\<times> 's) list , _ :: 's rel) = (case ws of [] \\<Rightarrow>  False | (w::'a list,p,q)#_ \\<Rightarrow> final p = final q)\""], ["", "fun test where \"test (ws, _ :: 's rel) = (case ws of [] \\<Rightarrow>  False | (p,q)#_ \\<Rightarrow> final p = final q)\""], ["", "fun step_invariant where \"step_invariant (ws, ps, N) =\n    (let\n      (w, r, s) = hd ws;\n      ps' = (r, s) # ps;\n      succs = map (\\<lambda>a.\n        let r' = delta a r; s' = delta a s\n        in ((a # w, r', s'), (post r', post s'))) (\\<sigma> n);\n      new = remdups' snd (filter (\\<lambda>(_, rs). rs \\<notin> N) succs);\n      ws' = tl ws @ map fst new;\n      N' = set (map snd new) \\<union> N\n    in (ws', ps', N'))\""], ["", "fun step where \"step (ws, N) =\n    (let\n      (r, s) = hd ws;\n      succs = map (\\<lambda>a.\n        let r' = delta a r; s' = delta a s\n        in ((r', s'), (post r', post s'))) (\\<sigma> n);\n      new = remdups' snd (filter (\\<lambda>(_, rs). rs \\<notin> N) succs)\n    in (tl ws @ map fst new, set (map snd new) \\<union> N))\""], ["", "definition closure_invariant where \"closure_invariant = while_option test_invariant step_invariant\""], ["", "definition closure where \"closure = while_option test step\""], ["", "definition invariant where\n  \"invariant r s = (\\<lambda>(ws, ps, N).\n     (r, s) \\<in> snd ` set ws \\<union> set ps \\<and>\n     distinct (map snd ws @ ps) \\<and>\n     bij_betw (map_prod post post) (set (map snd ws @ ps)) N \\<and>\n     (\\<forall>(w, r', s') \\<in> set ws. fold delta (rev w) r = r' \\<and> fold delta (rev w) s = s' \\<and>\n        wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s') \\<and>\n     (\\<forall>(r', s') \\<in> set ps. (\\<exists>w. fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n       wf_state r' \\<and> wf_state s' \\<and> (final r' \\<longleftrightarrow> final s') \\<and>\n       (\\<forall>a\\<in>set (\\<sigma> n). (post (delta a r'), post (delta a s')) \\<in> N)))\""], ["", "lemma invariant_start:\n  \"\\<lbrakk>wf_state r; wf_state s\\<rbrakk> \\<Longrightarrow> invariant r s ([([], r, s)], [], {(post r, post s)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_state r; wf_state s\\<rbrakk>\n    \\<Longrightarrow> invariant r s ([([], r, s)], [], {(post r, post s)})", "by (auto simp add: invariant_def bij_betw_def)"], ["", "lemma step_invariant_mono:\n  assumes \"step_invariant (ws, ps, N) = (ws', ps', N')\"\n  shows \"snd ` set ws \\<union> set ps \\<subseteq> snd ` set ws' \\<union> set ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set ws \\<union> set ps \\<subseteq> snd ` set ws' \\<union> set ps'", "using assms"], ["proof (prove)\nusing this:\n  step_invariant (ws, ps, N) = (ws', ps', N')\n\ngoal (1 subgoal):\n 1. snd ` set ws \\<union> set ps \\<subseteq> snd ` set ws' \\<union> set ps'", "proof (intro subsetI, elim UnE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n        step_invariant (ws, ps, N) = (ws', ps', N');\n        x \\<in> snd ` set ws\\<rbrakk>\n       \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'\n 2. \\<And>x.\n       \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n        step_invariant (ws, ps, N) = (ws', ps', N'); x \\<in> set ps\\<rbrakk>\n       \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n        step_invariant (ws, ps, N) = (ws', ps', N');\n        x \\<in> snd ` set ws\\<rbrakk>\n       \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'\n 2. \\<And>x.\n       \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n        step_invariant (ws, ps, N) = (ws', ps', N'); x \\<in> set ps\\<rbrakk>\n       \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'", "assume \"x \\<in> snd `set ws\""], ["proof (state)\nthis:\n  x \\<in> snd ` set ws\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n        step_invariant (ws, ps, N) = (ws', ps', N');\n        x \\<in> snd ` set ws\\<rbrakk>\n       \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'\n 2. \\<And>x.\n       \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n        step_invariant (ws, ps, N) = (ws', ps', N'); x \\<in> set ps\\<rbrakk>\n       \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'", "with assms"], ["proof (chain)\npicking this:\n  step_invariant (ws, ps, N) = (ws', ps', N')\n  x \\<in> snd ` set ws", "show \"x \\<in> snd ` set ws' \\<union> set ps'\""], ["proof (prove)\nusing this:\n  step_invariant (ws, ps, N) = (ws', ps', N')\n  x \\<in> snd ` set ws\n\ngoal (1 subgoal):\n 1. x \\<in> snd ` set ws' \\<union> set ps'", "proof (cases \"x = snd (hd ws)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n     x \\<in> snd ` set ws; x = snd (hd ws)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'\n 2. \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n     x \\<in> snd ` set ws; x \\<noteq> snd (hd ws)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'", "case False"], ["proof (state)\nthis:\n  x \\<noteq> snd (hd ws)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n     x \\<in> snd ` set ws; x = snd (hd ws)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'\n 2. \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n     x \\<in> snd ` set ws; x \\<noteq> snd (hd ws)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'", "with \\<open>x \\<in> image snd (set ws)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> snd ` set ws\n  x \\<noteq> snd (hd ws)", "have \"x \\<in> snd ` set (tl ws)\""], ["proof (prove)\nusing this:\n  x \\<in> snd ` set ws\n  x \\<noteq> snd (hd ws)\n\ngoal (1 subgoal):\n 1. x \\<in> snd ` set (tl ws)", "by (cases ws) auto"], ["proof (state)\nthis:\n  x \\<in> snd ` set (tl ws)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n     x \\<in> snd ` set ws; x = snd (hd ws)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'\n 2. \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n     x \\<in> snd ` set ws; x \\<noteq> snd (hd ws)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'", "with assms"], ["proof (chain)\npicking this:\n  step_invariant (ws, ps, N) = (ws', ps', N')\n  x \\<in> snd ` set (tl ws)", "show ?thesis"], ["proof (prove)\nusing this:\n  step_invariant (ws, ps, N) = (ws', ps', N')\n  x \\<in> snd ` set (tl ws)\n\ngoal (1 subgoal):\n 1. x \\<in> snd ` set ws' \\<union> set ps'", "by (auto split: prod.splits simp: Let_def)"], ["proof (state)\nthis:\n  x \\<in> snd ` set ws' \\<union> set ps'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n     x \\<in> snd ` set ws; x = snd (hd ws)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'", "qed (auto split: prod.splits simp: Let_def)"], ["proof (state)\nthis:\n  x \\<in> snd ` set ws' \\<union> set ps'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>step_invariant (ws, ps, N) = (ws', ps', N');\n        step_invariant (ws, ps, N) = (ws', ps', N'); x \\<in> set ps\\<rbrakk>\n       \\<Longrightarrow> x \\<in> snd ` set ws' \\<union> set ps'", "qed (auto split: prod.splits simp: Let_def)"], ["", "lemma step_invatiant_unfold: \"step_invariant (w # ws, ps, N) = (ws', ps', N') \\<Longrightarrow> (\\<exists>xs r s.\n  w = (xs, r, s) \\<and> ps' = (r, s) # ps \\<and>\n  ws' = ws @ remdups' (map_prod post post o snd) (filter (\\<lambda>(_, p). map_prod post post p \\<notin> N)\n   (map (\\<lambda>a. (a#xs, delta a r, delta a s)) (\\<sigma> n))) \\<and>\n  N' = set (map (\\<lambda>a. (post (delta a r), post (delta a s))) (\\<sigma> n)) \\<union> N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step_invariant (w # ws, ps, N) = (ws', ps', N') \\<Longrightarrow>\n    \\<exists>xs r s.\n       w = (xs, r, s) \\<and>\n       ps' = (r, s) # ps \\<and>\n       ws' =\n       ws @\n       remdups' (map_prod post post \\<circ> snd)\n        (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n          (map (\\<lambda>a. (a # xs, delta a r, delta a s))\n            (\\<sigma> n))) \\<and>\n       N' =\n       set (map (\\<lambda>a. (post (delta a r), post (delta a s)))\n             (\\<sigma> n)) \\<union>\n       N", "by (auto split: prod.splits dest!: mp_remdups'\n  simp: Let_def filter_map set_n_lists image_Collect image_image comp_def)"], ["", "lemma invariant: \"invariant r s st \\<Longrightarrow> test_invariant st \\<Longrightarrow> invariant r s (step_invariant st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant r s st; test_invariant st\\<rbrakk>\n    \\<Longrightarrow> invariant r s (step_invariant st)", "proof (unfold invariant_def, (split prod.splits)+, elim case_prodE conjE, clarify, intro allI impI conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> (r, s) \\<in> snd ` set x1b \\<union> set x1c\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd x1b @ x1c)\n 3. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> bij_betw (map_prod post post)\n                          (set (map snd x1b @ x1c)) x2\n 4. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 5. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "fix ws ps N ws' ps' N'"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> (r, s) \\<in> snd ` set x1b \\<union> set x1c\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd x1b @ x1c)\n 3. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> bij_betw (map_prod post post)\n                          (set (map snd x1b @ x1c)) x2\n 4. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 5. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "assume test_invariant: \"test_invariant (ws, ps, N)\"\n  and step_invariant: \"step_invariant (ws, ps, N) = (ws', ps', N')\"\n  and rs: \"(r, s) \\<in> snd ` set ws \\<union> set ps\"\n  and distinct: \"distinct (map snd ws @ ps)\"\n  and bij: \"bij_betw (map_prod post post) (set (map snd ws @ ps)) N\"\n  and ws: \"\\<forall>(w, r', s') \\<in> set ws. fold delta (rev w) r = r' \\<and> fold delta (rev w) s = s' \\<and>\n    wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\"\n      (is \"\\<forall>(w, r', s') \\<in> set ws. ?ws w r' s'\")\n  and ps: \"\\<forall>(r', s') \\<in> set ps. (\\<exists>w. fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n    wf_state r' \\<and> wf_state s' \\<and> (final r' \\<longleftrightarrow> final s') \\<and>\n    (\\<forall>a\\<in>set (\\<sigma> n). (post (delta a r'), post (delta a s')) \\<in> N)\"\n      (is \"\\<forall>(r, s) \\<in> set ps. ?ps r s N\")"], ["proof (state)\nthis:\n  test_invariant (ws, ps, N)\n  step_invariant (ws, ps, N) = (ws', ps', N')\n  (r, s) \\<in> snd ` set ws \\<union> set ps\n  distinct (map snd ws @ ps)\n  bij_betw (map_prod post post) (set (map snd ws @ ps)) N\n  \\<forall>(w, r', s')\\<in>set ws.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  \\<forall>(r', s')\\<in>set ps.\n     (\\<exists>w. fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n     wf_state r' \\<and>\n     wf_state s' \\<and>\n     final r' = final s' \\<and>\n     (\\<forall>a\\<in>set (\\<sigma> n).\n         (post (delta a r'), post (delta a s')) \\<in> N)\n\ngoal (5 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> (r, s) \\<in> snd ` set x1b \\<union> set x1c\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd x1b @ x1c)\n 3. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> bij_betw (map_prod post post)\n                          (set (map snd x1b @ x1c)) x2\n 4. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 5. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "from test_invariant"], ["proof (chain)\npicking this:\n  test_invariant (ws, ps, N)", "obtain x xs where ws_Cons: \"ws = x # xs\""], ["proof (prove)\nusing this:\n  test_invariant (ws, ps, N)\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. ws = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ws) auto"], ["proof (state)\nthis:\n  ws = x # xs\n\ngoal (5 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> (r, s) \\<in> snd ` set x1b \\<union> set x1c\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd x1b @ x1c)\n 3. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> bij_betw (map_prod post post)\n                          (set (map snd x1b @ x1c)) x2\n 4. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 5. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "obtain w r' s' where x: \"x = (w, r', s')\" and ps': \"ps' = (r', s') # ps\"\n    and ws': \"ws' = xs @ remdups' (map_prod post post o snd)\n      (filter (\\<lambda>(_, p). map_prod post post p \\<notin> N)\n        (map (\\<lambda>a. (a # w, delta a r',  delta a s')) (\\<sigma> n)))\"\n    and N': \"N' = (set (map (\\<lambda>a. (post (delta a r'), post (delta a s'))) (\\<sigma> n)) - N) \\<union> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w r' s'.\n        \\<lbrakk>x = (w, r', s'); ps' = (r', s') # ps;\n         ws' =\n         xs @\n         remdups' (map_prod post post \\<circ> snd)\n          (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n            (map (\\<lambda>a. (a # w, delta a r', delta a s'))\n              (\\<sigma> n)));\n         N' =\n         set (map (\\<lambda>a. (post (delta a r'), post (delta a s')))\n               (\\<sigma> n)) -\n         N \\<union>\n         N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step_invatiant_unfold[OF step_invariant[unfolded ws_Cons]]"], ["proof (prove)\nusing this:\n  \\<exists>xsa r s.\n     x = (xsa, r, s) \\<and>\n     ps' = (r, s) # ps \\<and>\n     ws' =\n     xs @\n     remdups' (map_prod post post \\<circ> snd)\n      (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n        (map (\\<lambda>a. (a # xsa, delta a r, delta a s))\n          (\\<sigma> n))) \\<and>\n     N' =\n     set (map (\\<lambda>a. (post (delta a r), post (delta a s)))\n           (\\<sigma> n)) \\<union>\n     N\n\ngoal (1 subgoal):\n 1. (\\<And>w r' s'.\n        \\<lbrakk>x = (w, r', s'); ps' = (r', s') # ps;\n         ws' =\n         xs @\n         remdups' (map_prod post post \\<circ> snd)\n          (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n            (map (\\<lambda>a. (a # w, delta a r', delta a s'))\n              (\\<sigma> n)));\n         N' =\n         set (map (\\<lambda>a. (post (delta a r'), post (delta a s')))\n               (\\<sigma> n)) -\n         N \\<union>\n         N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (w, r', s')\n  ps' = (r', s') # ps\n  ws' =\n  xs @\n  remdups' (map_prod post post \\<circ> snd)\n   (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n     (map (\\<lambda>a. (a # w, delta a r', delta a s')) (\\<sigma> n)))\n  N' =\n  set (map (\\<lambda>a. (post (delta a r'), post (delta a s')))\n        (\\<sigma> n)) -\n  N \\<union>\n  N\n\ngoal (5 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> (r, s) \\<in> snd ` set x1b \\<union> set x1c\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd x1b @ x1c)\n 3. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> bij_betw (map_prod post post)\n                          (set (map snd x1b @ x1c)) x2\n 4. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 5. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "hence ws'ps': \"set (map snd ws' @ ps') =\n     set (remdups' (map_prod post post) (filter (\\<lambda>p. map_prod post post p \\<notin> N)\n    (map (\\<lambda>a. (delta a r',  delta a s')) (\\<sigma> n)))) \\<union> (set (map snd ws @ ps))\""], ["proof (prove)\nusing this:\n  x = (w, r', s')\n  ps' = (r', s') # ps\n  ws' =\n  xs @\n  remdups' (map_prod post post \\<circ> snd)\n   (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n     (map (\\<lambda>a. (a # w, delta a r', delta a s')) (\\<sigma> n)))\n  N' =\n  set (map (\\<lambda>a. (post (delta a r'), post (delta a s')))\n        (\\<sigma> n)) -\n  N \\<union>\n  N\n\ngoal (1 subgoal):\n 1. set (map snd ws' @ ps') =\n    set (remdups' (map_prod post post)\n          (filter (\\<lambda>p. map_prod post post p \\<notin> N)\n            (map (\\<lambda>a. (delta a r', delta a s'))\n              (\\<sigma> n)))) \\<union>\n    set (map snd ws @ ps)", "unfolding ws' ps' ws_Cons x"], ["proof (prove)\nusing this:\n  (w, r', s') = (w, r', s')\n  (r', s') # ps = (r', s') # ps\n  xs @\n  remdups' (map_prod post post \\<circ> snd)\n   (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n     (map (\\<lambda>a. (a # w, delta a r', delta a s')) (\\<sigma> n))) =\n  xs @\n  remdups' (map_prod post post \\<circ> snd)\n   (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n     (map (\\<lambda>a. (a # w, delta a r', delta a s')) (\\<sigma> n)))\n  N' =\n  set (map (\\<lambda>a. (post (delta a r'), post (delta a s')))\n        (\\<sigma> n)) -\n  N \\<union>\n  N\n\ngoal (1 subgoal):\n 1. set (map snd\n          (xs @\n           remdups' (map_prod post post \\<circ> snd)\n            (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n              (map (\\<lambda>a. (a # w, delta a r', delta a s'))\n                (\\<sigma> n)))) @\n         (r', s') # ps) =\n    set (remdups' (map_prod post post)\n          (filter (\\<lambda>p. map_prod post post p \\<notin> N)\n            (map (\\<lambda>a. (delta a r', delta a s'))\n              (\\<sigma> n)))) \\<union>\n    set (map snd ((w, r', s') # xs) @ ps)", "by (auto dest!: mp_remdups' simp: filter_map image_image image_Un o_def)"], ["proof (state)\nthis:\n  set (map snd ws' @ ps') =\n  set (remdups' (map_prod post post)\n        (filter (\\<lambda>p. map_prod post post p \\<notin> N)\n          (map (\\<lambda>a. (delta a r', delta a s'))\n            (\\<sigma> n)))) \\<union>\n  set (map snd ws @ ps)\n\ngoal (5 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> (r, s) \\<in> snd ` set x1b \\<union> set x1c\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd x1b @ x1c)\n 3. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> bij_betw (map_prod post post)\n                          (set (map snd x1b @ x1c)) x2\n 4. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 5. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "from rs step_invariant"], ["proof (chain)\npicking this:\n  (r, s) \\<in> snd ` set ws \\<union> set ps\n  step_invariant (ws, ps, N) = (ws', ps', N')", "show \"(r, s) \\<in> snd ` set ws' \\<union> set ps'\""], ["proof (prove)\nusing this:\n  (r, s) \\<in> snd ` set ws \\<union> set ps\n  step_invariant (ws, ps, N) = (ws', ps', N')\n\ngoal (1 subgoal):\n 1. (r, s) \\<in> snd ` set ws' \\<union> set ps'", "by (blast dest: step_invariant_mono)"], ["proof (state)\nthis:\n  (r, s) \\<in> snd ` set ws' \\<union> set ps'\n\ngoal (4 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd x1b @ x1c)\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> bij_betw (map_prod post post)\n                          (set (map snd x1b @ x1c)) x2\n 3. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 4. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "(*next*)"], ["proof (state)\nthis:\n  (r, s) \\<in> snd ` set ws' \\<union> set ps'\n\ngoal (4 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct (map snd x1b @ x1c)\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> bij_betw (map_prod post post)\n                          (set (map snd x1b @ x1c)) x2\n 3. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 4. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "from distinct ps' ws' ws_Cons x bij"], ["proof (chain)\npicking this:\n  distinct (map snd ws @ ps)\n  ps' = (r', s') # ps\n  ws' =\n  xs @\n  remdups' (map_prod post post \\<circ> snd)\n   (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n     (map (\\<lambda>a. (a # w, delta a r', delta a s')) (\\<sigma> n)))\n  ws = x # xs\n  x = (w, r', s')\n  bij_betw (map_prod post post) (set (map snd ws @ ps)) N", "show \"distinct (map snd ws' @ ps')\""], ["proof (prove)\nusing this:\n  distinct (map snd ws @ ps)\n  ps' = (r', s') # ps\n  ws' =\n  xs @\n  remdups' (map_prod post post \\<circ> snd)\n   (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n     (map (\\<lambda>a. (a # w, delta a r', delta a s')) (\\<sigma> n)))\n  ws = x # xs\n  x = (w, r', s')\n  bij_betw (map_prod post post) (set (map snd ws @ ps)) N\n\ngoal (1 subgoal):\n 1. distinct (map snd ws' @ ps')", "by (auto simp: bij_betw_def\n      intro!: imageI[of _ _ \"map_prod post post\"] distinct_remdups'_strong\n        map_prod_imageI[of _ _ _ post post]\n      dest!: mp_remdups'\n      elim: image_eqI[of _ snd, OF sym[OF snd_conv]])"], ["proof (state)\nthis:\n  distinct (map snd ws' @ ps')\n\ngoal (3 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> bij_betw (map_prod post post)\n                          (set (map snd x1b @ x1c)) x2\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 3. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "(*next*)"], ["proof (state)\nthis:\n  distinct (map snd ws' @ ps')\n\ngoal (3 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> bij_betw (map_prod post post)\n                          (set (map snd x1b @ x1c)) x2\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 3. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "from ps' ws' N' ws x bij"], ["proof (chain)\npicking this:\n  ps' = (r', s') # ps\n  ws' =\n  xs @\n  remdups' (map_prod post post \\<circ> snd)\n   (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n     (map (\\<lambda>a. (a # w, delta a r', delta a s')) (\\<sigma> n)))\n  N' =\n  set (map (\\<lambda>a. (post (delta a r'), post (delta a s')))\n        (\\<sigma> n)) -\n  N \\<union>\n  N\n  \\<forall>(w, r', s')\\<in>set ws.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  x = (w, r', s')\n  bij_betw (map_prod post post) (set (map snd ws @ ps)) N", "show \"bij_betw (map_prod post post) (set (map snd ws' @ ps')) N'\""], ["proof (prove)\nusing this:\n  ps' = (r', s') # ps\n  ws' =\n  xs @\n  remdups' (map_prod post post \\<circ> snd)\n   (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n     (map (\\<lambda>a. (a # w, delta a r', delta a s')) (\\<sigma> n)))\n  N' =\n  set (map (\\<lambda>a. (post (delta a r'), post (delta a s')))\n        (\\<sigma> n)) -\n  N \\<union>\n  N\n  \\<forall>(w, r', s')\\<in>set ws.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  x = (w, r', s')\n  bij_betw (map_prod post post) (set (map snd ws @ ps)) N\n\ngoal (1 subgoal):\n 1. bij_betw (map_prod post post) (set (map snd ws' @ ps')) N'", "unfolding ws'ps' N'"], ["proof (prove)\nusing this:\n  ps' = (r', s') # ps\n  ws' =\n  xs @\n  remdups' (map_prod post post \\<circ> snd)\n   (filter (\\<lambda>(uu_, p). map_prod post post p \\<notin> N)\n     (map (\\<lambda>a. (a # w, delta a r', delta a s')) (\\<sigma> n)))\n  set (map (\\<lambda>a. (post (delta a r'), post (delta a s')))\n        (\\<sigma> n)) -\n  N \\<union>\n  N =\n  set (map (\\<lambda>a. (post (delta a r'), post (delta a s')))\n        (\\<sigma> n)) -\n  N \\<union>\n  N\n  \\<forall>(w, r', s')\\<in>set ws.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  x = (w, r', s')\n  bij_betw (map_prod post post) (set (map snd ws @ ps)) N\n\ngoal (1 subgoal):\n 1. bij_betw (map_prod post post)\n     (set (remdups' (map_prod post post)\n            (filter (\\<lambda>p. map_prod post post p \\<notin> N)\n              (map (\\<lambda>a. (delta a r', delta a s'))\n                (\\<sigma> n)))) \\<union>\n      set (map snd ws @ ps))\n     (set (map (\\<lambda>a. (post (delta a r'), post (delta a s')))\n            (\\<sigma> n)) -\n      N \\<union>\n      N)", "by (intro bij_betw_combine[OF _ bij]) (auto simp: bij_betw_def map_prod_def)"], ["proof (state)\nthis:\n  bij_betw (map_prod post post) (set (map snd ws' @ ps')) N'\n\ngoal (2 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "(*next*)"], ["proof (state)\nthis:\n  bij_betw (map_prod post post) (set (map snd ws' @ ps')) N'\n\ngoal (2 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "from ws x ws_Cons"], ["proof (chain)\npicking this:\n  \\<forall>(w, r', s')\\<in>set ws.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  x = (w, r', s')\n  ws = x # xs", "have wr's': \"?ws w r' s'\""], ["proof (prove)\nusing this:\n  \\<forall>(w, r', s')\\<in>set ws.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  x = (w, r', s')\n  ws = x # xs\n\ngoal (1 subgoal):\n 1. fold delta (rev w) r = r' \\<and>\n    fold delta (rev w) s = s' \\<and>\n    wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'", "by auto"], ["proof (state)\nthis:\n  fold delta (rev w) r = r' \\<and>\n  fold delta (rev w) s = s' \\<and>\n  wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n\ngoal (2 subgoals):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(w, r', s')\\<in>set x1b.\n                            fold delta (rev w) r = r' \\<and>\n                            fold delta (rev w) s = s' \\<and>\n                            wf_word n (rev w) \\<and>\n                            wf_state r' \\<and> wf_state s'\n 2. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "with ws ws_Cons"], ["proof (chain)\npicking this:\n  \\<forall>(w, r', s')\\<in>set ws.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  ws = x # xs\n  fold delta (rev w) r = r' \\<and>\n  fold delta (rev w) s = s' \\<and>\n  wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'", "show \"\\<forall>(w, r', s') \\<in> set ws'. ?ws w r' s'\""], ["proof (prove)\nusing this:\n  \\<forall>(w, r', s')\\<in>set ws.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  ws = x # xs\n  fold delta (rev w) r = r' \\<and>\n  fold delta (rev w) s = s' \\<and>\n  wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n\ngoal (1 subgoal):\n 1. \\<forall>(w, r', s')\\<in>set ws'.\n       fold delta (rev w) r = r' \\<and>\n       fold delta (rev w) s = s' \\<and>\n       wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'", "unfolding ws'"], ["proof (prove)\nusing this:\n  \\<forall>(w, r', s')\\<in>set ws.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  ws = x # xs\n  fold delta (rev w) r = r' \\<and>\n  fold delta (rev w) s = s' \\<and>\n  wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n\ngoal (1 subgoal):\n 1. \\<forall>(w, r', s')\n             \\<in>set (xs @\n                       remdups' (map_prod post post \\<circ> snd)\n                        (filter\n                          (\\<lambda>(uu_, p).\n                              map_prod post post p \\<notin> N)\n                          (map (\\<lambda>a. (a # w, delta a r', delta a s'))\n                            (\\<sigma> n)))).\n       fold delta (rev w) r = r' \\<and>\n       fold delta (rev w) s = s' \\<and>\n       wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'", "by (auto dest!: mp_remdups' elim!: subsetD)"], ["proof (state)\nthis:\n  \\<forall>(w, r', s')\\<in>set ws'.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n\ngoal (1 subgoal):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "(*next*)"], ["proof (state)\nthis:\n  \\<forall>(w, r', s')\\<in>set ws'.\n     fold delta (rev w) r = r' \\<and>\n     fold delta (rev w) s = s' \\<and>\n     wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n\ngoal (1 subgoal):\n 1. \\<And>x1 a b x1a x2a x1b aa ba x1c x2.\n       \\<lbrakk>test_invariant (x1, x1a, x2a);\n        (r, s) \\<in> snd ` set x1 \\<union> set x1a;\n        distinct (map snd x1 @ x1a);\n        bij_betw (map_prod post post) (set (map snd x1 @ x1a)) x2a;\n        \\<forall>(w, r', s')\\<in>set x1.\n           fold delta (rev w) r = r' \\<and>\n           fold delta (rev w) s = s' \\<and>\n           wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s';\n        \\<forall>(r', s')\\<in>set x1a.\n           (\\<exists>w.\n               fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n           wf_state r' \\<and>\n           wf_state s' \\<and>\n           final r' = final s' \\<and>\n           (\\<forall>a\\<in>set (\\<sigma> n).\n               (post (delta a r'), post (delta a s')) \\<in> x2a);\n        st = (x1, x1a, x2a);\n        step_invariant (x1, x1a, x2a) = (x1b, x1c, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(r', s')\\<in>set x1c.\n                            (\\<exists>w.\n                                fold delta w r = r' \\<and>\n                                fold delta w s = s') \\<and>\n                            wf_state r' \\<and>\n                            wf_state s' \\<and>\n                            final r' = final s' \\<and>\n                            (\\<forall>a\\<in>set (\\<sigma> n).\n                                (post (delta a r'), post (delta a s'))\n                                \\<in> x2)", "from ps wr's' test_invariant[unfolded ws_Cons x]"], ["proof (chain)\npicking this:\n  \\<forall>(r', s')\\<in>set ps.\n     (\\<exists>w. fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n     wf_state r' \\<and>\n     wf_state s' \\<and>\n     final r' = final s' \\<and>\n     (\\<forall>a\\<in>set (\\<sigma> n).\n         (post (delta a r'), post (delta a s')) \\<in> N)\n  fold delta (rev w) r = r' \\<and>\n  fold delta (rev w) s = s' \\<and>\n  wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  test_invariant ((w, r', s') # xs, ps, N)", "show \"\\<forall>(r', s') \\<in> set ps'. ?ps r' s' N'\""], ["proof (prove)\nusing this:\n  \\<forall>(r', s')\\<in>set ps.\n     (\\<exists>w. fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n     wf_state r' \\<and>\n     wf_state s' \\<and>\n     final r' = final s' \\<and>\n     (\\<forall>a\\<in>set (\\<sigma> n).\n         (post (delta a r'), post (delta a s')) \\<in> N)\n  fold delta (rev w) r = r' \\<and>\n  fold delta (rev w) s = s' \\<and>\n  wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  test_invariant ((w, r', s') # xs, ps, N)\n\ngoal (1 subgoal):\n 1. \\<forall>(r', s')\\<in>set ps'.\n       (\\<exists>w. fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n       wf_state r' \\<and>\n       wf_state s' \\<and>\n       final r' = final s' \\<and>\n       (\\<forall>a\\<in>set (\\<sigma> n).\n           (post (delta a r'), post (delta a s')) \\<in> N')", "unfolding ps' N'"], ["proof (prove)\nusing this:\n  \\<forall>(r', s')\\<in>set ps.\n     (\\<exists>w. fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n     wf_state r' \\<and>\n     wf_state s' \\<and>\n     final r' = final s' \\<and>\n     (\\<forall>a\\<in>set (\\<sigma> n).\n         (post (delta a r'), post (delta a s')) \\<in> N)\n  fold delta (rev w) r = r' \\<and>\n  fold delta (rev w) s = s' \\<and>\n  wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s'\n  test_invariant ((w, r', s') # xs, ps, N)\n\ngoal (1 subgoal):\n 1. \\<forall>(r'a, s'a)\\<in>set ((r', s') # ps).\n       (\\<exists>w. fold delta w r = r'a \\<and> fold delta w s = s'a) \\<and>\n       wf_state r'a \\<and>\n       wf_state s'a \\<and>\n       final r'a = final s'a \\<and>\n       (\\<forall>a\\<in>set (\\<sigma> n).\n           (post (delta a r'a), post (delta a s'a))\n           \\<in> set (map (\\<lambda>a.\n                              (post (delta a r'), post (delta a s')))\n                       (\\<sigma> n)) -\n                 N \\<union>\n                 N)", "by (fastforce simp: image_Collect)"], ["proof (state)\nthis:\n  \\<forall>(r', s')\\<in>set ps'.\n     (\\<exists>w. fold delta w r = r' \\<and> fold delta w s = s') \\<and>\n     wf_state r' \\<and>\n     wf_state s' \\<and>\n     final r' = final s' \\<and>\n     (\\<forall>a\\<in>set (\\<sigma> n).\n         (post (delta a r'), post (delta a s')) \\<in> N')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_commute: \"ws \\<noteq> [] \\<Longrightarrow>\n  (case step_invariant (ws, ps, N) of (ws', ps', N') \\<Rightarrow> (map snd ws', N')) = step (map snd ws, N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    (case step_invariant (ws, ps, N) of\n     (ws', ps', N') \\<Rightarrow> (map snd ws', N')) =\n    step (map snd ws, N)", "apply (auto split: prod.splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a b x1a x2.\n       \\<lbrakk>ws \\<noteq> []; hd ws = (x1, a, b);\n        hd (map snd ws) = (x1a, x2)\\<rbrakk>\n       \\<Longrightarrow> map snd (tl ws) = tl (map snd ws)\n 2. \\<And>x1 a b x1a x2.\n       \\<lbrakk>ws \\<noteq> []; hd ws = (x1, a, b);\n        hd (map snd ws) = (x1a, x2)\\<rbrakk>\n       \\<Longrightarrow> map (snd \\<circ> fst)\n                          (remdups' snd\n                            (filter (\\<lambda>(uu_, rs). rs \\<notin> N)\n                              (map (\\<lambda>aa.\n let r' = delta aa a; s' = delta aa b\n in ((aa # x1, r', s'), post r', post s'))\n                                (\\<sigma> n)))) =\n                         map fst\n                          (remdups' snd\n                            (filter (\\<lambda>(uu_, rs). rs \\<notin> N)\n                              (map (\\<lambda>a.\n let r' = delta a x1a; s' = delta a x2 in ((r', s'), post r', post s'))\n                                (\\<sigma> n))))\n 3. \\<And>x1 a b x1a x2 ba ab ac bb ad ae.\n       \\<lbrakk>ws \\<noteq> []; hd ws = (x1, a, b);\n        hd (map snd ws) = (x1a, x2); (ad, ba) \\<notin> N;\n        ((ab, ac, bb), ad, ba) =\n        (let r' = delta ae a; s' = delta ae b\n         in ((ae # x1, r', s'), post r', post s'));\n        ae \\<in> set (\\<sigma> n)\\<rbrakk>\n       \\<Longrightarrow> (ad, ba)\n                         \\<in> snd `\n                               {x. \\<forall>a b aa ba.\nx = ((a, b), aa, ba) \\<longrightarrow>\n((a, b), aa, ba)\n\\<in> (\\<lambda>a.\n          let r' = delta a x1a; s' = delta a x2\n          in ((r', s'), post r', post s')) `\n      set (\\<sigma> n) \\<and>\n(aa, ba) \\<notin> N}\n 4. \\<And>x1 a b x1a x2 ba ab bb ac ad.\n       \\<lbrakk>ws \\<noteq> []; hd ws = (x1, a, b);\n        hd (map snd ws) = (x1a, x2); (ac, ba) \\<notin> N;\n        ((ab, bb), ac, ba) =\n        (let r' = delta ad x1a; s' = delta ad x2\n         in ((r', s'), post r', post s'));\n        ad \\<in> set (\\<sigma> n)\\<rbrakk>\n       \\<Longrightarrow> (ac, ba)\n                         \\<in> snd `\n                               {x. \\<forall>aa ab ba ac bb.\nx = ((aa, ab, ba), ac, bb) \\<longrightarrow>\n((aa, ab, ba), ac, bb)\n\\<in> (\\<lambda>aa.\n          let r' = delta aa a; s' = delta aa b\n          in ((aa # x1, r', s'), post r', post s')) `\n      set (\\<sigma> n) \\<and>\n(ac, bb) \\<notin> N}", "apply (auto simp only: step_invariant.simps step.simps Let_def map_apfst_remdups' filter_map list.map_comp apfst_def map_prod_def snd_conv id_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 a b x1a x2.\n       \\<lbrakk>ws \\<noteq> []; hd ws = (x1, a, b);\n        hd (map snd ws) = (x1a, x2)\\<rbrakk>\n       \\<Longrightarrow> map snd (tl ws) = tl (map snd ws)\n 2. \\<And>x1 a b x1a x2.\n       \\<lbrakk>ws \\<noteq> []; hd ws = (x1, a, b);\n        hd (map snd ws) = (x1a, x2)\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (remdups' snd\n                            (map ((\\<lambda>(x, y). (snd x, y)) \\<circ>\n                                  (\\<lambda>aa.\n((aa # x1, delta aa a, delta aa b), post (delta aa a), post (delta aa b))))\n                              (filter\n                                ((\\<lambda>(uu_, rs). rs \\<notin> N) \\<circ>\n                                 (\\<lambda>aa.\n                                     ((aa # x1, delta aa a, delta aa b),\npost (delta aa a), post (delta aa b))))\n                                (\\<sigma> n)))) =\n                         map fst\n                          (remdups' snd\n                            (map (\\<lambda>a.\n                                     ((delta a x1a, delta a x2),\npost (delta a x1a), post (delta a x2)))\n                              (filter\n                                ((\\<lambda>(uu_, rs). rs \\<notin> N) \\<circ>\n                                 (\\<lambda>a.\n                                     ((delta a x1a, delta a x2),\npost (delta a x1a), post (delta a x2))))\n                                (\\<sigma> n))))\n 3. \\<And>x1 a b x1a x2 ae.\n       \\<lbrakk>ws \\<noteq> []; hd ws = (x1, a, b);\n        hd (map snd ws) = (x1a, x2);\n        (post (delta ae a), post (delta ae b)) \\<notin> N;\n        ae \\<in> set (\\<sigma> n)\\<rbrakk>\n       \\<Longrightarrow> (post (delta ae a), post (delta ae b))\n                         \\<in> snd `\n                               {x. \\<forall>a b aa ba.\nx = ((a, b), aa, ba) \\<longrightarrow>\n((a, b), aa, ba)\n\\<in> (\\<lambda>a.\n          ((delta a x1a, delta a x2), post (delta a x1a),\n           post (delta a x2))) `\n      set (\\<sigma> n) \\<and>\n(aa, ba) \\<notin> N}\n 4. \\<And>x1 a b x1a x2 ad.\n       \\<lbrakk>ws \\<noteq> []; hd ws = (x1, a, b);\n        hd (map snd ws) = (x1a, x2);\n        (post (delta ad x1a), post (delta ad x2)) \\<notin> N;\n        ad \\<in> set (\\<sigma> n)\\<rbrakk>\n       \\<Longrightarrow> (post (delta ad x1a), post (delta ad x2))\n                         \\<in> snd `\n                               {x. \\<forall>aa ab ba ac bb.\nx = ((aa, ab, ba), ac, bb) \\<longrightarrow>\n((aa, ab, ba), ac, bb)\n\\<in> (\\<lambda>aa.\n          ((aa # x1, delta aa a, delta aa b), post (delta aa a),\n           post (delta aa b))) `\n      set (\\<sigma> n) \\<and>\n(ac, bb) \\<notin> N}", "apply (auto simp: filter_map comp_def map_tl hd_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 b x1a ae.\n       \\<lbrakk>ws \\<noteq> []; hd ws = (x1, x1a, b);\n        (post (delta ae x1a), post (delta ae b)) \\<notin> N;\n        ae \\<in> set (\\<sigma> n)\\<rbrakk>\n       \\<Longrightarrow> (post (delta ae x1a), post (delta ae b))\n                         \\<in> snd `\n                               {x. \\<forall>a ba aa bb.\nx = ((a, ba), aa, bb) \\<longrightarrow>\n((a, ba), aa, bb)\n\\<in> (\\<lambda>a.\n          ((delta a x1a, delta a b), post (delta a x1a),\n           post (delta a b))) `\n      set (\\<sigma> n) \\<and>\n(aa, bb) \\<notin> N}\n 2. \\<And>x1 b x1a ad.\n       \\<lbrakk>ws \\<noteq> []; hd ws = (x1, x1a, b);\n        (post (delta ad x1a), post (delta ad b)) \\<notin> N;\n        ad \\<in> set (\\<sigma> n)\\<rbrakk>\n       \\<Longrightarrow> (post (delta ad x1a), post (delta ad b))\n                         \\<in> snd `\n                               {x. \\<forall>a aa ba ab bb.\nx = ((a, aa, ba), ab, bb) \\<longrightarrow>\n((a, aa, ba), ab, bb)\n\\<in> (\\<lambda>x.\n          ((x # x1, delta x x1a, delta x b), post (delta x x1a),\n           post (delta x b))) `\n      set (\\<sigma> n) \\<and>\n(ab, bb) \\<notin> N}", "apply (intro image_eqI, auto)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma closure_invariant_closure:\n  \"map_option (\\<lambda>(ws, ps, N). (map snd ws, N)) (closure_invariant (ws, ps, N)) = closure (map snd ws, N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (\\<lambda>(ws, ps, N). (map snd ws, N))\n     (closure_invariant (ws, ps, N)) =\n    closure (map snd ws, N)", "unfolding closure_invariant_def closure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (\\<lambda>(ws, ps, N). (map snd ws, N))\n     (while_option test_invariant step_invariant (ws, ps, N)) =\n    while_option test step (map snd ws, N)", "by (rule trans[OF while_option_commute[of _ test _ _ \"step\"]])\n   (auto split: list.splits simp del: step_invariant.simps step.simps list.map simp: step_commute)"], ["", "lemma\n  assumes result: \"closure_invariant ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n    Some(ws, ps, N)\" (is \"closure_invariant ([([], ?r, ?s)], _) = _\")\n  and WF: \"wf n r\" \"wf n s\"\n  shows closure_invariant_sound: \"ws = [] \\<Longrightarrow> lang n r = lang n s\" and\n    counterexample: \"ws \\<noteq> [] \\<Longrightarrow> rev (fst (hd ws)) \\<in> lang n r \\<longleftrightarrow> rev (fst (hd ws)) \\<notin> lang n s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ws = [] \\<Longrightarrow> lang n r = lang n s) &&&\n    (ws \\<noteq> [] \\<Longrightarrow>\n     (rev (fst (hd ws)) \\<in> lang n r) =\n     (rev (fst (hd ws)) \\<notin> lang n s))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow> lang n r = lang n s\n 2. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "from WF"], ["proof (chain)\npicking this:\n  local.wf n r\n  local.wf n s", "have wf_state: \"wf_state ?r\" \"wf_state ?s\""], ["proof (prove)\nusing this:\n  local.wf n r\n  local.wf n s\n\ngoal (1 subgoal):\n 1. wf_state (init r) &&& wf_state (init s)", "by simp_all"], ["proof (state)\nthis:\n  wf_state (init r)\n  wf_state (init s)\n\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow> lang n r = lang n s\n 2. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "from invariant invariant_start[OF wf_state]"], ["proof (chain)\npicking this:\n  \\<lbrakk>invariant ?r ?s ?st; test_invariant ?st\\<rbrakk>\n  \\<Longrightarrow> invariant ?r ?s (step_invariant ?st)\n  invariant (init r) (init s)\n   ([([], init r, init s)], [], {(post (init r), post (init s))})", "have invariant_ps: \"invariant ?r ?s (ws, ps, N)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>invariant ?r ?s ?st; test_invariant ?st\\<rbrakk>\n  \\<Longrightarrow> invariant ?r ?s (step_invariant ?st)\n  invariant (init r) (init s)\n   ([([], init r, init s)], [], {(post (init r), post (init s))})\n\ngoal (1 subgoal):\n 1. invariant (init r) (init s) (ws, ps, N)", "by (rule while_option_rule[OF _ result[unfolded closure_invariant_def]])"], ["proof (state)\nthis:\n  invariant (init r) (init s) (ws, ps, N)\n\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow> lang n r = lang n s\n 2. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "{"], ["proof (state)\nthis:\n  invariant (init r) (init s) (ws, ps, N)\n\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow> lang n r = lang n s\n 2. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "assume \"ws = []\""], ["proof (state)\nthis:\n  ws = []\n\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow> lang n r = lang n s\n 2. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "with invariant_ps"], ["proof (chain)\npicking this:\n  invariant (init r) (init s) (ws, ps, N)\n  ws = []", "have \"bisimulation (in_rel (set ps))\" \"(?r, ?s) \\<in> set ps\""], ["proof (prove)\nusing this:\n  invariant (init r) (init s) (ws, ps, N)\n  ws = []\n\ngoal (1 subgoal):\n 1. bisimulation (in_rel (set ps)) &&& (init r, init s) \\<in> set ps", "by (auto simp: bij_betw_def invariant_def bisimulation_def progression_def image2p_in_rel)"], ["proof (state)\nthis:\n  bisimulation (in_rel (set ps))\n  (init r, init s) \\<in> set ps\n\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow> lang n r = lang n s\n 2. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "with wf_state"], ["proof (chain)\npicking this:\n  wf_state (init r)\n  wf_state (init s)\n  bisimulation (in_rel (set ps))\n  (init r, init s) \\<in> set ps", "have \"L ?r = L ?s\""], ["proof (prove)\nusing this:\n  wf_state (init r)\n  wf_state (init s)\n  bisimulation (in_rel (set ps))\n  (init r, init s) \\<in> set ps\n\ngoal (1 subgoal):\n 1. L (init r) = L (init s)", "by (auto dest: coinduction)"], ["proof (state)\nthis:\n  L (init r) = L (init s)\n\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow> lang n r = lang n s\n 2. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "with WF"], ["proof (chain)\npicking this:\n  local.wf n r\n  local.wf n s\n  L (init r) = L (init s)", "show \"lang n r = lang n s\""], ["proof (prove)\nusing this:\n  local.wf n r\n  local.wf n s\n  L (init r) = L (init s)\n\ngoal (1 subgoal):\n 1. lang n r = lang n s", "by simp"], ["proof (state)\nthis:\n  lang n r = lang n s\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "}"], ["proof (state)\nthis:\n  ws = [] \\<Longrightarrow> lang n r = lang n s\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "{"], ["proof (state)\nthis:\n  ws = [] \\<Longrightarrow> lang n r = lang n s\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "assume \"ws \\<noteq> []\""], ["proof (state)\nthis:\n  ws \\<noteq> []\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "then"], ["proof (chain)\npicking this:\n  ws \\<noteq> []", "obtain w r' s' ws' where ws: \"ws = (w, r', s') # ws'\""], ["proof (prove)\nusing this:\n  ws \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>w r' s' ws'.\n        ws = (w, r', s') # ws' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ws) auto"], ["proof (state)\nthis:\n  ws = (w, r', s') # ws'\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "with invariant_ps"], ["proof (chain)\npicking this:\n  invariant (init r) (init s) (ws, ps, N)\n  ws = (w, r', s') # ws'", "have \"r' = fold delta (rev w) (init r)\" \"s' = fold delta (rev w) (init s)\"\n      \"wf_word n (rev w)\""], ["proof (prove)\nusing this:\n  invariant (init r) (init s) (ws, ps, N)\n  ws = (w, r', s') # ws'\n\ngoal (1 subgoal):\n 1. r' = fold delta (rev w) (init r) &&&\n    s' = fold delta (rev w) (init s) &&& wf_word n (rev w)", "unfolding invariant_def"], ["proof (prove)\nusing this:\n  case (ws, ps, N) of\n  (ws, ps, N) \\<Rightarrow>\n    (init r, init s) \\<in> snd ` set ws \\<union> set ps \\<and>\n    distinct (map snd ws @ ps) \\<and>\n    bij_betw (map_prod post post) (set (map snd ws @ ps)) N \\<and>\n    (\\<forall>(w, r', s')\\<in>set ws.\n        fold delta (rev w) (init r) = r' \\<and>\n        fold delta (rev w) (init s) = s' \\<and>\n        wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s') \\<and>\n    (\\<forall>(r', s')\\<in>set ps.\n        (\\<exists>w.\n            fold delta w (init r) = r' \\<and>\n            fold delta w (init s) = s') \\<and>\n        wf_state r' \\<and>\n        wf_state s' \\<and>\n        final r' = final s' \\<and>\n        (\\<forall>a\\<in>set (\\<sigma> n).\n            (post (delta a r'), post (delta a s')) \\<in> N))\n  ws = (w, r', s') # ws'\n\ngoal (1 subgoal):\n 1. r' = fold delta (rev w) (init r) &&&\n    s' = fold delta (rev w) (init s) &&& wf_word n (rev w)", "by auto"], ["proof (state)\nthis:\n  r' = fold delta (rev w) (init r)\n  s' = fold delta (rev w) (init s)\n  wf_word n (rev w)\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "moreover"], ["proof (state)\nthis:\n  r' = fold delta (rev w) (init r)\n  s' = fold delta (rev w) (init s)\n  wf_word n (rev w)\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "have \"\\<not> test_invariant ((w, r', s') # ws', ps, N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> test_invariant ((w, r', s') # ws', ps, N)", "by (rule while_option_stop[OF result[unfolded ws closure_invariant_def]])"], ["proof (state)\nthis:\n  \\<not> test_invariant ((w, r', s') # ws', ps, N)\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "ultimately"], ["proof (chain)\npicking this:\n  r' = fold delta (rev w) (init r)\n  s' = fold delta (rev w) (init s)\n  wf_word n (rev w)\n  \\<not> test_invariant ((w, r', s') # ws', ps, N)", "have \"rev (fst (hd ws)) \\<in> L ?r \\<longleftrightarrow> rev (fst (hd ws)) \\<notin> L ?s\""], ["proof (prove)\nusing this:\n  r' = fold delta (rev w) (init r)\n  s' = fold delta (rev w) (init s)\n  wf_word n (rev w)\n  \\<not> test_invariant ((w, r', s') # ws', ps, N)\n\ngoal (1 subgoal):\n 1. (rev (fst (hd ws)) \\<in> L (init r)) =\n    (rev (fst (hd ws)) \\<notin> L (init s))", "unfolding ws"], ["proof (prove)\nusing this:\n  r' = fold delta (rev w) (init r)\n  s' = fold delta (rev w) (init s)\n  wf_word n (rev w)\n  \\<not> test_invariant ((w, r', s') # ws', ps, N)\n\ngoal (1 subgoal):\n 1. (rev (fst (hd ((w, r', s') # ws'))) \\<in> L (init r)) =\n    (rev (fst (hd ((w, r', s') # ws'))) \\<notin> L (init s))", "using wf_state"], ["proof (prove)\nusing this:\n  r' = fold delta (rev w) (init r)\n  s' = fold delta (rev w) (init s)\n  wf_word n (rev w)\n  \\<not> test_invariant ((w, r', s') # ws', ps, N)\n  wf_state (init r)\n  wf_state (init s)\n\ngoal (1 subgoal):\n 1. (rev (fst (hd ((w, r', s') # ws'))) \\<in> L (init r)) =\n    (rev (fst (hd ((w, r', s') # ws'))) \\<notin> L (init s))", "by (simp add: in_fold_lQuot)"], ["proof (state)\nthis:\n  (rev (fst (hd ws)) \\<in> L (init r)) =\n  (rev (fst (hd ws)) \\<notin> L (init s))\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<Longrightarrow>\n    (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "with WF"], ["proof (chain)\npicking this:\n  local.wf n r\n  local.wf n s\n  (rev (fst (hd ws)) \\<in> L (init r)) =\n  (rev (fst (hd ws)) \\<notin> L (init s))", "show \"rev (fst (hd ws)) \\<in> lang n r \\<longleftrightarrow> rev (fst (hd ws)) \\<notin> lang n s\""], ["proof (prove)\nusing this:\n  local.wf n r\n  local.wf n s\n  (rev (fst (hd ws)) \\<in> L (init r)) =\n  (rev (fst (hd ws)) \\<notin> L (init s))\n\ngoal (1 subgoal):\n 1. (rev (fst (hd ws)) \\<in> lang n r) =\n    (rev (fst (hd ws)) \\<notin> lang n s)", "by simp"], ["proof (state)\nthis:\n  (rev (fst (hd ws)) \\<in> lang n r) = (rev (fst (hd ws)) \\<notin> lang n s)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ws \\<noteq> [] \\<Longrightarrow>\n  (rev (fst (hd ws)) \\<in> lang n r) = (rev (fst (hd ws)) \\<notin> lang n s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closure_sound:\n  assumes result: \"closure ([(init r, init s)], {(post (init r), post (init s))}) = Some ([], N)\"\n  and WF: \"wf n r\" \"wf n s\"\n  shows \"lang n r = lang n s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n r = lang n s", "using trans[OF closure_invariant_closure[of \"[([], init r, init s)]\", simplified] result]"], ["proof (prove)\nusing this:\n  map_option (\\<lambda>(ws, ps, N). (map snd ws, N))\n   (closure_invariant\n     ([([], init r, init s)], ?ps1, {(post (init r), post (init s))})) =\n  Some ([], N)\n\ngoal (1 subgoal):\n 1. lang n r = lang n s", "by (auto dest: closure_invariant_sound[OF _ WF])"], ["", "definition check_eqv where\n  \"check_eqv r s =\n    (let r' = init r; s' = init s in (case closure ([(r', s')], {(post r', post s')}) of\n       Some ([], _) \\<Rightarrow> True | _ \\<Rightarrow> False))\""], ["", "lemma check_eqv_sound:\n  assumes \"check_eqv r s\" and WF: \"wf n r\" \"wf n s\"\n  shows \"lang n r = lang n s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n r = lang n s", "using closure_sound assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>closure\n            ([(init ?r, init ?s)], {(post (init ?r), post (init ?s))}) =\n           Some ([], ?N);\n   local.wf n ?r; local.wf n ?s\\<rbrakk>\n  \\<Longrightarrow> lang n ?r = lang n ?s\n  check_eqv r s\n  local.wf n r\n  local.wf n s\n\ngoal (1 subgoal):\n 1. lang n r = lang n s", "by (auto simp: check_eqv_def Let_def split: option.splits list.splits)"], ["", "definition counterexample where\n  \"counterexample r s =\n    (let r' = init r; s' = init s in (case closure_invariant ([([], r', s')], [], {(post r', post s')}) of\n       Some((w,_,_) # _, _) \\<Rightarrow> Some (rev w) | _ => None))\""], ["", "lemma counterexample_sound:\n  assumes result: \"counterexample r s = Some w\"  and WF: \"wf n r\" \"wf n s\"\n  shows \"w \\<in> lang n r \\<longleftrightarrow> w \\<notin> lang n s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> lang n r) = (w \\<notin> lang n s)", "using assms"], ["proof (prove)\nusing this:\n  counterexample r s = Some w\n  local.wf n r\n  local.wf n s\n\ngoal (1 subgoal):\n 1. (w \\<in> lang n r) = (w \\<notin> lang n s)", "unfolding counterexample_def Let_def"], ["proof (prove)\nusing this:\n  (case closure_invariant\n         ([([], init r, init s)], [], {(post (init r), post (init s))}) of\n   None \\<Rightarrow> None | Some ([], xc) \\<Rightarrow> None\n   | Some ((w, xa, xaa) # xb, xc) \\<Rightarrow> Some (rev w)) =\n  Some w\n  local.wf n r\n  local.wf n s\n\ngoal (1 subgoal):\n 1. (w \\<in> lang n r) = (w \\<notin> lang n s)", "by (auto dest!: counterexample[of r s] split: option.splits list.splits)"], ["", "text\\<open>Auxiliary exacutable functions:\\<close>"], ["", "definition reachable :: \"'b rexp \\<Rightarrow> 's set\" where\n  \"reachable s = snd (the (rtrancl_while (\\<lambda>_. True) (\\<lambda>s. map (\\<lambda>a. post (delta a s)) (\\<sigma> n)) (init s)))\""], ["", "definition automaton :: \"'b rexp \\<Rightarrow> (('s * 'a) * 's) set\" where\n  \"automaton s =\n    snd (the\n    (let i = init s;\n         start = (([i], {post i}), {});\n         test_invariant = \\<lambda>((ws, Z), A). ws \\<noteq> [];\n         step_invariant = \\<lambda>((ws, Z), A).\n           (let s = hd ws;\n                new_edges = map (\\<lambda>a. ((s, a), delta a s)) (\\<sigma> n);\n                new = remdups (filter (\\<lambda>ss. post ss \\<notin> Z) (map snd new_edges))\n           in ((new @ tl ws, post ` set new \\<union> Z), set new_edges \\<union> A))\n    in while_option test_invariant step_invariant start))\""], ["", "definition match :: \"'b rexp \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  \"match s w = final (fold delta w (init s))\""], ["", "lemma match_correct: \"\\<lbrakk>wf_word n w; wf n s\\<rbrakk> \\<Longrightarrow> match s w \\<longleftrightarrow> w \\<in> lang n s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_word n w; local.wf n s\\<rbrakk>\n    \\<Longrightarrow> match s w = (w \\<in> lang n s)", "unfolding match_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_word n w; local.wf n s\\<rbrakk>\n    \\<Longrightarrow> final (fold delta w (init s)) = (w \\<in> lang n s)", "by (induct w arbitrary: s) (auto simp: in_fold_lQuot lQuot_def)"], ["", "end"], ["", "locale rexp_DFA = rexp_DA \\<sigma> wf_atom project lookup init delta final wf_state post L n\n  for \\<sigma> :: \"nat \\<Rightarrow> 'a list\"\n  and wf_atom :: \"nat \\<Rightarrow> 'b :: linorder \\<Rightarrow> bool\"\n  and project :: \"'a \\<Rightarrow> 'a\"\n  and lookup :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and init :: \"'b rexp \\<Rightarrow> 's\"\n  and delta :: \"'a \\<Rightarrow> 's \\<Rightarrow> 's\"\n  and final :: \"'s \\<Rightarrow> bool\"\n  and wf_state :: \"'s \\<Rightarrow> bool\"\n  and post :: \"'s \\<Rightarrow> 's\"\n  and L :: \"'s \\<Rightarrow> 'a lang\"\n  and n :: nat +\nassumes fin: \"finite {fold delta w (init s) | w. True}\"\nbegin"], ["", "abbreviation \"Reachable s \\<equiv> {fold delta w (init s) | w. True}\""], ["", "lemma closure_invariant_termination:\n  assumes WF: \"wf n r\" \"wf n s\"\n  and result: \"closure_invariant ([([], init r, init s)], [], {(post (init r), post (init s))}) = None\"\n    (is \"closure_invariant ([([], ?r, ?s)], _) = None\" is \"?cl = None\")\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "let ?D =  \"post ` Reachable r \\<times> post ` Reachable s\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "let ?X = \"\\<lambda>ps. ?D - map_prod post post ` set ps\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "let ?f = \"\\<lambda>(ws, ps, N). card (?X ps)\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<exists>st. ?cl = Some st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>st.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some st", "unfolding closure_invariant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>st.\n       while_option test_invariant step_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some st", "proof (rule measure_while_option_Some[of \"invariant ?r ?s\" _ _ ?f], intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "fix st"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "assume base: \"invariant ?r ?s st\" and \"test_invariant st\""], ["proof (state)\nthis:\n  invariant (init r) (init s) st\n  test_invariant st\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "hence step: \"invariant ?r ?s (step_invariant st)\""], ["proof (prove)\nusing this:\n  invariant (init r) (init s) st\n  test_invariant st\n\ngoal (1 subgoal):\n 1. invariant (init r) (init s) (step_invariant st)", "by (rule invariant)"], ["proof (state)\nthis:\n  invariant (init r) (init s) (step_invariant st)\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "obtain ws ps N where st: \"st = (ws, ps, N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ws ps N.\n        st = (ws, ps, N) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases st) blast"], ["proof (state)\nthis:\n  st = (ws, ps, N)\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "hence \"finite (?X ps)\""], ["proof (prove)\nusing this:\n  st = (ws, ps, N)\n\ngoal (1 subgoal):\n 1. finite\n     (post ` Reachable r \\<times> post ` Reachable s -\n      map_prod post post ` set ps)", "by (blast intro: finite_cartesian_product fin)"], ["proof (state)\nthis:\n  finite\n   (post ` Reachable r \\<times> post ` Reachable s -\n    map_prod post post ` set ps)\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "moreover"], ["proof (state)\nthis:\n  finite\n   (post ` Reachable r \\<times> post ` Reachable s -\n    map_prod post post ` set ps)\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "obtain ws' ps' N' where step_invariant: \"step_invariant (ws, ps, N) = (ws', ps', N')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ws' ps' N'.\n        step_invariant (ws, ps, N) = (ws', ps', N') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"step_invariant (ws, ps, N)\") blast"], ["proof (state)\nthis:\n  step_invariant (ws, ps, N) = (ws', ps', N')\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "moreover"], ["proof (state)\nthis:\n  step_invariant (ws, ps, N) = (ws', ps', N')\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "{"], ["proof (state)\nthis:\n  step_invariant (ws, ps, N) = (ws', ps', N')\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "have \"map_prod post post ` set ps \\<subseteq> ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod post post ` set ps\n    \\<subseteq> post ` Reachable r \\<times> post ` Reachable s", "using base[unfolded st invariant_def]"], ["proof (prove)\nusing this:\n  case (ws, ps, N) of\n  (ws, ps, N) \\<Rightarrow>\n    (init r, init s) \\<in> snd ` set ws \\<union> set ps \\<and>\n    distinct (map snd ws @ ps) \\<and>\n    bij_betw (map_prod post post) (set (map snd ws @ ps)) N \\<and>\n    (\\<forall>(w, r', s')\\<in>set ws.\n        fold delta (rev w) (init r) = r' \\<and>\n        fold delta (rev w) (init s) = s' \\<and>\n        wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s') \\<and>\n    (\\<forall>(r', s')\\<in>set ps.\n        (\\<exists>w.\n            fold delta w (init r) = r' \\<and>\n            fold delta w (init s) = s') \\<and>\n        wf_state r' \\<and>\n        wf_state s' \\<and>\n        final r' = final s' \\<and>\n        (\\<forall>a\\<in>set (\\<sigma> n).\n            (post (delta a r'), post (delta a s')) \\<in> N))\n\ngoal (1 subgoal):\n 1. map_prod post post ` set ps\n    \\<subseteq> post ` Reachable r \\<times> post ` Reachable s", "by fast"], ["proof (state)\nthis:\n  map_prod post post ` set ps\n  \\<subseteq> post ` Reachable r \\<times> post ` Reachable s\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "moreover"], ["proof (state)\nthis:\n  map_prod post post ` set ps\n  \\<subseteq> post ` Reachable r \\<times> post ` Reachable s\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "have \"map_prod post post ` set ps' \\<subseteq> ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod post post ` set ps'\n    \\<subseteq> post ` Reachable r \\<times> post ` Reachable s", "using step[unfolded st step_invariant invariant_def]"], ["proof (prove)\nusing this:\n  case (ws', ps', N') of\n  (ws, ps, N) \\<Rightarrow>\n    (init r, init s) \\<in> snd ` set ws \\<union> set ps \\<and>\n    distinct (map snd ws @ ps) \\<and>\n    bij_betw (map_prod post post) (set (map snd ws @ ps)) N \\<and>\n    (\\<forall>(w, r', s')\\<in>set ws.\n        fold delta (rev w) (init r) = r' \\<and>\n        fold delta (rev w) (init s) = s' \\<and>\n        wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s') \\<and>\n    (\\<forall>(r', s')\\<in>set ps.\n        (\\<exists>w.\n            fold delta w (init r) = r' \\<and>\n            fold delta w (init s) = s') \\<and>\n        wf_state r' \\<and>\n        wf_state s' \\<and>\n        final r' = final s' \\<and>\n        (\\<forall>a\\<in>set (\\<sigma> n).\n            (post (delta a r'), post (delta a s')) \\<in> N))\n\ngoal (1 subgoal):\n 1. map_prod post post ` set ps'\n    \\<subseteq> post ` Reachable r \\<times> post ` Reachable s", "by fast"], ["proof (state)\nthis:\n  map_prod post post ` set ps'\n  \\<subseteq> post ` Reachable r \\<times> post ` Reachable s\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "moreover"], ["proof (state)\nthis:\n  map_prod post post ` set ps'\n  \\<subseteq> post ` Reachable r \\<times> post ` Reachable s\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "{"], ["proof (state)\nthis:\n  map_prod post post ` set ps'\n  \\<subseteq> post ` Reachable r \\<times> post ` Reachable s\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "have \"distinct (map snd ws @ ps)\" \"inj_on (map_prod post post) (set (map snd ws @ ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map snd ws @ ps) &&&\n    inj_on (map_prod post post) (set (map snd ws @ ps))", "using base[unfolded st invariant_def]"], ["proof (prove)\nusing this:\n  case (ws, ps, N) of\n  (ws, ps, N) \\<Rightarrow>\n    (init r, init s) \\<in> snd ` set ws \\<union> set ps \\<and>\n    distinct (map snd ws @ ps) \\<and>\n    bij_betw (map_prod post post) (set (map snd ws @ ps)) N \\<and>\n    (\\<forall>(w, r', s')\\<in>set ws.\n        fold delta (rev w) (init r) = r' \\<and>\n        fold delta (rev w) (init s) = s' \\<and>\n        wf_word n (rev w) \\<and> wf_state r' \\<and> wf_state s') \\<and>\n    (\\<forall>(r', s')\\<in>set ps.\n        (\\<exists>w.\n            fold delta w (init r) = r' \\<and>\n            fold delta w (init s) = s') \\<and>\n        wf_state r' \\<and>\n        wf_state s' \\<and>\n        final r' = final s' \\<and>\n        (\\<forall>a\\<in>set (\\<sigma> n).\n            (post (delta a r'), post (delta a s')) \\<in> N))\n\ngoal (1 subgoal):\n 1. distinct (map snd ws @ ps) &&&\n    inj_on (map_prod post post) (set (map snd ws @ ps))", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  distinct (map snd ws @ ps)\n  inj_on (map_prod post post) (set (map snd ws @ ps))\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "hence \"distinct (map (map_prod post post) (map snd ws @ ps))\""], ["proof (prove)\nusing this:\n  distinct (map snd ws @ ps)\n  inj_on (map_prod post post) (set (map snd ws @ ps))\n\ngoal (1 subgoal):\n 1. distinct (map (map_prod post post) (map snd ws @ ps))", "unfolding distinct_map"], ["proof (prove)\nusing this:\n  distinct (map snd ws @ ps)\n  inj_on (map_prod post post) (set (map snd ws @ ps))\n\ngoal (1 subgoal):\n 1. distinct (map snd ws @ ps) \\<and>\n    inj_on (map_prod post post) (set (map snd ws @ ps))", ".."], ["proof (state)\nthis:\n  distinct (map (map_prod post post) (map snd ws @ ps))\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "hence \"map_prod post post ` set ps \\<subset> map_prod post post ` set (snd (hd ws) # ps)\""], ["proof (prove)\nusing this:\n  distinct (map (map_prod post post) (map snd ws @ ps))\n\ngoal (1 subgoal):\n 1. map_prod post post ` set ps\n    \\<subset> map_prod post post ` set (snd (hd ws) # ps)", "using \\<open>test_invariant st\\<close> st"], ["proof (prove)\nusing this:\n  distinct (map (map_prod post post) (map snd ws @ ps))\n  test_invariant st\n  st = (ws, ps, N)\n\ngoal (1 subgoal):\n 1. map_prod post post ` set ps\n    \\<subset> map_prod post post ` set (snd (hd ws) # ps)", "by (cases ws) (simp_all, blast)"], ["proof (state)\nthis:\n  map_prod post post ` set ps\n  \\<subset> map_prod post post ` set (snd (hd ws) # ps)\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "moreover"], ["proof (state)\nthis:\n  map_prod post post ` set ps\n  \\<subset> map_prod post post ` set (snd (hd ws) # ps)\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "have \"map_prod post post ` set ps' = map_prod post post ` set (snd (hd ws) # ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod post post ` set ps' =\n    map_prod post post ` set (snd (hd ws) # ps)", "using step_invariant"], ["proof (prove)\nusing this:\n  step_invariant (ws, ps, N) = (ws', ps', N')\n\ngoal (1 subgoal):\n 1. map_prod post post ` set ps' =\n    map_prod post post ` set (snd (hd ws) # ps)", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  map_prod post post ` set ps' = map_prod post post ` set (snd (hd ws) # ps)\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "ultimately"], ["proof (chain)\npicking this:\n  map_prod post post ` set ps\n  \\<subset> map_prod post post ` set (snd (hd ws) # ps)\n  map_prod post post ` set ps' = map_prod post post ` set (snd (hd ws) # ps)", "have \"map_prod post post ` set ps \\<subset> map_prod post post ` set ps'\""], ["proof (prove)\nusing this:\n  map_prod post post ` set ps\n  \\<subset> map_prod post post ` set (snd (hd ws) # ps)\n  map_prod post post ` set ps' = map_prod post post ` set (snd (hd ws) # ps)\n\ngoal (1 subgoal):\n 1. map_prod post post ` set ps \\<subset> map_prod post post ` set ps'", "by simp"], ["proof (state)\nthis:\n  map_prod post post ` set ps \\<subset> map_prod post post ` set ps'\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "}"], ["proof (state)\nthis:\n  map_prod post post ` set ps \\<subset> map_prod post post ` set ps'\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "ultimately"], ["proof (chain)\npicking this:\n  map_prod post post ` set ps\n  \\<subseteq> post ` Reachable r \\<times> post ` Reachable s\n  map_prod post post ` set ps'\n  \\<subseteq> post ` Reachable r \\<times> post ` Reachable s\n  map_prod post post ` set ps \\<subset> map_prod post post ` set ps'", "have \"?X ps' \\<subset> ?X ps\""], ["proof (prove)\nusing this:\n  map_prod post post ` set ps\n  \\<subseteq> post ` Reachable r \\<times> post ` Reachable s\n  map_prod post post ` set ps'\n  \\<subseteq> post ` Reachable r \\<times> post ` Reachable s\n  map_prod post post ` set ps \\<subset> map_prod post post ` set ps'\n\ngoal (1 subgoal):\n 1. post ` Reachable r \\<times> post ` Reachable s -\n    map_prod post post ` set ps'\n    \\<subset> post ` Reachable r \\<times> post ` Reachable s -\n              map_prod post post ` set ps", "by (auto simp add: image_set simp del: set_map)"], ["proof (state)\nthis:\n  post ` Reachable r \\<times> post ` Reachable s -\n  map_prod post post ` set ps'\n  \\<subset> post ` Reachable r \\<times> post ` Reachable s -\n            map_prod post post ` set ps\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "}"], ["proof (state)\nthis:\n  post ` Reachable r \\<times> post ` Reachable s -\n  map_prod post post ` set ps'\n  \\<subset> post ` Reachable r \\<times> post ` Reachable s -\n            map_prod post post ` set ps\n\ngoal (3 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> (case step_invariant sa of\n                          (ws, ps, N) \\<Rightarrow>\n                            card\n                             (post ` Reachable r \\<times>\n                              post ` Reachable s -\n                              map_prod post post ` set ps))\n                         < (case sa of\n                            (ws, ps, N) \\<Rightarrow>\n                              card\n                               (post ` Reachable r \\<times>\n                                post ` Reachable s -\n                                map_prod post post ` set ps))\n 3. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   (post ` Reachable r \\<times> post ` Reachable s -\n    map_prod post post ` set ps)\n  step_invariant (ws, ps, N) = (ws', ps', N')\n  post ` Reachable r \\<times> post ` Reachable s -\n  map_prod post post ` set ps'\n  \\<subset> post ` Reachable r \\<times> post ` Reachable s -\n            map_prod post post ` set ps", "show \"?f (step_invariant st) < ?f st\""], ["proof (prove)\nusing this:\n  finite\n   (post ` Reachable r \\<times> post ` Reachable s -\n    map_prod post post ` set ps)\n  step_invariant (ws, ps, N) = (ws', ps', N')\n  post ` Reachable r \\<times> post ` Reachable s -\n  map_prod post post ` set ps'\n  \\<subset> post ` Reachable r \\<times> post ` Reachable s -\n            map_prod post post ` set ps\n\ngoal (1 subgoal):\n 1. (case step_invariant st of\n     (ws, ps, N) \\<Rightarrow>\n       card\n        (post ` Reachable r \\<times> post ` Reachable s -\n         map_prod post post ` set ps))\n    < (case st of\n       (ws, ps, N) \\<Rightarrow>\n         card\n          (post ` Reachable r \\<times> post ` Reachable s -\n           map_prod post post ` set ps))", "unfolding st step_invariant"], ["proof (prove)\nusing this:\n  finite\n   (post ` Reachable r \\<times> post ` Reachable s -\n    map_prod post post ` set ps)\n  (ws', ps', N') = (ws', ps', N')\n  post ` Reachable r \\<times> post ` Reachable s -\n  map_prod post post ` set ps'\n  \\<subset> post ` Reachable r \\<times> post ` Reachable s -\n            map_prod post post ` set ps\n\ngoal (1 subgoal):\n 1. (case (ws', ps', N') of\n     (ws, ps, N) \\<Rightarrow>\n       card\n        (post ` Reachable r \\<times> post ` Reachable s -\n         map_prod post post ` set ps))\n    < (case (ws, ps, N) of\n       (ws, ps, N) \\<Rightarrow>\n         card\n          (post ` Reachable r \\<times> post ` Reachable s -\n           map_prod post post ` set ps))", "using psubset_card_mono[of \"?X ps\" \"?X ps'\"]"], ["proof (prove)\nusing this:\n  finite\n   (post ` Reachable r \\<times> post ` Reachable s -\n    map_prod post post ` set ps)\n  (ws', ps', N') = (ws', ps', N')\n  post ` Reachable r \\<times> post ` Reachable s -\n  map_prod post post ` set ps'\n  \\<subset> post ` Reachable r \\<times> post ` Reachable s -\n            map_prod post post ` set ps\n  \\<lbrakk>finite\n            (post ` Reachable r \\<times> post ` Reachable s -\n             map_prod post post ` set ps);\n   post ` Reachable r \\<times> post ` Reachable s -\n   map_prod post post ` set ps'\n   \\<subset> post ` Reachable r \\<times> post ` Reachable s -\n             map_prod post post ` set ps\\<rbrakk>\n  \\<Longrightarrow> card\n                     (post ` Reachable r \\<times> post ` Reachable s -\n                      map_prod post post ` set ps')\n                    < card\n                       (post ` Reachable r \\<times> post ` Reachable s -\n                        map_prod post post ` set ps)\n\ngoal (1 subgoal):\n 1. (case (ws', ps', N') of\n     (ws, ps, N) \\<Rightarrow>\n       card\n        (post ` Reachable r \\<times> post ` Reachable s -\n         map_prod post post ` set ps))\n    < (case (ws, ps, N) of\n       (ws, ps, N) \\<Rightarrow>\n         card\n          (post ` Reachable r \\<times> post ` Reachable s -\n           map_prod post post ` set ps))", "by simp"], ["proof (state)\nthis:\n  (case step_invariant st of\n   (ws, ps, N) \\<Rightarrow>\n     card\n      (post ` Reachable r \\<times> post ` Reachable s -\n       map_prod post post ` set ps))\n  < (case st of\n     (ws, ps, N) \\<Rightarrow>\n       card\n        (post ` Reachable r \\<times> post ` Reachable s -\n         map_prod post post ` set ps))\n\ngoal (2 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>invariant (init r) (init s) sa; test_invariant sa\\<rbrakk>\n       \\<Longrightarrow> invariant (init r) (init s) (step_invariant sa)\n 2. invariant (init r) (init s)\n     ([([], init r, init s)], [], {(post (init r), post (init s))})", "qed (auto simp add: invariant_start WF invariant)"], ["proof (state)\nthis:\n  \\<exists>st.\n     closure_invariant\n      ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n     Some st\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>st.\n     closure_invariant\n      ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n     Some st", "show False"], ["proof (prove)\nusing this:\n  \\<exists>st.\n     closure_invariant\n      ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n     Some st\n\ngoal (1 subgoal):\n 1. False", "using result"], ["proof (prove)\nusing this:\n  \\<exists>st.\n     closure_invariant\n      ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n     Some st\n  closure_invariant\n   ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n  None\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closure_termination:\n  assumes WF: \"wf n r\" \"wf n s\"\n  and result: \"closure ([(init r, init s)], {(post (init r), post (init s))}) = None\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using trans[OF closure_invariant_closure[of \"[([], init r, init s)]\", simplified] result]"], ["proof (prove)\nusing this:\n  map_option (\\<lambda>(ws, ps, N). (map snd ws, N))\n   (closure_invariant\n     ([([], init r, init s)], ?ps1, {(post (init r), post (init s))})) =\n  None\n\ngoal (1 subgoal):\n 1. False", "by (auto intro: closure_invariant_termination[OF WF])"], ["", "lemma closure_invariant_complete:\n  assumes eq: \"lang n r = lang n s\"\n  and WF:  \"wf n r\" \"wf n s\"\n  shows \"\\<exists>ps N. closure_invariant ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n    Some([], ps, N)\" (is \"\\<exists>_ _. closure_invariant ([([], ?r, ?s)], _) = _\" is \"\\<exists>_ _. ?cl = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ps N.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some ([], ps, N)", "proof (cases ?cl)"], ["proof (state)\ngoal (2 subgoals):\n 1. closure_invariant\n     ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n    None \\<Longrightarrow>\n    \\<exists>ps N.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some ([], ps, N)\n 2. \\<And>a.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some a \\<Longrightarrow>\n       \\<exists>ps N.\n          closure_invariant\n           ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n          Some ([], ps, N)", "case (Some st)"], ["proof (state)\nthis:\n  closure_invariant\n   ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n  Some st\n\ngoal (2 subgoals):\n 1. closure_invariant\n     ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n    None \\<Longrightarrow>\n    \\<exists>ps N.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some ([], ps, N)\n 2. \\<And>a.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some a \\<Longrightarrow>\n       \\<exists>ps N.\n          closure_invariant\n           ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n          Some ([], ps, N)", "moreover"], ["proof (state)\nthis:\n  closure_invariant\n   ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n  Some st\n\ngoal (2 subgoals):\n 1. closure_invariant\n     ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n    None \\<Longrightarrow>\n    \\<exists>ps N.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some ([], ps, N)\n 2. \\<And>a.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some a \\<Longrightarrow>\n       \\<exists>ps N.\n          closure_invariant\n           ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n          Some ([], ps, N)", "obtain ws ps N where ws_ps_N: \"st = (ws, ps, N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ws ps N.\n        st = (ws, ps, N) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases st) blast"], ["proof (state)\nthis:\n  st = (ws, ps, N)\n\ngoal (2 subgoals):\n 1. closure_invariant\n     ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n    None \\<Longrightarrow>\n    \\<exists>ps N.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some ([], ps, N)\n 2. \\<And>a.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some a \\<Longrightarrow>\n       \\<exists>ps N.\n          closure_invariant\n           ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n          Some ([], ps, N)", "ultimately"], ["proof (chain)\npicking this:\n  closure_invariant\n   ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n  Some st\n  st = (ws, ps, N)", "show ?thesis"], ["proof (prove)\nusing this:\n  closure_invariant\n   ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n  Some st\n  st = (ws, ps, N)\n\ngoal (1 subgoal):\n 1. \\<exists>ps N.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some ([], ps, N)", "proof (cases ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>closure_invariant\n              ([([], init r, init s)], [],\n               {(post (init r), post (init s))}) =\n             Some st;\n     st = (ws, ps, N); ws = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ps N.\n                         closure_invariant\n                          ([([], init r, init s)], [],\n                           {(post (init r), post (init s))}) =\n                         Some ([], ps, N)\n 2. \\<And>a list.\n       \\<lbrakk>closure_invariant\n                 ([([], init r, init s)], [],\n                  {(post (init r), post (init s))}) =\n                Some st;\n        st = (ws, ps, N); ws = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps N.\n                            closure_invariant\n                             ([([], init r, init s)], [],\n                              {(post (init r), post (init s))}) =\n                            Some ([], ps, N)", "case (Cons wrs ws)"], ["proof (state)\nthis:\n  ws__ = wrs # ws\n\ngoal (2 subgoals):\n 1. \\<lbrakk>closure_invariant\n              ([([], init r, init s)], [],\n               {(post (init r), post (init s))}) =\n             Some st;\n     st = (ws__, ps, N); ws__ = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ps N.\n                         closure_invariant\n                          ([([], init r, init s)], [],\n                           {(post (init r), post (init s))}) =\n                         Some ([], ps, N)\n 2. \\<And>a list.\n       \\<lbrakk>closure_invariant\n                 ([([], init r, init s)], [],\n                  {(post (init r), post (init s))}) =\n                Some st;\n        st = (ws__, ps, N); ws__ = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps N.\n                            closure_invariant\n                             ([([], init r, init s)], [],\n                              {(post (init r), post (init s))}) =\n                            Some ([], ps, N)", "with Some"], ["proof (chain)\npicking this:\n  closure_invariant\n   ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n  Some st\n  ws__ = wrs # ws", "obtain w where \"counterexample r s = Some w\""], ["proof (prove)\nusing this:\n  closure_invariant\n   ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n  Some st\n  ws__ = wrs # ws\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        counterexample r s = Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding counterexample_def"], ["proof (prove)\nusing this:\n  closure_invariant\n   ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n  Some st\n  ws__ = wrs # ws\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        (let r' = init r; s' = init s\n         in case closure_invariant\n                  ([([], r', s')], [], {(post r', post s')}) of\n            None \\<Rightarrow> None | Some ([], xc) \\<Rightarrow> None\n            | Some ((w, xa, xaa) # xb, xc) \\<Rightarrow> Some (rev w)) =\n        Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases wrs) (auto simp: ws_ps_N)"], ["proof (state)\nthis:\n  counterexample r s = Some w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>closure_invariant\n              ([([], init r, init s)], [],\n               {(post (init r), post (init s))}) =\n             Some st;\n     st = (ws__, ps, N); ws__ = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ps N.\n                         closure_invariant\n                          ([([], init r, init s)], [],\n                           {(post (init r), post (init s))}) =\n                         Some ([], ps, N)\n 2. \\<And>a list.\n       \\<lbrakk>closure_invariant\n                 ([([], init r, init s)], [],\n                  {(post (init r), post (init s))}) =\n                Some st;\n        st = (ws__, ps, N); ws__ = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps N.\n                            closure_invariant\n                             ([([], init r, init s)], [],\n                              {(post (init r), post (init s))}) =\n                            Some ([], ps, N)", "with eq counterexample_sound[OF _ WF]"], ["proof (chain)\npicking this:\n  lang n r = lang n s\n  counterexample r s = Some ?w \\<Longrightarrow>\n  (?w \\<in> lang n r) = (?w \\<notin> lang n s)\n  counterexample r s = Some w", "show ?thesis"], ["proof (prove)\nusing this:\n  lang n r = lang n s\n  counterexample r s = Some ?w \\<Longrightarrow>\n  (?w \\<in> lang n r) = (?w \\<notin> lang n s)\n  counterexample r s = Some w\n\ngoal (1 subgoal):\n 1. \\<exists>ps N.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some ([], ps, N)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ps N.\n     closure_invariant\n      ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n     Some ([], ps, N)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>closure_invariant\n              ([([], init r, init s)], [],\n               {(post (init r), post (init s))}) =\n             Some st;\n     st = (ws__, ps, N); ws__ = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ps N.\n                         closure_invariant\n                          ([([], init r, init s)], [],\n                           {(post (init r), post (init s))}) =\n                         Some ([], ps, N)", "qed blast"], ["proof (state)\nthis:\n  \\<exists>ps N.\n     closure_invariant\n      ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n     Some ([], ps, N)\n\ngoal (1 subgoal):\n 1. closure_invariant\n     ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n    None \\<Longrightarrow>\n    \\<exists>ps N.\n       closure_invariant\n        ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n       Some ([], ps, N)", "qed (auto intro: closure_invariant_termination[OF WF])"], ["", "lemma closure_complete:\n  assumes \"lang n r = lang n s\" \"wf n r\" \"wf n s\"\n  shows \"\\<exists>N. closure ([(init r, init s)], {(post (init r), post (init s))}) = Some ([], N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       closure ([(init r, init s)], {(post (init r), post (init s))}) =\n       Some ([], N)", "using closure_invariant_complete[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>ps N.\n     closure_invariant\n      ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n     Some ([], ps, N)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       closure ([(init r, init s)], {(post (init r), post (init s))}) =\n       Some ([], N)", "by (subst closure_invariant_closure[of \"[([], init r, init s)]\", simplified, symmetric]) auto"], ["", "lemma check_eqv_complete:\n  assumes \"lang n r = lang n s\" \"wf n r\" \"wf n s\"\n  shows \"check_eqv r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_eqv r s", "using closure_complete[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     closure ([(init r, init s)], {(post (init r), post (init s))}) =\n     Some ([], N)\n\ngoal (1 subgoal):\n 1. check_eqv r s", "by (auto simp: check_eqv_def)"], ["", "lemma counterexample_complete:\n  assumes \"lang n r \\<noteq> lang n s\" and WF: \"wf n r\" \"wf n s\"\n  shows \"\\<exists>w. counterexample r s = Some w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. counterexample r s = Some w", "using closure_invariant_sound[OF _ WF] closure_invariant_termination[OF WF] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>closure_invariant\n            ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n           Some (?ws, ?ps, ?N);\n   ?ws = []\\<rbrakk>\n  \\<Longrightarrow> lang n r = lang n s\n  closure_invariant\n   ([([], init r, init s)], [], {(post (init r), post (init s))}) =\n  None \\<Longrightarrow>\n  False\n  lang n r \\<noteq> lang n s\n  local.wf n r\n  local.wf n s\n\ngoal (1 subgoal):\n 1. \\<exists>w. counterexample r s = Some w", "by (fastforce simp: counterexample_def Let_def split: option.splits list.splits)"], ["", "end"], ["", "locale rexp_DA_no_post = rexp_DA \\<sigma> wf_atom project lookup init delta final wf_state id L n\n  for \\<sigma> :: \"nat \\<Rightarrow> 'a list\"\n  and wf_atom :: \"nat \\<Rightarrow> 'b :: linorder \\<Rightarrow> bool\"\n  and project :: \"'a \\<Rightarrow> 'a\"\n  and lookup :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and init :: \"'b rexp \\<Rightarrow> 's\"\n  and delta :: \"'a \\<Rightarrow> 's \\<Rightarrow> 's\"\n  and final :: \"'s \\<Rightarrow> bool\"\n  and wf_state :: \"'s \\<Rightarrow> bool\"\n  and L :: \"'s \\<Rightarrow> 'a lang\"\n  and n :: nat\nbegin"], ["", "lemma step_efficient[code]: \"step (ws, N) =\n  (let\n    (r, s) = hd ws;\n    new = remdups (filter (\\<lambda>(r,s). (r,s) \\<notin> N) (map (\\<lambda>a. (delta a r, delta a s)) (\\<sigma> n)))\n  in (tl ws @ new, set new \\<union> N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (ws, N) =\n    (let (r, s) = hd ws;\n         new =\n           remdups\n            (filter (\\<lambda>(r, s). (r, s) \\<notin> N)\n              (map (\\<lambda>a. (delta a r, delta a s)) (\\<sigma> n)))\n     in (tl ws @ new, set new \\<union> N))", "by (force simp: Let_def map_apfst_remdups' filter_map o_def split: prod.splits)"], ["", "end"], ["", "locale rexp_DFA_no_post = rexp_DFA \\<sigma> wf_atom project lookup init delta final wf_state id L\n  for \\<sigma> :: \"nat \\<Rightarrow> 'a list\"\n  and wf_atom :: \"nat \\<Rightarrow> 'b :: linorder \\<Rightarrow> bool\"\n  and project :: \"'a \\<Rightarrow> 'a\"\n  and lookup :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and init :: \"'b rexp \\<Rightarrow> 's\"\n  and delta :: \"'a \\<Rightarrow> 's \\<Rightarrow> 's\"\n  and final :: \"'s \\<Rightarrow> bool\"\n  and wf_state :: \"'s \\<Rightarrow> bool\"\n  and L :: \"'s \\<Rightarrow> 'a lang\"\nbegin"], ["", "sublocale rexp_DA_no_post"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DA_no_post \\<sigma> wf_atom project lookup init delta final\n     wf_state L n", "by unfold_locales"], ["", "end"], ["", "locale rexp_DA_sim = project \"set o \\<sigma>\" wf_atom project lookup\n  for \\<sigma> :: \"nat \\<Rightarrow> 'a list\"\n  and wf_atom :: \"nat \\<Rightarrow> 'b :: linorder \\<Rightarrow> bool\"\n  and project :: \"'a \\<Rightarrow> 'a\"\n  and lookup :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\" +\n  fixes init :: \"'b rexp \\<Rightarrow> 's\"\n  fixes sim_delta :: \"'s \\<Rightarrow> 's list\"\n  fixes final :: \"'s \\<Rightarrow> bool\"\n  fixes wf_state :: \"'s \\<Rightarrow> bool\"\n  fixes L :: \"'s \\<Rightarrow> 'a lang\"\n  fixes post :: \"'s \\<Rightarrow> 's\"\n  fixes n :: nat\n  assumes L_init[simp]: \"wf n r \\<Longrightarrow> L (init r) = lang n r\"\n  assumes final_iff_Nil[simp]: \"final s \\<longleftrightarrow> [] \\<in> L s\"\n  assumes L_wf_state[dest]: \"wf_state s \\<Longrightarrow> L s \\<subseteq> lists (set (\\<sigma> n))\"\n  assumes init_wf_state[simp]: \"wf n r \\<Longrightarrow> wf_state (init r)\"\n  assumes L_post[simp]: \"wf_state s \\<Longrightarrow> L (post s) = L s\"\n  assumes wf_state_post[simp]: \"wf_state s \\<Longrightarrow> wf_state (post s)\"\n  assumes L_sim_delta[simp]: \"wf_state s \\<Longrightarrow> map L (sim_delta s) = map (\\<lambda>a. lQuot a (L s)) (\\<sigma> n)\"\n  assumes sim_delta_wf_state[simp]: \"wf_state s \\<Longrightarrow> \\<forall>s' \\<in> set (sim_delta s). wf_state s'\"\nbegin"], ["", "definition \"delta a s = sim_delta s ! index (\\<sigma> n) a\""], ["", "lemma length_sim_delta[simp]: \"wf_state s \\<Longrightarrow> length (sim_delta s) = length (\\<sigma> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_state s \\<Longrightarrow> length (sim_delta s) = length (\\<sigma> n)", "by (metis L_sim_delta length_map)"], ["", "lemma L_delta[simp]: \"\\<lbrakk>a \\<in> set (\\<sigma> n); wf_state s\\<rbrakk> \\<Longrightarrow> L (delta a s) = lQuot a (L s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set (\\<sigma> n); wf_state s\\<rbrakk>\n    \\<Longrightarrow> L (delta a s) = lQuot a (L s)", "using L_sim_delta[of s]"], ["proof (prove)\nusing this:\n  wf_state s \\<Longrightarrow>\n  map L (sim_delta s) = map (\\<lambda>a. lQuot a (L s)) (\\<sigma> n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set (\\<sigma> n); wf_state s\\<rbrakk>\n    \\<Longrightarrow> L (delta a s) = lQuot a (L s)", "unfolding delta_def in_set_conv_nth"], ["proof (prove)\nusing this:\n  wf_state s \\<Longrightarrow>\n  map L (sim_delta s) = map (\\<lambda>a. lQuot a (L s)) (\\<sigma> n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>i<length (\\<sigma> n). \\<sigma> n ! i = a;\n     wf_state s\\<rbrakk>\n    \\<Longrightarrow> L (sim_delta s ! index (\\<sigma> n) a) = lQuot a (L s)", "by (subst (asm) list_eq_iff_nth_eq) auto"], ["", "lemma delta_wf_state[simp]: \"\\<lbrakk>a \\<in> set (\\<sigma> n); wf_state s\\<rbrakk> \\<Longrightarrow> wf_state (delta a s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set (\\<sigma> n); wf_state s\\<rbrakk>\n    \\<Longrightarrow> wf_state (delta a s)", "unfolding delta_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set (\\<sigma> n); wf_state s\\<rbrakk>\n    \\<Longrightarrow> wf_state (sim_delta s ! index (\\<sigma> n) a)", "by (auto intro: bspec[OF sim_delta_wf_state nth_mem])"], ["", "sublocale rexp_DA \\<sigma> wf_atom project lookup init delta final wf_state post L"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DA \\<sigma> wf_atom project lookup init delta final wf_state post L\n     n", "by unfold_locales auto"], ["", "sublocale rexp_DA_sim_no_post: rexp_DA_no_post \\<sigma> wf_atom project lookup init delta final wf_state L"], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DA_no_post \\<sigma> wf_atom project lookup init delta final\n     wf_state L n", "by unfold_locales auto"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}