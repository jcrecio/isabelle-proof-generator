{"file_name": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence/M2L_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence", "problem_names": ["lemma \"Thm TYPE(Enum.finite_1) 0 M2L\"", "lemma \"Thm TYPE(Enum.finite_1) 0 (FNot (All (FExists (FLess 1 0))))\"", "lemma \"Thm (TYPE(bool)) 0 (FNot (FExists (FExists (FAnd (FLess 0 1) (FLess 1 0)))))\"", "lemma Drinker: \"Thm (TYPE(bool)) 1 (FExists (Imp (FIn 0 1) (All (FIn 0 2))))\"", "lemma \"Thm (TYPE(bool)) 1 (Imp (All (FIn 0 1)) (FExists (FIn 0 1)))\"", "lemma \"Thm1 0\"", "lemma \"Thm1 1\"", "lemma \"Thm1 2\"", "lemma \"Thm (TYPE(bool)) 0 \\<Phi>0\"", "lemma \"Thm (TYPE(bool * bool)) 0 \\<Phi>1\"", "lemma \"Thm (TYPE(bool * bool * bool)) 0 \\<Phi>2\""], "translations": [["", "lemma \"Thm TYPE(Enum.finite_1) 0 M2L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm TYPE(Enum.finite_1) 0 M2L", "by eval"], ["", "lemma \"Thm TYPE(Enum.finite_1) 0 (FNot (All (FExists (FLess 1 0))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm TYPE(Enum.finite_1) 0\n     (FNot (M2L_Examples.All (FExists (FLess 1 0))))", "by eval"], ["", "lemma \"Thm (TYPE(bool)) 0 (FNot (FExists (FExists (FAnd (FLess 0 1) (FLess 1 0)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm TYPE(bool) 0\n     (FNot (FExists (FExists (FAnd (FLess 0 1) (FLess 1 0)))))", "by eval"], ["", "lemma Drinker: \"Thm (TYPE(bool)) 1 (FExists (Imp (FIn 0 1) (All (FIn 0 2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm TYPE(bool) 1 (FExists (Imp (FIn 0 1) (M2L_Examples.All (FIn 0 2))))", "by eval"], ["", "lemma \"Thm (TYPE(bool)) 1 (Imp (All (FIn 0 1)) (FExists (FIn 0 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm TYPE(bool) 1 (Imp (M2L_Examples.All (FIn 0 1)) (FExists (FIn 0 1)))", "by eval"], ["", "(*\ndefinition \"mod_two a b c d = Iff a (Iff b (Iff c d))\"\ndefinition \"at_least_two a b c d = Iff d (FOr (FAnd a b) (FOr (FAnd b c) (FAnd a c)))\"\n\ndefinition \"ADD S A B = FEXISTS (FAnd (All (Imp (First 0) (FNot (FIn 0 1))))\n  (All (FAnd (mod_two (FIn 0 (A+2)) (FIn 0 (B+2)) (FIn 0 1) (FIn 0 (S+2)))\n       (Imp (FExists (FAnd (Last 0) (FLess 1 0)))\n            (at_least_two (FIn 0 (A+2)) (FIn 0 (B+2)) (FIn 0 1) (All (Imp (Suc 0 1) (FIn 0 2))))))))\"\n\ndefinition Comm_Lemma :: \"Enum.finite_1 formula\" where\n  \"Comm_Lemma = AL (AL (FEXISTS (FAnd (ADD 0 1 2) (FEXISTS (FAnd (ADD 0 3 2) (EQ 0 1))))))\"\n\nlemma \"Thm TYPE(bool) 0 (AL (AL (FEXISTS (ADD 0 1 2))))\"\n  by eval\n\nlemma \"Thm TYPE(Enum.finite_1) 0 Comm_Lemma\"\n  by eval\n*)"], ["", "abbreviation Globally (\"\\<box>_\" [40] 40) where \"Globally P == %n. All (Imp (FNot (FLess (n+1) 0)) (P 0))\""], ["", "abbreviation Future (\"\\<diamond>_\" [40] 40) where \"Future P == %n. FExists (FAnd (FNot (FLess (n+1) 0)) (P 0))\""], ["", "abbreviation IMP (infixr \"\\<rightarrow>\" 50) where \"IMP P1 P2 == %n. Imp (P1 n) (P2 n)\""], ["", "abbreviation \"FOR xs n \\<equiv> rexp_of_list FOr FALSE (map (\\<lambda>x. FQ x n) xs)\""], ["", "abbreviation \\<Phi>0 :: \"bool formula\" where \"\\<Phi>0 \\<equiv>\n  (All (((\\<box>(FOR [(True)])) \\<rightarrow> (\\<box>(FOR [(True)]))) 0))\""], ["", "abbreviation \\<Phi>1 :: \"(bool \\<times> bool) formula\" where \"\\<Phi>1 \\<equiv>\n  (All (((\\<box>(FOR [(True, True), (True, False)] \\<rightarrow>\n            FOR [(True, True), (False, True)])) \\<rightarrow>\n         (\\<box>(FOR [(True, True), (True, False)])) \\<rightarrow>\n         (\\<box>(FOR [(True, True), (False, True)]))) 0))\""], ["", "abbreviation \\<Phi>2 :: \"(bool \\<times> bool \\<times> bool) formula\" where \"\\<Phi>2 \\<equiv> \n  (All (((\\<box>(FOR [(True, True, True), (True, True, False), (True, False, True), (True, False, False)] \\<rightarrow>\n            FOR [(True, True, True), (True, True, False), (False, True, True), (False, True, False)] \\<rightarrow>\n            FOR [(True, True, True), (True, False, True), (False, True, True), (False, False, True)])) \\<rightarrow>\n        (\\<box>(FOR [(True, True, True), (True, True, False), (True, False, True), (True, False, False)])) \\<rightarrow>\n        (\\<box>(FOR [(True, True, True), (True, True, False), (False, True, True), (False, True, False)])) \\<rightarrow>\n        (\\<box>(FOR [(True, True, True), (True, True, False), (False, True, True), (False, True, False)]))) 0))\""], ["", "definition \\<Psi> :: \"nat \\<Rightarrow> Enum.finite_1 formula\" where\n  \"\\<Psi> n = All (((\\<box>(foldr (\\<lambda>i \\<phi>. (\\<lambda>m. FIn m (2 + i)) \\<rightarrow> \\<phi>) [0..<n] (\\<lambda>m. FIn m (n + 2)))) \\<rightarrow>\n     foldr (\\<lambda>i \\<phi>. (\\<box>(\\<lambda>m. FIn m (2 + i))) \\<rightarrow> \\<phi>) [0..<n] (\\<box>(\\<lambda>m. FIn m (n + 2)))) 0)\""], ["", "definition \"Thm1 n = Thm (TYPE(Enum.finite_1)) (n + 1) (\\<Psi> n)\""], ["", "definition \"Thm1_slow n = Thm_slow (TYPE(Enum.finite_1)) (n + 1) (\\<Psi> n)\""], ["", "definition \"Thm1_dual n = Thm_dual (TYPE(Enum.finite_1)) (n + 1) (\\<Psi> n)\""], ["", "lemma \"Thm1 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm1 0", "by eval"], ["", "lemma \"Thm1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm1 1", "by eval"], ["", "lemma \"Thm1 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm1 2", "by eval"], ["", "lemma \"Thm (TYPE(bool)) 0 \\<Phi>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm TYPE(bool) 0 \\<Phi>0", "by eval"], ["", "lemma \"Thm (TYPE(bool * bool)) 0 \\<Phi>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm TYPE(bool \\<times> bool) 0 \\<Phi>1", "by eval"], ["", "lemma \"Thm (TYPE(bool * bool * bool)) 0 \\<Phi>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Thm TYPE(bool \\<times> bool \\<times> bool) 0 \\<Phi>2", "by eval"], ["", "(*\nexport_code Thm1 Nat in SML module_name M2L_Thm1 file \"M2L_Thm1.ML\"\nexport_code Thm1_slow Nat in SML module_name M2L_Thm1_slow file \"M2L_Thm1_slow.ML\"\nexport_code Thm1_dual Nat in SML module_name M2L_Thm1_dual file \"M2L_Thm1_dual.ML\"\n\nML_file \"M2L_Thm1.ML\"\nML_file \"M2L_Thm1_slow.ML\"\nML_file \"M2L_Thm1_dual.ML\"\n\nML {* PolyML.timing true; open M2L_Thm1; thm1 (Nat 0); thm1 (Nat 1); thm1 (Nat 2); thm1 (Nat 3); *}\nML {* PolyML.timing true; open M2L_Thm1_dual; thm1_dual (Nat 0); thm1_dual (Nat 1); thm1_dual (Nat 2); thm1_dual (Nat 3); *}\nML {* PolyML.timing true; open M2L_Thm1_slow; thm1_slow (Nat 0); thm1_slow (Nat 1); thm1_slow (Nat 2); *}\n*)"], ["", "end"]]}