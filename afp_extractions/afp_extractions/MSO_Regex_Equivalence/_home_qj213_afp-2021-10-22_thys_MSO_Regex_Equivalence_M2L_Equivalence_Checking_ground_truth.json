{"file_name": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence/M2L_Equivalence_Checking.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence", "problem_names": ["lemma enum_not_empty[simp]: \"Enum.enum \\<noteq> []\" (is \"?enum \\<noteq> []\")", "lemma lang_Plus_Zero: \"lang \\<Sigma> n (Plus r One) = lang \\<Sigma> n (Plus s One) \\<longleftrightarrow> lang \\<Sigma> n r - {[]} = lang \\<Sigma> n s - {[]}\"", "lemmas lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_norm] \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of]", "lemmas lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of'_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_norm] \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of']", "lemmas lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of''_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_norm] \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of'']", "lemma soundness: \"slow.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> = \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>\"", "lemma completeness:\n  assumes \"\\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> = \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>\" \"wf_formula n (FOr \\<phi> \\<psi>)\"\n  shows \"slow.check_eqv n \\<phi> \\<psi>\"", "lemma soundness: \"fast.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> = \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>\"", "lemma soundness: \"dual.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> = \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>\""], "translations": [["", "lemma enum_not_empty[simp]: \"Enum.enum \\<noteq> []\" (is \"?enum \\<noteq> []\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_class.enum \\<noteq> []", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. enum_class.enum = [] \\<Longrightarrow> False", "assume \"?enum = []\""], ["proof (state)\nthis:\n  enum_class.enum = []\n\ngoal (1 subgoal):\n 1. enum_class.enum = [] \\<Longrightarrow> False", "hence \"set ?enum = {}\""], ["proof (prove)\nusing this:\n  enum_class.enum = []\n\ngoal (1 subgoal):\n 1. set enum_class.enum = {}", "by simp"], ["proof (state)\nthis:\n  set enum_class.enum = {}\n\ngoal (1 subgoal):\n 1. enum_class.enum = [] \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  set enum_class.enum = {}\n\ngoal (1 subgoal):\n 1. False", "unfolding UNIV_enum[symmetric]"], ["proof (prove)\nusing this:\n  UNIV = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "global_interpretation \\<Phi>: formula \"Enum.enum :: 'a :: {enum, linorder} list\"\n  defines\n      pre_wf_formula = \\<Phi>.pre_wf_formula\n  and wf_formula = \\<Phi>.wf_formula\n  and rexp_of = \\<Phi>.rexp_of\n  and rexp_of_alt = \\<Phi>.rexp_of_alt\n  and rexp_of_alt' = \\<Phi>.rexp_of_alt'\n  and rexp_of' = \\<Phi>.rexp_of'\n  and rexp_of'' = \\<Phi>.rexp_of''\n  and valid_ENC = \\<Phi>.valid_ENC\n  and ENC = \\<Phi>.ENC\n  and dec_interp = \\<Phi>.dec_interp"], ["proof (prove)\ngoal (1 subgoal):\n 1. formula enum_class.enum", "by unfold_locales (auto simp: \\<sigma>_def \\<pi>_def set_n_lists)"], ["", "lemma lang_Plus_Zero: \"lang \\<Sigma> n (Plus r One) = lang \\<Sigma> n (Plus s One) \\<longleftrightarrow> lang \\<Sigma> n r - {[]} = lang \\<Sigma> n s - {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lang \\<Sigma> n (Plus r One) = lang \\<Sigma> n (Plus s One)) =\n    (lang \\<Sigma> n r - {[]} = lang \\<Sigma> n s - {[]})", "by auto"], ["", "lemmas lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_norm] \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of]"], ["", "lemmas lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of'_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_norm] \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of']"], ["", "lemmas lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of''_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_norm] \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of'']"], ["", "setup \\<open>Sign.map_naming (Name_Space.mandatory_path \"slow\")\\<close>"], ["", "global_interpretation D: rexp_DFA \"\\<sigma> \\<Sigma>\" \"wf_atom \\<Sigma>\" \\<pi> lookup \"\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>\"\n  \"\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>\" final \"alphabet.wf (wf_atom \\<Sigma>) n\" pnorm \"lang \\<Sigma> n\" n\n  for \\<Sigma> :: \"'a :: linorder list\" and n :: nat\n  defines\n      test = \"rexp_DA.test (final :: 'a atom rexp \\<Rightarrow> bool)\"\n  and step = \"rexp_DA.step (\\<sigma> \\<Sigma>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) pnorm n\"\n  and closure = \"rexp_DA.closure (\\<sigma> \\<Sigma>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) final pnorm n\"\n  and check_eqvRE = \"rexp_DA.check_eqv (\\<sigma> \\<Sigma>) (\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) final pnorm n\"\n  and test_invariant = \"rexp_DA.test_invariant (final :: 'a atom rexp \\<Rightarrow> bool) ::\n    (('a \\<times> bool list) list \\<times> _) list \\<times> _ \\<Rightarrow> bool\"\n  and step_invariant = \"rexp_DA.step_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) pnorm n\"\n  and closure_invariant = \"rexp_DA.closure_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) final pnorm n\"\n  and counterexampleRE = \"rexp_DA.counterexample (\\<sigma> \\<Sigma>) (\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) final pnorm n\"\n  and reachable = \"rexp_DA.reachable (\\<sigma> \\<Sigma>) (\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) pnorm n\"\n  and automaton = \"rexp_DA.automaton (\\<sigma> \\<Sigma>) (\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) pnorm n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA (\\<sigma> \\<Sigma>) (wf_atom \\<Sigma>) \\<pi> lookup\n     (\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>)\n     (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>)\n     final (M2L_Equivalence_Checking.wf \\<Sigma> n) pnorm (lang \\<Sigma> n)\n     n", "by unfold_locales (auto simp only: comp_apply\n    ACI_norm_wf ACI_norm_lang wf_inorm lang_inorm wf_pnorm lang_pnorm wf_lderiv lang_lderiv\n    lang_final finite_fold_lderiv dest!: lang_subset_lists)"], ["", "definition check_eqv where\n\"check_eqv n \\<phi> \\<psi> \\<longleftrightarrow> wf_formula n (FOr \\<phi> \\<psi>) \\<and>\n   slow.check_eqvRE Enum.enum n (Plus (rexp_of'' n (norm \\<phi>)) One) (Plus (rexp_of'' n (norm \\<psi>)) One)\""], ["", "definition counterexample where\n\"counterexample n \\<phi> \\<psi> =\n   map_option (\\<lambda>w. dec_interp n (FOV (FOr \\<phi> \\<psi>)) w)\n   (slow.counterexampleRE Enum.enum n (Plus (rexp_of'' n (norm \\<phi>)) One) (Plus (rexp_of'' n (norm \\<psi>)) One))\""], ["", "lemma soundness: \"slow.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> = \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slow.check_eqv n \\<phi> \\<psi> \\<Longrightarrow>\n    \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> =\n    \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>", "by (rule box_equals[OF iffD1[OF lang_Plus_Zero, OF slow.D.check_eqv_sound]\n  sym[OF trans[OF lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of''_norm]] sym[OF trans[OF lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of''_norm]]])\n   (auto simp: slow.check_eqv_def intro!: \\<Phi>.wf_rexp_of'')"], ["", "lemma completeness:\n  assumes \"\\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> = \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>\" \"wf_formula n (FOr \\<phi> \\<psi>)\"\n  shows \"slow.check_eqv n \\<phi> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slow.check_eqv n \\<phi> \\<psi>", "using assms(2)"], ["proof (prove)\nusing this:\n  wf_formula n (FOr \\<phi> \\<psi>)\n\ngoal (1 subgoal):\n 1. slow.check_eqv n \\<phi> \\<psi>", "unfolding slow.check_eqv_def"], ["proof (prove)\nusing this:\n  wf_formula n (FOr \\<phi> \\<psi>)\n\ngoal (1 subgoal):\n 1. wf_formula n (FOr \\<phi> \\<psi>) \\<and>\n    slow.check_eqvRE enum_class.enum n\n     (Plus (rexp_of'' n (norm \\<phi>)) One)\n     (Plus (rexp_of'' n (norm \\<psi>)) One)", "by (intro conjI[OF assms(2) slow.D.check_eqv_complete[OF iffD2[OF lang_Plus_Zero]],\n                OF box_equals[OF assms(1) lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of''_norm lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of''_norm]])\n   (auto intro!: \\<Phi>.wf_rexp_of'')"], ["", "setup \\<open>Sign.map_naming Name_Space.parent_path\\<close>"], ["", "setup \\<open>Sign.map_naming (Name_Space.mandatory_path \"fast\")\\<close>"], ["", "global_interpretation D: rexp_DA_no_post \"\\<sigma> \\<Sigma>\" \"wf_atom \\<Sigma>\" \\<pi> lookup \"\\<lambda>x. pnorm (inorm x)\"\n  \"\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)\" final \"alphabet.wf (wf_atom \\<Sigma>) n\" \"lang \\<Sigma> n\" n\n  for \\<Sigma> :: \"'a :: linorder list\" and n :: nat\n  defines\n      test = \"rexp_DA.test (final :: 'a atom rexp \\<Rightarrow> bool)\"\n  and step = \"rexp_DA.step (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) id n\"\n  and closure = \"rexp_DA.closure (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) final id n\"\n  and check_eqvRE = \"rexp_DA.check_eqv (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm (inorm x)) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) final id n\"\n  and test_invariant = \"rexp_DA.test_invariant (final :: 'a atom rexp \\<Rightarrow> bool) ::\n    (('a \\<times> bool list) list \\<times> _) list \\<times> _ \\<Rightarrow> bool\"\n  and step_invariant = \"rexp_DA.step_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) id n\"\n  and closure_invariant = \"rexp_DA.closure_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) final id n\"\n  and counterexampleRE = \"rexp_DA.counterexample (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm (inorm x)) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) final id n\"\n  and reachable = \"rexp_DA.reachable (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm (inorm x)) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) id n\"\n  and automaton = \"rexp_DA.automaton (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm (inorm x)) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) id n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DA_no_post (\\<sigma> \\<Sigma>) (wf_atom \\<Sigma>) \\<pi> lookup\n     (\\<lambda>x. pnorm (inorm x))\n     (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) final\n     (M2L_Equivalence_Checking.wf \\<Sigma> n) (lang \\<Sigma> n) n", "by unfold_locales (auto simp only: comp_apply\n    ACI_norm_wf ACI_norm_lang wf_inorm lang_inorm wf_pnorm lang_pnorm wf_lderiv lang_lderiv id_apply\n    lang_final dest!: lang_subset_lists)"], ["", "definition check_eqv where\n\"check_eqv n \\<phi> \\<psi> \\<longleftrightarrow> wf_formula n (FOr \\<phi> \\<psi>) \\<and>\n   fast.check_eqvRE Enum.enum n (Plus (rexp_of'' n (norm \\<phi>)) One) (Plus (rexp_of'' n (norm \\<psi>)) One)\""], ["", "definition counterexample where\n\"counterexample n \\<phi> \\<psi> =\n   map_option (\\<lambda>w. dec_interp n (FOV (FOr \\<phi> \\<psi>)) w)\n   (fast.counterexampleRE Enum.enum n (Plus (rexp_of'' n (norm \\<phi>)) One) (Plus (rexp_of'' n (norm \\<psi>)) One))\""], ["", "lemma soundness: \"fast.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> = \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast.check_eqv n \\<phi> \\<psi> \\<Longrightarrow>\n    \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> =\n    \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>", "by (rule box_equals[OF iffD1[OF lang_Plus_Zero, OF fast.D.check_eqv_sound]\n  sym[OF trans[OF lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of''_norm]] sym[OF trans[OF lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of''_norm]]])\n   (auto simp: fast.check_eqv_def intro!: \\<Phi>.wf_rexp_of'')"], ["", "setup \\<open>Sign.map_naming Name_Space.parent_path\\<close>"], ["", "setup \\<open>Sign.map_naming (Name_Space.mandatory_path \"dual\")\\<close>"], ["", "global_interpretation D: rexp_DA_no_post \"\\<sigma> \\<Sigma>\" \"wf_atom \\<Sigma>\" \\<pi> lookup\n  \"\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x))\" \"\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)\" final_dual\n  \"alphabet.wf_dual (wf_atom \\<Sigma>) n\" \"lang_dual \\<Sigma> n\" n\n  for \\<Sigma> :: \"'a :: linorder list\" and n :: nat\n  defines\n      test = \"rexp_DA.test (final_dual :: 'a atom rexp_dual \\<Rightarrow> bool)\"\n  and step = \"rexp_DA.step (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) id n\"\n  and closure = \"rexp_DA.closure (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) final_dual id n\"\n  and check_eqvRE = \"rexp_DA.check_eqv (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x))) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) final_dual id n\"\n  and test_invariant = \"rexp_DA.test_invariant (final_dual :: 'a atom rexp_dual \\<Rightarrow> bool) ::\n    (('a \\<times> bool list) list \\<times> _) list \\<times> _ \\<Rightarrow> bool\"\n  and step_invariant = \"rexp_DA.step_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) id n\"\n  and closure_invariant = \"rexp_DA.closure_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) final_dual id n\"\n  and counterexampleRE = \"rexp_DA.counterexample (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x))) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) final_dual id n\"\n  and reachable = \"rexp_DA.reachable (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x))) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) id n\"\n  and automaton = \"rexp_DA.automaton (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x))) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) id n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DA_no_post (\\<sigma> \\<Sigma>) (wf_atom \\<Sigma>) \\<pi> lookup\n     (\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x)))\n     (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) final_dual\n     (wf_dual \\<Sigma> n) (lang_dual \\<Sigma> n) n", "by unfold_locales (auto simp only: comp_apply id_apply\n    wf_inorm lang_inorm\n    wf_dual_pnorm_dual lang_dual_pnorm_dual\n    wf_dual_rexp_dual_of lang_dual_rexp_dual_of\n    wf_dual_lderiv_dual lang_dual_lderiv_dual\n    lang_dual_final_dual dest!: lang_dual_subset_lists)"], ["", "definition check_eqv where\n\"check_eqv n \\<phi> \\<psi> \\<longleftrightarrow> wf_formula n (FOr \\<phi> \\<psi>) \\<and>\n   dual.check_eqvRE Enum.enum n (Plus (rexp_of'' n (norm \\<phi>)) One) (Plus (rexp_of'' n (norm \\<psi>)) One)\""], ["", "definition counterexample where\n\"counterexample n \\<phi> \\<psi> =\n   map_option (\\<lambda>w. dec_interp n (FOV (FOr \\<phi> \\<psi>)) w)\n   (dual.counterexampleRE Enum.enum n (Plus (rexp_of'' n (norm \\<phi>)) One) (Plus (rexp_of'' n (norm \\<psi>)) One))\""], ["", "lemma soundness: \"dual.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> = \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual.check_eqv n \\<phi> \\<psi> \\<Longrightarrow>\n    \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<phi> =\n    \\<Phi>.lang\\<^sub>M\\<^sub>2\\<^sub>L n \\<psi>", "by (rule box_equals[OF iffD1[OF lang_Plus_Zero, OF dual.D.check_eqv_sound]\n  sym[OF trans[OF lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of''_norm]] sym[OF trans[OF lang\\<^sub>M\\<^sub>2\\<^sub>L_rexp_of''_norm]]])\n   (auto simp: dual.check_eqv_def intro!: \\<Phi>.wf_rexp_of'')"], ["", "setup \\<open>Sign.map_naming Name_Space.parent_path\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}