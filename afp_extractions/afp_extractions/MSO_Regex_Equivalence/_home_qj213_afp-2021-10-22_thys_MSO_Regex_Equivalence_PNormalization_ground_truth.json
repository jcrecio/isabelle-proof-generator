{"file_name": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence/PNormalization.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence", "problem_names": ["lemma (in alphabet) wf_pnPlus[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> wf n (pnPlus r s)\"", "lemma (in project) lang_pnPlus[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> lang n (pnPlus r s) = lang n (Plus r s)\"", "lemma (in alphabet) wf_pnTimes[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> wf n (pnTimes r s)\"", "lemma (in project) lang_pnTimes[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> lang n (pnTimes r s) = lang n (Times r s)\"", "lemma (in alphabet) wf_pnInter[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> wf n (pnInter r s)\"", "lemma (in project) lang_pnInter[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> lang n (pnInter r s) = lang n (Inter r s)\"", "lemma (in alphabet) wf_pnNot[simp]: \"wf n r \\<Longrightarrow> wf n (pnNot r)\"", "lemma (in project) lang_pnNot[simp]: \"wf n r \\<Longrightarrow> lang n (pnNot r) = lang n (Not r)\"", "lemma (in alphabet) wf_pnPr[simp]: \"wf (Suc n) r \\<Longrightarrow> wf n (pnPr r)\"", "lemma (in project) lang_pnPr[simp]: \"wf (Suc n) r \\<Longrightarrow> lang n (pnPr r) = lang n (Pr r)\"", "lemma (in alphabet) wf_pnorm[simp]: \"wf n r \\<Longrightarrow> wf n (pnorm r)\"", "lemma (in project) lang_pnorm[simp]: \"wf n r \\<Longrightarrow> lang n (pnorm r) = lang n r\""], "translations": [["", "lemma (in alphabet) wf_pnPlus[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> wf n (pnPlus r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; local.wf n s\\<rbrakk>\n    \\<Longrightarrow> local.wf n (pnPlus r s)", "by (induct r s rule: pnPlus.induct) auto"], ["", "lemma (in project) lang_pnPlus[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> lang n (pnPlus r s) = lang n (Plus r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; local.wf n s\\<rbrakk>\n    \\<Longrightarrow> lang n (pnPlus r s) = lang n (Plus r s)", "by (induct r s rule: pnPlus.induct) (auto dest!: lang_subset_lists dest: project\n      subsetD[OF star_subset_lists, unfolded in_lists_conv_set, rotated -1]\n      subsetD[OF conc_subset_lists, unfolded in_lists_conv_set, rotated -1])"], ["", "fun pnTimes :: \"'a::linorder rexp \\<Rightarrow> 'a rexp \\<Rightarrow> 'a rexp\" where\n  \"pnTimes Zero r = Zero\"\n| \"pnTimes One r = r\"\n| \"pnTimes (Plus r s) t = pnPlus (pnTimes r t) (pnTimes s t)\"\n| \"pnTimes r s = Times r s\""], ["", "lemma (in alphabet) wf_pnTimes[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> wf n (pnTimes r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; local.wf n s\\<rbrakk>\n    \\<Longrightarrow> local.wf n (pnTimes r s)", "by (induct r s rule: pnTimes.induct) auto"], ["", "lemma (in project) lang_pnTimes[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> lang n (pnTimes r s) = lang n (Times r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; local.wf n s\\<rbrakk>\n    \\<Longrightarrow> lang n (pnTimes r s) = lang n (Times r s)", "by (induct r s rule: pnTimes.induct) auto"], ["", "fun pnInter :: \"'a::linorder rexp \\<Rightarrow> 'a rexp \\<Rightarrow> 'a rexp\" where\n  \"pnInter Zero r = Zero\"\n| \"pnInter r Zero = Zero\"\n| \"pnInter Full r = r\"\n| \"pnInter r Full = r\"\n| \"pnInter (Plus r s) t = pnPlus (pnInter r t) (pnInter s t)\"\n| \"pnInter r (Plus s t) = pnPlus (pnInter r s) (pnInter r t)\"\n| \"pnInter (Inter r s) t = pnInter r (pnInter s t)\"\n| \"pnInter r (Inter s t) =\n     (if r = s then Inter s t\n     else if r \\<le> s then Inter r (Inter s t)\n     else Inter s (pnInter r t))\"\n| \"pnInter r s =\n     (if r = s then s\n      else if r \\<le> s then Inter r s\n      else Inter s r)\""], ["", "lemma (in alphabet) wf_pnInter[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> wf n (pnInter r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; local.wf n s\\<rbrakk>\n    \\<Longrightarrow> local.wf n (pnInter r s)", "by (induct r s rule: pnInter.induct) auto"], ["", "lemma (in project) lang_pnInter[simp]: \"\\<lbrakk>wf n r; wf n s\\<rbrakk> \\<Longrightarrow> lang n (pnInter r s) = lang n (Inter r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; local.wf n s\\<rbrakk>\n    \\<Longrightarrow> lang n (pnInter r s) = lang n (rexp.Inter r s)", "by (induct r s rule: pnInter.induct) (auto, auto dest!: lang_subset_lists dest: project\n      subsetD[OF star_subset_lists, unfolded in_lists_conv_set, rotated -1]\n      subsetD[OF conc_subset_lists, unfolded in_lists_conv_set, rotated -1])"], ["", "fun pnNot :: \"'a::linorder rexp \\<Rightarrow> 'a rexp\" where\n  \"pnNot (Plus r s) = pnInter (pnNot r) (pnNot s)\"\n| \"pnNot (Inter r s) = pnPlus (pnNot r) (pnNot s)\"\n| \"pnNot Full = Zero\"\n| \"pnNot Zero = Full\"\n| \"pnNot (Not r) = r\"\n| \"pnNot r = Not r\""], ["", "lemma (in alphabet) wf_pnNot[simp]: \"wf n r \\<Longrightarrow> wf n (pnNot r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (pnNot r)", "by (induct r rule: pnNot.induct) auto"], ["", "lemma (in project) lang_pnNot[simp]: \"wf n r \\<Longrightarrow> lang n (pnNot r) = lang n (Not r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> lang n (pnNot r) = lang n (rexp.Not r)", "by (induct r rule: pnNot.induct) (auto dest: lang_subset_lists)"], ["", "fun pnPr :: \"'a::linorder rexp \\<Rightarrow> 'a rexp\" where\n  \"pnPr Zero = Zero\"\n| \"pnPr One = One\"\n| \"pnPr (Plus r s) = pnPlus (pnPr r) (pnPr s)\"\n| \"pnPr r = Pr r\""], ["", "lemma (in alphabet) wf_pnPr[simp]: \"wf (Suc n) r \\<Longrightarrow> wf n (pnPr r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf (Suc n) r \\<Longrightarrow> local.wf n (pnPr r)", "by (induct r rule: pnPr.induct) auto"], ["", "lemma (in project) lang_pnPr[simp]: \"wf (Suc n) r \\<Longrightarrow> lang n (pnPr r) = lang n (Pr r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf (Suc n) r \\<Longrightarrow> lang n (pnPr r) = lang n (Pr r)", "by (induct r rule: pnPr.induct) auto"], ["", "primrec pnorm :: \"'a::linorder rexp \\<Rightarrow> 'a rexp\" where\n  \"pnorm Zero = Zero\"\n| \"pnorm Full = Full\"\n| \"pnorm One = One\"\n| \"pnorm (Atom a) = Atom a\"\n| \"pnorm (Plus r s) = pnPlus (pnorm r) (pnorm s)\"\n| \"pnorm (Times r s) = pnTimes (pnorm r) s\"\n| \"pnorm (Star r) = Star r\"\n| \"pnorm (Inter r s) = pnInter (pnorm r) (pnorm s)\"\n| \"pnorm (Not r) = pnNot (pnorm r)\"\n| \"pnorm (Pr r) = pnPr (pnorm r)\""], ["", "lemma (in alphabet) wf_pnorm[simp]: \"wf n r \\<Longrightarrow> wf n (pnorm r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (pnorm r)", "by (induct r arbitrary: n) auto"], ["", "lemma (in project) lang_pnorm[simp]: \"wf n r \\<Longrightarrow> lang n (pnorm r) = lang n r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> lang n (pnorm r) = lang n r", "by (induct r arbitrary: n) auto"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}