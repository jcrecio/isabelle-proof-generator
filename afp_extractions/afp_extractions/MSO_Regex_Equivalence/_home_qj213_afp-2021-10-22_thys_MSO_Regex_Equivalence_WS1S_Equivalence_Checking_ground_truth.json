{"file_name": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence/WS1S_Equivalence_Checking.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence", "problem_names": ["lemma enum_not_empty[simp]: \"Enum.enum \\<noteq> []\" (is \"?enum \\<noteq> []\")", "lemmas lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_norm] \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of]", "lemmas lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of'_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_norm] \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of']", "lemmas lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of''_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_norm] \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of'']", "lemma soundness: \"slow.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> = \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>\"", "lemma completeness:\n  assumes \"\\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> = \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>\" \"wf_formula n (FOr \\<phi> \\<psi>)\"\n  shows \"slow.check_eqv n \\<phi> \\<psi>\"", "lemma soundness: \"fast.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> = \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>\"", "lemma soundness: \"dual.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> = \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>\""], "translations": [["", "lemma enum_not_empty[simp]: \"Enum.enum \\<noteq> []\" (is \"?enum \\<noteq> []\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_class.enum \\<noteq> []", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. enum_class.enum = [] \\<Longrightarrow> False", "assume \"?enum = []\""], ["proof (state)\nthis:\n  enum_class.enum = []\n\ngoal (1 subgoal):\n 1. enum_class.enum = [] \\<Longrightarrow> False", "hence \"set ?enum = {}\""], ["proof (prove)\nusing this:\n  enum_class.enum = []\n\ngoal (1 subgoal):\n 1. set enum_class.enum = {}", "by simp"], ["proof (state)\nthis:\n  set enum_class.enum = {}\n\ngoal (1 subgoal):\n 1. enum_class.enum = [] \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  set enum_class.enum = {}\n\ngoal (1 subgoal):\n 1. False", "unfolding UNIV_enum[symmetric]"], ["proof (prove)\nusing this:\n  UNIV = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "global_interpretation \\<Phi>: formula \"Enum.enum :: 'a :: {enum, linorder} list\"\n  rewrites \"embed2.samequot_exec lookup (\\<epsilon> (Enum.enum :: 'a :: {enum, linorder} list)) (case_prod Singleton) = \\<QQ> Enum.enum\"\n  defines\n      pre_wf_formula = \\<Phi>.pre_wf_formula\n  and wf_formula = \\<Phi>.wf_formula\n  and rexp_of = \\<Phi>.rexp_of\n  and rexp_of_alt = \\<Phi>.rexp_of_alt\n  and rexp_of_alt' = \\<Phi>.rexp_of_alt'\n  and rexp_of' = \\<Phi>.rexp_of'\n  and rexp_of'' = \\<Phi>.rexp_of''\n  and valid_ENC = \\<Phi>.valid_ENC\n  and ENC = \\<Phi>.ENC\n  and dec_interp = \\<Phi>.stream_dec\n  and any = \\<Phi>.any"], ["proof (prove)\ngoal (1 subgoal):\n 1. formula enum_class.enum &&&\n    embed2.samequot_exec lookup (\\<epsilon> enum_class.enum)\n     (\\<lambda>(x, y). Singleton x y) =\n    \\<QQ> enum_class.enum", "by unfold_locales (auto simp: \\<sigma>_def \\<pi>_def \\<QQ>_def)"], ["", "lemmas lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_norm] \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of]"], ["", "lemmas lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of'_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_norm] \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of']"], ["", "lemmas lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of''_norm = trans[OF sym[OF \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_norm] \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of'']"], ["", "setup \\<open>Sign.map_naming (Name_Space.mandatory_path \"slow\")\\<close>"], ["", "global_interpretation D: rexp_DFA \"\\<sigma> \\<Sigma>\" \"wf_atom \\<Sigma>\" \\<pi> lookup \"\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>\"\n  \"\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>\" final \"alphabet.wf (wf_atom \\<Sigma>) n\" pnorm \"lang \\<Sigma> n\" n\n  for \\<Sigma> :: \"'a :: linorder list\" and n :: nat\n  defines\n      test = \"rexp_DA.test (final :: 'a atom rexp \\<Rightarrow> bool)\"\n  and step = \"rexp_DA.step (\\<sigma> \\<Sigma>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) pnorm n\"\n  and closure = \"rexp_DA.closure (\\<sigma> \\<Sigma>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) final pnorm n\"\n  and check_eqvRE = \"rexp_DA.check_eqv (\\<sigma> \\<Sigma>) (\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) final pnorm n\"\n  and test_invariant = \"rexp_DA.test_invariant (final :: 'a atom rexp \\<Rightarrow> bool) ::\n    (('a \\<times> bool list) list \\<times> _) list \\<times> _ \\<Rightarrow> bool\"\n  and step_invariant = \"rexp_DA.step_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) pnorm n\"\n  and closure_invariant = \"rexp_DA.closure_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) final pnorm n\"\n  and counterexampleRE = \"rexp_DA.counterexample (\\<sigma> \\<Sigma>) (\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) final pnorm n\"\n  and reachable = \"rexp_DA.reachable (\\<sigma> \\<Sigma>) (\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) pnorm n\"\n  and automaton = \"rexp_DA.automaton (\\<sigma> \\<Sigma>) (\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>) (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>) pnorm n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DFA (\\<sigma> \\<Sigma>) (wf_atom \\<Sigma>) \\<pi> lookup\n     (\\<lambda>x. \\<guillemotleft>pnorm (inorm x)\\<guillemotright>)\n     (\\<lambda>a r. \\<guillemotleft>\\<DD> \\<Sigma> a r\\<guillemotright>)\n     final (WS1S_Equivalence_Checking.wf \\<Sigma> n) pnorm (lang \\<Sigma> n)\n     n", "by unfold_locales (auto simp only: comp_apply\n    ACI_norm_wf ACI_norm_lang wf_inorm lang_inorm wf_pnorm lang_pnorm wf_lderiv lang_lderiv\n    lang_final finite_fold_lderiv dest!: lang_subset_lists)"], ["", "definition check_eqv where\n\"check_eqv n \\<phi> \\<psi> \\<longleftrightarrow> wf_formula n (FOr \\<phi> \\<psi>) \\<and>\n   slow.check_eqvRE Enum.enum n (rexp_of'' n (norm \\<phi>)) (rexp_of'' n (norm \\<psi>))\""], ["", "definition counterexample where\n\"counterexample n \\<phi> \\<psi> =\n   map_option (\\<lambda>w. dec_interp n (FOV (FOr \\<phi> \\<psi>)) (w @- sconst (any, replicate n False)))\n   (slow.counterexampleRE Enum.enum n (rexp_of'' n (norm \\<phi>)) (rexp_of'' n (norm \\<psi>)))\""], ["", "lemma soundness: \"slow.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> = \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slow.check_eqv n \\<phi> \\<psi> \\<Longrightarrow>\n    \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> =\n    \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>", "by (rule box_equals[OF slow.D.check_eqv_sound\n  sym[OF trans[OF lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of''_norm]] sym[OF trans[OF lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of''_norm]]])\n   (auto simp: slow.check_eqv_def intro!: \\<Phi>.wf_rexp_of'')"], ["", "lemma completeness:\n  assumes \"\\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> = \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>\" \"wf_formula n (FOr \\<phi> \\<psi>)\"\n  shows \"slow.check_eqv n \\<phi> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slow.check_eqv n \\<phi> \\<psi>", "using assms(2)"], ["proof (prove)\nusing this:\n  wf_formula n (FOr \\<phi> \\<psi>)\n\ngoal (1 subgoal):\n 1. slow.check_eqv n \\<phi> \\<psi>", "unfolding slow.check_eqv_def"], ["proof (prove)\nusing this:\n  wf_formula n (FOr \\<phi> \\<psi>)\n\ngoal (1 subgoal):\n 1. wf_formula n (FOr \\<phi> \\<psi>) \\<and>\n    slow.check_eqvRE enum_class.enum n (rexp_of'' n (norm \\<phi>))\n     (rexp_of'' n (norm \\<psi>))", "by (intro conjI[OF assms(2) slow.D.check_eqv_complete,\n                OF box_equals[OF assms(1) lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of''_norm lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of''_norm]])\n   (auto intro!: \\<Phi>.wf_rexp_of'')"], ["", "setup \\<open>Sign.map_naming Name_Space.parent_path\\<close>"], ["", "setup \\<open>Sign.map_naming (Name_Space.mandatory_path \"fast\")\\<close>"], ["", "global_interpretation D: rexp_DA_no_post \"\\<sigma> \\<Sigma>\" \"wf_atom \\<Sigma>\" \\<pi> lookup \"\\<lambda>x. pnorm (inorm x)\"\n  \"\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)\" final \"alphabet.wf (wf_atom \\<Sigma>) n\" \"lang \\<Sigma> n\" n\n  for \\<Sigma> :: \"'a :: linorder list\" and n :: nat\n  defines\n      test = \"rexp_DA.test (final :: 'a atom rexp \\<Rightarrow> bool)\"\n  and step = \"rexp_DA.step (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) id n\"\n  and closure = \"rexp_DA.closure (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) final id n\"\n  and check_eqvRE = \"rexp_DA.check_eqv (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm (inorm x)) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) final id n\"\n  and test_invariant = \"rexp_DA.test_invariant (final :: 'a atom rexp \\<Rightarrow> bool) ::\n    (('a \\<times> bool list) list \\<times> _) list \\<times> _ \\<Rightarrow> bool\"\n  and step_invariant = \"rexp_DA.step_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) id n\"\n  and closure_invariant = \"rexp_DA.closure_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) final id n\"\n  and counterexampleRE = \"rexp_DA.counterexample (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm (inorm x)) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) final id n\"\n  and reachable = \"rexp_DA.reachable (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm (inorm x)) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) id n\"\n  and automaton = \"rexp_DA.automaton (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm (inorm x)) (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) id n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DA_no_post (\\<sigma> \\<Sigma>) (wf_atom \\<Sigma>) \\<pi> lookup\n     (\\<lambda>x. pnorm (inorm x))\n     (\\<lambda>a r. pnorm (\\<DD> \\<Sigma> a r)) final\n     (WS1S_Equivalence_Checking.wf \\<Sigma> n) (lang \\<Sigma> n) n", "by unfold_locales (auto simp only: comp_apply\n    ACI_norm_wf ACI_norm_lang wf_inorm lang_inorm wf_pnorm lang_pnorm wf_lderiv lang_lderiv id_apply\n    lang_final dest!: lang_subset_lists)"], ["", "definition check_eqv where\n\"check_eqv n \\<phi> \\<psi> \\<longleftrightarrow> wf_formula n (FOr \\<phi> \\<psi>) \\<and>\n   fast.check_eqvRE Enum.enum n (rexp_of'' n (norm \\<phi>)) (rexp_of'' n (norm \\<psi>))\""], ["", "definition counterexample where\n\"counterexample n \\<phi> \\<psi> =\n   map_option (\\<lambda>w. dec_interp n (FOV (FOr \\<phi> \\<psi>)) (w @- sconst (any, replicate n False)))\n   (fast.counterexampleRE Enum.enum n (rexp_of'' n (norm \\<phi>)) (rexp_of'' n (norm \\<psi>)))\""], ["", "lemma soundness: \"fast.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> = \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast.check_eqv n \\<phi> \\<psi> \\<Longrightarrow>\n    \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> =\n    \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>", "by (rule box_equals[OF fast.D.check_eqv_sound\n  sym[OF trans[OF lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of''_norm]] sym[OF trans[OF lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of''_norm]]])\n   (auto simp: fast.check_eqv_def intro!: \\<Phi>.wf_rexp_of'')"], ["", "setup \\<open>Sign.map_naming Name_Space.parent_path\\<close>"], ["", "setup \\<open>Sign.map_naming (Name_Space.mandatory_path \"dual\")\\<close>"], ["", "global_interpretation D: rexp_DA_no_post \"\\<sigma> \\<Sigma>\" \"wf_atom \\<Sigma>\" \\<pi> lookup\n  \"\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x))\" \"\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)\" final_dual\n  \"alphabet.wf_dual (wf_atom \\<Sigma>) n\" \"lang_dual \\<Sigma> n\" n\n  for \\<Sigma> :: \"'a :: linorder list\" and n :: nat\n  defines\n      test = \"rexp_DA.test (final_dual :: 'a atom rexp_dual \\<Rightarrow> bool)\"\n  and step = \"rexp_DA.step (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) id n\"\n  and closure = \"rexp_DA.closure (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) final_dual id n\"\n  and check_eqvRE = \"rexp_DA.check_eqv (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x))) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) final_dual id n\"\n  and test_invariant = \"rexp_DA.test_invariant (final_dual :: 'a atom rexp_dual \\<Rightarrow> bool) ::\n    (('a \\<times> bool list) list \\<times> _) list \\<times> _ \\<Rightarrow> bool\"\n  and step_invariant = \"rexp_DA.step_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) id n\"\n  and closure_invariant = \"rexp_DA.closure_invariant (\\<sigma> \\<Sigma>) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) final_dual id n\"\n  and counterexampleRE = \"rexp_DA.counterexample (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x))) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) final_dual id n\"\n  and reachable = \"rexp_DA.reachable (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x))) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) id n\"\n  and automaton = \"rexp_DA.automaton (\\<sigma> \\<Sigma>) (\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x))) (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) id n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rexp_DA_no_post (\\<sigma> \\<Sigma>) (wf_atom \\<Sigma>) \\<pi> lookup\n     (\\<lambda>x. pnorm_dual (rexp_dual_of (inorm x)))\n     (\\<lambda>a r. pnorm_dual (Co\\<DD> \\<Sigma> a r)) final_dual\n     (wf_dual \\<Sigma> n) (lang_dual \\<Sigma> n) n", "by unfold_locales (auto simp only: comp_apply id_apply\n    wf_inorm lang_inorm\n    wf_dual_pnorm_dual lang_dual_pnorm_dual\n    wf_dual_rexp_dual_of lang_dual_rexp_dual_of\n    wf_dual_lderiv_dual lang_dual_lderiv_dual\n    lang_dual_final_dual dest!: lang_dual_subset_lists)"], ["", "definition check_eqv where\n\"check_eqv n \\<phi> \\<psi> \\<longleftrightarrow> wf_formula n (FOr \\<phi> \\<psi>) \\<and>\n   dual.check_eqvRE Enum.enum n (rexp_of'' n (norm \\<phi>)) (rexp_of'' n (norm \\<psi>))\""], ["", "definition counterexample where\n\"counterexample n \\<phi> \\<psi> =\n   map_option (\\<lambda>w. dec_interp n (FOV (FOr \\<phi> \\<psi>)) (w @- sconst (any, replicate n False)))\n   (dual.counterexampleRE Enum.enum n (rexp_of'' n (norm \\<phi>)) (rexp_of'' n (norm \\<psi>)))\""], ["", "lemma soundness: \"dual.check_eqv n \\<phi> \\<psi> \\<Longrightarrow> \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> = \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual.check_eqv n \\<phi> \\<psi> \\<Longrightarrow>\n    \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<phi> =\n    \\<Phi>.lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S n \\<psi>", "by (rule box_equals[OF dual.D.check_eqv_sound\n  sym[OF trans[OF lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of''_norm]] sym[OF trans[OF lang\\<^sub>W\\<^sub>S\\<^sub>1\\<^sub>S_rexp_of''_norm]]])\n   (auto simp: dual.check_eqv_def intro!: \\<Phi>.wf_rexp_of'')"], ["", "setup \\<open>Sign.map_naming Name_Space.parent_path\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}