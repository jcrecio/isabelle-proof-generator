{"file_name": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence/Pi_Regular_Operators.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence", "problem_names": ["lemma REV_REV[simp]: \"REV (REV r) = r\"", "lemma final_REV[simp]: \"final (REV r) = final r\"", "lemma REV_PLUS: \"REV (PLUS xs) = PLUS (map REV xs)\"", "lemma (in alphabet) wf_REV[simp]: \"wf n r \\<Longrightarrow> wf n (REV r)\"", "lemma (in project) lang_REV[simp]: \"lang n (REV r) = rev ` lang n r\"", "lemma rderivs_snoc: \"rderivs (ws @ [w]) r = rderiv w (rderivs ws r)\"", "lemma rderivs_append: \"rderivs (ws @ ws') r = rderivs ws' (rderivs ws r)\"", "lemma rderiv_lderiv: \"rderiv as r = REV (lderiv as (REV r))\"", "lemma rderivs_lderivs: \"rderivs w r = REV (lderivs w (REV r))\"", "lemma wf_rderiv[simp]: \"wf n r \\<Longrightarrow> wf n (rderiv w r)\"", "lemma wf_rderivs[simp]: \"wf n r \\<Longrightarrow> wf n (rderivs ws r)\"", "lemma lang_rderiv: \"\\<lbrakk>wf n r; as \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> lang n (rderiv as r) = rQuot as (lang n r)\"", "lemma lang_rderivs: \"\\<lbrakk>wf n r; wf_word n w\\<rbrakk> \\<Longrightarrow> lang n (rderivs w r) = rQuots w (lang n r)\"", "lemma toplevel_summands_REV[simp]: \"toplevel_summands (REV r) = REV ` toplevel_summands r\"", "lemma ACI_norm_REV: \"\\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>REV r\\<guillemotright>\"", "lemma ACI_norm_rderiv: \"\\<guillemotleft>rderiv as \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>rderiv as r\\<guillemotright>\"", "lemma ACI_norm_rderivs: \"\\<guillemotleft>rderivs w \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>rderivs w r\\<guillemotright>\"", "theorem finite_rderivs: \"finite {\\<guillemotleft>rderivs xs r\\<guillemotright> | xs . True}\"", "lemma lderiv_PLUS[simp]: \"lderiv a (PLUS xs) = PLUS (map (lderiv a) xs)\"", "lemma rderiv_PLUS[simp]: \"rderiv a (PLUS xs) = PLUS (map (rderiv a) xs)\"", "lemma lang_rderiv_lderiv: \"lang n (rderiv a (lderiv b r)) = lang n (lderiv b (rderiv a r))\"", "lemma lang_lderiv_rderiv: \"lang n (lderiv a (rderiv b r)) = lang n (rderiv b (lderiv a r))\"", "lemma lang_rderiv_lderivs[simp]: \"\\<lbrakk>wf n r; wf_word n w; a \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow>\n  lang n (rderiv a (lderivs w r)) = lang n (lderivs w (rderiv a r))\"", "lemma lang_lderiv_rderivs[simp]: \"\\<lbrakk>wf n r; wf_word n w; a \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow>\n  lang n (lderiv a (rderivs w r)) = lang n (rderivs w (lderiv a r))\"", "lemma lang_biderivs: \"\\<lbrakk>wf n r; wf_word n w1; wf_word n w2\\<rbrakk> \\<Longrightarrow>\n  lang n (biderivs w1 w2 r) = biQuots w1 w2 (lang n r)\"", "lemma wf_biderivs[simp]: \"wf n r \\<Longrightarrow> wf n (biderivs w1 w2 r)\"", "lemma ACI_norm_biderivs: \"\\<guillemotleft>biderivs w1 w2 \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>biderivs w1 w2 r\\<guillemotright>\"", "lemma \"finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> | w1 w2 . True}\"", "lemma fin_cut_same_Nil[simp]: \"fin_cut_same x [] = []\"", "lemma Least_fin_cut_same: \"(LEAST n. drop n xs = replicate (length xs - n) y) =\n  length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs))\"\n  (is \"Least ?P = ?min\")", "lemma takeWhile_takes_all: \"length xs = m \\<Longrightarrow> m \\<le> length (takeWhile P xs) \\<longleftrightarrow> Ball (set xs) P\"", "lemma fin_cut_same_Cons[simp]: \"fin_cut_same x (y # xs) =\n  (if fin_cut_same x xs = [] then if x = y then [] else [y] else y # fin_cut_same x xs)\"", "lemma fin_cut_same_singleton[simp]: \"fin_cut_same x (xs @ [x]) = fin_cut_same x xs\"", "lemma fin_cut_same_replicate[simp]: \"fin_cut_same x (xs @ replicate n x) = fin_cut_same x xs\"", "lemma fin_cut_sameE: \"fin_cut_same x xs = ys \\<Longrightarrow> \\<exists>m. xs = ys @ replicate m x\"", "lemma SAMEQUOT_mono: \"A \\<subseteq> B \\<Longrightarrow> SAMEQUOT a A \\<subseteq> SAMEQUOT a B\"", "lemma finite_rderivs_same: \"finite {\\<guillemotleft>rderivs (replicate m a) r\\<guillemotright> | m . True}\"", "lemma wf_word_replicate[simp]: \"a \\<in> \\<Sigma> n \\<Longrightarrow> wf_word n (replicate m a)\"", "lemma star_singleton[simp]: \"star {[x]} = {replicate m x | m . True}\"", "lemma wf_samequot: \"\\<lbrakk>wf n r; a \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> wf n (samequot a r)\"", "lemma lang_samequot: \"\\<lbrakk>wf n r; a \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> \n   lang n (samequot a r) = SAMEQUOT a (lang n r)\"", "lemma invar_rderiv_and_add_init: \"invar_rderiv_and_add as r (True, [\\<guillemotleft>r\\<guillemotright>])\"", "lemma invar_rderiv_and_add_step: \"invar_rderiv_and_add as r brs \\<Longrightarrow> fst brs \\<Longrightarrow>\n  invar_rderiv_and_add as r (rderiv_and_add as brs)\"", "lemma rderivs_replicate_mult: \"\\<lbrakk>\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>; i > 0\\<rbrakk> \\<Longrightarrow>\n  \\<guillemotleft>rderivs (replicate (m * i) as) r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\"", "lemma rderivs_replicate_mult_rest: \n  assumes \"\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\" \"k < i\"\n  shows \"\\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> = \\<guillemotleft>rderivs (replicate k as) r\\<guillemotright>\" (is \"?L = ?R\")", "lemma rderivs_replicate_mod: \n  assumes \"\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\" \"i > 0\"\n  shows \"\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> = \\<guillemotleft>rderivs (replicate (m mod i) as) r\\<guillemotright>\" (is \"?L = ?R\")", "lemma rderivs_replicate_diff: \"\\<lbrakk>\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> = \\<guillemotleft>rderivs (replicate j as) r\\<guillemotright>; i > j\\<rbrakk> \\<Longrightarrow>\n  \\<guillemotleft>rderivs (replicate (i - j) as) (rderivs (replicate j as) r)\\<guillemotright> = \\<guillemotleft>rderivs (replicate j as) r\\<guillemotright>\"", "lemma samequot_wf:\n  assumes \"wf n r\" \"while_option fst (rderiv_and_add as) (True, [\\<guillemotleft>r\\<guillemotright>]) = Some (b, rs)\"\n  shows \"wf n (PLUS rs)\"", "lemma samequot_soundness:\n  assumes \"while_option fst (rderiv_and_add as) (True, [\\<guillemotleft>r\\<guillemotright>]) = Some (b, rs)\"\n  shows \"lang n (PLUS rs) = \\<Union> (lang n ` {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> | m. True})\"", "lemma length_subset_card: \"\\<lbrakk>finite X; distinct (x # xs); set (x # xs) \\<subseteq> X\\<rbrakk> \\<Longrightarrow> length xs < card X\"", "lemma samequot_termination:\n  assumes \"while_option fst (rderiv_and_add as) (True, [\\<guillemotleft>r\\<guillemotright>]) = None\" (is \"?cl = None\")\n  shows \"False\"", "lemma wf_samequot_exec: \"\\<lbrakk>wf n r; as \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> wf n (samequot_exec as r)\"", "lemma samequot_exec_samequot: \"lang n (samequot_exec as r) = lang n (samequot as r)\"", "lemma lang_samequot_exec:\n  \"\\<lbrakk>wf n r; as \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> lang n (samequot_exec as r) = SAMEQUOT as (lang n r)\"", "lemma Prefix_Suffix: \"Prefix L = rev ` Suffix (rev ` L)\"", "lemma finite_lderivs_wf: \"finite {\\<guillemotleft>lderivs w r\\<guillemotright>| w. wf_word n w}\"", "lemma wf_SUFFIX[simp]: \"wf n r \\<Longrightarrow> wf n (SUFFIX r)\"", "lemma lang_SUFFIX[simp]: \"wf n r \\<Longrightarrow> lang n (SUFFIX r) = Suffix (lang n r)\"", "lemma wf_PREFIX[simp]: \"wf n r \\<Longrightarrow> wf n (PREFIX r)\"", "lemma lang_PREFIX[simp]: \"wf n r \\<Longrightarrow> lang n (PREFIX r) = Prefix (lang n r)\"", "lemma take_drop_CycleI[intro!]: \"x \\<in> L \\<Longrightarrow> drop i x @ take i x \\<in> Cycle L\"", "lemma take_drop_CycleI'[intro!]: \"drop i x @ take i x \\<in> L \\<Longrightarrow> x \\<in> Cycle L\""], "translations": [["", "lemma REV_REV[simp]: \"REV (REV r) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REV (REV r) = r", "by (induct r) auto"], ["", "lemma final_REV[simp]: \"final (REV r) = final r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final (REV r) = final r", "by (induct r) auto"], ["", "lemma REV_PLUS: \"REV (PLUS xs) = PLUS (map REV xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REV (PLUS xs) = PLUS (map REV xs)", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma (in alphabet) wf_REV[simp]: \"wf n r \\<Longrightarrow> wf n (REV r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (REV r)", "by (induct r arbitrary: n) auto"], ["", "lemma (in project) lang_REV[simp]: \"lang n (REV r) = rev ` lang n r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n (REV r) = rev ` lang n r", "by (induct r arbitrary: n) (auto simp: image_image rev_map image_set_diff)"], ["", "context embed\nbegin"], ["", "primrec rderiv :: \"'a \\<Rightarrow> 'b rexp \\<Rightarrow> 'b rexp\" where\n  \"rderiv _ Zero = Zero\"\n| \"rderiv _ Full = Full\"\n| \"rderiv _ One = Zero\"\n| \"rderiv a (Atom b) = (if lookup b a then One else Zero)\"\n| \"rderiv a (Plus r s) = Plus (rderiv a r) (rderiv a s)\"\n| \"rderiv a (Times r s) =\n    (let rs' = Times r (rderiv a s)\n     in if final s then Plus rs' (rderiv a r) else rs')\"\n| \"rderiv a (Star r) = Times (Star r) (rderiv a r)\"\n| \"rderiv a (Not r) = Not (rderiv a r)\"\n| \"rderiv a (Inter r s) = Inter (rderiv a r) (rderiv a s)\"\n| \"rderiv a (Pr r) = Pr (PLUS (map (\\<lambda>a'. rderiv a' r) (embed a)))\""], ["", "primrec rderivs where\n  \"rderivs [] r = r\"\n| \"rderivs (w#ws) r = rderivs ws (rderiv w r)\""], ["", "lemma rderivs_snoc: \"rderivs (ws @ [w]) r = rderiv w (rderivs ws r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rderivs (ws @ [w]) r = rderiv w (rderivs ws r)", "by (induct ws arbitrary: r) auto"], ["", "lemma rderivs_append: \"rderivs (ws @ ws') r = rderivs ws' (rderivs ws r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rderivs (ws @ ws') r = rderivs ws' (rderivs ws r)", "by (induct ws arbitrary: r) auto"], ["", "lemma rderiv_lderiv: \"rderiv as r = REV (lderiv as (REV r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rderiv as r = REV (lderiv as (REV r))", "by (induct r arbitrary: as) (auto simp: Let_def o_def REV_PLUS)"], ["", "lemma rderivs_lderivs: \"rderivs w r = REV (lderivs w (REV r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rderivs w r = REV (lderivs w (REV r))", "by (induct w arbitrary: r) (auto simp: rderiv_lderiv)"], ["", "lemma wf_rderiv[simp]: \"wf n r \\<Longrightarrow> wf n (rderiv w r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (rderiv w r)", "unfolding rderiv_lderiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (REV (lderiv w (REV r)))", "by (rule wf_REV[OF wf_lderiv[OF wf_REV]])"], ["", "lemma wf_rderivs[simp]: \"wf n r \\<Longrightarrow> wf n (rderivs ws r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (rderivs ws r)", "unfolding rderivs_lderivs"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (REV (lderivs ws (REV r)))", "by (rule wf_REV[OF wf_lderivs[OF wf_REV]])"], ["", "lemma lang_rderiv: \"\\<lbrakk>wf n r; as \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> lang n (rderiv as r) = rQuot as (lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; as \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> lang n (rderiv as r) = rQuot as (lang n r)", "unfolding rderiv_lderiv rQuot_rev_lQuot"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; as \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> lang n (REV (lderiv as (REV r))) =\n                      rev ` lQuot as (rev ` lang n r)", "by (simp add: lang_lderiv)"], ["", "lemma lang_rderivs: \"\\<lbrakk>wf n r; wf_word n w\\<rbrakk> \\<Longrightarrow> lang n (rderivs w r) = rQuots w (lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; wf_word n w\\<rbrakk>\n    \\<Longrightarrow> lang n (rderivs w r) = rQuots w (lang n r)", "unfolding rderivs_lderivs rQuots_rev_lQuots"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; wf_word n w\\<rbrakk>\n    \\<Longrightarrow> lang n (REV (lderivs w (REV r))) =\n                      rev ` lQuots w (rev ` lang n r)", "by (simp add: lang_lderivs)"], ["", "corollary rderivs_final:\nassumes \"wf n r\" \"wf_word n w\"\nshows \"final (rderivs w r) \\<longleftrightarrow> rev w \\<in> lang n r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final (rderivs w r) = (rev w \\<in> lang n r)", "using lang_rderivs[OF assms] lang_final[of \"rderivs w r\" n]"], ["proof (prove)\nusing this:\n  lang n (rderivs w r) = rQuots w (lang n r)\n  final (rderivs w r) = ([] \\<in> lang n (rderivs w r))\n\ngoal (1 subgoal):\n 1. final (rderivs w r) = (rev w \\<in> lang n r)", "by auto"], ["", "lemma toplevel_summands_REV[simp]: \"toplevel_summands (REV r) = REV ` toplevel_summands r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (REV r) = REV ` toplevel_summands r", "by (induct r) auto"], ["", "lemma ACI_norm_REV: \"\\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>REV r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV r\\<guillemotright>", "proof (induct r)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<guillemotleft>REV \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV Zero\\<guillemotright>\n 2. \\<guillemotleft>REV \\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV Full\\<guillemotright>\n 3. \\<guillemotleft>REV \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>REV \\<guillemotleft>Atom\n      x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV (Atom x)\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>REV \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>REV r1\\<guillemotright>;\n        \\<guillemotleft>REV \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>REV\n    \\<guillemotleft>Plus r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>REV (Plus r1 r2)\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>REV \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>REV r1\\<guillemotright>;\n        \\<guillemotleft>REV \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>REV\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>REV (Times r1 r2)\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>REV \\<guillemotleft>Star\n      r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV (Star r)\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>REV \\<guillemotleft>rexp.Not\n      r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV (rexp.Not r)\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>REV \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>REV r1\\<guillemotright>;\n        \\<guillemotleft>REV \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>REV\n    \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>REV\n    (rexp.Inter r1 r2)\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>REV \\<guillemotleft>Pr\n       r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV (Pr r)\\<guillemotright>", "case (Plus r s)"], ["proof (state)\nthis:\n  \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>REV r\\<guillemotright>\n  \\<guillemotleft>REV \\<guillemotleft>s\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>REV s\\<guillemotright>\n\ngoal (10 subgoals):\n 1. \\<guillemotleft>REV \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV Zero\\<guillemotright>\n 2. \\<guillemotleft>REV \\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV Full\\<guillemotright>\n 3. \\<guillemotleft>REV \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>REV \\<guillemotleft>Atom\n      x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV (Atom x)\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>REV \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>REV r1\\<guillemotright>;\n        \\<guillemotleft>REV \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>REV\n    \\<guillemotleft>Plus r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>REV (Plus r1 r2)\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>REV \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>REV r1\\<guillemotright>;\n        \\<guillemotleft>REV \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>REV\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>REV (Times r1 r2)\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>REV \\<guillemotleft>Star\n      r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV (Star r)\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>REV \\<guillemotleft>rexp.Not\n      r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV (rexp.Not r)\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>REV \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>REV r1\\<guillemotright>;\n        \\<guillemotleft>REV \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>REV\n    \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>REV\n    (rexp.Inter r1 r2)\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>REV \\<guillemotleft>Pr\n       r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV (Pr r)\\<guillemotright>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>REV \\<guillemotleft>Plus r\n   s\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV (Plus r s)\\<guillemotright>", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>REV \\<guillemotleft>Plus r\n   s\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV (Plus r s)\\<guillemotright>", "unfolding REV.simps ACI_norm.simps Plus[symmetric] image_Un[symmetric]\n      toplevel_summands.simps(1) toplevel_summands_ACI_norm toplevel_summands_REV"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>REV (PLUS\n                          (sorted_list_of_set\n                            (ACI_norm `\n                             (toplevel_summands r \\<union>\n                              toplevel_summands s))))\\<guillemotright> =\n    PLUS\n     (sorted_list_of_set\n       (ACI_norm `\n        REV `\n        ACI_norm ` (toplevel_summands r \\<union> toplevel_summands s)))", "unfolding toplevel_summands.simps(1)[symmetric] ACI_norm_flatten toplevel_summands_REV"], ["proof (prove)\ngoal (1 subgoal):\n 1. PLUS\n     (sorted_list_of_set\n       (ACI_norm `\n        REV `\n        toplevel_summands\n         (PLUS\n           (sorted_list_of_set\n             (ACI_norm ` toplevel_summands (Plus r s)))))) =\n    PLUS\n     (sorted_list_of_set\n       (ACI_norm ` REV ` ACI_norm ` toplevel_summands (Plus r s)))", "unfolding ACI_norm_flatten[symmetric] toplevel_summands_ACI_norm"], ["proof (prove)\ngoal (1 subgoal):\n 1. PLUS\n     (sorted_list_of_set\n       (ACI_norm ` REV ` ACI_norm ` toplevel_summands (Plus r s))) =\n    PLUS\n     (sorted_list_of_set\n       (ACI_norm ` REV ` ACI_norm ` toplevel_summands (Plus r s)))", ".."], ["proof (state)\nthis:\n  \\<guillemotleft>REV \\<guillemotleft>Plus r\n s\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>REV (Plus r s)\\<guillemotright>\n\ngoal (9 subgoals):\n 1. \\<guillemotleft>REV \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV Zero\\<guillemotright>\n 2. \\<guillemotleft>REV \\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV Full\\<guillemotright>\n 3. \\<guillemotleft>REV \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>REV One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>REV \\<guillemotleft>Atom\n      x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV (Atom x)\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>REV \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>REV r1\\<guillemotright>;\n        \\<guillemotleft>REV \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>REV\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>REV (Times r1 r2)\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>REV \\<guillemotleft>Star\n      r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV (Star r)\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>REV \\<guillemotleft>rexp.Not\n      r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV (rexp.Not r)\\<guillemotright>\n 8. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>REV \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>REV r1\\<guillemotright>;\n        \\<guillemotleft>REV \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>REV r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>REV\n    \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>REV\n    (rexp.Inter r1 r2)\\<guillemotright>\n 9. \\<And>r.\n       \\<guillemotleft>REV \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>REV \\<guillemotleft>Pr\n      r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>REV (Pr r)\\<guillemotright>", "qed auto"], ["", "lemma ACI_norm_rderiv: \"\\<guillemotleft>rderiv as \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>rderiv as r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderiv as\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>rderiv as r\\<guillemotright>", "unfolding rderiv_lderiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>REV (lderiv as\n                          (REV \\<guillemotleft>r\\<guillemotright>))\\<guillemotright> =\n    \\<guillemotleft>REV (lderiv as (REV r))\\<guillemotright>", "by (metis ACI_norm_REV ACI_norm_lderiv)"], ["", "lemma ACI_norm_rderivs: \"\\<guillemotleft>rderivs w \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>rderivs w r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs w\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>rderivs w r\\<guillemotright>", "unfolding rderivs_lderivs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>REV (lderivs w\n                          (REV \\<guillemotleft>r\\<guillemotright>))\\<guillemotright> =\n    \\<guillemotleft>REV (lderivs w (REV r))\\<guillemotright>", "by (metis ACI_norm_REV ACI_norm_lderivs)"], ["", "theorem finite_rderivs: \"finite {\\<guillemotleft>rderivs xs r\\<guillemotright> | xs . True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>rderivs xs r\\<guillemotright> |xs. True}", "unfolding rderivs_lderivs"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<guillemotleft>REV (lderivs xs (REV r))\\<guillemotright> |xs. True}", "by (subst ACI_norm_REV[symmetric]) (auto intro: finite_surj[OF finite_lderivs, of _ \"\\<lambda>r. \\<guillemotleft>REV r\\<guillemotright>\"])"], ["", "lemma lderiv_PLUS[simp]: \"lderiv a (PLUS xs) = PLUS (map (lderiv a) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lderiv a (PLUS xs) = PLUS (map (lderiv a) xs)", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma rderiv_PLUS[simp]: \"rderiv a (PLUS xs) = PLUS (map (rderiv a) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rderiv a (PLUS xs) = PLUS (map (rderiv a) xs)", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma lang_rderiv_lderiv: \"lang n (rderiv a (lderiv b r)) = lang n (lderiv b (rderiv a r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n (rderiv a (lderiv b r)) = lang n (lderiv b (rderiv a r))", "by (induct r arbitrary: n a b) (auto simp: Let_def conc_assoc)"], ["", "lemma lang_lderiv_rderiv: \"lang n (lderiv a (rderiv b r)) = lang n (rderiv b (lderiv a r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n (lderiv a (rderiv b r)) = lang n (rderiv b (lderiv a r))", "by (induct r arbitrary: n a b) (auto simp: Let_def conc_assoc)"], ["", "lemma lang_rderiv_lderivs[simp]: \"\\<lbrakk>wf n r; wf_word n w; a \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow>\n  lang n (rderiv a (lderivs w r)) = lang n (lderivs w (rderiv a r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; wf_word n w; a \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> lang n (rderiv a (lderivs w r)) =\n                      lang n (lderivs w (rderiv a r))", "by (induct w arbitrary: n r)\n    (auto, auto simp: lang_lderivs lang_lderiv lang_rderiv lQuot_rQuot)"], ["", "lemma lang_lderiv_rderivs[simp]: \"\\<lbrakk>wf n r; wf_word n w; a \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow>\n  lang n (lderiv a (rderivs w r)) = lang n (rderivs w (lderiv a r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; wf_word n w; a \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> lang n (lderiv a (rderivs w r)) =\n                      lang n (rderivs w (lderiv a r))", "by (induct w arbitrary: n r)\n    (auto, auto simp: lang_rderivs lang_lderiv lang_rderiv lQuot_rQuot)"], ["", "(*\nprimrec bideriv :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a rexp \\<Rightarrow> 'a rexp\" where\n  \"bideriv _ _ Zero = Zero\"\n| \"bideriv _ _ One = Zero\"\n| \"bideriv a b (Atom c) = Zero\"\n| \"bideriv a b (Plus r s) = Plus (bideriv a b r) (bideriv a b s)\"\n| \"bideriv a b (Times r s) =\n    (let rs' = Times (lderiv a r) (rderiv b s)\n     in if final r \\<and> final s then Plus (Plus rs' (bideriv a b r)) (bideriv a b s)\n        else if final r then Plus rs' (bideriv a b s)\n        else if final s then Plus rs' (bideriv a b r)\n        else rs')\"\n| \"bideriv a b (Star r) = Plus (bideriv a b r) (TIMES [lderiv a r, Star r, rderiv b r])\"\n| \"bideriv a b (Not r) = Not (bideriv a b r)\"\n| \"bideriv a b (Inter r s) = Inter (bideriv a b r) (bideriv a b s)\"\n| \"bideriv a b (Pr r) = Pr (PLUS (map (\\<lambda>b. PLUS (map (\\<lambda>a. bideriv a b r) (embed a))) (embed b)))\"\n\nlemma wf_bideriv[simp]: \"wf n r \\<Longrightarrow> wf n (bideriv a b r)\"\n  by (induct r arbitrary: n a b) (auto simp: maps_def Let_def)\n\nlemma ACI_norm_bideriv_rderiv_lderiv: \"\\<guillemotleft>bideriv a b r\\<guillemotright> = \\<guillemotleft>rderiv b (lderiv a r)\\<guillemotright>\"\n  by (induct r arbitrary: a b)\n    (auto simp: Let_def maps_def o_def list_all2_map1 list_all2_map2 intro!: ACI_PLUS list_all2_refl)\n\nlemma bideriv_rderiv_lderiv:\n  \"lang n (bideriv a b r) = lang n (rderiv b (lderiv a r))\"\n  by (induct r arbitrary: n a b) (auto simp: Let_def)\n\nlemma lang_bideriv:\n  \"\\<lbrakk>wf n r; a \\<in> \\<Sigma> n; b \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> lang n (bideriv a b r) = biQuot a b (lang n r)\"\n  by (auto simp: bideriv_rderiv_lderiv lang_lderiv lang_rderiv biQuot_rQuot_lQuot)\n\nlemma ACI_norm_bideriv: \"\\<guillemotleft>bideriv a b \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>bideriv a b r\\<guillemotright>\"\n  unfolding ACI_norm_bideriv_rderiv_lderiv by (metis ACI_norm_lderiv ACI_norm_rderiv)\n\nfun biderivs where\n  \"biderivs [] [] r = r\"\n| \"biderivs as [] r = lderivs as r\"\n| \"biderivs [] bs r = rderivs bs r\"\n| \"biderivs (a#as) (b#bs) r = biderivs as bs (bideriv a b r)\"\n\nlemma biderivs_rderivs_lderivs: \"\\<lbrakk>wf n r; wf_word n w1; wf_word n w2\\<rbrakk> \\<Longrightarrow>\n  lang n (biderivs w1 w2 r) = lang n (rderivs w2 (lderivs w1 r))\"\n  by (induct arbitrary: r rule: biderivs.induct)\n    (auto simp: lang_rderivs lang_lderivs bideriv_rderiv_lderiv)\n\nlemma lang_biderivs:\n  \"\\<lbrakk>wf n r; wf_word n w1; wf_word n w2\\<rbrakk> \\<Longrightarrow> lang n (biderivs w1 w2 r) = biQuots w1 w2 (lang n r)\"\n  by (auto simp: biderivs_rderivs_lderivs lang_lderivs lang_rderivs biQuots_rQuots_lQuots)\n\nlemma wf_biderivs[simp]: \"wf n r \\<Longrightarrow> wf n (biderivs w1 w2 r)\"\n  by (induct arbitrary: r rule: biderivs.induct) auto\n*)"], ["", "definition \"biderivs w1 w2 = rderivs w2 o lderivs w1\""], ["", "lemma lang_biderivs: \"\\<lbrakk>wf n r; wf_word n w1; wf_word n w2\\<rbrakk> \\<Longrightarrow>\n  lang n (biderivs w1 w2 r) = biQuots w1 w2 (lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; wf_word n w1; wf_word n w2\\<rbrakk>\n    \\<Longrightarrow> lang n (biderivs w1 w2 r) = biQuots w1 w2 (lang n r)", "unfolding biderivs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; wf_word n w1; wf_word n w2\\<rbrakk>\n    \\<Longrightarrow> lang n ((rderivs w2 \\<circ> lderivs w1) r) =\n                      biQuots w1 w2 (lang n r)", "by (auto simp: lang_rderivs lang_lderivs in_lists_conv_set)"], ["", "lemma wf_biderivs[simp]: \"wf n r \\<Longrightarrow> wf n (biderivs w1 w2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (biderivs w1 w2 r)", "unfolding biderivs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow>\n    local.wf n ((rderivs w2 \\<circ> lderivs w1) r)", "by simp"], ["", "corollary biderivs_final:\nassumes \"wf n r\" \"wf_word n w1\" \"wf_word n w2\"\nshows \"final (biderivs w1 w2 r) \\<longleftrightarrow> w1 @ rev w2 \\<in> lang n r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final (biderivs w1 w2 r) = (w1 @ rev w2 \\<in> lang n r)", "using lang_biderivs[OF assms] lang_final[of \"biderivs w1 w2 r\" n]"], ["proof (prove)\nusing this:\n  lang n (biderivs w1 w2 r) = biQuots w1 w2 (lang n r)\n  final (biderivs w1 w2 r) = ([] \\<in> lang n (biderivs w1 w2 r))\n\ngoal (1 subgoal):\n 1. final (biderivs w1 w2 r) = (w1 @ rev w2 \\<in> lang n r)", "by auto"], ["", "lemma ACI_norm_biderivs: \"\\<guillemotleft>biderivs w1 w2 \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>biderivs w1 w2 r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>biderivs w1 w2\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>biderivs w1 w2 r\\<guillemotright>", "unfolding biderivs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>(rderivs w2 \\<circ> lderivs w1)\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>(rderivs w2 \\<circ> lderivs w1) r\\<guillemotright>", "by (metis ACI_norm_lderivs ACI_norm_rderivs o_apply)"], ["", "lemma \"finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> | w1 w2 . True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True}", "have \"{\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> | w1 w2 . True} =\n    (\\<Union>s \\<in> {\\<guillemotleft>lderivs as r\\<guillemotright> | as . True}. {\\<guillemotleft>rderivs bs s\\<guillemotright> | bs . True})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True} =\n    (\\<Union>s\\<in>{\\<guillemotleft>lderivs as r\\<guillemotright> |as.\n                    True}.\n        {\\<guillemotleft>rderivs bs s\\<guillemotright> |bs. True})", "unfolding biderivs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<guillemotleft>(rderivs w2 \\<circ> lderivs w1) r\\<guillemotright> |w1\n     w2. True} =\n    (\\<Union>s\\<in>{\\<guillemotleft>lderivs as r\\<guillemotright> |as.\n                    True}.\n        {\\<guillemotleft>rderivs bs s\\<guillemotright> |bs. True})", "by (fastforce simp: ACI_norm_rderivs)"], ["proof (state)\nthis:\n  {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True} =\n  (\\<Union>s\\<in>{\\<guillemotleft>lderivs as r\\<guillemotright> |as. True}.\n      {\\<guillemotleft>rderivs bs s\\<guillemotright> |bs. True})\n\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True}", "also"], ["proof (state)\nthis:\n  {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True} =\n  (\\<Union>s\\<in>{\\<guillemotleft>lderivs as r\\<guillemotright> |as. True}.\n      {\\<guillemotleft>rderivs bs s\\<guillemotright> |bs. True})\n\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>s\\<in>{\\<guillemotleft>lderivs as r\\<guillemotright> |as.\n                     True}.\n         {\\<guillemotleft>rderivs bs s\\<guillemotright> |bs. True})", "by (rule iffD2[OF finite_UN[OF finite_lderivs] ballI[OF finite_rderivs]])"], ["proof (state)\nthis:\n  finite\n   (\\<Union>s\\<in>{\\<guillemotleft>lderivs as r\\<guillemotright> |as. True}.\n       {\\<guillemotleft>rderivs bs s\\<guillemotright> |bs. True})\n\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True}", "finally"], ["proof (chain)\npicking this:\n  finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True}\n\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True}", "."], ["proof (state)\nthis:\n  finite {\\<guillemotleft>biderivs w1 w2 r\\<guillemotright> |w1 w2. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Quotioning by the same letter\\<close>"], ["", "definition \"fin_cut_same x xs = take (LEAST n. drop n xs = replicate (length xs - n) x) xs\""], ["", "lemma fin_cut_same_Nil[simp]: \"fin_cut_same x [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_cut_same x [] = []", "unfolding fin_cut_same_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (LEAST n. drop n [] = replicate (length [] - n) x) [] = []", "by simp"], ["", "lemma Least_fin_cut_same: \"(LEAST n. drop n xs = replicate (length xs - n) y) =\n  length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs))\"\n  (is \"Least ?P = ?min\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. drop n xs = replicate (length xs - n) y) =\n    length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. drop (length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs))) xs =\n    replicate\n     (length xs -\n      (length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs))))\n     y\n 2. \\<And>ya.\n       drop ya xs = replicate (length xs - ya) y \\<Longrightarrow>\n       length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs)) \\<le> ya", "show \"?P ?min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs))) xs =\n    replicate\n     (length xs -\n      (length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs))))\n     y", "by (induct xs rule: rev_induct) (auto simp:  Suc_diff_le replicate_append_same)"], ["proof (state)\nthis:\n  drop (length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs))) xs =\n  replicate\n   (length xs -\n    (length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs))))\n   y\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       drop ya xs = replicate (length xs - ya) y \\<Longrightarrow>\n       length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs)) \\<le> ya", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       drop ya xs = replicate (length xs - ya) y \\<Longrightarrow>\n       length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs)) \\<le> ya", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       drop ya xs = replicate (length xs - ya) y \\<Longrightarrow>\n       length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs)) \\<le> ya", "assume \"?P m\""], ["proof (state)\nthis:\n  drop m xs = replicate (length xs - m) y\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       drop ya xs = replicate (length xs - ya) y \\<Longrightarrow>\n       length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs)) \\<le> ya", "have \"length xs - m \\<le> length (takeWhile (\\<lambda>x. x = y) (rev xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs - m \\<le> length (takeWhile (\\<lambda>x. x = y) (rev xs))", "proof (intro length_takeWhile_less_P_nth)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i < length xs - m \\<Longrightarrow> rev xs ! i = y\n 2. length xs - m \\<le> length (rev xs)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i < length xs - m \\<Longrightarrow> rev xs ! i = y\n 2. length xs - m \\<le> length (rev xs)", "assume \"i < length xs - m\""], ["proof (state)\nthis:\n  i < length xs - m\n\ngoal (2 subgoals):\n 1. \\<And>i. i < length xs - m \\<Longrightarrow> rev xs ! i = y\n 2. length xs - m \\<le> length (rev xs)", "hence \"rev xs ! i \\<in> set (drop m xs)\""], ["proof (prove)\nusing this:\n  i < length xs - m\n\ngoal (1 subgoal):\n 1. rev xs ! i \\<in> set (drop m xs)", "by (induct xs arbitrary: i rule: rev_induct) (auto simp: nth_Cons')"], ["proof (state)\nthis:\n  rev xs ! i \\<in> set (drop m xs)\n\ngoal (2 subgoals):\n 1. \\<And>i. i < length xs - m \\<Longrightarrow> rev xs ! i = y\n 2. length xs - m \\<le> length (rev xs)", "with \\<open>?P m\\<close>"], ["proof (chain)\npicking this:\n  drop m xs = replicate (length xs - m) y\n  rev xs ! i \\<in> set (drop m xs)", "show \"rev xs ! i = y\""], ["proof (prove)\nusing this:\n  drop m xs = replicate (length xs - m) y\n  rev xs ! i \\<in> set (drop m xs)\n\ngoal (1 subgoal):\n 1. rev xs ! i = y", "by simp"], ["proof (state)\nthis:\n  rev xs ! i = y\n\ngoal (1 subgoal):\n 1. length xs - m \\<le> length (rev xs)", "qed simp"], ["proof (state)\nthis:\n  length xs - m \\<le> length (takeWhile (\\<lambda>x. x = y) (rev xs))\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       drop ya xs = replicate (length xs - ya) y \\<Longrightarrow>\n       length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs)) \\<le> ya", "thus \"?min \\<le> m\""], ["proof (prove)\nusing this:\n  length xs - m \\<le> length (takeWhile (\\<lambda>x. x = y) (rev xs))\n\ngoal (1 subgoal):\n 1. length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs)) \\<le> m", "by linarith"], ["proof (state)\nthis:\n  length xs - length (takeWhile (\\<lambda>x. x = y) (rev xs)) \\<le> m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma takeWhile_takes_all: \"length xs = m \\<Longrightarrow> m \\<le> length (takeWhile P xs) \\<longleftrightarrow> Ball (set xs) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = m \\<Longrightarrow>\n    (m \\<le> length (takeWhile P xs)) = Ball (set xs) P", "by hypsubst_thin (induct xs, auto)"], ["", "lemma fin_cut_same_Cons[simp]: \"fin_cut_same x (y # xs) =\n  (if fin_cut_same x xs = [] then if x = y then [] else [y] else y # fin_cut_same x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_cut_same x (y # xs) =\n    (if fin_cut_same x xs = [] then if x = y then [] else [y]\n     else y # fin_cut_same x xs)", "unfolding fin_cut_same_def Least_fin_cut_same"], ["proof (prove)\ngoal (1 subgoal):\n 1. take\n     (length (y # xs) -\n      length (takeWhile (\\<lambda>xa. xa = x) (rev (y # xs))))\n     (y # xs) =\n    (if take (length xs - length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n         xs =\n        []\n     then if x = y then [] else [y]\n     else y #\n          take\n           (length xs - length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n           xs)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x = y;\n     length xs\n     \\<le> length (takeWhile (\\<lambda>x. x = y) (rev xs))\\<rbrakk>\n    \\<Longrightarrow> Suc (length xs)\n                      \\<le> length\n                             (takeWhile (\\<lambda>x. x = y) (rev xs @ [y]))\n 2. \\<lbrakk>x = y;\n     \\<not> length xs \\<le> length (takeWhile (\\<lambda>x. x = y) (rev xs));\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>x. x = y) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>x. x = y) (rev xs)))\n                       xs\n 3. \\<lbrakk>x \\<noteq> y;\n     length xs\n     \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs))\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      [y]\n 4. \\<lbrakk>x \\<noteq> y;\n     \\<not> length xs\n            \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs));\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                       xs", "apply (simp add: takeWhile_takes_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = y;\n     \\<not> length xs \\<le> length (takeWhile (\\<lambda>x. x = y) (rev xs));\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>x. x = y) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>x. x = y) (rev xs)))\n                       xs\n 2. \\<lbrakk>x \\<noteq> y;\n     length xs\n     \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs))\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      [y]\n 3. \\<lbrakk>x \\<noteq> y;\n     \\<not> length xs\n            \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs));\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                       xs", "apply (simp add: takeWhile_takes_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = y; \\<exists>x\\<in>set xs. x \\<noteq> y;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>x. x = y) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>x. x = y) (rev xs)))\n                       xs\n 2. \\<lbrakk>x \\<noteq> y;\n     length xs\n     \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs))\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      [y]\n 3. \\<lbrakk>x \\<noteq> y;\n     \\<not> length xs\n            \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs));\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                       xs", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x = y; xs \\<noteq> []; xa \\<in> set xs;\n        xa \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> take\n                          (Suc (length xs) -\n                           length (takeWhile (\\<lambda>x. x = y) (rev xs)))\n                          (y # xs) =\n                         y #\n                         take\n                          (length xs -\n                           length (takeWhile (\\<lambda>x. x = y) (rev xs)))\n                          xs\n 2. \\<lbrakk>x \\<noteq> y;\n     length xs\n     \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs))\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      [y]\n 3. \\<lbrakk>x \\<noteq> y;\n     \\<not> length xs\n            \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs));\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                       xs", "apply (metis (full_types) Suc_diff_le length_rev length_takeWhile_le take_Suc_Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y;\n     length xs\n     \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs))\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      [y]\n 2. \\<lbrakk>x \\<noteq> y;\n     \\<not> length xs\n            \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs));\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                       xs", "apply (simp add: takeWhile_takes_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; \\<forall>xa\\<in>set xs. xa = x\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      [y]\n 2. \\<lbrakk>x \\<noteq> y;\n     \\<not> length xs\n            \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs));\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                       xs", "apply (subst takeWhile_append2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<noteq> y; \\<forall>xa\\<in>set xs. xa = x;\n        xa \\<in> set (rev xs)\\<rbrakk>\n       \\<Longrightarrow> xa = x\n 2. \\<lbrakk>x \\<noteq> y; \\<forall>xa\\<in>set xs. xa = x\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (rev xs @ takeWhile (\\<lambda>xa. xa = x) [y]))\n                       (y # xs) =\n                      [y]\n 3. \\<lbrakk>x \\<noteq> y;\n     \\<not> length xs\n            \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs));\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                       xs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y;\n     \\<not> length xs\n            \\<le> length (takeWhile (\\<lambda>xa. xa = x) (rev xs));\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                       xs", "apply (simp add: takeWhile_takes_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; \\<exists>xa\\<in>set xs. xa \\<noteq> x;\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> take\n                       (Suc (length xs) -\n                        length\n                         (takeWhile (\\<lambda>xa. xa = x) (rev xs @ [y])))\n                       (y # xs) =\n                      y #\n                      take\n                       (length xs -\n                        length (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                       xs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<noteq> y; xs \\<noteq> []; xa \\<in> set xs;\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> take\n                          (Suc (length xs) -\n                           length\n                            (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                          (y # xs) =\n                         y #\n                         take\n                          (length xs -\n                           length\n                            (takeWhile (\\<lambda>xa. xa = x) (rev xs)))\n                          xs", "apply (metis (full_types) Suc_diff_le length_rev length_takeWhile_le take_Suc_Cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fin_cut_same_singleton[simp]: \"fin_cut_same x (xs @ [x]) = fin_cut_same x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_cut_same x (xs @ [x]) = fin_cut_same x xs", "by (induct xs) auto"], ["", "lemma fin_cut_same_replicate[simp]: \"fin_cut_same x (xs @ replicate n x) = fin_cut_same x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_cut_same x (xs @ replicate n x) = fin_cut_same x xs", "by (induct n arbitrary: xs)\n    (auto simp: replicate_append_same[symmetric] append_assoc[symmetric] simp del: append_assoc)"], ["", "lemma fin_cut_sameE: \"fin_cut_same x xs = ys \\<Longrightarrow> \\<exists>m. xs = ys @ replicate m x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_cut_same x xs = ys \\<Longrightarrow>\n    \\<exists>m. xs = ys @ replicate m x", "apply (induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       fin_cut_same x [] = ys \\<Longrightarrow>\n       \\<exists>m. [] = ys @ replicate m x\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   fin_cut_same x xs = ys \\<Longrightarrow>\n                   \\<exists>m. xs = ys @ replicate m x;\n        fin_cut_same x (a # xs) = ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. a # xs = ys @ replicate m x", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       fin_cut_same x (replicate m x) = [] \\<Longrightarrow>\n       \\<exists>ma. x # replicate m x = replicate ma x\n 2. \\<And>xs m.\n       \\<lbrakk>xs = fin_cut_same x xs @ replicate m x;\n        fin_cut_same x xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. xs = fin_cut_same x xs @ replicate m x\n 3. \\<And>a xs m.\n       \\<lbrakk>xs = fin_cut_same x xs @ replicate m x; x \\<noteq> a;\n        fin_cut_same x xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. xs = fin_cut_same x xs @ replicate m x", "apply (metis replicate_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs m.\n       \\<lbrakk>xs = fin_cut_same x xs @ replicate m x;\n        fin_cut_same x xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. xs = fin_cut_same x xs @ replicate m x\n 2. \\<And>a xs m.\n       \\<lbrakk>xs = fin_cut_same x xs @ replicate m x; x \\<noteq> a;\n        fin_cut_same x xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. xs = fin_cut_same x xs @ replicate m x", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs m.\n       \\<lbrakk>xs = fin_cut_same x xs @ replicate m x; x \\<noteq> a;\n        fin_cut_same x xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. xs = fin_cut_same x xs @ replicate m x", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"SAMEQUOT a A = {fin_cut_same a x @ replicate m a| x m. x \\<in> A}\""], ["", "lemma SAMEQUOT_mono: \"A \\<subseteq> B \\<Longrightarrow> SAMEQUOT a A \\<subseteq> SAMEQUOT a B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> SAMEQUOT a A \\<subseteq> SAMEQUOT a B", "unfolding SAMEQUOT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow>\n    {fin_cut_same a x @ replicate m a |x m. x \\<in> A}\n    \\<subseteq> {fin_cut_same a x @ replicate m a |x m. x \\<in> B}", "by auto"], ["", "locale embed2 = embed \\<Sigma> wf_atom project lookup embed\n  for \\<Sigma> :: \"nat \\<Rightarrow> 'a set\"\n  and wf_atom :: \"nat \\<Rightarrow> 'b :: linorder \\<Rightarrow> bool\"\n  and project :: \"'a \\<Rightarrow> 'a\"\n  and lookup :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and embed :: \"'a \\<Rightarrow> 'a list\" +\n  fixes singleton :: \"'a \\<Rightarrow> 'b\"\n  assumes wf_singleton[simp]: \"a \\<in> \\<Sigma> n \\<Longrightarrow> wf_atom n (singleton a)\"\n  assumes lookup_singleton[simp]: \"lookup (singleton a) a' = (a = a')\"\nbegin"], ["", "lemma finite_rderivs_same: \"finite {\\<guillemotleft>rderivs (replicate m a) r\\<guillemotright> | m . True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<guillemotleft>rderivs (replicate m a) r\\<guillemotright> |m. True}", "by (auto intro: finite_subset[OF _ finite_rderivs])"], ["", "lemma wf_word_replicate[simp]: \"a \\<in> \\<Sigma> n \\<Longrightarrow> wf_word n (replicate m a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<Sigma> n \\<Longrightarrow> wf_word n (replicate m a)", "by (induct m) auto"], ["", "lemma star_singleton[simp]: \"star {[x]} = {replicate m x | m . True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. star {[x]} = {replicate m x |m. True}", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> star {[x]} \\<Longrightarrow>\n       xa \\<in> {replicate m x |m. True}\n 2. \\<And>xa.\n       xa \\<in> {replicate m x |m. True} \\<Longrightarrow>\n       xa \\<in> star {[x]}", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> star {[x]} \\<Longrightarrow>\n       xa \\<in> {replicate m x |m. True}\n 2. \\<And>xa.\n       xa \\<in> {replicate m x |m. True} \\<Longrightarrow>\n       xa \\<in> star {[x]}", "assume \"xs \\<in> star {[x]}\""], ["proof (state)\nthis:\n  xs \\<in> star {[x]}\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> star {[x]} \\<Longrightarrow>\n       xa \\<in> {replicate m x |m. True}\n 2. \\<And>xa.\n       xa \\<in> {replicate m x |m. True} \\<Longrightarrow>\n       xa \\<in> star {[x]}", "thus \"xs \\<in> {replicate m x | m . True}\""], ["proof (prove)\nusing this:\n  xs \\<in> star {[x]}\n\ngoal (1 subgoal):\n 1. xs \\<in> {replicate m x |m. True}", "by (induct xs) (auto, metis replicate_Suc)"], ["proof (state)\nthis:\n  xs \\<in> {replicate m x |m. True}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {replicate m x |m. True} \\<Longrightarrow>\n       xa \\<in> star {[x]}", "qed (auto intro: Ball_starI)"], ["", "definition \"samequot a r = Times (flatten PLUS {\\<guillemotleft>rderivs (replicate m a) r\\<guillemotright> | m . True}) (Star (Atom (singleton a)))\""], ["", "lemma wf_samequot: \"\\<lbrakk>wf n r; a \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> wf n (samequot a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> local.wf n (samequot a r)", "unfolding samequot_def wf.simps wf_flatten_PLUS[OF finite_rderivs_same]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> Ball\n                       {\\<guillemotleft>rderivs (replicate m a)\n   r\\<guillemotright> |\n                        m. True}\n                       (local.wf n) \\<and>\n                      wf_atom n (singleton a)", "by auto"], ["", "lemma lang_samequot: \"\\<lbrakk>wf n r; a \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> \n   lang n (samequot a r) = SAMEQUOT a (lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> lang n (samequot a r) = SAMEQUOT a (lang n r)", "unfolding SAMEQUOT_def samequot_def lang.simps lang_flatten_PLUS[OF finite_rderivs_same]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> \\<Union>\n                       (lang n `\n                        {\\<guillemotleft>rderivs (replicate m a)\n    r\\<guillemotright> |\n                         m. True}) @@\n                      star\n                       {[x] |x.\n                        lookup (singleton a) x \\<and> x \\<in> \\<Sigma> n} =\n                      {fin_cut_same a x @ replicate m a |x m.\n                       x \\<in> lang n r}", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> {fin_cut_same a x @ replicate m a |x m.\n                       x \\<in> lang n r} =\n                      \\<Union>\n                       (lang n `\n                        {\\<guillemotleft>rderivs (replicate m a)\n    r\\<guillemotright> |\n                         m. True}) @@\n                      star\n                       {[x] |x.\n                        lookup (singleton a) x \\<and> x \\<in> \\<Sigma> n}", "apply (auto simp: lang_rderivs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa m.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r\\<rbrakk>\n       \\<Longrightarrow> fin_cut_same a xa @ replicate m a\n                         \\<in> \\<Union>\n                                (lang n `\n                                 {uu_.\n                                  \\<exists>m.\n                                     uu_ =\n                                     \\<guillemotleft>rderivs (replicate m a)\n                r\\<guillemotright>}) @@\n                               {uu_. \\<exists>m. uu_ = replicate m a}\n 2. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply (intro concI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa m.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r\\<rbrakk>\n       \\<Longrightarrow> fin_cut_same a xa\n                         \\<in> \\<Union>\n                                (lang n `\n                                 {uu_.\n                                  \\<exists>m.\n                                     uu_ =\n                                     \\<guillemotleft>rderivs (replicate m a)\n                r\\<guillemotright>})\n 2. \\<And>xa m.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r\\<rbrakk>\n       \\<Longrightarrow> replicate m a\n                         \\<in> {uu_. \\<exists>m. uu_ = replicate m a}\n 3. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>m.\n                                x =\n                                \\<guillemotleft>rderivs (replicate m a)\n           r\\<guillemotright>) \\<and>\n                            fin_cut_same a xa \\<in> lang n x\n 2. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply (insert fin_cut_sameE[OF refl, of _ a])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r;\n        \\<And>xs.\n           \\<exists>m. xs = fin_cut_same a xs @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>m.\n                                x =\n                                \\<guillemotleft>rderivs (replicate m a)\n           r\\<guillemotright>) \\<and>\n                            fin_cut_same a xa \\<in> lang n x\n 2. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a};\n        \\<And>xs.\n           \\<exists>m. xs = fin_cut_same a xs @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply (drule meta_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r;\n        \\<exists>m.\n           ?xs20 xa = fin_cut_same a (?xs20 xa) @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>m.\n                                x =\n                                \\<guillemotleft>rderivs (replicate m a)\n           r\\<guillemotright>) \\<and>\n                            fin_cut_same a xa \\<in> lang n x\n 2. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a};\n        \\<And>xs.\n           \\<exists>m. xs = fin_cut_same a xs @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa m.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r;\n        ?xs20 xa = fin_cut_same a (?xs20 xa) @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>m.\n                                x =\n                                \\<guillemotleft>rderivs (replicate m a)\n           r\\<guillemotright>) \\<and>\n                            fin_cut_same a xa \\<in> lang n x\n 2. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a};\n        \\<And>xs.\n           \\<exists>m. xs = fin_cut_same a xs @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa m.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r;\n        ?xs20 xa = fin_cut_same a (?xs20 xa) @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> ?x24 xa m =\n                         \\<guillemotleft>rderivs (replicate (?m26 xa m) a)\n    r\\<guillemotright>\n 2. \\<And>xa m.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r;\n        ?xs20 xa = fin_cut_same a (?xs20 xa) @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> fin_cut_same a xa \\<in> lang n (?x24 xa m)\n 3. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a};\n        \\<And>xs.\n           \\<exists>m. xs = fin_cut_same a xs @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply (rule refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa m.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r;\n        ?xs20 xa = fin_cut_same a (?xs20 xa) @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> fin_cut_same a xa\n                         \\<in> lang n\n                                \\<guillemotleft>rderivs\n           (replicate (?m26 xa m) a) r\\<guillemotright>\n 2. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a};\n        \\<And>xs.\n           \\<exists>m. xs = fin_cut_same a xs @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply (auto simp: lang_rderivs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa m.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r;\n        ?xs20 xa = fin_cut_same a (?xs20 xa) @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> fin_cut_same a xa @ replicate (?m26 xa m) a\n                         \\<in> lang n r\n 2. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a};\n        \\<And>xs.\n           \\<exists>m. xs = fin_cut_same a xs @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply (erule subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa m.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n; xa \\<in> lang n r\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> lang n r\n 2. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a};\n        \\<And>xs.\n           \\<exists>m. xs = fin_cut_same a xs @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        x \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>}) @@\n                {uu_. \\<exists>m. uu_ = replicate m a};\n        \\<And>xs.\n           \\<exists>m. xs = fin_cut_same a xs @ replicate m a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply (erule concE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x u v.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        \\<And>xs. \\<exists>m. xs = fin_cut_same a xs @ replicate m a;\n        u \\<in> \\<Union>\n                 (lang n `\n                  {uu_.\n                   \\<exists>m.\n                      uu_ =\n                      \\<guillemotleft>rderivs (replicate m a)\n r\\<guillemotright>});\n        v \\<in> {uu_. \\<exists>m. uu_ = replicate m a}; x = u @ v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>m.\n                                x =\n                                fin_cut_same a xa @ replicate m a) \\<and>\n                            xa \\<in> lang n r", "apply (auto simp: lang_rderivs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u m ma.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        \\<And>xs. \\<exists>m. xs = fin_cut_same a xs @ replicate m a;\n        u @ replicate ma a \\<in> lang n r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>ma.\n                                u @ replicate m a =\n                                fin_cut_same a x @ replicate ma a) \\<and>\n                            x \\<in> lang n r", "apply (drule meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u m ma.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        u @ replicate ma a \\<in> lang n r;\n        \\<exists>mb.\n           ?xs39 u m ma =\n           fin_cut_same a (?xs39 u m ma) @ replicate mb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>ma.\n                                u @ replicate m a =\n                                fin_cut_same a x @ replicate ma a) \\<and>\n                            x \\<in> lang n r", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u m ma mb.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        u @ replicate ma a \\<in> lang n r;\n        ?xs39 u m ma =\n        fin_cut_same a (?xs39 u m ma) @ replicate mb a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>ma.\n                                u @ replicate m a =\n                                fin_cut_same a x @ replicate ma a) \\<and>\n                            x \\<in> lang n r", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u m ma mb.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        u @ replicate ma a \\<in> lang n r;\n        ?xs39 u m ma =\n        fin_cut_same a (?xs39 u m ma) @ replicate mb a\\<rbrakk>\n       \\<Longrightarrow> u @ replicate m a =\n                         fin_cut_same a (?x43 u m ma mb) @\n                         replicate (?m45 u m ma mb) a\n 2. \\<And>u m ma mb.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        u @ replicate ma a \\<in> lang n r;\n        ?xs39 u m ma =\n        fin_cut_same a (?xs39 u m ma) @ replicate mb a\\<rbrakk>\n       \\<Longrightarrow> ?x43 u m ma mb \\<in> lang n r", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u m ma mb.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        u @ replicate ma a \\<in> lang n r;\n        ?xs39 u m ma =\n        fin_cut_same a (?xs39 u m ma) @ replicate mb a\\<rbrakk>\n       \\<Longrightarrow> ?x43 u m ma mb \\<in> lang n r\n 2. \\<And>u m ma mb.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        u @ replicate ma a \\<in> lang n r;\n        ?xs39 u m ma =\n        fin_cut_same a (?xs39 u m ma) @ replicate mb a\\<rbrakk>\n       \\<Longrightarrow> u @ replicate m a =\n                         fin_cut_same a (?x43 u m ma mb) @\n                         replicate (?m45 u m ma mb) a", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u m ma mb.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        u @ replicate ma a \\<in> lang n r;\n        ?xs39 u m ma =\n        fin_cut_same a (?xs39 u m ma) @ replicate mb a\\<rbrakk>\n       \\<Longrightarrow> u @ replicate m a =\n                         fin_cut_same a (u @ replicate ma a) @\n                         replicate (?m45 u m ma mb) a", "unfolding fin_cut_same_replicate"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u m ma mb.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        u @ replicate ma a \\<in> lang n r;\n        ?xs39 u m ma =\n        fin_cut_same a (?xs39 u m ma) @ replicate mb a\\<rbrakk>\n       \\<Longrightarrow> u @ replicate m a =\n                         fin_cut_same a u @ replicate (?m45 u m ma mb) a", "apply (erule trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u m ma mb.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        u @ replicate ma a \\<in> lang n r\\<rbrakk>\n       \\<Longrightarrow> fin_cut_same a (u @ replicate m a) @\n                         replicate mb a =\n                         fin_cut_same a u @ replicate (?m45 u m ma mb) a", "unfolding fin_cut_same_replicate"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u m ma mb.\n       \\<lbrakk>local.wf n r; a \\<in> \\<Sigma> n;\n        u @ replicate ma a \\<in> lang n r\\<rbrakk>\n       \\<Longrightarrow> fin_cut_same a u @ replicate mb a =\n                         fin_cut_same a u @ replicate (?m45 u m ma mb) a", "apply (rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun rderiv_and_add where\n  \"rderiv_and_add as (_ :: bool, rs) =\n    (let\n      r = \\<guillemotleft>rderiv as (hd rs)\\<guillemotright>\n    in if r \\<in> set rs then (False, rs) else (True, r # rs))\""], ["", "definition \"invar_rderiv_and_add as r brs \\<equiv>\n  (if fst brs then True else \\<guillemotleft>rderiv as (hd (snd brs))\\<guillemotright> \\<in> set (snd brs)) \\<and>\n  snd brs \\<noteq> [] \\<and> distinct (snd brs) \\<and>\n  (\\<forall>i < length (snd brs). snd brs ! i = \\<guillemotleft>rderivs (replicate (length (snd brs) - 1 - i) as) r\\<guillemotright>)\""], ["", "lemma invar_rderiv_and_add_init: \"invar_rderiv_and_add as r (True, [\\<guillemotleft>r\\<guillemotright>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_rderiv_and_add as r (True, [\\<guillemotleft>r\\<guillemotright>])", "unfolding invar_rderiv_and_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if fst (True, [\\<guillemotleft>r\\<guillemotright>]) then True\n     else \\<guillemotleft>rderiv as\n                           (hd (snd (True,\n                                     [\\<guillemotleft>r\\<guillemotright>])))\\<guillemotright>\n          \\<in> set (snd (True,\n                          [\\<guillemotleft>r\\<guillemotright>]))) \\<and>\n    snd (True, [\\<guillemotleft>r\\<guillemotright>]) \\<noteq> [] \\<and>\n    distinct (snd (True, [\\<guillemotleft>r\\<guillemotright>])) \\<and>\n    (\\<forall>i<length (snd (True, [\\<guillemotleft>r\\<guillemotright>])).\n        snd (True, [\\<guillemotleft>r\\<guillemotright>]) ! i =\n        \\<guillemotleft>rderivs\n                         (replicate\n                           (length\n                             (snd (True,\n                                   [\\<guillemotleft>r\\<guillemotright>])) -\n                            1 -\n                            i)\n                           as)\n                         r\\<guillemotright>)", "by auto"], ["", "lemma invar_rderiv_and_add_step: \"invar_rderiv_and_add as r brs \\<Longrightarrow> fst brs \\<Longrightarrow>\n  invar_rderiv_and_add as r (rderiv_and_add as brs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar_rderiv_and_add as r brs; fst brs\\<rbrakk>\n    \\<Longrightarrow> invar_rderiv_and_add as r (rderiv_and_add as brs)", "unfolding invar_rderiv_and_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if fst brs then True\n              else \\<guillemotleft>rderiv as (hd (snd brs))\\<guillemotright>\n                   \\<in> set (snd brs)) \\<and>\n             snd brs \\<noteq> [] \\<and>\n             distinct (snd brs) \\<and>\n             (\\<forall>i<length (snd brs).\n                 snd brs ! i =\n                 \\<guillemotleft>rderivs\n                                  (replicate (length (snd brs) - 1 - i) as)\n                                  r\\<guillemotright>);\n     fst brs\\<rbrakk>\n    \\<Longrightarrow> (if fst (rderiv_and_add as brs) then True\n                       else \\<guillemotleft>rderiv as\n       (hd (snd (rderiv_and_add as brs)))\\<guillemotright>\n                            \\<in> set (snd (rderiv_and_add as brs))) \\<and>\n                      snd (rderiv_and_add as brs) \\<noteq> [] \\<and>\n                      distinct (snd (rderiv_and_add as brs)) \\<and>\n                      (\\<forall>i<length (snd (rderiv_and_add as brs)).\n                          snd (rderiv_and_add as brs) ! i =\n                          \\<guillemotleft>rderivs\n     (replicate (length (snd (rderiv_and_add as brs)) - 1 - i) as)\n     r\\<guillemotright>)", "by (cases brs) (auto simp:\n    Let_def nth_Cons' ACI_norm_rderiv rderivs_snoc[symmetric] neq_Nil_conv replicate_append_same)"], ["", "lemma rderivs_replicate_mult: \"\\<lbrakk>\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>; i > 0\\<rbrakk> \\<Longrightarrow>\n  \\<guillemotleft>rderivs (replicate (m * i) as) r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> =\n             \\<guillemotleft>r\\<guillemotright>;\n     0 < i\\<rbrakk>\n    \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (m * i) as)\n r\\<guillemotright> =\n                      \\<guillemotleft>r\\<guillemotright>", "proof (induct m arbitrary: r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<guillemotleft>rderivs (replicate i as)\n                                 r\\<guillemotright> =\n                \\<guillemotleft>r\\<guillemotright>;\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (0 * i) as)\n    r\\<guillemotright> =\n                         \\<guillemotleft>r\\<guillemotright>\n 2. \\<And>m r.\n       \\<lbrakk>\\<And>r.\n                   \\<lbrakk>\\<guillemotleft>rderivs (replicate i as)\n       r\\<guillemotright> =\n                            \\<guillemotleft>r\\<guillemotright>;\n                    0 < i\\<rbrakk>\n                   \\<Longrightarrow> \\<guillemotleft>rderivs\n                (replicate (m * i) as) r\\<guillemotright> =\n                                     \\<guillemotleft>r\\<guillemotright>;\n        \\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright>;\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (Suc m * i) as)\n    r\\<guillemotright> =\n                         \\<guillemotleft>r\\<guillemotright>", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<guillemotleft>rderivs (replicate i as) ?r\\<guillemotright> =\n           \\<guillemotleft>?r\\<guillemotright>;\n   0 < i\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (m * i) as)\n                                     ?r\\<guillemotright> =\n                    \\<guillemotleft>?r\\<guillemotright>\n  \\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n  0 < i\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<guillemotleft>rderivs (replicate i as)\n                                 r\\<guillemotright> =\n                \\<guillemotleft>r\\<guillemotright>;\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (0 * i) as)\n    r\\<guillemotright> =\n                         \\<guillemotleft>r\\<guillemotright>\n 2. \\<And>m r.\n       \\<lbrakk>\\<And>r.\n                   \\<lbrakk>\\<guillemotleft>rderivs (replicate i as)\n       r\\<guillemotright> =\n                            \\<guillemotleft>r\\<guillemotright>;\n                    0 < i\\<rbrakk>\n                   \\<Longrightarrow> \\<guillemotleft>rderivs\n                (replicate (m * i) as) r\\<guillemotright> =\n                                     \\<guillemotleft>r\\<guillemotright>;\n        \\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright>;\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (Suc m * i) as)\n    r\\<guillemotright> =\n                         \\<guillemotleft>r\\<guillemotright>", "hence \"\\<guillemotleft>rderivs (replicate (m * i) as) \\<guillemotleft>rderivs (replicate i as) r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<guillemotleft>rderivs (replicate i as) ?r\\<guillemotright> =\n           \\<guillemotleft>?r\\<guillemotright>;\n   0 < i\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (m * i) as)\n                                     ?r\\<guillemotright> =\n                    \\<guillemotleft>?r\\<guillemotright>\n  \\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n  0 < i\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m * i) as)\n                     \\<guillemotleft>rderivs (replicate i as)\nr\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>r\\<guillemotright>", "by (auto simp: ACI_norm_rderivs)"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (m * i) as)\n                   \\<guillemotleft>rderivs (replicate i as)\n                                    r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<guillemotleft>rderivs (replicate i as)\n                                 r\\<guillemotright> =\n                \\<guillemotleft>r\\<guillemotright>;\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (0 * i) as)\n    r\\<guillemotright> =\n                         \\<guillemotleft>r\\<guillemotright>\n 2. \\<And>m r.\n       \\<lbrakk>\\<And>r.\n                   \\<lbrakk>\\<guillemotleft>rderivs (replicate i as)\n       r\\<guillemotright> =\n                            \\<guillemotleft>r\\<guillemotright>;\n                    0 < i\\<rbrakk>\n                   \\<Longrightarrow> \\<guillemotleft>rderivs\n                (replicate (m * i) as) r\\<guillemotright> =\n                                     \\<guillemotleft>r\\<guillemotright>;\n        \\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright>;\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (Suc m * i) as)\n    r\\<guillemotright> =\n                         \\<guillemotleft>r\\<guillemotright>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<guillemotleft>rderivs (replicate (m * i) as)\n                   \\<guillemotleft>rderivs (replicate i as)\n                                    r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (Suc m * i) as) r\\<guillemotright> =\n    \\<guillemotleft>r\\<guillemotright>", "by (auto simp: ACI_norm_rderivs replicate_add rderivs_append)"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (Suc m * i) as) r\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>\\<guillemotleft>rderivs (replicate i as)\n                                 r\\<guillemotright> =\n                \\<guillemotleft>r\\<guillemotright>;\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (0 * i) as)\n    r\\<guillemotright> =\n                         \\<guillemotleft>r\\<guillemotright>", "qed simp"], ["", "lemma rderivs_replicate_mult_rest: \n  assumes \"\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\" \"k < i\"\n  shows \"\\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> = \\<guillemotleft>rderivs (replicate k as) r\\<guillemotright>\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate k as) r\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate k as) r\\<guillemotright>", "have \"?L = \\<guillemotleft>rderivs (replicate k as) \\<guillemotleft>rderivs (replicate (m * i) as) r\\<guillemotright>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate k as)\n                     \\<guillemotleft>rderivs (replicate (m * i) as)\nr\\<guillemotright>\\<guillemotright>", "by (simp add: ACI_norm_rderivs replicate_add rderivs_append)"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate k as)\n                   \\<guillemotleft>rderivs (replicate (m * i) as)\n                                    r\\<guillemotright>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate k as) r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate k as)\n                   \\<guillemotleft>rderivs (replicate (m * i) as)\n                                    r\\<guillemotright>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate k as) r\\<guillemotright>", "have \"\\<guillemotleft>rderivs (replicate (m * i) as) r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m * i) as) r\\<guillemotright> =\n    \\<guillemotleft>r\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  \\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n  k < i\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m * i) as) r\\<guillemotright> =\n    \\<guillemotleft>r\\<guillemotright>", "by (simp add: rderivs_replicate_mult)"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (m * i) as) r\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate k as) r\\<guillemotright>", "finally"], ["proof (chain)\npicking this:\n  \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate k as)\n                   \\<guillemotleft>r\\<guillemotright>\\<guillemotright>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate k as)\n                   \\<guillemotleft>r\\<guillemotright>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate k as) r\\<guillemotright>", "by (simp add: ACI_norm_rderivs)"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (m * i + k) as) r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate k as) r\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rderivs_replicate_mod: \n  assumes \"\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\" \"i > 0\"\n  shows \"\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> = \\<guillemotleft>rderivs (replicate (m mod i) as) r\\<guillemotright>\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate (m mod i) as) r\\<guillemotright>", "by (subst div_mult_mod_eq[symmetric, of m i])\n    (intro rderivs_replicate_mult_rest[OF assms(1)] mod_less_divisor[OF assms(2)])"], ["", "lemma rderivs_replicate_diff: \"\\<lbrakk>\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> = \\<guillemotleft>rderivs (replicate j as) r\\<guillemotright>; i > j\\<rbrakk> \\<Longrightarrow>\n  \\<guillemotleft>rderivs (replicate (i - j) as) (rderivs (replicate j as) r)\\<guillemotright> = \\<guillemotleft>rderivs (replicate j as) r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> =\n             \\<guillemotleft>rderivs (replicate j as) r\\<guillemotright>;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (i - j) as)\n (rderivs (replicate j as) r)\\<guillemotright> =\n                      \\<guillemotleft>rderivs (replicate j as)\n r\\<guillemotright>", "unfolding rderivs_append[symmetric] replicate_add[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<guillemotleft>rderivs (replicate i as) r\\<guillemotright> =\n             \\<guillemotleft>rderivs (replicate j as) r\\<guillemotright>;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> \\<guillemotleft>rderivs (replicate (j + (i - j)) as)\n r\\<guillemotright> =\n                      \\<guillemotleft>rderivs (replicate j as)\n r\\<guillemotright>", "by auto"], ["", "lemma samequot_wf:\n  assumes \"wf n r\" \"while_option fst (rderiv_and_add as) (True, [\\<guillemotleft>r\\<guillemotright>]) = Some (b, rs)\"\n  shows \"wf n (PLUS rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n (PLUS rs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.wf n (PLUS rs)", "have \"\\<not> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> b", "using while_option_stop[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<not> fst (b, rs)\n\ngoal (1 subgoal):\n 1. \\<not> b", "by simp"], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. local.wf n (PLUS rs)", "from while_option_rule[where P=\"invar_rderiv_and_add as r\",\n    OF invar_rderiv_and_add_step assms(2) invar_rderiv_and_add_init]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>s.\n              \\<lbrakk>invar_rderiv_and_add as r s; fst s\\<rbrakk>\n              \\<Longrightarrow> invar_rderiv_and_add as r s;\n   \\<And>s.\n      \\<lbrakk>invar_rderiv_and_add as r s; fst s\\<rbrakk>\n      \\<Longrightarrow> fst s\\<rbrakk>\n  \\<Longrightarrow> invar_rderiv_and_add as r (b, rs)", "have *: \"invar_rderiv_and_add as r (b, rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>s.\n              \\<lbrakk>invar_rderiv_and_add as r s; fst s\\<rbrakk>\n              \\<Longrightarrow> invar_rderiv_and_add as r s;\n   \\<And>s.\n      \\<lbrakk>invar_rderiv_and_add as r s; fst s\\<rbrakk>\n      \\<Longrightarrow> fst s\\<rbrakk>\n  \\<Longrightarrow> invar_rderiv_and_add as r (b, rs)\n\ngoal (1 subgoal):\n 1. invar_rderiv_and_add as r (b, rs)", "by simp"], ["proof (state)\nthis:\n  invar_rderiv_and_add as r (b, rs)\n\ngoal (1 subgoal):\n 1. local.wf n (PLUS rs)", "thus \"wf n (PLUS rs)\""], ["proof (prove)\nusing this:\n  invar_rderiv_and_add as r (b, rs)\n\ngoal (1 subgoal):\n 1. local.wf n (PLUS rs)", "unfolding invar_rderiv_and_add_def wf_PLUS"], ["proof (prove)\nusing this:\n  (if fst (b, rs) then True\n   else \\<guillemotleft>rderiv as (hd (snd (b, rs)))\\<guillemotright>\n        \\<in> set (snd (b, rs))) \\<and>\n  snd (b, rs) \\<noteq> [] \\<and>\n  distinct (snd (b, rs)) \\<and>\n  (\\<forall>i<length (snd (b, rs)).\n      snd (b, rs) ! i =\n      \\<guillemotleft>rderivs (replicate (length (snd (b, rs)) - 1 - i) as)\n                       r\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. Ball (set rs) (local.wf n)", "by (auto simp: in_set_conv_nth wf_rderivs[OF assms(1)])"], ["proof (state)\nthis:\n  local.wf n (PLUS rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma samequot_soundness:\n  assumes \"while_option fst (rderiv_and_add as) (True, [\\<guillemotleft>r\\<guillemotright>]) = Some (b, rs)\"\n  shows \"lang n (PLUS rs) = \\<Union> (lang n ` {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> | m. True})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "have \"\\<not> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> b", "using while_option_stop[OF assms]"], ["proof (prove)\nusing this:\n  \\<not> fst (b, rs)\n\ngoal (1 subgoal):\n 1. \\<not> b", "by simp"], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "moreover"], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "from while_option_rule[where P=\"invar_rderiv_and_add as r\",\n    OF invar_rderiv_and_add_step assms invar_rderiv_and_add_init]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>s.\n              \\<lbrakk>invar_rderiv_and_add as r s; fst s\\<rbrakk>\n              \\<Longrightarrow> invar_rderiv_and_add as r s;\n   \\<And>s.\n      \\<lbrakk>invar_rderiv_and_add as r s; fst s\\<rbrakk>\n      \\<Longrightarrow> fst s\\<rbrakk>\n  \\<Longrightarrow> invar_rderiv_and_add as r (b, rs)", "have *: \"invar_rderiv_and_add as r (b, rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>s.\n              \\<lbrakk>invar_rderiv_and_add as r s; fst s\\<rbrakk>\n              \\<Longrightarrow> invar_rderiv_and_add as r s;\n   \\<And>s.\n      \\<lbrakk>invar_rderiv_and_add as r s; fst s\\<rbrakk>\n      \\<Longrightarrow> fst s\\<rbrakk>\n  \\<Longrightarrow> invar_rderiv_and_add as r (b, rs)\n\ngoal (1 subgoal):\n 1. invar_rderiv_and_add as r (b, rs)", "by simp"], ["proof (state)\nthis:\n  invar_rderiv_and_add as r (b, rs)\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> b\n  invar_rderiv_and_add as r (b, rs)", "obtain i where i: \"i < length rs\" and \"\\<guillemotleft>rderivs (replicate (length rs - Suc i) as) r\\<guillemotright> =\n       \\<guillemotleft>rderivs (replicate (Suc (length rs - Suc 0)) as) r\\<guillemotright>\" (is \"\\<guillemotleft>rderivs ?x r\\<guillemotright> = _\")"], ["proof (prove)\nusing this:\n  \\<not> b\n  invar_rderiv_and_add as r (b, rs)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length rs;\n         \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                          r\\<guillemotright> =\n         \\<guillemotleft>rderivs (replicate (Suc (length rs - Suc 0)) as)\n                          r\\<guillemotright>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding invar_rderiv_and_add_def"], ["proof (prove)\nusing this:\n  \\<not> b\n  (if fst (b, rs) then True\n   else \\<guillemotleft>rderiv as (hd (snd (b, rs)))\\<guillemotright>\n        \\<in> set (snd (b, rs))) \\<and>\n  snd (b, rs) \\<noteq> [] \\<and>\n  distinct (snd (b, rs)) \\<and>\n  (\\<forall>i<length (snd (b, rs)).\n      snd (b, rs) ! i =\n      \\<guillemotleft>rderivs (replicate (length (snd (b, rs)) - 1 - i) as)\n                       r\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length rs;\n         \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                          r\\<guillemotright> =\n         \\<guillemotleft>rderivs (replicate (Suc (length rs - Suc 0)) as)\n                          r\\<guillemotright>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth hd_conv_nth ACI_norm_rderiv\n      rderivs_snoc[symmetric] replicate_append_same)"], ["proof (state)\nthis:\n  i < length rs\n  \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                   r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (Suc (length rs - Suc 0)) as)\n                   r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "with *"], ["proof (chain)\npicking this:\n  invar_rderiv_and_add as r (b, rs)\n  i < length rs\n  \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                   r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (Suc (length rs - Suc 0)) as)\n                   r\\<guillemotright>", "have \"\\<guillemotleft>rderivs ?x r\\<guillemotright> = \\<guillemotleft>rderivs (replicate (length rs) as) r\\<guillemotright>\""], ["proof (prove)\nusing this:\n  invar_rderiv_and_add as r (b, rs)\n  i < length rs\n  \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                   r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (Suc (length rs - Suc 0)) as)\n                   r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                     r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate (length rs) as) r\\<guillemotright>", "by (auto simp: invar_rderiv_and_add_def)"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                   r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (length rs) as) r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "with i"], ["proof (chain)\npicking this:\n  i < length rs\n  \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                   r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (length rs) as) r\\<guillemotright>", "have cyc: \"\\<guillemotleft>rderivs (replicate (Suc i) as) (rderivs ?x r)\\<guillemotright> = \\<guillemotleft>rderivs ?x r\\<guillemotright>\""], ["proof (prove)\nusing this:\n  i < length rs\n  \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                   r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (length rs) as) r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (Suc i) as)\n                     (rderivs (replicate (length rs - Suc i) as)\n                       r)\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                     r\\<guillemotright>", "by (fastforce dest: rderivs_replicate_diff[OF sym])"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (Suc i) as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                   r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "{"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (Suc i) as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                   r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "have \"\\<exists>i<length rs. rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "proof (cases \"m > length rs - Suc i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "case True"], ["proof (state)\nthis:\n  length rs - Suc i < m\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "with i"], ["proof (chain)\npicking this:\n  i < length rs\n  length rs - Suc i < m", "obtain m' where m: \"m = m' + length rs - Suc i\""], ["proof (prove)\nusing this:\n  i < length rs\n  length rs - Suc i < m\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        m = m' + length rs - Suc i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto intro: exI[of _ \"m - (length rs - Suc i)\"])"], ["proof (state)\nthis:\n  m = m' + length rs - Suc i\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "with i"], ["proof (chain)\npicking this:\n  i < length rs\n  m = m' + length rs - Suc i", "have \"\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> = \\<guillemotleft>rderivs (replicate m' as) (rderivs ?x r)\\<guillemotright>\""], ["proof (prove)\nusing this:\n  i < length rs\n  m = m' + length rs - Suc i\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate m' as)\n                     (rderivs (replicate (length rs - Suc i) as)\n                       r)\\<guillemotright>", "unfolding replicate_add[symmetric] rderivs_append[symmetric]"], ["proof (prove)\nusing this:\n  i < length rs\n  m = m' + length rs - Suc i\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate (length rs - Suc i + m') as)\n                     r\\<guillemotright>", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate m' as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright>\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate m' as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright>\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "from cyc"], ["proof (chain)\npicking this:\n  \\<guillemotleft>rderivs (replicate (Suc i) as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                   r\\<guillemotright>", "have \"\\<dots> = \\<guillemotleft>rderivs (replicate (m' mod (Suc i)) as) (rderivs ?x r)\\<guillemotright>\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>rderivs (replicate (Suc i) as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (length rs - Suc i) as)\n                   r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate m' as)\n                     (rderivs (replicate (length rs - Suc i) as)\n                       r)\\<guillemotright> =\n    \\<guillemotleft>rderivs (replicate (m' mod Suc i) as)\n                     (rderivs (replicate (length rs - Suc i) as)\n                       r)\\<guillemotright>", "by (elim rderivs_replicate_mod) simp"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate m' as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (m' mod Suc i) as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright>\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate m' as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (m' mod Suc i) as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright>\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "from i"], ["proof (chain)\npicking this:\n  i < length rs", "have \"\\<dots> = \\<guillemotleft>rderivs (replicate (m' mod (Suc i) + length rs - Suc i) as) r\\<guillemotright>\""], ["proof (prove)\nusing this:\n  i < length rs\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs (replicate (m' mod Suc i) as)\n                     (rderivs (replicate (length rs - Suc i) as)\n                       r)\\<guillemotright> =\n    \\<guillemotleft>rderivs\n                     (replicate (m' mod Suc i + length rs - Suc i) as)\n                     r\\<guillemotright>", "unfolding rderivs_append[symmetric] replicate_add[symmetric]"], ["proof (prove)\nusing this:\n  i < length rs\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs\n                     (replicate (length rs - Suc i + m' mod Suc i) as)\n                     r\\<guillemotright> =\n    \\<guillemotleft>rderivs\n                     (replicate (m' mod Suc i + length rs - Suc i) as)\n                     r\\<guillemotright>", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (m' mod Suc i) as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (m' mod Suc i + length rs - Suc i) as)\n                   r\\<guillemotright>\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (m' mod Suc i) as)\n                   (rderivs (replicate (length rs - Suc i) as)\n                     r)\\<guillemotright> =\n  \\<guillemotleft>rderivs (replicate (m' mod Suc i + length rs - Suc i) as)\n                   r\\<guillemotright>\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "from m i"], ["proof (chain)\npicking this:\n  m = m' + length rs - Suc i\n  i < length rs", "have \"\\<dots> = \\<guillemotleft>rderivs (replicate ((m - (length rs - Suc i)) mod (Suc i) + length rs - Suc i) as) r\\<guillemotright>\""], ["proof (prove)\nusing this:\n  m = m' + length rs - Suc i\n  i < length rs\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs\n                     (replicate (m' mod Suc i + length rs - Suc i) as)\n                     r\\<guillemotright> =\n    \\<guillemotleft>rderivs\n                     (replicate\n                       ((m - (length rs - Suc i)) mod Suc i + length rs -\n                        Suc i)\n                       as)\n                     r\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (m' mod Suc i + length rs - Suc i) as)\n                   r\\<guillemotright> =\n  \\<guillemotleft>rderivs\n                   (replicate\n                     ((m - (length rs - Suc i)) mod Suc i + length rs -\n                      Suc i)\n                     as)\n                   r\\<guillemotright>\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs (replicate (m' mod Suc i + length rs - Suc i) as)\n                   r\\<guillemotright> =\n  \\<guillemotleft>rderivs\n                   (replicate\n                     ((m - (length rs - Suc i)) mod Suc i + length rs -\n                      Suc i)\n                     as)\n                   r\\<guillemotright>\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "have \"\\<dots> = \\<guillemotleft>rderivs (replicate (length rs - Suc (i - (m - (length rs - Suc i)) mod (Suc i))) as) r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>rderivs\n                     (replicate\n                       ((m - (length rs - Suc i)) mod Suc i + length rs -\n                        Suc i)\n                       as)\n                     r\\<guillemotright> =\n    \\<guillemotleft>rderivs\n                     (replicate\n                       (length rs -\n                        Suc (i - (m - (length rs - Suc i)) mod Suc i))\n                       as)\n                     r\\<guillemotright>", "by (subst Suc_diff_le[symmetric])\n          (metis less_Suc_eq_le mod_less_divisor zero_less_Suc, simp add: add.commute)"], ["proof (state)\nthis:\n  \\<guillemotleft>rderivs\n                   (replicate\n                     ((m - (length rs - Suc i)) mod Suc i + length rs -\n                      Suc i)\n                     as)\n                   r\\<guillemotright> =\n  \\<guillemotleft>rderivs\n                   (replicate\n                     (length rs -\n                      Suc (i - (m - (length rs - Suc i)) mod Suc i))\n                     as)\n                   r\\<guillemotright>\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "finally"], ["proof (chain)\npicking this:\n  \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n  \\<guillemotleft>rderivs\n                   (replicate\n                     (length rs -\n                      Suc (i - (m - (length rs - Suc i)) mod Suc i))\n                     as)\n                   r\\<guillemotright>", "have \"\\<exists>j < length rs. \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> = \\<guillemotleft>rderivs (replicate (length rs - Suc j) as) r\\<guillemotright>\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n  \\<guillemotleft>rderivs\n                   (replicate\n                     (length rs -\n                      Suc (i - (m - (length rs - Suc i)) mod Suc i))\n                     as)\n                   r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<exists>j<length rs.\n       \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n       \\<guillemotleft>rderivs (replicate (length rs - Suc j) as)\n                        r\\<guillemotright>", "using i"], ["proof (prove)\nusing this:\n  \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n  \\<guillemotleft>rderivs\n                   (replicate\n                     (length rs -\n                      Suc (i - (m - (length rs - Suc i)) mod Suc i))\n                     as)\n                   r\\<guillemotright>\n  i < length rs\n\ngoal (1 subgoal):\n 1. \\<exists>j<length rs.\n       \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n       \\<guillemotleft>rderivs (replicate (length rs - Suc j) as)\n                        r\\<guillemotright>", "by (metis less_imp_diff_less)"], ["proof (state)\nthis:\n  \\<exists>j<length rs.\n     \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n     \\<guillemotleft>rderivs (replicate (length rs - Suc j) as)\n                      r\\<guillemotright>\n\ngoal (2 subgoals):\n 1. length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n 2. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "with *"], ["proof (chain)\npicking this:\n  invar_rderiv_and_add as r (b, rs)\n  \\<exists>j<length rs.\n     \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n     \\<guillemotleft>rderivs (replicate (length rs - Suc j) as)\n                      r\\<guillemotright>", "show ?thesis"], ["proof (prove)\nusing this:\n  invar_rderiv_and_add as r (b, rs)\n  \\<exists>j<length rs.\n     \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n     \\<guillemotleft>rderivs (replicate (length rs - Suc j) as)\n                      r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "unfolding invar_rderiv_and_add_def"], ["proof (prove)\nusing this:\n  (if fst (b, rs) then True\n   else \\<guillemotleft>rderiv as (hd (snd (b, rs)))\\<guillemotright>\n        \\<in> set (snd (b, rs))) \\<and>\n  snd (b, rs) \\<noteq> [] \\<and>\n  distinct (snd (b, rs)) \\<and>\n  (\\<forall>i<length (snd (b, rs)).\n      snd (b, rs) ! i =\n      \\<guillemotleft>rderivs (replicate (length (snd (b, rs)) - 1 - i) as)\n                       r\\<guillemotright>)\n  \\<exists>j<length rs.\n     \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> =\n     \\<guillemotleft>rderivs (replicate (length rs - Suc j) as)\n                      r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length rs.\n     rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "case False"], ["proof (state)\nthis:\n  \\<not> length rs - Suc i < m\n\ngoal (1 subgoal):\n 1. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "with i"], ["proof (chain)\npicking this:\n  i < length rs\n  \\<not> length rs - Suc i < m", "have \"\\<exists>j < length rs. m = length rs - Suc j\""], ["proof (prove)\nusing this:\n  i < length rs\n  \\<not> length rs - Suc i < m\n\ngoal (1 subgoal):\n 1. \\<exists>j<length rs. m = length rs - Suc j", "by (induct m)\n          (metis diff_self_eq_0 gr_implies_not0 lessI nat.exhaust,\n           metis (no_types) One_nat_def Suc_diff_Suc diff_Suc_1 gr0_conv_Suc less_imp_diff_less\n             not_less_eq not_less_iff_gr_or_eq)"], ["proof (state)\nthis:\n  \\<exists>j<length rs. m = length rs - Suc j\n\ngoal (1 subgoal):\n 1. \\<not> length rs - Suc i < m \\<Longrightarrow>\n    \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "with *"], ["proof (chain)\npicking this:\n  invar_rderiv_and_add as r (b, rs)\n  \\<exists>j<length rs. m = length rs - Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  invar_rderiv_and_add as r (b, rs)\n  \\<exists>j<length rs. m = length rs - Suc j\n\ngoal (1 subgoal):\n 1. \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "unfolding invar_rderiv_and_add_def"], ["proof (prove)\nusing this:\n  (if fst (b, rs) then True\n   else \\<guillemotleft>rderiv as (hd (snd (b, rs)))\\<guillemotright>\n        \\<in> set (snd (b, rs))) \\<and>\n  snd (b, rs) \\<noteq> [] \\<and>\n  distinct (snd (b, rs)) \\<and>\n  (\\<forall>i<length (snd (b, rs)).\n      snd (b, rs) ! i =\n      \\<guillemotleft>rderivs (replicate (length (snd (b, rs)) - 1 - i) as)\n                       r\\<guillemotright>)\n  \\<exists>j<length rs. m = length rs - Suc j\n\ngoal (1 subgoal):\n 1. \\<exists>i<length rs.\n       rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length rs.\n     rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<length rs.\n     rs ! i = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "}"], ["proof (state)\nthis:\n  \\<exists>i<length rs.\n     rs ! i = \\<guillemotleft>rderivs (replicate ?m2 as) r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "hence \"\\<Union> (lang n ` {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m. True}) \\<subseteq> lang n (PLUS rs)\""], ["proof (prove)\nusing this:\n  \\<exists>i<length rs.\n     rs ! i = \\<guillemotleft>rderivs (replicate ?m2 as) r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})\n    \\<subseteq> lang n (PLUS rs)", "by (fastforce simp: in_set_conv_nth intro!: bexI[rotated])"], ["proof (state)\nthis:\n  \\<Union>\n   (lang n `\n    {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m. True})\n  \\<subseteq> lang n (PLUS rs)\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "moreover"], ["proof (state)\nthis:\n  \\<Union>\n   (lang n `\n    {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m. True})\n  \\<subseteq> lang n (PLUS rs)\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "from *"], ["proof (chain)\npicking this:\n  invar_rderiv_and_add as r (b, rs)", "have \"lang n (PLUS rs) \\<subseteq> \\<Union> (lang n ` {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m. True})\""], ["proof (prove)\nusing this:\n  invar_rderiv_and_add as r (b, rs)\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs)\n    \\<subseteq> \\<Union>\n                 (lang n `\n                  {\\<guillemotleft>rderivs (replicate m as)\n                                    r\\<guillemotright> |\n                   m. True})", "unfolding invar_rderiv_and_add_def"], ["proof (prove)\nusing this:\n  (if fst (b, rs) then True\n   else \\<guillemotleft>rderiv as (hd (snd (b, rs)))\\<guillemotright>\n        \\<in> set (snd (b, rs))) \\<and>\n  snd (b, rs) \\<noteq> [] \\<and>\n  distinct (snd (b, rs)) \\<and>\n  (\\<forall>i<length (snd (b, rs)).\n      snd (b, rs) ! i =\n      \\<guillemotleft>rderivs (replicate (length (snd (b, rs)) - 1 - i) as)\n                       r\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs)\n    \\<subseteq> \\<Union>\n                 (lang n `\n                  {\\<guillemotleft>rderivs (replicate m as)\n                                    r\\<guillemotright> |\n                   m. True})", "by (fastforce simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  lang n (PLUS rs)\n  \\<subseteq> \\<Union>\n               (lang n `\n                {\\<guillemotleft>rderivs (replicate m as)\n                                  r\\<guillemotright> |\n                 m. True})\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "ultimately"], ["proof (chain)\npicking this:\n  \\<Union>\n   (lang n `\n    {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m. True})\n  \\<subseteq> lang n (PLUS rs)\n  lang n (PLUS rs)\n  \\<subseteq> \\<Union>\n               (lang n `\n                {\\<guillemotleft>rderivs (replicate m as)\n                                  r\\<guillemotright> |\n                 m. True})", "show \"lang n (PLUS rs) = \\<Union> (lang n ` {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m. True})\""], ["proof (prove)\nusing this:\n  \\<Union>\n   (lang n `\n    {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m. True})\n  \\<subseteq> lang n (PLUS rs)\n  lang n (PLUS rs)\n  \\<subseteq> \\<Union>\n               (lang n `\n                {\\<guillemotleft>rderivs (replicate m as)\n                                  r\\<guillemotright> |\n                 m. True})\n\ngoal (1 subgoal):\n 1. lang n (PLUS rs) =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True})", "by blast"], ["proof (state)\nthis:\n  lang n (PLUS rs) =\n  \\<Union>\n   (lang n `\n    {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m. True})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_subset_card: \"\\<lbrakk>finite X; distinct (x # xs); set (x # xs) \\<subseteq> X\\<rbrakk> \\<Longrightarrow> length xs < card X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; distinct (x # xs);\n     set (x # xs) \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> length xs < card X", "by (metis card_mono distinct_card impossible_Cons not_le_imp_less order_trans)"], ["", "lemma samequot_termination:\n  assumes \"while_option fst (rderiv_and_add as) (True, [\\<guillemotleft>r\\<guillemotright>]) = None\" (is \"?cl = None\")\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "let ?D =  \"{\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> | m . True}\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "let ?f = \"\\<lambda>(b, rs). card ?D + 1 - length rs + (if b then 1 else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<exists>st. ?cl = Some st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>st.\n       while_option fst (rderiv_and_add as)\n        (True, [\\<guillemotleft>r\\<guillemotright>]) =\n       Some st", "apply (rule measure_while_option_Some[of \"invar_rderiv_and_add as r\" _ _ ?f])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>invar_rderiv_and_add as r s; fst s\\<rbrakk>\n       \\<Longrightarrow> invar_rderiv_and_add as r\n                          (rderiv_and_add as s) \\<and>\n                         (case rderiv_and_add as s of\n                          (b, rs) \\<Rightarrow>\n                            card\n                             {\\<guillemotleft>rderivs (replicate m as)\n         r\\<guillemotright> |\n                              m. True} +\n                            1 -\n                            length rs +\n                            (if b then 1 else 0))\n                         < (case s of\n                            (b, rs) \\<Rightarrow>\n                              card\n                               {\\<guillemotleft>rderivs (replicate m as)\n           r\\<guillemotright> |\n                                m. True} +\n                              1 -\n                              length rs +\n                              (if b then 1 else 0))\n 2. invar_rderiv_and_add as r (True, [\\<guillemotleft>r\\<guillemotright>])", "apply (auto simp: invar_rderiv_and_add_init invar_rderiv_and_add_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>invar_rderiv_and_add as r (True, b); a\\<rbrakk>\n       \\<Longrightarrow> (case let r = \\<guillemotleft>rderiv as\n                  (hd b)\\<guillemotright>\n                               in if r \\<in> set b then (False, b)\n                                  else (True, r # b) of\n                          (b, rs) \\<Rightarrow>\n                            Suc (card\n                                  {uu_.\n                                   \\<exists>m.\nuu_ = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>}) -\n                            length rs +\n                            (if b then 1 else 0))\n                         < Suc (Suc (card\n{uu_.\n \\<exists>m.\n    uu_ = \\<guillemotleft>rderivs (replicate m as) r\\<guillemotright>}) -\n                                length b)", "apply (auto simp: invar_rderiv_and_add_def Let_def neq_Nil_conv in_set_conv_nth\n       intro!: diff_less_mono2 length_subset_card[OF finite_rderivs_same, simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a y ys i.\n       \\<lbrakk>a;\n        \\<forall>i<Suc (length ys).\n           (y # ys) ! i =\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright>;\n        \\<forall>i<Suc (length ys).\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright> \\<noteq>\n           \\<guillemotleft>rderiv as y\\<guillemotright>;\n        \\<forall>i<length ys. ys ! i \\<noteq> y; distinct ys; i < length ys;\n        ys ! i = ?x16 True y ys\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a y ys.\n       \\<lbrakk>a;\n        \\<forall>i<Suc (length ys).\n           (y # ys) ! i =\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright>;\n        \\<forall>i<Suc (length ys).\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright> \\<noteq>\n           \\<guillemotleft>rderiv as y\\<guillemotright>;\n        \\<forall>i<length ys. ys ! i \\<noteq> y; distinct ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            ?x16 True y ys =\n                            \\<guillemotleft>rderivs (replicate m as)\n       r\\<guillemotright>\n 3. \\<And>a y ys i.\n       \\<lbrakk>a;\n        \\<forall>i<Suc (length ys).\n           (y # ys) ! i =\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright>;\n        \\<forall>i<Suc (length ys).\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright> \\<noteq>\n           \\<guillemotleft>rderiv as y\\<guillemotright>;\n        \\<forall>i<length ys. ys ! i \\<noteq> y; distinct ys;\n        i < length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            ys ! i =\n                            \\<guillemotleft>rderivs (replicate m as)\n       r\\<guillemotright>", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a y ys.\n       \\<lbrakk>a;\n        \\<forall>i<Suc (length ys).\n           (y # ys) ! i =\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright>;\n        \\<forall>i<Suc (length ys).\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright> \\<noteq>\n           \\<guillemotleft>rderiv as y\\<guillemotright>;\n        \\<forall>i<length ys. ys ! i \\<noteq> y; distinct ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            y =\n                            \\<guillemotleft>rderivs (replicate m as)\n       r\\<guillemotright>\n 2. \\<And>a y ys i.\n       \\<lbrakk>a;\n        \\<forall>i<Suc (length ys).\n           (y # ys) ! i =\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright>;\n        \\<forall>i<Suc (length ys).\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright> \\<noteq>\n           \\<guillemotleft>rderiv as y\\<guillemotright>;\n        \\<forall>i<length ys. ys ! i \\<noteq> y; distinct ys;\n        i < length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            ys ! i =\n                            \\<guillemotleft>rderivs (replicate m as)\n       r\\<guillemotright>", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y ys i.\n       \\<lbrakk>a;\n        \\<forall>i<Suc (length ys).\n           (y # ys) ! i =\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright>;\n        \\<forall>i<Suc (length ys).\n           \\<guillemotleft>rderivs (replicate (length ys - i) as)\n                            r\\<guillemotright> \\<noteq>\n           \\<guillemotleft>rderiv as y\\<guillemotright>;\n        \\<forall>i<length ys. ys ! i \\<noteq> y; distinct ys;\n        i < length ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            ys ! i =\n                            \\<guillemotleft>rderivs (replicate m as)\n       r\\<guillemotright>", "apply (metis Suc_less_eq nth_Cons_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>st.\n     while_option fst (rderiv_and_add as)\n      (True, [\\<guillemotleft>r\\<guillemotright>]) =\n     Some st\n\ngoal (1 subgoal):\n 1. False", "with assms"], ["proof (chain)\npicking this:\n  while_option fst (rderiv_and_add as)\n   (True, [\\<guillemotleft>r\\<guillemotright>]) =\n  None\n  \\<exists>st.\n     while_option fst (rderiv_and_add as)\n      (True, [\\<guillemotleft>r\\<guillemotright>]) =\n     Some st", "show False"], ["proof (prove)\nusing this:\n  while_option fst (rderiv_and_add as)\n   (True, [\\<guillemotleft>r\\<guillemotright>]) =\n  None\n  \\<exists>st.\n     while_option fst (rderiv_and_add as)\n      (True, [\\<guillemotleft>r\\<guillemotright>]) =\n     Some st\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"samequot_exec a r =\n  Times (PLUS (snd (the (while_option fst (rderiv_and_add a) (True, [\\<guillemotleft>r\\<guillemotright>]))))) (Star (Atom (singleton a)))\""], ["", "lemma wf_samequot_exec: \"\\<lbrakk>wf n r; as \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> wf n (samequot_exec as r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; as \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> local.wf n (samequot_exec as r)", "unfolding samequot_exec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; as \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> local.wf n\n                       (Times\n                         (PLUS\n                           (snd (the (while_option fst (rderiv_and_add as)\n (True, [\\<guillemotleft>r\\<guillemotright>])))))\n                         (Star (Atom (singleton as))))", "by (cases \"while_option fst (rderiv_and_add as) (True, [\\<guillemotleft>r\\<guillemotright>])\")\n    (auto dest: samequot_termination samequot_wf)"], ["", "lemma samequot_exec_samequot: \"lang n (samequot_exec as r) = lang n (samequot as r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n (samequot_exec as r) = lang n (samequot as r)", "unfolding samequot_exec_def samequot_def lang.simps lang_flatten_PLUS[OF finite_rderivs_same]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n\n     (PLUS\n       (snd (the (while_option fst (rderiv_and_add as)\n                   (True, [\\<guillemotleft>r\\<guillemotright>]))))) @@\n    star {[x] |x. lookup (singleton as) x \\<and> x \\<in> \\<Sigma> n} =\n    \\<Union>\n     (lang n `\n      {\\<guillemotleft>rderivs (replicate m as) r\\<guillemotright> |m.\n       True}) @@\n    star {[x] |x. lookup (singleton as) x \\<and> x \\<in> \\<Sigma> n}", "by (cases \"while_option fst (rderiv_and_add as) (True, [\\<guillemotleft>r\\<guillemotright>])\")\n    (auto dest: samequot_termination dest!: samequot_soundness[of _ _ _ _ n] simp del: ACI_norm_lang)"], ["", "lemma lang_samequot_exec:\n  \"\\<lbrakk>wf n r; as \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> lang n (samequot_exec as r) = SAMEQUOT as (lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; as \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> lang n (samequot_exec as r) = SAMEQUOT as (lang n r)", "unfolding samequot_exec_samequot"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; as \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> lang n (samequot as r) = SAMEQUOT as (lang n r)", "by (rule lang_samequot)"], ["", "end"], ["", "subsection \\<open>Suffix and Prefix Languages\\<close>"], ["", "definition Suffix :: \"'a lang \\<Rightarrow> 'a lang\" where\n  \"Suffix L = {w. \\<exists>u. u @ w \\<in> L}\""], ["", "definition Prefix :: \"'a lang \\<Rightarrow> 'a lang\" where\n  \"Prefix L = {w. \\<exists>u. w @ u \\<in> L}\""], ["", "lemma Prefix_Suffix: \"Prefix L = rev ` Suffix (rev ` L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prefix L = rev ` Suffix (rev ` L)", "unfolding Prefix_def Suffix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {w. \\<exists>u. w @ u \\<in> L} =\n    rev ` {w. \\<exists>u. u @ w \\<in> rev ` L}", "by (auto simp: rev_append_invert\n  intro: image_eqI[of _ rev, OF rev_rev_ident[symmetric]]\n         image_eqI[of _ rev, OF rev_append[symmetric]])"], ["", "definition Root :: \"'a lang \\<Rightarrow> 'a lang\" where\n  \"Root L = {x . \\<exists>n > 0. x ^^ n \\<in> L}\""], ["", "definition Cycle :: \"'a lang \\<Rightarrow> 'a lang\" where\n  \"Cycle L = {u @ w | u w. w @ u \\<in> L}\""], ["", "context embed\nbegin"], ["", "context\nfixes n :: nat\nbegin"], ["", "definition SUFFIX :: \"'b rexp \\<Rightarrow> 'b rexp\" where\n  \"SUFFIX r = flatten PLUS {\\<guillemotleft>lderivs w r\\<guillemotright>| w. wf_word n w}\""], ["", "lemma finite_lderivs_wf: \"finite {\\<guillemotleft>lderivs w r\\<guillemotright>| w. wf_word n w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>lderivs w r\\<guillemotright> |w. wf_word n w}", "by (auto intro: finite_subset[OF _ finite_lderivs])"], ["", "definition PREFIX :: \"'b rexp \\<Rightarrow> 'b rexp\" where\n  \"PREFIX r = REV (SUFFIX (REV r))\""], ["", "lemma wf_SUFFIX[simp]: \"wf n r \\<Longrightarrow> wf n (SUFFIX r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (SUFFIX r)", "unfolding SUFFIX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow>\n    local.wf n\n     (PLUS\n       (sorted_list_of_set\n         {\\<guillemotleft>lderivs w r\\<guillemotright> |w. wf_word n w}))", "by (intro iffD2[OF wf_flatten_PLUS[OF finite_lderivs_wf]]) auto"], ["", "lemma lang_SUFFIX[simp]: \"wf n r \\<Longrightarrow> lang n (SUFFIX r) = Suffix (lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> lang n (SUFFIX r) = Suffix (lang n r)", "unfolding SUFFIX_def Suffix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow>\n    lang n\n     (PLUS\n       (sorted_list_of_set\n         {\\<guillemotleft>lderivs w r\\<guillemotright> |w. wf_word n w})) =\n    {w. \\<exists>u. u @ w \\<in> lang n r}", "using lang_flatten_PLUS[OF finite_lderivs_wf] lang_lderivs wf_lang_wf_word"], ["proof (prove)\nusing this:\n  lang ?n\n   (PLUS\n     (sorted_list_of_set\n       {\\<guillemotleft>lderivs w ?r1\\<guillemotright> |w. wf_word n w})) =\n  \\<Union>\n   (lang ?n `\n    {\\<guillemotleft>lderivs w ?r1\\<guillemotright> |w. wf_word n w})\n  \\<lbrakk>local.wf ?n ?r; wf_word ?n ?ws\\<rbrakk>\n  \\<Longrightarrow> lang ?n (lderivs ?ws ?r) = lQuots ?ws (lang ?n ?r)\n  local.wf ?n ?r \\<Longrightarrow> \\<forall>w\\<in>lang ?n ?r. wf_word ?n w\n\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow>\n    lang n\n     (PLUS\n       (sorted_list_of_set\n         {\\<guillemotleft>lderivs w r\\<guillemotright> |w. wf_word n w})) =\n    {w. \\<exists>u. u @ w \\<in> lang n r}", "by fastforce"], ["", "lemma wf_PREFIX[simp]: \"wf n r \\<Longrightarrow> wf n (PREFIX r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (PREFIX r)", "unfolding PREFIX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (REV (SUFFIX (REV r)))", "by auto"], ["", "lemma lang_PREFIX[simp]: \"wf n r \\<Longrightarrow> lang n (PREFIX r) = Prefix (lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> lang n (PREFIX r) = Prefix (lang n r)", "unfolding PREFIX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow>\n    lang n (REV (SUFFIX (REV r))) = Prefix (lang n r)", "by (auto simp: Prefix_Suffix)"], ["", "end"], ["", "lemma take_drop_CycleI[intro!]: \"x \\<in> L \\<Longrightarrow> drop i x @ take i x \\<in> Cycle L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> L \\<Longrightarrow> drop i x @ take i x \\<in> Cycle L", "unfolding Cycle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> L \\<Longrightarrow>\n    drop i x @ take i x \\<in> {u @ w |u w. w @ u \\<in> L}", "by fastforce"], ["", "lemma take_drop_CycleI'[intro!]: \"drop i x @ take i x \\<in> L \\<Longrightarrow> x \\<in> Cycle L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop i x @ take i x \\<in> L \\<Longrightarrow> x \\<in> Cycle L", "by (drule take_drop_CycleI[of _ _ \"length x - i\"]) auto"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}