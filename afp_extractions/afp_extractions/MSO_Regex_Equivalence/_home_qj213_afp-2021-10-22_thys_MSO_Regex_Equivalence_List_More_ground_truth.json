{"file_name": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence/List_More.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence", "problem_names": ["lemma in_set_bool_product_lists[simp]:\n  \"bs \\<in> set (bool_product_lists n) \\<longleftrightarrow> length bs = n\"", "lemma insort_min[simp]: \"\\<forall>y \\<in> set xs. x < y \\<Longrightarrow> insort x xs = x # xs\"", "lemma insort_max[simp]: \"\\<forall>y \\<in> set xs. x > y \\<Longrightarrow> insort x xs = xs @ [x]\"", "lemma insort_snoc[simp]: \"\\<forall>z \\<in> set xs. y > z \\<Longrightarrow>\n  insort x (xs @ [y]) = (if x < y then insort x xs @ [y] else xs @ [y, x])\"", "lemma insort_remdups[simp]: \"\\<lbrakk>sorted xs; a \\<notin> set xs\\<rbrakk> \\<Longrightarrow> insort a (remdups xs) = remdups (insort a xs)\"", "lemma remdups_insort[simp]: \"a \\<in> set xs \\<Longrightarrow> remdups (insort a xs) = remdups xs\"", "lemma sort_remdups[simp]: \"sort (remdups xs) = remdups (sort xs)\"", "lemma sort_map_insort[simp]: \"sorted xs \\<Longrightarrow> sort (map f (insort a xs)) = insort (f a) (sort (map f xs))\"", "lemma sort_map_sort[simp]: \"sort (map f (sort xs)) = sort (map f xs)\"", "lemma remdups_append: \"remdups (xs @ ys) = remdups (filter (\\<lambda>x. x \\<notin> set ys) xs) @ remdups ys\"", "lemma remdups_concat_map_remdups:\n  \"remdups (concat (map f (remdups xs))) = remdups (concat (map f xs))\"", "lemma map_remdups'[simp]: \"map f (remdups' f xs) = remdups (map f xs)\"", "lemma remdups'_map[simp]: \"remdups' f (map g xs) = map g (remdups' (f o g) xs)\"", "lemma map_apfst_remdups':\n  \"map (f o fst) (remdups' snd xs) = map fst (remdups' snd (map (apfst f) xs))\"", "lemma set_remdups'[simp]: \"f ` set (remdups' f xs) = f ` set xs\"", "lemma subset_remdups': \"set (remdups' f xs) \\<subseteq> set xs\"", "lemma find_append[simp]:\n  \"List.find P (xs @ ys) = None = (List.find P xs = None \\<and> List.find P ys = None)\"", "lemma subset_remdups'_append: \"set (remdups' f (xs @ ys)) \\<subseteq> set (remdups' f xs) \\<union> set (remdups' f ys)\"", "lemmas mp_remdups' = subsetD[OF subset_remdups']", "lemmas mp_remdups'_append = subsetD[OF subset_remdups'_append]", "lemma inj_on_set_remdups'[simp]: \"inj_on f (set (remdups' f xs))\"", "lemma distinct_remdups'[simp]: \"distinct (map f (remdups' f xs))\"", "lemma distinct_remdups'_strong: \"(\\<forall>x\\<in>set xs. \\<forall>y\\<in>set xs. g x = g y \\<longrightarrow> f x = f y) \\<Longrightarrow>\n  distinct (map g (remdups' f xs))\"", "lemma set_remdups'_strong:\n  \"f ` set (remdups' g xs) = f ` set xs\" if \"\\<forall>x\\<in>set xs. \\<forall>y\\<in>set xs. g x = g y \\<longrightarrow> f x = f y\"", "lemma multiset_concat_gen: \"M + mset (concat xs) = fold (\\<lambda>x M. M + mset x) xs M\"", "lemma fold_mset_insort[simp]: \"fold (\\<lambda>x M. M + mset (f x)) (insort x xs) M =\n  fold (\\<lambda>x M. M + mset (f x)) xs (mset (f x) + M)\"", "lemma fold_mset_sort[simp]:\n  \"fold (\\<lambda>x M. M + mset (f x)) (sort xs) M = fold (\\<lambda>x M. M + mset (f x)) xs M\"", "lemma multiset_concat_map_sort[simp]:\n  \"mset (concat (map f (sort xs))) = mset (concat (map f xs))\"", "lemma sort_concat_map_sort[simp]: \"sort (concat (map f (sort xs))) = sort (concat (map f xs))\""], "translations": [["", "lemma in_set_bool_product_lists[simp]:\n  \"bs \\<in> set (bool_product_lists n) \\<longleftrightarrow> length bs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs \\<in> set (bool_product_lists n)) = (length bs = n)", "proof (induct n arbitrary: bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs. (bs \\<in> set (bool_product_lists 0)) = (length bs = 0)\n 2. \\<And>n bs.\n       (\\<And>bs.\n           (bs \\<in> set (bool_product_lists n)) =\n           (length bs = n)) \\<Longrightarrow>\n       (bs \\<in> set (bool_product_lists (Suc n))) = (length bs = Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  (?bs \\<in> set (bool_product_lists n)) = (length ?bs = n)\n\ngoal (2 subgoals):\n 1. \\<And>bs. (bs \\<in> set (bool_product_lists 0)) = (length bs = 0)\n 2. \\<And>n bs.\n       (\\<And>bs.\n           (bs \\<in> set (bool_product_lists n)) =\n           (length bs = n)) \\<Longrightarrow>\n       (bs \\<in> set (bool_product_lists (Suc n))) = (length bs = Suc n)", "thus ?case"], ["proof (prove)\nusing this:\n  (?bs \\<in> set (bool_product_lists n)) = (length ?bs = n)\n\ngoal (1 subgoal):\n 1. (bs \\<in> set (bool_product_lists (Suc n))) = (length bs = Suc n)", "by (cases bs) auto"], ["proof (state)\nthis:\n  (bs \\<in> set (bool_product_lists (Suc n))) = (length bs = Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>bs. (bs \\<in> set (bool_product_lists 0)) = (length bs = 0)", "qed simp"], ["", "text \\<open>More on sort and remdups\\<close>"], ["", "lemma insort_min[simp]: \"\\<forall>y \\<in> set xs. x < y \\<Longrightarrow> insort x xs = x # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set xs. x < y \\<Longrightarrow> insort x xs = x # xs", "by (induct xs) auto"], ["", "lemma insort_max[simp]: \"\\<forall>y \\<in> set xs. x > y \\<Longrightarrow> insort x xs = xs @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set xs. y < x \\<Longrightarrow> insort x xs = xs @ [x]", "by (induct xs) auto"], ["", "lemma insort_snoc[simp]: \"\\<forall>z \\<in> set xs. y > z \\<Longrightarrow>\n  insort x (xs @ [y]) = (if x < y then insort x xs @ [y] else xs @ [y, x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set xs. z < y \\<Longrightarrow>\n    insort x (xs @ [y]) = (if x < y then insort x xs @ [y] else xs @ [y, x])", "by (induct xs) auto"], ["", "declare set_insort_key[simp]"], ["", "lemma insort_remdups[simp]: \"\\<lbrakk>sorted xs; a \\<notin> set xs\\<rbrakk> \\<Longrightarrow> insort a (remdups xs) = remdups (insort a xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; a \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> insort a (remdups xs) = remdups (insort a xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted []; a \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> insort a (remdups []) = remdups (insort a [])\n 2. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>sorted xs; a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> insort a (remdups xs) =\n                                  remdups (insort a xs);\n        sorted (aa # xs); a \\<notin> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> insort a (remdups (aa # xs)) =\n                         remdups (insort a (aa # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted xs; a \\<notin> set xs\\<rbrakk>\n  \\<Longrightarrow> insort a (remdups xs) = remdups (insort a xs)\n  sorted (x # xs)\n  a \\<notin> set (x # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted []; a \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> insort a (remdups []) = remdups (insort a [])\n 2. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>sorted xs; a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> insort a (remdups xs) =\n                                  remdups (insort a xs);\n        sorted (aa # xs); a \\<notin> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> insort a (remdups (aa # xs)) =\n                         remdups (insort a (aa # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted xs; a \\<notin> set xs\\<rbrakk>\n  \\<Longrightarrow> insort a (remdups xs) = remdups (insort a xs)\n  sorted (x # xs)\n  a \\<notin> set (x # xs)\n\ngoal (1 subgoal):\n 1. insort a (remdups (x # xs)) = remdups (insort a (x # xs))", "by (cases xs) (auto)"], ["proof (state)\nthis:\n  insort a (remdups (x # xs)) = remdups (insort a (x # xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted []; a \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> insort a (remdups []) = remdups (insort a [])", "qed simp"], ["", "lemma remdups_insort[simp]: \"a \\<in> set xs \\<Longrightarrow> remdups (insort a xs) = remdups xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<Longrightarrow> remdups (insort a xs) = remdups xs", "by (induct xs) auto"], ["", "lemma sort_remdups[simp]: \"sort (remdups xs) = remdups (sort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (remdups xs) = remdups (sort xs)", "by (induct xs) auto"], ["", "lemma sort_map_insort[simp]: \"sorted xs \\<Longrightarrow> sort (map f (insort a xs)) = insort (f a) (sort (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs \\<Longrightarrow>\n    sort (map f (insort a xs)) = insort (f a) (sort (map f xs))", "by (induct xs) (auto simp: insort_left_comm)"], ["", "lemma sort_map_sort[simp]: \"sort (map f (sort xs)) = sort (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (map f (sort xs)) = sort (map f xs)", "by (induct xs) auto"], ["", "lemma remdups_append: \"remdups (xs @ ys) = remdups (filter (\\<lambda>x. x \\<notin> set ys) xs) @ remdups ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (xs @ ys) =\n    remdups (filter (\\<lambda>x. x \\<notin> set ys) xs) @ remdups ys", "by (induct xs) auto"], ["", "lemma remdups_concat_map_remdups:\n  \"remdups (concat (map f (remdups xs))) = remdups (concat (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (concat (map f (remdups xs))) = remdups (concat (map f xs))", "by (induct xs) (auto simp: remdups_append filter_empty_conv)"], ["", "(*remdups'*)"], ["", "primrec remdups' where\n  \"remdups' f [] = []\"\n| \"remdups' f (x # xs) =\n    (case List.find (\\<lambda>y. f x = f y) xs of None \\<Rightarrow> x # remdups' f xs | _ \\<Rightarrow> remdups' f xs)\""], ["", "lemma map_remdups'[simp]: \"map f (remdups' f xs) = remdups (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (remdups' f xs) = remdups (map f xs)", "by (induct xs) (auto split: option.splits simp add: find_Some_iff find_None_iff)"], ["", "lemma remdups'_map[simp]: \"remdups' f (map g xs) = map g (remdups' (f o g) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups' f (map g xs) = map g (remdups' (f \\<circ> g) xs)", "by (induct xs) (auto split: option.splits simp add: find_None_iff,\n                auto simp: find_Some_iff elim: imageI[OF nth_mem])"], ["", "lemma map_apfst_remdups':\n  \"map (f o fst) (remdups' snd xs) = map fst (remdups' snd (map (apfst f) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (f \\<circ> fst) (remdups' snd xs) =\n    map fst (remdups' snd (map (apfst f) xs))", "by (auto simp: comp_def)"], ["", "lemma set_remdups'[simp]: \"f ` set (remdups' f xs) = f ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` set (remdups' f xs) = f ` set xs", "by (induct xs) (auto split: option.splits simp add: find_Some_iff)"], ["", "lemma subset_remdups': \"set (remdups' f xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups' f xs) \\<subseteq> set xs", "by (induct xs) (auto split: option.splits)"], ["", "lemma find_append[simp]:\n  \"List.find P (xs @ ys) = None = (List.find P xs = None \\<and> List.find P ys = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find P (xs @ ys) = None) = (find P xs = None \\<and> find P ys = None)", "by (induct xs) auto"], ["", "lemma subset_remdups'_append: \"set (remdups' f (xs @ ys)) \\<subseteq> set (remdups' f xs) \\<union> set (remdups' f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups' f (xs @ ys))\n    \\<subseteq> set (remdups' f xs) \\<union> set (remdups' f ys)", "by (induct xs arbitrary: ys) (auto split: option.splits)"], ["", "lemmas mp_remdups' = subsetD[OF subset_remdups']"], ["", "lemmas mp_remdups'_append = subsetD[OF subset_remdups'_append]"], ["", "lemma inj_on_set_remdups'[simp]: \"inj_on f (set (remdups' f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set (remdups' f xs))", "by (induct xs) (auto split: option.splits simp add: find_None_iff dest!: mp_remdups')"], ["", "lemma distinct_remdups'[simp]: \"distinct (map f (remdups' f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f (remdups' f xs))", "by (induct xs) (auto split: option.splits simp: find_None_iff)"], ["", "lemma distinct_remdups'_strong: \"(\\<forall>x\\<in>set xs. \\<forall>y\\<in>set xs. g x = g y \\<longrightarrow> f x = f y) \\<Longrightarrow>\n  distinct (map g (remdups' f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs.\n       \\<forall>y\\<in>set xs.\n          g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n    distinct (map g (remdups' f xs))", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       \\<forall>y\\<in>set [].\n          g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n    distinct (map g (remdups' f []))\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   \\<forall>y\\<in>set xs.\n                      g x = g y \\<longrightarrow>\n                      f x = f y \\<Longrightarrow>\n                distinct (map g (remdups' f xs));\n        \\<forall>x\\<in>set (a # xs).\n           \\<forall>y\\<in>set (a # xs).\n              g x = g y \\<longrightarrow> f x = f y\\<rbrakk>\n       \\<Longrightarrow> distinct (map g (remdups' f (a # xs)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs.\n     \\<forall>y\\<in>set xs.\n        g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n  distinct (map g (remdups' f xs))\n  \\<forall>xa\\<in>set (x # xs).\n     \\<forall>y\\<in>set (x # xs). g xa = g y \\<longrightarrow> f xa = f y\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       \\<forall>y\\<in>set [].\n          g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n    distinct (map g (remdups' f []))\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   \\<forall>y\\<in>set xs.\n                      g x = g y \\<longrightarrow>\n                      f x = f y \\<Longrightarrow>\n                distinct (map g (remdups' f xs));\n        \\<forall>x\\<in>set (a # xs).\n           \\<forall>y\\<in>set (a # xs).\n              g x = g y \\<longrightarrow> f x = f y\\<rbrakk>\n       \\<Longrightarrow> distinct (map g (remdups' f (a # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs.\n     \\<forall>y\\<in>set xs.\n        g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n  distinct (map g (remdups' f xs))\n  \\<forall>xa\\<in>set (x # xs).\n     \\<forall>y\\<in>set (x # xs). g xa = g y \\<longrightarrow> f xa = f y\n\ngoal (1 subgoal):\n 1. distinct (map g (remdups' f (x # xs)))", "by (auto split: option.splits) (fastforce simp: find_None_iff dest!: mp_remdups')"], ["proof (state)\nthis:\n  distinct (map g (remdups' f (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set [].\n       \\<forall>y\\<in>set [].\n          g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n    distinct (map g (remdups' f []))", "qed simp"], ["", "lemma set_remdups'_strong:\n  \"f ` set (remdups' g xs) = f ` set xs\" if \"\\<forall>x\\<in>set xs. \\<forall>y\\<in>set xs. g x = g y \\<longrightarrow> f x = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` set (remdups' g xs) = f ` set xs", "using that"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs.\n     \\<forall>y\\<in>set xs. g x = g y \\<longrightarrow> f x = f y\n\ngoal (1 subgoal):\n 1. f ` set (remdups' g xs) = f ` set xs", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       \\<forall>y\\<in>set [].\n          g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n    f ` set (remdups' g []) = f ` set []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   \\<forall>y\\<in>set xs.\n                      g x = g y \\<longrightarrow>\n                      f x = f y \\<Longrightarrow>\n                f ` set (remdups' g xs) = f ` set xs;\n        \\<forall>x\\<in>set (a # xs).\n           \\<forall>y\\<in>set (a # xs).\n              g x = g y \\<longrightarrow> f x = f y\\<rbrakk>\n       \\<Longrightarrow> f ` set (remdups' g (a # xs)) = f ` set (a # xs)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set [].\n     \\<forall>y\\<in>set []. g x = g y \\<longrightarrow> f x = f y\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       \\<forall>y\\<in>set [].\n          g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n    f ` set (remdups' g []) = f ` set []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   \\<forall>y\\<in>set xs.\n                      g x = g y \\<longrightarrow>\n                      f x = f y \\<Longrightarrow>\n                f ` set (remdups' g xs) = f ` set xs;\n        \\<forall>x\\<in>set (a # xs).\n           \\<forall>y\\<in>set (a # xs).\n              g x = g y \\<longrightarrow> f x = f y\\<rbrakk>\n       \\<Longrightarrow> f ` set (remdups' g (a # xs)) = f ` set (a # xs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set [].\n     \\<forall>y\\<in>set []. g x = g y \\<longrightarrow> f x = f y", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set [].\n     \\<forall>y\\<in>set []. g x = g y \\<longrightarrow> f x = f y\n\ngoal (1 subgoal):\n 1. f ` set (remdups' g []) = f ` set []", "by simp"], ["proof (state)\nthis:\n  f ` set (remdups' g []) = f ` set []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   \\<forall>y\\<in>set xs.\n                      g x = g y \\<longrightarrow>\n                      f x = f y \\<Longrightarrow>\n                f ` set (remdups' g xs) = f ` set xs;\n        \\<forall>x\\<in>set (a # xs).\n           \\<forall>y\\<in>set (a # xs).\n              g x = g y \\<longrightarrow> f x = f y\\<rbrakk>\n       \\<Longrightarrow> f ` set (remdups' g (a # xs)) = f ` set (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   \\<forall>y\\<in>set xs.\n                      g x = g y \\<longrightarrow>\n                      f x = f y \\<Longrightarrow>\n                f ` set (remdups' g xs) = f ` set xs;\n        \\<forall>x\\<in>set (a # xs).\n           \\<forall>y\\<in>set (a # xs).\n              g x = g y \\<longrightarrow> f x = f y\\<rbrakk>\n       \\<Longrightarrow> f ` set (remdups' g (a # xs)) = f ` set (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs.\n     \\<forall>y\\<in>set xs.\n        g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n  f ` set (remdups' g xs) = f ` set xs\n  \\<forall>xa\\<in>set (x # xs).\n     \\<forall>y\\<in>set (x # xs). g xa = g y \\<longrightarrow> f xa = f y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   \\<forall>y\\<in>set xs.\n                      g x = g y \\<longrightarrow>\n                      f x = f y \\<Longrightarrow>\n                f ` set (remdups' g xs) = f ` set xs;\n        \\<forall>x\\<in>set (a # xs).\n           \\<forall>y\\<in>set (a # xs).\n              g x = g y \\<longrightarrow> f x = f y\\<rbrakk>\n       \\<Longrightarrow> f ` set (remdups' g (a # xs)) = f ` set (a # xs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set xs.\n     \\<forall>y\\<in>set xs.\n        g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n  f ` set (remdups' g xs) = f ` set xs\n  \\<forall>xa\\<in>set (x # xs).\n     \\<forall>y\\<in>set (x # xs). g xa = g y \\<longrightarrow> f xa = f y", "have \"\\<forall>x\\<in>set xs. \\<forall>y\\<in>set xs. g x = g y \\<longrightarrow> f x = f y\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs.\n     \\<forall>y\\<in>set xs.\n        g x = g y \\<longrightarrow> f x = f y \\<Longrightarrow>\n  f ` set (remdups' g xs) = f ` set xs\n  \\<forall>xa\\<in>set (x # xs).\n     \\<forall>y\\<in>set (x # xs). g xa = g y \\<longrightarrow> f xa = f y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs.\n       \\<forall>y\\<in>set xs. g x = g y \\<longrightarrow> f x = f y", "by (auto simp only: set_simps)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs.\n     \\<forall>y\\<in>set xs. g x = g y \\<longrightarrow> f x = f y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   \\<forall>y\\<in>set xs.\n                      g x = g y \\<longrightarrow>\n                      f x = f y \\<Longrightarrow>\n                f ` set (remdups' g xs) = f ` set xs;\n        \\<forall>x\\<in>set (a # xs).\n           \\<forall>y\\<in>set (a # xs).\n              g x = g y \\<longrightarrow> f x = f y\\<rbrakk>\n       \\<Longrightarrow> f ` set (remdups' g (a # xs)) = f ` set (a # xs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set xs.\n     \\<forall>y\\<in>set xs. g x = g y \\<longrightarrow> f x = f y", "have \"f ` set (remdups' g xs) = f ` set xs\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs.\n     \\<forall>y\\<in>set xs. g x = g y \\<longrightarrow> f x = f y\n\ngoal (1 subgoal):\n 1. f ` set (remdups' g xs) = f ` set xs", "by (rule Cons.IH)"], ["proof (state)\nthis:\n  f ` set (remdups' g xs) = f ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   \\<forall>y\\<in>set xs.\n                      g x = g y \\<longrightarrow>\n                      f x = f y \\<Longrightarrow>\n                f ` set (remdups' g xs) = f ` set xs;\n        \\<forall>x\\<in>set (a # xs).\n           \\<forall>y\\<in>set (a # xs).\n              g x = g y \\<longrightarrow> f x = f y\\<rbrakk>\n       \\<Longrightarrow> f ` set (remdups' g (a # xs)) = f ` set (a # xs)", "then"], ["proof (chain)\npicking this:\n  f ` set (remdups' g xs) = f ` set xs", "show ?case"], ["proof (prove)\nusing this:\n  f ` set (remdups' g xs) = f ` set xs\n\ngoal (1 subgoal):\n 1. f ` set (remdups' g (x # xs)) = f ` set (x # xs)", "by (auto simp add: find_Some_iff split: option.splits)\n      (metis Cons.prems image_eqI list.set_intros(1) list.set_intros(2) nth_mem)"], ["proof (state)\nthis:\n  f ` set (remdups' g (x # xs)) = f ` set (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*multisets only needed below*)"], ["", "lemma multiset_concat_gen: \"M + mset (concat xs) = fold (\\<lambda>x M. M + mset x) xs M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M + mset (concat xs) = fold (\\<lambda>x M. M + mset x) xs M", "by (induct xs arbitrary: M) (auto, metis union_assoc)"], ["", "corollary multiset_concat: \"mset (concat xs) = fold (\\<lambda>x M. M + mset x) xs {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (concat xs) = fold (\\<lambda>x M. M + mset x) xs {#}", "using multiset_concat_gen[of \"{#}\" xs]"], ["proof (prove)\nusing this:\n  {#} + mset (concat xs) = fold (\\<lambda>x M. M + mset x) xs {#}\n\ngoal (1 subgoal):\n 1. mset (concat xs) = fold (\\<lambda>x M. M + mset x) xs {#}", "by simp"], ["", "lemma fold_mset_insort[simp]: \"fold (\\<lambda>x M. M + mset (f x)) (insort x xs) M =\n  fold (\\<lambda>x M. M + mset (f x)) xs (mset (f x) + M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x M. M + mset (f x)) (insort x xs) M =\n    fold (\\<lambda>x M. M + mset (f x)) xs (mset (f x) + M)", "by (induct xs arbitrary: M) (auto simp: ac_simps)"], ["", "lemma fold_mset_sort[simp]:\n  \"fold (\\<lambda>x M. M + mset (f x)) (sort xs) M = fold (\\<lambda>x M. M + mset (f x)) xs M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x M. M + mset (f x)) (sort xs) M =\n    fold (\\<lambda>x M. M + mset (f x)) xs M", "by (induct xs arbitrary: M) (auto simp: ac_simps)"], ["", "lemma multiset_concat_map_sort[simp]:\n  \"mset (concat (map f (sort xs))) = mset (concat (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (concat (map f (sort xs))) = mset (concat (map f xs))", "by (auto simp: multiset_concat fold_map o_def)"], ["", "lemma sort_concat_map_sort[simp]: \"sort (concat (map f (sort xs))) = sort (concat (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (concat (map f (sort xs))) = sort (concat (map f xs))", "by (auto intro: properties_for_sort)"], ["", "end"]]}