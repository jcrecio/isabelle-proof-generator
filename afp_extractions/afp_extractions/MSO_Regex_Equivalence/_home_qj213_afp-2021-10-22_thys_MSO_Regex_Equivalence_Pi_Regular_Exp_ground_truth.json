{"file_name": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence/Pi_Regular_Exp.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence", "problem_names": ["lemma list_singleton_induct [case_names nil single cons]:\n  assumes nil: \"P []\"\n  assumes single: \"\\<And>x. P [x]\"\n  assumes cons: \"\\<And>x y xs. P (y # xs) \\<Longrightarrow> P (x # (y # xs))\"\n  shows \"P xs\"", "lemma toplevel_summands_nonempty[simp]:\n  \"toplevel_summands r \\<noteq> {}\"", "lemma toplevel_summands_finite[simp]:\n  \"finite (toplevel_summands r)\"", "lemma Plus_toplevel_summands:\n  \"Plus r s \\<in> toplevel_summands t \\<Longrightarrow> False\"", "lemma toplevel_summands_not_Plus[simp]:\n  \"(\\<forall>r s. x \\<noteq> Plus r s) \\<Longrightarrow> toplevel_summands x = {x}\"", "lemma toplevel_summands_PLUS_strong:\n  \"\\<lbrakk>xs \\<noteq> []; list_all (\\<lambda>x. \\<not>(\\<exists>r s. x = Plus r s)) xs\\<rbrakk> \\<Longrightarrow> toplevel_summands (PLUS xs) = set xs\"", "lemma toplevel_summands_flatten:\n  \"\\<lbrakk>X \\<noteq> {}; finite X; \\<forall>x \\<in> X. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk> \\<Longrightarrow> toplevel_summands (flatten PLUS X) = X\"", "lemma ACI_norm_Plus:\n  \"\\<guillemotleft>r\\<guillemotright> = Plus s t \\<Longrightarrow> \\<exists>s t. r = Plus s t\"", "lemma toplevel_summands_flatten_ACI_norm_image:\n  \"toplevel_summands (flatten PLUS (ACI_norm ` toplevel_summands r)) = ACI_norm ` toplevel_summands r\"", "lemma toplevel_summands_flatten_ACI_norm_image_Union:\n  \"toplevel_summands (flatten PLUS (ACI_norm ` toplevel_summands r \\<union> ACI_norm ` toplevel_summands s)) =\n    ACI_norm ` toplevel_summands r \\<union> ACI_norm ` toplevel_summands s\"", "lemma toplevel_summands_ACI_norm:\n  \"toplevel_summands \\<guillemotleft>r\\<guillemotright> = ACI_norm ` toplevel_summands r\"", "lemma ACI_norm_flatten:\n  \"\\<guillemotleft>r\\<guillemotright> = flatten PLUS (ACI_norm ` toplevel_summands r)\"", "theorem ACI_norm_idem[simp]:\n  \"\\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\"", "lemma toplevel_summands_ACI_nPlus:\n  \"toplevel_summands (ACI_nPlus r s) = toplevel_summands (Plus r s)\"", "lemma toplevel_summands_ACI_norm_alt:\n  \"toplevel_summands (ACI_norm_alt r) = ACI_norm_alt ` toplevel_summands r\"", "lemma ACI_norm_alt_Plus:\n  \"ACI_norm_alt r = Plus s t \\<Longrightarrow> \\<exists>s t. r = Plus s t\"", "lemma toplevel_summands_flatten_ACI_norm_alt_image:\n  \"toplevel_summands (flatten PLUS (ACI_norm_alt ` toplevel_summands r)) = ACI_norm_alt ` toplevel_summands r\"", "lemma ACI_norm_ACI_norm_alt: \"\\<guillemotleft>ACI_norm_alt r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\"", "lemma ACI_nPlus_singleton_PLUS: \n  \"\\<lbrakk>xs \\<noteq> []; sorted xs; distinct xs; \\<forall>x \\<in> {x} \\<union> set xs. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk> \\<Longrightarrow>\n  ACI_nPlus x (PLUS xs) = (if x \\<in> set xs then PLUS xs else PLUS (insort x xs))\"", "lemma ACI_nPlus_PLUS:\n  \"\\<lbrakk>xs1 \\<noteq> []; xs2 \\<noteq> []; \\<forall>x \\<in> set (xs1 @ xs2). \\<not>(\\<exists>r s. x = Plus r s); sorted xs2; distinct xs2\\<rbrakk>\\<Longrightarrow>\n  ACI_nPlus (PLUS xs1) (PLUS xs2) = flatten PLUS (set (xs1 @ xs2))\"", "lemma ACI_nPlus_flatten_PLUS:\n  \"\\<lbrakk>X1 \\<noteq> {}; X2 \\<noteq> {}; finite X1; finite X2; \\<forall>x \\<in> X1 \\<union> X2. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk>\\<Longrightarrow>\n  ACI_nPlus (flatten PLUS X1) (flatten PLUS X2) = flatten PLUS (X1 \\<union> X2)\"", "lemma ACI_nPlus_ACI_norm[simp]: \"ACI_nPlus \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright> = \\<guillemotleft>Plus r s\\<guillemotright>\"", "lemma ACI_norm_alt:\n  \"ACI_norm_alt r = \\<guillemotleft>r\\<guillemotright>\"", "lemma toplevel_summands_final:\n  \"final s = (\\<exists>r\\<in>toplevel_summands s. final r)\"", "lemma final_PLUS:\n  \"final (PLUS xs) = (\\<exists>r \\<in> set xs. final r)\"", "theorem ACI_norm_final[simp]:\n  \"final \\<guillemotleft>r\\<guillemotright> = final r\"", "lemma wf_word_snoc[simp]: \"wf_word n (ws @ [w]) = ((w \\<in> \\<Sigma> n) \\<and> wf_word n ws)\"", "lemma wf_word_append[simp]: \"wf_word n (ws @ vs) = (wf_word n ws \\<and> wf_word n vs)\"", "lemma wf_word: \"wf_word n w = (w \\<in> lists (\\<Sigma> n))\"", "lemma toplevel_summands_wf:\n  \"wf n s = (\\<forall>r\\<in>toplevel_summands s. wf n r)\"", "lemma wf_PLUS[simp]:\n  \"wf n (PLUS xs) = (\\<forall>r \\<in> set xs. wf n r)\"", "lemma wf_TIMES[simp]:\n  \"wf n (TIMES xs) = (\\<forall>r \\<in> set xs. wf n r)\"", "lemma wf_flatten_PLUS[simp]:\n  \"finite X \\<Longrightarrow> wf n (flatten PLUS X) = (\\<forall>r \\<in> X. wf n r)\"", "theorem ACI_norm_wf[simp]:\n  \"wf n \\<guillemotleft>r\\<guillemotright> = wf n r\"", "lemma wf_INTERSECT[simp]:\n  \"wf n (INTERSECT xs) = (\\<forall>r \\<in> set xs. wf n r)\"", "lemma wf_flatten_INTERSECT[simp]:\n  \"finite X \\<Longrightarrow> wf n (flatten INTERSECT X) = (\\<forall>r \\<in> X. wf n r)\"", "lemma wf_word_map_project[simp]: \"wf_word (Suc n) ws \\<Longrightarrow> wf_word n (map project ws)\"", "lemma wf_lang_wf_word: \"wf n r \\<Longrightarrow> \\<forall>w \\<in> lang n r. wf_word n w\"", "lemma lang_subset_lists: \"wf n r \\<Longrightarrow> lang n r \\<subseteq> lists (\\<Sigma> n)\"", "lemma toplevel_summands_lang:\n  \"r \\<in> toplevel_summands s \\<Longrightarrow> lang n r \\<subseteq> lang n s\"", "lemma toplevel_summands_lang_UN:\n  \"lang n s = (\\<Union>r\\<in>toplevel_summands s. lang n r)\"", "lemma toplevel_summands_in_lang:\n  \"w \\<in> lang n s = (\\<exists>r\\<in>toplevel_summands s. w \\<in> lang n r)\"", "lemma lang_PLUS[simp]:\n  \"lang n (PLUS xs) = (\\<Union>r \\<in> set xs. lang n r)\"", "lemma lang_TIMES[simp]:\n  \"lang n (TIMES xs) = foldr (@@) (map (lang n) xs) {[]}\"", "lemma lang_flatten_PLUS:\n  \"finite X \\<Longrightarrow> lang n (flatten PLUS X) = (\\<Union>r \\<in> X. lang n r)\"", "theorem ACI_norm_lang[simp]:\n  \"lang n \\<guillemotleft>r\\<guillemotright> = lang n r\"", "lemma lang_final: \"final r = ([] \\<in> lang n r)\"", "lemma in_lang_INTERSECT:\n  \"wf_word n w \\<Longrightarrow> w \\<in> lang n (INTERSECT xs) = (\\<forall>r \\<in> set xs. w \\<in> lang n r)\"", "lemma lang_INTERSECT:\n  \"lang n (INTERSECT xs) = (if xs = [] then lists (\\<Sigma> n) else \\<Inter>r \\<in> set xs. lang n r)\"", "lemma lang_flatten_INTERSECT[simp]:\n  assumes \"finite X\" \"X \\<noteq> {}\" \"\\<forall>r\\<in>X. wf n r\"\n  shows \"w \\<in> lang n (flatten INTERSECT X) = (\\<forall>r \\<in> X. w \\<in> lang n r)\" (is \"?L = ?R\")"], "translations": [["", "lemma list_singleton_induct [case_names nil single cons]:\n  assumes nil: \"P []\"\n  assumes single: \"\\<And>x. P [x]\"\n  assumes cons: \"\\<And>x y xs. P (y # xs) \\<Longrightarrow> P (x # (y # xs))\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using assms"], ["proof (prove)\nusing this:\n  P []\n  P [?x]\n  P (?y # ?xs) \\<Longrightarrow> P (?x # ?y # ?xs)\n\ngoal (1 subgoal):\n 1. P xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P []; \\<And>x. P [x];\n     \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs)\\<rbrakk>\n    \\<Longrightarrow> P []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>P []; \\<And>x. P [x];\n                 \\<And>y xs x.\n                    P (y # xs) \\<Longrightarrow> P (x # y # xs)\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        P []; \\<And>x. P [x];\n        \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>P []; \\<And>x. P [x];\n   \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs)\\<rbrakk>\n  \\<Longrightarrow> P xs\n  P []\n  P [?x]\n  P (?y # ?xs) \\<Longrightarrow> P (?x # ?y # ?xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P []; \\<And>x. P [x];\n     \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs)\\<rbrakk>\n    \\<Longrightarrow> P []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>P []; \\<And>x. P [x];\n                 \\<And>y xs x.\n                    P (y # xs) \\<Longrightarrow> P (x # y # xs)\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        P []; \\<And>x. P [x];\n        \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>P []; \\<And>x. P [x];\n   \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs)\\<rbrakk>\n  \\<Longrightarrow> P xs\n  P []\n  P [?x]\n  P (?y # ?xs) \\<Longrightarrow> P (?x # ?y # ?xs)\n\ngoal (1 subgoal):\n 1. P (x # xs)", "by (cases xs) auto"], ["proof (state)\nthis:\n  P (x # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P []; \\<And>x. P [x];\n     \\<And>y xs x. P (y # xs) \\<Longrightarrow> P (x # y # xs)\\<rbrakk>\n    \\<Longrightarrow> P []", "qed simp"], ["", "subsection \\<open>ACI normalization\\<close>"], ["", "fun toplevel_summands :: \"'a rexp \\<Rightarrow> 'a rexp set\" where\n  \"toplevel_summands (Plus r s) = toplevel_summands r \\<union> toplevel_summands s\"\n| \"toplevel_summands r = {r}\""], ["", "abbreviation (input) \"flatten LISTOP X \\<equiv> LISTOP (sorted_list_of_set X)\""], ["", "lemma toplevel_summands_nonempty[simp]:\n  \"toplevel_summands r \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands r \\<noteq> {}", "by (induct r) auto"], ["", "lemma toplevel_summands_finite[simp]:\n  \"finite (toplevel_summands r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (toplevel_summands r)", "by (induct r) auto"], ["", "primrec ACI_norm :: \"('a::linorder) rexp \\<Rightarrow> 'a rexp\"  (\"\\<guillemotleft>_\\<guillemotright>\") where\n  \"\\<guillemotleft>Zero\\<guillemotright> = Zero\"\n| \"\\<guillemotleft>Full\\<guillemotright> = Full\"\n| \"\\<guillemotleft>One\\<guillemotright> = One\"\n| \"\\<guillemotleft>Atom a\\<guillemotright> = Atom a\"\n| \"\\<guillemotleft>Plus r s\\<guillemotright> = flatten PLUS (toplevel_summands (Plus \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright>))\"\n| \"\\<guillemotleft>Times r s\\<guillemotright> = Times \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright>\"\n| \"\\<guillemotleft>Star r\\<guillemotright> = Star \\<guillemotleft>r\\<guillemotright>\"\n| \"\\<guillemotleft>Not r\\<guillemotright> = Not \\<guillemotleft>r\\<guillemotright>\"\n| \"\\<guillemotleft>Inter r s\\<guillemotright> = Inter \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright>\"\n| \"\\<guillemotleft>Pr r\\<guillemotright> = Pr \\<guillemotleft>r\\<guillemotright>\""], ["", "lemma Plus_toplevel_summands:\n  \"Plus r s \\<in> toplevel_summands t \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Plus r s \\<in> toplevel_summands t \\<Longrightarrow> False", "by (induct t) auto"], ["", "lemma toplevel_summands_not_Plus[simp]:\n  \"(\\<forall>r s. x \\<noteq> Plus r s) \\<Longrightarrow> toplevel_summands x = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r s. x \\<noteq> Plus r s \\<Longrightarrow>\n    toplevel_summands x = {x}", "by (induct x) auto"], ["", "lemma toplevel_summands_PLUS_strong:\n  \"\\<lbrakk>xs \\<noteq> []; list_all (\\<lambda>x. \\<not>(\\<exists>r s. x = Plus r s)) xs\\<rbrakk> \\<Longrightarrow> toplevel_summands (PLUS xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [];\n     list_all (\\<lambda>x. \\<nexists>r s. x = Plus r s) xs\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands (PLUS xs) = set xs", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma toplevel_summands_flatten:\n  \"\\<lbrakk>X \\<noteq> {}; finite X; \\<forall>x \\<in> X. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk> \\<Longrightarrow> toplevel_summands (flatten PLUS X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {}; finite X;\n     \\<forall>x\\<in>X. \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands (PLUS (sorted_list_of_set X)) = X", "using toplevel_summands_PLUS_strong[of \"sorted_list_of_set X\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_list_of_set X \\<noteq> [];\n   list_all (\\<lambda>x. \\<nexists>r s. x = Plus r s)\n    (sorted_list_of_set X)\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands (PLUS (sorted_list_of_set X)) =\n                    set (sorted_list_of_set X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {}; finite X;\n     \\<forall>x\\<in>X. \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands (PLUS (sorted_list_of_set X)) = X", "unfolding list_all_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_list_of_set X \\<noteq> [];\n   \\<forall>x\\<in>set (sorted_list_of_set X).\n      \\<nexists>r s. x = Plus r s\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands (PLUS (sorted_list_of_set X)) =\n                    set (sorted_list_of_set X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {}; finite X;\n     \\<forall>x\\<in>X. \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands (PLUS (sorted_list_of_set X)) = X", "by fastforce"], ["", "lemma ACI_norm_Plus:\n  \"\\<guillemotleft>r\\<guillemotright> = Plus s t \\<Longrightarrow> \\<exists>s t. r = Plus s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>r\\<guillemotright> = Plus s t \\<Longrightarrow>\n    \\<exists>s t. r = Plus s t", "by (induct r) auto"], ["", "lemma toplevel_summands_flatten_ACI_norm_image:\n  \"toplevel_summands (flatten PLUS (ACI_norm ` toplevel_summands r)) = ACI_norm ` toplevel_summands r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands\n     (PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands r))) =\n    ACI_norm ` toplevel_summands r", "by (intro toplevel_summands_flatten) (auto dest!: ACI_norm_Plus intro: Plus_toplevel_summands)"], ["", "lemma toplevel_summands_flatten_ACI_norm_image_Union:\n  \"toplevel_summands (flatten PLUS (ACI_norm ` toplevel_summands r \\<union> ACI_norm ` toplevel_summands s)) =\n    ACI_norm ` toplevel_summands r \\<union> ACI_norm ` toplevel_summands s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands\n     (PLUS\n       (sorted_list_of_set\n         (ACI_norm ` toplevel_summands r \\<union>\n          ACI_norm ` toplevel_summands s))) =\n    ACI_norm ` toplevel_summands r \\<union> ACI_norm ` toplevel_summands s", "by (intro toplevel_summands_flatten) (auto dest!: ACI_norm_Plus[OF sym] intro: Plus_toplevel_summands)"], ["", "lemma toplevel_summands_ACI_norm:\n  \"toplevel_summands \\<guillemotleft>r\\<guillemotright> = ACI_norm ` toplevel_summands r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands \\<guillemotleft>r\\<guillemotright> =\n    ACI_norm ` toplevel_summands r", "by (induct r) (auto simp: toplevel_summands_flatten_ACI_norm_image_Union)"], ["", "lemma ACI_norm_flatten:\n  \"\\<guillemotleft>r\\<guillemotright> = flatten PLUS (ACI_norm ` toplevel_summands r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>r\\<guillemotright> =\n    PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands r))", "by (induct r) (auto simp: image_Un toplevel_summands_flatten_ACI_norm_image)"], ["", "theorem ACI_norm_idem[simp]:\n  \"\\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>r\\<guillemotright>", "proof (induct r)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>rexp.Not\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>rexp.Inter r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>\\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "case (Plus r s)"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n  \\<guillemotleft>\\<guillemotleft>s\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>s\\<guillemotright>\n\ngoal (10 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>rexp.Not\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>rexp.Inter r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>\\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "have \"\\<guillemotleft>\\<guillemotleft>Plus r s\\<guillemotright>\\<guillemotright> = \\<guillemotleft>flatten PLUS (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union> toplevel_summands \\<guillemotleft>s\\<guillemotright>)\\<guillemotright>\"\n    (is \"_ = \\<guillemotleft>flatten PLUS ?U\\<guillemotright>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<guillemotleft>Plus r\n                                     s\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>PLUS\n                     (sorted_list_of_set\n                       (toplevel_summands\n                         \\<guillemotleft>r\\<guillemotright> \\<union>\n                        toplevel_summands\n                         \\<guillemotleft>s\\<guillemotright>))\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<guillemotleft>Plus r\n                                   s\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>PLUS\n                   (sorted_list_of_set\n                     (toplevel_summands\n                       \\<guillemotleft>r\\<guillemotright> \\<union>\n                      toplevel_summands\n                       \\<guillemotleft>s\\<guillemotright>))\\<guillemotright>\n\ngoal (10 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>rexp.Not\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>rexp.Inter r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>\\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<guillemotleft>Plus r\n                                   s\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>PLUS\n                   (sorted_list_of_set\n                     (toplevel_summands\n                       \\<guillemotleft>r\\<guillemotright> \\<union>\n                      toplevel_summands\n                       \\<guillemotleft>s\\<guillemotright>))\\<guillemotright>\n\ngoal (10 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>rexp.Not\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>rexp.Inter r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>\\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "have \"\\<dots> = flatten PLUS (ACI_norm ` toplevel_summands (flatten PLUS ?U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>PLUS\n                     (sorted_list_of_set\n                       (toplevel_summands\n                         \\<guillemotleft>r\\<guillemotright> \\<union>\n                        toplevel_summands\n                         \\<guillemotleft>s\\<guillemotright>))\\<guillemotright> =\n    PLUS\n     (sorted_list_of_set\n       (ACI_norm `\n        toplevel_summands\n         (PLUS\n           (sorted_list_of_set\n             (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n              toplevel_summands \\<guillemotleft>s\\<guillemotright>)))))", "by (simp only: ACI_norm_flatten)"], ["proof (state)\nthis:\n  \\<guillemotleft>PLUS\n                   (sorted_list_of_set\n                     (toplevel_summands\n                       \\<guillemotleft>r\\<guillemotright> \\<union>\n                      toplevel_summands\n                       \\<guillemotleft>s\\<guillemotright>))\\<guillemotright> =\n  PLUS\n   (sorted_list_of_set\n     (ACI_norm `\n      toplevel_summands\n       (PLUS\n         (sorted_list_of_set\n           (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n            toplevel_summands \\<guillemotleft>s\\<guillemotright>)))))\n\ngoal (10 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>rexp.Not\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>rexp.Inter r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>\\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  \\<guillemotleft>PLUS\n                   (sorted_list_of_set\n                     (toplevel_summands\n                       \\<guillemotleft>r\\<guillemotright> \\<union>\n                      toplevel_summands\n                       \\<guillemotleft>s\\<guillemotright>))\\<guillemotright> =\n  PLUS\n   (sorted_list_of_set\n     (ACI_norm `\n      toplevel_summands\n       (PLUS\n         (sorted_list_of_set\n           (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n            toplevel_summands \\<guillemotleft>s\\<guillemotright>)))))\n\ngoal (10 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>rexp.Not\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>rexp.Inter r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>\\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "have \"toplevel_summands (flatten PLUS ?U) = ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands\n     (PLUS\n       (sorted_list_of_set\n         (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n          toplevel_summands \\<guillemotleft>s\\<guillemotright>))) =\n    toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n    toplevel_summands \\<guillemotleft>s\\<guillemotright>", "by (intro toplevel_summands_flatten) (auto intro: Plus_toplevel_summands)"], ["proof (state)\nthis:\n  toplevel_summands\n   (PLUS\n     (sorted_list_of_set\n       (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n        toplevel_summands \\<guillemotleft>s\\<guillemotright>))) =\n  toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n  toplevel_summands \\<guillemotleft>s\\<guillemotright>\n\ngoal (10 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>rexp.Not\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>rexp.Inter r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>\\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "also"], ["proof (state)\nthis:\n  toplevel_summands\n   (PLUS\n     (sorted_list_of_set\n       (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n        toplevel_summands \\<guillemotleft>s\\<guillemotright>))) =\n  toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n  toplevel_summands \\<guillemotleft>s\\<guillemotright>\n\ngoal (10 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>rexp.Not\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>rexp.Inter r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>\\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "have \"flatten PLUS (ACI_norm ` ?U) = flatten PLUS (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union> toplevel_summands \\<guillemotleft>s\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PLUS\n     (sorted_list_of_set\n       (ACI_norm `\n        (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n         toplevel_summands \\<guillemotleft>s\\<guillemotright>))) =\n    PLUS\n     (sorted_list_of_set\n       (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n        toplevel_summands \\<guillemotleft>s\\<guillemotright>))", "by (simp only: image_Un toplevel_summands_ACI_norm[symmetric] Plus)"], ["proof (state)\nthis:\n  PLUS\n   (sorted_list_of_set\n     (ACI_norm `\n      (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n       toplevel_summands \\<guillemotleft>s\\<guillemotright>))) =\n  PLUS\n   (sorted_list_of_set\n     (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n      toplevel_summands \\<guillemotleft>s\\<guillemotright>))\n\ngoal (10 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Plus r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>rexp.Not\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>rexp.Inter r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>\\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "finally"], ["proof (chain)\npicking this:\n  \\<guillemotleft>\\<guillemotleft>Plus r\n                                   s\\<guillemotright>\\<guillemotright> =\n  PLUS\n   (sorted_list_of_set\n     (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n      toplevel_summands \\<guillemotleft>s\\<guillemotright>))", "show ?case"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<guillemotleft>Plus r\n                                   s\\<guillemotright>\\<guillemotright> =\n  PLUS\n   (sorted_list_of_set\n     (toplevel_summands \\<guillemotleft>r\\<guillemotright> \\<union>\n      toplevel_summands \\<guillemotleft>s\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<guillemotleft>Plus r\n                                     s\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Plus r s\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<guillemotleft>Plus r\n                                   s\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>Plus r s\\<guillemotright>\n\ngoal (9 subgoals):\n 1. \\<guillemotleft>\\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>\\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>\\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>\\<guillemotleft>Atom\n  x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>Times r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Star\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>rexp.Not\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 8. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>\\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>\\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<guillemotleft>rexp.Inter r1\n                    r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 9. \\<And>r.\n       \\<guillemotleft>\\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>\\<guillemotleft>Pr\n  r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>Pr r\\<guillemotright>", "qed auto"], ["", "fun ACI_nPlus :: \"'a::linorder rexp \\<Rightarrow> 'a rexp \\<Rightarrow> 'a rexp\"\nwhere\n  \"ACI_nPlus (Plus r1 r2) s = ACI_nPlus r1 (ACI_nPlus r2 s)\"\n| \"ACI_nPlus r (Plus s1 s2) =\n  (if r = s1 then Plus s1 s2\n  else if r < s1 then Plus r (Plus s1 s2)\n  else Plus s1 (ACI_nPlus r s2))\"\n| \"ACI_nPlus r s =\n  (if r = s then r\n  else if r < s then Plus r s\n  else Plus s r)\""], ["", "fun ACI_norm_alt where \n  \"ACI_norm_alt Zero = Zero\"\n| \"ACI_norm_alt Full = Full\"\n| \"ACI_norm_alt One = One\"\n| \"ACI_norm_alt (Atom a) = Atom a\"\n| \"ACI_norm_alt (Plus r s) = ACI_nPlus (ACI_norm_alt r) (ACI_norm_alt s)\"\n| \"ACI_norm_alt (Times r s) = Times (ACI_norm_alt r) (ACI_norm_alt s)\"\n| \"ACI_norm_alt (Star r) = Star (ACI_norm_alt r)\"\n| \"ACI_norm_alt (Not r) = Not (ACI_norm_alt r)\"\n| \"ACI_norm_alt (Inter r s) = Inter (ACI_norm_alt r) (ACI_norm_alt s)\"\n| \"ACI_norm_alt (Pr r) = Pr (ACI_norm_alt r)\""], ["", "lemma toplevel_summands_ACI_nPlus:\n  \"toplevel_summands (ACI_nPlus r s) = toplevel_summands (Plus r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (ACI_nPlus r s) = toplevel_summands (Plus r s)", "by (induct r s rule: ACI_nPlus.induct) auto"], ["", "lemma toplevel_summands_ACI_norm_alt:\n  \"toplevel_summands (ACI_norm_alt r) = ACI_norm_alt ` toplevel_summands r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (ACI_norm_alt r) = ACI_norm_alt ` toplevel_summands r", "by (induct r) (auto simp: toplevel_summands_ACI_nPlus)"], ["", "lemma ACI_norm_alt_Plus:\n  \"ACI_norm_alt r = Plus s t \\<Longrightarrow> \\<exists>s t. r = Plus s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI_norm_alt r = Plus s t \\<Longrightarrow> \\<exists>s t. r = Plus s t", "by (induct r) auto"], ["", "lemma toplevel_summands_flatten_ACI_norm_alt_image:\n  \"toplevel_summands (flatten PLUS (ACI_norm_alt ` toplevel_summands r)) = ACI_norm_alt ` toplevel_summands r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands\n     (PLUS (sorted_list_of_set (ACI_norm_alt ` toplevel_summands r))) =\n    ACI_norm_alt ` toplevel_summands r", "by (intro toplevel_summands_flatten) (auto dest!: ACI_norm_alt_Plus intro: Plus_toplevel_summands)"], ["", "lemma ACI_norm_ACI_norm_alt: \"\\<guillemotleft>ACI_norm_alt r\\<guillemotright> = \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n    \\<guillemotleft>r\\<guillemotright>", "proof (induction r)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<guillemotleft>ACI_norm_alt Zero\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>ACI_norm_alt Full\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>ACI_norm_alt One\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>ACI_norm_alt (Atom x)\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (Plus r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (Times r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>ACI_norm_alt (Star r)\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>ACI_norm_alt (rexp.Not r)\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (rexp.Inter r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>ACI_norm_alt (Pr r)\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "case (Plus r s)"], ["proof (state)\nthis:\n  \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n  \\<guillemotleft>r\\<guillemotright>\n  \\<guillemotleft>ACI_norm_alt s\\<guillemotright> =\n  \\<guillemotleft>s\\<guillemotright>\n\ngoal (10 subgoals):\n 1. \\<guillemotleft>ACI_norm_alt Zero\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>ACI_norm_alt Full\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>ACI_norm_alt One\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>ACI_norm_alt (Atom x)\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (Plus r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>Plus r1 r2\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (Times r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>ACI_norm_alt (Star r)\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 8. \\<And>r.\n       \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>ACI_norm_alt (rexp.Not r)\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (rexp.Inter r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 10. \\<And>r.\n        \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n        \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n        \\<guillemotleft>ACI_norm_alt (Pr r)\\<guillemotright> =\n        \\<guillemotleft>Pr r\\<guillemotright>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>ACI_norm_alt (Plus r s)\\<guillemotright> =\n    \\<guillemotleft>Plus r s\\<guillemotright>", "using ACI_norm_flatten [of \"ACI_norm_alt (Plus r s)\"] ACI_norm_flatten [of \"Plus r s\"]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>ACI_norm_alt (Plus r s)\\<guillemotright> =\n  PLUS\n   (sorted_list_of_set\n     (ACI_norm ` toplevel_summands (ACI_norm_alt (Plus r s))))\n  \\<guillemotleft>Plus r s\\<guillemotright> =\n  PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands (Plus r s)))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>ACI_norm_alt (Plus r s)\\<guillemotright> =\n    \\<guillemotleft>Plus r s\\<guillemotright>", "by (auto simp: image_Un toplevel_summands_ACI_nPlus)\n      (metis Plus.IH toplevel_summands_ACI_norm)"], ["proof (state)\nthis:\n  \\<guillemotleft>ACI_norm_alt (Plus r s)\\<guillemotright> =\n  \\<guillemotleft>Plus r s\\<guillemotright>\n\ngoal (9 subgoals):\n 1. \\<guillemotleft>ACI_norm_alt Zero\\<guillemotright> =\n    \\<guillemotleft>Zero\\<guillemotright>\n 2. \\<guillemotleft>ACI_norm_alt Full\\<guillemotright> =\n    \\<guillemotleft>Full\\<guillemotright>\n 3. \\<guillemotleft>ACI_norm_alt One\\<guillemotright> =\n    \\<guillemotleft>One\\<guillemotright>\n 4. \\<And>x.\n       \\<guillemotleft>ACI_norm_alt (Atom x)\\<guillemotright> =\n       \\<guillemotleft>Atom x\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (Times r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>Times r1 r2\\<guillemotright>\n 6. \\<And>r.\n       \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>ACI_norm_alt (Star r)\\<guillemotright> =\n       \\<guillemotleft>Star r\\<guillemotright>\n 7. \\<And>r.\n       \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>ACI_norm_alt (rexp.Not r)\\<guillemotright> =\n       \\<guillemotleft>rexp.Not r\\<guillemotright>\n 8. \\<And>r1 r2.\n       \\<lbrakk>\\<guillemotleft>ACI_norm_alt r1\\<guillemotright> =\n                \\<guillemotleft>r1\\<guillemotright>;\n        \\<guillemotleft>ACI_norm_alt r2\\<guillemotright> =\n        \\<guillemotleft>r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>ACI_norm_alt\n    (rexp.Inter r1 r2)\\<guillemotright> =\n                         \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\n 9. \\<And>r.\n       \\<guillemotleft>ACI_norm_alt r\\<guillemotright> =\n       \\<guillemotleft>r\\<guillemotright> \\<Longrightarrow>\n       \\<guillemotleft>ACI_norm_alt (Pr r)\\<guillemotright> =\n       \\<guillemotleft>Pr r\\<guillemotright>", "qed auto"], ["", "lemma ACI_nPlus_singleton_PLUS: \n  \"\\<lbrakk>xs \\<noteq> []; sorted xs; distinct xs; \\<forall>x \\<in> {x} \\<union> set xs. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk> \\<Longrightarrow>\n  ACI_nPlus x (PLUS xs) = (if x \\<in> set xs then PLUS xs else PLUS (insort x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; sorted xs; distinct xs;\n     \\<forall>x\\<in>{x} \\<union> set xs.\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS xs) =\n                      (if x \\<in> set xs then PLUS xs\n                       else PLUS (insort x xs))", "proof (induct xs rule: list_singleton_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa.\n       \\<lbrakk>[xa] \\<noteq> []; sorted [xa]; distinct [xa];\n        \\<forall>x\\<in>{x} \\<union> set [xa].\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS [xa]) =\n                         (if x \\<in> set [xa] then PLUS [xa]\n                          else PLUS (insort x [xa]))\n 3. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<nexists>r s. x = Plus r s\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "case (single y)"], ["proof (state)\nthis:\n  [y] \\<noteq> []\n  sorted [y]\n  distinct [y]\n  \\<forall>x\\<in>{x} \\<union> set [y]. \\<nexists>r s. x = Plus r s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa.\n       \\<lbrakk>[xa] \\<noteq> []; sorted [xa]; distinct [xa];\n        \\<forall>x\\<in>{x} \\<union> set [xa].\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS [xa]) =\n                         (if x \\<in> set [xa] then PLUS [xa]\n                          else PLUS (insort x [xa]))\n 3. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<nexists>r s. x = Plus r s\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  [y] \\<noteq> []\n  sorted [y]\n  distinct [y]\n  \\<forall>x\\<in>{x} \\<union> set [y]. \\<nexists>r s. x = Plus r s\n\ngoal (1 subgoal):\n 1. ACI_nPlus x (PLUS [y]) =\n    (if x \\<in> set [y] then PLUS [y] else PLUS (insort x [y]))", "by (cases x y rule: linorder_cases) (induct x y rule: ACI_nPlus.induct, auto)+"], ["proof (state)\nthis:\n  ACI_nPlus x (PLUS [y]) =\n  (if x \\<in> set [y] then PLUS [y] else PLUS (insort x [y]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<nexists>r s. x = Plus r s\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<nexists>r s. x = Plus r s\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "case (cons y1 y2 ys)"], ["proof (state)\nthis:\n  \\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys); distinct (y2 # ys);\n   \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n      \\<nexists>r s. x = Plus r s\\<rbrakk>\n  \\<Longrightarrow> ACI_nPlus x (PLUS (y2 # ys)) =\n                    (if x \\<in> set (y2 # ys) then PLUS (y2 # ys)\n                     else PLUS (insort x (y2 # ys)))\n  y1 # y2 # ys \\<noteq> []\n  sorted (y1 # y2 # ys)\n  distinct (y1 # y2 # ys)\n  \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n     \\<nexists>r s. x = Plus r s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))\n 2. \\<And>xa y xs.\n       \\<lbrakk>\\<lbrakk>y # xs \\<noteq> []; sorted (y # xs);\n                 distinct (y # xs);\n                 \\<forall>x\\<in>{x} \\<union> set (y # xs).\n                    \\<nexists>r s. x = Plus r s\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus x (PLUS (y # xs)) =\n                                  (if x \\<in> set (y # xs)\n                                   then PLUS (y # xs)\n                                   else PLUS (insort x (y # xs)));\n        xa # y # xs \\<noteq> []; sorted (xa # y # xs);\n        distinct (xa # y # xs);\n        \\<forall>x\\<in>{x} \\<union> set (xa # y # xs).\n           \\<nexists>r s. x = Plus r s\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus x (PLUS (xa # y # xs)) =\n                         (if x \\<in> set (xa # y # xs)\n                          then PLUS (xa # y # xs)\n                          else PLUS (insort x (xa # y # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>y2 # ys \\<noteq> []; sorted (y2 # ys); distinct (y2 # ys);\n   \\<forall>x\\<in>{x} \\<union> set (y2 # ys).\n      \\<nexists>r s. x = Plus r s\\<rbrakk>\n  \\<Longrightarrow> ACI_nPlus x (PLUS (y2 # ys)) =\n                    (if x \\<in> set (y2 # ys) then PLUS (y2 # ys)\n                     else PLUS (insort x (y2 # ys)))\n  y1 # y2 # ys \\<noteq> []\n  sorted (y1 # y2 # ys)\n  distinct (y1 # y2 # ys)\n  \\<forall>x\\<in>{x} \\<union> set (y1 # y2 # ys).\n     \\<nexists>r s. x = Plus r s\n\ngoal (1 subgoal):\n 1. ACI_nPlus x (PLUS (y1 # y2 # ys)) =\n    (if x \\<in> set (y1 # y2 # ys) then PLUS (y1 # y2 # ys)\n     else PLUS (insort x (y1 # y2 # ys)))", "by (cases x) (auto)"], ["proof (state)\nthis:\n  ACI_nPlus x (PLUS (y1 # y2 # ys)) =\n  (if x \\<in> set (y1 # y2 # ys) then PLUS (y1 # y2 # ys)\n   else PLUS (insort x (y1 # y2 # ys)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[] \\<noteq> []; sorted []; distinct [];\n     \\<forall>x\\<in>{x} \\<union> set [].\n        \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x (PLUS []) =\n                      (if x \\<in> set [] then PLUS []\n                       else PLUS (insort x []))", "qed simp"], ["", "lemma ACI_nPlus_PLUS:\n  \"\\<lbrakk>xs1 \\<noteq> []; xs2 \\<noteq> []; \\<forall>x \\<in> set (xs1 @ xs2). \\<not>(\\<exists>r s. x = Plus r s); sorted xs2; distinct xs2\\<rbrakk>\\<Longrightarrow>\n  ACI_nPlus (PLUS xs1) (PLUS xs2) = flatten PLUS (set (xs1 @ xs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs1 \\<noteq> []; xs2 \\<noteq> [];\n     \\<forall>x\\<in>set (xs1 @ xs2). \\<nexists>r s. x = Plus r s;\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus (PLUS xs1) (PLUS xs2) =\n                      PLUS (sorted_list_of_set (set (xs1 @ xs2)))", "proof (induct xs1 arbitrary: xs2 rule: list_singleton_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         PLUS (sorted_list_of_set (set ([] @ xs2)))\n 2. \\<And>x xs2.\n       \\<lbrakk>[x] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([x] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS [x]) (PLUS xs2) =\n                         PLUS (sorted_list_of_set (set ([x] @ xs2)))\n 3. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<nexists>r s. x = Plus r s;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> ACI_nPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     PLUS\n(sorted_list_of_set (set ((y # xs) @ xs2)));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         PLUS\n                          (sorted_list_of_set (set ((x # y # xs) @ xs2)))", "case (single x1)"], ["proof (state)\nthis:\n  [x1] \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ([x1] @ xs2). \\<nexists>r s. x = Plus r s\n  sorted xs2\n  distinct xs2\n\ngoal (3 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         PLUS (sorted_list_of_set (set ([] @ xs2)))\n 2. \\<And>x xs2.\n       \\<lbrakk>[x] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([x] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS [x]) (PLUS xs2) =\n                         PLUS (sorted_list_of_set (set ([x] @ xs2)))\n 3. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<nexists>r s. x = Plus r s;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> ACI_nPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     PLUS\n(sorted_list_of_set (set ((y # xs) @ xs2)));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         PLUS\n                          (sorted_list_of_set (set ((x # y # xs) @ xs2)))", "thus ?case"], ["proof (prove)\nusing this:\n  [x1] \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ([x1] @ xs2). \\<nexists>r s. x = Plus r s\n  sorted xs2\n  distinct xs2\n\ngoal (1 subgoal):\n 1. ACI_nPlus (PLUS [x1]) (PLUS xs2) =\n    PLUS (sorted_list_of_set (set ([x1] @ xs2)))", "apply (auto intro!: trans[OF ACI_nPlus_singleton_PLUS] simp: insert_absorb simp del: sorted_list_of_set_insert)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>x\\<in>set xs2. \\<forall>r s. x \\<noteq> Plus r s;\n     x1 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS xs2 = PLUS (sorted_list_of_set (set xs2))\n 2. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x1 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs2. \\<forall>r s. x \\<noteq> Plus r s;\n     x1 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS (insort x1 xs2) =\n                      PLUS (insort x1 (sorted_list_of_set (set xs2)))", "apply (metis finite_set finite_sorted_distinct_unique sorted_list_of_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x1 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs2. \\<forall>r s. x \\<noteq> Plus r s;\n     x1 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS (insort x1 xs2) =\n                      PLUS (insort x1 (sorted_list_of_set (set xs2)))", "apply (metis remdups_id_iff_distinct sorted_list_of_set_sort_remdups sorted_sort_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ACI_nPlus (PLUS [x1]) (PLUS xs2) =\n  PLUS (sorted_list_of_set (set ([x1] @ xs2)))\n\ngoal (2 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         PLUS (sorted_list_of_set (set ([] @ xs2)))\n 2. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<nexists>r s. x = Plus r s;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> ACI_nPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     PLUS\n(sorted_list_of_set (set ((y # xs) @ xs2)));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         PLUS\n                          (sorted_list_of_set (set ((x # y # xs) @ xs2)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         PLUS (sorted_list_of_set (set ([] @ xs2)))\n 2. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<nexists>r s. x = Plus r s;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> ACI_nPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     PLUS\n(sorted_list_of_set (set ((y # xs) @ xs2)));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         PLUS\n                          (sorted_list_of_set (set ((x # y # xs) @ xs2)))", "case (cons x11 x12 xs1)"], ["proof (state)\nthis:\n  \\<lbrakk>x12 # xs1 \\<noteq> []; ?xs2.0 \\<noteq> [];\n   \\<forall>x\\<in>set ((x12 # xs1) @ ?xs2.0). \\<nexists>r s. x = Plus r s;\n   sorted ?xs2.0; distinct ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS ?xs2.0) =\n                    PLUS (sorted_list_of_set (set ((x12 # xs1) @ ?xs2.0)))\n  x11 # x12 # xs1 \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2). \\<nexists>r s. x = Plus r s\n  sorted xs2\n  distinct xs2\n\ngoal (2 subgoals):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         PLUS (sorted_list_of_set (set ([] @ xs2)))\n 2. \\<And>x y xs xs2.\n       \\<lbrakk>\\<And>xs2.\n                   \\<lbrakk>y # xs \\<noteq> []; xs2 \\<noteq> [];\n                    \\<forall>x\\<in>set ((y # xs) @ xs2).\n                       \\<nexists>r s. x = Plus r s;\n                    sorted xs2; distinct xs2\\<rbrakk>\n                   \\<Longrightarrow> ACI_nPlus (PLUS (y # xs)) (PLUS xs2) =\n                                     PLUS\n(sorted_list_of_set (set ((y # xs) @ xs2)));\n        x # y # xs \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ((x # y # xs) @ xs2).\n           \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS (x # y # xs)) (PLUS xs2) =\n                         PLUS\n                          (sorted_list_of_set (set ((x # y # xs) @ xs2)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x12 # xs1 \\<noteq> []; ?xs2.0 \\<noteq> [];\n   \\<forall>x\\<in>set ((x12 # xs1) @ ?xs2.0). \\<nexists>r s. x = Plus r s;\n   sorted ?xs2.0; distinct ?xs2.0\\<rbrakk>\n  \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS ?xs2.0) =\n                    PLUS (sorted_list_of_set (set ((x12 # xs1) @ ?xs2.0)))\n  x11 # x12 # xs1 \\<noteq> []\n  xs2 \\<noteq> []\n  \\<forall>x\\<in>set ((x11 # x12 # xs1) @ xs2). \\<nexists>r s. x = Plus r s\n  sorted xs2\n  distinct xs2\n\ngoal (1 subgoal):\n 1. ACI_nPlus (PLUS (x11 # x12 # xs1)) (PLUS xs2) =\n    PLUS (sorted_list_of_set (set ((x11 # x12 # xs1) @ xs2)))", "apply (simp del: sorted_list_of_set_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus x11\n                       (PLUS\n                         (sorted_list_of_set\n                           (insert x12 (set xs1 \\<union> set xs2)))) =\n                      PLUS\n                       (sorted_list_of_set\n                         (insert x11\n                           (insert x12 (set xs1 \\<union> set xs2))))", "apply (rule trans[OF ACI_nPlus_singleton_PLUS])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> sorted_list_of_set\n                       (insert x12 (set xs1 \\<union> set xs2)) \\<noteq>\n                      []\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (sorted_list_of_set\n                         (insert x12 (set xs1 \\<union> set xs2)))\n 3. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (sorted_list_of_set\n                         (insert x12 (set xs1 \\<union> set xs2)))\n 4. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>{x11} \\<union>\n                                     set\n(sorted_list_of_set (insert x12 (set xs1 \\<union> set xs2))).\n                         \\<nexists>r s. x = Plus r s\n 5. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> [];\n     (\\<forall>r s. x11 \\<noteq> Plus r s) \\<and>\n     (\\<forall>r s. x12 \\<noteq> Plus r s) \\<and>\n     (\\<forall>x\\<in>set xs1 \\<union> set xs2.\n         \\<forall>r s. x \\<noteq> Plus r s);\n     sorted xs2; distinct xs2\\<rbrakk>\n    \\<Longrightarrow> (if x11\n                          \\<in> set (sorted_list_of_set\n(insert x12 (set xs1 \\<union> set xs2)))\n                       then PLUS\n                             (sorted_list_of_set\n                               (insert x12 (set xs1 \\<union> set xs2)))\n                       else PLUS\n                             (insort x11\n                               (sorted_list_of_set\n                                 (insert x12\n                                   (set xs1 \\<union> set xs2))))) =\n                      PLUS\n                       (sorted_list_of_set\n                         (insert x11\n                           (insert x12 (set xs1 \\<union> set xs2))))", "apply (auto simp del: sorted_list_of_set_insert simp add: insert_commute[of x11])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<in> set xs1\\<rbrakk>\n    \\<Longrightarrow> PLUS\n                       (sorted_list_of_set\n                         (insert x12 (set xs1 \\<union> set xs2))) =\n                      PLUS\n                       (sorted_list_of_set\n                         (insert x12\n                           (insert x11 (set xs1 \\<union> set xs2))))\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS\n                       (sorted_list_of_set\n                         (insert x12 (set xs1 \\<union> set xs2))) =\n                      PLUS\n                       (sorted_list_of_set\n                         (insert x12\n                           (insert x11 (set xs1 \\<union> set xs2))))\n 3. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x11 \\<noteq> Plus r s;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<noteq> x12; x11 \\<notin> set xs1; x11 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS\n                       (insort x11\n                         (sorted_list_of_set\n                           (insert x12 (set xs1 \\<union> set xs2)))) =\n                      PLUS\n                       (sorted_list_of_set\n                         (insert x12\n                           (insert x11 (set xs1 \\<union> set xs2))))", "apply (auto simp only: Un_insert_left[of x11, symmetric] insert_absorb) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<in> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS\n                       (sorted_list_of_set\n                         (insert x12 (set xs1 \\<union> set xs2))) =\n                      PLUS\n                       (sorted_list_of_set\n                         (insert x12\n                           (insert x11 (set xs1 \\<union> set xs2))))\n 2. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x11 \\<noteq> Plus r s;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<noteq> x12; x11 \\<notin> set xs1; x11 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS\n                       (insort x11\n                         (sorted_list_of_set\n                           (insert x12 (set xs1 \\<union> set xs2)))) =\n                      PLUS\n                       (sorted_list_of_set\n                         (insert x12\n                           (insert x11 (set xs1 \\<union> set xs2))))", "apply (auto simp only: Un_insert_right[of _ x11, symmetric] insert_absorb) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs2.\n                \\<lbrakk>xs2 \\<noteq> [];\n                 \\<forall>x\\<in>set xs1 \\<union> set xs2.\n                    \\<forall>r s. x \\<noteq> Plus r s;\n                 sorted xs2; distinct xs2\\<rbrakk>\n                \\<Longrightarrow> ACI_nPlus (PLUS (x12 # xs1)) (PLUS xs2) =\n                                  PLUS\n                                   (sorted_list_of_set\n                                     (insert x12\n (set xs1 \\<union> set xs2)));\n     xs2 \\<noteq> []; sorted xs2; distinct xs2;\n     \\<forall>r s. x11 \\<noteq> Plus r s;\n     \\<forall>r s. x12 \\<noteq> Plus r s;\n     \\<forall>x\\<in>set xs1 \\<union> set xs2.\n        \\<forall>r s. x \\<noteq> Plus r s;\n     x11 \\<noteq> x12; x11 \\<notin> set xs1; x11 \\<notin> set xs2\\<rbrakk>\n    \\<Longrightarrow> PLUS\n                       (insort x11\n                         (sorted_list_of_set\n                           (insert x12 (set xs1 \\<union> set xs2)))) =\n                      PLUS\n                       (sorted_list_of_set\n                         (insert x12\n                           (insert x11 (set xs1 \\<union> set xs2))))", "apply (auto simp add: insert_commute[of x12])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ACI_nPlus (PLUS (x11 # x12 # xs1)) (PLUS xs2) =\n  PLUS (sorted_list_of_set (set ((x11 # x12 # xs1) @ xs2)))\n\ngoal (1 subgoal):\n 1. \\<And>xs2.\n       \\<lbrakk>[] \\<noteq> []; xs2 \\<noteq> [];\n        \\<forall>x\\<in>set ([] @ xs2). \\<nexists>r s. x = Plus r s;\n        sorted xs2; distinct xs2\\<rbrakk>\n       \\<Longrightarrow> ACI_nPlus (PLUS []) (PLUS xs2) =\n                         PLUS (sorted_list_of_set (set ([] @ xs2)))", "qed simp"], ["", "lemma ACI_nPlus_flatten_PLUS:\n  \"\\<lbrakk>X1 \\<noteq> {}; X2 \\<noteq> {}; finite X1; finite X2; \\<forall>x \\<in> X1 \\<union> X2. \\<not>(\\<exists>r s. x = Plus r s)\\<rbrakk>\\<Longrightarrow>\n  ACI_nPlus (flatten PLUS X1) (flatten PLUS X2) = flatten PLUS (X1 \\<union> X2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X1 \\<noteq> {}; X2 \\<noteq> {}; finite X1; finite X2;\n     \\<forall>x\\<in>X1 \\<union> X2. \\<nexists>r s. x = Plus r s\\<rbrakk>\n    \\<Longrightarrow> ACI_nPlus (PLUS (sorted_list_of_set X1))\n                       (PLUS (sorted_list_of_set X2)) =\n                      PLUS (sorted_list_of_set (X1 \\<union> X2))", "by (rule trans[OF ACI_nPlus_PLUS]) auto"], ["", "lemma ACI_nPlus_ACI_norm[simp]: \"ACI_nPlus \\<guillemotleft>r\\<guillemotright> \\<guillemotleft>s\\<guillemotright> = \\<guillemotleft>Plus r s\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI_nPlus \\<guillemotleft>r\\<guillemotright>\n     \\<guillemotleft>s\\<guillemotright> =\n    \\<guillemotleft>Plus r s\\<guillemotright>", "using ACI_norm_flatten [of r] ACI_norm_flatten [of s] ACI_norm_flatten [of \"Plus r s\"]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>r\\<guillemotright> =\n  PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands r))\n  \\<guillemotleft>s\\<guillemotright> =\n  PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands s))\n  \\<guillemotleft>Plus r s\\<guillemotright> =\n  PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands (Plus r s)))\n\ngoal (1 subgoal):\n 1. ACI_nPlus \\<guillemotleft>r\\<guillemotright>\n     \\<guillemotleft>s\\<guillemotright> =\n    \\<guillemotleft>Plus r s\\<guillemotright>", "apply (auto intro!: trans [OF ACI_nPlus_flatten_PLUS])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ra sa xa.\n       \\<lbrakk>\\<guillemotleft>r\\<guillemotright> =\n                PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands r));\n        \\<guillemotleft>s\\<guillemotright> =\n        PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands s));\n        PLUS\n         (sorted_list_of_set\n           (toplevel_summands\n             (PLUS\n               (sorted_list_of_set\n                 (ACI_norm ` toplevel_summands r))) \\<union>\n            toplevel_summands\n             (PLUS\n               (sorted_list_of_set (ACI_norm ` toplevel_summands s))))) =\n        PLUS\n         (sorted_list_of_set\n           (ACI_norm ` (toplevel_summands r \\<union> toplevel_summands s)));\n        Plus ra sa = \\<guillemotleft>xa\\<guillemotright>;\n        xa \\<in> toplevel_summands r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ra sa xa.\n       \\<lbrakk>\\<guillemotleft>r\\<guillemotright> =\n                PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands r));\n        \\<guillemotleft>s\\<guillemotright> =\n        PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands s));\n        PLUS\n         (sorted_list_of_set\n           (toplevel_summands\n             (PLUS\n               (sorted_list_of_set\n                 (ACI_norm ` toplevel_summands r))) \\<union>\n            toplevel_summands\n             (PLUS\n               (sorted_list_of_set (ACI_norm ` toplevel_summands s))))) =\n        PLUS\n         (sorted_list_of_set\n           (ACI_norm ` (toplevel_summands r \\<union> toplevel_summands s)));\n        Plus ra sa = \\<guillemotleft>xa\\<guillemotright>;\n        xa \\<in> toplevel_summands s\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>\\<guillemotleft>r\\<guillemotright> =\n             PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands r));\n     \\<guillemotleft>s\\<guillemotright> =\n     PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands s));\n     PLUS\n      (sorted_list_of_set\n        (toplevel_summands\n          (PLUS\n            (sorted_list_of_set (ACI_norm ` toplevel_summands r))) \\<union>\n         toplevel_summands\n          (PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands s))))) =\n     PLUS\n      (sorted_list_of_set\n        (ACI_norm `\n         (toplevel_summands r \\<union> toplevel_summands s)))\\<rbrakk>\n    \\<Longrightarrow> PLUS\n                       (sorted_list_of_set\n                         (ACI_norm ` toplevel_summands r \\<union>\n                          ACI_norm ` toplevel_summands s)) =\n                      PLUS\n                       (sorted_list_of_set\n                         (ACI_norm `\n                          (toplevel_summands r \\<union>\n                           toplevel_summands s)))", "apply (auto simp: image_Un Un_assoc  intro!: trans [OF ACI_nPlus_flatten_PLUS])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ra sa xa.\n       \\<lbrakk>\\<guillemotleft>r\\<guillemotright> =\n                PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands r));\n        \\<guillemotleft>s\\<guillemotright> =\n        PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands s));\n        PLUS\n         (sorted_list_of_set\n           (toplevel_summands\n             (PLUS\n               (sorted_list_of_set\n                 (ACI_norm ` toplevel_summands r))) \\<union>\n            toplevel_summands\n             (PLUS\n               (sorted_list_of_set (ACI_norm ` toplevel_summands s))))) =\n        PLUS\n         (sorted_list_of_set\n           (ACI_norm ` toplevel_summands r \\<union>\n            ACI_norm ` toplevel_summands s));\n        Plus ra sa = \\<guillemotleft>xa\\<guillemotright>;\n        xa \\<in> toplevel_summands r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ra sa xa.\n       \\<lbrakk>\\<guillemotleft>r\\<guillemotright> =\n                PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands r));\n        \\<guillemotleft>s\\<guillemotright> =\n        PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands s));\n        PLUS\n         (sorted_list_of_set\n           (toplevel_summands\n             (PLUS\n               (sorted_list_of_set\n                 (ACI_norm ` toplevel_summands r))) \\<union>\n            toplevel_summands\n             (PLUS\n               (sorted_list_of_set (ACI_norm ` toplevel_summands s))))) =\n        PLUS\n         (sorted_list_of_set\n           (ACI_norm ` toplevel_summands r \\<union>\n            ACI_norm ` toplevel_summands s));\n        Plus ra sa = \\<guillemotleft>xa\\<guillemotright>;\n        xa \\<in> toplevel_summands s\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis ACI_norm_Plus Plus_toplevel_summands)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ACI_norm_alt:\n  \"ACI_norm_alt r = \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI_norm_alt r = \\<guillemotleft>r\\<guillemotright>", "by (induct r) auto"], ["", "declare ACI_norm_alt[symmetric, code]"], ["", "subsection \\<open>Finality\\<close>"], ["", "primrec final :: \"'a rexp \\<Rightarrow> bool\"\nwhere\n  \"final Zero = False\"\n| \"final Full = True\"\n| \"final One = True\"\n| \"final (Atom _) = False\"\n| \"final (Plus r s) = (final r \\<or> final s)\"\n| \"final (Times r s) = (final r \\<and> final s)\"\n| \"final (Star _) = True\"\n| \"final (Not r) = (~ final r)\"\n| \"final (Inter r1 r2) = (final r1 \\<and> final r2)\"\n| \"final (Pr r) = final r\""], ["", "lemma toplevel_summands_final:\n  \"final s = (\\<exists>r\\<in>toplevel_summands s. final r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final s = (\\<exists>r\\<in>toplevel_summands s. final r)", "by (induct s) auto"], ["", "lemma final_PLUS:\n  \"final (PLUS xs) = (\\<exists>r \\<in> set xs. final r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final (PLUS xs) = (\\<exists>r\\<in>set xs. final r)", "by (induct xs rule: list_singleton_induct) auto"], ["", "theorem ACI_norm_final[simp]:\n  \"final \\<guillemotleft>r\\<guillemotright> = final r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final \\<guillemotleft>r\\<guillemotright> = final r", "proof (induct r)"], ["proof (state)\ngoal (10 subgoals):\n 1. final \\<guillemotleft>Zero\\<guillemotright> = final Zero\n 2. final \\<guillemotleft>Full\\<guillemotright> = final Full\n 3. final \\<guillemotleft>One\\<guillemotright> = final One\n 4. \\<And>x. final \\<guillemotleft>Atom x\\<guillemotright> = final (Atom x)\n 5. \\<And>r1 r2.\n       \\<lbrakk>final \\<guillemotleft>r1\\<guillemotright> = final r1;\n        final \\<guillemotleft>r2\\<guillemotright> = final r2\\<rbrakk>\n       \\<Longrightarrow> final \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         final (Plus r1 r2)\n 6. \\<And>r1 r2.\n       \\<lbrakk>final \\<guillemotleft>r1\\<guillemotright> = final r1;\n        final \\<guillemotleft>r2\\<guillemotright> = final r2\\<rbrakk>\n       \\<Longrightarrow> final\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         final (Times r1 r2)\n 7. \\<And>r.\n       final \\<guillemotleft>r\\<guillemotright> = final r \\<Longrightarrow>\n       final \\<guillemotleft>Star r\\<guillemotright> = final (Star r)\n 8. \\<And>r.\n       final \\<guillemotleft>r\\<guillemotright> = final r \\<Longrightarrow>\n       final \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       final (rexp.Not r)\n 9. \\<And>r1 r2.\n       \\<lbrakk>final \\<guillemotleft>r1\\<guillemotright> = final r1;\n        final \\<guillemotleft>r2\\<guillemotright> = final r2\\<rbrakk>\n       \\<Longrightarrow> final\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         final (rexp.Inter r1 r2)\n 10. \\<And>r.\n        final \\<guillemotleft>r\\<guillemotright> = final r \\<Longrightarrow>\n        final \\<guillemotleft>Pr r\\<guillemotright> = final (Pr r)", "case (Plus r1 r2)"], ["proof (state)\nthis:\n  final \\<guillemotleft>r1\\<guillemotright> = final r1\n  final \\<guillemotleft>r2\\<guillemotright> = final r2\n\ngoal (10 subgoals):\n 1. final \\<guillemotleft>Zero\\<guillemotright> = final Zero\n 2. final \\<guillemotleft>Full\\<guillemotright> = final Full\n 3. final \\<guillemotleft>One\\<guillemotright> = final One\n 4. \\<And>x. final \\<guillemotleft>Atom x\\<guillemotright> = final (Atom x)\n 5. \\<And>r1 r2.\n       \\<lbrakk>final \\<guillemotleft>r1\\<guillemotright> = final r1;\n        final \\<guillemotleft>r2\\<guillemotright> = final r2\\<rbrakk>\n       \\<Longrightarrow> final \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         final (Plus r1 r2)\n 6. \\<And>r1 r2.\n       \\<lbrakk>final \\<guillemotleft>r1\\<guillemotright> = final r1;\n        final \\<guillemotleft>r2\\<guillemotright> = final r2\\<rbrakk>\n       \\<Longrightarrow> final\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         final (Times r1 r2)\n 7. \\<And>r.\n       final \\<guillemotleft>r\\<guillemotright> = final r \\<Longrightarrow>\n       final \\<guillemotleft>Star r\\<guillemotright> = final (Star r)\n 8. \\<And>r.\n       final \\<guillemotleft>r\\<guillemotright> = final r \\<Longrightarrow>\n       final \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       final (rexp.Not r)\n 9. \\<And>r1 r2.\n       \\<lbrakk>final \\<guillemotleft>r1\\<guillemotright> = final r1;\n        final \\<guillemotleft>r2\\<guillemotright> = final r2\\<rbrakk>\n       \\<Longrightarrow> final\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         final (rexp.Inter r1 r2)\n 10. \\<And>r.\n        final \\<guillemotleft>r\\<guillemotright> = final r \\<Longrightarrow>\n        final \\<guillemotleft>Pr r\\<guillemotright> = final (Pr r)", "thus ?case"], ["proof (prove)\nusing this:\n  final \\<guillemotleft>r1\\<guillemotright> = final r1\n  final \\<guillemotleft>r2\\<guillemotright> = final r2\n\ngoal (1 subgoal):\n 1. final \\<guillemotleft>Plus r1 r2\\<guillemotright> = final (Plus r1 r2)", "using toplevel_summands_final"], ["proof (prove)\nusing this:\n  final \\<guillemotleft>r1\\<guillemotright> = final r1\n  final \\<guillemotleft>r2\\<guillemotright> = final r2\n  final ?s = (\\<exists>r\\<in>toplevel_summands ?s. final r)\n\ngoal (1 subgoal):\n 1. final \\<guillemotleft>Plus r1 r2\\<guillemotright> = final (Plus r1 r2)", "by (auto simp: final_PLUS)"], ["proof (state)\nthis:\n  final \\<guillemotleft>Plus r1 r2\\<guillemotright> = final (Plus r1 r2)\n\ngoal (9 subgoals):\n 1. final \\<guillemotleft>Zero\\<guillemotright> = final Zero\n 2. final \\<guillemotleft>Full\\<guillemotright> = final Full\n 3. final \\<guillemotleft>One\\<guillemotright> = final One\n 4. \\<And>x. final \\<guillemotleft>Atom x\\<guillemotright> = final (Atom x)\n 5. \\<And>r1 r2.\n       \\<lbrakk>final \\<guillemotleft>r1\\<guillemotright> = final r1;\n        final \\<guillemotleft>r2\\<guillemotright> = final r2\\<rbrakk>\n       \\<Longrightarrow> final\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         final (Times r1 r2)\n 6. \\<And>r.\n       final \\<guillemotleft>r\\<guillemotright> = final r \\<Longrightarrow>\n       final \\<guillemotleft>Star r\\<guillemotright> = final (Star r)\n 7. \\<And>r.\n       final \\<guillemotleft>r\\<guillemotright> = final r \\<Longrightarrow>\n       final \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       final (rexp.Not r)\n 8. \\<And>r1 r2.\n       \\<lbrakk>final \\<guillemotleft>r1\\<guillemotright> = final r1;\n        final \\<guillemotleft>r2\\<guillemotright> = final r2\\<rbrakk>\n       \\<Longrightarrow> final\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         final (rexp.Inter r1 r2)\n 9. \\<And>r.\n       final \\<guillemotleft>r\\<guillemotright> = final r \\<Longrightarrow>\n       final \\<guillemotleft>Pr r\\<guillemotright> = final (Pr r)", "qed auto"], ["", "subsection \\<open>Wellformedness w.r.t. an alphabet\\<close>"], ["", "locale alphabet =\nfixes \\<Sigma> :: \"nat \\<Rightarrow> 'a set\" (\"\\<Sigma> _\")\nand wf_atom :: \"nat \\<Rightarrow> 'b :: linorder \\<Rightarrow> bool\"\nbegin"], ["", "primrec wf :: \"nat \\<Rightarrow> 'b rexp \\<Rightarrow> bool\"\nwhere\n\"wf n Zero = True\" |\n\"wf n Full = True\" |\n\"wf n One = True\" |\n\"wf n (Atom a) = (wf_atom n a)\" |\n\"wf n (Plus r s) = (wf n r \\<and> wf n s)\" |\n\"wf n (Times r s) = (wf n r \\<and> wf n s)\" |\n\"wf n (Star r) = wf n r\" |\n\"wf n (Not r) = wf n r\" |\n\"wf n (Inter r s) = (wf n r \\<and> wf n s)\" |\n\"wf n (Pr r) = wf (n + 1) r\""], ["", "primrec wf_word where\n  \"wf_word n [] = True\"\n| \"wf_word n (w # ws) = ((w \\<in> \\<Sigma> n) \\<and> wf_word n ws)\""], ["", "lemma wf_word_snoc[simp]: \"wf_word n (ws @ [w]) = ((w \\<in> \\<Sigma> n) \\<and> wf_word n ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_word n (ws @ [w]) = (w \\<in> \\<Sigma> n \\<and> wf_word n ws)", "by (induct ws) auto"], ["", "lemma wf_word_append[simp]: \"wf_word n (ws @ vs) = (wf_word n ws \\<and> wf_word n vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_word n (ws @ vs) = (wf_word n ws \\<and> wf_word n vs)", "by (induct ws arbitrary: vs) auto"], ["", "lemma wf_word: \"wf_word n w = (w \\<in> lists (\\<Sigma> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_word n w = (w \\<in> lists \\<Sigma> n)", "by (induct w) auto"], ["", "lemma toplevel_summands_wf:\n  \"wf n s = (\\<forall>r\\<in>toplevel_summands s. wf n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n s = (\\<forall>r\\<in>toplevel_summands s. local.wf n r)", "by (induct s) auto"], ["", "lemma wf_PLUS[simp]:\n  \"wf n (PLUS xs) = (\\<forall>r \\<in> set xs. wf n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n (PLUS xs) = (\\<forall>r\\<in>set xs. local.wf n r)", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma wf_TIMES[simp]:\n  \"wf n (TIMES xs) = (\\<forall>r \\<in> set xs. wf n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n (TIMES xs) = (\\<forall>r\\<in>set xs. local.wf n r)", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma wf_flatten_PLUS[simp]:\n  \"finite X \\<Longrightarrow> wf n (flatten PLUS X) = (\\<forall>r \\<in> X. wf n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    local.wf n (PLUS (sorted_list_of_set X)) =\n    (\\<forall>r\\<in>X. local.wf n r)", "using wf_PLUS[of n \"sorted_list_of_set X\"]"], ["proof (prove)\nusing this:\n  local.wf n (PLUS (sorted_list_of_set X)) =\n  (\\<forall>r\\<in>set (sorted_list_of_set X). local.wf n r)\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    local.wf n (PLUS (sorted_list_of_set X)) =\n    (\\<forall>r\\<in>X. local.wf n r)", "by fastforce"], ["", "theorem ACI_norm_wf[simp]:\n  \"wf n \\<guillemotleft>r\\<guillemotright> = wf n r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n \\<guillemotleft>r\\<guillemotright> = local.wf n r", "proof (induct r arbitrary: n)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n.\n       local.wf n \\<guillemotleft>Zero\\<guillemotright> = local.wf n Zero\n 2. \\<And>n.\n       local.wf n \\<guillemotleft>Full\\<guillemotright> = local.wf n Full\n 3. \\<And>n.\n       local.wf n \\<guillemotleft>One\\<guillemotright> = local.wf n One\n 4. \\<And>x n.\n       local.wf n \\<guillemotleft>Atom x\\<guillemotright> =\n       local.wf n (Atom x)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n \\<guillemotleft>r1\\<guillemotright> =\n                   local.wf n r1;\n        \\<And>n.\n           local.wf n \\<guillemotleft>r2\\<guillemotright> =\n           local.wf n r2\\<rbrakk>\n       \\<Longrightarrow> local.wf n\n                          \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         local.wf n (Plus r1 r2)\n 6. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n \\<guillemotleft>r1\\<guillemotright> =\n                   local.wf n r1;\n        \\<And>n.\n           local.wf n \\<guillemotleft>r2\\<guillemotright> =\n           local.wf n r2\\<rbrakk>\n       \\<Longrightarrow> local.wf n\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         local.wf n (Times r1 r2)\n 7. \\<And>r n.\n       (\\<And>n.\n           local.wf n \\<guillemotleft>r\\<guillemotright> =\n           local.wf n r) \\<Longrightarrow>\n       local.wf n \\<guillemotleft>Star r\\<guillemotright> =\n       local.wf n (Star r)\n 8. \\<And>r n.\n       (\\<And>n.\n           local.wf n \\<guillemotleft>r\\<guillemotright> =\n           local.wf n r) \\<Longrightarrow>\n       local.wf n \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       local.wf n (rexp.Not r)\n 9. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n \\<guillemotleft>r1\\<guillemotright> =\n                   local.wf n r1;\n        \\<And>n.\n           local.wf n \\<guillemotleft>r2\\<guillemotright> =\n           local.wf n r2\\<rbrakk>\n       \\<Longrightarrow> local.wf n\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         local.wf n (rexp.Inter r1 r2)\n 10. \\<And>r n.\n        (\\<And>n.\n            local.wf n \\<guillemotleft>r\\<guillemotright> =\n            local.wf n r) \\<Longrightarrow>\n        local.wf n \\<guillemotleft>Pr r\\<guillemotright> = local.wf n (Pr r)", "case (Plus r1 r2)"], ["proof (state)\nthis:\n  local.wf ?n \\<guillemotleft>r1\\<guillemotright> = local.wf ?n r1\n  local.wf ?n \\<guillemotleft>r2\\<guillemotright> = local.wf ?n r2\n\ngoal (10 subgoals):\n 1. \\<And>n.\n       local.wf n \\<guillemotleft>Zero\\<guillemotright> = local.wf n Zero\n 2. \\<And>n.\n       local.wf n \\<guillemotleft>Full\\<guillemotright> = local.wf n Full\n 3. \\<And>n.\n       local.wf n \\<guillemotleft>One\\<guillemotright> = local.wf n One\n 4. \\<And>x n.\n       local.wf n \\<guillemotleft>Atom x\\<guillemotright> =\n       local.wf n (Atom x)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n \\<guillemotleft>r1\\<guillemotright> =\n                   local.wf n r1;\n        \\<And>n.\n           local.wf n \\<guillemotleft>r2\\<guillemotright> =\n           local.wf n r2\\<rbrakk>\n       \\<Longrightarrow> local.wf n\n                          \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         local.wf n (Plus r1 r2)\n 6. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n \\<guillemotleft>r1\\<guillemotright> =\n                   local.wf n r1;\n        \\<And>n.\n           local.wf n \\<guillemotleft>r2\\<guillemotright> =\n           local.wf n r2\\<rbrakk>\n       \\<Longrightarrow> local.wf n\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         local.wf n (Times r1 r2)\n 7. \\<And>r n.\n       (\\<And>n.\n           local.wf n \\<guillemotleft>r\\<guillemotright> =\n           local.wf n r) \\<Longrightarrow>\n       local.wf n \\<guillemotleft>Star r\\<guillemotright> =\n       local.wf n (Star r)\n 8. \\<And>r n.\n       (\\<And>n.\n           local.wf n \\<guillemotleft>r\\<guillemotright> =\n           local.wf n r) \\<Longrightarrow>\n       local.wf n \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       local.wf n (rexp.Not r)\n 9. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n \\<guillemotleft>r1\\<guillemotright> =\n                   local.wf n r1;\n        \\<And>n.\n           local.wf n \\<guillemotleft>r2\\<guillemotright> =\n           local.wf n r2\\<rbrakk>\n       \\<Longrightarrow> local.wf n\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         local.wf n (rexp.Inter r1 r2)\n 10. \\<And>r n.\n        (\\<And>n.\n            local.wf n \\<guillemotleft>r\\<guillemotright> =\n            local.wf n r) \\<Longrightarrow>\n        local.wf n \\<guillemotleft>Pr r\\<guillemotright> = local.wf n (Pr r)", "thus ?case"], ["proof (prove)\nusing this:\n  local.wf ?n \\<guillemotleft>r1\\<guillemotright> = local.wf ?n r1\n  local.wf ?n \\<guillemotleft>r2\\<guillemotright> = local.wf ?n r2\n\ngoal (1 subgoal):\n 1. local.wf n \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n    local.wf n (Plus r1 r2)", "using toplevel_summands_wf[of n \"\\<guillemotleft>r1\\<guillemotright>\"] toplevel_summands_wf[of n \"\\<guillemotleft>r2\\<guillemotright>\"]"], ["proof (prove)\nusing this:\n  local.wf ?n \\<guillemotleft>r1\\<guillemotright> = local.wf ?n r1\n  local.wf ?n \\<guillemotleft>r2\\<guillemotright> = local.wf ?n r2\n  local.wf n \\<guillemotleft>r1\\<guillemotright> =\n  (\\<forall>r\\<in>toplevel_summands \\<guillemotleft>r1\\<guillemotright>.\n      local.wf n r)\n  local.wf n \\<guillemotleft>r2\\<guillemotright> =\n  (\\<forall>r\\<in>toplevel_summands \\<guillemotleft>r2\\<guillemotright>.\n      local.wf n r)\n\ngoal (1 subgoal):\n 1. local.wf n \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n    local.wf n (Plus r1 r2)", "by auto"], ["proof (state)\nthis:\n  local.wf n \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n  local.wf n (Plus r1 r2)\n\ngoal (9 subgoals):\n 1. \\<And>n.\n       local.wf n \\<guillemotleft>Zero\\<guillemotright> = local.wf n Zero\n 2. \\<And>n.\n       local.wf n \\<guillemotleft>Full\\<guillemotright> = local.wf n Full\n 3. \\<And>n.\n       local.wf n \\<guillemotleft>One\\<guillemotright> = local.wf n One\n 4. \\<And>x n.\n       local.wf n \\<guillemotleft>Atom x\\<guillemotright> =\n       local.wf n (Atom x)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n \\<guillemotleft>r1\\<guillemotright> =\n                   local.wf n r1;\n        \\<And>n.\n           local.wf n \\<guillemotleft>r2\\<guillemotright> =\n           local.wf n r2\\<rbrakk>\n       \\<Longrightarrow> local.wf n\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         local.wf n (Times r1 r2)\n 6. \\<And>r n.\n       (\\<And>n.\n           local.wf n \\<guillemotleft>r\\<guillemotright> =\n           local.wf n r) \\<Longrightarrow>\n       local.wf n \\<guillemotleft>Star r\\<guillemotright> =\n       local.wf n (Star r)\n 7. \\<And>r n.\n       (\\<And>n.\n           local.wf n \\<guillemotleft>r\\<guillemotright> =\n           local.wf n r) \\<Longrightarrow>\n       local.wf n \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       local.wf n (rexp.Not r)\n 8. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n \\<guillemotleft>r1\\<guillemotright> =\n                   local.wf n r1;\n        \\<And>n.\n           local.wf n \\<guillemotleft>r2\\<guillemotright> =\n           local.wf n r2\\<rbrakk>\n       \\<Longrightarrow> local.wf n\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         local.wf n (rexp.Inter r1 r2)\n 9. \\<And>r n.\n       (\\<And>n.\n           local.wf n \\<guillemotleft>r\\<guillemotright> =\n           local.wf n r) \\<Longrightarrow>\n       local.wf n \\<guillemotleft>Pr r\\<guillemotright> = local.wf n (Pr r)", "qed auto"], ["", "lemma wf_INTERSECT[simp]:\n  \"wf n (INTERSECT xs) = (\\<forall>r \\<in> set xs. wf n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n (INTERSECT xs) = (\\<forall>r\\<in>set xs. local.wf n r)", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma wf_flatten_INTERSECT[simp]:\n  \"finite X \\<Longrightarrow> wf n (flatten INTERSECT X) = (\\<forall>r \\<in> X. wf n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    local.wf n (INTERSECT (sorted_list_of_set X)) =\n    (\\<forall>r\\<in>X. local.wf n r)", "using wf_INTERSECT[of n \"sorted_list_of_set X\"]"], ["proof (prove)\nusing this:\n  local.wf n (INTERSECT (sorted_list_of_set X)) =\n  (\\<forall>r\\<in>set (sorted_list_of_set X). local.wf n r)\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    local.wf n (INTERSECT (sorted_list_of_set X)) =\n    (\\<forall>r\\<in>X. local.wf n r)", "by fastforce"], ["", "end"], ["", "subsection \\<open>Language\\<close>"], ["", "locale project =\n  alphabet \\<Sigma> wf_atom for \\<Sigma> :: \"nat \\<Rightarrow> 'a set\" and wf_atom :: \"nat \\<Rightarrow> 'b :: linorder \\<Rightarrow> bool\" +\nfixes project :: \"'a \\<Rightarrow> 'a\"\nand lookup :: \"'b \\<Rightarrow> 'a \\<Rightarrow> bool\"\nassumes project: \"\\<And>a. a \\<in> \\<Sigma> (Suc n) \\<Longrightarrow> project a \\<in> \\<Sigma> n\"\nbegin"], ["", "primrec lang :: \"nat \\<Rightarrow> 'b rexp => 'a lang\" where\n\"lang n Zero = {}\" |\n\"lang n Full = lists (\\<Sigma> n)\" |\n\"lang n One = {[]}\" |\n\"lang n (Atom b) = {[x] | x. lookup b x \\<and> x \\<in> \\<Sigma> n}\" |\n\"lang n (Plus r s) = (lang n r) \\<union> (lang n s)\" |\n\"lang n (Times r s) = conc (lang n r) (lang n s)\" |\n\"lang n (Star r) = star (lang n r)\" |\n\"lang n (Not r) = lists (\\<Sigma> n) - lang n r\" |\n\"lang n (Inter r s) = (lang n r \\<inter> lang n s)\" |\n\"lang n (Pr r) = map project ` lang (n + 1) r\""], ["", "lemma wf_word_map_project[simp]: \"wf_word (Suc n) ws \\<Longrightarrow> wf_word n (map project ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_word (Suc n) ws \\<Longrightarrow> wf_word n (map project ws)", "by (induct ws arbitrary: n) (auto intro: project)"], ["", "lemma wf_lang_wf_word: \"wf n r \\<Longrightarrow> \\<forall>w \\<in> lang n r. wf_word n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> \\<forall>w\\<in>lang n r. wf_word n w", "by (induct r arbitrary: n) (auto elim: rev_subsetD[OF _ conc_mono] star_induct intro: iffD2[OF wf_word])"], ["", "lemma lang_subset_lists: \"wf n r \\<Longrightarrow> lang n r \\<subseteq> lists (\\<Sigma> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> lang n r \\<subseteq> lists (\\<Sigma> n)", "proof (induct r arbitrary: n)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n.\n       local.wf n Zero \\<Longrightarrow>\n       lang n Zero \\<subseteq> lists (\\<Sigma> n)\n 2. \\<And>n.\n       local.wf n Full \\<Longrightarrow>\n       lang n Full \\<subseteq> lists (\\<Sigma> n)\n 3. \\<And>n.\n       local.wf n One \\<Longrightarrow>\n       lang n One \\<subseteq> lists (\\<Sigma> n)\n 4. \\<And>x n.\n       local.wf n (Atom x) \\<Longrightarrow>\n       lang n (Atom x) \\<subseteq> lists (\\<Sigma> n)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r1 \\<Longrightarrow>\n                   lang n r1 \\<subseteq> lists (\\<Sigma> n);\n        \\<And>n.\n           local.wf n r2 \\<Longrightarrow>\n           lang n r2 \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (Plus r1 r2)\\<rbrakk>\n       \\<Longrightarrow> lang n (Plus r1 r2) \\<subseteq> lists (\\<Sigma> n)\n 6. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r1 \\<Longrightarrow>\n                   lang n r1 \\<subseteq> lists (\\<Sigma> n);\n        \\<And>n.\n           local.wf n r2 \\<Longrightarrow>\n           lang n r2 \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (Times r1 r2)\\<rbrakk>\n       \\<Longrightarrow> lang n (Times r1 r2) \\<subseteq> lists (\\<Sigma> n)\n 7. \\<And>r n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r \\<Longrightarrow>\n                   lang n r \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (Star r)\\<rbrakk>\n       \\<Longrightarrow> lang n (Star r) \\<subseteq> lists (\\<Sigma> n)\n 8. \\<And>r n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r \\<Longrightarrow>\n                   lang n r \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (rexp.Not r)\\<rbrakk>\n       \\<Longrightarrow> lang n (rexp.Not r) \\<subseteq> lists (\\<Sigma> n)\n 9. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r1 \\<Longrightarrow>\n                   lang n r1 \\<subseteq> lists (\\<Sigma> n);\n        \\<And>n.\n           local.wf n r2 \\<Longrightarrow>\n           lang n r2 \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (rexp.Inter r1 r2)\\<rbrakk>\n       \\<Longrightarrow> lang n (rexp.Inter r1 r2)\n                         \\<subseteq> lists (\\<Sigma> n)\n 10. \\<And>r n.\n        \\<lbrakk>\\<And>n.\n                    local.wf n r \\<Longrightarrow>\n                    lang n r \\<subseteq> lists (\\<Sigma> n);\n         local.wf n (Pr r)\\<rbrakk>\n        \\<Longrightarrow> lang n (Pr r) \\<subseteq> lists (\\<Sigma> n)", "case Pr"], ["proof (state)\nthis:\n  local.wf ?n r_ \\<Longrightarrow>\n  lang ?n r_ \\<subseteq> lists (\\<Sigma> ?n)\n  local.wf n (Pr r_)\n\ngoal (10 subgoals):\n 1. \\<And>n.\n       local.wf n Zero \\<Longrightarrow>\n       lang n Zero \\<subseteq> lists (\\<Sigma> n)\n 2. \\<And>n.\n       local.wf n Full \\<Longrightarrow>\n       lang n Full \\<subseteq> lists (\\<Sigma> n)\n 3. \\<And>n.\n       local.wf n One \\<Longrightarrow>\n       lang n One \\<subseteq> lists (\\<Sigma> n)\n 4. \\<And>x n.\n       local.wf n (Atom x) \\<Longrightarrow>\n       lang n (Atom x) \\<subseteq> lists (\\<Sigma> n)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r1 \\<Longrightarrow>\n                   lang n r1 \\<subseteq> lists (\\<Sigma> n);\n        \\<And>n.\n           local.wf n r2 \\<Longrightarrow>\n           lang n r2 \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (Plus r1 r2)\\<rbrakk>\n       \\<Longrightarrow> lang n (Plus r1 r2) \\<subseteq> lists (\\<Sigma> n)\n 6. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r1 \\<Longrightarrow>\n                   lang n r1 \\<subseteq> lists (\\<Sigma> n);\n        \\<And>n.\n           local.wf n r2 \\<Longrightarrow>\n           lang n r2 \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (Times r1 r2)\\<rbrakk>\n       \\<Longrightarrow> lang n (Times r1 r2) \\<subseteq> lists (\\<Sigma> n)\n 7. \\<And>r n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r \\<Longrightarrow>\n                   lang n r \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (Star r)\\<rbrakk>\n       \\<Longrightarrow> lang n (Star r) \\<subseteq> lists (\\<Sigma> n)\n 8. \\<And>r n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r \\<Longrightarrow>\n                   lang n r \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (rexp.Not r)\\<rbrakk>\n       \\<Longrightarrow> lang n (rexp.Not r) \\<subseteq> lists (\\<Sigma> n)\n 9. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r1 \\<Longrightarrow>\n                   lang n r1 \\<subseteq> lists (\\<Sigma> n);\n        \\<And>n.\n           local.wf n r2 \\<Longrightarrow>\n           lang n r2 \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (rexp.Inter r1 r2)\\<rbrakk>\n       \\<Longrightarrow> lang n (rexp.Inter r1 r2)\n                         \\<subseteq> lists (\\<Sigma> n)\n 10. \\<And>r n.\n        \\<lbrakk>\\<And>n.\n                    local.wf n r \\<Longrightarrow>\n                    lang n r \\<subseteq> lists (\\<Sigma> n);\n         local.wf n (Pr r)\\<rbrakk>\n        \\<Longrightarrow> lang n (Pr r) \\<subseteq> lists (\\<Sigma> n)", "thus ?case"], ["proof (prove)\nusing this:\n  local.wf ?n r_ \\<Longrightarrow>\n  lang ?n r_ \\<subseteq> lists (\\<Sigma> ?n)\n  local.wf n (Pr r_)\n\ngoal (1 subgoal):\n 1. lang n (Pr r_) \\<subseteq> lists (\\<Sigma> n)", "by (fastforce intro!: project)"], ["proof (state)\nthis:\n  lang n (Pr r_) \\<subseteq> lists (\\<Sigma> n)\n\ngoal (9 subgoals):\n 1. \\<And>n.\n       local.wf n Zero \\<Longrightarrow>\n       lang n Zero \\<subseteq> lists (\\<Sigma> n)\n 2. \\<And>n.\n       local.wf n Full \\<Longrightarrow>\n       lang n Full \\<subseteq> lists (\\<Sigma> n)\n 3. \\<And>n.\n       local.wf n One \\<Longrightarrow>\n       lang n One \\<subseteq> lists (\\<Sigma> n)\n 4. \\<And>x n.\n       local.wf n (Atom x) \\<Longrightarrow>\n       lang n (Atom x) \\<subseteq> lists (\\<Sigma> n)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r1 \\<Longrightarrow>\n                   lang n r1 \\<subseteq> lists (\\<Sigma> n);\n        \\<And>n.\n           local.wf n r2 \\<Longrightarrow>\n           lang n r2 \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (Plus r1 r2)\\<rbrakk>\n       \\<Longrightarrow> lang n (Plus r1 r2) \\<subseteq> lists (\\<Sigma> n)\n 6. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r1 \\<Longrightarrow>\n                   lang n r1 \\<subseteq> lists (\\<Sigma> n);\n        \\<And>n.\n           local.wf n r2 \\<Longrightarrow>\n           lang n r2 \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (Times r1 r2)\\<rbrakk>\n       \\<Longrightarrow> lang n (Times r1 r2) \\<subseteq> lists (\\<Sigma> n)\n 7. \\<And>r n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r \\<Longrightarrow>\n                   lang n r \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (Star r)\\<rbrakk>\n       \\<Longrightarrow> lang n (Star r) \\<subseteq> lists (\\<Sigma> n)\n 8. \\<And>r n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r \\<Longrightarrow>\n                   lang n r \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (rexp.Not r)\\<rbrakk>\n       \\<Longrightarrow> lang n (rexp.Not r) \\<subseteq> lists (\\<Sigma> n)\n 9. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   local.wf n r1 \\<Longrightarrow>\n                   lang n r1 \\<subseteq> lists (\\<Sigma> n);\n        \\<And>n.\n           local.wf n r2 \\<Longrightarrow>\n           lang n r2 \\<subseteq> lists (\\<Sigma> n);\n        local.wf n (rexp.Inter r1 r2)\\<rbrakk>\n       \\<Longrightarrow> lang n (rexp.Inter r1 r2)\n                         \\<subseteq> lists (\\<Sigma> n)", "qed (auto simp: conc_subset_lists star_subset_lists)"], ["", "lemma toplevel_summands_lang:\n  \"r \\<in> toplevel_summands s \\<Longrightarrow> lang n r \\<subseteq> lang n s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> toplevel_summands s \\<Longrightarrow>\n    lang n r \\<subseteq> lang n s", "by (induct s) auto"], ["", "lemma toplevel_summands_lang_UN:\n  \"lang n s = (\\<Union>r\\<in>toplevel_summands s. lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n s = \\<Union> (lang n ` toplevel_summands s)", "by (induct s) auto"], ["", "lemma toplevel_summands_in_lang:\n  \"w \\<in> lang n s = (\\<exists>r\\<in>toplevel_summands s. w \\<in> lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> lang n s) =\n    (\\<exists>r\\<in>toplevel_summands s. w \\<in> lang n r)", "by (induct s) auto"], ["", "lemma lang_PLUS[simp]:\n  \"lang n (PLUS xs) = (\\<Union>r \\<in> set xs. lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n (PLUS xs) = \\<Union> (lang n ` set xs)", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma lang_TIMES[simp]:\n  \"lang n (TIMES xs) = foldr (@@) (map (lang n) xs) {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n (TIMES xs) = foldr (@@) (map (lang n) xs) {[]}", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma lang_flatten_PLUS:\n  \"finite X \\<Longrightarrow> lang n (flatten PLUS X) = (\\<Union>r \\<in> X. lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    lang n (PLUS (sorted_list_of_set X)) = \\<Union> (lang n ` X)", "using lang_PLUS[of n \"sorted_list_of_set X\"]"], ["proof (prove)\nusing this:\n  lang n (PLUS (sorted_list_of_set X)) =\n  \\<Union> (lang n ` set (sorted_list_of_set X))\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    lang n (PLUS (sorted_list_of_set X)) = \\<Union> (lang n ` X)", "by fastforce"], ["", "theorem ACI_norm_lang[simp]:\n  \"lang n \\<guillemotleft>r\\<guillemotright> = lang n r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n \\<guillemotleft>r\\<guillemotright> = lang n r", "proof (induct r arbitrary: n)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n. lang n \\<guillemotleft>Zero\\<guillemotright> = lang n Zero\n 2. \\<And>n. lang n \\<guillemotleft>Full\\<guillemotright> = lang n Full\n 3. \\<And>n. lang n \\<guillemotleft>One\\<guillemotright> = lang n One\n 4. \\<And>x n.\n       lang n \\<guillemotleft>Atom x\\<guillemotright> = lang n (Atom x)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         lang n (Plus r1 r2)\n 6. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         lang n (Times r1 r2)\n 7. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>Star r\\<guillemotright> = lang n (Star r)\n 8. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       lang n (rexp.Not r)\n 9. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         lang n (rexp.Inter r1 r2)\n 10. \\<And>r n.\n        (\\<And>n.\n            lang n \\<guillemotleft>r\\<guillemotright> =\n            lang n r) \\<Longrightarrow>\n        lang n \\<guillemotleft>Pr r\\<guillemotright> = lang n (Pr r)", "case (Plus r1 r2)"], ["proof (state)\nthis:\n  lang ?n \\<guillemotleft>r1\\<guillemotright> = lang ?n r1\n  lang ?n \\<guillemotleft>r2\\<guillemotright> = lang ?n r2\n\ngoal (10 subgoals):\n 1. \\<And>n. lang n \\<guillemotleft>Zero\\<guillemotright> = lang n Zero\n 2. \\<And>n. lang n \\<guillemotleft>Full\\<guillemotright> = lang n Full\n 3. \\<And>n. lang n \\<guillemotleft>One\\<guillemotright> = lang n One\n 4. \\<And>x n.\n       lang n \\<guillemotleft>Atom x\\<guillemotright> = lang n (Atom x)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         lang n (Plus r1 r2)\n 6. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         lang n (Times r1 r2)\n 7. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>Star r\\<guillemotright> = lang n (Star r)\n 8. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       lang n (rexp.Not r)\n 9. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         lang n (rexp.Inter r1 r2)\n 10. \\<And>r n.\n        (\\<And>n.\n            lang n \\<guillemotleft>r\\<guillemotright> =\n            lang n r) \\<Longrightarrow>\n        lang n \\<guillemotleft>Pr r\\<guillemotright> = lang n (Pr r)", "moreover"], ["proof (state)\nthis:\n  lang ?n \\<guillemotleft>r1\\<guillemotright> = lang ?n r1\n  lang ?n \\<guillemotleft>r2\\<guillemotright> = lang ?n r2\n\ngoal (10 subgoals):\n 1. \\<And>n. lang n \\<guillemotleft>Zero\\<guillemotright> = lang n Zero\n 2. \\<And>n. lang n \\<guillemotleft>Full\\<guillemotright> = lang n Full\n 3. \\<And>n. lang n \\<guillemotleft>One\\<guillemotright> = lang n One\n 4. \\<And>x n.\n       lang n \\<guillemotleft>Atom x\\<guillemotright> = lang n (Atom x)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         lang n (Plus r1 r2)\n 6. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         lang n (Times r1 r2)\n 7. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>Star r\\<guillemotright> = lang n (Star r)\n 8. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       lang n (rexp.Not r)\n 9. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         lang n (rexp.Inter r1 r2)\n 10. \\<And>r n.\n        (\\<And>n.\n            lang n \\<guillemotleft>r\\<guillemotright> =\n            lang n r) \\<Longrightarrow>\n        lang n \\<guillemotleft>Pr r\\<guillemotright> = lang n (Pr r)", "from Plus[symmetric]"], ["proof (chain)\npicking this:\n  lang ?n r1 = lang ?n \\<guillemotleft>r1\\<guillemotright>\n  lang ?n r2 = lang ?n \\<guillemotleft>r2\\<guillemotright>", "have \"lang n (Plus r1 r2) \\<subseteq> lang n \\<guillemotleft>Plus r1 r2\\<guillemotright>\""], ["proof (prove)\nusing this:\n  lang ?n r1 = lang ?n \\<guillemotleft>r1\\<guillemotright>\n  lang ?n r2 = lang ?n \\<guillemotleft>r2\\<guillemotright>\n\ngoal (1 subgoal):\n 1. lang n (Plus r1 r2)\n    \\<subseteq> lang n \\<guillemotleft>Plus r1 r2\\<guillemotright>", "using toplevel_summands_in_lang[of _ n \"\\<guillemotleft>r1\\<guillemotright>\"] toplevel_summands_in_lang[of _ n \"\\<guillemotleft>r2\\<guillemotright>\"]"], ["proof (prove)\nusing this:\n  lang ?n r1 = lang ?n \\<guillemotleft>r1\\<guillemotright>\n  lang ?n r2 = lang ?n \\<guillemotleft>r2\\<guillemotright>\n  (?w \\<in> lang n \\<guillemotleft>r1\\<guillemotright>) =\n  (\\<exists>r\\<in>toplevel_summands \\<guillemotleft>r1\\<guillemotright>.\n      ?w \\<in> lang n r)\n  (?w \\<in> lang n \\<guillemotleft>r2\\<guillemotright>) =\n  (\\<exists>r\\<in>toplevel_summands \\<guillemotleft>r2\\<guillemotright>.\n      ?w \\<in> lang n r)\n\ngoal (1 subgoal):\n 1. lang n (Plus r1 r2)\n    \\<subseteq> lang n \\<guillemotleft>Plus r1 r2\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  lang n (Plus r1 r2)\n  \\<subseteq> lang n \\<guillemotleft>Plus r1 r2\\<guillemotright>\n\ngoal (10 subgoals):\n 1. \\<And>n. lang n \\<guillemotleft>Zero\\<guillemotright> = lang n Zero\n 2. \\<And>n. lang n \\<guillemotleft>Full\\<guillemotright> = lang n Full\n 3. \\<And>n. lang n \\<guillemotleft>One\\<guillemotright> = lang n One\n 4. \\<And>x n.\n       lang n \\<guillemotleft>Atom x\\<guillemotright> = lang n (Atom x)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>Plus r1 r2\\<guillemotright> =\n                         lang n (Plus r1 r2)\n 6. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         lang n (Times r1 r2)\n 7. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>Star r\\<guillemotright> = lang n (Star r)\n 8. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       lang n (rexp.Not r)\n 9. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         lang n (rexp.Inter r1 r2)\n 10. \\<And>r n.\n        (\\<And>n.\n            lang n \\<guillemotleft>r\\<guillemotright> =\n            lang n r) \\<Longrightarrow>\n        lang n \\<guillemotleft>Pr r\\<guillemotright> = lang n (Pr r)", "ultimately"], ["proof (chain)\npicking this:\n  lang ?n \\<guillemotleft>r1\\<guillemotright> = lang ?n r1\n  lang ?n \\<guillemotleft>r2\\<guillemotright> = lang ?n r2\n  lang n (Plus r1 r2)\n  \\<subseteq> lang n \\<guillemotleft>Plus r1 r2\\<guillemotright>", "show ?case"], ["proof (prove)\nusing this:\n  lang ?n \\<guillemotleft>r1\\<guillemotright> = lang ?n r1\n  lang ?n \\<guillemotleft>r2\\<guillemotright> = lang ?n r2\n  lang n (Plus r1 r2)\n  \\<subseteq> lang n \\<guillemotleft>Plus r1 r2\\<guillemotright>\n\ngoal (1 subgoal):\n 1. lang n \\<guillemotleft>Plus r1 r2\\<guillemotright> = lang n (Plus r1 r2)", "by (fastforce dest!: toplevel_summands_lang)"], ["proof (state)\nthis:\n  lang n \\<guillemotleft>Plus r1 r2\\<guillemotright> = lang n (Plus r1 r2)\n\ngoal (9 subgoals):\n 1. \\<And>n. lang n \\<guillemotleft>Zero\\<guillemotright> = lang n Zero\n 2. \\<And>n. lang n \\<guillemotleft>Full\\<guillemotright> = lang n Full\n 3. \\<And>n. lang n \\<guillemotleft>One\\<guillemotright> = lang n One\n 4. \\<And>x n.\n       lang n \\<guillemotleft>Atom x\\<guillemotright> = lang n (Atom x)\n 5. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>Times r1 r2\\<guillemotright> =\n                         lang n (Times r1 r2)\n 6. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>Star r\\<guillemotright> = lang n (Star r)\n 7. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>rexp.Not r\\<guillemotright> =\n       lang n (rexp.Not r)\n 8. \\<And>r1 r2 n.\n       \\<lbrakk>\\<And>n.\n                   lang n \\<guillemotleft>r1\\<guillemotright> = lang n r1;\n        \\<And>n.\n           lang n \\<guillemotleft>r2\\<guillemotright> = lang n r2\\<rbrakk>\n       \\<Longrightarrow> lang n\n                          \\<guillemotleft>rexp.Inter r1\n     r2\\<guillemotright> =\n                         lang n (rexp.Inter r1 r2)\n 9. \\<And>r n.\n       (\\<And>n.\n           lang n \\<guillemotleft>r\\<guillemotright> =\n           lang n r) \\<Longrightarrow>\n       lang n \\<guillemotleft>Pr r\\<guillemotright> = lang n (Pr r)", "qed auto"], ["", "lemma lang_final: \"final r = ([] \\<in> lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final r = ([] \\<in> lang n r)", "using concI[of \"[]\" _ \"[]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>[] \\<in> ?A; [] \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> [] @ [] \\<in> ?A @@ ?B\n\ngoal (1 subgoal):\n 1. final r = ([] \\<in> lang n r)", "by (induct r arbitrary: n) auto"], ["", "lemma in_lang_INTERSECT:\n  \"wf_word n w \\<Longrightarrow> w \\<in> lang n (INTERSECT xs) = (\\<forall>r \\<in> set xs. w \\<in> lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_word n w \\<Longrightarrow>\n    (w \\<in> lang n (INTERSECT xs)) =\n    (\\<forall>r\\<in>set xs. w \\<in> lang n r)", "by (induct xs rule: list_singleton_induct) (auto simp: wf_word)"], ["", "lemma lang_INTERSECT:\n  \"lang n (INTERSECT xs) = (if xs = [] then lists (\\<Sigma> n) else \\<Inter>r \\<in> set xs. lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang n (INTERSECT xs) =\n    (if xs = [] then lists (\\<Sigma> n) else \\<Inter> (lang n ` set xs))", "by (induct xs rule: list_singleton_induct) auto"], ["", "lemma lang_flatten_INTERSECT[simp]:\n  assumes \"finite X\" \"X \\<noteq> {}\" \"\\<forall>r\\<in>X. wf n r\"\n  shows \"w \\<in> lang n (flatten INTERSECT X) = (\\<forall>r \\<in> X. w \\<in> lang n r)\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> lang n (INTERSECT (sorted_list_of_set X))) =\n    (\\<forall>r\\<in>X. w \\<in> lang n r)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. w \\<in> lang n (INTERSECT (sorted_list_of_set X)) \\<Longrightarrow>\n    \\<forall>r\\<in>X. w \\<in> lang n r\n 2. \\<forall>r\\<in>X. w \\<in> lang n r \\<Longrightarrow>\n    w \\<in> lang n (INTERSECT (sorted_list_of_set X))", "assume ?L"], ["proof (state)\nthis:\n  w \\<in> lang n (INTERSECT (sorted_list_of_set X))\n\ngoal (2 subgoals):\n 1. w \\<in> lang n (INTERSECT (sorted_list_of_set X)) \\<Longrightarrow>\n    \\<forall>r\\<in>X. w \\<in> lang n r\n 2. \\<forall>r\\<in>X. w \\<in> lang n r \\<Longrightarrow>\n    w \\<in> lang n (INTERSECT (sorted_list_of_set X))", "thus ?R"], ["proof (prove)\nusing this:\n  w \\<in> lang n (INTERSECT (sorted_list_of_set X))\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>X. w \\<in> lang n r", "using in_lang_INTERSECT[OF bspec[OF wf_lang_wf_word[OF iffD2[OF wf_flatten_INTERSECT]]],\n    OF assms(1,3) \\<open>?L\\<close>, of \"sorted_list_of_set X\"] assms(1)"], ["proof (prove)\nusing this:\n  w \\<in> lang n (INTERSECT (sorted_list_of_set X))\n  (w \\<in> lang n (INTERSECT (sorted_list_of_set X))) =\n  (\\<forall>r\\<in>set (sorted_list_of_set X). w \\<in> lang n r)\n  finite X\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>X. w \\<in> lang n r", "by auto"], ["proof (state)\nthis:\n  \\<forall>r\\<in>X. w \\<in> lang n r\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>X. w \\<in> lang n r \\<Longrightarrow>\n    w \\<in> lang n (INTERSECT (sorted_list_of_set X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>X. w \\<in> lang n r \\<Longrightarrow>\n    w \\<in> lang n (INTERSECT (sorted_list_of_set X))", "assume ?R"], ["proof (state)\nthis:\n  \\<forall>r\\<in>X. w \\<in> lang n r\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>X. w \\<in> lang n r \\<Longrightarrow>\n    w \\<in> lang n (INTERSECT (sorted_list_of_set X))", "with assms"], ["proof (chain)\npicking this:\n  finite X\n  X \\<noteq> {}\n  \\<forall>r\\<in>X. local.wf n r\n  \\<forall>r\\<in>X. w \\<in> lang n r", "show ?L"], ["proof (prove)\nusing this:\n  finite X\n  X \\<noteq> {}\n  \\<forall>r\\<in>X. local.wf n r\n  \\<forall>r\\<in>X. w \\<in> lang n r\n\ngoal (1 subgoal):\n 1. w \\<in> lang n (INTERSECT (sorted_list_of_set X))", "by (intro iffD2[OF in_lang_INTERSECT]) (auto dest: wf_lang_wf_word)"], ["proof (state)\nthis:\n  w \\<in> lang n (INTERSECT (sorted_list_of_set X))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}