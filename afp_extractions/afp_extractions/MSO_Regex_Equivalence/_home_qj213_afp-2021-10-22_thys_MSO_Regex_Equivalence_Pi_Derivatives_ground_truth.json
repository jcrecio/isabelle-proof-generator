{"file_name": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence/Pi_Derivatives.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MSO_Regex_Equivalence", "problem_names": ["lemma toplevel_summands_lderiv:\n  \"toplevel_summands (lderiv as r) = (\\<Union>s\\<in>toplevel_summands r. toplevel_summands (lderiv as s))\"", "lemma lderivs_Zero[simp]: \"lderivs xs Zero = Zero\"", "lemma lderivs_Full[simp]: \"lderivs xs Full = Full\"", "lemma lderivs_One: \"lderivs xs One \\<in> {Zero, One}\"", "lemma lderivs_Atom: \"lderivs xs (Atom as) \\<in> {Zero, One, Atom as}\"", "lemma lderivs_Plus: \"lderivs xs (Plus r s) = Plus (lderivs xs r) (lderivs xs s)\"", "lemma lderivs_PLUS: \"lderivs xs (PLUS ys) = PLUS (map (lderivs xs) ys)\"", "lemma toplevel_summands_lderivs_Times: \"toplevel_summands (lderivs xs (Times r s)) \\<subseteq>\n  {Times (lderivs xs r) s} \\<union>\n  {r'. \\<exists>ys zs. r' \\<in> toplevel_summands (lderivs ys s) \\<and> ys \\<noteq> [] \\<and> zs @ ys = xs}\"", "lemma toplevel_summands_lderivs_Star_nonempty:\n  \"xs \\<noteq> [] \\<Longrightarrow> toplevel_summands (lderivs xs (Star r)) \\<subseteq>\n    {Times (lderivs ys r) (Star r) | ys. \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}\"", "lemma toplevel_summands_lderivs_Star:\n  \"toplevel_summands (lderivs xs (Star r)) \\<subseteq>\n    {Star r} \\<union> {Times (lderivs ys r) (Star r) | ys. \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}\"", "lemma ex_lderivs_Pr: \"\\<exists>s. lderivs ass (Pr r) = Pr s\"", "lemma toplevel_summands_PLUS:\n \"xs \\<noteq> [] \\<Longrightarrow> toplevel_summands (PLUS (map f xs)) = (\\<Union>r \\<in> set xs. toplevel_summands (f r))\"", "lemma lderiv_toplevel_summands_Zero:\n  \"\\<lbrakk>lderivs xs (Pr r) = Pr s; toplevel_summands r = {Zero}\\<rbrakk> \\<Longrightarrow> toplevel_summands s = {Zero}\"", "lemma toplevel_summands_lderivs_Pr:\n  \"\\<lbrakk>xs \\<noteq> []; lderivs xs (Pr r) = Pr s\\<rbrakk> \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or> toplevel_summands s \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\"", "lemma lderivs_Pr:\n  \"{lderivs xs (Pr r) | xs. True} \\<subseteq>\n    {Pr s | s. toplevel_summands s \\<subseteq> {Zero} \\<or>\n               toplevel_summands s \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}\"\n  (is \"?L \\<subseteq>?R\")", "lemma ACI_norm_toplevel_summands_Zero: \"toplevel_summands r \\<subseteq> {Zero} \\<Longrightarrow> \\<guillemotleft>r\\<guillemotright> = Zero\"", "lemma ACI_norm_lderivs_Pr:\n  \"ACI_norm ` {lderivs xs (Pr r) | xs. True} \\<subseteq>\n    {Pr Zero} \\<union> {Pr \\<guillemotleft>s\\<guillemotright> | s. toplevel_summands s \\<subseteq> (\\<Union>xs. toplevel_summands \\<guillemotleft>lderivs xs r\\<guillemotright>)}\"", "lemma finite_ACI_norm_toplevel_summands: \"finite B \\<Longrightarrow> finite {f \\<guillemotleft>s\\<guillemotright> |s. toplevel_summands s \\<subseteq> B}\"", "lemma lderivs_Not: \"lderivs xs (Not r) = Not (lderivs xs r)\"", "lemma lderivs_Inter: \"lderivs xs (Inter r s) = Inter (lderivs xs r) (lderivs xs s)\"", "theorem finite_lderivs: \"finite {\\<guillemotleft>lderivs xs r\\<guillemotright> | xs . True}\"", "lemma wf_lderiv[simp]: \"wf n r \\<Longrightarrow> wf n (lderiv w r)\"", "lemma wf_lderivs[simp]: \"wf n r \\<Longrightarrow> wf n (lderivs ws r)\"", "lemma lQuot_map_project:\nassumes \"as \\<in> \\<Sigma> n\" \"A \\<subseteq> lists (\\<Sigma> (Suc n))\"\nshows \"lQuot as (map project ` A) = map project ` (\\<Union>a \\<in> set (embed as). lQuot a A)\" (is \"?L = ?R\")", "lemma lang_lderiv: \"\\<lbrakk>wf n r; w \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> lang n (lderiv w r) = lQuot w (lang n r)\"", "lemma lang_lderivs: \"\\<lbrakk>wf n r; wf_word n ws\\<rbrakk> \\<Longrightarrow> lang n (lderivs ws r) = lQuots ws (lang n r)\"", "lemma ACI_norm_PLUS:\n  \"list_all2 (\\<lambda>r s. \\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>) xs ys \\<Longrightarrow> \\<guillemotleft>PLUS xs\\<guillemotright> = \\<guillemotleft>PLUS ys\\<guillemotright>\"", "lemma toplevel_summands_ACI_norm_lderiv:\n  \"(\\<Union>a\\<in>toplevel_summands r. toplevel_summands \\<guillemotleft>lderiv as \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) = toplevel_summands \\<guillemotleft>lderiv as \\<guillemotleft>r\\<guillemotright>\\<guillemotright>\"", "theorem ACI_norm_lderiv:\n  \"\\<guillemotleft>lderiv as \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>lderiv as r\\<guillemotright>\"", "lemma lderivs_snoc[simp]: \"lderivs (ws @ [w]) r = (lderiv w (lderivs ws r))\"", "theorem ACI_norm_lderivs:\n  \"\\<guillemotleft>lderivs ws \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>lderivs ws r\\<guillemotright>\"", "lemma lderivs_alt: \"\\<guillemotleft>lderivs w r\\<guillemotright> = fold (\\<lambda>a r. \\<guillemotleft>lderiv a r\\<guillemotright>) w \\<guillemotleft>r\\<guillemotright>\"", "lemma finite_fold_lderiv: \"finite {fold (\\<lambda>a r. \\<guillemotleft>lderiv a r\\<guillemotright>) w \\<guillemotleft>s\\<guillemotright> |w. True}\""], "translations": [["", "lemma toplevel_summands_lderiv:\n  \"toplevel_summands (lderiv as r) = (\\<Union>s\\<in>toplevel_summands r. toplevel_summands (lderiv as s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (lderiv as r) =\n    (\\<Union>s\\<in>toplevel_summands r. toplevel_summands (lderiv as s))", "by (induct r) (auto simp: Let_def)"], ["", "lemma lderivs_Zero[simp]: \"lderivs xs Zero = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lderivs xs Zero = Zero", "by (induct xs) auto"], ["", "lemma lderivs_Full[simp]: \"lderivs xs Full = Full\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lderivs xs Full = Full", "by (induct xs) auto"], ["", "lemma lderivs_One: \"lderivs xs One \\<in> {Zero, One}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lderivs xs One \\<in> {Zero, One}", "by (induct xs) auto"], ["", "lemma lderivs_Atom: \"lderivs xs (Atom as) \\<in> {Zero, One, Atom as}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lderivs xs (Atom as) \\<in> {Zero, One, Atom as}", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. lderivs [] (Atom as) \\<in> {Zero, One, Atom as}\n 2. \\<And>a xs.\n       lderivs xs (Atom as) \\<in> {Zero, One, Atom as} \\<Longrightarrow>\n       lderivs (a # xs) (Atom as) \\<in> {Zero, One, Atom as}", "case (Cons x xs)"], ["proof (state)\nthis:\n  lderivs xs (Atom as) \\<in> {Zero, One, Atom as}\n\ngoal (2 subgoals):\n 1. lderivs [] (Atom as) \\<in> {Zero, One, Atom as}\n 2. \\<And>a xs.\n       lderivs xs (Atom as) \\<in> {Zero, One, Atom as} \\<Longrightarrow>\n       lderivs (a # xs) (Atom as) \\<in> {Zero, One, Atom as}", "thus ?case"], ["proof (prove)\nusing this:\n  lderivs xs (Atom as) \\<in> {Zero, One, Atom as}\n\ngoal (1 subgoal):\n 1. lderivs (x # xs) (Atom as) \\<in> {Zero, One, Atom as}", "by (auto intro: insertE[OF lderivs_One])"], ["proof (state)\nthis:\n  lderivs (x # xs) (Atom as) \\<in> {Zero, One, Atom as}\n\ngoal (1 subgoal):\n 1. lderivs [] (Atom as) \\<in> {Zero, One, Atom as}", "qed simp"], ["", "lemma lderivs_Plus: \"lderivs xs (Plus r s) = Plus (lderivs xs r) (lderivs xs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lderivs xs (Plus r s) = Plus (lderivs xs r) (lderivs xs s)", "by (induct xs arbitrary: r s) auto"], ["", "lemma lderivs_PLUS: \"lderivs xs (PLUS ys) = PLUS (map (lderivs xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lderivs xs (PLUS ys) = PLUS (map (lderivs xs) ys)", "by (induct ys rule: list_singleton_induct) (auto simp: lderivs_Plus)"], ["", "lemma toplevel_summands_lderivs_Times: \"toplevel_summands (lderivs xs (Times r s)) \\<subseteq>\n  {Times (lderivs xs r) s} \\<union>\n  {r'. \\<exists>ys zs. r' \\<in> toplevel_summands (lderivs ys s) \\<and> ys \\<noteq> [] \\<and> zs @ ys = xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (lderivs xs (Times r s))\n    \\<subseteq> {Times (lderivs xs r) s} \\<union>\n                {r'.\n                 \\<exists>ys zs.\n                    r' \\<in> toplevel_summands (lderivs ys s) \\<and>\n                    ys \\<noteq> [] \\<and> zs @ ys = xs}", "proof (induct xs arbitrary: r s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r s.\n       toplevel_summands (lderivs [] (Times r s))\n       \\<subseteq> {Times (lderivs [] r) s} \\<union>\n                   {r'.\n                    \\<exists>ys zs.\n                       r' \\<in> toplevel_summands (lderivs ys s) \\<and>\n                       ys \\<noteq> [] \\<and> zs @ ys = []}\n 2. \\<And>a xs r s.\n       (\\<And>r s.\n           toplevel_summands (lderivs xs (Times r s))\n           \\<subseteq> {Times (lderivs xs r) s} \\<union>\n                       {r'.\n                        \\<exists>ys zs.\n                           r' \\<in> toplevel_summands (lderivs ys s) \\<and>\n                           ys \\<noteq> [] \\<and>\n                           zs @ ys = xs}) \\<Longrightarrow>\n       toplevel_summands (lderivs (a # xs) (Times r s))\n       \\<subseteq> {Times (lderivs (a # xs) r) s} \\<union>\n                   {r'.\n                    \\<exists>ys zs.\n                       r' \\<in> toplevel_summands (lderivs ys s) \\<and>\n                       ys \\<noteq> [] \\<and> zs @ ys = a # xs}", "case (Cons x xs)"], ["proof (state)\nthis:\n  toplevel_summands (lderivs xs (Times ?r ?s))\n  \\<subseteq> {Times (lderivs xs ?r) ?s} \\<union>\n              {r'.\n               \\<exists>ys zs.\n                  r' \\<in> toplevel_summands (lderivs ys ?s) \\<and>\n                  ys \\<noteq> [] \\<and> zs @ ys = xs}\n\ngoal (2 subgoals):\n 1. \\<And>r s.\n       toplevel_summands (lderivs [] (Times r s))\n       \\<subseteq> {Times (lderivs [] r) s} \\<union>\n                   {r'.\n                    \\<exists>ys zs.\n                       r' \\<in> toplevel_summands (lderivs ys s) \\<and>\n                       ys \\<noteq> [] \\<and> zs @ ys = []}\n 2. \\<And>a xs r s.\n       (\\<And>r s.\n           toplevel_summands (lderivs xs (Times r s))\n           \\<subseteq> {Times (lderivs xs r) s} \\<union>\n                       {r'.\n                        \\<exists>ys zs.\n                           r' \\<in> toplevel_summands (lderivs ys s) \\<and>\n                           ys \\<noteq> [] \\<and>\n                           zs @ ys = xs}) \\<Longrightarrow>\n       toplevel_summands (lderivs (a # xs) (Times r s))\n       \\<subseteq> {Times (lderivs (a # xs) r) s} \\<union>\n                   {r'.\n                    \\<exists>ys zs.\n                       r' \\<in> toplevel_summands (lderivs ys s) \\<and>\n                       ys \\<noteq> [] \\<and> zs @ ys = a # xs}", "thus ?case"], ["proof (prove)\nusing this:\n  toplevel_summands (lderivs xs (Times ?r ?s))\n  \\<subseteq> {Times (lderivs xs ?r) ?s} \\<union>\n              {r'.\n               \\<exists>ys zs.\n                  r' \\<in> toplevel_summands (lderivs ys ?s) \\<and>\n                  ys \\<noteq> [] \\<and> zs @ ys = xs}\n\ngoal (1 subgoal):\n 1. toplevel_summands (lderivs (x # xs) (Times r s))\n    \\<subseteq> {Times (lderivs (x # xs) r) s} \\<union>\n                {r'.\n                 \\<exists>ys zs.\n                    r' \\<in> toplevel_summands (lderivs ys s) \\<and>\n                    ys \\<noteq> [] \\<and> zs @ ys = x # xs}", "by (auto simp: Let_def lderivs_Plus) (fastforce intro: exI[of _ \"x#xs\"])+"], ["proof (state)\nthis:\n  toplevel_summands (lderivs (x # xs) (Times r s))\n  \\<subseteq> {Times (lderivs (x # xs) r) s} \\<union>\n              {r'.\n               \\<exists>ys zs.\n                  r' \\<in> toplevel_summands (lderivs ys s) \\<and>\n                  ys \\<noteq> [] \\<and> zs @ ys = x # xs}\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       toplevel_summands (lderivs [] (Times r s))\n       \\<subseteq> {Times (lderivs [] r) s} \\<union>\n                   {r'.\n                    \\<exists>ys zs.\n                       r' \\<in> toplevel_summands (lderivs ys s) \\<and>\n                       ys \\<noteq> [] \\<and> zs @ ys = []}", "qed simp"], ["", "lemma toplevel_summands_lderivs_Star_nonempty:\n  \"xs \\<noteq> [] \\<Longrightarrow> toplevel_summands (lderivs xs (Star r)) \\<subseteq>\n    {Times (lderivs ys r) (Star r) | ys. \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    toplevel_summands (lderivs xs (Star r))\n    \\<subseteq> {Times (lderivs ys r) (Star r) |ys.\n                 \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "proof (induct xs rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   ys \\<noteq> [] \\<longrightarrow>\n                   toplevel_summands (lderivs ys (Star r))\n                   \\<subseteq> {Times (lderivs ysa r) (Star r) |ysa.\n                                \\<exists>zs.\n                                   ysa \\<noteq> [] \\<and> zs @ ysa = ys};\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands (lderivs xs (Star r))\n                         \\<subseteq> {Times (lderivs ys r) (Star r) |ys.\n\\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     toplevel_summands (lderivs ys (Star r))\n     \\<subseteq> {Times (lderivs ysa r) (Star r) |ysa.\n                  \\<exists>zs. ysa \\<noteq> [] \\<and> zs @ ysa = ys}\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   ys \\<noteq> [] \\<longrightarrow>\n                   toplevel_summands (lderivs ys (Star r))\n                   \\<subseteq> {Times (lderivs ysa r) (Star r) |ysa.\n                                \\<exists>zs.\n                                   ysa \\<noteq> [] \\<and> zs @ ysa = ys};\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands (lderivs xs (Star r))\n                         \\<subseteq> {Times (lderivs ys r) (Star r) |ys.\n\\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "then"], ["proof (chain)\npicking this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     toplevel_summands (lderivs ys (Star r))\n     \\<subseteq> {Times (lderivs ysa r) (Star r) |ysa.\n                  \\<exists>zs. ysa \\<noteq> [] \\<and> zs @ ysa = ys}\n  xs \\<noteq> []", "obtain y ys where \"xs = y # ys\""], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow>\n     toplevel_summands (lderivs ys (Star r))\n     \\<subseteq> {Times (lderivs ysa r) (Star r) |ysa.\n                  \\<exists>zs. ysa \\<noteq> [] \\<and> zs @ ysa = ys}\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>y ys. xs = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs) auto"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   ys \\<noteq> [] \\<longrightarrow>\n                   toplevel_summands (lderivs ys (Star r))\n                   \\<subseteq> {Times (lderivs ysa r) (Star r) |ysa.\n                                \\<exists>zs.\n                                   ysa \\<noteq> [] \\<and> zs @ ysa = ys};\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands (lderivs xs (Star r))\n                         \\<subseteq> {Times (lderivs ys r) (Star r) |ys.\n\\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "thus ?case"], ["proof (prove)\nusing this:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. toplevel_summands (lderivs xs (Star r))\n    \\<subseteq> {Times (lderivs ys r) (Star r) |ys.\n                 \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "using spec[OF 1(1)]"], ["proof (prove)\nusing this:\n  xs = y # ys\n  length ?x < length xs \\<longrightarrow>\n  ?x \\<noteq> [] \\<longrightarrow>\n  toplevel_summands (lderivs ?x (Star r))\n  \\<subseteq> {Times (lderivs ys r) (Star r) |ys.\n               \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = ?x}\n\ngoal (1 subgoal):\n 1. toplevel_summands (lderivs xs (Star r))\n    \\<subseteq> {Times (lderivs ys r) (Star r) |ys.\n                 \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "by (auto dest!: subsetD[OF toplevel_summands_lderivs_Times] intro: exI[of _ \"y#ys\"])\n       (auto elim!: impE dest!: meta_spec subsetD)"], ["proof (state)\nthis:\n  toplevel_summands (lderivs xs (Star r))\n  \\<subseteq> {Times (lderivs ys r) (Star r) |ys.\n               \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma toplevel_summands_lderivs_Star:\n  \"toplevel_summands (lderivs xs (Star r)) \\<subseteq>\n    {Star r} \\<union> {Times (lderivs ys r) (Star r) | ys. \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (lderivs xs (Star r))\n    \\<subseteq> {Star r} \\<union>\n                {Times (lderivs ys r) (Star r) |ys.\n                 \\<exists>zs. ys \\<noteq> [] \\<and> zs @ ys = xs}", "by (cases \"xs = []\") (auto dest!: toplevel_summands_lderivs_Star_nonempty)"], ["", "lemma ex_lderivs_Pr: \"\\<exists>s. lderivs ass (Pr r) = Pr s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. lderivs ass (Pr r) = Pr s", "by (induct ass arbitrary: r) auto"], ["", "lemma toplevel_summands_PLUS:\n \"xs \\<noteq> [] \\<Longrightarrow> toplevel_summands (PLUS (map f xs)) = (\\<Union>r \\<in> set xs. toplevel_summands (f r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    toplevel_summands (PLUS (map f xs)) =\n    (\\<Union>r\\<in>set xs. toplevel_summands (f r))", "by (induct xs rule: list_singleton_induct) simp_all"], ["", "lemma lderiv_toplevel_summands_Zero:\n  \"\\<lbrakk>lderivs xs (Pr r) = Pr s; toplevel_summands r = {Zero}\\<rbrakk> \\<Longrightarrow> toplevel_summands s = {Zero}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lderivs xs (Pr r) = Pr s; toplevel_summands r = {Zero}\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands s = {Zero}", "proof (induct xs arbitrary: r s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r s.\n       \\<lbrakk>lderivs [] (Pr r) = Pr s;\n        toplevel_summands r = {Zero}\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s = {Zero}\n 2. \\<And>a xs r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>lderivs xs (Pr r) = Pr s;\n                    toplevel_summands r = {Zero}\\<rbrakk>\n                   \\<Longrightarrow> toplevel_summands s = {Zero};\n        lderivs (a # xs) (Pr r) = Pr s;\n        toplevel_summands r = {Zero}\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s = {Zero}", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>lderivs ys (Pr ?r) = Pr ?s;\n   toplevel_summands ?r = {Zero}\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands ?s = {Zero}\n  lderivs (y # ys) (Pr r) = Pr s\n  toplevel_summands r = {Zero}\n\ngoal (2 subgoals):\n 1. \\<And>r s.\n       \\<lbrakk>lderivs [] (Pr r) = Pr s;\n        toplevel_summands r = {Zero}\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s = {Zero}\n 2. \\<And>a xs r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>lderivs xs (Pr r) = Pr s;\n                    toplevel_summands r = {Zero}\\<rbrakk>\n                   \\<Longrightarrow> toplevel_summands s = {Zero};\n        lderivs (a # xs) (Pr r) = Pr s;\n        toplevel_summands r = {Zero}\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s = {Zero}", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  lderivs (y # ys) (Pr r) = Pr s", "have \"toplevel_summands (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) = {Zero}\""], ["proof (prove)\nusing this:\n  lderivs (y # ys) (Pr r) = Pr s\n\ngoal (1 subgoal):\n 1. toplevel_summands (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) =\n    {Zero}", "proof (cases \"embed y = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>lderivs (y # ys) (Pr r) = Pr s; embed y = []\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands\n                       (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) =\n                      {Zero}\n 2. \\<lbrakk>lderivs (y # ys) (Pr r) = Pr s; embed y \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands\n                       (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) =\n                      {Zero}", "case False"], ["proof (state)\nthis:\n  embed y \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lderivs (y # ys) (Pr r) = Pr s; embed y = []\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands\n                       (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) =\n                      {Zero}\n 2. \\<lbrakk>lderivs (y # ys) (Pr r) = Pr s; embed y \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands\n                       (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) =\n                      {Zero}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) =\n    {Zero}", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  toplevel_summands r = {Zero}\n\ngoal (1 subgoal):\n 1. toplevel_summands (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) =\n    {Zero}", "unfolding toplevel_summands_PLUS[OF False]"], ["proof (prove)\nusing this:\n  toplevel_summands r = {Zero}\n\ngoal (1 subgoal):\n 1. (\\<Union>r\\<in>set (embed y). toplevel_summands (lderiv r r)) = {Zero}", "by (subst toplevel_summands_lderiv) (simp add: False)"], ["proof (state)\nthis:\n  toplevel_summands (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) = {Zero}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lderivs (y # ys) (Pr r) = Pr s; embed y = []\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands\n                       (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) =\n                      {Zero}", "qed simp"], ["proof (state)\nthis:\n  toplevel_summands (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) = {Zero}\n\ngoal (2 subgoals):\n 1. \\<And>r s.\n       \\<lbrakk>lderivs [] (Pr r) = Pr s;\n        toplevel_summands r = {Zero}\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s = {Zero}\n 2. \\<And>a xs r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>lderivs xs (Pr r) = Pr s;\n                    toplevel_summands r = {Zero}\\<rbrakk>\n                   \\<Longrightarrow> toplevel_summands s = {Zero};\n        lderivs (a # xs) (Pr r) = Pr s;\n        toplevel_summands r = {Zero}\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s = {Zero}", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>lderivs ys (Pr ?r) = Pr ?s;\n   toplevel_summands ?r = {Zero}\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands ?s = {Zero}\n  lderivs (y # ys) (Pr r) = Pr s\n  toplevel_summands r = {Zero}\n  toplevel_summands (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) = {Zero}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>lderivs ys (Pr ?r) = Pr ?s;\n   toplevel_summands ?r = {Zero}\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands ?s = {Zero}\n  lderivs (y # ys) (Pr r) = Pr s\n  toplevel_summands r = {Zero}\n  toplevel_summands (PLUS (map (\\<lambda>a. lderiv a r) (embed y))) = {Zero}\n\ngoal (1 subgoal):\n 1. toplevel_summands s = {Zero}", "by simp"], ["proof (state)\nthis:\n  toplevel_summands s = {Zero}\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<lbrakk>lderivs [] (Pr r) = Pr s;\n        toplevel_summands r = {Zero}\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s = {Zero}", "qed simp"], ["", "lemma toplevel_summands_lderivs_Pr:\n  \"\\<lbrakk>xs \\<noteq> []; lderivs xs (Pr r) = Pr s\\<rbrakk> \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or> toplevel_summands s \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; lderivs xs (Pr r) = Pr s\\<rbrakk>\n    \\<Longrightarrow> toplevel_summands s \\<subseteq> {Zero} \\<or>\n                      toplevel_summands s\n                      \\<subseteq> (\\<Union>xs.\ntoplevel_summands (lderivs xs r))", "proof (induct xs arbitrary: r s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r s.\n       \\<lbrakk>[] \\<noteq> []; lderivs [] (Pr r) = Pr s\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s \\<subseteq> {Zero} \\<or>\n                         toplevel_summands s\n                         \\<subseteq> (\\<Union>xs.\n   toplevel_summands (lderivs xs r))\n 2. \\<And>a xs r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>xs \\<noteq> [];\n                    lderivs xs (Pr r) = Pr s\\<rbrakk>\n                   \\<Longrightarrow> toplevel_summands s\n                                     \\<subseteq> {Zero} \\<or>\n                                     toplevel_summands s\n                                     \\<subseteq> (\\<Union>xs.\n               toplevel_summands (lderivs xs r));\n        a # xs \\<noteq> []; lderivs (a # xs) (Pr r) = Pr s\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s \\<subseteq> {Zero} \\<or>\n                         toplevel_summands s\n                         \\<subseteq> (\\<Union>xs.\n   toplevel_summands (lderivs xs r))", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>ys \\<noteq> []; lderivs ys (Pr ?r) = Pr ?s\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands ?s \\<subseteq> {Zero} \\<or>\n                    toplevel_summands ?s\n                    \\<subseteq> (\\<Union>xs.\n                                    toplevel_summands (lderivs xs ?r))\n  y # ys \\<noteq> []\n  lderivs (y # ys) (Pr r) = Pr s\n\ngoal (2 subgoals):\n 1. \\<And>r s.\n       \\<lbrakk>[] \\<noteq> []; lderivs [] (Pr r) = Pr s\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s \\<subseteq> {Zero} \\<or>\n                         toplevel_summands s\n                         \\<subseteq> (\\<Union>xs.\n   toplevel_summands (lderivs xs r))\n 2. \\<And>a xs r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>xs \\<noteq> [];\n                    lderivs xs (Pr r) = Pr s\\<rbrakk>\n                   \\<Longrightarrow> toplevel_summands s\n                                     \\<subseteq> {Zero} \\<or>\n                                     toplevel_summands s\n                                     \\<subseteq> (\\<Union>xs.\n               toplevel_summands (lderivs xs r));\n        a # xs \\<noteq> []; lderivs (a # xs) (Pr r) = Pr s\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s \\<subseteq> {Zero} \\<or>\n                         toplevel_summands s\n                         \\<subseteq> (\\<Union>xs.\n   toplevel_summands (lderivs xs r))", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>ys \\<noteq> []; lderivs ys (Pr ?r) = Pr ?s\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands ?s \\<subseteq> {Zero} \\<or>\n                    toplevel_summands ?s\n                    \\<subseteq> (\\<Union>xs.\n                                    toplevel_summands (lderivs xs ?r))\n  y # ys \\<noteq> []\n  lderivs (y # ys) (Pr r) = Pr s\n\ngoal (2 subgoals):\n 1. \\<And>r s.\n       \\<lbrakk>[] \\<noteq> []; lderivs [] (Pr r) = Pr s\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s \\<subseteq> {Zero} \\<or>\n                         toplevel_summands s\n                         \\<subseteq> (\\<Union>xs.\n   toplevel_summands (lderivs xs r))\n 2. \\<And>a xs r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>xs \\<noteq> [];\n                    lderivs xs (Pr r) = Pr s\\<rbrakk>\n                   \\<Longrightarrow> toplevel_summands s\n                                     \\<subseteq> {Zero} \\<or>\n                                     toplevel_summands s\n                                     \\<subseteq> (\\<Union>xs.\n               toplevel_summands (lderivs xs r));\n        a # xs \\<noteq> []; lderivs (a # xs) (Pr r) = Pr s\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s \\<subseteq> {Zero} \\<or>\n                         toplevel_summands s\n                         \\<subseteq> (\\<Union>xs.\n   toplevel_summands (lderivs xs r))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "proof (cases \"embed y = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. embed y = [] \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n 2. embed y \\<noteq> [] \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "case True"], ["proof (state)\nthis:\n  embed y = []\n\ngoal (2 subgoals):\n 1. embed y = [] \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n 2. embed y \\<noteq> [] \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>ys \\<noteq> []; lderivs ys (Pr ?r) = Pr ?s\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands ?s \\<subseteq> {Zero} \\<or>\n                    toplevel_summands ?s\n                    \\<subseteq> (\\<Union>xs.\n                                    toplevel_summands (lderivs xs ?r))\n  y # ys \\<noteq> []\n  lderivs (y # ys) (Pr r) = Pr s\n  embed y = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ys \\<noteq> []; lderivs ys (Pr ?r) = Pr ?s\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands ?s \\<subseteq> {Zero} \\<or>\n                    toplevel_summands ?s\n                    \\<subseteq> (\\<Union>xs.\n                                    toplevel_summands (lderivs xs ?r))\n  y # ys \\<noteq> []\n  lderivs (y # ys) (Pr r) = Pr s\n  embed y = []\n\ngoal (1 subgoal):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "by (cases \"ys = []\") (auto dest: lderiv_toplevel_summands_Zero)"], ["proof (state)\nthis:\n  toplevel_summands s \\<subseteq> {Zero} \\<or>\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n\ngoal (1 subgoal):\n 1. embed y \\<noteq> [] \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. embed y \\<noteq> [] \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "case False"], ["proof (state)\nthis:\n  embed y \\<noteq> []\n\ngoal (1 subgoal):\n 1. embed y \\<noteq> [] \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "proof (cases ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       toplevel_summands s \\<subseteq> {Zero} \\<or>\n       toplevel_summands s\n       \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "case Nil"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       toplevel_summands s \\<subseteq> {Zero} \\<or>\n       toplevel_summands s\n       \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "with *"], ["proof (chain)\npicking this:\n  \\<lbrakk>ys \\<noteq> []; lderivs ys (Pr ?r) = Pr ?s\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands ?s \\<subseteq> {Zero} \\<or>\n                    toplevel_summands ?s\n                    \\<subseteq> (\\<Union>xs.\n                                    toplevel_summands (lderivs xs ?r))\n  y # ys \\<noteq> []\n  lderivs (y # ys) (Pr r) = Pr s\n  ys = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ys \\<noteq> []; lderivs ys (Pr ?r) = Pr ?s\\<rbrakk>\n  \\<Longrightarrow> toplevel_summands ?s \\<subseteq> {Zero} \\<or>\n                    toplevel_summands ?s\n                    \\<subseteq> (\\<Union>xs.\n                                    toplevel_summands (lderivs xs ?r))\n  y # ys \\<noteq> []\n  lderivs (y # ys) (Pr r) = Pr s\n  ys = []\n\ngoal (1 subgoal):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "by (auto simp: toplevel_summands_PLUS[OF False]) (metis lderivs.simps)"], ["proof (state)\nthis:\n  toplevel_summands s \\<subseteq> {Zero} \\<or>\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       toplevel_summands s \\<subseteq> {Zero} \\<or>\n       toplevel_summands s\n       \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       toplevel_summands s \\<subseteq> {Zero} \\<or>\n       toplevel_summands s\n       \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "case (Cons z zs)"], ["proof (state)\nthis:\n  ys = z # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       toplevel_summands s \\<subseteq> {Zero} \\<or>\n       toplevel_summands s\n       \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "have \"toplevel_summands s \\<subseteq> {Zero} \\<or> toplevel_summands s \\<subseteq>\n       (\\<Union>xs. toplevel_summands (lderivs xs (PLUS (map (\\<lambda>a. lderiv a r) (embed y)))))\" (is \"_ \\<or> ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs.\n                    toplevel_summands\n                     (lderivs xs\n                       (PLUS (map (\\<lambda>a. lderiv a r) (embed y)))))", "by (rule *(1)) (auto simp: Cons *(3)[symmetric])"], ["proof (state)\nthis:\n  toplevel_summands s \\<subseteq> {Zero} \\<or>\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs.\n                  toplevel_summands\n                   (lderivs xs\n                     (PLUS (map (\\<lambda>a. lderiv a r) (embed y)))))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       toplevel_summands s \\<subseteq> {Zero} \\<or>\n       toplevel_summands s\n       \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "thus ?thesis"], ["proof (prove)\nusing this:\n  toplevel_summands s \\<subseteq> {Zero} \\<or>\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs.\n                  toplevel_summands\n                   (lderivs xs\n                     (PLUS (map (\\<lambda>a. lderiv a r) (embed y)))))\n\ngoal (1 subgoal):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n 2. toplevel_summands s\n    \\<subseteq> (\\<Union>xs.\n                    toplevel_summands\n                     (lderivs xs\n                       (PLUS\n                         (map (\\<lambda>a. lderiv a r)\n                           (embed y))))) \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "assume ?B"], ["proof (state)\nthis:\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs.\n                  toplevel_summands\n                   (lderivs xs\n                     (PLUS (map (\\<lambda>a. lderiv a r) (embed y)))))\n\ngoal (2 subgoals):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n 2. toplevel_summands s\n    \\<subseteq> (\\<Union>xs.\n                    toplevel_summands\n                     (lderivs xs\n                       (PLUS\n                         (map (\\<lambda>a. lderiv a r)\n                           (embed y))))) \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "also"], ["proof (state)\nthis:\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs.\n                  toplevel_summands\n                   (lderivs xs\n                     (PLUS (map (\\<lambda>a. lderiv a r) (embed y)))))\n\ngoal (2 subgoals):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n 2. toplevel_summands s\n    \\<subseteq> (\\<Union>xs.\n                    toplevel_summands\n                     (lderivs xs\n                       (PLUS\n                         (map (\\<lambda>a. lderiv a r)\n                           (embed y))))) \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "have \"\\<dots> \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>xs.\n        toplevel_summands\n         (lderivs xs (PLUS (map (\\<lambda>a. lderiv a r) (embed y)))))\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "by (auto simp: lderivs_PLUS toplevel_summands_PLUS[OF False]) (metis lderivs.simps(2))"], ["proof (state)\nthis:\n  (\\<Union>xs.\n      toplevel_summands\n       (lderivs xs (PLUS (map (\\<lambda>a. lderiv a r) (embed y)))))\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n\ngoal (2 subgoals):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n 2. toplevel_summands s\n    \\<subseteq> (\\<Union>xs.\n                    toplevel_summands\n                     (lderivs xs\n                       (PLUS\n                         (map (\\<lambda>a. lderiv a r)\n                           (embed y))))) \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "finally"], ["proof (chain)\npicking this:\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "show ?thesis"], ["proof (prove)\nusing this:\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n\ngoal (1 subgoal):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", ".."], ["proof (state)\nthis:\n  toplevel_summands s \\<subseteq> {Zero} \\<or>\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n\ngoal (1 subgoal):\n 1. toplevel_summands s \\<subseteq> {Zero} \\<Longrightarrow>\n    toplevel_summands s \\<subseteq> {Zero} \\<or>\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))", "qed blast"], ["proof (state)\nthis:\n  toplevel_summands s \\<subseteq> {Zero} \\<or>\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  toplevel_summands s \\<subseteq> {Zero} \\<or>\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  toplevel_summands s \\<subseteq> {Zero} \\<or>\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<lbrakk>[] \\<noteq> []; lderivs [] (Pr r) = Pr s\\<rbrakk>\n       \\<Longrightarrow> toplevel_summands s \\<subseteq> {Zero} \\<or>\n                         toplevel_summands s\n                         \\<subseteq> (\\<Union>xs.\n   toplevel_summands (lderivs xs r))", "qed simp"], ["", "lemma lderivs_Pr:\n  \"{lderivs xs (Pr r) | xs. True} \\<subseteq>\n    {Pr s | s. toplevel_summands s \\<subseteq> {Zero} \\<or>\n               toplevel_summands s \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}\"\n  (is \"?L \\<subseteq>?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {lderivs xs (Pr r) |xs. True}\n    \\<subseteq> {Pr s |s.\n                 toplevel_summands s \\<subseteq> {Zero} \\<or>\n                 toplevel_summands s\n                 \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {lderivs xs (Pr r) |xs. True} \\<Longrightarrow>\n       x \\<in> {Pr s |s.\n                toplevel_summands s \\<subseteq> {Zero} \\<or>\n                toplevel_summands s\n                \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {lderivs xs (Pr r) |xs. True} \\<Longrightarrow>\n       x \\<in> {Pr s |s.\n                toplevel_summands s \\<subseteq> {Zero} \\<or>\n                toplevel_summands s\n                \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}", "assume \"s \\<in> ?L\""], ["proof (state)\nthis:\n  s \\<in> {lderivs xs (Pr r) |xs. True}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {lderivs xs (Pr r) |xs. True} \\<Longrightarrow>\n       x \\<in> {Pr s |s.\n                toplevel_summands s \\<subseteq> {Zero} \\<or>\n                toplevel_summands s\n                \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}", "then"], ["proof (chain)\npicking this:\n  s \\<in> {lderivs xs (Pr r) |xs. True}", "obtain xs where \"s = lderivs xs (Pr r)\""], ["proof (prove)\nusing this:\n  s \\<in> {lderivs xs (Pr r) |xs. True}\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        s = lderivs xs (Pr r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s = lderivs xs (Pr r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {lderivs xs (Pr r) |xs. True} \\<Longrightarrow>\n       x \\<in> {Pr s |s.\n                toplevel_summands s \\<subseteq> {Zero} \\<or>\n                toplevel_summands s\n                \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}", "moreover"], ["proof (state)\nthis:\n  s = lderivs xs (Pr r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {lderivs xs (Pr r) |xs. True} \\<Longrightarrow>\n       x \\<in> {Pr s |s.\n                toplevel_summands s \\<subseteq> {Zero} \\<or>\n                toplevel_summands s\n                \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}", "obtain t where \"lderivs xs (Pr r) = Pr t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        lderivs xs (Pr r) = Pr t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_lderivs_Pr"], ["proof (prove)\nusing this:\n  \\<exists>s. lderivs ?ass (Pr ?r) = Pr s\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        lderivs xs (Pr r) = Pr t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lderivs xs (Pr r) = Pr t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {lderivs xs (Pr r) |xs. True} \\<Longrightarrow>\n       x \\<in> {Pr s |s.\n                toplevel_summands s \\<subseteq> {Zero} \\<or>\n                toplevel_summands s\n                \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}", "ultimately"], ["proof (chain)\npicking this:\n  s = lderivs xs (Pr r)\n  lderivs xs (Pr r) = Pr t", "show \"s \\<in> ?R\""], ["proof (prove)\nusing this:\n  s = lderivs xs (Pr r)\n  lderivs xs (Pr r) = Pr t\n\ngoal (1 subgoal):\n 1. s \\<in> {Pr s |s.\n             toplevel_summands s \\<subseteq> {Zero} \\<or>\n             toplevel_summands s\n             \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}", "by (cases \"xs = []\") (auto dest!: toplevel_summands_lderivs_Pr elim!: allE[of _ \"[]\"])"], ["proof (state)\nthis:\n  s \\<in> {Pr s |s.\n           toplevel_summands s \\<subseteq> {Zero} \\<or>\n           toplevel_summands s\n           \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ACI_norm_toplevel_summands_Zero: \"toplevel_summands r \\<subseteq> {Zero} \\<Longrightarrow> \\<guillemotleft>r\\<guillemotright> = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toplevel_summands r \\<subseteq> {Zero} \\<Longrightarrow>\n    \\<guillemotleft>r\\<guillemotright> = Zero", "by (subst ACI_norm_flatten) (auto dest: subset_singletonD)"], ["", "lemma ACI_norm_lderivs_Pr:\n  \"ACI_norm ` {lderivs xs (Pr r) | xs. True} \\<subseteq>\n    {Pr Zero} \\<union> {Pr \\<guillemotleft>s\\<guillemotright> | s. toplevel_summands s \\<subseteq> (\\<Union>xs. toplevel_summands \\<guillemotleft>lderivs xs r\\<guillemotright>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ACI_norm ` {lderivs xs (Pr r) |xs. True}\n    \\<subseteq> {Pr Zero} \\<union>\n                {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                 toplevel_summands s\n                 \\<subseteq> (\\<Union>xs.\n                                 toplevel_summands\n                                  \\<guillemotleft>lderivs xs\n             r\\<guillemotright>)}", "proof (intro subset_trans[OF image_mono[OF lderivs_Pr]] subsetI,\n       elim imageE CollectE exE conjE disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s \\<subseteq> {Zero}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}\n 2. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "fix x x' s :: \"'b rexp\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s \\<subseteq> {Zero}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}\n 2. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "assume *: \"x = \\<guillemotleft>x'\\<guillemotright>\" \"x' = Pr s\" and \"toplevel_summands s \\<subseteq> {Zero}\""], ["proof (state)\nthis:\n  x = \\<guillemotleft>x'\\<guillemotright>\n  x' = Pr s\n  toplevel_summands s \\<subseteq> {Zero}\n\ngoal (2 subgoals):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s \\<subseteq> {Zero}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}\n 2. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "hence \"\\<guillemotleft>Pr s\\<guillemotright> = Pr Zero\""], ["proof (prove)\nusing this:\n  x = \\<guillemotleft>x'\\<guillemotright>\n  x' = Pr s\n  toplevel_summands s \\<subseteq> {Zero}\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>Pr s\\<guillemotright> = Pr Zero", "using ACI_norm_toplevel_summands_Zero"], ["proof (prove)\nusing this:\n  x = \\<guillemotleft>x'\\<guillemotright>\n  x' = Pr s\n  toplevel_summands s \\<subseteq> {Zero}\n  toplevel_summands ?r \\<subseteq> {Zero} \\<Longrightarrow>\n  \\<guillemotleft>?r\\<guillemotright> = Zero\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>Pr s\\<guillemotright> = Pr Zero", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>Pr s\\<guillemotright> = Pr Zero\n\ngoal (2 subgoals):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s \\<subseteq> {Zero}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}\n 2. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "thus \"x \\<in> {Pr Zero} \\<union>\n    {Pr \\<guillemotleft>s\\<guillemotright> |s. toplevel_summands s \\<subseteq> (\\<Union>xs. toplevel_summands \\<guillemotleft>lderivs xs r\\<guillemotright>)}\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>Pr s\\<guillemotright> = Pr Zero\n\ngoal (1 subgoal):\n 1. x \\<in> {Pr Zero} \\<union>\n            {Pr \\<guillemotleft>s\\<guillemotright> |s.\n             toplevel_summands s\n             \\<subseteq> (\\<Union>xs.\n                             toplevel_summands\n                              \\<guillemotleft>lderivs xs\n         r\\<guillemotright>)}", "unfolding *"], ["proof (prove)\nusing this:\n  \\<guillemotleft>Pr s\\<guillemotright> = Pr Zero\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>Pr s\\<guillemotright>\n    \\<in> {Pr Zero} \\<union>\n          {Pr \\<guillemotleft>s\\<guillemotright> |s.\n           toplevel_summands s\n           \\<subseteq> (\\<Union>xs.\n                           toplevel_summands\n                            \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "by blast"], ["proof (state)\nthis:\n  x \\<in> {Pr Zero} \\<union>\n          {Pr \\<guillemotleft>s\\<guillemotright> |s.\n           toplevel_summands s\n           \\<subseteq> (\\<Union>xs.\n                           toplevel_summands\n                            \\<guillemotleft>lderivs xs r\\<guillemotright>)}\n\ngoal (1 subgoal):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "fix x x' s :: \"'b rexp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "assume *: \"x = \\<guillemotleft>x'\\<guillemotright>\" \"x' = Pr s\" and \"toplevel_summands s \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\""], ["proof (state)\nthis:\n  x = \\<guillemotleft>x'\\<guillemotright>\n  x' = Pr s\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n\ngoal (1 subgoal):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "hence \"toplevel_summands \\<guillemotleft>s\\<guillemotright> \\<subseteq> (\\<Union>xs. toplevel_summands \\<guillemotleft>lderivs xs r\\<guillemotright>)\""], ["proof (prove)\nusing this:\n  x = \\<guillemotleft>x'\\<guillemotright>\n  x' = Pr s\n  toplevel_summands s\n  \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\n\ngoal (1 subgoal):\n 1. toplevel_summands \\<guillemotleft>s\\<guillemotright>\n    \\<subseteq> (\\<Union>xs.\n                    toplevel_summands\n                     \\<guillemotleft>lderivs xs r\\<guillemotright>)", "by (fastforce simp: toplevel_summands_ACI_norm)"], ["proof (state)\nthis:\n  toplevel_summands \\<guillemotleft>s\\<guillemotright>\n  \\<subseteq> (\\<Union>xs.\n                  toplevel_summands\n                   \\<guillemotleft>lderivs xs r\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "moreover"], ["proof (state)\nthis:\n  toplevel_summands \\<guillemotleft>s\\<guillemotright>\n  \\<subseteq> (\\<Union>xs.\n                  toplevel_summands\n                   \\<guillemotleft>lderivs xs r\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "have \"x = Pr \\<guillemotleft>\\<guillemotleft>s\\<guillemotright>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    Pr \\<guillemotleft>\\<guillemotleft>s\\<guillemotright>\\<guillemotright>", "unfolding * ACI_norm_idem ACI_norm.simps(10)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pr \\<guillemotleft>s\\<guillemotright> =\n    Pr \\<guillemotleft>s\\<guillemotright>", ".."], ["proof (state)\nthis:\n  x = Pr \\<guillemotleft>\\<guillemotleft>s\\<guillemotright>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x xa s.\n       \\<lbrakk>x = \\<guillemotleft>xa\\<guillemotright>; xa = Pr s;\n        toplevel_summands s\n        \\<subseteq> (\\<Union>xs. toplevel_summands (lderivs xs r))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {Pr Zero} \\<union>\n                                 {Pr \\<guillemotleft>s\\<guillemotright> |s.\n                                  toplevel_summands s\n                                  \\<subseteq> (\\<Union>xs.\n            toplevel_summands\n             \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "ultimately"], ["proof (chain)\npicking this:\n  toplevel_summands \\<guillemotleft>s\\<guillemotright>\n  \\<subseteq> (\\<Union>xs.\n                  toplevel_summands\n                   \\<guillemotleft>lderivs xs r\\<guillemotright>)\n  x = Pr \\<guillemotleft>\\<guillemotleft>s\\<guillemotright>\\<guillemotright>", "show \"x \\<in> {Pr Zero} \\<union>\n    {Pr \\<guillemotleft>s\\<guillemotright> |s. toplevel_summands s \\<subseteq> (\\<Union>xs. toplevel_summands \\<guillemotleft>lderivs xs r\\<guillemotright>)}\""], ["proof (prove)\nusing this:\n  toplevel_summands \\<guillemotleft>s\\<guillemotright>\n  \\<subseteq> (\\<Union>xs.\n                  toplevel_summands\n                   \\<guillemotleft>lderivs xs r\\<guillemotright>)\n  x = Pr \\<guillemotleft>\\<guillemotleft>s\\<guillemotright>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. x \\<in> {Pr Zero} \\<union>\n            {Pr \\<guillemotleft>s\\<guillemotright> |s.\n             toplevel_summands s\n             \\<subseteq> (\\<Union>xs.\n                             toplevel_summands\n                              \\<guillemotleft>lderivs xs\n         r\\<guillemotright>)}", "by blast"], ["proof (state)\nthis:\n  x \\<in> {Pr Zero} \\<union>\n          {Pr \\<guillemotleft>s\\<guillemotright> |s.\n           toplevel_summands s\n           \\<subseteq> (\\<Union>xs.\n                           toplevel_summands\n                            \\<guillemotleft>lderivs xs r\\<guillemotright>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ACI_norm_toplevel_summands: \"finite B \\<Longrightarrow> finite {f \\<guillemotleft>s\\<guillemotright> |s. toplevel_summands s \\<subseteq> B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B \\<Longrightarrow>\n    finite\n     {f \\<guillemotleft>s\\<guillemotright> |s.\n      toplevel_summands s \\<subseteq> B}", "apply (elim finite_surj [OF iffD2 [OF finite_Pow_iff], of _ _ \"f o flatten PLUS o image ACI_norm\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f \\<guillemotleft>s\\<guillemotright> |s.\n     toplevel_summands s \\<subseteq> B}\n    \\<subseteq> (f \\<circ> (\\<lambda>X. PLUS (sorted_list_of_set X)) \\<circ>\n                 (`) ACI_norm) `\n                Pow B", "apply (subst ACI_norm_flatten)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f (PLUS (sorted_list_of_set (ACI_norm ` toplevel_summands s))) |s.\n     toplevel_summands s \\<subseteq> B}\n    \\<subseteq> (f \\<circ> (\\<lambda>X. PLUS (sorted_list_of_set X)) \\<circ>\n                 (`) ACI_norm) `\n                Pow B", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lderivs_Not: \"lderivs xs (Not r) = Not (lderivs xs r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lderivs xs (rexp.Not r) = rexp.Not (lderivs xs r)", "by (induct xs arbitrary: r) auto"], ["", "lemma lderivs_Inter: \"lderivs xs (Inter r s) = Inter (lderivs xs r) (lderivs xs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lderivs xs (rexp.Inter r s) = rexp.Inter (lderivs xs r) (lderivs xs s)", "by (induct xs arbitrary: r s) auto"], ["", "theorem finite_lderivs: \"finite {\\<guillemotleft>lderivs xs r\\<guillemotright> | xs . True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}", "proof (induct r)"], ["proof (state)\ngoal (10 subgoals):\n 1. finite {\\<guillemotleft>lderivs xs Zero\\<guillemotright> |xs. True}\n 2. finite {\\<guillemotleft>lderivs xs Full\\<guillemotright> |xs. True}\n 3. finite {\\<guillemotleft>lderivs xs One\\<guillemotright> |xs. True}\n 4. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 5. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 6. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 7. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 8. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 9. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 10. \\<And>r.\n        finite\n         {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n          True} \\<Longrightarrow>\n        finite\n         {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "case Zero"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. finite {\\<guillemotleft>lderivs xs Zero\\<guillemotright> |xs. True}\n 2. finite {\\<guillemotleft>lderivs xs Full\\<guillemotright> |xs. True}\n 3. finite {\\<guillemotleft>lderivs xs One\\<guillemotright> |xs. True}\n 4. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 5. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 6. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 7. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 8. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 9. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 10. \\<And>r.\n        finite\n         {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n          True} \\<Longrightarrow>\n        finite\n         {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>lderivs xs Zero\\<guillemotright> |xs. True}", "by simp"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs Zero\\<guillemotright> |xs. True}\n\ngoal (9 subgoals):\n 1. finite {\\<guillemotleft>lderivs xs Full\\<guillemotright> |xs. True}\n 2. finite {\\<guillemotleft>lderivs xs One\\<guillemotright> |xs. True}\n 3. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 7. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 8. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 9. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. finite {\\<guillemotleft>lderivs xs Full\\<guillemotright> |xs. True}\n 2. finite {\\<guillemotleft>lderivs xs One\\<guillemotright> |xs. True}\n 3. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 7. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 8. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 9. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "case Full"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. finite {\\<guillemotleft>lderivs xs Full\\<guillemotright> |xs. True}\n 2. finite {\\<guillemotleft>lderivs xs One\\<guillemotright> |xs. True}\n 3. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 7. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 8. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 9. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>lderivs xs Full\\<guillemotright> |xs. True}", "by simp"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs Full\\<guillemotright> |xs. True}\n\ngoal (8 subgoals):\n 1. finite {\\<guillemotleft>lderivs xs One\\<guillemotright> |xs. True}\n 2. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 7. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 8. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. finite {\\<guillemotleft>lderivs xs One\\<guillemotright> |xs. True}\n 2. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 7. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 8. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "case One"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. finite {\\<guillemotleft>lderivs xs One\\<guillemotright> |xs. True}\n 2. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 7. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 8. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>lderivs xs One\\<guillemotright> |xs. True}", "by (rule finite_surj[of \"{Zero, One}\"]) (blast intro: insertE[OF lderivs_One])+"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs One\\<guillemotright> |xs. True}\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 6. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 7. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 6. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 7. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "case (Atom as)"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. \\<And>x.\n       finite\n        {\\<guillemotleft>lderivs xs (Atom x)\\<guillemotright> |xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 6. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 7. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>lderivs xs (Atom as)\\<guillemotright> |xs. True}", "by (rule finite_surj[of \"{Zero, One, Atom as}\"]) (blast intro: insertE[OF lderivs_Atom])+"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs (Atom as)\\<guillemotright> |xs. True}\n\ngoal (6 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 5. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 5. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "case (Plus r s)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}\n  finite {\\<guillemotleft>lderivs xs s\\<guillemotright> |xs. True}\n\ngoal (6 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Plus r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 5. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 6. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<guillemotleft>lderivs xs (Plus r s)\\<guillemotright> |xs. True}", "by (auto simp: lderivs_Plus intro!: finite_surj[OF finite_cartesian_product[OF Plus]])"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs (Plus r s)\\<guillemotright> |xs. True}\n\ngoal (5 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "case (Times r s)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}\n  finite {\\<guillemotleft>lderivs xs s\\<guillemotright> |xs. True}\n\ngoal (5 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "hence \"finite (\\<Union> (toplevel_summands ` {\\<guillemotleft>lderivs xs s\\<guillemotright> | xs . True}))\""], ["proof (prove)\nusing this:\n  finite {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}\n  finite {\\<guillemotleft>lderivs xs s\\<guillemotright> |xs. True}\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>\n       (toplevel_summands `\n        {\\<guillemotleft>lderivs xs s\\<guillemotright> |xs. True}))", "by auto"], ["proof (state)\nthis:\n  finite\n   (\\<Union>\n     (toplevel_summands `\n      {\\<guillemotleft>lderivs xs s\\<guillemotright> |xs. True}))\n\ngoal (5 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "moreover"], ["proof (state)\nthis:\n  finite\n   (\\<Union>\n     (toplevel_summands `\n      {\\<guillemotleft>lderivs xs s\\<guillemotright> |xs. True}))\n\ngoal (5 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "have \"{\\<guillemotleft>r'\\<guillemotright> |r'. \\<exists>ys. r' \\<in> toplevel_summands (lderivs ys s)} =\n    {r'. \\<exists>ys. r' \\<in> toplevel_summands \\<guillemotleft>lderivs ys s\\<guillemotright>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<guillemotleft>r'\\<guillemotright> |r'.\n     \\<exists>ys. r' \\<in> toplevel_summands (lderivs ys s)} =\n    {r'.\n     \\<exists>ys.\n        r' \\<in> toplevel_summands\n                  \\<guillemotleft>lderivs ys s\\<guillemotright>}", "unfolding toplevel_summands_ACI_norm"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<guillemotleft>r'\\<guillemotright> |r'.\n     \\<exists>ys. r' \\<in> toplevel_summands (lderivs ys s)} =\n    {r'. \\<exists>ys. r' \\<in> ACI_norm ` toplevel_summands (lderivs ys s)}", "by auto"], ["proof (state)\nthis:\n  {\\<guillemotleft>r'\\<guillemotright> |r'.\n   \\<exists>ys. r' \\<in> toplevel_summands (lderivs ys s)} =\n  {r'.\n   \\<exists>ys.\n      r' \\<in> toplevel_summands\n                \\<guillemotleft>lderivs ys s\\<guillemotright>}\n\ngoal (5 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   (\\<Union>\n     (toplevel_summands `\n      {\\<guillemotleft>lderivs xs s\\<guillemotright> |xs. True}))\n  {\\<guillemotleft>r'\\<guillemotright> |r'.\n   \\<exists>ys. r' \\<in> toplevel_summands (lderivs ys s)} =\n  {r'.\n   \\<exists>ys.\n      r' \\<in> toplevel_summands\n                \\<guillemotleft>lderivs ys s\\<guillemotright>}", "have fin: \"finite {\\<guillemotleft>r'\\<guillemotright> |r'. \\<exists>ys. r' \\<in> toplevel_summands (lderivs ys s)}\""], ["proof (prove)\nusing this:\n  finite\n   (\\<Union>\n     (toplevel_summands `\n      {\\<guillemotleft>lderivs xs s\\<guillemotright> |xs. True}))\n  {\\<guillemotleft>r'\\<guillemotright> |r'.\n   \\<exists>ys. r' \\<in> toplevel_summands (lderivs ys s)} =\n  {r'.\n   \\<exists>ys.\n      r' \\<in> toplevel_summands\n                \\<guillemotleft>lderivs ys s\\<guillemotright>}\n\ngoal (1 subgoal):\n 1. finite\n     {\\<guillemotleft>r'\\<guillemotright> |r'.\n      \\<exists>ys. r' \\<in> toplevel_summands (lderivs ys s)}", "by (fastforce intro: finite_subset[of _ \"\\<Union> (toplevel_summands ` {\\<guillemotleft>lderivs xs s\\<guillemotright> | xs . True})\"])"], ["proof (state)\nthis:\n  finite\n   {\\<guillemotleft>r'\\<guillemotright> |r'.\n    \\<exists>ys. r' \\<in> toplevel_summands (lderivs ys s)}\n\ngoal (5 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "let ?X = \"\\<lambda>xs. {Times (lderivs ys r) s | ys. True} \\<union> {r'. r' \\<in> (\\<Union>ys. toplevel_summands (lderivs ys s))}\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (Times r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 4. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 5. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<guillemotleft>lderivs xs (Times r s)\\<guillemotright> |xs. True}", "proof (simp only: ACI_norm_flatten,\n      rule finite_surj[of \"{X. \\<exists>xs. X \\<subseteq> ACI_norm ` ?X xs}\" _ \"flatten PLUS\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     {X. \\<exists>xs.\n            X \\<subseteq> ACI_norm `\n                          ({Times (lderivs ys r) s |ys. True} \\<union>\n                           {r'.\n                            r' \\<in> (\\<Union>ys.\n   toplevel_summands (lderivs ys s))})}\n 2. {PLUS\n      (sorted_list_of_set\n        (ACI_norm ` toplevel_summands (lderivs xs (Times r s)))) |\n     xs. True}\n    \\<subseteq> (\\<lambda>X. PLUS (sorted_list_of_set X)) `\n                {X. \\<exists>xs.\n                       X \\<subseteq> ACI_norm `\n                                     ({Times (lderivs ys r) s |ys.\n True} \\<union>\n{r'. r' \\<in> (\\<Union>ys. toplevel_summands (lderivs ys s))})}", "show \"finite {X. \\<exists>xs. X \\<subseteq> ACI_norm ` ?X xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {X. \\<exists>xs.\n            X \\<subseteq> ACI_norm `\n                          ({Times (lderivs ys r) s |ys. True} \\<union>\n                           {r'.\n                            r' \\<in> (\\<Union>ys.\n   toplevel_summands (lderivs ys s))})}", "using fin"], ["proof (prove)\nusing this:\n  finite\n   {\\<guillemotleft>r'\\<guillemotright> |r'.\n    \\<exists>ys. r' \\<in> toplevel_summands (lderivs ys s)}\n\ngoal (1 subgoal):\n 1. finite\n     {X. \\<exists>xs.\n            X \\<subseteq> ACI_norm `\n                          ({Times (lderivs ys r) s |ys. True} \\<union>\n                           {r'.\n                            r' \\<in> (\\<Union>ys.\n   toplevel_summands (lderivs ys s))})}", "by (fastforce simp: image_Un elim: finite_subset[rotated] intro: finite_surj[OF Times(1), of _ \"\\<lambda>r. Times r \\<guillemotleft>s\\<guillemotright>\"])"], ["proof (state)\nthis:\n  finite\n   {X. \\<exists>xs.\n          X \\<subseteq> ACI_norm `\n                        ({Times (lderivs ys r) s |ys. True} \\<union>\n                         {r'.\n                          r' \\<in> (\\<Union>ys.\n toplevel_summands (lderivs ys s))})}\n\ngoal (1 subgoal):\n 1. {PLUS\n      (sorted_list_of_set\n        (ACI_norm ` toplevel_summands (lderivs xs (Times r s)))) |\n     xs. True}\n    \\<subseteq> (\\<lambda>X. PLUS (sorted_list_of_set X)) `\n                {X. \\<exists>xs.\n                       X \\<subseteq> ACI_norm `\n                                     ({Times (lderivs ys r) s |ys.\n True} \\<union>\n{r'. r' \\<in> (\\<Union>ys. toplevel_summands (lderivs ys s))})}", "qed (fastforce dest!: subsetD[OF toplevel_summands_lderivs_Times] intro!: imageI)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs (Times r s)\\<guillemotright> |xs. True}\n\ngoal (4 subgoals):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "case (Star r)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}\n\ngoal (4 subgoals):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "let ?f = \"\\<lambda>f r'. Times r' (Star (f r))\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "let ?X = \"{Star r} \\<union> ?f id ` {r'. r' \\<in> {lderivs ys r|ys. True}}\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 3. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 4. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}", "proof (simp only: ACI_norm_flatten,\n      rule finite_surj[of \"{X. X \\<subseteq> ACI_norm ` ?X}\" _ \"flatten PLUS\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     {X. X \\<subseteq> ACI_norm `\n                       ({Star r} \\<union>\n                        (\\<lambda>r'. Times r' (Star (id r))) `\n                        {r'. r' \\<in> {lderivs ys r |ys. True}})}\n 2. {PLUS\n      (sorted_list_of_set\n        (ACI_norm ` toplevel_summands (lderivs xs (Star r)))) |\n     xs. True}\n    \\<subseteq> (\\<lambda>X. PLUS (sorted_list_of_set X)) `\n                {X. X \\<subseteq> ACI_norm `\n                                  ({Star r} \\<union>\n                                   (\\<lambda>r'. Times r' (Star (id r))) `\n                                   {r'. r' \\<in> {lderivs ys r |ys. True}})}", "have *: \"\\<And>X. ACI_norm ` ?f (\\<lambda>x. x) ` X = ?f ACI_norm ` ACI_norm ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       ACI_norm ` (\\<lambda>r'. Times r' (Star r)) ` X =\n       (\\<lambda>r'. Times r' (Star \\<guillemotleft>r\\<guillemotright>)) `\n       ACI_norm ` X", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  ACI_norm ` (\\<lambda>r'. Times r' (Star r)) ` ?X1 =\n  (\\<lambda>r'. Times r' (Star \\<guillemotleft>r\\<guillemotright>)) `\n  ACI_norm ` ?X1\n\ngoal (2 subgoals):\n 1. finite\n     {X. X \\<subseteq> ACI_norm `\n                       ({Star r} \\<union>\n                        (\\<lambda>r'. Times r' (Star (id r))) `\n                        {r'. r' \\<in> {lderivs ys r |ys. True}})}\n 2. {PLUS\n      (sorted_list_of_set\n        (ACI_norm ` toplevel_summands (lderivs xs (Star r)))) |\n     xs. True}\n    \\<subseteq> (\\<lambda>X. PLUS (sorted_list_of_set X)) `\n                {X. X \\<subseteq> ACI_norm `\n                                  ({Star r} \\<union>\n                                   (\\<lambda>r'. Times r' (Star (id r))) `\n                                   {r'. r' \\<in> {lderivs ys r |ys. True}})}", "show \"finite {X. X \\<subseteq> ACI_norm ` ?X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {X. X \\<subseteq> ACI_norm `\n                       ({Star r} \\<union>\n                        (\\<lambda>r'. Times r' (Star (id r))) `\n                        {r'. r' \\<in> {lderivs ys r |ys. True}})}", "by (rule finite_Collect_subsets)\n         (auto simp: * intro!: finite_imageI[of _ \"?f ACI_norm\"] intro: finite_subset[OF _ Star])"], ["proof (state)\nthis:\n  finite\n   {X. X \\<subseteq> ACI_norm `\n                     ({Star r} \\<union>\n                      (\\<lambda>r'. Times r' (Star (id r))) `\n                      {r'. r' \\<in> {lderivs ys r |ys. True}})}\n\ngoal (1 subgoal):\n 1. {PLUS\n      (sorted_list_of_set\n        (ACI_norm ` toplevel_summands (lderivs xs (Star r)))) |\n     xs. True}\n    \\<subseteq> (\\<lambda>X. PLUS (sorted_list_of_set X)) `\n                {X. X \\<subseteq> ACI_norm `\n                                  ({Star r} \\<union>\n                                   (\\<lambda>r'. Times r' (Star (id r))) `\n                                   {r'. r' \\<in> {lderivs ys r |ys. True}})}", "qed (fastforce dest!: subsetD[OF toplevel_summands_lderivs_Star] intro!: imageI)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs (Star r)\\<guillemotright> |xs. True}\n\ngoal (3 subgoals):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "case (Not r)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}\n\ngoal (3 subgoals):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite\n        {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n 2. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 3. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "thus ?case"], ["proof (prove)\nusing this:\n  finite {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}\n\ngoal (1 subgoal):\n 1. finite\n     {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}", "by (auto simp: lderivs_Not) (blast intro: finite_surj)"], ["proof (state)\nthis:\n  finite\n   {\\<guillemotleft>lderivs xs (rexp.Not r)\\<guillemotright> |xs. True}\n\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "case (Inter r s)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}\n  finite {\\<guillemotleft>lderivs xs s\\<guillemotright> |xs. True}\n\ngoal (2 subgoals):\n 1. \\<And>r1 r2.\n       \\<lbrakk>finite\n                 {\\<guillemotleft>lderivs xs r1\\<guillemotright> |xs. True};\n        finite\n         {\\<guillemotleft>lderivs xs r2\\<guillemotright> |xs. True}\\<rbrakk>\n       \\<Longrightarrow> finite\n                          {\\<guillemotleft>lderivs xs\n      (rexp.Inter r1 r2)\\<guillemotright> |\n                           xs. True}\n 2. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<guillemotleft>lderivs xs (rexp.Inter r s)\\<guillemotright> |xs.\n      True}", "by (auto simp: lderivs_Inter intro!: finite_surj[OF finite_cartesian_product[OF Inter]])"], ["proof (state)\nthis:\n  finite\n   {\\<guillemotleft>lderivs xs (rexp.Inter r s)\\<guillemotright> |xs. True}\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "case (Pr r)"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "hence *: \"finite (\\<Union> (toplevel_summands ` {\\<guillemotleft>lderivs xs r\\<guillemotright> | xs . True}))\""], ["proof (prove)\nusing this:\n  finite {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>\n       (toplevel_summands `\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}))", "by auto"], ["proof (state)\nthis:\n  finite\n   (\\<Union>\n     (toplevel_summands `\n      {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs. True}))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "have \"finite (\\<Union>xs. toplevel_summands \\<guillemotleft>lderivs xs r\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>xs.\n         toplevel_summands \\<guillemotleft>lderivs xs r\\<guillemotright>)", "by (rule finite_subset[OF _ *]) auto"], ["proof (state)\nthis:\n  finite\n   (\\<Union>xs.\n       toplevel_summands \\<guillemotleft>lderivs xs r\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "hence fin: \"finite {Pr \\<guillemotleft>s\\<guillemotright> |s. toplevel_summands s \\<subseteq> (\\<Union>xs. toplevel_summands \\<guillemotleft>lderivs xs r\\<guillemotright>)}\""], ["proof (prove)\nusing this:\n  finite\n   (\\<Union>xs.\n       toplevel_summands \\<guillemotleft>lderivs xs r\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. finite\n     {Pr \\<guillemotleft>s\\<guillemotright> |s.\n      toplevel_summands s\n      \\<subseteq> (\\<Union>xs.\n                      toplevel_summands\n                       \\<guillemotleft>lderivs xs r\\<guillemotright>)}", "by (intro finite_ACI_norm_toplevel_summands)"], ["proof (state)\nthis:\n  finite\n   {Pr \\<guillemotleft>s\\<guillemotright> |s.\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs.\n                    toplevel_summands\n                     \\<guillemotleft>lderivs xs r\\<guillemotright>)}\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "have \"{s. \\<exists>xs. s = \\<guillemotleft>lderivs xs (Pr r)\\<guillemotright>} = {\\<guillemotleft>s\\<guillemotright>| s. \\<exists>xs. s = lderivs xs (Pr r)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. \\<exists>xs.\n           s = \\<guillemotleft>lderivs xs (Pr r)\\<guillemotright>} =\n    {\\<guillemotleft>s\\<guillemotright> |s.\n     \\<exists>xs. s = lderivs xs (Pr r)}", "by auto"], ["proof (state)\nthis:\n  {s. \\<exists>xs. s = \\<guillemotleft>lderivs xs (Pr r)\\<guillemotright>} =\n  {\\<guillemotleft>s\\<guillemotright> |s.\n   \\<exists>xs. s = lderivs xs (Pr r)}\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       finite\n        {\\<guillemotleft>lderivs xs r\\<guillemotright> |xs.\n         True} \\<Longrightarrow>\n       finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "thus ?case"], ["proof (prove)\nusing this:\n  {s. \\<exists>xs. s = \\<guillemotleft>lderivs xs (Pr r)\\<guillemotright>} =\n  {\\<guillemotleft>s\\<guillemotright> |s.\n   \\<exists>xs. s = lderivs xs (Pr r)}\n\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "using finite_subset[OF ACI_norm_lderivs_Pr, of r] fin"], ["proof (prove)\nusing this:\n  {s. \\<exists>xs. s = \\<guillemotleft>lderivs xs (Pr r)\\<guillemotright>} =\n  {\\<guillemotleft>s\\<guillemotright> |s.\n   \\<exists>xs. s = lderivs xs (Pr r)}\n  finite\n   ({Pr Zero} \\<union>\n    {Pr \\<guillemotleft>s\\<guillemotright> |s.\n     toplevel_summands s\n     \\<subseteq> (\\<Union>xs.\n                     toplevel_summands\n                      \\<guillemotleft>lderivs xs\n r\\<guillemotright>)}) \\<Longrightarrow>\n  finite (ACI_norm ` {lderivs xs (Pr r) |xs. True})\n  finite\n   {Pr \\<guillemotleft>s\\<guillemotright> |s.\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs.\n                    toplevel_summands\n                     \\<guillemotleft>lderivs xs r\\<guillemotright>)}\n\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "unfolding image_Collect"], ["proof (prove)\nusing this:\n  {s. \\<exists>xs. s = \\<guillemotleft>lderivs xs (Pr r)\\<guillemotright>} =\n  {\\<guillemotleft>s\\<guillemotright> |s.\n   \\<exists>xs. s = lderivs xs (Pr r)}\n  finite\n   ({Pr Zero} \\<union>\n    {Pr \\<guillemotleft>s\\<guillemotright> |s.\n     toplevel_summands s\n     \\<subseteq> (\\<Union>xs.\n                     toplevel_summands\n                      \\<guillemotleft>lderivs xs\n r\\<guillemotright>)}) \\<Longrightarrow>\n  finite\n   {\\<guillemotleft>x\\<guillemotright> |x.\n    \\<exists>xs. x = lderivs xs (Pr r) \\<and> True}\n  finite\n   {Pr \\<guillemotleft>s\\<guillemotright> |s.\n    toplevel_summands s\n    \\<subseteq> (\\<Union>xs.\n                    toplevel_summands\n                     \\<guillemotleft>lderivs xs r\\<guillemotright>)}\n\ngoal (1 subgoal):\n 1. finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}", "by auto"], ["proof (state)\nthis:\n  finite {\\<guillemotleft>lderivs xs (Pr r)\\<guillemotright> |xs. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Wellformedness and language of derivatives\\<close>"], ["", "lemma wf_lderiv[simp]: \"wf n r \\<Longrightarrow> wf n (lderiv w r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (lderiv w r)", "by (induct r arbitrary: n w) (auto simp add: Let_def)"], ["", "lemma wf_lderivs[simp]: \"wf n r \\<Longrightarrow> wf n (lderivs ws r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf n r \\<Longrightarrow> local.wf n (lderivs ws r)", "by (induct ws arbitrary: r) (auto intro: wf_lderiv)"], ["", "lemma lQuot_map_project:\nassumes \"as \\<in> \\<Sigma> n\" \"A \\<subseteq> lists (\\<Sigma> (Suc n))\"\nshows \"lQuot as (map project ` A) = map project ` (\\<Union>a \\<in> set (embed as). lQuot a A)\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lQuot as (map project ` A) =\n    map project ` (\\<Union>a\\<in>set (embed as). lQuot a A)", "proof (intro equalityI image_subsetI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lQuot as (map project ` A) \\<Longrightarrow>\n       x \\<in> map project ` (\\<Union>a\\<in>set (embed as). lQuot a A)\n 2. \\<And>x.\n       x \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A) \\<Longrightarrow>\n       map project x \\<in> lQuot as (map project ` A)", "fix xss"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lQuot as (map project ` A) \\<Longrightarrow>\n       x \\<in> map project ` (\\<Union>a\\<in>set (embed as). lQuot a A)\n 2. \\<And>x.\n       x \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A) \\<Longrightarrow>\n       map project x \\<in> lQuot as (map project ` A)", "assume \"xss \\<in> ?L\""], ["proof (state)\nthis:\n  xss \\<in> lQuot as (map project ` A)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lQuot as (map project ` A) \\<Longrightarrow>\n       x \\<in> map project ` (\\<Union>a\\<in>set (embed as). lQuot a A)\n 2. \\<And>x.\n       x \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A) \\<Longrightarrow>\n       map project x \\<in> lQuot as (map project ` A)", "with assms"], ["proof (chain)\npicking this:\n  as \\<in> \\<Sigma> n\n  A \\<subseteq> lists (\\<Sigma> (Suc n))\n  xss \\<in> lQuot as (map project ` A)", "obtain zss\n    where zss: \"zss \\<in> A\" \"as # xss = map project zss\""], ["proof (prove)\nusing this:\n  as \\<in> \\<Sigma> n\n  A \\<subseteq> lists (\\<Sigma> (Suc n))\n  xss \\<in> lQuot as (map project ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>zss.\n        \\<lbrakk>zss \\<in> A; as # xss = map project zss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lQuot_def"], ["proof (prove)\nusing this:\n  as \\<in> \\<Sigma> n\n  A \\<subseteq> lists (\\<Sigma> (Suc n))\n  xss \\<in> {xs. as # xs \\<in> map project ` A}\n\ngoal (1 subgoal):\n 1. (\\<And>zss.\n        \\<lbrakk>zss \\<in> A; as # xss = map project zss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  zss \\<in> A\n  as # xss = map project zss\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lQuot as (map project ` A) \\<Longrightarrow>\n       x \\<in> map project ` (\\<Union>a\\<in>set (embed as). lQuot a A)\n 2. \\<And>x.\n       x \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A) \\<Longrightarrow>\n       map project x \\<in> lQuot as (map project ` A)", "hence \"xss = map project (tl zss)\""], ["proof (prove)\nusing this:\n  zss \\<in> A\n  as # xss = map project zss\n\ngoal (1 subgoal):\n 1. xss = map project (tl zss)", "by auto"], ["proof (state)\nthis:\n  xss = map project (tl zss)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> lQuot as (map project ` A) \\<Longrightarrow>\n       x \\<in> map project ` (\\<Union>a\\<in>set (embed as). lQuot a A)\n 2. \\<And>x.\n       x \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A) \\<Longrightarrow>\n       map project x \\<in> lQuot as (map project ` A)", "with zss assms(2)"], ["proof (chain)\npicking this:\n  zss \\<in> A\n  as # xss = map project zss\n  A \\<subseteq> lists (\\<Sigma> (Suc n))\n  xss = map project (tl zss)", "show \"xss \\<in> ?R\""], ["proof (prove)\nusing this:\n  zss \\<in> A\n  as # xss = map project zss\n  A \\<subseteq> lists (\\<Sigma> (Suc n))\n  xss = map project (tl zss)\n\ngoal (1 subgoal):\n 1. xss \\<in> map project ` (\\<Union>a\\<in>set (embed as). lQuot a A)", "using embed[OF project, of _ n]"], ["proof (prove)\nusing this:\n  zss \\<in> A\n  as # xss = map project zss\n  A \\<subseteq> lists (\\<Sigma> (Suc n))\n  xss = map project (tl zss)\n  ?a1 \\<in> \\<Sigma> (Suc n) \\<Longrightarrow>\n  (?b \\<in> set (embed (project ?a1))) =\n  (?b \\<in> \\<Sigma> (Suc n) \\<and> project ?b = project ?a1)\n\ngoal (1 subgoal):\n 1. xss \\<in> map project ` (\\<Union>a\\<in>set (embed as). lQuot a A)", "unfolding lQuot_def"], ["proof (prove)\nusing this:\n  zss \\<in> A\n  as # xss = map project zss\n  A \\<subseteq> lists (\\<Sigma> (Suc n))\n  xss = map project (tl zss)\n  ?a1 \\<in> \\<Sigma> (Suc n) \\<Longrightarrow>\n  (?b \\<in> set (embed (project ?a1))) =\n  (?b \\<in> \\<Sigma> (Suc n) \\<and> project ?b = project ?a1)\n\ngoal (1 subgoal):\n 1. xss\n    \\<in> map project ` (\\<Union>a\\<in>set (embed as). {xs. a # xs \\<in> A})", "by fastforce"], ["proof (state)\nthis:\n  xss \\<in> map project ` (\\<Union>a\\<in>set (embed as). lQuot a A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A) \\<Longrightarrow>\n       map project x \\<in> lQuot as (map project ` A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A) \\<Longrightarrow>\n       map project x \\<in> lQuot as (map project ` A)", "fix xss"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A) \\<Longrightarrow>\n       map project x \\<in> lQuot as (map project ` A)", "assume \"xss \\<in> (\\<Union>a \\<in> set (embed as). lQuot a A)\""], ["proof (state)\nthis:\n  xss \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A) \\<Longrightarrow>\n       map project x \\<in> lQuot as (map project ` A)", "with assms(1)"], ["proof (chain)\npicking this:\n  as \\<in> \\<Sigma> n\n  xss \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A)", "show \"map project xss \\<in> lQuot as (map project ` A)\""], ["proof (prove)\nusing this:\n  as \\<in> \\<Sigma> n\n  xss \\<in> (\\<Union>a\\<in>set (embed as). lQuot a A)\n\ngoal (1 subgoal):\n 1. map project xss \\<in> lQuot as (map project ` A)", "unfolding lQuot_def"], ["proof (prove)\nusing this:\n  as \\<in> \\<Sigma> n\n  xss \\<in> (\\<Union>a\\<in>set (embed as). {xs. a # xs \\<in> A})\n\ngoal (1 subgoal):\n 1. map project xss \\<in> {xs. as # xs \\<in> map project ` A}", "by (fastforce intro!: rev_image_eqI simp: embed)"], ["proof (state)\nthis:\n  map project xss \\<in> lQuot as (map project ` A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lang_lderiv: \"\\<lbrakk>wf n r; w \\<in> \\<Sigma> n\\<rbrakk> \\<Longrightarrow> lang n (lderiv w r) = lQuot w (lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n    \\<Longrightarrow> lang n (lderiv w r) = lQuot w (lang n r)", "proof (induct r arbitrary: n w)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>local.wf n Zero; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w Zero) = lQuot w (lang n Zero)\n 2. \\<And>n w.\n       \\<lbrakk>local.wf n Full; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w Full) = lQuot w (lang n Full)\n 3. \\<And>n w.\n       \\<lbrakk>local.wf n One; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w One) = lQuot w (lang n One)\n 4. \\<And>x n w.\n       \\<lbrakk>local.wf n (Atom x); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Atom x)) =\n                         lQuot w (lang n (Atom x))\n 5. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (Plus r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Plus r1 r2)) =\n                         lQuot w (lang n (Plus r1 r2))\n 6. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (Times r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Times r1 r2)) =\n                         lQuot w (lang n (Times r1 r2))\n 7. \\<And>r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r) =\n                                     lQuot w (lang n r);\n        local.wf n (Star r); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Star r)) =\n                         lQuot w (lang n (Star r))\n 8. \\<And>r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r) =\n                                     lQuot w (lang n r);\n        local.wf n (rexp.Not r); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (rexp.Not r)) =\n                         lQuot w (lang n (rexp.Not r))\n 9. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (rexp.Inter r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (rexp.Inter r1 r2)) =\n                         lQuot w (lang n (rexp.Inter r1 r2))\n 10. \\<And>r n w.\n        \\<lbrakk>\\<And>n w.\n                    \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                    \\<Longrightarrow> lang n (lderiv w r) =\nlQuot w (lang n r);\n         local.wf n (Pr r); w \\<in> \\<Sigma> n\\<rbrakk>\n        \\<Longrightarrow> lang n (lderiv w (Pr r)) = lQuot w (lang n (Pr r))", "case (Pr r)"], ["proof (state)\nthis:\n  \\<lbrakk>local.wf ?n r; ?w \\<in> \\<Sigma> ?n\\<rbrakk>\n  \\<Longrightarrow> lang ?n (lderiv ?w r) = lQuot ?w (lang ?n r)\n  local.wf n (Pr r)\n  w \\<in> \\<Sigma> n\n\ngoal (10 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>local.wf n Zero; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w Zero) = lQuot w (lang n Zero)\n 2. \\<And>n w.\n       \\<lbrakk>local.wf n Full; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w Full) = lQuot w (lang n Full)\n 3. \\<And>n w.\n       \\<lbrakk>local.wf n One; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w One) = lQuot w (lang n One)\n 4. \\<And>x n w.\n       \\<lbrakk>local.wf n (Atom x); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Atom x)) =\n                         lQuot w (lang n (Atom x))\n 5. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (Plus r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Plus r1 r2)) =\n                         lQuot w (lang n (Plus r1 r2))\n 6. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (Times r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Times r1 r2)) =\n                         lQuot w (lang n (Times r1 r2))\n 7. \\<And>r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r) =\n                                     lQuot w (lang n r);\n        local.wf n (Star r); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Star r)) =\n                         lQuot w (lang n (Star r))\n 8. \\<And>r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r) =\n                                     lQuot w (lang n r);\n        local.wf n (rexp.Not r); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (rexp.Not r)) =\n                         lQuot w (lang n (rexp.Not r))\n 9. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (rexp.Inter r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (rexp.Inter r1 r2)) =\n                         lQuot w (lang n (rexp.Inter r1 r2))\n 10. \\<And>r n w.\n        \\<lbrakk>\\<And>n w.\n                    \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                    \\<Longrightarrow> lang n (lderiv w r) =\nlQuot w (lang n r);\n         local.wf n (Pr r); w \\<in> \\<Sigma> n\\<rbrakk>\n        \\<Longrightarrow> lang n (lderiv w (Pr r)) = lQuot w (lang n (Pr r))", "hence *: \"wf (Suc n) r\" \"\\<And>w'. w' \\<in> set (embed w) \\<Longrightarrow>  w' \\<in> \\<Sigma> (Suc n)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>local.wf ?n r; ?w \\<in> \\<Sigma> ?n\\<rbrakk>\n  \\<Longrightarrow> lang ?n (lderiv ?w r) = lQuot ?w (lang ?n r)\n  local.wf n (Pr r)\n  w \\<in> \\<Sigma> n\n\ngoal (1 subgoal):\n 1. local.wf (Suc n) r &&&\n    (\\<And>w'.\n        w' \\<in> set (embed w) \\<Longrightarrow> w' \\<in> \\<Sigma> (Suc n))", "by (auto simp: embed)"], ["proof (state)\nthis:\n  local.wf (Suc n) r\n  ?w' \\<in> set (embed w) \\<Longrightarrow> ?w' \\<in> \\<Sigma> (Suc n)\n\ngoal (10 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>local.wf n Zero; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w Zero) = lQuot w (lang n Zero)\n 2. \\<And>n w.\n       \\<lbrakk>local.wf n Full; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w Full) = lQuot w (lang n Full)\n 3. \\<And>n w.\n       \\<lbrakk>local.wf n One; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w One) = lQuot w (lang n One)\n 4. \\<And>x n w.\n       \\<lbrakk>local.wf n (Atom x); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Atom x)) =\n                         lQuot w (lang n (Atom x))\n 5. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (Plus r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Plus r1 r2)) =\n                         lQuot w (lang n (Plus r1 r2))\n 6. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (Times r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Times r1 r2)) =\n                         lQuot w (lang n (Times r1 r2))\n 7. \\<And>r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r) =\n                                     lQuot w (lang n r);\n        local.wf n (Star r); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Star r)) =\n                         lQuot w (lang n (Star r))\n 8. \\<And>r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r) =\n                                     lQuot w (lang n r);\n        local.wf n (rexp.Not r); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (rexp.Not r)) =\n                         lQuot w (lang n (rexp.Not r))\n 9. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (rexp.Inter r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (rexp.Inter r1 r2)) =\n                         lQuot w (lang n (rexp.Inter r1 r2))\n 10. \\<And>r n w.\n        \\<lbrakk>\\<And>n w.\n                    \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                    \\<Longrightarrow> lang n (lderiv w r) =\nlQuot w (lang n r);\n         local.wf n (Pr r); w \\<in> \\<Sigma> n\\<rbrakk>\n        \\<Longrightarrow> lang n (lderiv w (Pr r)) = lQuot w (lang n (Pr r))", "from Pr(1)[OF *] lQuot_map_project[OF Pr(3) lang_subset_lists[OF *(1)]]"], ["proof (chain)\npicking this:\n  ?w \\<in> set (embed w) \\<Longrightarrow>\n  lang (Suc n) (lderiv ?w r) = lQuot ?w (lang (Suc n) r)\n  lQuot w (map project ` lang (Suc n) r) =\n  map project ` (\\<Union>a\\<in>set (embed w). lQuot a (lang (Suc n) r))", "show ?case"], ["proof (prove)\nusing this:\n  ?w \\<in> set (embed w) \\<Longrightarrow>\n  lang (Suc n) (lderiv ?w r) = lQuot ?w (lang (Suc n) r)\n  lQuot w (map project ` lang (Suc n) r) =\n  map project ` (\\<Union>a\\<in>set (embed w). lQuot a (lang (Suc n) r))\n\ngoal (1 subgoal):\n 1. lang n (lderiv w (Pr r)) = lQuot w (lang n (Pr r))", "by (auto simp: wf_lderiv[OF *(1)])"], ["proof (state)\nthis:\n  lang n (lderiv w (Pr r)) = lQuot w (lang n (Pr r))\n\ngoal (9 subgoals):\n 1. \\<And>n w.\n       \\<lbrakk>local.wf n Zero; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w Zero) = lQuot w (lang n Zero)\n 2. \\<And>n w.\n       \\<lbrakk>local.wf n Full; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w Full) = lQuot w (lang n Full)\n 3. \\<And>n w.\n       \\<lbrakk>local.wf n One; w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w One) = lQuot w (lang n One)\n 4. \\<And>x n w.\n       \\<lbrakk>local.wf n (Atom x); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Atom x)) =\n                         lQuot w (lang n (Atom x))\n 5. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (Plus r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Plus r1 r2)) =\n                         lQuot w (lang n (Plus r1 r2))\n 6. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (Times r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Times r1 r2)) =\n                         lQuot w (lang n (Times r1 r2))\n 7. \\<And>r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r) =\n                                     lQuot w (lang n r);\n        local.wf n (Star r); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (Star r)) =\n                         lQuot w (lang n (Star r))\n 8. \\<And>r n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r) =\n                                     lQuot w (lang n r);\n        local.wf n (rexp.Not r); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (rexp.Not r)) =\n                         lQuot w (lang n (rexp.Not r))\n 9. \\<And>r1 r2 n w.\n       \\<lbrakk>\\<And>n w.\n                   \\<lbrakk>local.wf n r1; w \\<in> \\<Sigma> n\\<rbrakk>\n                   \\<Longrightarrow> lang n (lderiv w r1) =\n                                     lQuot w (lang n r1);\n        \\<And>n w.\n           \\<lbrakk>local.wf n r2; w \\<in> \\<Sigma> n\\<rbrakk>\n           \\<Longrightarrow> lang n (lderiv w r2) = lQuot w (lang n r2);\n        local.wf n (rexp.Inter r1 r2); w \\<in> \\<Sigma> n\\<rbrakk>\n       \\<Longrightarrow> lang n (lderiv w (rexp.Inter r1 r2)) =\n                         lQuot w (lang n (rexp.Inter r1 r2))", "qed (auto simp: Let_def lang_final[symmetric])"], ["", "lemma lang_lderivs: \"\\<lbrakk>wf n r; wf_word n ws\\<rbrakk> \\<Longrightarrow> lang n (lderivs ws r) = lQuots ws (lang n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.wf n r; wf_word n ws\\<rbrakk>\n    \\<Longrightarrow> lang n (lderivs ws r) = lQuots ws (lang n r)", "by (induct ws arbitrary: r) (auto simp: lang_lderiv)"], ["", "corollary lderivs_final:\nassumes \"wf n r\" \"wf_word n ws\"\nshows \"final (lderivs ws r) \\<longleftrightarrow> ws \\<in> lang n r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final (lderivs ws r) = (ws \\<in> lang n r)", "using lang_lderivs[OF assms] lang_final[of \"lderivs ws r\" n]"], ["proof (prove)\nusing this:\n  lang n (lderivs ws r) = lQuots ws (lang n r)\n  final (lderivs ws r) = ([] \\<in> lang n (lderivs ws r))\n\ngoal (1 subgoal):\n 1. final (lderivs ws r) = (ws \\<in> lang n r)", "by auto"], ["", "abbreviation \"lderivs_set n r s \\<equiv> {(\\<guillemotleft>lderivs w r\\<guillemotright>, \\<guillemotleft>lderivs w s\\<guillemotright>) | w. wf_word n w}\""], ["", "subsection \\<open>Deriving preserves ACI-equivalence\\<close>"], ["", "lemma ACI_norm_PLUS:\n  \"list_all2 (\\<lambda>r s. \\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>) xs ys \\<Longrightarrow> \\<guillemotleft>PLUS xs\\<guillemotright> = \\<guillemotleft>PLUS ys\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>r s.\n         \\<guillemotleft>r\\<guillemotright> =\n         \\<guillemotleft>s\\<guillemotright>)\n     xs ys \\<Longrightarrow>\n    \\<guillemotleft>PLUS xs\\<guillemotright> =\n    \\<guillemotleft>PLUS ys\\<guillemotright>", "proof (induct rule: list_all2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>PLUS []\\<guillemotright> =\n    \\<guillemotleft>PLUS []\\<guillemotright>\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<guillemotleft>x\\<guillemotright> =\n                \\<guillemotleft>y\\<guillemotright>;\n        list_all2\n         (\\<lambda>r s.\n             \\<guillemotleft>r\\<guillemotright> =\n             \\<guillemotleft>s\\<guillemotright>)\n         xs ys;\n        \\<guillemotleft>PLUS xs\\<guillemotright> =\n        \\<guillemotleft>PLUS ys\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n                         \\<guillemotleft>PLUS (y # ys)\\<guillemotright>", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  \\<guillemotleft>x\\<guillemotright> = \\<guillemotleft>y\\<guillemotright>\n  list_all2\n   (\\<lambda>r s.\n       \\<guillemotleft>r\\<guillemotright> =\n       \\<guillemotleft>s\\<guillemotright>)\n   xs ys\n  \\<guillemotleft>PLUS xs\\<guillemotright> =\n  \\<guillemotleft>PLUS ys\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>PLUS []\\<guillemotright> =\n    \\<guillemotleft>PLUS []\\<guillemotright>\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<guillemotleft>x\\<guillemotright> =\n                \\<guillemotleft>y\\<guillemotright>;\n        list_all2\n         (\\<lambda>r s.\n             \\<guillemotleft>r\\<guillemotright> =\n             \\<guillemotleft>s\\<guillemotright>)\n         xs ys;\n        \\<guillemotleft>PLUS xs\\<guillemotright> =\n        \\<guillemotleft>PLUS ys\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n                         \\<guillemotleft>PLUS (y # ys)\\<guillemotright>", "hence \"length xs = length ys\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>x\\<guillemotright> = \\<guillemotleft>y\\<guillemotright>\n  list_all2\n   (\\<lambda>r s.\n       \\<guillemotleft>r\\<guillemotright> =\n       \\<guillemotleft>s\\<guillemotright>)\n   xs ys\n  \\<guillemotleft>PLUS xs\\<guillemotright> =\n  \\<guillemotleft>PLUS ys\\<guillemotright>\n\ngoal (1 subgoal):\n 1. length xs = length ys", "by (elim list_all2_lengthD)"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>PLUS []\\<guillemotright> =\n    \\<guillemotleft>PLUS []\\<guillemotright>\n 2. \\<And>x xs y ys.\n       \\<lbrakk>\\<guillemotleft>x\\<guillemotright> =\n                \\<guillemotleft>y\\<guillemotright>;\n        list_all2\n         (\\<lambda>r s.\n             \\<guillemotleft>r\\<guillemotright> =\n             \\<guillemotleft>s\\<guillemotright>)\n         xs ys;\n        \\<guillemotleft>PLUS xs\\<guillemotright> =\n        \\<guillemotleft>PLUS ys\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n                         \\<guillemotleft>PLUS (y # ys)\\<guillemotright>", "thus ?case"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n    \\<guillemotleft>PLUS (y # ys)\\<guillemotright>", "using Cons"], ["proof (prove)\nusing this:\n  length xs = length ys\n  \\<guillemotleft>x\\<guillemotright> = \\<guillemotleft>y\\<guillemotright>\n  list_all2\n   (\\<lambda>r s.\n       \\<guillemotleft>r\\<guillemotright> =\n       \\<guillemotleft>s\\<guillemotright>)\n   xs ys\n  \\<guillemotleft>PLUS xs\\<guillemotright> =\n  \\<guillemotleft>PLUS ys\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n    \\<guillemotleft>PLUS (y # ys)\\<guillemotright>", "by (induct xs ys rule: list_induct2) auto"], ["proof (state)\nthis:\n  \\<guillemotleft>PLUS (x # xs)\\<guillemotright> =\n  \\<guillemotleft>PLUS (y # ys)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>PLUS []\\<guillemotright> =\n    \\<guillemotleft>PLUS []\\<guillemotright>", "qed simp"], ["", "lemma toplevel_summands_ACI_norm_lderiv:\n  \"(\\<Union>a\\<in>toplevel_summands r. toplevel_summands \\<guillemotleft>lderiv as \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) = toplevel_summands \\<guillemotleft>lderiv as \\<guillemotleft>r\\<guillemotright>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>toplevel_summands r.\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>r\\<guillemotright>\\<guillemotright>", "proof (induct r)"], ["proof (state)\ngoal (10 subgoals):\n 1. (\\<Union>a\\<in>toplevel_summands Zero.\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright>\n 2. (\\<Union>a\\<in>toplevel_summands Full.\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>Full\\<guillemotright>\\<guillemotright>\n 3. (\\<Union>a\\<in>toplevel_summands One.\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>One\\<guillemotright>\\<guillemotright>\n 4. \\<And>x.\n       (\\<Union>a\\<in>toplevel_summands (Atom x).\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>Atom\n    x\\<guillemotright>\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>lderiv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>lderiv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands (Plus r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>lderiv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>lderiv as\n     \\<guillemotleft>Plus r1 r2\\<guillemotright>\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>lderiv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>lderiv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands (Times r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>lderiv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>lderiv as\n     \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright>\n 7. \\<And>r.\n       (\\<Union>a\\<in>toplevel_summands r.\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n       (\\<Union>a\\<in>toplevel_summands (Star r).\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>Star\n    r\\<guillemotright>\\<guillemotright>\n 8. \\<And>r.\n       (\\<Union>a\\<in>toplevel_summands r.\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n       (\\<Union>a\\<in>toplevel_summands (rexp.Not r).\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>rexp.Not\n    r\\<guillemotright>\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>lderiv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>lderiv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands\n   (rexp.Inter r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>lderiv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>lderiv as\n     \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright>\n 10. \\<And>r.\n        (\\<Union>a\\<in>toplevel_summands r.\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n        (\\<Union>a\\<in>toplevel_summands (Pr r).\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>Pr\n     r\\<guillemotright>\\<guillemotright>", "case (Plus r1 r2)"], ["proof (state)\nthis:\n  (\\<Union>a\\<in>toplevel_summands r1.\n      toplevel_summands\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n  toplevel_summands\n   \\<guillemotleft>lderiv as\n                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>\n  (\\<Union>a\\<in>toplevel_summands r2.\n      toplevel_summands\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n  toplevel_summands\n   \\<guillemotleft>lderiv as\n                    \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\n\ngoal (10 subgoals):\n 1. (\\<Union>a\\<in>toplevel_summands Zero.\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright>\n 2. (\\<Union>a\\<in>toplevel_summands Full.\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>Full\\<guillemotright>\\<guillemotright>\n 3. (\\<Union>a\\<in>toplevel_summands One.\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>One\\<guillemotright>\\<guillemotright>\n 4. \\<And>x.\n       (\\<Union>a\\<in>toplevel_summands (Atom x).\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>Atom\n    x\\<guillemotright>\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>lderiv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>lderiv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands (Plus r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>lderiv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>lderiv as\n     \\<guillemotleft>Plus r1 r2\\<guillemotright>\\<guillemotright>\n 6. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>lderiv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>lderiv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands (Times r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>lderiv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>lderiv as\n     \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright>\n 7. \\<And>r.\n       (\\<Union>a\\<in>toplevel_summands r.\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n       (\\<Union>a\\<in>toplevel_summands (Star r).\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>Star\n    r\\<guillemotright>\\<guillemotright>\n 8. \\<And>r.\n       (\\<Union>a\\<in>toplevel_summands r.\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n       (\\<Union>a\\<in>toplevel_summands (rexp.Not r).\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>rexp.Not\n    r\\<guillemotright>\\<guillemotright>\n 9. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>lderiv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>lderiv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands\n   (rexp.Inter r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>lderiv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>lderiv as\n     \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright>\n 10. \\<And>r.\n        (\\<Union>a\\<in>toplevel_summands r.\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n        (\\<Union>a\\<in>toplevel_summands (Pr r).\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>Pr\n     r\\<guillemotright>\\<guillemotright>", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Union>a\\<in>toplevel_summands r1.\n      toplevel_summands\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n  toplevel_summands\n   \\<guillemotleft>lderiv as\n                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>\n  (\\<Union>a\\<in>toplevel_summands r2.\n      toplevel_summands\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n  toplevel_summands\n   \\<guillemotleft>lderiv as\n                    \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>toplevel_summands (Plus r1 r2).\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>Plus r1\n r2\\<guillemotright>\\<guillemotright>", "unfolding toplevel_summands.simps toplevel_summands_ACI_norm\n     toplevel_summands_lderiv[of as \"\\<guillemotleft>Plus r1 r2\\<guillemotright>\"] image_Un Union_Un_distrib"], ["proof (prove)\nusing this:\n  (\\<Union>a\\<in>toplevel_summands r1.\n      ACI_norm `\n      toplevel_summands (lderiv as \\<guillemotleft>a\\<guillemotright>)) =\n  ACI_norm `\n  toplevel_summands (lderiv as \\<guillemotleft>r1\\<guillemotright>)\n  (\\<Union>a\\<in>toplevel_summands r2.\n      ACI_norm `\n      toplevel_summands (lderiv as \\<guillemotleft>a\\<guillemotright>)) =\n  ACI_norm `\n  toplevel_summands (lderiv as \\<guillemotleft>r2\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>toplevel_summands r1.\n        ACI_norm `\n        toplevel_summands\n         (lderiv as \\<guillemotleft>a\\<guillemotright>)) \\<union>\n    (\\<Union>a\\<in>toplevel_summands r2.\n        ACI_norm `\n        toplevel_summands (lderiv as \\<guillemotleft>a\\<guillemotright>)) =\n    ACI_norm `\n    (\\<Union>s\\<in>ACI_norm ` toplevel_summands r1.\n        toplevel_summands (lderiv as s)) \\<union>\n    ACI_norm `\n    (\\<Union>s\\<in>ACI_norm ` toplevel_summands r2.\n        toplevel_summands (lderiv as s))", "by (simp add: image_UN)"], ["proof (state)\nthis:\n  (\\<Union>a\\<in>toplevel_summands (Plus r1 r2).\n      toplevel_summands\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n  toplevel_summands\n   \\<guillemotleft>lderiv as\n                    \\<guillemotleft>Plus r1\n                                     r2\\<guillemotright>\\<guillemotright>\n\ngoal (9 subgoals):\n 1. (\\<Union>a\\<in>toplevel_summands Zero.\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright>\n 2. (\\<Union>a\\<in>toplevel_summands Full.\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>Full\\<guillemotright>\\<guillemotright>\n 3. (\\<Union>a\\<in>toplevel_summands One.\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n    toplevel_summands\n     \\<guillemotleft>lderiv as\n                      \\<guillemotleft>One\\<guillemotright>\\<guillemotright>\n 4. \\<And>x.\n       (\\<Union>a\\<in>toplevel_summands (Atom x).\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>Atom\n    x\\<guillemotright>\\<guillemotright>\n 5. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>lderiv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>lderiv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands (Times r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>lderiv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>lderiv as\n     \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright>\n 6. \\<And>r.\n       (\\<Union>a\\<in>toplevel_summands r.\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n       (\\<Union>a\\<in>toplevel_summands (Star r).\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>Star\n    r\\<guillemotright>\\<guillemotright>\n 7. \\<And>r.\n       (\\<Union>a\\<in>toplevel_summands r.\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n       (\\<Union>a\\<in>toplevel_summands (rexp.Not r).\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>rexp.Not\n    r\\<guillemotright>\\<guillemotright>\n 8. \\<And>r1 r2.\n       \\<lbrakk>(\\<Union>a\\<in>toplevel_summands r1.\n                    toplevel_summands\n                     \\<guillemotleft>lderiv as\n\\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                toplevel_summands\n                 \\<guillemotleft>lderiv as\n                                  \\<guillemotleft>r1\\<guillemotright>\\<guillemotright>;\n        (\\<Union>a\\<in>toplevel_summands r2.\n            toplevel_summands\n             \\<guillemotleft>lderiv as\n                              \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n        toplevel_summands\n         \\<guillemotleft>lderiv as\n                          \\<guillemotleft>r2\\<guillemotright>\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>toplevel_summands\n   (rexp.Inter r1 r2).\n                             toplevel_summands\n                              \\<guillemotleft>lderiv as\n         \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n                         toplevel_summands\n                          \\<guillemotleft>lderiv as\n     \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright>\n 9. \\<And>r.\n       (\\<Union>a\\<in>toplevel_summands r.\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>r\\<guillemotright>\\<guillemotright> \\<Longrightarrow>\n       (\\<Union>a\\<in>toplevel_summands (Pr r).\n           toplevel_summands\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>a\\<guillemotright>\\<guillemotright>) =\n       toplevel_summands\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>Pr\n    r\\<guillemotright>\\<guillemotright>", "qed (auto simp: Let_def)"], ["", "theorem ACI_norm_lderiv:\n  \"\\<guillemotleft>lderiv as \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>lderiv as r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>lderiv as\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>lderiv as r\\<guillemotright>", "proof (induct r arbitrary: as)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Zero\\<guillemotright>\n 2. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Full\\<guillemotright>\n 3. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as One\\<guillemotright>\n 4. \\<And>x as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Atom\n   x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Atom x)\\<guillemotright>\n 5. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>Plus r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (Plus r1 r2)\\<guillemotright>\n 6. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (Times r1 r2)\\<guillemotright>\n 7. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Star\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Star r)\\<guillemotright>\n 8. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>rexp.Not\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (rexp.Not r)\\<guillemotright>\n 9. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (rexp.Inter r1 r2)\\<guillemotright>\n 10. \\<And>r as.\n        (\\<And>as.\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n            \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>Pr\n    r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>lderiv as (Pr r)\\<guillemotright>", "case (Plus r1 r2)"], ["proof (state)\nthis:\n  \\<guillemotleft>lderiv ?as\n                   \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv ?as r1\\<guillemotright>\n  \\<guillemotleft>lderiv ?as\n                   \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv ?as r2\\<guillemotright>\n\ngoal (10 subgoals):\n 1. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Zero\\<guillemotright>\n 2. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Full\\<guillemotright>\n 3. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as One\\<guillemotright>\n 4. \\<And>x as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Atom\n   x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Atom x)\\<guillemotright>\n 5. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>Plus r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (Plus r1 r2)\\<guillemotright>\n 6. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (Times r1 r2)\\<guillemotright>\n 7. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Star\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Star r)\\<guillemotright>\n 8. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>rexp.Not\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (rexp.Not r)\\<guillemotright>\n 9. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (rexp.Inter r1 r2)\\<guillemotright>\n 10. \\<And>r as.\n        (\\<And>as.\n            \\<guillemotleft>lderiv as\n                             \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n            \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n        \\<guillemotleft>lderiv as\n                         \\<guillemotleft>Pr\n    r\\<guillemotright>\\<guillemotright> =\n        \\<guillemotleft>lderiv as (Pr r)\\<guillemotright>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<guillemotleft>lderiv ?as\n                   \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv ?as r1\\<guillemotright>\n  \\<guillemotleft>lderiv ?as\n                   \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv ?as r2\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>lderiv as\n                     \\<guillemotleft>Plus r1\nr2\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>lderiv as (Plus r1 r2)\\<guillemotright>", "unfolding lderiv.simps ACI_norm_flatten[of \"lderiv as \\<guillemotleft>Plus r1 r2\\<guillemotright>\"]\n     toplevel_summands_lderiv[of as \"\\<guillemotleft>Plus r1 r2\\<guillemotright>\"] image_Un image_UN"], ["proof (prove)\nusing this:\n  \\<guillemotleft>lderiv ?as\n                   \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv ?as r1\\<guillemotright>\n  \\<guillemotleft>lderiv ?as\n                   \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv ?as r2\\<guillemotright>\n\ngoal (1 subgoal):\n 1. PLUS\n     (sorted_list_of_set\n       (\\<Union>x\\<in>toplevel_summands\n                       \\<guillemotleft>Plus r1 r2\\<guillemotright>.\n           ACI_norm ` toplevel_summands (lderiv as x))) =\n    \\<guillemotleft>Plus (lderiv as r1) (lderiv as r2)\\<guillemotright>", "by (auto simp: toplevel_summands_ACI_norm toplevel_summands_flatten_ACI_norm_image_Union)\n     (auto simp: toplevel_summands_ACI_norm[symmetric] toplevel_summands_ACI_norm_lderiv)"], ["proof (state)\nthis:\n  \\<guillemotleft>lderiv as\n                   \\<guillemotleft>Plus r1\n                                    r2\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv as (Plus r1 r2)\\<guillemotright>\n\ngoal (9 subgoals):\n 1. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Zero\\<guillemotright>\n 2. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Full\\<guillemotright>\n 3. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as One\\<guillemotright>\n 4. \\<And>x as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Atom\n   x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Atom x)\\<guillemotright>\n 5. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (Times r1 r2)\\<guillemotright>\n 6. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Star\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Star r)\\<guillemotright>\n 7. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>rexp.Not\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (rexp.Not r)\\<guillemotright>\n 8. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (rexp.Inter r1 r2)\\<guillemotright>\n 9. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Pr r)\\<guillemotright>", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Zero\\<guillemotright>\n 2. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Full\\<guillemotright>\n 3. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as One\\<guillemotright>\n 4. \\<And>x as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Atom\n   x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Atom x)\\<guillemotright>\n 5. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (Times r1 r2)\\<guillemotright>\n 6. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Star\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Star r)\\<guillemotright>\n 7. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>rexp.Not\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (rexp.Not r)\\<guillemotright>\n 8. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (rexp.Inter r1 r2)\\<guillemotright>\n 9. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Pr r)\\<guillemotright>", "case (Pr r)"], ["proof (state)\nthis:\n  \\<guillemotleft>lderiv ?as\n                   \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv ?as r\\<guillemotright>\n\ngoal (9 subgoals):\n 1. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Zero\\<guillemotright>\n 2. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Full\\<guillemotright>\n 3. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as One\\<guillemotright>\n 4. \\<And>x as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Atom\n   x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Atom x)\\<guillemotright>\n 5. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (Times r1 r2)\\<guillemotright>\n 6. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Star\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Star r)\\<guillemotright>\n 7. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>rexp.Not\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (rexp.Not r)\\<guillemotright>\n 8. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (rexp.Inter r1 r2)\\<guillemotright>\n 9. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Pr r)\\<guillemotright>", "hence \"list_all2 (\\<lambda>r s. \\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright>)\n    (map (\\<lambda>a. lderiv a \\<guillemotleft>r\\<guillemotright>) (embed as)) (map (\\<lambda>a. lderiv a r) (embed as))\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>lderiv ?as\n                   \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv ?as r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>r s.\n         \\<guillemotleft>r\\<guillemotright> =\n         \\<guillemotleft>s\\<guillemotright>)\n     (map (\\<lambda>a. lderiv a \\<guillemotleft>r\\<guillemotright>)\n       (embed as))\n     (map (\\<lambda>a. lderiv a r) (embed as))", "unfolding list_all2_map1 list_all2_map2"], ["proof (prove)\nusing this:\n  \\<guillemotleft>lderiv ?as\n                   \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv ?as r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x y.\n         \\<guillemotleft>lderiv x\n                          \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n         \\<guillemotleft>lderiv y r\\<guillemotright>)\n     (embed as) (embed as)", "by (intro list_all2_refl)"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>r s.\n       \\<guillemotleft>r\\<guillemotright> =\n       \\<guillemotleft>s\\<guillemotright>)\n   (map (\\<lambda>a. lderiv a \\<guillemotleft>r\\<guillemotright>)\n     (embed as))\n   (map (\\<lambda>a. lderiv a r) (embed as))\n\ngoal (9 subgoals):\n 1. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Zero\\<guillemotright>\n 2. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Full\\<guillemotright>\n 3. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as One\\<guillemotright>\n 4. \\<And>x as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Atom\n   x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Atom x)\\<guillemotright>\n 5. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (Times r1 r2)\\<guillemotright>\n 6. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Star\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Star r)\\<guillemotright>\n 7. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>rexp.Not\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (rexp.Not r)\\<guillemotright>\n 8. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (rexp.Inter r1 r2)\\<guillemotright>\n 9. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Pr\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Pr r)\\<guillemotright>", "thus ?case"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>r s.\n       \\<guillemotleft>r\\<guillemotright> =\n       \\<guillemotleft>s\\<guillemotright>)\n   (map (\\<lambda>a. lderiv a \\<guillemotleft>r\\<guillemotright>)\n     (embed as))\n   (map (\\<lambda>a. lderiv a r) (embed as))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>lderiv as\n                     \\<guillemotleft>Pr\nr\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>lderiv as (Pr r)\\<guillemotright>", "unfolding lderiv.simps ACI_norm.simps"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>r s.\n       \\<guillemotleft>r\\<guillemotright> =\n       \\<guillemotleft>s\\<guillemotright>)\n   (map (\\<lambda>a. lderiv a \\<guillemotleft>r\\<guillemotright>)\n     (embed as))\n   (map (\\<lambda>a. lderiv a r) (embed as))\n\ngoal (1 subgoal):\n 1. Pr \\<guillemotleft>PLUS\n                        (map (\\<lambda>a'.\n                                 lderiv a'\n                                  \\<guillemotleft>r\\<guillemotright>)\n                          (embed as))\\<guillemotright> =\n    Pr \\<guillemotleft>PLUS\n                        (map (\\<lambda>a'. lderiv a' r)\n                          (embed as))\\<guillemotright>", "by (blast intro: ACI_norm_PLUS)"], ["proof (state)\nthis:\n  \\<guillemotleft>lderiv as\n                   \\<guillemotleft>Pr r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv as (Pr r)\\<guillemotright>\n\ngoal (8 subgoals):\n 1. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Zero\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Zero\\<guillemotright>\n 2. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Full\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as Full\\<guillemotright>\n 3. \\<And>as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>One\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as One\\<guillemotright>\n 4. \\<And>x as.\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Atom\n   x\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Atom x)\\<guillemotright>\n 5. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>Times r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (Times r1 r2)\\<guillemotright>\n 6. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>Star\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (Star r)\\<guillemotright>\n 7. \\<And>r as.\n       (\\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderiv as\n                        \\<guillemotleft>rexp.Not\n   r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderiv as (rexp.Not r)\\<guillemotright>\n 8. \\<And>r1 r2 as.\n       \\<lbrakk>\\<And>as.\n                   \\<guillemotleft>lderiv as\n                                    \\<guillemotleft>r1\\<guillemotright>\\<guillemotright> =\n                   \\<guillemotleft>lderiv as r1\\<guillemotright>;\n        \\<And>as.\n           \\<guillemotleft>lderiv as\n                            \\<guillemotleft>r2\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderiv as r2\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>lderiv as\n    \\<guillemotleft>rexp.Inter r1 r2\\<guillemotright>\\<guillemotright> =\n                         \\<guillemotleft>lderiv as\n    (rexp.Inter r1 r2)\\<guillemotright>", "qed (simp_all add: Let_def)"], ["", "corollary lderiv_preserves: \"\\<guillemotleft>r\\<guillemotright> = \\<guillemotleft>s\\<guillemotright> \\<Longrightarrow> \\<guillemotleft>lderiv as r\\<guillemotright> = \\<guillemotleft>lderiv as s\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>r\\<guillemotright> =\n    \\<guillemotleft>s\\<guillemotright> \\<Longrightarrow>\n    \\<guillemotleft>lderiv as r\\<guillemotright> =\n    \\<guillemotleft>lderiv as s\\<guillemotright>", "by (rule box_equals[OF _ ACI_norm_lderiv ACI_norm_lderiv]) (erule arg_cong)"], ["", "lemma lderivs_snoc[simp]: \"lderivs (ws @ [w]) r = (lderiv w (lderivs ws r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lderivs (ws @ [w]) r = lderiv w (lderivs ws r)", "by (induct ws arbitrary: r) auto"], ["", "theorem ACI_norm_lderivs:\n  \"\\<guillemotleft>lderivs ws \\<guillemotleft>r\\<guillemotright>\\<guillemotright> = \\<guillemotleft>lderivs ws r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>lderivs ws\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>lderivs ws r\\<guillemotright>", "proof (induct ws arbitrary: r rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<guillemotleft>lderivs []\n                        \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderivs [] r\\<guillemotright>\n 2. \\<And>x xs r.\n       (\\<And>r.\n           \\<guillemotleft>lderivs xs\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderivs xs r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderivs (xs @ [x])\n                        \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderivs (xs @ [x]) r\\<guillemotright>", "case (snoc w ws)"], ["proof (state)\nthis:\n  \\<guillemotleft>lderivs ws\n                   \\<guillemotleft>?r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderivs ws ?r\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<guillemotleft>lderivs []\n                        \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderivs [] r\\<guillemotright>\n 2. \\<And>x xs r.\n       (\\<And>r.\n           \\<guillemotleft>lderivs xs\n                            \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n           \\<guillemotleft>lderivs xs r\\<guillemotright>) \\<Longrightarrow>\n       \\<guillemotleft>lderivs (xs @ [x])\n                        \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderivs (xs @ [x]) r\\<guillemotright>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<guillemotleft>lderivs ws\n                   \\<guillemotleft>?r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderivs ws ?r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>lderivs (ws @ [w])\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>lderivs (ws @ [w]) r\\<guillemotright>", "using ACI_norm_lderiv[of w \"lderivs ws r\"] ACI_norm_lderiv[of w \"lderivs ws \\<guillemotleft>r\\<guillemotright>\"]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>lderivs ws\n                   \\<guillemotleft>?r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderivs ws ?r\\<guillemotright>\n  \\<guillemotleft>lderiv w\n                   \\<guillemotleft>lderivs ws\n                                    r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv w (lderivs ws r)\\<guillemotright>\n  \\<guillemotleft>lderiv w\n                   \\<guillemotleft>lderivs ws\n                                    \\<guillemotleft>r\\<guillemotright>\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderiv w\n                   (lderivs ws\n                     \\<guillemotleft>r\\<guillemotright>)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>lderivs (ws @ [w])\n                     \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n    \\<guillemotleft>lderivs (ws @ [w]) r\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>lderivs (ws @ [w])\n                   \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n  \\<guillemotleft>lderivs (ws @ [w]) r\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<guillemotleft>lderivs []\n                        \\<guillemotleft>r\\<guillemotright>\\<guillemotright> =\n       \\<guillemotleft>lderivs [] r\\<guillemotright>", "qed simp"], ["", "lemma lderivs_alt: \"\\<guillemotleft>lderivs w r\\<guillemotright> = fold (\\<lambda>a r. \\<guillemotleft>lderiv a r\\<guillemotright>) w \\<guillemotleft>r\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>lderivs w r\\<guillemotright> =\n    fold (\\<lambda>a r. \\<guillemotleft>lderiv a r\\<guillemotright>) w\n     \\<guillemotleft>r\\<guillemotright>", "by (induct w arbitrary: r) (auto simp: ACI_norm_lderiv)"], ["", "lemma finite_fold_lderiv: \"finite {fold (\\<lambda>a r. \\<guillemotleft>lderiv a r\\<guillemotright>) w \\<guillemotleft>s\\<guillemotright> |w. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {fold (\\<lambda>a r. \\<guillemotleft>lderiv a r\\<guillemotright>) w\n       \\<guillemotleft>s\\<guillemotright> |\n      w. True}", "using finite_lderivs"], ["proof (prove)\nusing this:\n  finite {\\<guillemotleft>lderivs xs ?r\\<guillemotright> |xs. True}\n\ngoal (1 subgoal):\n 1. finite\n     {fold (\\<lambda>a r. \\<guillemotleft>lderiv a r\\<guillemotright>) w\n       \\<guillemotleft>s\\<guillemotright> |\n      w. True}", "unfolding lderivs_alt"], ["proof (prove)\nusing this:\n  finite\n   {fold (\\<lambda>a r. \\<guillemotleft>lderiv a r\\<guillemotright>) xs\n     \\<guillemotleft>?r\\<guillemotright> |\n    xs. True}\n\ngoal (1 subgoal):\n 1. finite\n     {fold (\\<lambda>a r. \\<guillemotleft>lderiv a r\\<guillemotright>) w\n       \\<guillemotleft>s\\<guillemotright> |\n      w. True}", "."], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}