{"file_name": "/home/qj213/afp-2021-10-22/thys/Furstenberg_Topology/Furstenberg_Topology.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Furstenberg_Topology", "problem_names": ["lemma arith_prog_0_right [simp]: \"arith_prog a 0 = {a}\"", "lemma arith_prog_Suc_0_right [simp]: \"arith_prog a (Suc 0) = UNIV\"", "lemma in_arith_progI [intro]: \"[x = a] (mod b) \\<Longrightarrow> x \\<in> arith_prog a b\"", "lemma arith_prog_disjoint:\n  assumes \"[a \\<noteq> a'] (mod int b)\" and \"b > 0\"\n  shows   \"arith_prog a b \\<inter> arith_prog a' b = {}\"", "lemma arith_prog_dvd_mono: \"b dvd b' \\<Longrightarrow> arith_prog a b' \\<subseteq> arith_prog a b\"", "lemma bij_betw_arith_prog:\n  assumes \"b > 0\"\n  shows   \"bij_betw (\\<lambda>n. a + int b * n) UNIV (arith_prog a b)\"", "lemma arith_prog_altdef: \"arith_prog a b = range (\\<lambda>n. a + int b * n)\"", "lemma infinite_arith_prog: \"b > 0 \\<Longrightarrow> infinite (arith_prog a b)\"", "lemma open_fbint_imp_infinite:\n  fixes U :: \"fbint set\"\n  assumes \"open U\" and \"U \\<noteq> {}\"\n  shows   \"infinite U\"", "lemma not_open_finite_fbint [simp]:\n  assumes \"finite (U :: fbint set)\" \"U \\<noteq> {}\"\n  shows   \"\\<not>open U\"", "lemma open_arith_prog_fb [intro]:\n  assumes \"b > 0\"\n  shows   \"open (arith_prog_fb a b)\"", "lemma closed_arith_prog_fb [intro]:\n  assumes \"b > 0\"\n  shows   \"closed (arith_prog_fb a b)\"", "theorem \"infinite {p::nat. prime p}\"", "theorem topological_basis_fbint: \"topological_basis {arith_prog_fb a b |a b. b > 0}\"", "lemma open_fbint_altdef: \"open = generate_topology {arith_prog_fb a b |a b. b > 0}\"", "lemma t2_space_t3_spaceI:\n  assumes \"\\<And>(x :: 'a :: t2_space) U. x \\<in> U \\<Longrightarrow> open U \\<Longrightarrow>\n             \\<exists>V. x \\<in> V \\<and> open V \\<and> closure V \\<subseteq> U\"\n  shows   \"OFCLASS('a, t3_space_class)\"", "lemma N_summable: \"summable (\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)\"", "lemma N_sums: \"(\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) sums N n\"", "lemma N_nonneg: \"N n \\<ge> 0\"", "lemma N_uminus [simp]: \"N (-n) = N n\"", "lemma N_minus_commute: \"N (x - y) = N (y - x)\"", "lemma N_zero [simp]: \"N 0 = 0\"", "lemma not_dvd_imp_N_ge:\n  assumes \"\\<not>n dvd a\" \"n > 0\"\n  shows   \"N a \\<ge> 1 / q ^ n\"", "lemma N_lt_imp_dvd:\n  assumes \"N a < 1 / q ^ n\" and \"n > 0\"\n  shows   \"n dvd a\"", "lemma N_pos:\n  assumes \"n \\<noteq> 0\"\n  shows   \"N n > 0\"", "lemma N_zero_iff [simp]: \"N n = 0 \\<longleftrightarrow> n = 0\"", "lemma N_triangle_ineq: \"N (n + m) \\<le> N n + N m\"", "lemma N_1: \"N 1 = 1 / (q * (q - 1))\"", "lemma N_dvd_mono:\n  assumes \"m dvd n\"\n  shows   \"N n \\<le> N m\"", "lemma N_le_N_1: \"N n \\<le> N 1\"", "lemma N_prime:\n  assumes \"prime p\"\n  shows   \"N p = N 1 - 1 / q ^ nat p\"", "lemma N_2: \"N 2 = 1 / (q ^ 2 * (q - 1))\"", "lemma N_less_N_1:\n  assumes \"n \\<noteq> 1\" \"n \\<noteq> -1\"\n  shows   \"N n < N 1\"", "lemma nonprime_imp_N_lt:\n  assumes \"\\<not>prime_elem n\" \"\\<bar>n\\<bar> \\<noteq> 1\" \"n \\<noteq> 0\"\n  shows   \"N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>\"", "lemma prime_iff_N_eq:\n  assumes \"n \\<noteq> 0\"\n  shows   \"prime_elem n \\<longleftrightarrow> N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>\"", "lemma N_fact_le: \"N (fact m) \\<le> 1 / (q - 1) * 1 / q ^ m\"", "lemma N_prime_mono:\n  assumes \"prime p\" \"prime p'\" \"p \\<le> p'\"\n  shows   \"N p \\<le> N p'\"", "lemma N_prime_ge:\n  assumes \"prime p\"\n  shows   \"N p \\<ge> 1 / (q\\<^sup>2 * (q - 1))\"", "lemma N_prime_elem_ge:\n  assumes \"prime_elem p\"\n  shows   \"N p \\<ge> 1 / (q\\<^sup>2 * (q - 1))\"", "lemma dist_self [simp]: \"dist x x = 0\"", "lemma dist_sym [simp]: \"dist x y = dist y x\"", "lemma dist_pos: \"x \\<noteq> y \\<Longrightarrow> dist x y > 0\"", "lemma dist_eq_0_iff [simp]: \"dist x y = 0 \\<longleftrightarrow> x = y\"", "lemma dist_triangle_ineq: \"dist x z \\<le> dist x y + dist y z\"", "theorem dist_induces_open:\n  \"open U \\<longleftrightarrow> (\\<forall>x\\<in>U. \\<exists>e>0. \\<forall>y. dist x y < e \\<longrightarrow> y \\<in> U)\"", "lemma tendsto_fbint_fact: \"(\\<lambda>n. fbint (fact n)) \\<longlonglongrightarrow> fbint 0\""], "translations": [["", "lemma arith_prog_0_right [simp]: \"arith_prog a 0 = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog a 0 = {a}", "by (simp add: arith_prog_def)"], ["", "lemma arith_prog_Suc_0_right [simp]: \"arith_prog a (Suc 0) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog a (Suc 0) = UNIV", "by (auto simp: arith_prog_def)"], ["", "lemma in_arith_progI [intro]: \"[x = a] (mod b) \\<Longrightarrow> x \\<in> arith_prog a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x = a] (mod int b) \\<Longrightarrow> x \\<in> arith_prog a b", "by (auto simp: arith_prog_def)"], ["", "text \\<open>\n  Two arithmetic progressions with the same period and noncongruent starting points are\n  disjoint.\n\\<close>"], ["", "lemma arith_prog_disjoint:\n  assumes \"[a \\<noteq> a'] (mod int b)\" and \"b > 0\"\n  shows   \"arith_prog a b \\<inter> arith_prog a' b = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog a b \\<inter> arith_prog a' b = {}", "using assms"], ["proof (prove)\nusing this:\n  [a \\<noteq> a'] (mod int b)\n  0 < b\n\ngoal (1 subgoal):\n 1. arith_prog a b \\<inter> arith_prog a' b = {}", "by (auto simp: arith_prog_def cong_def)"], ["", "text \\<open>\n  Multiplying the period gives us a subset of the original progression.\n\\<close>"], ["", "lemma arith_prog_dvd_mono: \"b dvd b' \\<Longrightarrow> arith_prog a b' \\<subseteq> arith_prog a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b dvd b' \\<Longrightarrow> arith_prog a b' \\<subseteq> arith_prog a b", "by (auto simp: arith_prog_def cong_dvd_modulus)"], ["", "text \\<open>\n  The following proves the alternative definition mentioned above.\n\\<close>"], ["", "lemma bij_betw_arith_prog:\n  assumes \"b > 0\"\n  shows   \"bij_betw (\\<lambda>n. a + int b * n) UNIV (arith_prog a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>n. a + int b * n) UNIV (arith_prog a b)", "proof (rule bij_betwI[of _ _ _ \"\\<lambda>x. (x - a) div int b\"], goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<lambda>n. a + int b * n) \\<in> UNIV \\<rightarrow> arith_prog a b\n 2. (\\<lambda>x. (x - a) div int b) \\<in> arith_prog a b \\<rightarrow> UNIV\n 3. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow> (a + int b * x - a) div int b = x\n 4. \\<And>y.\n       y \\<in> arith_prog a b \\<Longrightarrow>\n       a + int b * ((y - a) div int b) = y", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. (\\<lambda>n. a + int b * n) \\<in> UNIV \\<rightarrow> arith_prog a b\n 2. (\\<lambda>x. (x - a) div int b) \\<in> arith_prog a b \\<rightarrow> UNIV\n 3. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow> (a + int b * x - a) div int b = x\n 4. \\<And>y.\n       y \\<in> arith_prog a b \\<Longrightarrow>\n       a + int b * ((y - a) div int b) = y", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. a + int b * n) \\<in> UNIV \\<rightarrow> arith_prog a b", "by (auto simp: arith_prog_def cong_add_lcancel_0 cong_mult_self_right mult_of_nat_commute)"], ["proof (state)\nthis:\n  (\\<lambda>n. a + int b * n) \\<in> UNIV \\<rightarrow> arith_prog a b\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. (x - a) div int b) \\<in> arith_prog a b \\<rightarrow> UNIV\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow> (a + int b * x - a) div int b = x\n 3. \\<And>y.\n       y \\<in> arith_prog a b \\<Longrightarrow>\n       a + int b * ((y - a) div int b) = y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x. (x - a) div int b) \\<in> arith_prog a b \\<rightarrow> UNIV\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow> (a + int b * x - a) div int b = x\n 3. \\<And>y.\n       y \\<in> arith_prog a b \\<Longrightarrow>\n       a + int b * ((y - a) div int b) = y", "case 4"], ["proof (state)\nthis:\n  y_ \\<in> arith_prog a b\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. (x - a) div int b) \\<in> arith_prog a b \\<rightarrow> UNIV\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow> (a + int b * x - a) div int b = x\n 3. \\<And>y.\n       y \\<in> arith_prog a b \\<Longrightarrow>\n       a + int b * ((y - a) div int b) = y", "thus ?case"], ["proof (prove)\nusing this:\n  y_ \\<in> arith_prog a b\n\ngoal (1 subgoal):\n 1. a + int b * ((y_ - a) div int b) = y_", "by (auto simp: arith_prog_def cong_iff_lin)"], ["proof (state)\nthis:\n  a + int b * ((y_ - a) div int b) = y_\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. (x - a) div int b) \\<in> arith_prog a b \\<rightarrow> UNIV\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow> (a + int b * x - a) div int b = x", "qed (use \\<open>b > 0\\<close> in \\<open>auto simp: arith_prog_def\\<close>)"], ["", "lemma arith_prog_altdef: \"arith_prog a b = range (\\<lambda>n. a + int b * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog a b = range (\\<lambda>n. a + int b * n)", "proof (cases \"b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow>\n    arith_prog a b = range (\\<lambda>n. a + int b * n)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    arith_prog a b = range (\\<lambda>n. a + int b * n)", "case False"], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow>\n    arith_prog a b = range (\\<lambda>n. a + int b * n)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    arith_prog a b = range (\\<lambda>n. a + int b * n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arith_prog a b = range (\\<lambda>n. a + int b * n)", "using bij_betw_arith_prog[of b]"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n  0 < b \\<Longrightarrow>\n  bij_betw (\\<lambda>n. ?a + int b * n) UNIV (arith_prog ?a b)\n\ngoal (1 subgoal):\n 1. arith_prog a b = range (\\<lambda>n. a + int b * n)", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  arith_prog a b = range (\\<lambda>n. a + int b * n)\n\ngoal (1 subgoal):\n 1. b = 0 \\<Longrightarrow>\n    arith_prog a b = range (\\<lambda>n. a + int b * n)", "qed auto"], ["", "text \\<open>\n  A simple corollary from this is also that any such arithmetic progression is infinite.\n\\<close>"], ["", "lemma infinite_arith_prog: \"b > 0 \\<Longrightarrow> infinite (arith_prog a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow> infinite (arith_prog a b)", "using bij_betw_finite[OF bij_betw_arith_prog[of b]]"], ["proof (prove)\nusing this:\n  0 < b \\<Longrightarrow> finite UNIV = finite (arith_prog ?a1 b)\n\ngoal (1 subgoal):\n 1. 0 < b \\<Longrightarrow> infinite (arith_prog a b)", "by simp"], ["", "subsection \\<open>The Furstenberg topology on \\<open>\\<int>\\<close>\\<close>"], ["", "text \\<open>\n  The typeclass-based topology is somewhat nicer to use in Isabelle/HOL, but the integers, \n  of course, already have a topology associated to them. We therefore need to introduce a type\n  copy of the integers and furnish them with the new topology. We can easily convert between\n  them and the `proper' integers using Lifting and Transfer.\n\\<close>"], ["", "typedef fbint = \"UNIV :: int set\"\n  morphisms int_of_fbint fbint"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_fbint"], ["", "lift_definition arith_prog_fb :: \"int \\<Rightarrow> nat \\<Rightarrow> fbint set\" is \"arith_prog\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instantiation fbint :: topological_space\nbegin"], ["", "text \\<open>\n  Furstenberg defined the topology as the one generated by all arithmetic progressions.\n  We use a slightly more explicit equivalent formulation that exploits the fact that\n  the intersection of two arithmetic progressions is again an arithmetic progression (or empty).\n\\<close>"], ["", "lift_definition open_fbint :: \"fbint set \\<Rightarrow> bool\" is\n  \"\\<lambda>U. (\\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>\n  We now prove that this indeed forms a topology.\n\\<close>"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fbint, topological_space_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. open UNIV\n 2. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 3. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "show \"open (UNIV :: fbint set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open UNIV", "by transfer auto"], ["proof (state)\nthis:\n  open UNIV\n\ngoal (2 subgoals):\n 1. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 2. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 2. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "fix U V :: \"fbint set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 2. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "assume \"open U\" and \"open V\""], ["proof (state)\nthis:\n  open U\n  open V\n\ngoal (2 subgoals):\n 1. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 2. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "show \"open (U \\<inter> V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (U \\<inter> V)", "proof (use \\<open>open U\\<close> \\<open>open V\\<close> in transfer, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>U V x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        \\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V;\n        x \\<in> U; x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0.\n                            arith_prog x b \\<subseteq> U \\<inter> V", "fix U V :: \"int set\" and x :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>U V x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        \\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V;\n        x \\<in> U; x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0.\n                            arith_prog x b \\<subseteq> U \\<inter> V", "assume U: \"\\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\" and V: \"\\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n  \\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>U V x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        \\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V;\n        x \\<in> U; x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0.\n                            arith_prog x b \\<subseteq> U \\<inter> V", "assume x: \"x \\<in> U\" \"x \\<in> V\""], ["proof (state)\nthis:\n  x \\<in> U\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>U V x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        \\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V;\n        x \\<in> U; x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0.\n                            arith_prog x b \\<subseteq> U \\<inter> V", "from U x"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n  x \\<in> U\n  x \\<in> V", "obtain b1 where b1: \"b1 > 0\" \"arith_prog x b1 \\<subseteq> U\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n  x \\<in> U\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>b1.\n        \\<lbrakk>0 < b1; arith_prog x b1 \\<subseteq> U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < b1\n  arith_prog x b1 \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<And>U V x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        \\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V;\n        x \\<in> U; x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0.\n                            arith_prog x b \\<subseteq> U \\<inter> V", "from V x"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V\n  x \\<in> U\n  x \\<in> V", "obtain b2 where b2: \"b2 > 0\" \"arith_prog x b2 \\<subseteq> V\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V\n  x \\<in> U\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>b2.\n        \\<lbrakk>0 < b2; arith_prog x b2 \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < b2\n  arith_prog x b2 \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>U V x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        \\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V;\n        x \\<in> U; x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0.\n                            arith_prog x b \\<subseteq> U \\<inter> V", "from b1 b2"], ["proof (chain)\npicking this:\n  0 < b1\n  arith_prog x b1 \\<subseteq> U\n  0 < b2\n  arith_prog x b2 \\<subseteq> V", "have \"lcm b1 b2 > 0\" \"arith_prog x (lcm b1 b2) \\<subseteq> U \\<inter> V\""], ["proof (prove)\nusing this:\n  0 < b1\n  arith_prog x b1 \\<subseteq> U\n  0 < b2\n  arith_prog x b2 \\<subseteq> V\n\ngoal (1 subgoal):\n 1. 0 < lcm b1 b2 &&& arith_prog x (lcm b1 b2) \\<subseteq> U \\<inter> V", "using arith_prog_dvd_mono[of b1 \"lcm b1 b2\" x] arith_prog_dvd_mono[of b2 \"lcm b1 b2\" x]"], ["proof (prove)\nusing this:\n  0 < b1\n  arith_prog x b1 \\<subseteq> U\n  0 < b2\n  arith_prog x b2 \\<subseteq> V\n  b1 dvd lcm b1 b2 \\<Longrightarrow>\n  arith_prog x (lcm b1 b2) \\<subseteq> arith_prog x b1\n  b2 dvd lcm b1 b2 \\<Longrightarrow>\n  arith_prog x (lcm b1 b2) \\<subseteq> arith_prog x b2\n\ngoal (1 subgoal):\n 1. 0 < lcm b1 b2 &&& arith_prog x (lcm b1 b2) \\<subseteq> U \\<inter> V", "by (auto simp: lcm_pos_nat)"], ["proof (state)\nthis:\n  0 < lcm b1 b2\n  arith_prog x (lcm b1 b2) \\<subseteq> U \\<inter> V\n\ngoal (1 subgoal):\n 1. \\<And>U V x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        \\<forall>x\\<in>V. \\<exists>b>0. arith_prog x b \\<subseteq> V;\n        x \\<in> U; x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0.\n                            arith_prog x b \\<subseteq> U \\<inter> V", "thus \"\\<exists>b>0. arith_prog x b \\<subseteq> U \\<inter> V\""], ["proof (prove)\nusing this:\n  0 < lcm b1 b2\n  arith_prog x (lcm b1 b2) \\<subseteq> U \\<inter> V\n\ngoal (1 subgoal):\n 1. \\<exists>b>0. arith_prog x b \\<subseteq> U \\<inter> V", "by blast"], ["proof (state)\nthis:\n  \\<exists>b>0. arith_prog x b \\<subseteq> U \\<inter> V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  open (U \\<inter> V)\n\ngoal (1 subgoal):\n 1. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "fix F :: \"fbint set set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "assume *: \"\\<forall>U\\<in>F. open U\""], ["proof (state)\nthis:\n  \\<forall>U\\<in>F. open U\n\ngoal (1 subgoal):\n 1. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "show \"open (\\<Union>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (\\<Union> F)", "proof (use * in transfer, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F x X.\n       \\<lbrakk>\\<forall>U\\<in>F.\n                   \\<forall>x\\<in>U.\n                      \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> X; X \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> \\<Union> F", "fix F :: \"int set set\" and U :: \"int set\" and x :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F x X.\n       \\<lbrakk>\\<forall>U\\<in>F.\n                   \\<forall>x\\<in>U.\n                      \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> X; X \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> \\<Union> F", "assume F: \"\\<forall>U\\<in>F. \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\""], ["proof (state)\nthis:\n  \\<forall>U\\<in>F.\n     \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<And>F x X.\n       \\<lbrakk>\\<forall>U\\<in>F.\n                   \\<forall>x\\<in>U.\n                      \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> X; X \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> \\<Union> F", "assume \"x \\<in> U\" \"U \\<in> F\""], ["proof (state)\nthis:\n  x \\<in> U\n  U \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>F x X.\n       \\<lbrakk>\\<forall>U\\<in>F.\n                   \\<forall>x\\<in>U.\n                      \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> X; X \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> \\<Union> F", "with F"], ["proof (chain)\npicking this:\n  \\<forall>U\\<in>F.\n     \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n  x \\<in> U\n  U \\<in> F", "obtain b where b: \"b > 0\" \"arith_prog x b \\<subseteq> U\""], ["proof (prove)\nusing this:\n  \\<forall>U\\<in>F.\n     \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n  x \\<in> U\n  U \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>0 < b; arith_prog x b \\<subseteq> U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 < b\n  arith_prog x b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<And>F x X.\n       \\<lbrakk>\\<forall>U\\<in>F.\n                   \\<forall>x\\<in>U.\n                      \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> X; X \\<in> F\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> \\<Union> F", "with \\<open>U \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  U \\<in> F\n  0 < b\n  arith_prog x b \\<subseteq> U", "show \"\\<exists>b>0. arith_prog x b \\<subseteq> \\<Union>F\""], ["proof (prove)\nusing this:\n  U \\<in> F\n  0 < b\n  arith_prog x b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<exists>b>0. arith_prog x b \\<subseteq> \\<Union> F", "by blast"], ["proof (state)\nthis:\n  \\<exists>b>0. arith_prog x b \\<subseteq> \\<Union> F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  open (\\<Union> F)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n  Since any non-empty open set contains an arithmetic progression and arithmetic progressions\n  are infinite, we obtain that all nonempty open sets are infinite.\n\\<close>"], ["", "lemma open_fbint_imp_infinite:\n  fixes U :: \"fbint set\"\n  assumes \"open U\" and \"U \\<noteq> {}\"\n  shows   \"infinite U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite U", "using assms"], ["proof (prove)\nusing this:\n  open U\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. infinite U", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>U.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        U \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> infinite U", "fix U :: \"int set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>U.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        U \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> infinite U", "assume *: \"\\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\" and \"U \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>U.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        U \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> infinite U", "from \\<open>U \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  U \\<noteq> {}", "obtain x where \"x \\<in> U\""], ["proof (prove)\nusing this:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>U.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        U \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> infinite U", "with *"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n  x \\<in> U", "obtain b where b: \"b > 0\" \"arith_prog x b \\<subseteq> U\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>0 < b; arith_prog x b \\<subseteq> U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < b\n  arith_prog x b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<And>U.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        U \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> infinite U", "from b"], ["proof (chain)\npicking this:\n  0 < b\n  arith_prog x b \\<subseteq> U", "have \"infinite (arith_prog x b)\""], ["proof (prove)\nusing this:\n  0 < b\n  arith_prog x b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. infinite (arith_prog x b)", "using infinite_arith_prog"], ["proof (prove)\nusing this:\n  0 < b\n  arith_prog x b \\<subseteq> U\n  0 < ?b \\<Longrightarrow> infinite (arith_prog ?a ?b)\n\ngoal (1 subgoal):\n 1. infinite (arith_prog x b)", "by blast"], ["proof (state)\nthis:\n  infinite (arith_prog x b)\n\ngoal (1 subgoal):\n 1. \\<And>U.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        U \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> infinite U", "with b"], ["proof (chain)\npicking this:\n  0 < b\n  arith_prog x b \\<subseteq> U\n  infinite (arith_prog x b)", "show \"infinite U\""], ["proof (prove)\nusing this:\n  0 < b\n  arith_prog x b \\<subseteq> U\n  infinite (arith_prog x b)\n\ngoal (1 subgoal):\n 1. infinite U", "using finite_subset"], ["proof (prove)\nusing this:\n  0 < b\n  arith_prog x b \\<subseteq> U\n  infinite (arith_prog x b)\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. infinite U", "by blast"], ["proof (state)\nthis:\n  infinite U\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_open_finite_fbint [simp]:\n  assumes \"finite (U :: fbint set)\" \"U \\<noteq> {}\"\n  shows   \"\\<not>open U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> open U", "using open_fbint_imp_infinite assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>open ?U; ?U \\<noteq> {}\\<rbrakk> \\<Longrightarrow> infinite ?U\n  finite U\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> open U", "by blast"], ["", "text \\<open>\n  More or less by definition, any arithmetic progression is open.\n\\<close>"], ["", "lemma open_arith_prog_fb [intro]:\n  assumes \"b > 0\"\n  shows   \"open (arith_prog_fb a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (arith_prog_fb a b)", "using assms"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. open (arith_prog_fb a b)", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a.\n       0 < b \\<Longrightarrow>\n       \\<forall>x\\<in>arith_prog a b.\n          \\<exists>ba>0. arith_prog x ba \\<subseteq> arith_prog a b", "fix a :: int and b :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a.\n       0 < b \\<Longrightarrow>\n       \\<forall>x\\<in>arith_prog a b.\n          \\<exists>ba>0. arith_prog x ba \\<subseteq> arith_prog a b", "assume \"b > 0\""], ["proof (state)\nthis:\n  0 < b\n\ngoal (1 subgoal):\n 1. \\<And>b a.\n       0 < b \\<Longrightarrow>\n       \\<forall>x\\<in>arith_prog a b.\n          \\<exists>ba>0. arith_prog x ba \\<subseteq> arith_prog a b", "show \"\\<forall>x\\<in>arith_prog a b. \\<exists>b'>0. arith_prog x b' \\<subseteq> arith_prog a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>arith_prog a b.\n       \\<exists>b'>0. arith_prog x b' \\<subseteq> arith_prog a b", "proof (intro ballI exI[of _ b] conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> arith_prog a b \\<Longrightarrow> 0 < b\n 2. \\<And>x.\n       x \\<in> arith_prog a b \\<Longrightarrow>\n       arith_prog x b \\<subseteq> arith_prog a b", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> arith_prog a b \\<Longrightarrow> 0 < b\n 2. \\<And>x.\n       x \\<in> arith_prog a b \\<Longrightarrow>\n       arith_prog x b \\<subseteq> arith_prog a b", "assume \"x \\<in> arith_prog a b\""], ["proof (state)\nthis:\n  x \\<in> arith_prog a b\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> arith_prog a b \\<Longrightarrow> 0 < b\n 2. \\<And>x.\n       x \\<in> arith_prog a b \\<Longrightarrow>\n       arith_prog x b \\<subseteq> arith_prog a b", "thus \"arith_prog x b \\<subseteq> arith_prog a b\""], ["proof (prove)\nusing this:\n  x \\<in> arith_prog a b\n\ngoal (1 subgoal):\n 1. arith_prog x b \\<subseteq> arith_prog a b", "using cong_trans"], ["proof (prove)\nusing this:\n  x \\<in> arith_prog a b\n  \\<lbrakk>[?b = ?c] (mod ?a); [?c = ?d] (mod ?a)\\<rbrakk>\n  \\<Longrightarrow> [?b = ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. arith_prog x b \\<subseteq> arith_prog a b", "by (auto simp: arith_prog_def )"], ["proof (state)\nthis:\n  arith_prog x b \\<subseteq> arith_prog a b\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> arith_prog a b \\<Longrightarrow> 0 < b", "qed (use \\<open>b > 0\\<close> in auto)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>arith_prog a b.\n     \\<exists>b'>0. arith_prog x b' \\<subseteq> arith_prog a b\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Slightly less obviously, any arithmetic progression is also closed.\n  This can be seen by realising that for a period \\<open>b\\<close>, we can partition the integers\n  into \\<open>b\\<close> congruence classes and then the complement of each congruence class is the \n  union of the other \\<open>b - 1\\<close> classes, and unions of open sets are open.\n\\<close>"], ["", "lemma closed_arith_prog_fb [intro]:\n  assumes \"b > 0\"\n  shows   \"closed (arith_prog_fb a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (arith_prog_fb a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed (arith_prog_fb a b)", "have \"open (-arith_prog_fb a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (- arith_prog_fb a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. open (- arith_prog_fb a b)", "have \"-arith_prog_fb a b = (\\<Union>i\\<in>{1..<b}. arith_prog_fb (a+i) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - arith_prog_fb a b =\n    (\\<Union>i\\<in>{1..<b}. arith_prog_fb (a + int i) b)", "proof (transfer fixing: b)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       - arith_prog a b = (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "fix a :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       - arith_prog a b = (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "have disjoint: \"x \\<notin> arith_prog a b\" if \"x \\<in> arith_prog (a + int i) b\" \"i \\<in> {1..<b}\" for x i"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> arith_prog a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> arith_prog a b", "have \"[a \\<noteq> a + int i] (mod int b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a \\<noteq> a + int i] (mod int b)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. [a = a + int i] (mod int b) \\<Longrightarrow> False", "assume \"[a = a + int i] (mod int b)\""], ["proof (state)\nthis:\n  [a = a + int i] (mod int b)\n\ngoal (1 subgoal):\n 1. [a = a + int i] (mod int b) \\<Longrightarrow> False", "hence \"[a + 0 = a + int i] (mod int b)\""], ["proof (prove)\nusing this:\n  [a = a + int i] (mod int b)\n\ngoal (1 subgoal):\n 1. [a + 0 = a + int i] (mod int b)", "by simp"], ["proof (state)\nthis:\n  [a + 0 = a + int i] (mod int b)\n\ngoal (1 subgoal):\n 1. [a = a + int i] (mod int b) \\<Longrightarrow> False", "hence \"[0 = int i] (mod int b)\""], ["proof (prove)\nusing this:\n  [a + 0 = a + int i] (mod int b)\n\ngoal (1 subgoal):\n 1. [0 = int i] (mod int b)", "by (subst (asm) cong_add_lcancel) auto"], ["proof (state)\nthis:\n  [0 = int i] (mod int b)\n\ngoal (1 subgoal):\n 1. [a = a + int i] (mod int b) \\<Longrightarrow> False", "with that"], ["proof (chain)\npicking this:\n  x \\<in> arith_prog (a + int i) b\n  i \\<in> {1..<b}\n  [0 = int i] (mod int b)", "show False"], ["proof (prove)\nusing this:\n  x \\<in> arith_prog (a + int i) b\n  i \\<in> {1..<b}\n  [0 = int i] (mod int b)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: cong_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [a \\<noteq> a + int i] (mod int b)\n\ngoal (1 subgoal):\n 1. x \\<notin> arith_prog a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  [a \\<noteq> a + int i] (mod int b)\n\ngoal (1 subgoal):\n 1. x \\<notin> arith_prog a b", "using arith_prog_disjoint[of a \"a + int i\" b] \\<open>b > 0\\<close> that"], ["proof (prove)\nusing this:\n  [a \\<noteq> a + int i] (mod int b)\n  \\<lbrakk>[a \\<noteq> a + int i] (mod int b); 0 < b\\<rbrakk>\n  \\<Longrightarrow> arith_prog a b \\<inter> arith_prog (a + int i) b = {}\n  0 < b\n  x \\<in> arith_prog (a + int i) b\n  i \\<in> {1..<b}\n\ngoal (1 subgoal):\n 1. x \\<notin> arith_prog a b", "by auto"], ["proof (state)\nthis:\n  x \\<notin> arith_prog a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> arith_prog (a + int ?i) b; ?i \\<in> {1..<b}\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> arith_prog a b\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       - arith_prog a b = (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "have covering: \"x \\<in> arith_prog a b \\<or> x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "define i where \"i = nat ((x - a) mod (int b))\""], ["proof (state)\nthis:\n  i = nat ((x - a) mod int b)\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "have \"[a + int i = a + (x - a) mod int b] (mod int b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a + int i = a + (x - a) mod int b] (mod int b)", "unfolding i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [a + int (nat ((x - a) mod int b)) = a + (x - a) mod int b] (mod int b)", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. [a + int (nat ((x - a) mod int b)) = a + (x - a) mod int b] (mod int b)", "by simp"], ["proof (state)\nthis:\n  [a + int i = a + (x - a) mod int b] (mod int b)\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "also"], ["proof (state)\nthis:\n  [a + int i = a + (x - a) mod int b] (mod int b)\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "have \"[a + (x - a) mod int b = a + (x - a)] (mod int b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a + (x - a) mod int b = a + (x - a)] (mod int b)", "by (intro cong_add) auto"], ["proof (state)\nthis:\n  [a + (x - a) mod int b = a + (x - a)] (mod int b)\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "finally"], ["proof (chain)\npicking this:\n  [a + int i = a + (x - a)] (mod int b)", "have \"[x = a + int i] (mod int b)\""], ["proof (prove)\nusing this:\n  [a + int i = a + (x - a)] (mod int b)\n\ngoal (1 subgoal):\n 1. [x = a + int i] (mod int b)", "by (simp add: cong_sym_eq)"], ["proof (state)\nthis:\n  [x = a + int i] (mod int b)\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "hence \"x \\<in> arith_prog (a + int i) b\""], ["proof (prove)\nusing this:\n  [x = a + int i] (mod int b)\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog (a + int i) b", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  [x = a + int i] (mod int b)\n  0 < b\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog (a + int i) b", "by (auto simp: arith_prog_def)"], ["proof (state)\nthis:\n  x \\<in> arith_prog (a + int i) b\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "moreover"], ["proof (state)\nthis:\n  x \\<in> arith_prog (a + int i) b\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "have \"i < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < b", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. i < b", "by (auto simp: i_def nat_less_iff)"], ["proof (state)\nthis:\n  i < b\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> arith_prog (a + int i) b\n  i < b", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> arith_prog (a + int i) b\n  i < b\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> arith_prog (a + int i) b\n  i < b\n  0 < b\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog a b \\<or>\n    x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "by (cases \"i = 0\") auto"], ["proof (state)\nthis:\n  x \\<in> arith_prog a b \\<or>\n  x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> arith_prog a b \\<or>\n  ?x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       - arith_prog a b = (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "from disjoint and covering"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> arith_prog (a + int ?i) b; ?i \\<in> {1..<b}\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> arith_prog a b\n  ?x \\<in> arith_prog a b \\<or>\n  ?x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "show \"- arith_prog a b = (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> arith_prog (a + int ?i) b; ?i \\<in> {1..<b}\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> arith_prog a b\n  ?x \\<in> arith_prog a b \\<or>\n  ?x \\<in> (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)\n\ngoal (1 subgoal):\n 1. - arith_prog a b = (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)", "by blast"], ["proof (state)\nthis:\n  - arith_prog a b = (\\<Union>i\\<in>{1..<b}. arith_prog (a + int i) b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - arith_prog_fb a b = (\\<Union>i\\<in>{1..<b}. arith_prog_fb (a + int i) b)\n\ngoal (1 subgoal):\n 1. open (- arith_prog_fb a b)", "also"], ["proof (state)\nthis:\n  - arith_prog_fb a b = (\\<Union>i\\<in>{1..<b}. arith_prog_fb (a + int i) b)\n\ngoal (1 subgoal):\n 1. open (- arith_prog_fb a b)", "from \\<open>b > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < b", "have \"open \\<dots>\""], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. open (\\<Union>i\\<in>{1..<b}. arith_prog_fb (a + int i) b)", "by auto"], ["proof (state)\nthis:\n  open (\\<Union>i\\<in>{1..<b}. arith_prog_fb (a + int i) b)\n\ngoal (1 subgoal):\n 1. open (- arith_prog_fb a b)", "finally"], ["proof (chain)\npicking this:\n  open (- arith_prog_fb a b)", "show ?thesis"], ["proof (prove)\nusing this:\n  open (- arith_prog_fb a b)\n\ngoal (1 subgoal):\n 1. open (- arith_prog_fb a b)", "."], ["proof (state)\nthis:\n  open (- arith_prog_fb a b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  open (- arith_prog_fb a b)\n\ngoal (1 subgoal):\n 1. closed (arith_prog_fb a b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  open (- arith_prog_fb a b)\n\ngoal (1 subgoal):\n 1. closed (arith_prog_fb a b)", "by (simp add: closed_def)"], ["proof (state)\nthis:\n  closed (arith_prog_fb a b)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The infinitude of primes\\<close>"], ["", "text \\<open>\n  The infinite of the primes now follows quite obviously: The multiples of any prime form a\n  closed set, so if there were only finitely many primes, the union of all of these would also\n  be open. However, since any number other than \\<open>\\<plusminus>1\\<close> has a prime divisor, the union of all these\n  sets is simply \\<open>\\<int>\\<setminus>{\\<plusminus>1}\\<close>, which is obviously \\<^emph>\\<open>not\\<close> closed since the finite set \\<open>{\\<plusminus>1}\\<close> is not\n  open.\n\\<close>"], ["", "theorem \"infinite {p::nat. prime p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {p. prime p}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {p. prime p} \\<Longrightarrow> False", "assume fin: \"finite {p::nat. prime p}\""], ["proof (state)\nthis:\n  finite {p. prime p}\n\ngoal (1 subgoal):\n 1. finite {p. prime p} \\<Longrightarrow> False", "define A where \"A = (\\<Union>p\\<in>{p::nat. prime p}. arith_prog_fb 0 p)\""], ["proof (state)\nthis:\n  A = \\<Union> (arith_prog_fb 0 ` {p. prime p})\n\ngoal (1 subgoal):\n 1. finite {p. prime p} \\<Longrightarrow> False", "have \"closed A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (\\<Union> (arith_prog_fb 0 ` Collect prime))", "using fin"], ["proof (prove)\nusing this:\n  finite {p. prime p}\n\ngoal (1 subgoal):\n 1. closed (\\<Union> (arith_prog_fb 0 ` Collect prime))", "by (intro closed_Union) (auto simp: prime_gt_0_nat)"], ["proof (state)\nthis:\n  closed A\n\ngoal (1 subgoal):\n 1. finite {p. prime p} \\<Longrightarrow> False", "hence \"open (-A)\""], ["proof (prove)\nusing this:\n  closed A\n\ngoal (1 subgoal):\n 1. open (- A)", "by (simp add: closed_def)"], ["proof (state)\nthis:\n  open (- A)\n\ngoal (1 subgoal):\n 1. finite {p. prime p} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  open (- A)\n\ngoal (1 subgoal):\n 1. finite {p. prime p} \\<Longrightarrow> False", "have \"A = -{fbint 1, fbint (-1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = - {fbint 1, fbint (- 1)}", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (arith_prog_fb 0 ` Collect prime) = - {fbint 1, fbint (- 1)}", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (arith_prog 0 ` Collect prime) = - {1, - 1}", "show \"(\\<Union>p\\<in>{p::nat. prime p}. arith_prog 0 p) = - {1, - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (arith_prog 0 ` {p. prime p}) = - {1, - 1}", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Union> (arith_prog 0 ` {p. prime p}) \\<Longrightarrow>\n       x \\<in> - {1, - 1}\n 2. \\<And>x.\n       x \\<in> - {1, - 1} \\<Longrightarrow>\n       x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "fix x :: int"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Union> (arith_prog 0 ` {p. prime p}) \\<Longrightarrow>\n       x \\<in> - {1, - 1}\n 2. \\<And>x.\n       x \\<in> - {1, - 1} \\<Longrightarrow>\n       x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "assume x: \"x \\<in> -{1, -1}\""], ["proof (state)\nthis:\n  x \\<in> - {1, - 1}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Union> (arith_prog 0 ` {p. prime p}) \\<Longrightarrow>\n       x \\<in> - {1, - 1}\n 2. \\<And>x.\n       x \\<in> - {1, - 1} \\<Longrightarrow>\n       x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "hence \"\\<bar>x\\<bar> \\<noteq> 1\""], ["proof (prove)\nusing this:\n  x \\<in> - {1, - 1}\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<noteq> 1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<Union> (arith_prog 0 ` {p. prime p}) \\<Longrightarrow>\n       x \\<in> - {1, - 1}\n 2. \\<And>x.\n       x \\<in> - {1, - 1} \\<Longrightarrow>\n       x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "show \"x \\<in> (\\<Union>p\\<in>{p::nat. prime p}. arith_prog 0 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "by (auto simp: A_def intro!: exI[of _ 2])"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "case [simp]: False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "obtain p where p: \"prime p\" \"p dvd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_divisor_exists[of x] and \\<open>\\<bar>x\\<bar> \\<noteq> 1\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> 0; \\<not> is_unit x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. b dvd x \\<and> prime b\n  \\<bar>x\\<bar> \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prime p\n  p dvd x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "hence \"x \\<in> arith_prog 0 (nat p)\""], ["proof (prove)\nusing this:\n  prime p\n  p dvd x\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog 0 (nat p)", "using prime_gt_0_int[of p]"], ["proof (prove)\nusing this:\n  prime p\n  p dvd x\n  prime p \\<Longrightarrow> 0 < p\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog 0 (nat p)", "by (auto simp: arith_prog_def cong_0_iff)"], ["proof (state)\nthis:\n  x \\<in> arith_prog 0 (nat p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> arith_prog 0 (nat p)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "using p"], ["proof (prove)\nusing this:\n  x \\<in> arith_prog 0 (nat p)\n  prime p\n  p dvd x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})", "by (auto simp: A_def intro!: exI[of _ \"nat p\"])"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (arith_prog 0 ` {p. prime p})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (arith_prog 0 ` {p. prime p}) \\<Longrightarrow>\n       x \\<in> - {1, - 1}", "qed (auto simp: A_def arith_prog_def cong_0_iff)"], ["proof (state)\nthis:\n  \\<Union> (arith_prog 0 ` {p. prime p}) = - {1, - 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A = - {fbint 1, fbint (- 1)}\n\ngoal (1 subgoal):\n 1. finite {p. prime p} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  A = - {fbint 1, fbint (- 1)}\n\ngoal (1 subgoal):\n 1. finite {p. prime p} \\<Longrightarrow> False", "have \"-(-{fbint 1, fbint (-1)}) = {fbint 1, fbint (-1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- {fbint 1, fbint (- 1)}) = {fbint 1, fbint (- 1)}", "by simp"], ["proof (state)\nthis:\n  - (- {fbint 1, fbint (- 1)}) = {fbint 1, fbint (- 1)}\n\ngoal (1 subgoal):\n 1. finite {p. prime p} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  open {fbint 1, fbint (- 1)}", "have \"open {fbint 1, fbint (-1)}\""], ["proof (prove)\nusing this:\n  open {fbint 1, fbint (- 1)}\n\ngoal (1 subgoal):\n 1. open {fbint 1, fbint (- 1)}", "."], ["proof (state)\nthis:\n  open {fbint 1, fbint (- 1)}\n\ngoal (1 subgoal):\n 1. finite {p. prime p} \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  open {fbint 1, fbint (- 1)}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Additional topological properties\\<close>"], ["", "text \\<open>\n  Just for fun, let us also show a few more properties of Furstenberg's topology.\n  First, we show the equivalence to the above to Furstenberg's original definition\n  (the topology generated by all arithmetic progressions).\n\\<close>"], ["", "theorem topological_basis_fbint: \"topological_basis {arith_prog_fb a b |a b. b > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. topological_basis {arith_prog_fb a b |a b. 0 < b}", "unfolding topological_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball {arith_prog_fb a b |a b. 0 < b} open \\<and>\n    (\\<forall>x.\n        open x \\<longrightarrow>\n        (\\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n            \\<Union> B' = x))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x a b. 0 < b \\<Longrightarrow> open (arith_prog_fb a b)\n 2. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "fix a :: int and b :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x a b. 0 < b \\<Longrightarrow> open (arith_prog_fb a b)\n 2. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "assume \"b > 0\""], ["proof (state)\nthis:\n  0 < b\n\ngoal (2 subgoals):\n 1. \\<And>x a b. 0 < b \\<Longrightarrow> open (arith_prog_fb a b)\n 2. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "thus \"open (arith_prog_fb a b)\""], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. open (arith_prog_fb a b)", "by auto"], ["proof (state)\nthis:\n  open (arith_prog_fb a b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "fix U :: \"fbint set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "assume \"open U\""], ["proof (state)\nthis:\n  open U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "hence \"\\<forall>x\\<in>U. \\<exists>b. b > 0 \\<and> arith_prog_fb (int_of_fbint x) b \\<subseteq> U\""], ["proof (prove)\nusing this:\n  open U\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>U.\n       \\<exists>b>0. arith_prog_fb (int_of_fbint x) b \\<subseteq> U", "by transfer"], ["proof (state)\nthis:\n  \\<forall>x\\<in>U.\n     \\<exists>b>0. arith_prog_fb (int_of_fbint x) b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "hence \"\\<exists>f. \\<forall>x\\<in>U. f x > 0 \\<and> arith_prog_fb (int_of_fbint x) (f x) \\<subseteq> U\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>U.\n     \\<exists>b>0. arith_prog_fb (int_of_fbint x) b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>x\\<in>U.\n          0 < f x \\<and> arith_prog_fb (int_of_fbint x) (f x) \\<subseteq> U", "by (subst (asm) bchoice_iff)"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<forall>x\\<in>U.\n        0 < f x \\<and> arith_prog_fb (int_of_fbint x) (f x) \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x\\<in>U.\n        0 < f x \\<and> arith_prog_fb (int_of_fbint x) (f x) \\<subseteq> U", "obtain f where f: \"\\<forall>x\\<in>U. f x > 0 \\<and> arith_prog_fb (int_of_fbint x) (f x) \\<subseteq> U\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x\\<in>U.\n        0 < f x \\<and> arith_prog_fb (int_of_fbint x) (f x) \\<subseteq> U\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>x\\<in>U.\n           0 < f x \\<and>\n           arith_prog_fb (int_of_fbint x) (f x)\n           \\<subseteq> U \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>x\\<in>U.\n     0 < f x \\<and> arith_prog_fb (int_of_fbint x) (f x) \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "define B where \"B = (\\<lambda>x. arith_prog_fb (int_of_fbint x) (f x)) ` U\""], ["proof (state)\nthis:\n  B = (\\<lambda>x. arith_prog_fb (int_of_fbint x) (f x)) ` U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "have \"B \\<subseteq> {arith_prog_fb a b |a b. b > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> {arith_prog_fb a b |a b. 0 < b}", "using f"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>U.\n     0 < f x \\<and> arith_prog_fb (int_of_fbint x) (f x) \\<subseteq> U\n\ngoal (1 subgoal):\n 1. B \\<subseteq> {arith_prog_fb a b |a b. 0 < b}", "by (auto simp: B_def)"], ["proof (state)\nthis:\n  B \\<subseteq> {arith_prog_fb a b |a b. 0 < b}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "moreover"], ["proof (state)\nthis:\n  B \\<subseteq> {arith_prog_fb a b |a b. 0 < b}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "have \"\\<Union>B = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> B = U", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>x \\<in> X; X \\<in> B\\<rbrakk> \\<Longrightarrow> x \\<in> U\n 2. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> \\<Union> B", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>x \\<in> X; X \\<in> B\\<rbrakk> \\<Longrightarrow> x \\<in> U\n 2. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> \\<Union> B", "assume \"x \\<in> U\""], ["proof (state)\nthis:\n  x \\<in> U\n\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>x \\<in> X; X \\<in> B\\<rbrakk> \\<Longrightarrow> x \\<in> U\n 2. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> \\<Union> B", "hence \"x \\<in> arith_prog_fb (int_of_fbint x) (f x)\""], ["proof (prove)\nusing this:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog_fb (int_of_fbint x) (f x)", "using f"], ["proof (prove)\nusing this:\n  x \\<in> U\n  \\<forall>x\\<in>U.\n     0 < f x \\<and> arith_prog_fb (int_of_fbint x) (f x) \\<subseteq> U\n\ngoal (1 subgoal):\n 1. x \\<in> arith_prog_fb (int_of_fbint x) (f x)", "by transfer auto"], ["proof (state)\nthis:\n  x \\<in> arith_prog_fb (int_of_fbint x) (f x)\n\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>x \\<in> X; X \\<in> B\\<rbrakk> \\<Longrightarrow> x \\<in> U\n 2. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> \\<Union> B", "with \\<open>x \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> U\n  x \\<in> arith_prog_fb (int_of_fbint x) (f x)", "show \"x \\<in> \\<Union>B\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  x \\<in> arith_prog_fb (int_of_fbint x) (f x)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> B", "by (auto simp: B_def)"], ["proof (state)\nthis:\n  x \\<in> \\<Union> B\n\ngoal (1 subgoal):\n 1. \\<And>x X.\n       \\<lbrakk>x \\<in> X; X \\<in> B\\<rbrakk> \\<Longrightarrow> x \\<in> U", "qed (use f in \\<open>auto simp: B_def\\<close>)"], ["proof (state)\nthis:\n  \\<Union> B = U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       open x \\<Longrightarrow>\n       \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}.\n          \\<Union> B' = x", "ultimately"], ["proof (chain)\npicking this:\n  B \\<subseteq> {arith_prog_fb a b |a b. 0 < b}\n  \\<Union> B = U", "show \"\\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}. \\<Union> B' = U\""], ["proof (prove)\nusing this:\n  B \\<subseteq> {arith_prog_fb a b |a b. 0 < b}\n  \\<Union> B = U\n\ngoal (1 subgoal):\n 1. \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}. \\<Union> B' = U", "by auto"], ["proof (state)\nthis:\n  \\<exists>B'\\<subseteq>{arith_prog_fb a b |a b. 0 < b}. \\<Union> B' = U\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma open_fbint_altdef: \"open = generate_topology {arith_prog_fb a b |a b. b > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open = generate_topology {arith_prog_fb a b |a b. 0 < b}", "using topological_basis_imp_subbasis[OF topological_basis_fbint]"], ["proof (prove)\nusing this:\n  open = generate_topology {arith_prog_fb a b |a b. 0 < b}\n\ngoal (1 subgoal):\n 1. open = generate_topology {arith_prog_fb a b |a b. 0 < b}", "."], ["", "text \\<open>\n  From this, we can immediately see that it is second countable:\n\\<close>"], ["", "instance fbint :: second_countable_topology"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fbint, second_countable_topology_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "have \"countable ((\\<lambda>(a,b). arith_prog_fb a b) ` (UNIV \\<times> {b. b > 0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable\n     ((\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}))", "by (intro countable_image) auto"], ["proof (state)\nthis:\n  countable\n   ((\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}))\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "also"], ["proof (state)\nthis:\n  countable\n   ((\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}))\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "have \"\\<dots> = {arith_prog_fb a b |a b. b > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}) =\n    {arith_prog_fb a b |a b. 0 < b}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}) =\n  {arith_prog_fb a b |a b. 0 < b}\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "ultimately"], ["proof (chain)\npicking this:\n  countable\n   ((\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}))\n  (\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}) =\n  {arith_prog_fb a b |a b. 0 < b}", "show \"\\<exists>B::fbint set set. countable B \\<and> open = generate_topology B\""], ["proof (prove)\nusing this:\n  countable\n   ((\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}))\n  (\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}) =\n  {arith_prog_fb a b |a b. 0 < b}\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "unfolding open_fbint_altdef"], ["proof (prove)\nusing this:\n  countable\n   ((\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}))\n  (\\<lambda>(a, b). arith_prog_fb a b) ` (UNIV \\<times> {b. 0 < b}) =\n  {arith_prog_fb a b |a b. 0 < b}\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       countable B \\<and>\n       generate_topology {arith_prog_fb a b |a b. 0 < b} =\n       generate_topology B", "by auto"], ["proof (state)\nthis:\n  \\<exists>B. countable B \\<and> open = generate_topology B\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A trivial consequence of the fact that nonempty open sets in this topology are infinite\n  is that it is a perfect space:\n\\<close>"], ["", "instance fbint :: perfect_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fbint, perfect_space_class)", "by standard auto"], ["", "text \\<open>\n  It is also Hausdorff, since given any two distinct integers, we can easily\n  construct two non-overlapping arithmetic progressions that each contain one of them.\n  We do not \\<^emph>\\<open>really\\<close> have to prove this since we will get it for free later on when we\n  show that it is a metric space, but here is the proof anyway:\n\\<close>"], ["", "instance fbint :: t2_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fbint, t2_space_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "fix x y :: fbint"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "define d where \"d = nat \\<bar>int_of_fbint x - int_of_fbint y\\<bar> + 1\""], ["proof (state)\nthis:\n  d = nat \\<bar>int_of_fbint x - int_of_fbint y\\<bar> + 1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "from \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have \"d > 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 0 < d", "unfolding d_def"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 0 < nat \\<bar>int_of_fbint x - int_of_fbint y\\<bar> + 1", "by transfer auto"], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "define U where \"U = arith_prog_fb (int_of_fbint x) d\""], ["proof (state)\nthis:\n  U = arith_prog_fb (int_of_fbint x) d\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "define V where \"V = arith_prog_fb (int_of_fbint y) d\""], ["proof (state)\nthis:\n  V = arith_prog_fb (int_of_fbint y) d\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "have \"U \\<inter> V = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<inter> V = {}", "unfolding U_def V_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog_fb (int_of_fbint x)\n     (nat \\<bar>int_of_fbint x - int_of_fbint y\\<bar> + 1) \\<inter>\n    arith_prog_fb (int_of_fbint y)\n     (nat \\<bar>int_of_fbint x - int_of_fbint y\\<bar> + 1) =\n    {}", "proof (use \\<open>x \\<noteq> y\\<close> in transfer, rule arith_prog_disjoint)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       [x \\<noteq> y] (mod int (nat \\<bar>x - y\\<bar> + 1))\n 2. \\<And>x y. x \\<noteq> y \\<Longrightarrow> 0 < nat \\<bar>x - y\\<bar> + 1", "fix x y :: int"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       [x \\<noteq> y] (mod int (nat \\<bar>x - y\\<bar> + 1))\n 2. \\<And>x y. x \\<noteq> y \\<Longrightarrow> 0 < nat \\<bar>x - y\\<bar> + 1", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       [x \\<noteq> y] (mod int (nat \\<bar>x - y\\<bar> + 1))\n 2. \\<And>x y. x \\<noteq> y \\<Longrightarrow> 0 < nat \\<bar>x - y\\<bar> + 1", "show \"[x \\<noteq> y] (mod int (nat \\<bar>x - y\\<bar> + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x \\<noteq> y] (mod int (nat \\<bar>x - y\\<bar> + 1))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. [x = y] (mod int (nat \\<bar>x - y\\<bar> + 1)) \\<Longrightarrow> False", "assume \"[x = y] (mod int (nat \\<bar>x - y\\<bar> + 1))\""], ["proof (state)\nthis:\n  [x = y] (mod int (nat \\<bar>x - y\\<bar> + 1))\n\ngoal (1 subgoal):\n 1. [x = y] (mod int (nat \\<bar>x - y\\<bar> + 1)) \\<Longrightarrow> False", "hence \"\\<bar>x - y\\<bar> + 1 dvd \\<bar>x - y\\<bar>\""], ["proof (prove)\nusing this:\n  [x = y] (mod int (nat \\<bar>x - y\\<bar> + 1))\n\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> + 1 dvd \\<bar>x - y\\<bar>", "by (auto simp: cong_iff_dvd_diff algebra_simps)"], ["proof (state)\nthis:\n  \\<bar>x - y\\<bar> + 1 dvd \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. [x = y] (mod int (nat \\<bar>x - y\\<bar> + 1)) \\<Longrightarrow> False", "hence \"\\<bar>x - y\\<bar> + 1 \\<le> \\<bar>x - y\\<bar>\""], ["proof (prove)\nusing this:\n  \\<bar>x - y\\<bar> + 1 dvd \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> + 1 \\<le> \\<bar>x - y\\<bar>", "by (rule zdvd_imp_le) (use \\<open>x \\<noteq> y\\<close> in auto)"], ["proof (state)\nthis:\n  \\<bar>x - y\\<bar> + 1 \\<le> \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. [x = y] (mod int (nat \\<bar>x - y\\<bar> + 1)) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<bar>x - y\\<bar> + 1 \\<le> \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x \\<noteq> y] (mod int (nat \\<bar>x - y\\<bar> + 1))\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<noteq> y \\<Longrightarrow> 0 < nat \\<bar>x - y\\<bar> + 1", "qed auto"], ["proof (state)\nthis:\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "moreover"], ["proof (state)\nthis:\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "have \"x \\<in> U\" \"y \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> U &&& y \\<in> V", "unfolding U_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> arith_prog_fb (int_of_fbint x) d &&&\n    y \\<in> arith_prog_fb (int_of_fbint y) d", "by (use \\<open>d > 0\\<close> in transfer, fastforce)+"], ["proof (state)\nthis:\n  x \\<in> U\n  y \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "moreover"], ["proof (state)\nthis:\n  x \\<in> U\n  y \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "have \"open U\" \"open V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open U &&& open V", "using \\<open>d > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. open U &&& open V", "by (auto simp: U_def V_def)"], ["proof (state)\nthis:\n  open U\n  open V\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "ultimately"], ["proof (chain)\npicking this:\n  U \\<inter> V = {}\n  x \\<in> U\n  y \\<in> V\n  open U\n  open V", "show \"\\<exists>U V. open U \\<and> open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\""], ["proof (prove)\nusing this:\n  U \\<inter> V = {}\n  x \\<in> U\n  y \\<in> V\n  open U\n  open V\n\ngoal (1 subgoal):\n 1. \\<exists>U V.\n       open U \\<and>\n       open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>U V.\n     open U \\<and>\n     open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO Move? *)"], ["", "text \\<open>\n  Next, we need a small lemma: Given an additional assumption, a $T_2$ space is also $T_3$:\n\\<close>"], ["", "lemma t2_space_t3_spaceI:\n  assumes \"\\<And>(x :: 'a :: t2_space) U. x \\<in> U \\<Longrightarrow> open U \\<Longrightarrow>\n             \\<exists>V. x \\<in> V \\<and> open V \\<and> closure V \\<subseteq> U\"\n  shows   \"OFCLASS('a, t3_space_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, t3_space_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S y.\n       \\<lbrakk>closed S; y \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>U V.\n                            open U \\<and>\n                            open V \\<and>\n                            y \\<in> U \\<and>\n                            S \\<subseteq> V \\<and> U \\<inter> V = {}", "fix X :: \"'a set\" and z :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S y.\n       \\<lbrakk>closed S; y \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>U V.\n                            open U \\<and>\n                            open V \\<and>\n                            y \\<in> U \\<and>\n                            S \\<subseteq> V \\<and> U \\<inter> V = {}", "assume X: \"closed X\" \"z \\<notin> X\""], ["proof (state)\nthis:\n  closed X\n  z \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<And>S y.\n       \\<lbrakk>closed S; y \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>U V.\n                            open U \\<and>\n                            open V \\<and>\n                            y \\<in> U \\<and>\n                            S \\<subseteq> V \\<and> U \\<inter> V = {}", "with assms[of z \"-X\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>z \\<in> - X; open (- X)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>V.\n                       z \\<in> V \\<and>\n                       open V \\<and> closure V \\<subseteq> - X\n  closed X\n  z \\<notin> X", "obtain V where V: \"z \\<in> V\" \"open V\" \"closure V \\<subseteq> -X\""], ["proof (prove)\nusing this:\n  \\<lbrakk>z \\<in> - X; open (- X)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>V.\n                       z \\<in> V \\<and>\n                       open V \\<and> closure V \\<subseteq> - X\n  closed X\n  z \\<notin> X\n\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>z \\<in> V; open V; closure V \\<subseteq> - X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> V\n  open V\n  closure V \\<subseteq> - X\n\ngoal (1 subgoal):\n 1. \\<And>S y.\n       \\<lbrakk>closed S; y \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>U V.\n                            open U \\<and>\n                            open V \\<and>\n                            y \\<in> U \\<and>\n                            S \\<subseteq> V \\<and> U \\<inter> V = {}", "show \"\\<exists>U V. open U \\<and> open V \\<and> z \\<in> U \\<and> X \\<subseteq> V \\<and> U \\<inter> V = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U V.\n       open U \\<and>\n       open V \\<and>\n       z \\<in> U \\<and> X \\<subseteq> V \\<and> U \\<inter> V = {}", "by (rule exI[of _ V], rule exI[of _ \"-closure V\"])\n       (use X V closure_subset[of V] in auto)"], ["proof (state)\nthis:\n  \\<exists>U V.\n     open U \\<and>\n     open V \\<and> z \\<in> U \\<and> X \\<subseteq> V \\<and> U \\<inter> V = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Since the Furstenberg topology is $T_2$ and every arithmetic progression is also closed,\n  we can now easily show that it is also $T_3$ (i.\\,e.\\ regular). \n  Again, we do not really need this proof, but here it is:\n\\<close>"], ["", "instance fbint :: t3_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fbint, t3_space_class)", "proof (rule t2_space_t3_spaceI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x U.\n       \\<lbrakk>x \\<in> U; open U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V.\n                            x \\<in> V \\<and>\n                            open V \\<and> closure V \\<subseteq> U", "fix x :: fbint and U :: \"fbint set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x U.\n       \\<lbrakk>x \\<in> U; open U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V.\n                            x \\<in> V \\<and>\n                            open V \\<and> closure V \\<subseteq> U", "assume \"x \\<in> U\" and \"open U\""], ["proof (state)\nthis:\n  x \\<in> U\n  open U\n\ngoal (1 subgoal):\n 1. \\<And>x U.\n       \\<lbrakk>x \\<in> U; open U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V.\n                            x \\<in> V \\<and>\n                            open V \\<and> closure V \\<subseteq> U", "then"], ["proof (chain)\npicking this:\n  x \\<in> U\n  open U", "obtain b where b: \"b > 0\" \"arith_prog_fb (int_of_fbint x) b \\<subseteq> U\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  open U\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>0 < b;\n         arith_prog_fb (int_of_fbint x) b \\<subseteq> U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer blast"], ["proof (state)\nthis:\n  0 < b\n  arith_prog_fb (int_of_fbint x) b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<And>x U.\n       \\<lbrakk>x \\<in> U; open U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V.\n                            x \\<in> V \\<and>\n                            open V \\<and> closure V \\<subseteq> U", "define V where \"V = arith_prog_fb (int_of_fbint x) b\""], ["proof (state)\nthis:\n  V = arith_prog_fb (int_of_fbint x) b\n\ngoal (1 subgoal):\n 1. \\<And>x U.\n       \\<lbrakk>x \\<in> U; open U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V.\n                            x \\<in> V \\<and>\n                            open V \\<and> closure V \\<subseteq> U", "have \"x \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V", "unfolding V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> arith_prog_fb (int_of_fbint x) b", "by transfer auto"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x U.\n       \\<lbrakk>x \\<in> U; open U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V.\n                            x \\<in> V \\<and>\n                            open V \\<and> closure V \\<subseteq> U", "moreover"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x U.\n       \\<lbrakk>x \\<in> U; open U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V.\n                            x \\<in> V \\<and>\n                            open V \\<and> closure V \\<subseteq> U", "have \"open V\" \"closed V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open V &&& closed V", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. open V &&& closed V", "by (auto simp: V_def)"], ["proof (state)\nthis:\n  open V\n  closed V\n\ngoal (1 subgoal):\n 1. \\<And>x U.\n       \\<lbrakk>x \\<in> U; open U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V.\n                            x \\<in> V \\<and>\n                            open V \\<and> closure V \\<subseteq> U", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> V\n  open V\n  closed V", "show \"\\<exists>V. x \\<in> V \\<and> open V \\<and> closure V \\<subseteq> U\""], ["proof (prove)\nusing this:\n  x \\<in> V\n  open V\n  closed V\n\ngoal (1 subgoal):\n 1. \\<exists>V. x \\<in> V \\<and> open V \\<and> closure V \\<subseteq> U", "using b"], ["proof (prove)\nusing this:\n  x \\<in> V\n  open V\n  closed V\n  0 < b\n  arith_prog_fb (int_of_fbint x) b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<exists>V. x \\<in> V \\<and> open V \\<and> closure V \\<subseteq> U", "by (intro exI[of _ V]) (auto simp: V_def)"], ["proof (state)\nthis:\n  \\<exists>V. x \\<in> V \\<and> open V \\<and> closure V \\<subseteq> U\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Metrizability\\<close>"], ["", "text \\<open>\n  The metrizability of Furstenberg's topology (i.\\,e.\\ that it is induced by some metric) can\n  be shown from the fact that it is second countable and $T_3$ using Urysohn's Metrization Theorem, \n  but this is not available in Isabelle yet. Let us therefore give an \\<^emph>\\<open>explicit\\<close> metric, \n  as described by Zulfeqarr~\\cite{zulfeqarr}. We follow the exposition by Dirmeier~\\cite{dirmeier}.\n\n  First, we define a kind of norm on the integers. The norm depends on a real parameter \\<open>q > 1\\<close>.\n  The value of \\<open>q\\<close> does not matter in the sense that all values induce the same topology\n  (which we will show). For the final definition, we then simply pick \\<open>q = 2\\<close>.\n\\<close>"], ["", "locale fbnorm =\n  fixes q :: \"real\"\n  assumes q_gt_1: \"q > 1\"\nbegin"], ["", "definition N :: \"int \\<Rightarrow> real\" where\n  \"N n = (\\<Sum>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)\""], ["", "lemma N_summable: \"summable (\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)", "by (rule summable_comparison_test[OF _ summable_geometric[of \"1/q\"]])\n     (use q_gt_1 in \\<open>auto intro!: exI[of _ 0] simp: power_divide\\<close>)"], ["", "lemma N_sums: \"(\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) sums N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) sums N n", "using N_summable"], ["proof (prove)\nusing this:\n  summable (\\<lambda>k. if k = 0 \\<or> int k dvd ?n then 0 else 1 / q ^ k)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) sums N n", "unfolding N_def"], ["proof (prove)\nusing this:\n  summable (\\<lambda>k. if k = 0 \\<or> int k dvd ?n then 0 else 1 / q ^ k)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) sums\n    (\\<Sum>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)", "by (rule summable_sums)"], ["", "lemma N_nonneg: \"N n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> N n", "by (rule sums_le[OF _ sums_zero N_sums]) (use q_gt_1 in auto)"], ["", "lemma N_uminus [simp]: \"N (-n) = N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (- n) = N n", "by (simp add: N_def)"], ["", "lemma N_minus_commute: \"N (x - y) = N (y - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (x - y) = N (y - x)", "using N_uminus[of \"x - y\"]"], ["proof (prove)\nusing this:\n  N (- (x - y)) = N (x - y)\n\ngoal (1 subgoal):\n 1. N (x - y) = N (y - x)", "by (simp del: N_uminus)"], ["", "lemma N_zero [simp]: \"N 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N 0 = 0", "by (simp add: N_def)"], ["", "lemma not_dvd_imp_N_ge:\n  assumes \"\\<not>n dvd a\" \"n > 0\"\n  shows   \"N a \\<ge> 1 / q ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / q ^ n \\<le> N a", "by (rule sums_le[OF _ sums_single[of n] N_sums]) (use q_gt_1 assms in auto)"], ["", "lemma N_lt_imp_dvd:\n  assumes \"N a < 1 / q ^ n\" and \"n > 0\"\n  shows   \"n dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n dvd a", "using not_dvd_imp_N_ge[of n a] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> int n dvd a; 0 < n\\<rbrakk>\n  \\<Longrightarrow> 1 / q ^ n \\<le> N a\n  N a < 1 / q ^ n\n  0 < n\n\ngoal (1 subgoal):\n 1. int n dvd a", "by auto"], ["", "lemma N_pos:\n  assumes \"n \\<noteq> 0\"\n  shows   \"N n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < N n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < N n", "have \"0 < 1 / q ^ (nat \\<bar>n\\<bar>+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / q ^ (nat \\<bar>n\\<bar> + 1)", "using q_gt_1"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. 0 < 1 / q ^ (nat \\<bar>n\\<bar> + 1)", "by simp"], ["proof (state)\nthis:\n  0 < 1 / q ^ (nat \\<bar>n\\<bar> + 1)\n\ngoal (1 subgoal):\n 1. 0 < N n", "also"], ["proof (state)\nthis:\n  0 < 1 / q ^ (nat \\<bar>n\\<bar> + 1)\n\ngoal (1 subgoal):\n 1. 0 < N n", "have \"\\<not>1 + \\<bar>n\\<bar> dvd \\<bar>n\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 1 + \\<bar>n\\<bar> dvd \\<bar>n\\<bar>", "using zdvd_imp_le[of \"1 + \\<bar>n\\<bar>\" \"\\<bar>n\\<bar>\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 + \\<bar>n\\<bar> dvd \\<bar>n\\<bar>; 0 < \\<bar>n\\<bar>\\<rbrakk>\n  \\<Longrightarrow> 1 + \\<bar>n\\<bar> \\<le> \\<bar>n\\<bar>\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> 1 + \\<bar>n\\<bar> dvd \\<bar>n\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<not> 1 + \\<bar>n\\<bar> dvd \\<bar>n\\<bar>\n\ngoal (1 subgoal):\n 1. 0 < N n", "hence \"1 / q ^ (nat \\<bar>n\\<bar>+1) \\<le> N n\""], ["proof (prove)\nusing this:\n  \\<not> 1 + \\<bar>n\\<bar> dvd \\<bar>n\\<bar>\n\ngoal (1 subgoal):\n 1. 1 / q ^ (nat \\<bar>n\\<bar> + 1) \\<le> N n", "by (intro not_dvd_imp_N_ge) (use assms in auto)"], ["proof (state)\nthis:\n  1 / q ^ (nat \\<bar>n\\<bar> + 1) \\<le> N n\n\ngoal (1 subgoal):\n 1. 0 < N n", "finally"], ["proof (chain)\npicking this:\n  0 < N n", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < N n\n\ngoal (1 subgoal):\n 1. 0 < N n", "."], ["proof (state)\nthis:\n  0 < N n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma N_zero_iff [simp]: \"N n = 0 \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (N n = 0) = (n = 0)", "using N_pos[of n]"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow> 0 < N n\n\ngoal (1 subgoal):\n 1. (N n = 0) = (n = 0)", "by (cases \"n = 0\") auto"], ["", "lemma N_triangle_ineq: \"N (n + m) \\<le> N n + N m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (n + m) \\<le> N n + N m", "proof (rule sums_le)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n. ?f n \\<le> ?g n\n 2. ?f sums N (n + m)\n 3. ?g sums (N n + N m)", "let ?I = \"\\<lambda>n k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n. ?f n \\<le> ?g n\n 2. ?f sums N (n + m)\n 3. ?g sums (N n + N m)", "show \"?I (n + m) sums N (n + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k = 0 \\<or> int k dvd n + m then 0 else 1 / q ^ k) sums\n    N (n + m)", "by (rule N_sums)"], ["proof (state)\nthis:\n  (\\<lambda>k. if k = 0 \\<or> int k dvd n + m then 0 else 1 / q ^ k) sums\n  N (n + m)\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n + m then 0 else 1 / q ^ na) \\<le> ?g na\n 2. ?g sums (N n + N m)", "show \"(\\<lambda>k. ?I n k + ?I m k) sums (N n + N m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        (if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) +\n        (if k = 0 \\<or> int k dvd m then 0 else 1 / q ^ k)) sums\n    (N n + N m)", "by (intro sums_add N_sums)"], ["proof (state)\nthis:\n  (\\<lambda>k.\n      (if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) +\n      (if k = 0 \\<or> int k dvd m then 0 else 1 / q ^ k)) sums\n  (N n + N m)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n + m then 0 else 1 / q ^ na)\n       \\<le> (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na) +\n             (if na = 0 \\<or> int na dvd m then 0 else 1 / q ^ na)", "qed (use q_gt_1 in auto)"], ["", "lemma N_1: \"N 1 = 1 / (q * (q - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N 1 = 1 / (q * (q - 1))", "proof (rule sums_unique2)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?f sums N 1\n 2. ?f sums (1 / (q * (q - 1)))", "have \"(\\<lambda>k. if k = 0 \\<or> int k dvd 1 then 0 else 1 / q ^ k) sums N 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k = 0 \\<or> is_unit (int k) then 0 else 1 / q ^ k) sums\n    N 1", "by (rule N_sums)"], ["proof (state)\nthis:\n  (\\<lambda>k. if k = 0 \\<or> is_unit (int k) then 0 else 1 / q ^ k) sums\n  N 1\n\ngoal (2 subgoals):\n 1. ?f sums N 1\n 2. ?f sums (1 / (q * (q - 1)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>k. if k = 0 \\<or> is_unit (int k) then 0 else 1 / q ^ k) sums\n  N 1\n\ngoal (2 subgoals):\n 1. ?f sums N 1\n 2. ?f sums (1 / (q * (q - 1)))", "have \"(\\<lambda>k. if k = 0 \\<or> int k dvd 1 then 0 else 1 / q ^ k) =\n               (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k = 0 \\<or> is_unit (int k) then 0 else 1 / q ^ k) =\n    (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k)", "by (simp add: power_divide cong: if_cong)"], ["proof (state)\nthis:\n  (\\<lambda>k. if k = 0 \\<or> is_unit (int k) then 0 else 1 / q ^ k) =\n  (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k)\n\ngoal (2 subgoals):\n 1. ?f sums N 1\n 2. ?f sums (1 / (q * (q - 1)))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums N 1", "show \"(\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums N 1\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums N 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums N 1", "."], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums N 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n    (1 / (q * (q - 1)))", "have \"(\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n                 (1 / (1 - 1 / q) + (- (1 / q) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n    (1 / (1 - 1 / q) + (- (1 / q) - 1))", "by (rule sums_If_finite_set'[OF geometric_sums]) (use q_gt_1 in auto)"], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n  (1 / (1 - 1 / q) + (- (1 / q) - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n    (1 / (q * (q - 1)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n  (1 / (1 - 1 / q) + (- (1 / q) - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n    (1 / (q * (q - 1)))", "have \"\\<dots> = 1 / (q * (q - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (1 - 1 / q) + (- (1 / q) - 1) = 1 / (q * (q - 1))", "using q_gt_1"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. 1 / (1 - 1 / q) + (- (1 / q) - 1) = 1 / (q * (q - 1))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  1 / (1 - 1 / q) + (- (1 / q) - 1) = 1 / (q * (q - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n    (1 / (q * (q - 1)))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n  (1 / (q * (q - 1)))", "show \"(\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n  (1 / (q * (q - 1)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n    (1 / (q * (q - 1)))", "."], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1} then 0 else (1 / q) ^ k) sums\n  (1 / (q * (q - 1)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  It follows directly from the definition that norms fulfil a kind of monotonicity property\n  with respect to divisibility: the norm of a number is at most as large as the norm of any of\n  its factors:\n\\<close>"], ["", "lemma N_dvd_mono:\n  assumes \"m dvd n\"\n  shows   \"N n \\<le> N m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N n \\<le> N m", "proof (rule sums_le[OF _ N_sums N_sums])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na)\n       \\<le> (if na = 0 \\<or> int na dvd m then 0 else 1 / q ^ na)", "fix k :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na)\n       \\<le> (if na = 0 \\<or> int na dvd m then 0 else 1 / q ^ na)", "show \"(if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) \\<le>\n        (if k = 0 \\<or> int k dvd m then 0 else 1 / q ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)\n    \\<le> (if k = 0 \\<or> int k dvd m then 0 else 1 / q ^ k)", "using q_gt_1 assms"], ["proof (prove)\nusing this:\n  1 < q\n  m dvd n\n\ngoal (1 subgoal):\n 1. (if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)\n    \\<le> (if k = 0 \\<or> int k dvd m then 0 else 1 / q ^ k)", "by auto"], ["proof (state)\nthis:\n  (if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)\n  \\<le> (if k = 0 \\<or> int k dvd m then 0 else 1 / q ^ k)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  In particular, this means that 1 and -1 have the greatest norm.\n\\<close>"], ["", "lemma N_le_N_1: \"N n \\<le> N 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N n \\<le> N 1", "by (rule N_dvd_mono) auto"], ["", "text \\<open>\n  Primes have relatively large norms, almost reaching the norm of 1:\n\\<close>"], ["", "lemma N_prime:\n  assumes \"prime p\"\n  shows   \"N p = N 1 - 1 / q ^ nat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N p = N 1 - 1 / q ^ nat p", "proof (rule sums_unique2)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?f sums N p\n 2. ?f sums (N 1 - 1 / q ^ nat p)", "define p' where \"p' = nat p\""], ["proof (state)\nthis:\n  p' = nat p\n\ngoal (2 subgoals):\n 1. ?f sums N p\n 2. ?f sums (N 1 - 1 / q ^ nat p)", "have p: \"p = int p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = int p'", "using assms"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. p = int p'", "by (auto simp: p'_def prime_ge_0_int)"], ["proof (state)\nthis:\n  p = int p'\n\ngoal (2 subgoals):\n 1. ?f sums N p\n 2. ?f sums (N 1 - 1 / q ^ nat p)", "have \"prime p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p'", "using assms"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. prime p'", "by (simp add: p)"], ["proof (state)\nthis:\n  prime p'\n\ngoal (2 subgoals):\n 1. ?f sums N p\n 2. ?f sums (N 1 - 1 / q ^ nat p)", "have \"(\\<lambda>k. if k = 0 \\<or> int k dvd p then 0 else 1 / q ^ k) sums N p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k = 0 \\<or> int k dvd p then 0 else 1 / q ^ k) sums N p", "by (rule N_sums)"], ["proof (state)\nthis:\n  (\\<lambda>k. if k = 0 \\<or> int k dvd p then 0 else 1 / q ^ k) sums N p\n\ngoal (2 subgoals):\n 1. ?f sums N p\n 2. ?f sums (N 1 - 1 / q ^ nat p)", "also"], ["proof (state)\nthis:\n  (\\<lambda>k. if k = 0 \\<or> int k dvd p then 0 else 1 / q ^ k) sums N p\n\ngoal (2 subgoals):\n 1. ?f sums N p\n 2. ?f sums (N 1 - 1 / q ^ nat p)", "have \"int k dvd p \\<longleftrightarrow> k \\<in> {1, p'}\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int k dvd p) = (k \\<in> {1, p'})", "using assms"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. (int k dvd p) = (k \\<in> {1, p'})", "by (auto simp: p prime_nat_iff)"], ["proof (state)\nthis:\n  (int ?k dvd p) = (?k \\<in> {1, p'})\n\ngoal (2 subgoals):\n 1. ?f sums N p\n 2. ?f sums (N 1 - 1 / q ^ nat p)", "hence \"(\\<lambda>k. if k = 0 \\<or> int k dvd p then 0 else 1 / q ^ k) =\n         (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k)\""], ["proof (prove)\nusing this:\n  (int ?k dvd p) = (?k \\<in> {1, p'})\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k = 0 \\<or> int k dvd p then 0 else 1 / q ^ k) =\n    (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k)", "using assms q_gt_1"], ["proof (prove)\nusing this:\n  (int ?k dvd p) = (?k \\<in> {1, p'})\n  prime p\n  1 < q\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k = 0 \\<or> int k dvd p then 0 else 1 / q ^ k) =\n    (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k)", "by (simp add: power_divide cong: if_cong)"], ["proof (state)\nthis:\n  (\\<lambda>k. if k = 0 \\<or> int k dvd p then 0 else 1 / q ^ k) =\n  (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k)\n\ngoal (2 subgoals):\n 1. ?f sums N p\n 2. ?f sums (N 1 - 1 / q ^ nat p)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums N p", "show \"\\<dots> sums N p\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums N p\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums N p", "."], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums N p\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1, nat p} then 0 else (1 / q) ^ k) sums\n    (N 1 - 1 / q ^ nat p)", "have \"(\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums\n                 (1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums\n    (1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - 1))", "by (rule sums_If_finite_set'[OF geometric_sums])\n       (use \\<open>prime p'\\<close> q_gt_1 prime_gt_Suc_0_nat[of p'] in \\<open>auto simp: \\<close>)"], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums\n  (1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1, nat p} then 0 else (1 / q) ^ k) sums\n    (N 1 - 1 / q ^ nat p)", "also"], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums\n  (1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1, nat p} then 0 else (1 / q) ^ k) sums\n    (N 1 - 1 / q ^ nat p)", "have \"\\<dots> = N 1 - 1 / q ^ p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - 1) = N 1 - 1 / q ^ p'", "using q_gt_1"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. 1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - 1) = N 1 - 1 / q ^ p'", "by (simp add: field_simps N_1)"], ["proof (state)\nthis:\n  1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - 1) = N 1 - 1 / q ^ p'\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1, nat p} then 0 else (1 / q) ^ k) sums\n    (N 1 - 1 / q ^ nat p)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums\n  (N 1 - 1 / q ^ p')", "show \"(\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums\n  (N 1 - 1 / q ^ p')\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums\n    (N 1 - 1 / q ^ p')", "."], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1, p'} then 0 else (1 / q) ^ k) sums\n  (N 1 - 1 / q ^ p')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma N_2: \"N 2 = 1 / (q ^ 2 * (q - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N 2 = 1 / (q\\<^sup>2 * (q - 1))", "using q_gt_1"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. N 2 = 1 / (q\\<^sup>2 * (q - 1))", "by (auto simp: N_prime N_1 field_simps power2_eq_square)"], ["", "lemma N_less_N_1:\n  assumes \"n \\<noteq> 1\" \"n \\<noteq> -1\"\n  shows   \"N n < N 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N n < N 1", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> N n < N 1\n 2. n \\<noteq> 0 \\<Longrightarrow> N n < N 1", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> N n < N 1\n 2. n \\<noteq> 0 \\<Longrightarrow> N n < N 1", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "obtain p where p: \"prime p\" \"p dvd n\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_divisor_exists[of n] assms"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  \\<lbrakk>n \\<noteq> 0; \\<not> is_unit n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. b dvd n \\<and> prime b\n  n \\<noteq> 1\n  n \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  prime p\n  p dvd n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> N n < N 1\n 2. n \\<noteq> 0 \\<Longrightarrow> N n < N 1", "hence \"N n \\<le> N p\""], ["proof (prove)\nusing this:\n  prime p\n  p dvd n\n\ngoal (1 subgoal):\n 1. N n \\<le> N p", "by (intro N_dvd_mono)"], ["proof (state)\nthis:\n  N n \\<le> N p\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> N n < N 1\n 2. n \\<noteq> 0 \\<Longrightarrow> N n < N 1", "also"], ["proof (state)\nthis:\n  N n \\<le> N p\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> N n < N 1\n 2. n \\<noteq> 0 \\<Longrightarrow> N n < N 1", "from p"], ["proof (chain)\npicking this:\n  prime p\n  p dvd n", "have \"N p < N 1\""], ["proof (prove)\nusing this:\n  prime p\n  p dvd n\n\ngoal (1 subgoal):\n 1. N p < N 1", "using q_gt_1"], ["proof (prove)\nusing this:\n  prime p\n  p dvd n\n  1 < q\n\ngoal (1 subgoal):\n 1. N p < N 1", "by (simp add: N_prime)"], ["proof (state)\nthis:\n  N p < N 1\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> N n < N 1\n 2. n \\<noteq> 0 \\<Longrightarrow> N n < N 1", "finally"], ["proof (chain)\npicking this:\n  N n < N 1", "show ?thesis"], ["proof (prove)\nusing this:\n  N n < N 1\n\ngoal (1 subgoal):\n 1. N n < N 1", "."], ["proof (state)\nthis:\n  N n < N 1\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> N n < N 1", "qed (use q_gt_1 in \\<open>auto simp: N_1\\<close>)"], ["", "text \\<open>\n  Composites, on the other hand, do not achieve this:\n\\<close>"], ["", "lemma nonprime_imp_N_lt:\n  assumes \"\\<not>prime_elem n\" \"\\<bar>n\\<bar> \\<noteq> 1\" \"n \\<noteq> 0\"\n  shows   \"N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "obtain p where p: \"prime p\" \"p dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_divisor_exists[of n] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<noteq> 0; \\<not> is_unit n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. b dvd n \\<and> prime b\n  \\<not> prime_elem n\n  \\<bar>n\\<bar> \\<noteq> 1\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prime p\n  p dvd n\n\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "define p' where \"p' = nat p\""], ["proof (state)\nthis:\n  p' = nat p\n\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "have p': \"p = int p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = int p'", "using p"], ["proof (prove)\nusing this:\n  prime p\n  p dvd n\n\ngoal (1 subgoal):\n 1. p = int p'", "by (auto simp: p'_def prime_ge_0_int)"], ["proof (state)\nthis:\n  p = int p'\n\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "have \"prime p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p'", "using p"], ["proof (prove)\nusing this:\n  prime p\n  p dvd n\n\ngoal (1 subgoal):\n 1. prime p'", "by (simp add: p')"], ["proof (state)\nthis:\n  prime p'\n\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "define n' where \"n' = nat \\<bar>n\\<bar>\""], ["proof (state)\nthis:\n  n' = nat \\<bar>n\\<bar>\n\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "have \"n' > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n'", "using assms"], ["proof (prove)\nusing this:\n  \\<not> prime_elem n\n  \\<bar>n\\<bar> \\<noteq> 1\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 < n'", "by (auto simp: n'_def)"], ["proof (state)\nthis:\n  1 < n'\n\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "have \"N n \\<le> 1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N n \\<le> 1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'", "proof (rule sums_le)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n. ?f n \\<le> ?g n\n 2. ?f sums N n\n 3. ?g sums (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')", "show \"(\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) sums N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) sums N n", "by (rule N_sums)"], ["proof (state)\nthis:\n  (\\<lambda>k. if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k) sums N n\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na) \\<le> ?g na\n 2. ?g sums (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na) \\<le> ?g na\n 2. ?g sums (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')", "from assms p"], ["proof (chain)\npicking this:\n  \\<not> prime_elem n\n  \\<bar>n\\<bar> \\<noteq> 1\n  n \\<noteq> 0\n  prime p\n  p dvd n", "have \"n' \\<noteq> p'\""], ["proof (prove)\nusing this:\n  \\<not> prime_elem n\n  \\<bar>n\\<bar> \\<noteq> 1\n  n \\<noteq> 0\n  prime p\n  p dvd n\n\ngoal (1 subgoal):\n 1. n' \\<noteq> p'", "by (auto simp: n'_def p'_def nat_eq_iff)"], ["proof (state)\nthis:\n  n' \\<noteq> p'\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na) \\<le> ?g na\n 2. ?g sums (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')", "hence \"(\\<lambda>k. if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k) sums\n                   (1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - (1 / q) ^ n' - 1))\""], ["proof (prove)\nusing this:\n  n' \\<noteq> p'\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k) sums\n    (1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - (1 / q) ^ n' - 1))", "by (intro sums_If_finite_set'[OF geometric_sums])\n         (use \\<open>prime p'\\<close> q_gt_1 prime_gt_Suc_0_nat[of p'] \\<open>n' > 1\\<close> in \\<open>auto simp: \\<close>)"], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k) sums\n  (1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - (1 / q) ^ n' - 1))\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na) \\<le> ?g na\n 2. ?g sums (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')", "also"], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k) sums\n  (1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - (1 / q) ^ n' - 1))\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na) \\<le> ?g na\n 2. ?g sums (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')", "have \"\\<dots> = 1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - (1 / q) ^ n' - 1) =\n    1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'", "using q_gt_1"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. 1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - (1 / q) ^ n' - 1) =\n    1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  1 / (1 - 1 / q) + (- (1 / q) - (1 / q) ^ p' - (1 / q) ^ n' - 1) =\n  1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na) \\<le> ?g na\n 2. ?g sums (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k. if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k) sums\n  (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')", "show \"(\\<lambda>k. if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k) sums \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k) sums\n  (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k) sums\n    (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')", "."], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k) sums\n  (1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n')\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na)\n       \\<le> (if na \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ na)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       (if na = 0 \\<or> int na dvd n then 0 else 1 / q ^ na)\n       \\<le> (if na \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ na)", "show \"\\<And>k. (if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)\n         \\<le> (if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       (if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)\n       \\<le> (if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k)", "using q_gt_1 p"], ["proof (prove)\nusing this:\n  1 < q\n  prime p\n  p dvd n\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       (if k = 0 \\<or> int k dvd n then 0 else 1 / q ^ k)\n       \\<le> (if k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ k)", "by (auto simp: p'_def n'_def power_divide)"], ["proof (state)\nthis:\n  (if ?k = 0 \\<or> int ?k dvd n then 0 else 1 / q ^ ?k)\n  \\<le> (if ?k \\<in> {0, 1, p', n'} then 0 else (1 / q) ^ ?k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N n \\<le> 1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'\n\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "also"], ["proof (state)\nthis:\n  N n \\<le> 1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'\n\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "have \"\\<dots> < 1 / (q * (q - 1)) - 1 / q ^ n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'\n    < 1 / (q * (q - 1)) - 1 / q ^ n'", "using q_gt_1"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. 1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'\n    < 1 / (q * (q - 1)) - 1 / q ^ n'", "by simp"], ["proof (state)\nthis:\n  1 / (q * (q - 1)) - 1 / q ^ p' - 1 / q ^ n'\n  < 1 / (q * (q - 1)) - 1 / q ^ n'\n\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "finally"], ["proof (chain)\npicking this:\n  N n < 1 / (q * (q - 1)) - 1 / q ^ n'", "show ?thesis"], ["proof (prove)\nusing this:\n  N n < 1 / (q * (q - 1)) - 1 / q ^ n'\n\ngoal (1 subgoal):\n 1. N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>", "by (simp add: n'_def N_1)"], ["proof (state)\nthis:\n  N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  This implies that one can use the norm as a primality test:\n\\<close>"], ["", "lemma prime_iff_N_eq:\n  assumes \"n \\<noteq> 0\"\n  shows   \"prime_elem n \\<longleftrightarrow> N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "have *: \"prime_elem n \\<longleftrightarrow> N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>\" if \"n > 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "consider \"n = 1\" | \"prime n\" | \"\\<not>prime n\" \"n > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 1 \\<Longrightarrow> thesis;\n     prime n \\<Longrightarrow> thesis;\n     \\<lbrakk>\\<not> prime n; 1 < n\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 1 \\<Longrightarrow> thesis;\n     prime n \\<Longrightarrow> thesis;\n     \\<lbrakk>\\<not> prime n; 1 < n\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>n = 1 \\<Longrightarrow> ?thesis;\n   prime n \\<Longrightarrow> ?thesis;\n   \\<lbrakk>\\<not> prime n; 1 < n\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = 1 \\<Longrightarrow> ?thesis;\n   prime n \\<Longrightarrow> ?thesis;\n   \\<lbrakk>\\<not> prime n; 1 < n\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n 2. prime n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n 3. \\<lbrakk>\\<not> prime n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "assume \"n = 1\""], ["proof (state)\nthis:\n  n = 1\n\ngoal (3 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n 2. prime n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n 3. \\<lbrakk>\\<not> prime n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 1\n\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "using q_gt_1"], ["proof (prove)\nusing this:\n  n = 1\n  1 < q\n\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "by (auto simp: N_1)"], ["proof (state)\nthis:\n  prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n\ngoal (2 subgoals):\n 1. prime n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n 2. \\<lbrakk>\\<not> prime n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. prime n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n 2. \\<lbrakk>\\<not> prime n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "assume n: \"\\<not>prime n\" \"n > 1\""], ["proof (state)\nthis:\n  \\<not> prime n\n  1 < n\n\ngoal (2 subgoals):\n 1. prime n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n 2. \\<lbrakk>\\<not> prime n; 1 < n\\<rbrakk>\n    \\<Longrightarrow> prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "with nonprime_imp_N_lt[of n]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> prime_elem n; \\<bar>n\\<bar> \\<noteq> 1;\n   n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>\n  \\<not> prime n\n  1 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> prime_elem n; \\<bar>n\\<bar> \\<noteq> 1;\n   n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> N n < N 1 - 1 / q ^ nat \\<bar>n\\<bar>\n  \\<not> prime n\n  1 < n\n\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "by simp"], ["proof (state)\nthis:\n  prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n\ngoal (1 subgoal):\n 1. prime n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "qed (auto simp: N_prime prime_ge_0_int)"], ["proof (state)\nthis:\n  prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow>\n  prime_elem ?n = (N ?n = N 1 - 1 / q ^ nat \\<bar>?n\\<bar>)\n\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "proof (cases \"n > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n 2. \\<not> 0 < n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "case True"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n 2. \\<not> 0 < n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "with *"], ["proof (chain)\npicking this:\n  0 < ?n \\<Longrightarrow>\n  prime_elem ?n = (N ?n = N 1 - 1 / q ^ nat \\<bar>?n\\<bar>)\n  0 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow>\n  prime_elem ?n = (N ?n = N 1 - 1 / q ^ nat \\<bar>?n\\<bar>)\n  0 < n\n\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "by blast"], ["proof (state)\nthis:\n  prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. \\<not> 0 < n \\<Longrightarrow>\n    prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "with *[of \"-n\"] assms"], ["proof (chain)\npicking this:\n  0 < - n \\<Longrightarrow>\n  prime_elem (- n) = (N (- n) = N 1 - 1 / q ^ nat \\<bar>- n\\<bar>)\n  n \\<noteq> 0\n  \\<not> 0 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < - n \\<Longrightarrow>\n  prime_elem (- n) = (N (- n) = N 1 - 1 / q ^ nat \\<bar>- n\\<bar>)\n  n \\<noteq> 0\n  \\<not> 0 < n\n\ngoal (1 subgoal):\n 1. prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)", "by simp"], ["proof (state)\nthis:\n  prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime_elem n = (N n = N 1 - 1 / q ^ nat \\<bar>n\\<bar>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Factorials, on the other hand, have very small norms:\n\\<close>"], ["", "lemma N_fact_le: \"N (fact m) \\<le> 1 / (q - 1) * 1 / q ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (fact m) \\<le> 1 / (q - 1) * 1 / q ^ m", "proof (rule sums_le[OF _ N_sums])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "have \"(\\<lambda>k. 1 / q ^ k / q ^ Suc m) sums (q / (q - 1) / q ^ Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / q ^ k / q ^ Suc m) sums (q / (q - 1) / q ^ Suc m)", "using geometric_sums[of \"1 / q\"] q_gt_1"], ["proof (prove)\nusing this:\n  norm (1 / q) < 1 \\<Longrightarrow> (^) (1 / q) sums (1 / (1 - 1 / q))\n  1 < q\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / q ^ k / q ^ Suc m) sums (q / (q - 1) / q ^ Suc m)", "by (intro sums_divide) (auto simp: field_simps)"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / q ^ k / q ^ Suc m) sums (q / (q - 1) / q ^ Suc m)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "also"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / q ^ k / q ^ Suc m) sums (q / (q - 1) / q ^ Suc m)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "have \"(q / (q - 1) / q ^ Suc m) = 1 / (q - 1) * 1 / q ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q / (q - 1) / q ^ Suc m = 1 / (q - 1) * 1 / q ^ m", "using q_gt_1"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. q / (q - 1) / q ^ Suc m = 1 / (q - 1) * 1 / q ^ m", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  q / (q - 1) / q ^ Suc m = 1 / (q - 1) * 1 / q ^ m\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "also"], ["proof (state)\nthis:\n  q / (q - 1) / q ^ Suc m = 1 / (q - 1) * 1 / q ^ m\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "have \"(\\<lambda>k. 1 / q ^ k / q ^ Suc m) = (\\<lambda>k. 1 / q ^ (k + Suc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / q ^ k / q ^ Suc m) = (\\<lambda>k. 1 / q ^ (k + Suc m))", "using q_gt_1"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / q ^ k / q ^ Suc m) = (\\<lambda>k. 1 / q ^ (k + Suc m))", "by (simp add: field_simps power_add)"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / q ^ k / q ^ Suc m) = (\\<lambda>k. 1 / q ^ (k + Suc m))\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "also"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / q ^ k / q ^ Suc m) = (\\<lambda>k. 1 / q ^ (k + Suc m))\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "have \"\\<dots> = (\\<lambda>k. if k + Suc m \\<le> m then 0 else 1 / q ^ (k + Suc m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. 1 / q ^ (k + Suc m)) =\n    (\\<lambda>k. if k + Suc m \\<le> m then 0 else 1 / q ^ (k + Suc m))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>k. 1 / q ^ (k + Suc m)) =\n  (\\<lambda>k. if k + Suc m \\<le> m then 0 else 1 / q ^ (k + Suc m))\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k. if k + Suc m \\<le> m then 0 else 1 / q ^ (k + Suc m)) sums\n  (1 / (q - 1) * 1 / q ^ m)", "have \"\\<dots> sums (1 / (q - 1) * 1 / q ^ m)\""], ["proof (prove)\nusing this:\n  (\\<lambda>k. if k + Suc m \\<le> m then 0 else 1 / q ^ (k + Suc m)) sums\n  (1 / (q - 1) * 1 / q ^ m)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k + Suc m \\<le> m then 0 else 1 / q ^ (k + Suc m)) sums\n    (1 / (q - 1) * 1 / q ^ m)", "."], ["proof (state)\nthis:\n  (\\<lambda>k. if k + Suc m \\<le> m then 0 else 1 / q ^ (k + Suc m)) sums\n  (1 / (q - 1) * 1 / q ^ m)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "also"], ["proof (state)\nthis:\n  (\\<lambda>k. if k + Suc m \\<le> m then 0 else 1 / q ^ (k + Suc m)) sums\n  (1 / (q - 1) * 1 / q ^ m)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "have \"?this \\<longleftrightarrow> (\\<lambda>k. if k \\<le> m then 0 else 1 / q ^ k) sums (1 / (q - 1) * 1 / q ^ m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k + Suc m \\<le> m then 0 else 1 / q ^ (k + Suc m)) sums\n    (1 / (q - 1) * 1 / q ^ m) =\n    (\\<lambda>k. if k \\<le> m then 0 else 1 / q ^ k) sums\n    (1 / (q - 1) * 1 / q ^ m)", "by (rule sums_zero_iff_shift) auto"], ["proof (state)\nthis:\n  (\\<lambda>k. if k + Suc m \\<le> m then 0 else 1 / q ^ (k + Suc m)) sums\n  (1 / (q - 1) * 1 / q ^ m) =\n  (\\<lambda>k. if k \\<le> m then 0 else 1 / q ^ k) sums\n  (1 / (q - 1) * 1 / q ^ m)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n) \\<le> ?g n\n 2. ?g sums (1 / (q - 1) * 1 / q ^ m)", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>k. if k \\<le> m then 0 else 1 / q ^ k) sums\n  (1 / (q - 1) * 1 / q ^ m)", "show \\<dots>"], ["proof (prove)\nusing this:\n  (\\<lambda>k. if k \\<le> m then 0 else 1 / q ^ k) sums\n  (1 / (q - 1) * 1 / q ^ m)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. if k \\<le> m then 0 else 1 / q ^ k) sums\n    (1 / (q - 1) * 1 / q ^ m)", "."], ["proof (state)\nthis:\n  (\\<lambda>k. if k \\<le> m then 0 else 1 / q ^ k) sums\n  (1 / (q - 1) * 1 / q ^ m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n)\n       \\<le> (if n \\<le> m then 0 else 1 / q ^ n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n)\n       \\<le> (if n \\<le> m then 0 else 1 / q ^ n)", "fix k :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n)\n       \\<le> (if n \\<le> m then 0 else 1 / q ^ n)", "have \"int k dvd fact m\" if \"k > 0\" \"k \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int k dvd fact m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int k dvd fact m", "have \"int k dvd int (fact m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int k dvd int (fact m)", "unfolding int_dvd_int_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. k dvd fact m", "using that"], ["proof (prove)\nusing this:\n  0 < k\n  k \\<le> m\n\ngoal (1 subgoal):\n 1. k dvd fact m", "by (simp add: dvd_fact)"], ["proof (state)\nthis:\n  int k dvd int (fact m)\n\ngoal (1 subgoal):\n 1. int k dvd fact m", "thus \"int k dvd fact m\""], ["proof (prove)\nusing this:\n  int k dvd int (fact m)\n\ngoal (1 subgoal):\n 1. int k dvd fact m", "unfolding of_nat_fact"], ["proof (prove)\nusing this:\n  int k dvd fact m\n\ngoal (1 subgoal):\n 1. int k dvd fact m", "by simp"], ["proof (state)\nthis:\n  int k dvd fact m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < k; k \\<le> m\\<rbrakk> \\<Longrightarrow> int k dvd fact m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (if n = 0 \\<or> int n dvd fact m then 0 else 1 / q ^ n)\n       \\<le> (if n \\<le> m then 0 else 1 / q ^ n)", "thus \"(if k = 0 \\<or> int k dvd fact m then 0 else 1 / q ^ k) \\<le>\n        (if k \\<le> m then 0 else 1 / q ^ k)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < k; k \\<le> m\\<rbrakk> \\<Longrightarrow> int k dvd fact m\n\ngoal (1 subgoal):\n 1. (if k = 0 \\<or> int k dvd fact m then 0 else 1 / q ^ k)\n    \\<le> (if k \\<le> m then 0 else 1 / q ^ k)", "using q_gt_1"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < k; k \\<le> m\\<rbrakk> \\<Longrightarrow> int k dvd fact m\n  1 < q\n\ngoal (1 subgoal):\n 1. (if k = 0 \\<or> int k dvd fact m then 0 else 1 / q ^ k)\n    \\<le> (if k \\<le> m then 0 else 1 / q ^ k)", "by auto"], ["proof (state)\nthis:\n  (if k = 0 \\<or> int k dvd fact m then 0 else 1 / q ^ k)\n  \\<le> (if k \\<le> m then 0 else 1 / q ^ k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma N_prime_mono:\n  assumes \"prime p\" \"prime p'\" \"p \\<le> p'\"\n  shows   \"N p \\<le> N p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N p \\<le> N p'", "using assms q_gt_1"], ["proof (prove)\nusing this:\n  prime p\n  prime p'\n  p \\<le> p'\n  1 < q\n\ngoal (1 subgoal):\n 1. N p \\<le> N p'", "by (auto simp add: N_prime field_simps nat_le_iff prime_ge_0_int)"], ["", "lemma N_prime_ge:\n  assumes \"prime p\"\n  shows   \"N p \\<ge> 1 / (q\\<^sup>2 * (q - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "have \"1 / (q ^ 2 * (q - 1)) = N 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) = N 2", "using q_gt_1"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) = N 2", "by (auto simp: N_prime N_1 field_simps power2_eq_square)"], ["proof (state)\nthis:\n  1 / (q\\<^sup>2 * (q - 1)) = N 2\n\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "also"], ["proof (state)\nthis:\n  1 / (q\\<^sup>2 * (q - 1)) = N 2\n\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "have \"\\<dots> \\<le> N p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N 2 \\<le> N p", "using assms"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. N 2 \\<le> N p", "by (intro N_prime_mono) (auto simp: prime_ge_2_int)"], ["proof (state)\nthis:\n  N 2 \\<le> N p\n\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "finally"], ["proof (chain)\npicking this:\n  1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "show ?thesis"], ["proof (prove)\nusing this:\n  1 / (q\\<^sup>2 * (q - 1)) \\<le> N p\n\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "."], ["proof (state)\nthis:\n  1 / (q\\<^sup>2 * (q - 1)) \\<le> N p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma N_prime_elem_ge:\n  assumes \"prime_elem p\"\n  shows   \"N p \\<ge> 1 / (q\\<^sup>2 * (q - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "proof (cases \"p \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> p \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p\n 2. \\<not> 0 \\<le> p \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "case True"], ["proof (state)\nthis:\n  0 \\<le> p\n\ngoal (2 subgoals):\n 1. 0 \\<le> p \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p\n 2. \\<not> 0 \\<le> p \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "with assms N_prime_ge"], ["proof (chain)\npicking this:\n  prime_elem p\n  prime ?p \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N ?p\n  0 \\<le> p", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_elem p\n  prime ?p \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N ?p\n  0 \\<le> p\n\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "by auto"], ["proof (state)\nthis:\n  1 / (q\\<^sup>2 * (q - 1)) \\<le> N p\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> p \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> p \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> p \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "with assms N_prime_ge[of \"-p\"]"], ["proof (chain)\npicking this:\n  prime_elem p\n  prime (- p) \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N (- p)\n  \\<not> 0 \\<le> p", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_elem p\n  prime (- p) \\<Longrightarrow> 1 / (q\\<^sup>2 * (q - 1)) \\<le> N (- p)\n  \\<not> 0 \\<le> p\n\ngoal (1 subgoal):\n 1. 1 / (q\\<^sup>2 * (q - 1)) \\<le> N p", "by auto"], ["proof (state)\nthis:\n  1 / (q\\<^sup>2 * (q - 1)) \\<le> N p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Next, we use this norm to derive a metric:\n\\<close>"], ["", "lift_definition dist :: \"fbint \\<Rightarrow> fbint \\<Rightarrow> real\" is\n  \"\\<lambda>x y. N (x - y)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma dist_self [simp]: \"dist x x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dist x x = 0", "by transfer simp"], ["", "lemma dist_sym [simp]: \"dist x y = dist y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dist x y = local.dist y x", "by transfer (simp add: N_minus_commute)"], ["", "lemma dist_pos: \"x \\<noteq> y \\<Longrightarrow> dist x y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> 0 < local.dist x y", "by transfer (use N_pos in simp)"], ["", "lemma dist_eq_0_iff [simp]: \"dist x y = 0 \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.dist x y = 0) = (x = y)", "using dist_pos[of x y]"], ["proof (prove)\nusing this:\n  x \\<noteq> y \\<Longrightarrow> 0 < local.dist x y\n\ngoal (1 subgoal):\n 1. (local.dist x y = 0) = (x = y)", "by (cases \"x = y\") auto"], ["", "lemma dist_triangle_ineq: \"dist x z \\<le> dist x y + dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dist x z \\<le> local.dist x y + local.dist y z", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x z y. N (x - z) \\<le> N (x - y) + N (y - z)", "fix x y z :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x z y. N (x - z) \\<le> N (x - y) + N (y - z)", "show \"N (x - z) \\<le> N (x - y) + N (y - z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (x - z) \\<le> N (x - y) + N (y - z)", "using N_triangle_ineq[of \"x - y\" \"y - z\"]"], ["proof (prove)\nusing this:\n  N (x - y + (y - z)) \\<le> N (x - y) + N (y - z)\n\ngoal (1 subgoal):\n 1. N (x - z) \\<le> N (x - y) + N (y - z)", "by simp"], ["proof (state)\nthis:\n  N (x - z) \\<le> N (x - y) + N (y - z)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Lastly, we show that the metric we defined indeed induces the Furstenberg topology.\n\\<close>"], ["", "theorem dist_induces_open:\n  \"open U \\<longleftrightarrow> (\\<forall>x\\<in>U. \\<exists>e>0. \\<forall>y. dist x y < e \\<longrightarrow> y \\<in> U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open U =\n    (\\<forall>x\\<in>U.\n        \\<exists>e>0.\n           \\<forall>y. local.dist x y < e \\<longrightarrow> y \\<in> U)", "proof (transfer, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e>0.\n                            \\<forall>y.\n                               N (x - y) < e \\<longrightarrow> y \\<in> U\n 2. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "fix U :: \"int set\" and x :: int"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e>0.\n                            \\<forall>y.\n                               N (x - y) < e \\<longrightarrow> y \\<in> U\n 2. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "assume *: \"\\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n\ngoal (2 subgoals):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e>0.\n                            \\<forall>y.\n                               N (x - y) < e \\<longrightarrow> y \\<in> U\n 2. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "assume \"x \\<in> U\""], ["proof (state)\nthis:\n  x \\<in> U\n\ngoal (2 subgoals):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e>0.\n                            \\<forall>y.\n                               N (x - y) < e \\<longrightarrow> y \\<in> U\n 2. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "with *"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n  x \\<in> U", "obtain b where b: \"b > 0\" \"arith_prog x b \\<subseteq> U\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>U. \\<exists>b>0. arith_prog x b \\<subseteq> U\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>0 < b; arith_prog x b \\<subseteq> U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 < b\n  arith_prog x b \\<subseteq> U\n\ngoal (2 subgoals):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e>0.\n                            \\<forall>y.\n                               N (x - y) < e \\<longrightarrow> y \\<in> U\n 2. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "define e where \"e = 1 / q ^ b\""], ["proof (state)\nthis:\n  e = 1 / q ^ b\n\ngoal (2 subgoals):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>b>0. arith_prog x b \\<subseteq> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e>0.\n                            \\<forall>y.\n                               N (x - y) < e \\<longrightarrow> y \\<in> U\n 2. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "show \"\\<exists>e>0. \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e>0. \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U", "proof (rule exI; safe?)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ?e1\n 2. \\<And>y. N (x - y) < ?e1 \\<Longrightarrow> y \\<in> U", "show \"e > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e", "using q_gt_1"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. 0 < e", "by (simp add: e_def)"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>y. N (x - y) < e \\<Longrightarrow> y \\<in> U", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. N (x - y) < e \\<Longrightarrow> y \\<in> U", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. N (x - y) < e \\<Longrightarrow> y \\<in> U", "assume \"N (x - y) < e\""], ["proof (state)\nthis:\n  N (x - y) < e\n\ngoal (1 subgoal):\n 1. \\<And>y. N (x - y) < e \\<Longrightarrow> y \\<in> U", "also"], ["proof (state)\nthis:\n  N (x - y) < e\n\ngoal (1 subgoal):\n 1. \\<And>y. N (x - y) < e \\<Longrightarrow> y \\<in> U", "have \"\\<dots> = 1 / q ^ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = 1 / q ^ b", "by fact"], ["proof (state)\nthis:\n  e = 1 / q ^ b\n\ngoal (1 subgoal):\n 1. \\<And>y. N (x - y) < e \\<Longrightarrow> y \\<in> U", "finally"], ["proof (chain)\npicking this:\n  N (x - y) < 1 / q ^ b", "have \"b dvd (x - y)\""], ["proof (prove)\nusing this:\n  N (x - y) < 1 / q ^ b\n\ngoal (1 subgoal):\n 1. int b dvd x - y", "by (rule N_lt_imp_dvd) fact"], ["proof (state)\nthis:\n  int b dvd x - y\n\ngoal (1 subgoal):\n 1. \\<And>y. N (x - y) < e \\<Longrightarrow> y \\<in> U", "hence \"y \\<in> arith_prog x b\""], ["proof (prove)\nusing this:\n  int b dvd x - y\n\ngoal (1 subgoal):\n 1. y \\<in> arith_prog x b", "by (auto simp: arith_prog_def cong_iff_dvd_diff dvd_diff_commute)"], ["proof (state)\nthis:\n  y \\<in> arith_prog x b\n\ngoal (1 subgoal):\n 1. \\<And>y. N (x - y) < e \\<Longrightarrow> y \\<in> U", "with b"], ["proof (chain)\npicking this:\n  0 < b\n  arith_prog x b \\<subseteq> U\n  y \\<in> arith_prog x b", "show \"y \\<in> U\""], ["proof (prove)\nusing this:\n  0 < b\n  arith_prog x b \\<subseteq> U\n  y \\<in> arith_prog x b\n\ngoal (1 subgoal):\n 1. y \\<in> U", "by blast"], ["proof (state)\nthis:\n  y \\<in> U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e>0. \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "fix U :: \"int set\" and x :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "assume *: \"\\<forall>x\\<in>U. \\<exists>e>0. \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>U.\n     \\<exists>e>0. \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "assume \"x \\<in> U\""], ["proof (state)\nthis:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "with *"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>U.\n     \\<exists>e>0. \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U\n  x \\<in> U", "obtain e where e: \"e > 0\" \"\\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>U.\n     \\<exists>e>0. \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>0 < e;\n         \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 < e\n  \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "have \"eventually (\\<lambda>N. 1 / (q - 1) * 1 / q ^ N < e) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F N in sequentially. 1 / (q - 1) * 1 / q ^ N < e", "using q_gt_1 \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  1 < q\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F N in sequentially. 1 / (q - 1) * 1 / q ^ N < e", "by real_asymp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F N in sequentially. 1 / (q - 1) * 1 / q ^ N < e\n\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F N in sequentially. 1 / (q - 1) * 1 / q ^ N < e", "obtain m where m: \"1 / (q - 1) * 1 / q ^ m < e\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F N in sequentially. 1 / (q - 1) * 1 / q ^ N < e\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        1 / (q - 1) * 1 / q ^ m < e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eventually_at_top_linorder)"], ["proof (state)\nthis:\n  1 / (q - 1) * 1 / q ^ m < e\n\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "define b :: nat where \"b = fact m\""], ["proof (state)\nthis:\n  b = fact m\n\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "have \"arith_prog x b \\<subseteq> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arith_prog x b \\<subseteq> U", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> arith_prog x b \\<Longrightarrow> xa \\<in> U", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> arith_prog x b \\<Longrightarrow> xa \\<in> U", "assume \"y \\<in> arith_prog x b\""], ["proof (state)\nthis:\n  y \\<in> arith_prog x b\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> arith_prog x b \\<Longrightarrow> xa \\<in> U", "show \"y \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> U", "proof (cases \"y = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "case False"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "from \\<open>y \\<in> arith_prog x b\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> arith_prog x b", "obtain n where y: \"y = x + int b * n\""], ["proof (prove)\nusing this:\n  y \\<in> arith_prog x b\n\ngoal (1 subgoal):\n 1. (\\<And>n. y = x + int b * n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: arith_prog_altdef)"], ["proof (state)\nthis:\n  y = x + int b * n\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "from y and \\<open>y \\<noteq> x\\<close>"], ["proof (chain)\npicking this:\n  y = x + int b * n\n  y \\<noteq> x", "have [simp]: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y = x + int b * n\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "have \"N (x - y) = N (int b * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (x - y) = N (int b * n)", "by (simp add: y)"], ["proof (state)\nthis:\n  N (x - y) = N (int b * n)\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "also"], ["proof (state)\nthis:\n  N (x - y) = N (int b * n)\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "have \"\\<dots> \\<le> N (int b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (int b * n) \\<le> N (int b)", "by (rule N_dvd_mono) auto"], ["proof (state)\nthis:\n  N (int b * n) \\<le> N (int b)\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "also"], ["proof (state)\nthis:\n  N (int b * n) \\<le> N (int b)\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "have \"\\<dots> \\<le> 1 / (q - 1) * 1 / q ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (int b) \\<le> 1 / (q - 1) * 1 / q ^ m", "using N_fact_le"], ["proof (prove)\nusing this:\n  N (fact ?m) \\<le> 1 / (q - 1) * 1 / q ^ ?m\n\ngoal (1 subgoal):\n 1. N (int b) \\<le> 1 / (q - 1) * 1 / q ^ m", "by (simp add: b_def)"], ["proof (state)\nthis:\n  N (int b) \\<le> 1 / (q - 1) * 1 / q ^ m\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "also"], ["proof (state)\nthis:\n  N (int b) \\<le> 1 / (q - 1) * 1 / q ^ m\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "have \"\\<dots> < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (q - 1) * 1 / q ^ m < e", "by fact"], ["proof (state)\nthis:\n  1 / (q - 1) * 1 / q ^ m < e\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> U\n 2. y \\<noteq> x \\<Longrightarrow> y \\<in> U", "finally"], ["proof (chain)\npicking this:\n  N (x - y) < e", "show \"y \\<in> U\""], ["proof (prove)\nusing this:\n  N (x - y) < e\n\ngoal (1 subgoal):\n 1. y \\<in> U", "using e"], ["proof (prove)\nusing this:\n  N (x - y) < e\n  0 < e\n  \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U\n\ngoal (1 subgoal):\n 1. y \\<in> U", "by auto"], ["proof (state)\nthis:\n  y \\<in> U\n\ngoal (1 subgoal):\n 1. y = x \\<Longrightarrow> y \\<in> U", "qed (use \\<open>x \\<in> U\\<close> in auto)"], ["proof (state)\nthis:\n  y \\<in> U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arith_prog x b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "moreover"], ["proof (state)\nthis:\n  arith_prog x b \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "have \"b > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b", "by (auto simp: b_def)"], ["proof (state)\nthis:\n  0 < b\n\ngoal (1 subgoal):\n 1. \\<And>U x.\n       \\<lbrakk>\\<forall>x\\<in>U.\n                   \\<exists>e>0.\n                      \\<forall>y. N (x - y) < e \\<longrightarrow> y \\<in> U;\n        x \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b>0. arith_prog x b \\<subseteq> U", "ultimately"], ["proof (chain)\npicking this:\n  arith_prog x b \\<subseteq> U\n  0 < b", "show \"\\<exists>b>0. arith_prog x b \\<subseteq> U\""], ["proof (prove)\nusing this:\n  arith_prog x b \\<subseteq> U\n  0 < b\n\ngoal (1 subgoal):\n 1. \\<exists>b>0. arith_prog x b \\<subseteq> U", "by blast"], ["proof (state)\nthis:\n  \\<exists>b>0. arith_prog x b \\<subseteq> U\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n  We now show that the Furstenberg space is a metric space with this metric (with \\<open>q = 2\\<close>),\n  which essentially only amounts to plugging together all the results from above.\n\\<close>"], ["", "interpretation fb: fbnorm 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. fbnorm 2", "by standard auto"], ["", "instantiation fbint :: dist\nbegin"], ["", "definition dist_fbint where \"dist_fbint = fb.dist\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fbint, dist_class)", ".."], ["", "end"], ["", "instantiation fbint :: uniformity_dist\nbegin"], ["", "definition uniformity_fbint :: \"(fbint \\<times> fbint) filter\" where\n  \"uniformity_fbint = (INF e\\<in>{0 <..}. principal {(x, y). dist x y < e})\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fbint, uniformity_dist_class)", "by standard (simp add: uniformity_fbint_def)"], ["", "end"], ["", "instance fbint :: open_uniformity"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fbint, open_uniformity_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)", "fix U :: \"fbint set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)", "show \"open U = (\\<forall>x\\<in>U. eventually (\\<lambda>(x',y). x' = x \\<longrightarrow> y \\<in> U) uniformity)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open U =\n    (\\<forall>x\\<in>U.\n        \\<forall>\\<^sub>F (x', y) in uniformity.\n           x' = x \\<longrightarrow> y \\<in> U)", "unfolding eventually_uniformity_metric dist_fbint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. open U =\n    (\\<forall>x\\<in>U.\n        \\<exists>e>0.\n           \\<forall>xa y.\n              fb.dist xa y < e \\<longrightarrow>\n              (case (xa, y) of\n               (x', y) \\<Rightarrow> x' = x \\<longrightarrow> y \\<in> U))", "using fb.dist_induces_open"], ["proof (prove)\nusing this:\n  open ?U =\n  (\\<forall>x\\<in>?U.\n      \\<exists>e>0.\n         \\<forall>y. fb.dist x y < e \\<longrightarrow> y \\<in> ?U)\n\ngoal (1 subgoal):\n 1. open U =\n    (\\<forall>x\\<in>U.\n        \\<exists>e>0.\n           \\<forall>xa y.\n              fb.dist xa y < e \\<longrightarrow>\n              (case (xa, y) of\n               (x', y) \\<Rightarrow> x' = x \\<longrightarrow> y \\<in> U))", "by simp"], ["proof (state)\nthis:\n  open U =\n  (\\<forall>x\\<in>U.\n      \\<forall>\\<^sub>F (x', y) in uniformity.\n         x' = x \\<longrightarrow> y \\<in> U)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance fbint :: metric_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fbint, metric_space_class)", "by standard (use fb.dist_triangle_ineq in \\<open>auto simp: dist_fbint_def\\<close>)"], ["", "text \\<open>\n  In particular, we can now show that the sequence \\<open>n!\\<close> tends to 0 in the Furstenberg topology:\n\\<close>"], ["", "lemma tendsto_fbint_fact: \"(\\<lambda>n. fbint (fact n)) \\<longlonglongrightarrow> fbint 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. fbint (fact n)) \\<longlonglongrightarrow> fbint 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. fbint (fact n)) \\<longlonglongrightarrow> fbint 0", "have \"(\\<lambda>n. dist (fbint (fact n)) (fbint 0)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. dist (fbint (fact n)) (fbint 0))\n    \\<longlonglongrightarrow> 0", "proof (rule tendsto_sandwich[OF always_eventually always_eventually]; safe?)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. ?f1 x \\<le> dist (fbint (fact x)) (fbint 0)\n 2. \\<And>x. dist (fbint (fact x)) (fbint 0) \\<le> ?h1 x\n 3. ?f1 \\<longlonglongrightarrow> 0\n 4. ?h1 \\<longlonglongrightarrow> 0", "fix n :: nat"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. ?f1 x \\<le> dist (fbint (fact x)) (fbint 0)\n 2. \\<And>x. dist (fbint (fact x)) (fbint 0) \\<le> ?h1 x\n 3. ?f1 \\<longlonglongrightarrow> 0\n 4. ?h1 \\<longlonglongrightarrow> 0", "show \"dist (fbint (fact n)) (fbint 0) \\<le> 1 / 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (fbint (fact n)) (fbint 0) \\<le> 1 / 2 ^ n", "unfolding dist_fbint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fb.dist (fbint (fact n)) (fbint 0) \\<le> 1 / 2 ^ n", "by (transfer fixing: n) (use fb.N_fact_le[of n] in simp)"], ["proof (state)\nthis:\n  dist (fbint (fact n)) (fbint 0) \\<le> 1 / 2 ^ n\n\ngoal (3 subgoals):\n 1. \\<And>x. ?f1 x \\<le> dist (fbint (fact x)) (fbint 0)\n 2. ?f1 \\<longlonglongrightarrow> 0\n 3. (\\<lambda>x. 1 / 2 ^ x) \\<longlonglongrightarrow> 0", "show \"dist (fbint (fact n)) (fbint 0) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> dist (fbint (fact n)) (fbint 0)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> dist (fbint (fact n)) (fbint 0)\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. 0) \\<longlonglongrightarrow> 0\n 2. (\\<lambda>x. 1 / 2 ^ x) \\<longlonglongrightarrow> 0", "show \"(\\<lambda>n. 1 / 2 ^ n :: real) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / 2 ^ n) \\<longlonglongrightarrow> 0", "by real_asymp"], ["proof (state)\nthis:\n  (\\<lambda>n. 1 / 2 ^ n) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. 0) \\<longlonglongrightarrow> 0", "qed simp_all"], ["proof (state)\nthis:\n  (\\<lambda>n. dist (fbint (fact n)) (fbint 0)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. fbint (fact n)) \\<longlonglongrightarrow> fbint 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. dist (fbint (fact n)) (fbint 0)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. fbint (fact n)) \\<longlonglongrightarrow> fbint 0", "using tendsto_dist_iff"], ["proof (prove)\nusing this:\n  (\\<lambda>n. dist (fbint (fact n)) (fbint 0)) \\<longlonglongrightarrow> 0\n  (?f \\<longlongrightarrow> ?l) ?F =\n  ((\\<lambda>x. dist (?f x) ?l) \\<longlongrightarrow> 0) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. fbint (fact n)) \\<longlonglongrightarrow> fbint 0", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>n. fbint (fact n)) \\<longlonglongrightarrow> fbint 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}