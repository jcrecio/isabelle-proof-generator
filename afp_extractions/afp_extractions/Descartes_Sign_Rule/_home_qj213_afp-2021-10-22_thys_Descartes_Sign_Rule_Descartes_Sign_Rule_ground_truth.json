{"file_name": "/home/qj213/afp-2021-10-22/thys/Descartes_Sign_Rule/Descartes_Sign_Rule.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Descartes_Sign_Rule", "problem_names": ["lemma op_plus_0: \"((+) (0 :: 'a :: monoid_add)) = id\"", "lemma filter_dropWhile: \n  \"filter (\\<lambda>x. \\<not>P x) (dropWhile P xs) = filter (\\<lambda>x. \\<not>P x) xs\"", "lemma pos_root_exI:\n  assumes \"poly p 0 * lead_coeff p < (0 :: real)\"\n  obtains x where \"x > 0\" \"poly p x = 0\"", "lemma reduce_root_pCons: \n  \"reduce_root a (pCons c p) = pCons c (smult a (reduce_root a p))\"", "lemma reduce_root_nonzero [simp]: \n  \"a \\<noteq> 0 \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> reduce_root a p \\<noteq> (0 :: 'a :: idom poly)\"", "lemma length_psums [simp]: \"length (psums xs) = length xs\"", "lemma psums_Cons: \n  \"psums (x#xs) = (x :: 'a :: semigroup_add) # map ((+) x) (psums xs)\"", "lemma last_psums: \n  \"(xs :: 'a :: monoid_add list) \\<noteq> [] \\<Longrightarrow> last (psums xs) = sum_list xs\"", "lemma psums_0_Cons [simp]: \n  \"psums (0#xs :: 'a :: monoid_add list) = 0 # psums xs\"", "lemma map_uminus_psums: \n  fixes xs :: \"'a :: ab_group_add list\"\n  shows \"map uminus (psums xs) = psums (map uminus xs)\"", "lemma psums_replicate_0_append:\n  \"psums (replicate n (0 :: 'a :: monoid_add) @ xs) = \n     replicate n 0 @ psums xs\"", "lemma psums_nth: \"n < length xs \\<Longrightarrow> psums xs ! n = (\\<Sum>i\\<le>n. xs ! i)\"", "lemma sign_changes_Nil [simp]: \"sign_changes [] = 0\"", "lemma sign_changes_singleton [simp]: \"sign_changes [x] = 0\"", "lemma sign_changes_cong:\n  assumes \"map sgn xs = map sgn ys\"\n  shows   \"sign_changes xs = sign_changes ys\"", "lemma sign_changes_Cons_ge: \"sign_changes (x # xs) \\<ge> sign_changes xs\"", "lemma sign_changes_Cons_Cons_different: \n  fixes x y :: \"'a :: linordered_idom\"\n  assumes \"x * y < 0\"\n  shows \"sign_changes (x # y # xs) = 1 + sign_changes (y # xs)\"", "lemma sign_changes_Cons_Cons_same: \n  fixes x y :: \"'a :: linordered_idom\"\n  shows \"x * y > 0 \\<Longrightarrow> sign_changes (x # y # xs) = sign_changes (y # xs)\"", "lemma sign_changes_0_Cons [simp]: \n  \"sign_changes (0 # xs :: 'a :: idom_abs_sgn list) = sign_changes xs\"", "lemma sign_changes_two: \n  fixes x y :: \"'a :: linordered_idom\"\n  shows \"sign_changes [x,y] = \n           (if x > 0 \\<and> y < 0 \\<or> x < 0 \\<and> y > 0 then 1 else 0)\"", "lemma sign_changes_induct [case_names nil sing zero nonzero]:\n  assumes \"P []\" \"\\<And>x. P [x]\" \"\\<And>xs. P xs \\<Longrightarrow> P (0#xs)\"\n          \"\\<And>x y xs. x \\<noteq> 0 \\<Longrightarrow> P ((x + y) # xs) \\<Longrightarrow> P (x # y # xs)\"\n  shows   \"P xs\"", "lemma sign_changes_filter: \n  fixes xs :: \"'a :: linordered_idom list\"\n  shows \"sign_changes (filter (\\<lambda>x. x \\<noteq> 0) xs) = sign_changes xs\"", "lemma sign_changes_Cons_Cons_0: \n  fixes xs :: \"'a :: linordered_idom list\"\n  shows \"sign_changes (x # 0 # xs) = sign_changes (x # xs)\"", "lemma sign_changes_uminus: \n  fixes xs :: \"'a :: linordered_idom list\"\n  shows   \"sign_changes (map uminus xs) = sign_changes xs\"", "lemma sign_changes_replicate: \"sign_changes (replicate n x) = 0\"", "lemma sign_changes_decompose:\n  assumes \"x \\<noteq> (0 :: 'a :: linordered_idom)\"\n  shows   \"sign_changes (xs @ x # ys) = \n             sign_changes (xs @ [x]) + sign_changes (x # ys)\"", "lemma even_sign_changes_iff:\n  assumes \"xs \\<noteq> ([] :: 'a :: linordered_idom list)\" \"hd xs \\<noteq> 0\" \"last xs \\<noteq> 0\"\n  shows   \"even (sign_changes xs) \\<longleftrightarrow> sgn (hd xs) = sgn (last xs)\"", "lemma arthan_wlog [consumes 3, case_names nonneg lift]:\n  fixes xs :: \"'a :: linordered_idom list\"\n  assumes \"xs \\<noteq> []\" \"last xs \\<noteq> 0\" \"x + y + sum_list xs = 0\"\n  assumes \"\\<And>x y xs. xs \\<noteq> [] \\<Longrightarrow> last xs \\<noteq> 0 \\<Longrightarrow> \n               x + y + sum_list xs = 0 \\<Longrightarrow> x \\<ge> 0 \\<Longrightarrow> P x y xs\"\n  assumes \"\\<And>x y xs. xs \\<noteq> [] \\<Longrightarrow> P x y xs \\<Longrightarrow> P (-x) (-y) (map uminus xs)\"\n  shows   \"P x y xs\"", "lemma arthan_aux1:\n  fixes xs :: \"'a :: {linordered_idom} list\"\n  assumes \"xs \\<noteq> []\" \"last xs \\<noteq> 0\" \"x + y + sum_list xs = 0\"\n  defines \"v \\<equiv> \\<lambda>xs. int (sign_changes xs)\"\n  shows \"v (x # y # xs) - v ((x + y) # xs) \\<ge> \n             v (psums (x # y # xs)) - v (psums ((x + y) # xs)) \\<and> \n         even (v (x # y # xs) - v ((x + y) # xs) - \n                  (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\"", "lemma arthan:\n  fixes xs :: \"'a :: linordered_idom list\"\n  assumes \"xs \\<noteq> []\" \"last xs \\<noteq> 0\" \"sum_list xs = 0\"\n  shows   \"sign_changes xs > sign_changes (psums xs) \\<and> \n           odd (sign_changes xs - sign_changes (psums xs))\"", "lemma finite_roots_with [simp]: \n  \"(p :: 'a :: linordered_idom poly) \\<noteq> 0 \\<Longrightarrow> finite (roots_with P p)\"", "lemma count_roots_with_times_root:\n  assumes \"p \\<noteq> 0\" \"P (a :: 'a :: linordered_idom)\"\n  shows   \"count_roots_with P ([:a, -1:] * p) = Suc (count_roots_with P p)\"", "lemma sign_changes_coeff_sign_changes:\n  assumes \"Poly xs = (p :: 'a :: linordered_idom poly)\"\n  shows   \"sign_changes xs = coeff_sign_changes p\"", "lemma coeff_sign_changes_reduce_root: \n  assumes \"a > (0 :: 'a :: linordered_idom)\"\n  shows   \"coeff_sign_changes (reduce_root a p) = coeff_sign_changes p\"", "lemma coeff_sign_changes_smult: \n  assumes \"a > (0 :: 'a :: linordered_idom)\"\n  shows   \"coeff_sign_changes (smult a p) = coeff_sign_changes p\"", "lemma odd_coeff_sign_changes_imp_pos_roots_aux:\n  assumes [simp]: \"p \\<noteq> (0 :: real poly)\" \"poly p 0 \\<noteq> 0\"\n  assumes \"odd (coeff_sign_changes p)\"\n  obtains x where \"x > 0\" \"poly p x = 0\"", "lemma odd_coeff_sign_changes_imp_pos_roots:\n  assumes \"p \\<noteq> (0 :: real poly)\"\n  assumes \"odd (coeff_sign_changes p)\"\n  obtains x where \"x > 0\" \"poly p x = 0\"", "lemma coeff_poly_times_one_minus_x:\n  fixes g :: \"'a :: linordered_idom poly\"\n  shows \"coeff g n = (\\<Sum>i\\<le>n. coeff (g * [:1, -1:]) i)\"", "lemma Poly_times_one_minus_x_eq_psums:\n  fixes xs :: \"'a :: linordered_idom list\"\n  assumes [simp]: \"length xs = length ys\"\n  assumes \"Poly xs = Poly ys * [:1, -1:]\"\n  shows   \"ys = psums xs\"", "lemma sign_changes_poly_times_one_minus_x:\n  fixes g :: \"'a :: linordered_idom poly\" and a :: 'a\n  assumes nz: \"g \\<noteq> 0\"\n  defines \"v \\<equiv> coeff_sign_changes\"\n  shows \"v ([:1, -1:] * g) - v g > 0 \\<and> odd (v ([:1, -1:] * g) - v g)\"", "lemma sign_changes_poly_times_root_minus_x:\n  fixes g :: \"'a :: linordered_idom poly\" and a :: 'a\n  assumes nz: \"g \\<noteq> 0\" and pos: \"a > 0\"\n  defines \"v \\<equiv> coeff_sign_changes\"\n  shows \"v ([:a, -1:] * g) - v g > 0 \\<and> odd (v ([:a, -1:] * g) - v g)\"", "lemma descartes_sign_rule_aux:\n  fixes p :: \"real poly\"\n  assumes \"p \\<noteq> 0\"\n  shows   \"coeff_sign_changes p \\<ge> count_pos_roots p \\<and> \n           even (coeff_sign_changes p - count_pos_roots p)\"", "theorem descartes_sign_rule:\n  fixes p :: \"real poly\"\n  assumes \"p \\<noteq> 0\"\n  shows \"\\<exists>d. even d \\<and> coeff_sign_changes p = count_pos_roots p + d\""], "translations": [["", "lemma op_plus_0: \"((+) (0 :: 'a :: monoid_add)) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) (0::'a) = id", "by auto"], ["", "lemma filter_dropWhile: \n  \"filter (\\<lambda>x. \\<not>P x) (dropWhile P xs) = filter (\\<lambda>x. \\<not>P x) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. \\<not> P x) (dropWhile P xs) =\n    filter (\\<lambda>x. \\<not> P x) xs", "by (induction xs) simp_all"], ["", "subsection \\<open>Polynomials\\<close>"], ["", "text\\<open>\n  A real polynomial whose leading and constant coefficients have opposite\n  non-zero signs must have a positive root.\n\\<close>"], ["", "lemma pos_root_exI:\n  assumes \"poly p 0 * lead_coeff p < (0 :: real)\"\n  obtains x where \"x > 0\" \"poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have P: \"\\<exists>x>0. poly p x = (0::real)\" if \"lead_coeff p > 0\" \"poly p 0 < 0\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>0. poly p x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>0. poly p x = 0", "note that(1)"], ["proof (state)\nthis:\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<exists>x>0. poly p x = 0", "also"], ["proof (state)\nthis:\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<exists>x>0. poly p x = 0", "from poly_pinfty_gt_lc[OF \\<open>lead_coeff p > 0\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x", "obtain x0 \n      where \"\\<And>x. x \\<ge> x0 \\<Longrightarrow> poly p x \\<ge> lead_coeff p\""], ["proof (prove)\nusing this:\n  \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x\n\ngoal (1 subgoal):\n 1. (\\<And>x0.\n        (\\<And>x.\n            x0 \\<le> x \\<Longrightarrow>\n            lead_coeff p \\<le> poly p x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x0 \\<le> ?x \\<Longrightarrow> lead_coeff p \\<le> poly p ?x\n\ngoal (1 subgoal):\n 1. \\<exists>x>0. poly p x = 0", "hence \"poly p (max x0 1) \\<ge> lead_coeff p\""], ["proof (prove)\nusing this:\n  x0 \\<le> ?x \\<Longrightarrow> lead_coeff p \\<le> poly p ?x\n\ngoal (1 subgoal):\n 1. lead_coeff p \\<le> poly p (max x0 1)", "by auto"], ["proof (state)\nthis:\n  lead_coeff p \\<le> poly p (max x0 1)\n\ngoal (1 subgoal):\n 1. \\<exists>x>0. poly p x = 0", "finally"], ["proof (chain)\npicking this:\n  0 < poly p (max x0 1)", "have \"poly p (max x0 1) > 0\""], ["proof (prove)\nusing this:\n  0 < poly p (max x0 1)\n\ngoal (1 subgoal):\n 1. 0 < poly p (max x0 1)", "."], ["proof (state)\nthis:\n  0 < poly p (max x0 1)\n\ngoal (1 subgoal):\n 1. \\<exists>x>0. poly p x = 0", "with that"], ["proof (chain)\npicking this:\n  0 < lead_coeff p\n  poly p 0 < 0\n  0 < poly p (max x0 1)", "have \"\\<exists>x. x > 0 \\<and> x < max x0 1 \\<and> poly p x = 0\""], ["proof (prove)\nusing this:\n  0 < lead_coeff p\n  poly p 0 < 0\n  0 < poly p (max x0 1)\n\ngoal (1 subgoal):\n 1. \\<exists>x>0. x < max x0 1 \\<and> poly p x = 0", "by (intro poly_IVT mult_neg_pos) auto"], ["proof (state)\nthis:\n  \\<exists>x>0. x < max x0 1 \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>0. poly p x = 0", "thus \"\\<exists>x>0. poly p x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>x>0. x < max x0 1 \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>0. poly p x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x>0. poly p x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < lead_coeff ?p; poly ?p 0 < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>0. poly ?p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"lead_coeff p > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < lead_coeff p \\<Longrightarrow> thesis\n 2. \\<not> 0 < lead_coeff p \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  0 < lead_coeff p\n\ngoal (2 subgoals):\n 1. 0 < lead_coeff p \\<Longrightarrow> thesis\n 2. \\<not> 0 < lead_coeff p \\<Longrightarrow> thesis", "with assms"], ["proof (chain)\npicking this:\n  poly p 0 * lead_coeff p < 0\n  0 < lead_coeff p", "have \"poly p 0 < 0\""], ["proof (prove)\nusing this:\n  poly p 0 * lead_coeff p < 0\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. poly p 0 < 0", "by (auto simp: mult_less_0_iff)"], ["proof (state)\nthis:\n  poly p 0 < 0\n\ngoal (2 subgoals):\n 1. 0 < lead_coeff p \\<Longrightarrow> thesis\n 2. \\<not> 0 < lead_coeff p \\<Longrightarrow> thesis", "from P[OF True this] that"], ["proof (chain)\npicking this:\n  \\<exists>x>0. poly p x = 0\n  \\<lbrakk>0 < ?x; poly p ?x = 0\\<rbrakk> \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x>0. poly p x = 0\n  \\<lbrakk>0 < ?x; poly p ?x = 0\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lead_coeff p \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < lead_coeff p \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lead_coeff p \\<Longrightarrow> thesis", "from False assms"], ["proof (chain)\npicking this:\n  \\<not> 0 < lead_coeff p\n  poly p 0 * lead_coeff p < 0", "have \"poly (-p) 0 < 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < lead_coeff p\n  poly p 0 * lead_coeff p < 0\n\ngoal (1 subgoal):\n 1. poly (- p) 0 < 0", "by (auto simp: mult_less_0_iff)"], ["proof (state)\nthis:\n  poly (- p) 0 < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lead_coeff p \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  poly (- p) 0 < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lead_coeff p \\<Longrightarrow> thesis", "from assms"], ["proof (chain)\npicking this:\n  poly p 0 * lead_coeff p < 0", "have \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly p 0 * lead_coeff p < 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lead_coeff p \\<Longrightarrow> thesis", "with False"], ["proof (chain)\npicking this:\n  \\<not> 0 < lead_coeff p\n  p \\<noteq> 0", "have \"lead_coeff (-p) > 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < lead_coeff p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff (- p)", "by (cases rule: linorder_cases[of \"lead_coeff p\" 0]) \n         (simp_all add:)"], ["proof (state)\nthis:\n  0 < lead_coeff (- p)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lead_coeff p \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  poly (- p) 0 < 0\n  0 < lead_coeff (- p)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (- p) 0 < 0\n  0 < lead_coeff (- p)\n\ngoal (1 subgoal):\n 1. thesis", "using that P[of \"-p\"]"], ["proof (prove)\nusing this:\n  poly (- p) 0 < 0\n  0 < lead_coeff (- p)\n  \\<lbrakk>0 < ?x; poly p ?x = 0\\<rbrakk> \\<Longrightarrow> thesis\n  \\<lbrakk>0 < lead_coeff (- p); poly (- p) 0 < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>0. poly (- p) x = 0\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Substitute $X$ with $aX$ in a polynomial $p(X)$. This turns all the $X - a$ factors in $p$\n  into factors of the form $X - 1$.\n\\<close>"], ["", "definition reduce_root where\n  \"reduce_root a p = pcompose p [:0, a:]\""], ["", "lemma reduce_root_pCons: \n  \"reduce_root a (pCons c p) = pCons c (smult a (reduce_root a p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_root a (pCons c p) = pCons c (smult a (reduce_root a p))", "by (simp add: reduce_root_def pcompose_pCons)"], ["", "lemma reduce_root_nonzero [simp]: \n  \"a \\<noteq> 0 \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> reduce_root a p \\<noteq> (0 :: 'a :: idom poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> reduce_root a p \\<noteq> 0", "unfolding reduce_root_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> p \\<circ>\\<^sub>p [:0::'a, a:] \\<noteq> 0", "using pcompose_eq_0[of p \"[:0, a:]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<circ>\\<^sub>p [:0::'a, a:] = 0;\n   0 < degree [:0::'a, a:]\\<rbrakk>\n  \\<Longrightarrow> p = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> p \\<circ>\\<^sub>p [:0::'a, a:] \\<noteq> 0", "by auto"], ["", "subsection \\<open>List of partial sums\\<close>"], ["", "text \\<open>\n  We first define, for a given list, the list of accumulated partial sums from left to right: \n  the list @{term \"psums xs\"} has as its $i$-th entry $\\sum_{j=0}^i \\mathrm{xs}_i$.\n\\<close>"], ["", "fun psums where\n  \"psums [] = []\"\n| \"psums [x] = [x]\"\n| \"psums (x#y#xs) = x # psums ((x+y) # xs)\""], ["", "lemma length_psums [simp]: \"length (psums xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (psums xs) = length xs", "by (induction xs rule: psums.induct) simp_all"], ["", "lemma psums_Cons: \n  \"psums (x#xs) = (x :: 'a :: semigroup_add) # map ((+) x) (psums xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. psums (x # xs) = x # map ((+) x) (psums xs)", "by (induction xs rule: psums.induct) (simp_all add: algebra_simps)"], ["", "lemma last_psums: \n  \"(xs :: 'a :: monoid_add list) \\<noteq> [] \\<Longrightarrow> last (psums xs) = sum_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> last (psums xs) = sum_list xs", "by (induction xs rule: psums.induct) \n     (auto simp add: add.assoc [symmetric] psums_Cons o_def)"], ["", "lemma psums_0_Cons [simp]: \n  \"psums (0#xs :: 'a :: monoid_add list) = 0 # psums xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. psums ((0::'a) # xs) = (0::'a) # psums xs", "by (induction xs rule: psums.induct) (simp_all add: algebra_simps)"], ["", "lemma map_uminus_psums: \n  fixes xs :: \"'a :: ab_group_add list\"\n  shows \"map uminus (psums xs) = psums (map uminus xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map uminus (psums xs) = psums (map uminus xs)", "by (induction xs rule: psums.induct) (simp_all)"], ["", "lemma psums_replicate_0_append:\n  \"psums (replicate n (0 :: 'a :: monoid_add) @ xs) = \n     replicate n 0 @ psums xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. psums (replicate n (0::'a) @ xs) = replicate n (0::'a) @ psums xs", "by (induction n) (simp_all add: psums_Cons op_plus_0)"], ["", "lemma psums_nth: \"n < length xs \\<Longrightarrow> psums xs ! n = (\\<Sum>i\\<le>n. xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow> psums xs ! n = sum ((!) xs) {..n}", "proof (induction xs arbitrary: n rule: psums.induct[case_names Nil sng rec])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       n < length [] \\<Longrightarrow> psums [] ! n = sum ((!) []) {..n}\n 2. \\<And>x n.\n       n < length [x] \\<Longrightarrow> psums [x] ! n = sum ((!) [x]) {..n}\n 3. \\<And>x y xs n.\n       \\<lbrakk>\\<And>n.\n                   n < length ((x + y) # xs) \\<Longrightarrow>\n                   psums ((x + y) # xs) ! n =\n                   sum ((!) ((x + y) # xs)) {..n};\n        n < length (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> psums (x # y # xs) ! n =\n                         sum ((!) (x # y # xs)) {..n}", "case (rec x y xs n)"], ["proof (state)\nthis:\n  ?n < length ((x + y) # xs) \\<Longrightarrow>\n  psums ((x + y) # xs) ! ?n = sum ((!) ((x + y) # xs)) {..?n}\n  n < length (x # y # xs)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       n < length [] \\<Longrightarrow> psums [] ! n = sum ((!) []) {..n}\n 2. \\<And>x n.\n       n < length [x] \\<Longrightarrow> psums [x] ! n = sum ((!) [x]) {..n}\n 3. \\<And>x y xs n.\n       \\<lbrakk>\\<And>n.\n                   n < length ((x + y) # xs) \\<Longrightarrow>\n                   psums ((x + y) # xs) ! n =\n                   sum ((!) ((x + y) # xs)) {..n};\n        n < length (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> psums (x # y # xs) ! n =\n                         sum ((!) (x # y # xs)) {..n}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "from Suc"], ["proof (chain)\npicking this:\n  n = Suc m", "have \"psums (x # y # xs) ! n = psums ((x+y) # xs) ! m\""], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. psums (x # y # xs) ! n = psums ((x + y) # xs) ! m", "by simp"], ["proof (state)\nthis:\n  psums (x # y # xs) ! n = psums ((x + y) # xs) ! m\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "also"], ["proof (state)\nthis:\n  psums (x # y # xs) ! n = psums ((x + y) # xs) ! m\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "from rec.prems Suc"], ["proof (chain)\npicking this:\n  n < length (x # y # xs)\n  n = Suc m", "have \"\\<dots> = (\\<Sum>i\\<le>m. ((x+y) # xs) ! i)\""], ["proof (prove)\nusing this:\n  n < length (x # y # xs)\n  n = Suc m\n\ngoal (1 subgoal):\n 1. psums ((x + y) # xs) ! m = sum ((!) ((x + y) # xs)) {..m}", "by (intro rec.IH) simp_all"], ["proof (state)\nthis:\n  psums ((x + y) # xs) ! m = sum ((!) ((x + y) # xs)) {..m}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "also"], ["proof (state)\nthis:\n  psums ((x + y) # xs) ! m = sum ((!) ((x + y) # xs)) {..m}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "have \"\\<dots> = x + y + (\\<Sum>i=1..m. (y#xs) ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((!) ((x + y) # xs)) {..m} = x + y + sum ((!) (y # xs)) {1..m}", "by (auto simp: atLeast0AtMost [symmetric] sum.atLeast_Suc_atMost[of 0])"], ["proof (state)\nthis:\n  sum ((!) ((x + y) # xs)) {..m} = x + y + sum ((!) (y # xs)) {1..m}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "also"], ["proof (state)\nthis:\n  sum ((!) ((x + y) # xs)) {..m} = x + y + sum ((!) (y # xs)) {1..m}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "have \"(\\<Sum>i=1..m. (y#xs) ! i) = (\\<Sum>i=Suc 1..Suc m. (x#y#xs) ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((!) (y # xs)) {1..m} = sum ((!) (x # y # xs)) {Suc 1..Suc m}", "by (subst sum.shift_bounds_cl_Suc_ivl) simp"], ["proof (state)\nthis:\n  sum ((!) (y # xs)) {1..m} = sum ((!) (x # y # xs)) {Suc 1..Suc m}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "also"], ["proof (state)\nthis:\n  sum ((!) (y # xs)) {1..m} = sum ((!) (x # y # xs)) {Suc 1..Suc m}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "from Suc"], ["proof (chain)\npicking this:\n  n = Suc m", "have \"x + y + \\<dots> = (\\<Sum>i\\<le>n. (x#y#xs) ! i)\""], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. x + y + sum ((!) (x # y # xs)) {Suc 1..Suc m} =\n    sum ((!) (x # y # xs)) {..n}", "by (auto simp: atLeast0AtMost [symmetric] sum.atLeast_Suc_atMost add_ac)"], ["proof (state)\nthis:\n  x + y + sum ((!) (x # y # xs)) {Suc 1..Suc m} =\n  sum ((!) (x # y # xs)) {..n}\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "finally"], ["proof (chain)\npicking this:\n  psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n\ngoal (1 subgoal):\n 1. psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "."], ["proof (state)\nthis:\n  psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}", "qed simp"], ["proof (state)\nthis:\n  psums (x # y # xs) ! n = sum ((!) (x # y # xs)) {..n}\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       n < length [] \\<Longrightarrow> psums [] ! n = sum ((!) []) {..n}\n 2. \\<And>x n.\n       n < length [x] \\<Longrightarrow> psums [x] ! n = sum ((!) [x]) {..n}", "qed simp_all"], ["", "subsection \\<open>Sign changes in a list\\<close>"], ["", "text \\<open>\n  Next, we define the number of sign changes in a sequence. Intuitively, this is the number \n  of times that, when passing through the list, a sign change between one element and the next \n  element occurs (while ignoring all zero entries).\n\n  We implement this by filtering all zeros from the list of signs, removing all adjacent equal \n  elements and taking the length of the resulting list minus one.\n\\<close>"], ["", "definition sign_changes :: \"('a :: {sgn,zero} list) \\<Rightarrow> nat\" where\n  \"sign_changes xs = length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map sgn xs))) - 1\""], ["", "lemma sign_changes_Nil [simp]: \"sign_changes [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes [] = 0", "by (simp add: sign_changes_def)"], ["", "lemma sign_changes_singleton [simp]: \"sign_changes [x] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes [x] = 0", "by (simp add: sign_changes_def)"], ["", "lemma sign_changes_cong:\n  assumes \"map sgn xs = map sgn ys\"\n  shows   \"sign_changes xs = sign_changes ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes ys", "using assms"], ["proof (prove)\nusing this:\n  map sgn xs = map sgn ys\n\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes ys", "unfolding sign_changes_def"], ["proof (prove)\nusing this:\n  map sgn xs = map sgn ys\n\ngoal (1 subgoal):\n 1. length\n     (remdups_adj (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs))) -\n    1 =\n    length\n     (remdups_adj (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn ys))) -\n    1", "by simp"], ["", "lemma sign_changes_Cons_ge: \"sign_changes (x # xs) \\<ge> sign_changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes xs \\<le> sign_changes (x # xs)", "unfolding sign_changes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs))) -\n    1\n    \\<le> length\n           (remdups_adj\n             (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn (x # xs)))) -\n          1", "by (simp add: remdups_adj_Cons split: list.split)"], ["", "lemma sign_changes_Cons_Cons_different: \n  fixes x y :: \"'a :: linordered_idom\"\n  assumes \"x * y < 0\"\n  shows \"sign_changes (x # y # xs) = 1 + sign_changes (y # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (x # y # xs) = 1 + sign_changes (y # xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes (x # y # xs) = 1 + sign_changes (y # xs)", "from assms"], ["proof (chain)\npicking this:\n  x * y < (0::'a)", "have \"sgn x = -1 \\<and> sgn y = 1 \\<or> sgn x = 1 \\<and> sgn y = -1\""], ["proof (prove)\nusing this:\n  x * y < (0::'a)\n\ngoal (1 subgoal):\n 1. sgn x = - (1::'a) \\<and> sgn y = (1::'a) \\<or>\n    sgn x = (1::'a) \\<and> sgn y = - (1::'a)", "by (auto simp: mult_less_0_iff)"], ["proof (state)\nthis:\n  sgn x = - (1::'a) \\<and> sgn y = (1::'a) \\<or>\n  sgn x = (1::'a) \\<and> sgn y = - (1::'a)\n\ngoal (1 subgoal):\n 1. sign_changes (x # y # xs) = 1 + sign_changes (y # xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sgn x = - (1::'a) \\<and> sgn y = (1::'a) \\<or>\n  sgn x = (1::'a) \\<and> sgn y = - (1::'a)\n\ngoal (1 subgoal):\n 1. sign_changes (x # y # xs) = 1 + sign_changes (y # xs)", "by (fastforce simp: sign_changes_def)"], ["proof (state)\nthis:\n  sign_changes (x # y # xs) = 1 + sign_changes (y # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_changes_Cons_Cons_same: \n  fixes x y :: \"'a :: linordered_idom\"\n  shows \"x * y > 0 \\<Longrightarrow> sign_changes (x # y # xs) = sign_changes (y # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < x * y \\<Longrightarrow>\n    sign_changes (x # y # xs) = sign_changes (y # xs)", "by (subst (asm) zero_less_mult_iff) (fastforce simp: sign_changes_def)"], ["", "lemma sign_changes_0_Cons [simp]: \n  \"sign_changes (0 # xs :: 'a :: idom_abs_sgn list) = sign_changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes ((0::'a) # xs) = sign_changes xs", "by (simp add: sign_changes_def)"], ["", "lemma sign_changes_two: \n  fixes x y :: \"'a :: linordered_idom\"\n  shows \"sign_changes [x,y] = \n           (if x > 0 \\<and> y < 0 \\<or> x < 0 \\<and> y > 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes [x, y] =\n    (if (0::'a) < x \\<and> y < (0::'a) \\<or> x < (0::'a) \\<and> (0::'a) < y\n     then 1 else 0)", "by (auto simp: sgn_if sign_changes_def mult_less_0_iff)"], ["", "lemma sign_changes_induct [case_names nil sing zero nonzero]:\n  assumes \"P []\" \"\\<And>x. P [x]\" \"\\<And>xs. P xs \\<Longrightarrow> P (0#xs)\"\n          \"\\<And>x y xs. x \\<noteq> 0 \\<Longrightarrow> P ((x + y) # xs) \\<Longrightarrow> P (x # y # xs)\"\n  shows   \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof (induction \"length xs\" arbitrary: xs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<And>xsa.\n           length xsa < length xs \\<Longrightarrow> P xsa) \\<Longrightarrow>\n       P xs", "case (less xs)"], ["proof (state)\nthis:\n  length ?xs < length xs \\<Longrightarrow> P ?xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<And>xsa.\n           length xsa < length xs \\<Longrightarrow> P xsa) \\<Longrightarrow>\n       P xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof (cases xs rule: psums.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> P xs\n 2. \\<And>x. xs = [x] \\<Longrightarrow> P xs\n 3. \\<And>x y xs. xs = x # y # xs \\<Longrightarrow> P xs", "fix x y xs'"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> P xs\n 2. \\<And>x. xs = [x] \\<Longrightarrow> P xs\n 3. \\<And>x y xs. xs = x # y # xs \\<Longrightarrow> P xs", "assume \"xs = x # y # xs'\""], ["proof (state)\nthis:\n  xs = x # y # xs'\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> P xs\n 2. \\<And>x. xs = [x] \\<Longrightarrow> P xs\n 3. \\<And>x y xs. xs = x # y # xs \\<Longrightarrow> P xs", "with assms less"], ["proof (chain)\npicking this:\n  P []\n  P [?x]\n  P ?xs \\<Longrightarrow> P ((0::'a) # ?xs)\n  \\<lbrakk>?x \\<noteq> (0::'a); P ((?x + ?y) # ?xs)\\<rbrakk>\n  \\<Longrightarrow> P (?x # ?y # ?xs)\n  length ?xs < length xs \\<Longrightarrow> P ?xs\n  xs = x # y # xs'", "show ?thesis"], ["proof (prove)\nusing this:\n  P []\n  P [?x]\n  P ?xs \\<Longrightarrow> P ((0::'a) # ?xs)\n  \\<lbrakk>?x \\<noteq> (0::'a); P ((?x + ?y) # ?xs)\\<rbrakk>\n  \\<Longrightarrow> P (?x # ?y # ?xs)\n  length ?xs < length xs \\<Longrightarrow> P ?xs\n  xs = x # y # xs'\n\ngoal (1 subgoal):\n 1. P xs", "by (cases \"x = 0\") auto"], ["proof (state)\nthis:\n  P xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P xs\n 2. \\<And>x. xs = [x] \\<Longrightarrow> P xs", "qed (insert less assms, auto)"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_changes_filter: \n  fixes xs :: \"'a :: linordered_idom list\"\n  shows \"sign_changes (filter (\\<lambda>x. x \\<noteq> 0) xs) = sign_changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (filter (\\<lambda>x. x \\<noteq> (0::'a)) xs) =\n    sign_changes xs", "by (simp add: sign_changes_def filter_map o_def sgn_0_0)"], ["", "lemma sign_changes_Cons_Cons_0: \n  fixes xs :: \"'a :: linordered_idom list\"\n  shows \"sign_changes (x # 0 # xs) = sign_changes (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (x # (0::'a) # xs) = sign_changes (x # xs)", "by (subst (1 2) sign_changes_filter [symmetric]) simp_all"], ["", "lemma sign_changes_uminus: \n  fixes xs :: \"'a :: linordered_idom list\"\n  shows   \"sign_changes (map uminus xs) = sign_changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) = sign_changes xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) = sign_changes xs", "have \"sign_changes (map uminus xs) = \n          length (remdups_adj [x\\<leftarrow>map sgn (map uminus xs) . x \\<noteq> 0]) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) =\n    length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> (0::'a))\n         (map sgn (map uminus xs)))) -\n    1", "unfolding sign_changes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> (0::'a))\n         (map sgn (map uminus xs)))) -\n    1 =\n    length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> (0::'a))\n         (map sgn (map uminus xs)))) -\n    1", ".."], ["proof (state)\nthis:\n  sign_changes (map uminus xs) =\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn (map uminus xs)))) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) = sign_changes xs", "also"], ["proof (state)\nthis:\n  sign_changes (map uminus xs) =\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn (map uminus xs)))) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) = sign_changes xs", "have \"map sgn (map uminus xs) = map uminus (map sgn xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map sgn (map uminus xs) = map uminus (map sgn xs)", "by (auto simp: sgn_minus)"], ["proof (state)\nthis:\n  map sgn (map uminus xs) = map uminus (map sgn xs)\n\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) = sign_changes xs", "also"], ["proof (state)\nthis:\n  map sgn (map uminus xs) = map uminus (map sgn xs)\n\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) = sign_changes xs", "have \"remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) \\<dots>) = \n                 map uminus (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map sgn xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map uminus (map sgn xs))) =\n    map uminus\n     (remdups_adj (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs)))", "by (subst filter_map, subst remdups_adj_map_injective) \n       (simp_all add: o_def)"], ["proof (state)\nthis:\n  remdups_adj\n   (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map uminus (map sgn xs))) =\n  map uminus\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs)))\n\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) = sign_changes xs", "also"], ["proof (state)\nthis:\n  remdups_adj\n   (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map uminus (map sgn xs))) =\n  map uminus\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs)))\n\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) = sign_changes xs", "have \"length \\<dots> - 1 = sign_changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map uminus\n       (remdups_adj\n         (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs)))) -\n    1 =\n    sign_changes xs", "by (simp add: sign_changes_def)"], ["proof (state)\nthis:\n  length\n   (map uminus\n     (remdups_adj (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs)))) -\n  1 =\n  sign_changes xs\n\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) = sign_changes xs", "finally"], ["proof (chain)\npicking this:\n  sign_changes (map uminus xs) = sign_changes xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes (map uminus xs) = sign_changes xs\n\ngoal (1 subgoal):\n 1. sign_changes (map uminus xs) = sign_changes xs", "."], ["proof (state)\nthis:\n  sign_changes (map uminus xs) = sign_changes xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_changes_replicate: \"sign_changes (replicate n x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (replicate n x) = 0", "by (simp add: sign_changes_def remdups_adj_replicate filter_replicate)"], ["", "lemma sign_changes_decompose:\n  assumes \"x \\<noteq> (0 :: 'a :: linordered_idom)\"\n  shows   \"sign_changes (xs @ x # ys) = \n             sign_changes (xs @ [x]) + sign_changes (x # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (xs @ x # ys) =\n    sign_changes (xs @ [x]) + sign_changes (x # ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes (xs @ x # ys) =\n    sign_changes (xs @ [x]) + sign_changes (x # ys)", "have \"sign_changes (xs @ x # ys) = \n            length (remdups_adj ([x\\<leftarrow>map sgn xs . x \\<noteq> 0] @ \n                      sgn x # [x\\<leftarrow>map sgn ys . x \\<noteq> 0])) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (xs @ x # ys) =\n    length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs) @\n        sgn x # filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn ys))) -\n    1", "by (simp add: sgn_0_0 assms sign_changes_def)"], ["proof (state)\nthis:\n  sign_changes (xs @ x # ys) =\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs) @\n      sgn x # filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn ys))) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes (xs @ x # ys) =\n    sign_changes (xs @ [x]) + sign_changes (x # ys)", "also"], ["proof (state)\nthis:\n  sign_changes (xs @ x # ys) =\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs) @\n      sgn x # filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn ys))) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes (xs @ x # ys) =\n    sign_changes (xs @ [x]) + sign_changes (x # ys)", "have \"\\<dots> = sign_changes (xs @ [x]) + sign_changes (x # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs) @\n        sgn x # filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn ys))) -\n    1 =\n    sign_changes (xs @ [x]) + sign_changes (x # ys)", "by (subst remdups_adj_append) (simp add: sign_changes_def assms sgn_0_0)"], ["proof (state)\nthis:\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn xs) @\n      sgn x # filter (\\<lambda>x. x \\<noteq> (0::'a)) (map sgn ys))) -\n  1 =\n  sign_changes (xs @ [x]) + sign_changes (x # ys)\n\ngoal (1 subgoal):\n 1. sign_changes (xs @ x # ys) =\n    sign_changes (xs @ [x]) + sign_changes (x # ys)", "finally"], ["proof (chain)\npicking this:\n  sign_changes (xs @ x # ys) =\n  sign_changes (xs @ [x]) + sign_changes (x # ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes (xs @ x # ys) =\n  sign_changes (xs @ [x]) + sign_changes (x # ys)\n\ngoal (1 subgoal):\n 1. sign_changes (xs @ x # ys) =\n    sign_changes (xs @ [x]) + sign_changes (x # ys)", "."], ["proof (state)\nthis:\n  sign_changes (xs @ x # ys) =\n  sign_changes (xs @ [x]) + sign_changes (x # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If the first and the last entry of a list are non-zero, its number of sign changes is even \n  if and only if the first and the last element have the same sign. This will be important \n  later to establish the base case of Descartes' Rule. (if there are no positive roots, \n  the number of sign changes is even)\n\\<close>"], ["", "lemma even_sign_changes_iff:\n  assumes \"xs \\<noteq> ([] :: 'a :: linordered_idom list)\" \"hd xs \\<noteq> 0\" \"last xs \\<noteq> 0\"\n  shows   \"even (sign_changes xs) \\<longleftrightarrow> sgn (hd xs) = sgn (last xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  hd xs \\<noteq> (0::'a)\n  last xs \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "proof (induction \"length xs\" arbitrary: xs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs; xsa \\<noteq> [];\n                    hd xsa \\<noteq> (0::'a);\n                    last xsa \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> even (sign_changes xsa) =\n                                     (sgn (hd xsa) = sgn (last xsa));\n        xs \\<noteq> []; hd xs \\<noteq> (0::'a);\n        last xs \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> even (sign_changes xs) =\n                         (sgn (hd xs) = sgn (last xs))", "case (less xs)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?xs < length xs; ?xs \\<noteq> []; hd ?xs \\<noteq> (0::'a);\n   last ?xs \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> even (sign_changes ?xs) =\n                    (sgn (hd ?xs) = sgn (last ?xs))\n  xs \\<noteq> []\n  hd xs \\<noteq> (0::'a)\n  last xs \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>length xsa < length xs; xsa \\<noteq> [];\n                    hd xsa \\<noteq> (0::'a);\n                    last xsa \\<noteq> (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> even (sign_changes xsa) =\n                                     (sgn (hd xsa) = sgn (last xsa));\n        xs \\<noteq> []; hd xs \\<noteq> (0::'a);\n        last xs \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> even (sign_changes xs) =\n                         (sgn (hd xs) = sgn (last xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "case (Cons x xs')"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "note x = this"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "proof (cases xs')"], ["proof (state)\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "case (Cons y xs'')"], ["proof (state)\nthis:\n  xs' = y # xs''\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "note y = this"], ["proof (state)\nthis:\n  xs' = y # xs''\n\ngoal (2 subgoals):\n 1. xs' = [] \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. \\<And>a list.\n       xs' = a # list \\<Longrightarrow>\n       even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "proof (rule linorder_cases[of \"x*y\" 0])"], ["proof (state)\ngoal (3 subgoals):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. x * y = (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 3. (0::'a) < x * y \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "assume xy: \"x*y = 0\""], ["proof (state)\nthis:\n  x * y = (0::'a)\n\ngoal (3 subgoals):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. x * y = (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 3. (0::'a) < x * y \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "with x y less(1,3,4)"], ["proof (chain)\npicking this:\n  xs = x # xs'\n  xs' = y # xs''\n  \\<lbrakk>length ?xs < length xs; ?xs \\<noteq> []; hd ?xs \\<noteq> (0::'a);\n   last ?xs \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> even (sign_changes ?xs) =\n                    (sgn (hd ?xs) = sgn (last ?xs))\n  hd xs \\<noteq> (0::'a)\n  last xs \\<noteq> (0::'a)\n  x * y = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = x # xs'\n  xs' = y # xs''\n  \\<lbrakk>length ?xs < length xs; ?xs \\<noteq> []; hd ?xs \\<noteq> (0::'a);\n   last ?xs \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> even (sign_changes ?xs) =\n                    (sgn (hd ?xs) = sgn (last ?xs))\n  hd xs \\<noteq> (0::'a)\n  last xs \\<noteq> (0::'a)\n  x * y = (0::'a)\n\ngoal (1 subgoal):\n 1. even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "by (auto simp: sign_changes_Cons_Cons_0)"], ["proof (state)\nthis:\n  even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n\ngoal (2 subgoals):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. (0::'a) < x * y \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. (0::'a) < x * y \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "assume xy: \"x*y > 0\""], ["proof (state)\nthis:\n  (0::'a) < x * y\n\ngoal (2 subgoals):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n 2. (0::'a) < x * y \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "with less(1,4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?xs < length xs; ?xs \\<noteq> []; hd ?xs \\<noteq> (0::'a);\n   last ?xs \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> even (sign_changes ?xs) =\n                    (sgn (hd ?xs) = sgn (last ?xs))\n  last xs \\<noteq> (0::'a)\n  (0::'a) < x * y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?xs < length xs; ?xs \\<noteq> []; hd ?xs \\<noteq> (0::'a);\n   last ?xs \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> even (sign_changes ?xs) =\n                    (sgn (hd ?xs) = sgn (last ?xs))\n  last xs \\<noteq> (0::'a)\n  (0::'a) < x * y\n\ngoal (1 subgoal):\n 1. even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "by (auto simp add: x y sign_changes_Cons_Cons_same zero_less_mult_iff)"], ["proof (state)\nthis:\n  even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n\ngoal (1 subgoal):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "assume xy: \"x*y < 0\""], ["proof (state)\nthis:\n  x * y < (0::'a)\n\ngoal (1 subgoal):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "moreover"], ["proof (state)\nthis:\n  x * y < (0::'a)\n\ngoal (1 subgoal):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "from xy"], ["proof (chain)\npicking this:\n  x * y < (0::'a)", "have \"sgn x = - sgn y\""], ["proof (prove)\nusing this:\n  x * y < (0::'a)\n\ngoal (1 subgoal):\n 1. sgn x = - sgn y", "by (auto simp: mult_less_0_iff)"], ["proof (state)\nthis:\n  sgn x = - sgn y\n\ngoal (1 subgoal):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "moreover"], ["proof (state)\nthis:\n  sgn x = - sgn y\n\ngoal (1 subgoal):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "have \"even (sign_changes (y # xs'')) \\<longleftrightarrow> \n                         sgn (hd (y # xs'')) = sgn (last (y # xs''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (sign_changes (y # xs'')) =\n    (sgn (hd (y # xs'')) = sgn (last (y # xs'')))", "using xy less.prems"], ["proof (prove)\nusing this:\n  x * y < (0::'a)\n  xs \\<noteq> []\n  hd xs \\<noteq> (0::'a)\n  last xs \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. even (sign_changes (y # xs'')) =\n    (sgn (hd (y # xs'')) = sgn (last (y # xs'')))", "by (intro less) (auto simp: x y)"], ["proof (state)\nthis:\n  even (sign_changes (y # xs'')) =\n  (sgn (hd (y # xs'')) = sgn (last (y # xs'')))\n\ngoal (1 subgoal):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "moreover"], ["proof (state)\nthis:\n  even (sign_changes (y # xs'')) =\n  (sgn (hd (y # xs'')) = sgn (last (y # xs'')))\n\ngoal (1 subgoal):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "from xy less.prems"], ["proof (chain)\npicking this:\n  x * y < (0::'a)\n  xs \\<noteq> []\n  hd xs \\<noteq> (0::'a)\n  last xs \\<noteq> (0::'a)", "have \"sgn y = sgn (last xs) \\<longleftrightarrow> -sgn y \\<noteq> sgn (last xs)\""], ["proof (prove)\nusing this:\n  x * y < (0::'a)\n  xs \\<noteq> []\n  hd xs \\<noteq> (0::'a)\n  last xs \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (sgn y = sgn (last xs)) = (- sgn y \\<noteq> sgn (last xs))", "by (auto simp: sgn_if)"], ["proof (state)\nthis:\n  (sgn y = sgn (last xs)) = (- sgn y \\<noteq> sgn (last xs))\n\ngoal (1 subgoal):\n 1. x * y < (0::'a) \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "ultimately"], ["proof (chain)\npicking this:\n  x * y < (0::'a)\n  sgn x = - sgn y\n  even (sign_changes (y # xs'')) =\n  (sgn (hd (y # xs'')) = sgn (last (y # xs'')))\n  (sgn y = sgn (last xs)) = (- sgn y \\<noteq> sgn (last xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  x * y < (0::'a)\n  sgn x = - sgn y\n  even (sign_changes (y # xs'')) =\n  (sgn (hd (y # xs'')) = sgn (last (y # xs'')))\n  (sgn y = sgn (last xs)) = (- sgn y \\<noteq> sgn (last xs))\n\ngoal (1 subgoal):\n 1. even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "by (auto simp: sign_changes_Cons_Cons_different x y)"], ["proof (state)\nthis:\n  even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n\ngoal (1 subgoal):\n 1. xs' = [] \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "qed (auto simp: x)"], ["proof (state)\nthis:\n  even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))", "qed (insert less.prems, simp_all)"], ["proof (state)\nthis:\n  even (sign_changes xs) = (sgn (hd xs) = sgn (last xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Arthan's lemma\\<close>"], ["", "context\nbegin"], ["", "text \\<open>\n  We first prove an auxiliary lemma that allows us to assume w.l.o.g. that the first element of \n  the list is non-negative, similarly to what Arthan does in his proof.\n\\<close>"], ["", "private"], ["", "lemma arthan_wlog [consumes 3, case_names nonneg lift]:\n  fixes xs :: \"'a :: linordered_idom list\"\n  assumes \"xs \\<noteq> []\" \"last xs \\<noteq> 0\" \"x + y + sum_list xs = 0\"\n  assumes \"\\<And>x y xs. xs \\<noteq> [] \\<Longrightarrow> last xs \\<noteq> 0 \\<Longrightarrow> \n               x + y + sum_list xs = 0 \\<Longrightarrow> x \\<ge> 0 \\<Longrightarrow> P x y xs\"\n  assumes \"\\<And>x y xs. xs \\<noteq> [] \\<Longrightarrow> P x y xs \\<Longrightarrow> P (-x) (-y) (map uminus xs)\"\n  shows   \"P x y xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x y xs", "proof (cases \"x \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> x \\<Longrightarrow> P x y xs\n 2. \\<not> (0::'a) \\<le> x \\<Longrightarrow> P x y xs", "assume x: \"\\<not>(x \\<ge> 0)\""], ["proof (state)\nthis:\n  \\<not> (0::'a) \\<le> x\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> x \\<Longrightarrow> P x y xs\n 2. \\<not> (0::'a) \\<le> x \\<Longrightarrow> P x y xs", "from assms"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  \\<lbrakk>?xs \\<noteq> []; last ?xs \\<noteq> (0::'a);\n   ?x + ?y + sum_list ?xs = (0::'a); (0::'a) \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> P ?x ?y ?xs\n  \\<lbrakk>?xs \\<noteq> []; P ?x ?y ?xs\\<rbrakk>\n  \\<Longrightarrow> P (- ?x) (- ?y) (map uminus ?xs)", "have \"map uminus xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  \\<lbrakk>?xs \\<noteq> []; last ?xs \\<noteq> (0::'a);\n   ?x + ?y + sum_list ?xs = (0::'a); (0::'a) \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> P ?x ?y ?xs\n  \\<lbrakk>?xs \\<noteq> []; P ?x ?y ?xs\\<rbrakk>\n  \\<Longrightarrow> P (- ?x) (- ?y) (map uminus ?xs)\n\ngoal (1 subgoal):\n 1. map uminus xs \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  map uminus xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> x \\<Longrightarrow> P x y xs\n 2. \\<not> (0::'a) \\<le> x \\<Longrightarrow> P x y xs", "moreover"], ["proof (state)\nthis:\n  map uminus xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> x \\<Longrightarrow> P x y xs\n 2. \\<not> (0::'a) \\<le> x \\<Longrightarrow> P x y xs", "from x assms(1,2,3)"], ["proof (chain)\npicking this:\n  \\<not> (0::'a) \\<le> x\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)", "have\"P (-x) (-y) (map uminus xs)\""], ["proof (prove)\nusing this:\n  \\<not> (0::'a) \\<le> x\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n\ngoal (1 subgoal):\n 1. P (- x) (- y) (map uminus xs)", "using uminus_sum_list_map[of \"\\<lambda>x. x\" xs, symmetric]"], ["proof (prove)\nusing this:\n  \\<not> (0::'a) \\<le> x\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  sum_list (map (uminus \\<circ> (\\<lambda>x. x)) xs) =\n  - (\\<Sum>x\\<leftarrow>xs. x)\n\ngoal (1 subgoal):\n 1. P (- x) (- y) (map uminus xs)", "by (intro assms) (auto simp: last_map algebra_simps o_def neg_eq_iff_add_eq_0)"], ["proof (state)\nthis:\n  P (- x) (- y) (map uminus xs)\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> x \\<Longrightarrow> P x y xs\n 2. \\<not> (0::'a) \\<le> x \\<Longrightarrow> P x y xs", "ultimately"], ["proof (chain)\npicking this:\n  map uminus xs \\<noteq> []\n  P (- x) (- y) (map uminus xs)", "have \"P (- (-x)) (- (-y)) (map uminus (map uminus xs))\""], ["proof (prove)\nusing this:\n  map uminus xs \\<noteq> []\n  P (- x) (- y) (map uminus xs)\n\ngoal (1 subgoal):\n 1. P (- (- x)) (- (- y)) (map uminus (map uminus xs))", "by (rule assms)"], ["proof (state)\nthis:\n  P (- (- x)) (- (- y)) (map uminus (map uminus xs))\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> x \\<Longrightarrow> P x y xs\n 2. \\<not> (0::'a) \\<le> x \\<Longrightarrow> P x y xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  P (- (- x)) (- (- y)) (map uminus (map uminus xs))\n\ngoal (1 subgoal):\n 1. P x y xs", "by (simp add: o_def)"], ["proof (state)\nthis:\n  P x y xs\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x \\<Longrightarrow> P x y xs", "qed (simp_all add: assms)"], ["", "text \\<open>\n  We now show that the $\\alpha$ and $\\beta$ in Arthan's proof have the necessary properties:\n  their difference is non-negative and even.\n\\<close>"], ["", "private"], ["", "lemma arthan_aux1:\n  fixes xs :: \"'a :: {linordered_idom} list\"\n  assumes \"xs \\<noteq> []\" \"last xs \\<noteq> 0\" \"x + y + sum_list xs = 0\"\n  defines \"v \\<equiv> \\<lambda>xs. int (sign_changes xs)\"\n  shows \"v (x # y # xs) - v ((x + y) # xs) \\<ge> \n             v (psums (x # y # xs)) - v (psums ((x + y) # xs)) \\<and> \n         even (v (x # y # xs) - v ((x + y) # xs) - \n                  (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "using assms(1-3)"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "proof (induction rule: arthan_wlog)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))\n 2. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> [];\n        v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n        \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n        even\n         (v (x # y # xs) - v ((x + y) # xs) -\n          (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\\<rbrakk>\n       \\<Longrightarrow> v (psums (- x # - y # map uminus xs)) -\n                         v (psums ((- x + - y) # map uminus xs))\n                         \\<le> v (- x # - y # map uminus xs) -\n                               v ((- x + - y) # map uminus xs) \\<and>\n                         even\n                          (v (- x # - y # map uminus xs) -\n                           v ((- x + - y) # map uminus xs) -\n                           (v (psums (- x # - y # map uminus xs)) -\n                            v (psums ((- x + - y) # map uminus xs))))", "have uminus_v: \"v (map uminus xs) = v xs\" for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (map uminus xs) = v xs", "by (simp add: v_def sign_changes_uminus)"], ["proof (state)\nthis:\n  v (map uminus ?xs) = v ?xs\n\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))\n 2. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> [];\n        v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n        \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n        even\n         (v (x # y # xs) - v ((x + y) # xs) -\n          (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\\<rbrakk>\n       \\<Longrightarrow> v (psums (- x # - y # map uminus xs)) -\n                         v (psums ((- x + - y) # map uminus xs))\n                         \\<le> v (- x # - y # map uminus xs) -\n                               v ((- x + - y) # map uminus xs) \\<and>\n                         even\n                          (v (- x # - y # map uminus xs) -\n                           v ((- x + - y) # map uminus xs) -\n                           (v (psums (- x # - y # map uminus xs)) -\n                            v (psums ((- x + - y) # map uminus xs))))", "case (lift x y xs)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))\n 2. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> [];\n        v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n        \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n        even\n         (v (x # y # xs) - v ((x + y) # xs) -\n          (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\\<rbrakk>\n       \\<Longrightarrow> v (psums (- x # - y # map uminus xs)) -\n                         v (psums ((- x + - y) # map uminus xs))\n                         \\<le> v (- x # - y # map uminus xs) -\n                               v ((- x + - y) # map uminus xs) \\<and>\n                         even\n                          (v (- x # - y # map uminus xs) -\n                           v ((- x + - y) # map uminus xs) -\n                           (v (psums (- x # - y # map uminus xs)) -\n                            v (psums ((- x + - y) # map uminus xs))))", "note lift(2)"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))\n 2. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> [];\n        v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n        \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n        even\n         (v (x # y # xs) - v ((x + y) # xs) -\n          (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\\<rbrakk>\n       \\<Longrightarrow> v (psums (- x # - y # map uminus xs)) -\n                         v (psums ((- x + - y) # map uminus xs))\n                         \\<le> v (- x # - y # map uminus xs) -\n                               v ((- x + - y) # map uminus xs) \\<and>\n                         even\n                          (v (- x # - y # map uminus xs) -\n                           v ((- x + - y) # map uminus xs) -\n                           (v (psums (- x # - y # map uminus xs)) -\n                            v (psums ((- x + - y) # map uminus xs))))", "also"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))\n 2. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> [];\n        v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n        \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n        even\n         (v (x # y # xs) - v ((x + y) # xs) -\n          (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\\<rbrakk>\n       \\<Longrightarrow> v (psums (- x # - y # map uminus xs)) -\n                         v (psums ((- x + - y) # map uminus xs))\n                         \\<le> v (- x # - y # map uminus xs) -\n                               v ((- x + - y) # map uminus xs) \\<and>\n                         even\n                          (v (- x # - y # map uminus xs) -\n                           v ((- x + - y) # map uminus xs) -\n                           (v (psums (- x # - y # map uminus xs)) -\n                            v (psums ((- x + - y) # map uminus xs))))", "have \"v (psums (x#y#xs)) - v (psums ((x+y)#xs)) =\n                 v (psums (- x # - y # map uminus xs)) - \n                 v (psums ((- x + - y) # map uminus xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs)) =\n    v (psums (- x # - y # map uminus xs)) -\n    v (psums ((- x + - y) # map uminus xs))", "by (subst (1 2) uminus_v [symmetric]) (simp add: map_uminus_psums)"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs)) =\n  v (psums (- x # - y # map uminus xs)) -\n  v (psums ((- x + - y) # map uminus xs))\n\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))\n 2. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> [];\n        v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n        \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n        even\n         (v (x # y # xs) - v ((x + y) # xs) -\n          (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\\<rbrakk>\n       \\<Longrightarrow> v (psums (- x # - y # map uminus xs)) -\n                         v (psums ((- x + - y) # map uminus xs))\n                         \\<le> v (- x # - y # map uminus xs) -\n                               v ((- x + - y) # map uminus xs) \\<and>\n                         even\n                          (v (- x # - y # map uminus xs) -\n                           v ((- x + - y) # map uminus xs) -\n                           (v (psums (- x # - y # map uminus xs)) -\n                            v (psums ((- x + - y) # map uminus xs))))", "also"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs)) =\n  v (psums (- x # - y # map uminus xs)) -\n  v (psums ((- x + - y) # map uminus xs))\n\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))\n 2. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> [];\n        v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n        \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n        even\n         (v (x # y # xs) - v ((x + y) # xs) -\n          (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\\<rbrakk>\n       \\<Longrightarrow> v (psums (- x # - y # map uminus xs)) -\n                         v (psums ((- x + - y) # map uminus xs))\n                         \\<le> v (- x # - y # map uminus xs) -\n                               v ((- x + - y) # map uminus xs) \\<and>\n                         even\n                          (v (- x # - y # map uminus xs) -\n                           v ((- x + - y) # map uminus xs) -\n                           (v (psums (- x # - y # map uminus xs)) -\n                            v (psums ((- x + - y) # map uminus xs))))", "have \"v (x # y # xs) - v ((x + y) # xs) = \n                 v (-x # -y # map uminus xs) - v ((-x + -y) # map uminus xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v (x # y # xs) - v ((x + y) # xs) =\n    v (- x # - y # map uminus xs) - v ((- x + - y) # map uminus xs)", "by (subst (1 2) uminus_v [symmetric]) simp"], ["proof (state)\nthis:\n  v (x # y # xs) - v ((x + y) # xs) =\n  v (- x # - y # map uminus xs) - v ((- x + - y) # map uminus xs)\n\ngoal (2 subgoals):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))\n 2. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> [];\n        v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n        \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n        even\n         (v (x # y # xs) - v ((x + y) # xs) -\n          (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\\<rbrakk>\n       \\<Longrightarrow> v (psums (- x # - y # map uminus xs)) -\n                         v (psums ((- x + - y) # map uminus xs))\n                         \\<le> v (- x # - y # map uminus xs) -\n                               v ((- x + - y) # map uminus xs) \\<and>\n                         even\n                          (v (- x # - y # map uminus xs) -\n                           v ((- x + - y) # map uminus xs) -\n                           (v (psums (- x # - y # map uminus xs)) -\n                            v (psums ((- x + - y) # map uminus xs))))", "finally"], ["proof (chain)\npicking this:\n  v (psums (- x # - y # map uminus xs)) -\n  v (psums ((- x + - y) # map uminus xs))\n  \\<le> v (- x # - y # map uminus xs) -\n        v ((- x + - y) # map uminus xs) \\<and>\n  even\n   (v (- x # - y # map uminus xs) - v ((- x + - y) # map uminus xs) -\n    (v (psums (- x # - y # map uminus xs)) -\n     v (psums ((- x + - y) # map uminus xs))))", "show ?case"], ["proof (prove)\nusing this:\n  v (psums (- x # - y # map uminus xs)) -\n  v (psums ((- x + - y) # map uminus xs))\n  \\<le> v (- x # - y # map uminus xs) -\n        v ((- x + - y) # map uminus xs) \\<and>\n  even\n   (v (- x # - y # map uminus xs) - v ((- x + - y) # map uminus xs) -\n    (v (psums (- x # - y # map uminus xs)) -\n     v (psums ((- x + - y) # map uminus xs))))\n\ngoal (1 subgoal):\n 1. v (psums (- x # - y # map uminus xs)) -\n    v (psums ((- x + - y) # map uminus xs))\n    \\<le> v (- x # - y # map uminus xs) -\n          v ((- x + - y) # map uminus xs) \\<and>\n    even\n     (v (- x # - y # map uminus xs) - v ((- x + - y) # map uminus xs) -\n      (v (psums (- x # - y # map uminus xs)) -\n       v (psums ((- x + - y) # map uminus xs))))", "."], ["proof (state)\nthis:\n  v (psums (- x # - y # map uminus xs)) -\n  v (psums ((- x + - y) # map uminus xs))\n  \\<le> v (- x # - y # map uminus xs) -\n        v ((- x + - y) # map uminus xs) \\<and>\n  even\n   (v (- x # - y # map uminus xs) - v ((- x + - y) # map uminus xs) -\n    (v (psums (- x # - y # map uminus xs)) -\n     v (psums ((- x + - y) # map uminus xs))))\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "case (nonneg x y xs)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "define p where \"p = (LEAST n. xs ! n \\<noteq> 0)\""], ["proof (state)\nthis:\n  p = (LEAST n. xs ! n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "define xs1 :: \"'a list\" where \"xs1 = replicate p 0\""], ["proof (state)\nthis:\n  xs1 = replicate p (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "define xs2 where \"xs2 = drop (Suc p) xs\""], ["proof (state)\nthis:\n  xs2 = drop (Suc p) xs\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "from nonneg"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  (0::'a) \\<le> x", "have \"xs ! (length xs - 1) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. xs ! (length xs - 1) \\<noteq> (0::'a)", "by (simp add: last_conv_nth)"], ["proof (state)\nthis:\n  xs ! (length xs - 1) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "hence p_nz: \"xs ! p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  xs ! (length xs - 1) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. xs ! p \\<noteq> (0::'a)", "unfolding p_def"], ["proof (prove)\nusing this:\n  xs ! (length xs - 1) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. xs ! (LEAST n. xs ! n \\<noteq> (0::'a)) \\<noteq> (0::'a)", "by (rule LeastI)"], ["proof (state)\nthis:\n  xs ! p \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "{"], ["proof (state)\nthis:\n  xs ! p \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "assume \"q < p\""], ["proof (state)\nthis:\n  q < p\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "hence \"xs ! q = 0\""], ["proof (prove)\nusing this:\n  q < p\n\ngoal (1 subgoal):\n 1. xs ! q = (0::'a)", "using Least_le[of \"\\<lambda>n. xs ! n \\<noteq> 0\" q]"], ["proof (prove)\nusing this:\n  q < p\n  xs ! q \\<noteq> (0::'a) \\<Longrightarrow>\n  (LEAST x. xs ! x \\<noteq> (0::'a)) \\<le> q\n\ngoal (1 subgoal):\n 1. xs ! q = (0::'a)", "unfolding p_def"], ["proof (prove)\nusing this:\n  q < (LEAST n. xs ! n \\<noteq> (0::'a))\n  xs ! q \\<noteq> (0::'a) \\<Longrightarrow>\n  (LEAST x. xs ! x \\<noteq> (0::'a)) \\<le> q\n\ngoal (1 subgoal):\n 1. xs ! q = (0::'a)", "by force"], ["proof (state)\nthis:\n  xs ! q = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "}"], ["proof (state)\nthis:\n  ?q2 < p \\<Longrightarrow> xs ! ?q2 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "note less_p_zero = this"], ["proof (state)\nthis:\n  ?q2 < p \\<Longrightarrow> xs ! ?q2 = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "from Least_le[of \"\\<lambda>n. xs ! n \\<noteq> 0\" \"length xs - 1\"] nonneg"], ["proof (chain)\npicking this:\n  xs ! (length xs - 1) \\<noteq> (0::'a) \\<Longrightarrow>\n  (LEAST x. xs ! x \\<noteq> (0::'a)) \\<le> length xs - 1\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  (0::'a) \\<le> x", "have \"p \\<le> length xs - 1\""], ["proof (prove)\nusing this:\n  xs ! (length xs - 1) \\<noteq> (0::'a) \\<Longrightarrow>\n  (LEAST x. xs ! x \\<noteq> (0::'a)) \\<le> length xs - 1\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. p \\<le> length xs - 1", "unfolding p_def"], ["proof (prove)\nusing this:\n  xs ! (length xs - 1) \\<noteq> (0::'a) \\<Longrightarrow>\n  (LEAST x. xs ! x \\<noteq> (0::'a)) \\<le> length xs - 1\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. (LEAST n. xs ! n \\<noteq> (0::'a)) \\<le> length xs - 1", "by (auto simp: last_conv_nth)"], ["proof (state)\nthis:\n  p \\<le> length xs - 1\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "with nonneg"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  (0::'a) \\<le> x\n  p \\<le> length xs - 1", "have p_less_length: \"p < length xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  (0::'a) \\<le> x\n  p \\<le> length xs - 1\n\ngoal (1 subgoal):\n 1. p < length xs", "by (cases xs) simp_all"], ["proof (state)\nthis:\n  p < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "from p_less_length less_p_zero"], ["proof (chain)\npicking this:\n  p < length xs\n  ?q2 < p \\<Longrightarrow> xs ! ?q2 = (0::'a)", "have \"take p xs = replicate p 0\""], ["proof (prove)\nusing this:\n  p < length xs\n  ?q2 < p \\<Longrightarrow> xs ! ?q2 = (0::'a)\n\ngoal (1 subgoal):\n 1. take p xs = replicate p (0::'a)", "by (subst list_eq_iff_nth_eq) auto"], ["proof (state)\nthis:\n  take p xs = replicate p (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "with p_less_length"], ["proof (chain)\npicking this:\n  p < length xs\n  take p xs = replicate p (0::'a)", "have xs_decompose: \"xs = xs1 @ xs ! p # xs2\""], ["proof (prove)\nusing this:\n  p < length xs\n  take p xs = replicate p (0::'a)\n\ngoal (1 subgoal):\n 1. xs = xs1 @ xs ! p # xs2", "unfolding xs1_def xs2_def"], ["proof (prove)\nusing this:\n  p < length xs\n  take p xs = replicate p (0::'a)\n\ngoal (1 subgoal):\n 1. xs = replicate p (0::'a) @ xs ! p # drop (Suc p) xs", "by (subst append_take_drop_id [of p, symmetric], \n        subst Cons_nth_drop_Suc) simp_all"], ["proof (state)\nthis:\n  xs = xs1 @ xs ! p # xs2\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "have v_decompose: \"v (xs' @ xs) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)\" for xs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (xs' @ xs) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v (xs' @ xs) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)", "have \"xs' @ xs = (xs' @ xs1) @ xs ! p # xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' @ xs = (xs' @ xs1) @ xs ! p # xs2", "by (subst xs_decompose) simp"], ["proof (state)\nthis:\n  xs' @ xs = (xs' @ xs1) @ xs ! p # xs2\n\ngoal (1 subgoal):\n 1. v (xs' @ xs) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)", "also"], ["proof (state)\nthis:\n  xs' @ xs = (xs' @ xs1) @ xs ! p # xs2\n\ngoal (1 subgoal):\n 1. v (xs' @ xs) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)", "have \"v \\<dots> = v (xs' @ [xs ! p]) + v (xs ! p # xs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ((xs' @ xs1) @ xs ! p # xs2) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (sign_changes ((xs' @ xs1) @ xs ! p # xs2)) =\n    int (sign_changes (xs' @ [xs ! p])) + int (sign_changes (xs ! p # xs2))", "by (subst sign_changes_decompose[OF p_nz], \n          subst (1 2 3 4) sign_changes_filter [symmetric]) (simp_all add: xs1_def)"], ["proof (state)\nthis:\n  v ((xs' @ xs1) @ xs ! p # xs2) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)\n\ngoal (1 subgoal):\n 1. v (xs' @ xs) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)", "finally"], ["proof (chain)\npicking this:\n  v (xs' @ xs) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)", "show ?thesis"], ["proof (prove)\nusing this:\n  v (xs' @ xs) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)\n\ngoal (1 subgoal):\n 1. v (xs' @ xs) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)", "."], ["proof (state)\nthis:\n  v (xs' @ xs) = v (xs' @ [xs ! p]) + v (xs ! p # xs2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v (?xs' @ xs) = v (?xs' @ [xs ! p]) + v (xs ! p # xs2)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "have psums_decompose: \"psums xs = replicate p 0 @ psums (xs!p # xs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. psums xs = replicate p (0::'a) @ psums (xs ! p # xs2)", "by (subst xs_decompose) (simp add: xs1_def psums_replicate_0_append)"], ["proof (state)\nthis:\n  psums xs = replicate p (0::'a) @ psums (xs ! p # xs2)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "have v_psums_decompose: \"sign_changes (xs' @ psums xs) = sign_changes (xs' @ [xs!p]) + \n         sign_changes (xs!p # map ((+) (xs!p)) (psums xs2))\" for xs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (xs' @ psums xs) =\n    sign_changes (xs' @ [xs ! p]) +\n    sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes (xs' @ psums xs) =\n    sign_changes (xs' @ [xs ! p]) +\n    sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))", "fix xs' :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes (xs'__ @ psums xs) =\n    sign_changes (xs'__ @ [xs ! p]) +\n    sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))", "have \"sign_changes (xs' @ psums xs) = \n            sign_changes (xs' @ xs ! p # map ((+) (xs!p)) (psums xs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (xs' @ psums xs) =\n    sign_changes (xs' @ xs ! p # map ((+) (xs ! p)) (psums xs2))", "by (subst psums_decompose, subst (1 2) sign_changes_filter [symmetric]) \n         (simp_all add: psums_Cons)"], ["proof (state)\nthis:\n  sign_changes (xs' @ psums xs) =\n  sign_changes (xs' @ xs ! p # map ((+) (xs ! p)) (psums xs2))\n\ngoal (1 subgoal):\n 1. sign_changes (xs'__ @ psums xs) =\n    sign_changes (xs'__ @ [xs ! p]) +\n    sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))", "also"], ["proof (state)\nthis:\n  sign_changes (xs' @ psums xs) =\n  sign_changes (xs' @ xs ! p # map ((+) (xs ! p)) (psums xs2))\n\ngoal (1 subgoal):\n 1. sign_changes (xs'__ @ psums xs) =\n    sign_changes (xs'__ @ [xs ! p]) +\n    sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))", "have \"\\<dots> = sign_changes (xs' @ [xs!p]) + \n                      sign_changes (xs!p # map ((+) (xs!p)) (psums xs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (xs' @ xs ! p # map ((+) (xs ! p)) (psums xs2)) =\n    sign_changes (xs' @ [xs ! p]) +\n    sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))", "by (subst sign_changes_decompose[OF p_nz]) simp_all"], ["proof (state)\nthis:\n  sign_changes (xs' @ xs ! p # map ((+) (xs ! p)) (psums xs2)) =\n  sign_changes (xs' @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n\ngoal (1 subgoal):\n 1. sign_changes (xs'__ @ psums xs) =\n    sign_changes (xs'__ @ [xs ! p]) +\n    sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))", "finally"], ["proof (chain)\npicking this:\n  sign_changes (xs' @ psums xs) =\n  sign_changes (xs' @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))", "show \"sign_changes (xs' @ psums xs) = \\<dots>\""], ["proof (prove)\nusing this:\n  sign_changes (xs' @ psums xs) =\n  sign_changes (xs' @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n\ngoal (1 subgoal):\n 1. sign_changes (xs' @ psums xs) =\n    sign_changes (xs' @ [xs ! p]) +\n    sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))", "."], ["proof (state)\nthis:\n  sign_changes (xs' @ psums xs) =\n  sign_changes (xs' @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_changes (?xs' @ psums xs) =\n  sign_changes (?xs' @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n        x + y + sum_list xs = (0::'a); (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n                         \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n                         even\n                          (v (x # y # xs) - v ((x + y) # xs) -\n                           (v (psums (x # y # xs)) -\n                            v (psums ((x + y) # xs))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "proof (cases \"x > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) < x \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. \\<not> (0::'a) < x \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume \"\\<not>(x > 0)\""], ["proof (state)\nthis:\n  \\<not> (0::'a) < x\n\ngoal (2 subgoals):\n 1. (0::'a) < x \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. \\<not> (0::'a) < x \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "with nonneg"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  (0::'a) \\<le> x\n  \\<not> (0::'a) < x", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  x + y + sum_list xs = (0::'a)\n  (0::'a) \\<le> x\n  \\<not> (0::'a) < x\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "by (auto simp: v_def)"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal (1 subgoal):\n 1. (0::'a) < x \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) < x \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume x: \"x > 0\""], ["proof (state)\nthis:\n  (0::'a) < x\n\ngoal (1 subgoal):\n 1. (0::'a) < x \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "proof (rule linorder_cases[of y 0])"], ["proof (state)\ngoal (3 subgoals):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume y: \"y > 0\""], ["proof (state)\nthis:\n  (0::'a) < y\n\ngoal (3 subgoals):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from x and this"], ["proof (chain)\npicking this:\n  (0::'a) < x\n  (0::'a) < y", "have xy: \"x + y > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < x\n  (0::'a) < y\n\ngoal (1 subgoal):\n 1. (0::'a) < x + y", "by (rule add_pos_pos)"], ["proof (state)\nthis:\n  (0::'a) < x + y\n\ngoal (3 subgoals):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "with y"], ["proof (chain)\npicking this:\n  (0::'a) < y\n  (0::'a) < x + y", "have \"sign_changes ((x + y) # xs) = sign_changes (y # xs)\""], ["proof (prove)\nusing this:\n  (0::'a) < y\n  (0::'a) < x + y\n\ngoal (1 subgoal):\n 1. sign_changes ((x + y) # xs) = sign_changes (y # xs)", "by (intro sign_changes_cong) auto"], ["proof (state)\nthis:\n  sign_changes ((x + y) # xs) = sign_changes (y # xs)\n\ngoal (3 subgoals):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "moreover"], ["proof (state)\nthis:\n  sign_changes ((x + y) # xs) = sign_changes (y # xs)\n\ngoal (3 subgoals):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "have \"sign_changes (x # psums ((x + y) # xs)) = \n                       sign_changes (psums ((x+y) # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (x # psums ((x + y) # xs)) =\n    sign_changes (psums ((x + y) # xs))", "using x xy"], ["proof (prove)\nusing this:\n  (0::'a) < x\n  (0::'a) < x + y\n\ngoal (1 subgoal):\n 1. sign_changes (x # psums ((x + y) # xs)) =\n    sign_changes (psums ((x + y) # xs))", "by (subst (1 2) psums_Cons) (simp_all add: sign_changes_Cons_Cons_same)"], ["proof (state)\nthis:\n  sign_changes (x # psums ((x + y) # xs)) =\n  sign_changes (psums ((x + y) # xs))\n\ngoal (3 subgoals):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "ultimately"], ["proof (chain)\npicking this:\n  sign_changes ((x + y) # xs) = sign_changes (y # xs)\n  sign_changes (x # psums ((x + y) # xs)) =\n  sign_changes (psums ((x + y) # xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes ((x + y) # xs) = sign_changes (y # xs)\n  sign_changes (x # psums ((x + y) # xs)) =\n  sign_changes (psums ((x + y) # xs))\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "using x y"], ["proof (prove)\nusing this:\n  sign_changes ((x + y) # xs) = sign_changes (y # xs)\n  sign_changes (x # psums ((x + y) # xs)) =\n  sign_changes (psums ((x + y) # xs))\n  (0::'a) < x\n  (0::'a) < y\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "by (simp add: v_def algebra_simps sign_changes_Cons_Cons_same)"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal (2 subgoals):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume y: \"y = 0\""], ["proof (state)\nthis:\n  y = (0::'a)\n\ngoal (2 subgoals):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "with x"], ["proof (chain)\npicking this:\n  (0::'a) < x\n  y = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) < x\n  y = (0::'a)\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "by (simp add: v_def sign_changes_Cons_Cons_0 psums_Cons \n                      o_def sign_changes_Cons_Cons_same)"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal (1 subgoal):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume y: \"y < 0\""], ["proof (state)\nthis:\n  y < (0::'a)\n\ngoal (1 subgoal):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "with x"], ["proof (chain)\npicking this:\n  (0::'a) < x\n  y < (0::'a)", "have different: \"x * y < 0\""], ["proof (prove)\nusing this:\n  (0::'a) < x\n  y < (0::'a)\n\ngoal (1 subgoal):\n 1. x * y < (0::'a)", "by (rule mult_pos_neg)"], ["proof (state)\nthis:\n  x * y < (0::'a)\n\ngoal (1 subgoal):\n 1. y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "proof (rule linorder_cases[of \"x + y\" 0])"], ["proof (state)\ngoal (3 subgoals):\n 1. x + y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. x + y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume xy: \"x + y < 0\""], ["proof (state)\nthis:\n  x + y < (0::'a)\n\ngoal (3 subgoals):\n 1. x + y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. x + y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "with x"], ["proof (chain)\npicking this:\n  (0::'a) < x\n  x + y < (0::'a)", "have different': \"x * (x + y) < 0\""], ["proof (prove)\nusing this:\n  (0::'a) < x\n  x + y < (0::'a)\n\ngoal (1 subgoal):\n 1. x * (x + y) < (0::'a)", "by (rule mult_pos_neg)"], ["proof (state)\nthis:\n  x * (x + y) < (0::'a)\n\ngoal (3 subgoals):\n 1. x + y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. x + y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "have \"(\\<lambda>t. t + (x + y)) = ((+) (x + y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. t + (x + y)) = (+) (x + y)", "by (rule ext) simp"], ["proof (state)\nthis:\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)\n\ngoal (3 subgoals):\n 1. x + y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. x + y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)\n\ngoal (3 subgoals):\n 1. x + y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. x + y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from y xy"], ["proof (chain)\npicking this:\n  y < (0::'a)\n  x + y < (0::'a)", "have \"sign_changes ((x+y) # xs) = sign_changes (y # xs)\""], ["proof (prove)\nusing this:\n  y < (0::'a)\n  x + y < (0::'a)\n\ngoal (1 subgoal):\n 1. sign_changes ((x + y) # xs) = sign_changes (y # xs)", "by (intro sign_changes_cong) auto"], ["proof (state)\nthis:\n  sign_changes ((x + y) # xs) = sign_changes (y # xs)\n\ngoal (3 subgoals):\n 1. x + y < (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. x + y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 3. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)\n  sign_changes ((x + y) # xs) = sign_changes (y # xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)\n  sign_changes ((x + y) # xs) = sign_changes (y # xs)\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "using xy different different' y"], ["proof (prove)\nusing this:\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)\n  sign_changes ((x + y) # xs) = sign_changes (y # xs)\n  x + y < (0::'a)\n  x * y < (0::'a)\n  x * (x + y) < (0::'a)\n  y < (0::'a)\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "by (simp add: v_def sign_changes_Cons_Cons_different psums_Cons o_def add_ac)"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal (2 subgoals):\n 1. x + y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x + y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume xy: \"x + y = 0\""], ["proof (state)\nthis:\n  x + y = (0::'a)\n\ngoal (2 subgoals):\n 1. x + y = (0::'a) \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "proof (cases \"xs ! p > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume p: \"xs ! p > 0\""], ["proof (state)\nthis:\n  (0::'a) < xs ! p\n\ngoal (2 subgoals):\n 1. (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from p y"], ["proof (chain)\npicking this:\n  (0::'a) < xs ! p\n  y < (0::'a)", "have different': \"y * xs ! p < 0\""], ["proof (prove)\nusing this:\n  (0::'a) < xs ! p\n  y < (0::'a)\n\ngoal (1 subgoal):\n 1. y * xs ! p < (0::'a)", "by (intro mult_neg_pos)"], ["proof (state)\nthis:\n  y * xs ! p < (0::'a)\n\ngoal (2 subgoals):\n 1. (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "with v_decompose[of \"[x, y]\"] v_decompose[of \"[x+y]\"] x xy p different different' \n               v_psums_decompose[of \"[x]\"] v_psums_decompose[of \"[]\"]"], ["proof (chain)\npicking this:\n  v ([x, y] @ xs) = v ([x, y] @ [xs ! p]) + v (xs ! p # xs2)\n  v ([x + y] @ xs) = v ([x + y] @ [xs ! p]) + v (xs ! p # xs2)\n  (0::'a) < x\n  x + y = (0::'a)\n  (0::'a) < xs ! p\n  x * y < (0::'a)\n  y * xs ! p < (0::'a)\n  sign_changes ([x] @ psums xs) =\n  sign_changes ([x] @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n  sign_changes ([] @ psums xs) =\n  sign_changes ([] @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n  y * xs ! p < (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  v ([x, y] @ xs) = v ([x, y] @ [xs ! p]) + v (xs ! p # xs2)\n  v ([x + y] @ xs) = v ([x + y] @ [xs ! p]) + v (xs ! p # xs2)\n  (0::'a) < x\n  x + y = (0::'a)\n  (0::'a) < xs ! p\n  x * y < (0::'a)\n  y * xs ! p < (0::'a)\n  sign_changes ([x] @ psums xs) =\n  sign_changes ([x] @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n  sign_changes ([] @ psums xs) =\n  sign_changes ([] @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n  y * xs ! p < (0::'a)\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "by (auto simp add: algebra_simps v_def sign_changes_Cons_Cons_0 \n                             sign_changes_Cons_Cons_different sign_changes_Cons_Cons_same)"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume \"\\<not>(xs ! p > 0)\""], ["proof (state)\nthis:\n  \\<not> (0::'a) < xs ! p\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "with p_nz"], ["proof (chain)\npicking this:\n  xs ! p \\<noteq> (0::'a)\n  \\<not> (0::'a) < xs ! p", "have p: \"xs ! p < 0\""], ["proof (prove)\nusing this:\n  xs ! p \\<noteq> (0::'a)\n  \\<not> (0::'a) < xs ! p\n\ngoal (1 subgoal):\n 1. xs ! p < (0::'a)", "by simp"], ["proof (state)\nthis:\n  xs ! p < (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from p y"], ["proof (chain)\npicking this:\n  xs ! p < (0::'a)\n  y < (0::'a)", "have same: \"y * xs ! p > 0\""], ["proof (prove)\nusing this:\n  xs ! p < (0::'a)\n  y < (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) < y * xs ! p", "by (intro mult_neg_neg)"], ["proof (state)\nthis:\n  (0::'a) < y * xs ! p\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from p x"], ["proof (chain)\npicking this:\n  xs ! p < (0::'a)\n  (0::'a) < x", "have different': \"x * xs ! p < 0\""], ["proof (prove)\nusing this:\n  xs ! p < (0::'a)\n  (0::'a) < x\n\ngoal (1 subgoal):\n 1. x * xs ! p < (0::'a)", "by (intro mult_pos_neg)"], ["proof (state)\nthis:\n  x * xs ! p < (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from v_decompose[of \"[x, y]\"] v_decompose[of \"[x+y]\"] xy different different' same \n               v_psums_decompose[of \"[x]\"] v_psums_decompose[of \"[]\"]"], ["proof (chain)\npicking this:\n  v ([x, y] @ xs) = v ([x, y] @ [xs ! p]) + v (xs ! p # xs2)\n  v ([x + y] @ xs) = v ([x + y] @ [xs ! p]) + v (xs ! p # xs2)\n  x + y = (0::'a)\n  x * y < (0::'a)\n  x * xs ! p < (0::'a)\n  (0::'a) < y * xs ! p\n  sign_changes ([x] @ psums xs) =\n  sign_changes ([x] @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n  sign_changes ([] @ psums xs) =\n  sign_changes ([] @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))", "show ?thesis"], ["proof (prove)\nusing this:\n  v ([x, y] @ xs) = v ([x, y] @ [xs ! p]) + v (xs ! p # xs2)\n  v ([x + y] @ xs) = v ([x + y] @ [xs ! p]) + v (xs ! p # xs2)\n  x + y = (0::'a)\n  x * y < (0::'a)\n  x * xs ! p < (0::'a)\n  (0::'a) < y * xs ! p\n  sign_changes ([x] @ psums xs) =\n  sign_changes ([x] @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n  sign_changes ([] @ psums xs) =\n  sign_changes ([] @ [xs ! p]) +\n  sign_changes (xs ! p # map ((+) (xs ! p)) (psums xs2))\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "by (auto simp add: algebra_simps v_def sign_changes_Cons_Cons_0 \n                             sign_changes_Cons_Cons_different sign_changes_Cons_Cons_same)"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal (1 subgoal):\n 1. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume xy: \"x + y > 0\""], ["proof (state)\nthis:\n  (0::'a) < x + y\n\ngoal (1 subgoal):\n 1. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from x and this"], ["proof (chain)\npicking this:\n  (0::'a) < x\n  (0::'a) < x + y", "have same: \"x * (x + y) > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < x\n  (0::'a) < x + y\n\ngoal (1 subgoal):\n 1. (0::'a) < x * (x + y)", "by (rule mult_pos_pos)"], ["proof (state)\nthis:\n  (0::'a) < x * (x + y)\n\ngoal (1 subgoal):\n 1. (0::'a) < x + y \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "proof (cases \"xs ! p > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume p: \"xs ! p > 0\""], ["proof (state)\nthis:\n  (0::'a) < xs ! p\n\ngoal (2 subgoals):\n 1. (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from xy p"], ["proof (chain)\npicking this:\n  (0::'a) < x + y\n  (0::'a) < xs ! p", "have same': \"(x + y) * xs ! p > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < x + y\n  (0::'a) < xs ! p\n\ngoal (1 subgoal):\n 1. (0::'a) < (x + y) * xs ! p", "by (intro mult_pos_pos)"], ["proof (state)\nthis:\n  (0::'a) < (x + y) * xs ! p\n\ngoal (2 subgoals):\n 1. (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from p y"], ["proof (chain)\npicking this:\n  (0::'a) < xs ! p\n  y < (0::'a)", "have different': \"y * xs ! p < 0\""], ["proof (prove)\nusing this:\n  (0::'a) < xs ! p\n  y < (0::'a)\n\ngoal (1 subgoal):\n 1. y * xs ! p < (0::'a)", "by (intro mult_neg_pos)"], ["proof (state)\nthis:\n  y * xs ! p < (0::'a)\n\ngoal (2 subgoals):\n 1. (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "have \"(\\<lambda>t. t + (x + y)) = ((+) (x + y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. t + (x + y)) = (+) (x + y)", "by (rule ext) simp"], ["proof (state)\nthis:\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)\n\ngoal (2 subgoals):\n 1. (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n 2. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "with v_decompose[of \"[x, y]\"] v_decompose[of \"[x+y]\"] different different' same same'"], ["proof (chain)\npicking this:\n  v ([x, y] @ xs) = v ([x, y] @ [xs ! p]) + v (xs ! p # xs2)\n  v ([x + y] @ xs) = v ([x + y] @ [xs ! p]) + v (xs ! p # xs2)\n  x * y < (0::'a)\n  y * xs ! p < (0::'a)\n  (0::'a) < x * (x + y)\n  (0::'a) < (x + y) * xs ! p\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)", "show ?thesis"], ["proof (prove)\nusing this:\n  v ([x, y] @ xs) = v ([x, y] @ [xs ! p]) + v (xs ! p # xs2)\n  v ([x + y] @ xs) = v ([x + y] @ [xs ! p]) + v (xs ! p # xs2)\n  x * y < (0::'a)\n  y * xs ! p < (0::'a)\n  (0::'a) < x * (x + y)\n  (0::'a) < (x + y) * xs ! p\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "by (auto simp add: algebra_simps v_def psums_Cons o_def\n                             sign_changes_Cons_Cons_different sign_changes_Cons_Cons_same)"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "assume \"\\<not>(xs ! p > 0)\""], ["proof (state)\nthis:\n  \\<not> (0::'a) < xs ! p\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "with p_nz"], ["proof (chain)\npicking this:\n  xs ! p \\<noteq> (0::'a)\n  \\<not> (0::'a) < xs ! p", "have p: \"xs ! p < 0\""], ["proof (prove)\nusing this:\n  xs ! p \\<noteq> (0::'a)\n  \\<not> (0::'a) < xs ! p\n\ngoal (1 subgoal):\n 1. xs ! p < (0::'a)", "by simp"], ["proof (state)\nthis:\n  xs ! p < (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from xy p"], ["proof (chain)\npicking this:\n  (0::'a) < x + y\n  xs ! p < (0::'a)", "have different': \"(x + y) * xs ! p < 0\""], ["proof (prove)\nusing this:\n  (0::'a) < x + y\n  xs ! p < (0::'a)\n\ngoal (1 subgoal):\n 1. (x + y) * xs ! p < (0::'a)", "by (rule mult_pos_neg)"], ["proof (state)\nthis:\n  (x + y) * xs ! p < (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "from y p"], ["proof (chain)\npicking this:\n  y < (0::'a)\n  xs ! p < (0::'a)", "have same': \"y * xs ! p > 0\""], ["proof (prove)\nusing this:\n  y < (0::'a)\n  xs ! p < (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) < y * xs ! p", "by (rule mult_neg_neg)"], ["proof (state)\nthis:\n  (0::'a) < y * xs ! p\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "have \"(\\<lambda>t. t + (x + y)) = ((+) (x + y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. t + (x + y)) = (+) (x + y)", "by (rule ext) simp"], ["proof (state)\nthis:\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)\n\ngoal (1 subgoal):\n 1. \\<not> (0::'a) < xs ! p \\<Longrightarrow>\n    v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "with v_decompose[of \"[x, y]\"] v_decompose[of \"[x+y]\"] different different' same same'"], ["proof (chain)\npicking this:\n  v ([x, y] @ xs) = v ([x, y] @ [xs ! p]) + v (xs ! p # xs2)\n  v ([x + y] @ xs) = v ([x + y] @ [xs ! p]) + v (xs ! p # xs2)\n  x * y < (0::'a)\n  (x + y) * xs ! p < (0::'a)\n  (0::'a) < x * (x + y)\n  (0::'a) < y * xs ! p\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)", "show ?thesis"], ["proof (prove)\nusing this:\n  v ([x, y] @ xs) = v ([x, y] @ [xs ! p]) + v (xs ! p # xs2)\n  v ([x + y] @ xs) = v ([x + y] @ [xs ! p]) + v (xs ! p # xs2)\n  x * y < (0::'a)\n  (x + y) * xs ! p < (0::'a)\n  (0::'a) < x * (x + y)\n  (0::'a) < y * xs ! p\n  (\\<lambda>t. t + (x + y)) = (+) (x + y)\n\ngoal (1 subgoal):\n 1. v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n    \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n    even\n     (v (x # y # xs) - v ((x + y) # xs) -\n      (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))", "by (auto simp add: algebra_simps v_def psums_Cons o_def\n                              sign_changes_Cons_Cons_different sign_changes_Cons_Cons_same)"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v (psums (x # y # xs)) - v (psums ((x + y) # xs))\n  \\<le> v (x # y # xs) - v ((x + y) # xs) \\<and>\n  even\n   (v (x # y # xs) - v ((x + y) # xs) -\n    (v (psums (x # y # xs)) - v (psums ((x + y) # xs))))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Now we can prove the main lemma of the proof by induction over the list with our specialised\n  induction rule for @{term \"sign_changes\"}. It states that for a non-empty list whose last element \n  is non-zero and whose sum is zero, the difference of the sign changes in the list and in the list \n  of its partial sums is odd and positive. \n\\<close>"], ["", "lemma arthan:\n  fixes xs :: \"'a :: linordered_idom list\"\n  assumes \"xs \\<noteq> []\" \"last xs \\<noteq> 0\" \"sum_list xs = 0\"\n  shows   \"sign_changes xs > sign_changes (psums xs) \\<and> \n           odd (sign_changes xs - sign_changes (psums xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (psums xs) < sign_changes xs \\<and>\n    odd (sign_changes xs - sign_changes (psums xs))", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  last xs \\<noteq> (0::'a)\n  sum_list xs = (0::'a)\n\ngoal (1 subgoal):\n 1. sign_changes (psums xs) < sign_changes xs \\<and>\n    odd (sign_changes xs - sign_changes (psums xs))", "proof (induction xs rule: sign_changes_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; last [] \\<noteq> (0::'a);\n     sum_list [] = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> sign_changes (psums []) < sign_changes [] \\<and>\n                      odd (sign_changes [] - sign_changes (psums []))\n 2. \\<And>x.\n       \\<lbrakk>[x] \\<noteq> []; last [x] \\<noteq> (0::'a);\n        sum_list [x] = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sign_changes (psums [x]) < sign_changes [x] \\<and>\n                         odd (sign_changes [x] - sign_changes (psums [x]))\n 3. \\<And>xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n                 sum_list xs = (0::'a)\\<rbrakk>\n                \\<Longrightarrow> sign_changes (psums xs)\n                                  < sign_changes xs \\<and>\n                                  odd (sign_changes xs -\n sign_changes (psums xs));\n        (0::'a) # xs \\<noteq> []; last ((0::'a) # xs) \\<noteq> (0::'a);\n        sum_list ((0::'a) # xs) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sign_changes (psums ((0::'a) # xs))\n                         < sign_changes ((0::'a) # xs) \\<and>\n                         odd (sign_changes ((0::'a) # xs) -\n                              sign_changes (psums ((0::'a) # xs)))\n 4. \\<And>x y xs.\n       \\<lbrakk>x \\<noteq> (0::'a);\n        \\<lbrakk>(x + y) # xs \\<noteq> [];\n         last ((x + y) # xs) \\<noteq> (0::'a);\n         sum_list ((x + y) # xs) = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> sign_changes (psums ((x + y) # xs))\n                          < sign_changes ((x + y) # xs) \\<and>\n                          odd (sign_changes ((x + y) # xs) -\n                               sign_changes (psums ((x + y) # xs)));\n        x # y # xs \\<noteq> []; last (x # y # xs) \\<noteq> (0::'a);\n        sum_list (x # y # xs) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sign_changes (psums (x # y # xs))\n                         < sign_changes (x # y # xs) \\<and>\n                         odd (sign_changes (x # y # xs) -\n                              sign_changes (psums (x # y # xs)))", "case (nonzero x y xs)"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n  \\<lbrakk>(x + y) # xs \\<noteq> []; last ((x + y) # xs) \\<noteq> (0::'a);\n   sum_list ((x + y) # xs) = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> sign_changes (psums ((x + y) # xs))\n                    < sign_changes ((x + y) # xs) \\<and>\n                    odd (sign_changes ((x + y) # xs) -\n                         sign_changes (psums ((x + y) # xs)))\n  x # y # xs \\<noteq> []\n  last (x # y # xs) \\<noteq> (0::'a)\n  sum_list (x # y # xs) = (0::'a)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; last [] \\<noteq> (0::'a);\n     sum_list [] = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> sign_changes (psums []) < sign_changes [] \\<and>\n                      odd (sign_changes [] - sign_changes (psums []))\n 2. \\<And>x.\n       \\<lbrakk>[x] \\<noteq> []; last [x] \\<noteq> (0::'a);\n        sum_list [x] = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sign_changes (psums [x]) < sign_changes [x] \\<and>\n                         odd (sign_changes [x] - sign_changes (psums [x]))\n 3. \\<And>xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n                 sum_list xs = (0::'a)\\<rbrakk>\n                \\<Longrightarrow> sign_changes (psums xs)\n                                  < sign_changes xs \\<and>\n                                  odd (sign_changes xs -\n sign_changes (psums xs));\n        (0::'a) # xs \\<noteq> []; last ((0::'a) # xs) \\<noteq> (0::'a);\n        sum_list ((0::'a) # xs) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sign_changes (psums ((0::'a) # xs))\n                         < sign_changes ((0::'a) # xs) \\<and>\n                         odd (sign_changes ((0::'a) # xs) -\n                              sign_changes (psums ((0::'a) # xs)))\n 4. \\<And>x y xs.\n       \\<lbrakk>x \\<noteq> (0::'a);\n        \\<lbrakk>(x + y) # xs \\<noteq> [];\n         last ((x + y) # xs) \\<noteq> (0::'a);\n         sum_list ((x + y) # xs) = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> sign_changes (psums ((x + y) # xs))\n                          < sign_changes ((x + y) # xs) \\<and>\n                          odd (sign_changes ((x + y) # xs) -\n                               sign_changes (psums ((x + y) # xs)));\n        x # y # xs \\<noteq> []; last (x # y # xs) \\<noteq> (0::'a);\n        sum_list (x # y # xs) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sign_changes (psums (x # y # xs))\n                         < sign_changes (x # y # xs) \\<and>\n                         odd (sign_changes (x # y # xs) -\n                              sign_changes (psums (x # y # xs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))", "define \\<alpha> where \"\\<alpha> = int (sign_changes (x # y # xs)) - int (sign_changes ((x + y) # xs))\""], ["proof (state)\nthis:\n  \\<alpha> =\n  int (sign_changes (x # y # xs)) - int (sign_changes ((x + y) # xs))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))", "define \\<beta> where \"\\<beta> = int (sign_changes (psums (x # y # xs))) - int (sign_changes (psums ((x+y) # xs)))\""], ["proof (state)\nthis:\n  \\<beta> =\n  int (sign_changes (psums (x # y # xs))) -\n  int (sign_changes (psums ((x + y) # xs)))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))", "from nonzero False"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'a)\n  \\<lbrakk>(x + y) # xs \\<noteq> []; last ((x + y) # xs) \\<noteq> (0::'a);\n   sum_list ((x + y) # xs) = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> sign_changes (psums ((x + y) # xs))\n                    < sign_changes ((x + y) # xs) \\<and>\n                    odd (sign_changes ((x + y) # xs) -\n                         sign_changes (psums ((x + y) # xs)))\n  x # y # xs \\<noteq> []\n  last (x # y # xs) \\<noteq> (0::'a)\n  sum_list (x # y # xs) = (0::'a)\n  xs \\<noteq> []", "have \"\\<alpha> \\<ge> \\<beta> \\<and> even (\\<alpha> - \\<beta>)\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  \\<lbrakk>(x + y) # xs \\<noteq> []; last ((x + y) # xs) \\<noteq> (0::'a);\n   sum_list ((x + y) # xs) = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> sign_changes (psums ((x + y) # xs))\n                    < sign_changes ((x + y) # xs) \\<and>\n                    odd (sign_changes ((x + y) # xs) -\n                         sign_changes (psums ((x + y) # xs)))\n  x # y # xs \\<noteq> []\n  last (x # y # xs) \\<noteq> (0::'a)\n  sum_list (x # y # xs) = (0::'a)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<beta> \\<le> \\<alpha> \\<and> even (\\<alpha> - \\<beta>)", "unfolding \\<alpha>_def \\<beta>_def"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  \\<lbrakk>(x + y) # xs \\<noteq> []; last ((x + y) # xs) \\<noteq> (0::'a);\n   sum_list ((x + y) # xs) = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> sign_changes (psums ((x + y) # xs))\n                    < sign_changes ((x + y) # xs) \\<and>\n                    odd (sign_changes ((x + y) # xs) -\n                         sign_changes (psums ((x + y) # xs)))\n  x # y # xs \\<noteq> []\n  last (x # y # xs) \\<noteq> (0::'a)\n  sum_list (x # y # xs) = (0::'a)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. int (sign_changes (psums (x # y # xs))) -\n    int (sign_changes (psums ((x + y) # xs)))\n    \\<le> int (sign_changes (x # y # xs)) -\n          int (sign_changes ((x + y) # xs)) \\<and>\n    even\n     (int (sign_changes (x # y # xs)) - int (sign_changes ((x + y) # xs)) -\n      (int (sign_changes (psums (x # y # xs))) -\n       int (sign_changes (psums ((x + y) # xs)))))", "by (intro arthan_aux1) auto"], ["proof (state)\nthis:\n  \\<beta> \\<le> \\<alpha> \\<and> even (\\<alpha> - \\<beta>)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))", "from False and nonzero.prems"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  x # y # xs \\<noteq> []\n  last (x # y # xs) \\<noteq> (0::'a)\n  sum_list (x # y # xs) = (0::'a)", "have\n       \"sign_changes (psums ((x + y) # xs)) < sign_changes ((x + y) # xs) \\<and>\n        odd (sign_changes ((x + y) # xs) - sign_changes (psums ((x + y) # xs)))\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  x # y # xs \\<noteq> []\n  last (x # y # xs) \\<noteq> (0::'a)\n  sum_list (x # y # xs) = (0::'a)\n\ngoal (1 subgoal):\n 1. sign_changes (psums ((x + y) # xs)) < sign_changes ((x + y) # xs) \\<and>\n    odd (sign_changes ((x + y) # xs) - sign_changes (psums ((x + y) # xs)))", "by (intro nonzero.IH) (auto simp: add.assoc)"], ["proof (state)\nthis:\n  sign_changes (psums ((x + y) # xs)) < sign_changes ((x + y) # xs) \\<and>\n  odd (sign_changes ((x + y) # xs) - sign_changes (psums ((x + y) # xs)))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))", "with arthan_aux1[of xs x y] nonzero(4,5) False(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n   x + y + sum_list xs = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> int (sign_changes (psums (x # y # xs))) -\n                    int (sign_changes (psums ((x + y) # xs)))\n                    \\<le> int (sign_changes (x # y # xs)) -\n                          int (sign_changes ((x + y) # xs)) \\<and>\n                    even\n                     (int (sign_changes (x # y # xs)) -\n                      int (sign_changes ((x + y) # xs)) -\n                      (int (sign_changes (psums (x # y # xs))) -\n                       int (sign_changes (psums ((x + y) # xs)))))\n  last (x # y # xs) \\<noteq> (0::'a)\n  sum_list (x # y # xs) = (0::'a)\n  xs \\<noteq> []\n  sign_changes (psums ((x + y) # xs)) < sign_changes ((x + y) # xs) \\<and>\n  odd (sign_changes ((x + y) # xs) - sign_changes (psums ((x + y) # xs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n   x + y + sum_list xs = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> int (sign_changes (psums (x # y # xs))) -\n                    int (sign_changes (psums ((x + y) # xs)))\n                    \\<le> int (sign_changes (x # y # xs)) -\n                          int (sign_changes ((x + y) # xs)) \\<and>\n                    even\n                     (int (sign_changes (x # y # xs)) -\n                      int (sign_changes ((x + y) # xs)) -\n                      (int (sign_changes (psums (x # y # xs))) -\n                       int (sign_changes (psums ((x + y) # xs)))))\n  last (x # y # xs) \\<noteq> (0::'a)\n  sum_list (x # y # xs) = (0::'a)\n  xs \\<noteq> []\n  sign_changes (psums ((x + y) # xs)) < sign_changes ((x + y) # xs) \\<and>\n  odd (sign_changes ((x + y) # xs) - sign_changes (psums ((x + y) # xs)))\n\ngoal (1 subgoal):\n 1. sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))", "by force"], ["proof (state)\nthis:\n  sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n  odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n    odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))", "qed (insert nonzero.prems, auto split: if_split_asm simp: sign_changes_two add_eq_0_iff)"], ["proof (state)\nthis:\n  sign_changes (psums (x # y # xs)) < sign_changes (x # y # xs) \\<and>\n  odd (sign_changes (x # y # xs) - sign_changes (psums (x # y # xs)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; last [] \\<noteq> (0::'a);\n     sum_list [] = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> sign_changes (psums []) < sign_changes [] \\<and>\n                      odd (sign_changes [] - sign_changes (psums []))\n 2. \\<And>x.\n       \\<lbrakk>[x] \\<noteq> []; last [x] \\<noteq> (0::'a);\n        sum_list [x] = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sign_changes (psums [x]) < sign_changes [x] \\<and>\n                         odd (sign_changes [x] - sign_changes (psums [x]))\n 3. \\<And>xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> []; last xs \\<noteq> (0::'a);\n                 sum_list xs = (0::'a)\\<rbrakk>\n                \\<Longrightarrow> sign_changes (psums xs)\n                                  < sign_changes xs \\<and>\n                                  odd (sign_changes xs -\n sign_changes (psums xs));\n        (0::'a) # xs \\<noteq> []; last ((0::'a) # xs) \\<noteq> (0::'a);\n        sum_list ((0::'a) # xs) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sign_changes (psums ((0::'a) # xs))\n                         < sign_changes ((0::'a) # xs) \\<and>\n                         odd (sign_changes ((0::'a) # xs) -\n                              sign_changes (psums ((0::'a) # xs)))", "qed (auto split: if_split_asm simp: add_eq_0_iff)"], ["", "end"], ["", "subsection \\<open>Roots of a polynomial with a certain property\\<close>"], ["", "text \\<open>\n  The set of roots of a polynomial @{term \"p\"} that fulfil a given property @{term \"P\"}:\n\\<close>"], ["", "definition \"roots_with P p = {x. P x \\<and> poly p x = 0}\""], ["", "text \\<open>\n  The number of roots of a polynomial @{term \"p\"} with a given property @{term \"P\"}, where \n  multiple roots are counted multiple times.\n \\<close>"], ["", "definition \"count_roots_with P p = (\\<Sum>x\\<in>roots_with P p. order x p)\""], ["", "abbreviation \"pos_roots \\<equiv> roots_with (\\<lambda>x. x > 0)\""], ["", "abbreviation \"count_pos_roots \\<equiv> count_roots_with (\\<lambda>x. x > 0)\""], ["", "lemma finite_roots_with [simp]: \n  \"(p :: 'a :: linordered_idom poly) \\<noteq> 0 \\<Longrightarrow> finite (roots_with P p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> finite (roots_with P p)", "by (rule finite_subset[OF _ poly_roots_finite[of p]]) (auto simp: roots_with_def)"], ["", "lemma count_roots_with_times_root:\n  assumes \"p \\<noteq> 0\" \"P (a :: 'a :: linordered_idom)\"\n  shows   \"count_roots_with P ([:a, -1:] * p) = Suc (count_roots_with P p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "define q where \"q = [:a, -1:] * p\""], ["proof (state)\nthis:\n  q = [:a, - (1::'a):] * p\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  P a", "have a: \"a \\<in> roots_with P q\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  P a\n\ngoal (1 subgoal):\n 1. a \\<in> roots_with P q", "by (simp_all add: roots_with_def q_def)"], ["proof (state)\nthis:\n  a \\<in> roots_with P q\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "have q_nz: \"q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a, - (1::'a):] * p \\<noteq> 0", "by (rule no_zero_divisors) (simp_all add: assms)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "have \"count_roots_with P q = (\\<Sum>x\\<in>roots_with P q. order x q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_with P q = (\\<Sum>x\\<in>roots_with P q. order x q)", "by (simp add: count_roots_with_def)"], ["proof (state)\nthis:\n  count_roots_with P q = (\\<Sum>x\\<in>roots_with P q. order x q)\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "also"], ["proof (state)\nthis:\n  count_roots_with P q = (\\<Sum>x\\<in>roots_with P q. order x q)\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "from a q_nz"], ["proof (chain)\npicking this:\n  a \\<in> roots_with P q\n  q \\<noteq> 0", "have \"\\<dots> = order a q + (\\<Sum>x\\<in>roots_with P q - {a}. order x q)\""], ["proof (prove)\nusing this:\n  a \\<in> roots_with P q\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>roots_with P q. order x q) =\n    order a q + (\\<Sum>x\\<in>roots_with P q - {a}. order x q)", "by (subst sum.remove) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>roots_with P q. order x q) =\n  order a q + (\\<Sum>x\\<in>roots_with P q - {a}. order x q)\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>roots_with P q. order x q) =\n  order a q + (\\<Sum>x\\<in>roots_with P q - {a}. order x q)\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "have \"order a q = order a [:a, -1:] + order a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a q = order a [:a, - (1::'a):] + order a p", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order a ([:a, - (1::'a):] * p) = order a [:a, - (1::'a):] + order a p", "by (subst order_mult[OF no_zero_divisors]) (simp_all add: assms)"], ["proof (state)\nthis:\n  order a q = order a [:a, - (1::'a):] + order a p\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "also"], ["proof (state)\nthis:\n  order a q = order a [:a, - (1::'a):] + order a p\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "have \"order a [:a, -1:] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a [:a, - (1::'a):] = 1", "by (subst order_smult [of \"-1\", symmetric])\n       (insert order_power_n_n[of a 1], simp_all add: order_1)"], ["proof (state)\nthis:\n  order a [:a, - (1::'a):] = 1\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "also"], ["proof (state)\nthis:\n  order a [:a, - (1::'a):] = 1\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "have \"(\\<Sum>x\\<in>roots_with P q - {a}. order x q) = (\\<Sum>x\\<in>roots_with P q - {a}. order x p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>roots_with P q - {a}. order x q) =\n    (\\<Sum>x\\<in>roots_with P q - {a}. order x p)", "proof (intro sum.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots_with P q - {a} \\<Longrightarrow> order x q = order x p", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots_with P q - {a} \\<Longrightarrow> order x q = order x p", "assume x: \"x \\<in> roots_with P q - {a}\""], ["proof (state)\nthis:\n  x \\<in> roots_with P q - {a}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots_with P q - {a} \\<Longrightarrow> order x q = order x p", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  P a", "have \"order x q = order x [:a, -1:] + order x p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  P a\n\ngoal (1 subgoal):\n 1. order x q = order x [:a, - (1::'a):] + order x p", "unfolding q_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  P a\n\ngoal (1 subgoal):\n 1. order x ([:a, - (1::'a):] * p) = order x [:a, - (1::'a):] + order x p", "by (subst order_mult[OF no_zero_divisors]) (simp_all add: assms)"], ["proof (state)\nthis:\n  order x q = order x [:a, - (1::'a):] + order x p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots_with P q - {a} \\<Longrightarrow> order x q = order x p", "also"], ["proof (state)\nthis:\n  order x q = order x [:a, - (1::'a):] + order x p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots_with P q - {a} \\<Longrightarrow> order x q = order x p", "from x"], ["proof (chain)\npicking this:\n  x \\<in> roots_with P q - {a}", "have \"order x [:a, -1:] = 0\""], ["proof (prove)\nusing this:\n  x \\<in> roots_with P q - {a}\n\ngoal (1 subgoal):\n 1. order x [:a, - (1::'a):] = 0", "by (intro order_0I) simp_all"], ["proof (state)\nthis:\n  order x [:a, - (1::'a):] = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots_with P q - {a} \\<Longrightarrow> order x q = order x p", "finally"], ["proof (chain)\npicking this:\n  order x q = 0 + order x p", "show \"order x q = order x p\""], ["proof (prove)\nusing this:\n  order x q = 0 + order x p\n\ngoal (1 subgoal):\n 1. order x q = order x p", "by simp"], ["proof (state)\nthis:\n  order x q = order x p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>roots_with P q - {a}. order x q) =\n  (\\<Sum>x\\<in>roots_with P q - {a}. order x p)\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>roots_with P q - {a}. order x q) =\n  (\\<Sum>x\\<in>roots_with P q - {a}. order x p)\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "from a q_nz"], ["proof (chain)\npicking this:\n  a \\<in> roots_with P q\n  q \\<noteq> 0", "have \"1 + order a p + (\\<Sum>x\\<in>roots_with P q - {a}. order x p) = \n                           1 + (\\<Sum>x\\<in>roots_with P q. order x p)\""], ["proof (prove)\nusing this:\n  a \\<in> roots_with P q\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 + order a p + (\\<Sum>x\\<in>roots_with P q - {a}. order x p) =\n    1 + (\\<Sum>x\\<in>roots_with P q. order x p)", "by (subst add.assoc, subst sum.remove[symmetric]) simp_all"], ["proof (state)\nthis:\n  1 + order a p + (\\<Sum>x\\<in>roots_with P q - {a}. order x p) =\n  1 + (\\<Sum>x\\<in>roots_with P q. order x p)\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "also"], ["proof (state)\nthis:\n  1 + order a p + (\\<Sum>x\\<in>roots_with P q - {a}. order x p) =\n  1 + (\\<Sum>x\\<in>roots_with P q. order x p)\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "from q_nz"], ["proof (chain)\npicking this:\n  q \\<noteq> 0", "have \"(\\<Sum>x\\<in>roots_with P q. order x p) = (\\<Sum>x\\<in>roots_with P p. order x p)\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>roots_with P q. order x p) =\n    (\\<Sum>x\\<in>roots_with P p. order x p)", "proof (intro sum.mono_neutral_right)"], ["proof (state)\ngoal (3 subgoals):\n 1. q \\<noteq> 0 \\<Longrightarrow> finite (roots_with P q)\n 2. q \\<noteq> 0 \\<Longrightarrow> roots_with P p \\<subseteq> roots_with P q\n 3. q \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>i\\<in>roots_with P q - roots_with P p. order i p = 0", "show \"roots_with P p \\<subseteq> roots_with P q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roots_with P p \\<subseteq> roots_with P q", "by (auto simp: roots_with_def q_def simp del: mult_pCons_left)"], ["proof (state)\nthis:\n  roots_with P p \\<subseteq> roots_with P q\n\ngoal (2 subgoals):\n 1. q \\<noteq> 0 \\<Longrightarrow> finite (roots_with P q)\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>i\\<in>roots_with P q - roots_with P p. order i p = 0", "show \"\\<forall>x\\<in>roots_with P q - roots_with P p. order x p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>roots_with P q - roots_with P p. order x p = 0", "by (auto simp: roots_with_def q_def order_root simp del: mult_pCons_left)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>roots_with P q - roots_with P p. order x p = 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> finite (roots_with P q)", "qed simp_all"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>roots_with P q. order x p) =\n  (\\<Sum>x\\<in>roots_with P p. order x p)\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "finally"], ["proof (chain)\npicking this:\n  count_roots_with P q = 1 + (\\<Sum>x\\<in>roots_with P p. order x p)", "show ?thesis"], ["proof (prove)\nusing this:\n  count_roots_with P q = 1 + (\\<Sum>x\\<in>roots_with P p. order x p)\n\ngoal (1 subgoal):\n 1. count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)", "by (simp add: q_def count_roots_with_def)"], ["proof (state)\nthis:\n  count_roots_with P ([:a, - (1::'a):] * p) = Suc (count_roots_with P p)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Coefficient sign changes of a polynomial\\<close>"], ["", "abbreviation (input) \"coeff_sign_changes f \\<equiv> sign_changes (coeffs f)\""], ["", "text \\<open>\n  We first show that when building a polynomial from a coefficient list, the coefficient sign\n  sign changes of the resulting polynomial are the same as the same sign changes in the list.\n\n  Note that constructing a polynomial from a list removes all trailing zeros.\n\\<close>"], ["", "lemma sign_changes_coeff_sign_changes:\n  assumes \"Poly xs = (p :: 'a :: linordered_idom poly)\"\n  shows   \"sign_changes xs = coeff_sign_changes p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs p)", "have \"coeffs p = coeffs (Poly xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs p = coeffs (Poly xs)", "by (subst assms) (rule refl)"], ["proof (state)\nthis:\n  coeffs p = coeffs (Poly xs)\n\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs p)", "also"], ["proof (state)\nthis:\n  coeffs p = coeffs (Poly xs)\n\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs p)", "have \"\\<dots> = strip_while ((=) 0) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (Poly xs) = strip_while ((=) (0::'a)) xs", "by simp"], ["proof (state)\nthis:\n  coeffs (Poly xs) = strip_while ((=) (0::'a)) xs\n\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs p)", "also"], ["proof (state)\nthis:\n  coeffs (Poly xs) = strip_while ((=) (0::'a)) xs\n\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs p)", "have \"filter ((\\<noteq>) 0) \\<dots> = filter ((\\<noteq>) 0) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) xs) =\n    filter ((\\<noteq>) (0::'a)) xs", "unfolding strip_while_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) (0::'a)) (rev (dropWhile ((=) (0::'a)) (rev xs))) =\n    filter ((\\<noteq>) (0::'a)) xs", "by (subst rev_filter [symmetric], subst filter_dropWhile) (simp_all add: rev_filter)"], ["proof (state)\nthis:\n  filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) xs) =\n  filter ((\\<noteq>) (0::'a)) xs\n\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs p)", "also"], ["proof (state)\nthis:\n  filter ((\\<noteq>) (0::'a)) (strip_while ((=) (0::'a)) xs) =\n  filter ((\\<noteq>) (0::'a)) xs\n\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs p)", "have \"sign_changes \\<dots> = sign_changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (filter ((\\<noteq>) (0::'a)) xs) = sign_changes xs", "by (simp add: sign_changes_filter)"], ["proof (state)\nthis:\n  sign_changes (filter ((\\<noteq>) (0::'a)) xs) = sign_changes xs\n\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs p)", "finally"], ["proof (chain)\npicking this:\n  sign_changes (filter ((\\<noteq>) (0::'a)) (coeffs p)) = sign_changes xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes (filter ((\\<noteq>) (0::'a)) (coeffs p)) = sign_changes xs\n\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs p)", "by (simp add: sign_changes_filter)"], ["proof (state)\nthis:\n  sign_changes xs = sign_changes (coeffs p)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  By applying @{term \"reduce_root a\"}, we can assume w.l.o.g. that the root in\n  question is 1, since applying root reduction does not change the number of \n  sign changes.\n\\<close>"], ["", "lemma coeff_sign_changes_reduce_root: \n  assumes \"a > (0 :: 'a :: linordered_idom)\"\n  shows   \"coeff_sign_changes (reduce_root a p) = coeff_sign_changes p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (coeffs (reduce_root a p)) = sign_changes (coeffs p)", "proof (intro sign_changes_cong, induction p)"], ["proof (state)\ngoal (2 subgoals):\n 1. map sgn (coeffs (reduce_root a 0)) = map sgn (coeffs 0)\n 2. \\<And>aa p.\n       \\<lbrakk>aa \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        map sgn (coeffs (reduce_root a p)) = map sgn (coeffs p)\\<rbrakk>\n       \\<Longrightarrow> map sgn (coeffs (reduce_root a (pCons aa p))) =\n                         map sgn (coeffs (pCons aa p))", "case (pCons c p)"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  map sgn (coeffs (reduce_root a p)) = map sgn (coeffs p)\n\ngoal (2 subgoals):\n 1. map sgn (coeffs (reduce_root a 0)) = map sgn (coeffs 0)\n 2. \\<And>aa p.\n       \\<lbrakk>aa \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        map sgn (coeffs (reduce_root a p)) = map sgn (coeffs p)\\<rbrakk>\n       \\<Longrightarrow> map sgn (coeffs (reduce_root a (pCons aa p))) =\n                         map sgn (coeffs (pCons aa p))", "have \"map sgn (coeffs (reduce_root a (pCons c p))) = \n             cCons (sgn c) (map sgn (coeffs (reduce_root a p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map sgn (coeffs (reduce_root a (pCons c p))) =\n    cCons (sgn c) (map sgn (coeffs (reduce_root a p)))", "using assms"], ["proof (prove)\nusing this:\n  (0::'a) < a\n\ngoal (1 subgoal):\n 1. map sgn (coeffs (reduce_root a (pCons c p))) =\n    cCons (sgn c) (map sgn (coeffs (reduce_root a p)))", "by (auto simp add: cCons_def sgn_0_0 sgn_mult reduce_root_pCons coeffs_smult)"], ["proof (state)\nthis:\n  map sgn (coeffs (reduce_root a (pCons c p))) =\n  cCons (sgn c) (map sgn (coeffs (reduce_root a p)))\n\ngoal (2 subgoals):\n 1. map sgn (coeffs (reduce_root a 0)) = map sgn (coeffs 0)\n 2. \\<And>aa p.\n       \\<lbrakk>aa \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        map sgn (coeffs (reduce_root a p)) = map sgn (coeffs p)\\<rbrakk>\n       \\<Longrightarrow> map sgn (coeffs (reduce_root a (pCons aa p))) =\n                         map sgn (coeffs (pCons aa p))", "also"], ["proof (state)\nthis:\n  map sgn (coeffs (reduce_root a (pCons c p))) =\n  cCons (sgn c) (map sgn (coeffs (reduce_root a p)))\n\ngoal (2 subgoals):\n 1. map sgn (coeffs (reduce_root a 0)) = map sgn (coeffs 0)\n 2. \\<And>aa p.\n       \\<lbrakk>aa \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        map sgn (coeffs (reduce_root a p)) = map sgn (coeffs p)\\<rbrakk>\n       \\<Longrightarrow> map sgn (coeffs (reduce_root a (pCons aa p))) =\n                         map sgn (coeffs (pCons aa p))", "note pCons.IH"], ["proof (state)\nthis:\n  map sgn (coeffs (reduce_root a p)) = map sgn (coeffs p)\n\ngoal (2 subgoals):\n 1. map sgn (coeffs (reduce_root a 0)) = map sgn (coeffs 0)\n 2. \\<And>aa p.\n       \\<lbrakk>aa \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        map sgn (coeffs (reduce_root a p)) = map sgn (coeffs p)\\<rbrakk>\n       \\<Longrightarrow> map sgn (coeffs (reduce_root a (pCons aa p))) =\n                         map sgn (coeffs (pCons aa p))", "also"], ["proof (state)\nthis:\n  map sgn (coeffs (reduce_root a p)) = map sgn (coeffs p)\n\ngoal (2 subgoals):\n 1. map sgn (coeffs (reduce_root a 0)) = map sgn (coeffs 0)\n 2. \\<And>aa p.\n       \\<lbrakk>aa \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        map sgn (coeffs (reduce_root a p)) = map sgn (coeffs p)\\<rbrakk>\n       \\<Longrightarrow> map sgn (coeffs (reduce_root a (pCons aa p))) =\n                         map sgn (coeffs (pCons aa p))", "have \"cCons (sgn c) (map sgn (coeffs p)) = map sgn (coeffs (pCons c p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cCons (sgn c) (map sgn (coeffs p)) = map sgn (coeffs (pCons c p))", "using assms"], ["proof (prove)\nusing this:\n  (0::'a) < a\n\ngoal (1 subgoal):\n 1. cCons (sgn c) (map sgn (coeffs p)) = map sgn (coeffs (pCons c p))", "by (auto simp add: cCons_def sgn_0_0)"], ["proof (state)\nthis:\n  cCons (sgn c) (map sgn (coeffs p)) = map sgn (coeffs (pCons c p))\n\ngoal (2 subgoals):\n 1. map sgn (coeffs (reduce_root a 0)) = map sgn (coeffs 0)\n 2. \\<And>aa p.\n       \\<lbrakk>aa \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        map sgn (coeffs (reduce_root a p)) = map sgn (coeffs p)\\<rbrakk>\n       \\<Longrightarrow> map sgn (coeffs (reduce_root a (pCons aa p))) =\n                         map sgn (coeffs (pCons aa p))", "finally"], ["proof (chain)\npicking this:\n  map sgn (coeffs (reduce_root a (pCons c p))) =\n  map sgn (coeffs (pCons c p))", "show ?case"], ["proof (prove)\nusing this:\n  map sgn (coeffs (reduce_root a (pCons c p))) =\n  map sgn (coeffs (pCons c p))\n\ngoal (1 subgoal):\n 1. map sgn (coeffs (reduce_root a (pCons c p))) =\n    map sgn (coeffs (pCons c p))", "."], ["proof (state)\nthis:\n  map sgn (coeffs (reduce_root a (pCons c p))) =\n  map sgn (coeffs (pCons c p))\n\ngoal (1 subgoal):\n 1. map sgn (coeffs (reduce_root a 0)) = map sgn (coeffs 0)", "qed (simp_all add: reduce_root_def)"], ["", "text \\<open>\n  Multiplying a polynomial with a positive constant also does not change the number \n  of sign changes. (in fact, any non-zero constant would also work, but the proof \n  is slightly more difficult and positive constants suffice in our use case)\n\\<close>"], ["", "lemma coeff_sign_changes_smult: \n  assumes \"a > (0 :: 'a :: linordered_idom)\"\n  shows   \"coeff_sign_changes (smult a p) = coeff_sign_changes p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (coeffs (smult a p)) = sign_changes (coeffs p)", "using assms"], ["proof (prove)\nusing this:\n  (0::'a) < a\n\ngoal (1 subgoal):\n 1. sign_changes (coeffs (smult a p)) = sign_changes (coeffs p)", "by (auto intro!: sign_changes_cong simp: sgn_mult coeffs_smult)"], ["", "context\nbegin"], ["", "text \\<open>\n  We now show that a polynomial with an odd number of sign changes contains a \n  positive root. We first assume that the constant coefficient is non-zero. Then it is \n  clear that the polynomial's sign at 0 will be the sign of the constant coefficient, whereas \n  the polynomial's sign for sufficiently large inputs will be the sign of the leading coefficient.\n\n  Moreover, we have shown before that in a list with an odd number of sign changes and \n  non-zero initial and last coefficients, the initial coefficient and the last coefficient have \n  opposite and non-zero signs. Then, the polynomial obviously has a positive root.\n\\<close>"], ["", "private"], ["", "lemma odd_coeff_sign_changes_imp_pos_roots_aux:\n  assumes [simp]: \"p \\<noteq> (0 :: real poly)\" \"poly p 0 \\<noteq> 0\"\n  assumes \"odd (coeff_sign_changes p)\"\n  obtains x where \"x > 0\" \"poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>poly p 0 \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  poly p 0 \\<noteq> 0", "have [simp]: \"hd (coeffs p) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly p 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. hd (coeffs p) \\<noteq> 0", "by (induct p) auto"], ["proof (state)\nthis:\n  hd (coeffs p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  poly p 0 \\<noteq> 0\n  odd (sign_changes (coeffs p))", "have  \"\\<not> even (coeff_sign_changes p)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly p 0 \\<noteq> 0\n  odd (sign_changes (coeffs p))\n\ngoal (1 subgoal):\n 1. odd (sign_changes (coeffs p))", "by blast"], ["proof (state)\nthis:\n  odd (sign_changes (coeffs p))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  odd (sign_changes (coeffs p))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"even (coeff_sign_changes p) \\<longleftrightarrow> sgn (hd (coeffs p)) = sgn (lead_coeff p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (sign_changes (coeffs p)) =\n    (sgn (hd (coeffs p)) = sgn (lead_coeff p))", "by (auto simp add: even_sign_changes_iff last_coeffs_eq_coeff_degree)"], ["proof (state)\nthis:\n  even (sign_changes (coeffs p)) =\n  (sgn (hd (coeffs p)) = sgn (lead_coeff p))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  sgn (hd (coeffs p)) \\<noteq> sgn (lead_coeff p)", "have \"sgn (hd (coeffs p)) * sgn (lead_coeff p) < 0\""], ["proof (prove)\nusing this:\n  sgn (hd (coeffs p)) \\<noteq> sgn (lead_coeff p)\n\ngoal (1 subgoal):\n 1. sgn (hd (coeffs p)) * sgn (lead_coeff p) < 0", "by (auto simp: sgn_if split: if_split_asm)"], ["proof (state)\nthis:\n  sgn (hd (coeffs p)) * sgn (lead_coeff p) < 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  sgn (hd (coeffs p)) * sgn (lead_coeff p) < 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"hd (coeffs p) = poly p 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. hd (coeffs p) = poly p 0", "by (induction p) auto"], ["proof (state)\nthis:\n  hd (coeffs p) = poly p 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  sgn (poly p 0) * sgn (lead_coeff p) < 0", "have \"poly p 0 * lead_coeff p < 0\""], ["proof (prove)\nusing this:\n  sgn (poly p 0) * sgn (lead_coeff p) < 0\n\ngoal (1 subgoal):\n 1. poly p 0 * lead_coeff p < 0", "by (auto simp: mult_less_0_iff)"], ["proof (state)\nthis:\n  poly p 0 * lead_coeff p < 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pos_root_exI[OF this] that"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>0 < ?x; poly p ?x = 0\\<rbrakk> \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>0 < ?x; poly p ?x = 0\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We can now show the statement without the restriction to a non-zero constant coefficient.\n  We can do this by simply factoring $p$ into the form $p \\cdot x^n$, where $n$ is chosen as\n  large as possible. This corresponds to stripping all initial zeros of the coefficient list,\n  which obviously changes neither the existence of positive roots nor the number of coefficient \n  sign changes.\n\\<close>"], ["", "lemma odd_coeff_sign_changes_imp_pos_roots:\n  assumes \"p \\<noteq> (0 :: real poly)\"\n  assumes \"odd (coeff_sign_changes p)\"\n  obtains x where \"x > 0\" \"poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define s where \"s = sgn (lead_coeff p)\""], ["proof (state)\nthis:\n  s = sgn (lead_coeff p)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define n where \"n = order 0 p\""], ["proof (state)\nthis:\n  n = order 0 p\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define r where \"r = p div [:0, 1:] ^ n\""], ["proof (state)\nthis:\n  r = p div [:0, 1:] ^ n\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have p: \"p = [:0, 1:] ^ n * r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = [:0, 1:] ^ n * r", "unfolding r_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = [:0, 1:] ^ order 0 p * (p div [:0, 1:] ^ order 0 p)", "using order_1[of 0 p]"], ["proof (prove)\nusing this:\n  [:- 0, 1:] ^ order 0 p dvd p\n\ngoal (1 subgoal):\n 1. p = [:0, 1:] ^ order 0 p * (p div [:0, 1:] ^ order 0 p)", "by (simp del: mult_pCons_left)"], ["proof (state)\nthis:\n  p = [:0, 1:] ^ n * r\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  odd (sign_changes (coeffs p))\n  p = [:0, 1:] ^ n * r", "have r_nz: \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  odd (sign_changes (coeffs p))\n  p = [:0, 1:] ^ n * r\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain x where \"x > 0\" \"poly r x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule odd_coeff_sign_changes_imp_pos_roots_aux)"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?p2 \\<noteq> 0\n 2. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    poly ?p2 0 \\<noteq> 0\n 3. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs ?p2))\n 4. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly ?p2 x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "by fact"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (3 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    poly r 0 \\<noteq> 0\n 2. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 3. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"order 0 p = order 0 p + order 0 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order 0 p = order 0 p + order 0 r", "by (subst p, insert order_power_n_n[of \"0::real\" n] r_nz)\n         (simp del: mult_pCons_left add: order_mult n_def)"], ["proof (state)\nthis:\n  order 0 p = order 0 p + order 0 r\n\ngoal (3 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    poly r 0 \\<noteq> 0\n 2. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 3. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"order 0 r = 0\""], ["proof (prove)\nusing this:\n  order 0 p = order 0 p + order 0 r\n\ngoal (1 subgoal):\n 1. order 0 r = 0", "by simp"], ["proof (state)\nthis:\n  order 0 r = 0\n\ngoal (3 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    poly r 0 \\<noteq> 0\n 2. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 3. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "with r_nz"], ["proof (chain)\npicking this:\n  r \\<noteq> 0\n  order 0 r = 0", "show nz: \"poly r 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  order 0 r = 0\n\ngoal (1 subgoal):\n 1. poly r 0 \\<noteq> 0", "by (simp add: order_root)"], ["proof (state)\nthis:\n  poly r 0 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "note \\<open>odd (coeff_sign_changes p)\\<close>"], ["proof (state)\nthis:\n  odd (sign_changes (coeffs p))\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  odd (sign_changes (coeffs p))\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"p = [:0, 1:] ^ n * r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = [:0, 1:] ^ n * r", "by (simp add: p)"], ["proof (state)\nthis:\n  p = [:0, 1:] ^ n * r\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  p = [:0, 1:] ^ n * r\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"[:0, 1:] ^ n = monom 1 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] ^ n = monom (1::'a) n", "by (induction n) (simp_all add: monom_Suc monom_0)"], ["proof (state)\nthis:\n  [:0::?'a1, 1::?'a1:] ^ n = monom (1::?'a1) n\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  [:0::?'a1, 1::?'a1:] ^ n = monom (1::?'a1) n\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"coeffs (monom 1 n * r) = replicate n 0 @ coeffs r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeffs (monom 1 n * r) = replicate n 0 @ coeffs r", "by (induction n) (simp_all add: monom_Suc cCons_def r_nz monom_0)"], ["proof (state)\nthis:\n  coeffs (monom 1 n * r) = replicate n 0 @ coeffs r\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  coeffs (monom 1 n * r) = replicate n 0 @ coeffs r\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"sign_changes \\<dots> = coeff_sign_changes r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (replicate n 0 @ coeffs r) = sign_changes (coeffs r)", "by (subst (1 2) sign_changes_filter [symmetric]) simp"], ["proof (state)\nthis:\n  sign_changes (replicate n 0 @ coeffs r) = sign_changes (coeffs r)\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    odd (sign_changes (coeffs r))\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  odd (sign_changes (coeffs r))", "show \"odd (coeff_sign_changes r)\""], ["proof (prove)\nusing this:\n  odd (sign_changes (coeffs r))\n\ngoal (1 subgoal):\n 1. odd (sign_changes (coeffs r))", "."], ["proof (state)\nthis:\n  odd (sign_changes (coeffs r))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>0 < x; poly r x = 0\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 < x; poly r x = 0\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed"], ["proof (state)\nthis:\n  0 < x\n  poly r x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < x\n  poly r x = 0\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of x]) (simp_all add: p)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Proof of Descartes' sign rule\\<close>"], ["", "text \\<open>\n  For a polynomial $p(X) = a_0 + \\ldots + a_n X^n$, we have \n  $[X^i] (1-X)p(X) = (\\sum\\limits_{j=0}^i a_j)$.\n\\<close>"], ["", "lemma coeff_poly_times_one_minus_x:\n  fixes g :: \"'a :: linordered_idom poly\"\n  shows \"coeff g n = (\\<Sum>i\\<le>n. coeff (g * [:1, -1:]) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff g n = sum (coeff (g * [:1::'a, - (1::'a):])) {..n}", "by (induction n) simp_all"], ["", "text \\<open>\n  We apply the previous lemma to the coefficient list of a polynomial and show: \n  given a polynomial $p(X)$ and $q(X) = (1 - X)p(X)$, the coefficient list of $p(X)$ is the \n  list of partial sums of the coefficient list of $q(X)$.\n\\<close>"], ["", "lemma Poly_times_one_minus_x_eq_psums:\n  fixes xs :: \"'a :: linordered_idom list\"\n  assumes [simp]: \"length xs = length ys\"\n  assumes \"Poly xs = Poly ys * [:1, -1:]\"\n  shows   \"ys = psums xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = psums xs", "proof (rule nth_equalityI; safe?)"], ["proof (state)\ngoal (2 subgoals):\n 1. length ys = length (psums xs)\n 2. \\<And>i. i < length ys \\<Longrightarrow> ys ! i = psums xs ! i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length ys = length (psums xs)\n 2. \\<And>i. i < length ys \\<Longrightarrow> ys ! i = psums xs ! i", "assume i: \"i < length ys\""], ["proof (state)\nthis:\n  i < length ys\n\ngoal (2 subgoals):\n 1. length ys = length (psums xs)\n 2. \\<And>i. i < length ys \\<Longrightarrow> ys ! i = psums xs ! i", "hence \"ys ! i = coeff (Poly ys) i\""], ["proof (prove)\nusing this:\n  i < length ys\n\ngoal (1 subgoal):\n 1. ys ! i = coeff (Poly ys) i", "by (simp add: nth_default_def)"], ["proof (state)\nthis:\n  ys ! i = coeff (Poly ys) i\n\ngoal (2 subgoals):\n 1. length ys = length (psums xs)\n 2. \\<And>i. i < length ys \\<Longrightarrow> ys ! i = psums xs ! i", "also"], ["proof (state)\nthis:\n  ys ! i = coeff (Poly ys) i\n\ngoal (2 subgoals):\n 1. length ys = length (psums xs)\n 2. \\<And>i. i < length ys \\<Longrightarrow> ys ! i = psums xs ! i", "from coeff_poly_times_one_minus_x[of \"Poly ys\" i] assms"], ["proof (chain)\npicking this:\n  coeff (Poly ys) i = sum (coeff (Poly ys * [:1::'a, - (1::'a):])) {..i}\n  length xs = length ys\n  Poly xs = Poly ys * [:1::'a, - (1::'a):]", "have \"\\<dots> = (\\<Sum>j\\<le>i. coeff (Poly xs) j)\""], ["proof (prove)\nusing this:\n  coeff (Poly ys) i = sum (coeff (Poly ys * [:1::'a, - (1::'a):])) {..i}\n  length xs = length ys\n  Poly xs = Poly ys * [:1::'a, - (1::'a):]\n\ngoal (1 subgoal):\n 1. coeff (Poly ys) i = sum (coeff (Poly xs)) {..i}", "by simp"], ["proof (state)\nthis:\n  coeff (Poly ys) i = sum (coeff (Poly xs)) {..i}\n\ngoal (2 subgoals):\n 1. length ys = length (psums xs)\n 2. \\<And>i. i < length ys \\<Longrightarrow> ys ! i = psums xs ! i", "also"], ["proof (state)\nthis:\n  coeff (Poly ys) i = sum (coeff (Poly xs)) {..i}\n\ngoal (2 subgoals):\n 1. length ys = length (psums xs)\n 2. \\<And>i. i < length ys \\<Longrightarrow> ys ! i = psums xs ! i", "from i"], ["proof (chain)\npicking this:\n  i < length ys", "have \"\\<dots> = psums xs ! i\""], ["proof (prove)\nusing this:\n  i < length ys\n\ngoal (1 subgoal):\n 1. sum (coeff (Poly xs)) {..i} = psums xs ! i", "by (auto simp: nth_default_def psums_nth)"], ["proof (state)\nthis:\n  sum (coeff (Poly xs)) {..i} = psums xs ! i\n\ngoal (2 subgoals):\n 1. length ys = length (psums xs)\n 2. \\<And>i. i < length ys \\<Longrightarrow> ys ! i = psums xs ! i", "finally"], ["proof (chain)\npicking this:\n  ys ! i = psums xs ! i", "show \"ys ! i = psums xs ! i\""], ["proof (prove)\nusing this:\n  ys ! i = psums xs ! i\n\ngoal (1 subgoal):\n 1. ys ! i = psums xs ! i", "."], ["proof (state)\nthis:\n  ys ! i = psums xs ! i\n\ngoal (1 subgoal):\n 1. length ys = length (psums xs)", "qed simp_all"], ["", "text \\<open>\n  We can now apply our main lemma on the sign changes in lists to the coefficient lists of \n  a nonzero polynomial $p(X)$ and $(1-X)p(X)$: the difference of the changes in the \n  coefficient lists is odd and positive.\n\\<close>"], ["", "lemma sign_changes_poly_times_one_minus_x:\n  fixes g :: \"'a :: linordered_idom poly\" and a :: 'a\n  assumes nz: \"g \\<noteq> 0\"\n  defines \"v \\<equiv> coeff_sign_changes\"\n  shows \"v ([:1, -1:] * g) - v g > 0 \\<and> odd (v ([:1, -1:] * g) - v g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "define xs where \"xs = coeffs ([:1, -1:] * g)\""], ["proof (state)\nthis:\n  xs = coeffs ([:1::'a, - (1::'a):] * g)\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "define ys where \"ys = coeffs g @ [0]\""], ["proof (state)\nthis:\n  ys = coeffs g @ [0::'a]\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "have ys: \"ys = psums xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = psums xs", "proof (rule Poly_times_one_minus_x_eq_psums)"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs = length ys\n 2. Poly xs = Poly ys * [:1::'a, - (1::'a):]", "show \"length xs = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys", "unfolding xs_def ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (coeffs ([:1::'a, - (1::'a):] * g)) = length (coeffs g @ [0::'a])", "by (simp add: length_coeffs nz degree_mult_eq no_zero_divisors del: mult_pCons_left)"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. Poly xs = Poly ys * [:1::'a, - (1::'a):]", "show \"Poly xs = Poly ys * [:1, - 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly xs = Poly ys * [:1::'a, - (1::'a):]", "unfolding xs_def ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (coeffs ([:1::'a, - (1::'a):] * g)) =\n    Poly (coeffs g @ [0::'a]) * [:1::'a, - (1::'a):]", "by (simp only: Poly_snoc Poly_coeffs) simp"], ["proof (state)\nthis:\n  Poly xs = Poly ys * [:1::'a, - (1::'a):]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ys = psums xs\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "have \"sign_changes (psums xs) < sign_changes xs \\<and> \n        odd (sign_changes xs - sign_changes (psums xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (psums xs) < sign_changes xs \\<and>\n    odd (sign_changes xs - sign_changes (psums xs))", "proof (rule arthan)"], ["proof (state)\ngoal (3 subgoals):\n 1. xs \\<noteq> []\n 2. last xs \\<noteq> (0::'a)\n 3. sum_list xs = (0::'a)", "show \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by (auto simp: xs_def nz simp del: mult_pCons_left)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. last xs \\<noteq> (0::'a)\n 2. sum_list xs = (0::'a)", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "show \"sum_list xs = 0\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)", "by (simp add: last_psums [symmetric] ys [symmetric] ys_def)"], ["proof (state)\nthis:\n  sum_list xs = (0::'a)\n\ngoal (1 subgoal):\n 1. last xs \\<noteq> (0::'a)", "show \"last xs \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last xs \\<noteq> (0::'a)", "by (auto simp: xs_def nz last_coeffs_eq_coeff_degree simp del: mult_pCons_left)"], ["proof (state)\nthis:\n  last xs \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_changes (psums xs) < sign_changes xs \\<and>\n  odd (sign_changes xs - sign_changes (psums xs))\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "with ys"], ["proof (chain)\npicking this:\n  ys = psums xs\n  sign_changes (psums xs) < sign_changes xs \\<and>\n  odd (sign_changes xs - sign_changes (psums xs))", "have \"sign_changes ys < sign_changes xs \\<and> \n                odd (sign_changes xs - sign_changes ys)\""], ["proof (prove)\nusing this:\n  ys = psums xs\n  sign_changes (psums xs) < sign_changes xs \\<and>\n  odd (sign_changes xs - sign_changes (psums xs))\n\ngoal (1 subgoal):\n 1. sign_changes ys < sign_changes xs \\<and>\n    odd (sign_changes xs - sign_changes ys)", "by simp"], ["proof (state)\nthis:\n  sign_changes ys < sign_changes xs \\<and>\n  odd (sign_changes xs - sign_changes ys)\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "also"], ["proof (state)\nthis:\n  sign_changes ys < sign_changes xs \\<and>\n  odd (sign_changes xs - sign_changes ys)\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "have \"sign_changes xs = v ([:1, -1:] * g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes xs = v ([:1::'a, - (1::'a):] * g)", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes xs = sign_changes (coeffs ([:1::'a, - (1::'a):] * g))", "by (intro sign_changes_coeff_sign_changes) (simp_all add: xs_def)"], ["proof (state)\nthis:\n  sign_changes xs = v ([:1::'a, - (1::'a):] * g)\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "also"], ["proof (state)\nthis:\n  sign_changes xs = v ([:1::'a, - (1::'a):] * g)\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "have \"sign_changes ys = v g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes ys = v g", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes ys = sign_changes (coeffs g)", "by (intro sign_changes_coeff_sign_changes) (simp_all add: ys_def Poly_snoc)"], ["proof (state)\nthis:\n  sign_changes ys = v g\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "finally"], ["proof (chain)\npicking this:\n  v g < v ([:1::'a, - (1::'a):] * g) \\<and>\n  odd (v ([:1::'a, - (1::'a):] * g) - v g)", "show ?thesis"], ["proof (prove)\nusing this:\n  v g < v ([:1::'a, - (1::'a):] * g) \\<and>\n  odd (v ([:1::'a, - (1::'a):] * g) - v g)\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:1::'a, - (1::'a):] * g) - v g)", "by simp"], ["proof (state)\nthis:\n  0 < v ([:1::'a, - (1::'a):] * g) - v g \\<and>\n  odd (v ([:1::'a, - (1::'a):] * g) - v g)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We can now lift the previous lemma to the case of $p(X)$ and $(a-X)p(X)$ by substituting $X$ \n  with $aX$, yielding the polynomials $p(aX)$ and $a \\cdot (1-X) \\cdot p(aX)$.\n\\<close>"], ["", "lemma sign_changes_poly_times_root_minus_x:\n  fixes g :: \"'a :: linordered_idom poly\" and a :: 'a\n  assumes nz: \"g \\<noteq> 0\" and pos: \"a > 0\"\n  defines \"v \\<equiv> coeff_sign_changes\"\n  shows \"v ([:a, -1:] * g) - v g > 0 \\<and> odd (v ([:a, -1:] * g) - v g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "have \"0 < v ([:1, - 1:] * reduce_root a g) - v (reduce_root a g) \\<and>\n            odd (v ([:1, - 1:] * reduce_root a g) - v (reduce_root a g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * reduce_root a g) -\n        v (reduce_root a g) \\<and>\n    odd (v ([:1::'a, - (1::'a):] * reduce_root a g) - v (reduce_root a g))", "using nz pos"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  (0::'a) < a\n\ngoal (1 subgoal):\n 1. 0 < v ([:1::'a, - (1::'a):] * reduce_root a g) -\n        v (reduce_root a g) \\<and>\n    odd (v ([:1::'a, - (1::'a):] * reduce_root a g) - v (reduce_root a g))", "unfolding v_def"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  (0::'a) < a\n\ngoal (1 subgoal):\n 1. 0 < sign_changes (coeffs ([:1::'a, - (1::'a):] * reduce_root a g)) -\n        sign_changes (coeffs (reduce_root a g)) \\<and>\n    odd (sign_changes (coeffs ([:1::'a, - (1::'a):] * reduce_root a g)) -\n         sign_changes (coeffs (reduce_root a g)))", "by (intro sign_changes_poly_times_one_minus_x) simp_all"], ["proof (state)\nthis:\n  0 < v ([:1::'a, - (1::'a):] * reduce_root a g) -\n      v (reduce_root a g) \\<and>\n  odd (v ([:1::'a, - (1::'a):] * reduce_root a g) - v (reduce_root a g))\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "also"], ["proof (state)\nthis:\n  0 < v ([:1::'a, - (1::'a):] * reduce_root a g) -\n      v (reduce_root a g) \\<and>\n  odd (v ([:1::'a, - (1::'a):] * reduce_root a g) - v (reduce_root a g))\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "have \"v ([:1, -1:] * reduce_root a g) = v (smult a ([:1, -1:] * reduce_root a g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ([:1::'a, - (1::'a):] * reduce_root a g) =\n    v (smult a ([:1::'a, - (1::'a):] * reduce_root a g))", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (coeffs ([:1::'a, - (1::'a):] * reduce_root a g)) =\n    sign_changes (coeffs (smult a ([:1::'a, - (1::'a):] * reduce_root a g)))", "by (simp add: coeff_sign_changes_smult pos)"], ["proof (state)\nthis:\n  v ([:1::'a, - (1::'a):] * reduce_root a g) =\n  v (smult a ([:1::'a, - (1::'a):] * reduce_root a g))\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "also"], ["proof (state)\nthis:\n  v ([:1::'a, - (1::'a):] * reduce_root a g) =\n  v (smult a ([:1::'a, - (1::'a):] * reduce_root a g))\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "have \"smult a ([:1, -1:] * reduce_root a g) = [:a:] * [:1, -1:] * reduce_root a g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult a ([:1::'a, - (1::'a):] * reduce_root a g) =\n    [:a:] * [:1::'a, - (1::'a):] * reduce_root a g", "by (subst mult.assoc) simp"], ["proof (state)\nthis:\n  smult a ([:1::'a, - (1::'a):] * reduce_root a g) =\n  [:a:] * [:1::'a, - (1::'a):] * reduce_root a g\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "also"], ["proof (state)\nthis:\n  smult a ([:1::'a, - (1::'a):] * reduce_root a g) =\n  [:a:] * [:1::'a, - (1::'a):] * reduce_root a g\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "have \"[:a:] * [:1, -1:] = reduce_root a [:a, -1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a:] * [:1::'a, - (1::'a):] = reduce_root a [:a, - (1::'a):]", "by (simp add: reduce_root_def pcompose_pCons)"], ["proof (state)\nthis:\n  [:a:] * [:1::'a, - (1::'a):] = reduce_root a [:a, - (1::'a):]\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "also"], ["proof (state)\nthis:\n  [:a:] * [:1::'a, - (1::'a):] = reduce_root a [:a, - (1::'a):]\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "have \"\\<dots> * reduce_root a g = reduce_root a ([:a, -1:] * g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_root a [:a, - (1::'a):] * reduce_root a g =\n    reduce_root a ([:a, - (1::'a):] * g)", "unfolding reduce_root_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a, - (1::'a):] \\<circ>\\<^sub>p [:0::'a, a:] *\n    g \\<circ>\\<^sub>p [:0::'a, a:] =\n    ([:a, - (1::'a):] * g) \\<circ>\\<^sub>p [:0::'a, a:]", "by (simp only: pcompose_mult)"], ["proof (state)\nthis:\n  reduce_root a [:a, - (1::'a):] * reduce_root a g =\n  reduce_root a ([:a, - (1::'a):] * g)\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "also"], ["proof (state)\nthis:\n  reduce_root a [:a, - (1::'a):] * reduce_root a g =\n  reduce_root a ([:a, - (1::'a):] * g)\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "have \"v \\<dots> = v ([:a, -1:] * g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v (reduce_root a ([:a, - (1::'a):] * g)) = v ([:a, - (1::'a):] * g)", "by (simp add: v_def coeff_sign_changes_reduce_root pos)"], ["proof (state)\nthis:\n  v (reduce_root a ([:a, - (1::'a):] * g)) = v ([:a, - (1::'a):] * g)\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "also"], ["proof (state)\nthis:\n  v (reduce_root a ([:a, - (1::'a):] * g)) = v ([:a, - (1::'a):] * g)\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "have \"v (reduce_root a g) = v g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v (reduce_root a g) = v g", "by (simp add: v_def coeff_sign_changes_reduce_root pos)"], ["proof (state)\nthis:\n  v (reduce_root a g) = v g\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "finally"], ["proof (chain)\npicking this:\n  0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n  odd (v ([:a, - (1::'a):] * g) - v g)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n  odd (v ([:a, - (1::'a):] * g) - v g)\n\ngoal (1 subgoal):\n 1. 0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n    odd (v ([:a, - (1::'a):] * g) - v g)", "."], ["proof (state)\nthis:\n  0 < v ([:a, - (1::'a):] * g) - v g \\<and>\n  odd (v ([:a, - (1::'a):] * g) - v g)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Finally, the difference of the number of coefficient sign changes and the number of\n  positive roots is non-negative and even. This follows straightforwardly by induction \n  over the roots.\n\\<close>"], ["", "lemma descartes_sign_rule_aux:\n  fixes p :: \"real poly\"\n  assumes \"p \\<noteq> 0\"\n  shows   \"coeff_sign_changes p \\<ge> count_pos_roots p \\<and> \n           even (coeff_sign_changes p - count_pos_roots p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n    even (sign_changes (coeffs p) - count_roots_with ((<) 0) p)", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n    even (sign_changes (coeffs p) - count_roots_with ((<) 0) p)", "proof (induction p rule: poly_root_induct[where P = \"\\<lambda>a. a > 0\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    count_roots_with ((<) 0) 0 \\<le> sign_changes (coeffs 0) \\<and>\n    even (sign_changes (coeffs 0) - count_roots_with ((<) 0) 0)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. 0 < a \\<Longrightarrow> poly p a \\<noteq> 0;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) p\n                         \\<le> sign_changes (coeffs p) \\<and>\n                         even\n                          (sign_changes (coeffs p) -\n                           count_roots_with ((<) 0) p)\n 3. \\<And>a p.\n       \\<lbrakk>0 < a;\n        p \\<noteq> 0 \\<Longrightarrow>\n        count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n        even (sign_changes (coeffs p) - count_roots_with ((<) 0) p);\n        [:a, - 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) ([:a, - 1:] * p)\n                         \\<le> sign_changes (coeffs ([:a, - 1:] * p)) \\<and>\n                         even\n                          (sign_changes (coeffs ([:a, - 1:] * p)) -\n                           count_roots_with ((<) 0) ([:a, - 1:] * p))", "case (root a p)"], ["proof (state)\nthis:\n  0 < a\n  p \\<noteq> 0 \\<Longrightarrow>\n  count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n  even (sign_changes (coeffs p) - count_roots_with ((<) 0) p)\n  [:a, - 1:] * p \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    count_roots_with ((<) 0) 0 \\<le> sign_changes (coeffs 0) \\<and>\n    even (sign_changes (coeffs 0) - count_roots_with ((<) 0) 0)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. 0 < a \\<Longrightarrow> poly p a \\<noteq> 0;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) p\n                         \\<le> sign_changes (coeffs p) \\<and>\n                         even\n                          (sign_changes (coeffs p) -\n                           count_roots_with ((<) 0) p)\n 3. \\<And>a p.\n       \\<lbrakk>0 < a;\n        p \\<noteq> 0 \\<Longrightarrow>\n        count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n        even (sign_changes (coeffs p) - count_roots_with ((<) 0) p);\n        [:a, - 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) ([:a, - 1:] * p)\n                         \\<le> sign_changes (coeffs ([:a, - 1:] * p)) \\<and>\n                         even\n                          (sign_changes (coeffs ([:a, - 1:] * p)) -\n                           count_roots_with ((<) 0) ([:a, - 1:] * p))", "define q where \"q = [:a, -1:] * p\""], ["proof (state)\nthis:\n  q = [:a, - 1:] * p\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    count_roots_with ((<) 0) 0 \\<le> sign_changes (coeffs 0) \\<and>\n    even (sign_changes (coeffs 0) - count_roots_with ((<) 0) 0)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. 0 < a \\<Longrightarrow> poly p a \\<noteq> 0;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) p\n                         \\<le> sign_changes (coeffs p) \\<and>\n                         even\n                          (sign_changes (coeffs p) -\n                           count_roots_with ((<) 0) p)\n 3. \\<And>a p.\n       \\<lbrakk>0 < a;\n        p \\<noteq> 0 \\<Longrightarrow>\n        count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n        even (sign_changes (coeffs p) - count_roots_with ((<) 0) p);\n        [:a, - 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) ([:a, - 1:] * p)\n                         \\<le> sign_changes (coeffs ([:a, - 1:] * p)) \\<and>\n                         even\n                          (sign_changes (coeffs ([:a, - 1:] * p)) -\n                           count_roots_with ((<) 0) ([:a, - 1:] * p))", "from root.prems"], ["proof (chain)\npicking this:\n  [:a, - 1:] * p \\<noteq> 0", "have p: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  [:a, - 1:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    count_roots_with ((<) 0) 0 \\<le> sign_changes (coeffs 0) \\<and>\n    even (sign_changes (coeffs 0) - count_roots_with ((<) 0) 0)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. 0 < a \\<Longrightarrow> poly p a \\<noteq> 0;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) p\n                         \\<le> sign_changes (coeffs p) \\<and>\n                         even\n                          (sign_changes (coeffs p) -\n                           count_roots_with ((<) 0) p)\n 3. \\<And>a p.\n       \\<lbrakk>0 < a;\n        p \\<noteq> 0 \\<Longrightarrow>\n        count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n        even (sign_changes (coeffs p) - count_roots_with ((<) 0) p);\n        [:a, - 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) ([:a, - 1:] * p)\n                         \\<le> sign_changes (coeffs ([:a, - 1:] * p)) \\<and>\n                         even\n                          (sign_changes (coeffs ([:a, - 1:] * p)) -\n                           count_roots_with ((<) 0) ([:a, - 1:] * p))", "with root p sign_changes_poly_times_root_minus_x[of p a] \n       count_roots_with_times_root[of p \"\\<lambda>x. x > 0\" a]"], ["proof (chain)\npicking this:\n  0 < a\n  p \\<noteq> 0 \\<Longrightarrow>\n  count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n  even (sign_changes (coeffs p) - count_roots_with ((<) 0) p)\n  [:a, - 1:] * p \\<noteq> 0\n  p \\<noteq> 0\n  \\<lbrakk>p \\<noteq> 0; 0 < a\\<rbrakk>\n  \\<Longrightarrow> 0 < sign_changes (coeffs ([:a, - 1:] * p)) -\n                        sign_changes (coeffs p) \\<and>\n                    odd (sign_changes (coeffs ([:a, - 1:] * p)) -\n                         sign_changes (coeffs p))\n  \\<lbrakk>p \\<noteq> 0; 0 < a\\<rbrakk>\n  \\<Longrightarrow> count_roots_with ((<) 0) ([:a, - 1:] * p) =\n                    Suc (count_roots_with ((<) 0) p)\n  p \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  p \\<noteq> 0 \\<Longrightarrow>\n  count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n  even (sign_changes (coeffs p) - count_roots_with ((<) 0) p)\n  [:a, - 1:] * p \\<noteq> 0\n  p \\<noteq> 0\n  \\<lbrakk>p \\<noteq> 0; 0 < a\\<rbrakk>\n  \\<Longrightarrow> 0 < sign_changes (coeffs ([:a, - 1:] * p)) -\n                        sign_changes (coeffs p) \\<and>\n                    odd (sign_changes (coeffs ([:a, - 1:] * p)) -\n                         sign_changes (coeffs p))\n  \\<lbrakk>p \\<noteq> 0; 0 < a\\<rbrakk>\n  \\<Longrightarrow> count_roots_with ((<) 0) ([:a, - 1:] * p) =\n                    Suc (count_roots_with ((<) 0) p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots_with ((<) 0) ([:a, - 1:] * p)\n    \\<le> sign_changes (coeffs ([:a, - 1:] * p)) \\<and>\n    even\n     (sign_changes (coeffs ([:a, - 1:] * p)) -\n      count_roots_with ((<) 0) ([:a, - 1:] * p))", "by (fold q_def) fastforce"], ["proof (state)\nthis:\n  count_roots_with ((<) 0) ([:a, - 1:] * p)\n  \\<le> sign_changes (coeffs ([:a, - 1:] * p)) \\<and>\n  even\n   (sign_changes (coeffs ([:a, - 1:] * p)) -\n    count_roots_with ((<) 0) ([:a, - 1:] * p))\n\ngoal (2 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    count_roots_with ((<) 0) 0 \\<le> sign_changes (coeffs 0) \\<and>\n    even (sign_changes (coeffs 0) - count_roots_with ((<) 0) 0)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. 0 < a \\<Longrightarrow> poly p a \\<noteq> 0;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) p\n                         \\<le> sign_changes (coeffs p) \\<and>\n                         even\n                          (sign_changes (coeffs p) -\n                           count_roots_with ((<) 0) p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    count_roots_with ((<) 0) 0 \\<le> sign_changes (coeffs 0) \\<and>\n    even (sign_changes (coeffs 0) - count_roots_with ((<) 0) 0)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. 0 < a \\<Longrightarrow> poly p a \\<noteq> 0;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) p\n                         \\<le> sign_changes (coeffs p) \\<and>\n                         even\n                          (sign_changes (coeffs p) -\n                           count_roots_with ((<) 0) p)", "case (no_roots p)"], ["proof (state)\nthis:\n  0 < ?a \\<Longrightarrow> poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    count_roots_with ((<) 0) 0 \\<le> sign_changes (coeffs 0) \\<and>\n    even (sign_changes (coeffs 0) - count_roots_with ((<) 0) 0)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. 0 < a \\<Longrightarrow> poly p a \\<noteq> 0;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) p\n                         \\<le> sign_changes (coeffs p) \\<and>\n                         even\n                          (sign_changes (coeffs p) -\n                           count_roots_with ((<) 0) p)", "from no_roots"], ["proof (chain)\npicking this:\n  0 < ?a \\<Longrightarrow> poly p ?a \\<noteq> 0\n  p \\<noteq> 0", "have \"pos_roots p = {}\""], ["proof (prove)\nusing this:\n  0 < ?a \\<Longrightarrow> poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. roots_with ((<) 0) p = {}", "by (auto simp: roots_with_def)"], ["proof (state)\nthis:\n  roots_with ((<) 0) p = {}\n\ngoal (2 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    count_roots_with ((<) 0) 0 \\<le> sign_changes (coeffs 0) \\<and>\n    even (sign_changes (coeffs 0) - count_roots_with ((<) 0) 0)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. 0 < a \\<Longrightarrow> poly p a \\<noteq> 0;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) p\n                         \\<le> sign_changes (coeffs p) \\<and>\n                         even\n                          (sign_changes (coeffs p) -\n                           count_roots_with ((<) 0) p)", "hence [simp]: \"count_pos_roots p = 0\""], ["proof (prove)\nusing this:\n  roots_with ((<) 0) p = {}\n\ngoal (1 subgoal):\n 1. count_roots_with ((<) 0) p = 0", "by (simp add: count_roots_with_def)"], ["proof (state)\nthis:\n  count_roots_with ((<) 0) p = 0\n\ngoal (2 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    count_roots_with ((<) 0) 0 \\<le> sign_changes (coeffs 0) \\<and>\n    even (sign_changes (coeffs 0) - count_roots_with ((<) 0) 0)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. 0 < a \\<Longrightarrow> poly p a \\<noteq> 0;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> count_roots_with ((<) 0) p\n                         \\<le> sign_changes (coeffs p) \\<and>\n                         even\n                          (sign_changes (coeffs p) -\n                           count_roots_with ((<) 0) p)", "thus ?case"], ["proof (prove)\nusing this:\n  count_roots_with ((<) 0) p = 0\n\ngoal (1 subgoal):\n 1. count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n    even (sign_changes (coeffs p) - count_roots_with ((<) 0) p)", "using no_roots \\<open>p \\<noteq> 0\\<close> odd_coeff_sign_changes_imp_pos_roots[of p]"], ["proof (prove)\nusing this:\n  count_roots_with ((<) 0) p = 0\n  0 < ?a \\<Longrightarrow> poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n  p \\<noteq> 0\n  \\<lbrakk>p \\<noteq> 0; odd (sign_changes (coeffs p));\n   \\<And>x.\n      \\<lbrakk>0 < x; poly p x = 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n    even (sign_changes (coeffs p) - count_roots_with ((<) 0) p)", "by (auto simp: roots_with_def)"], ["proof (state)\nthis:\n  count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n  even (sign_changes (coeffs p) - count_roots_with ((<) 0) p)\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    count_roots_with ((<) 0) 0 \\<le> sign_changes (coeffs 0) \\<and>\n    even (sign_changes (coeffs 0) - count_roots_with ((<) 0) 0)", "qed simp_all"], ["", "text \\<open>\n  The main theorem is then an obvious consequence\n\\<close>"], ["", "theorem descartes_sign_rule:\n  fixes p :: \"real poly\"\n  assumes \"p \\<noteq> 0\"\n  shows \"\\<exists>d. even d \\<and> coeff_sign_changes p = count_pos_roots p + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       even d \\<and>\n       sign_changes (coeffs p) = count_roots_with ((<) 0) p + d", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. even ?d \\<and> sign_changes (coeffs p) = count_roots_with ((<) 0) p + ?d", "define d where \"d = coeff_sign_changes p - count_pos_roots p\""], ["proof (state)\nthis:\n  d = sign_changes (coeffs p) - count_roots_with ((<) 0) p\n\ngoal (1 subgoal):\n 1. even ?d \\<and> sign_changes (coeffs p) = count_roots_with ((<) 0) p + ?d", "show \"even d \\<and> coeff_sign_changes p = count_pos_roots p + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even d \\<and> sign_changes (coeffs p) = count_roots_with ((<) 0) p + d", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. even (sign_changes (coeffs p) - count_roots_with ((<) 0) p) \\<and>\n    sign_changes (coeffs p) =\n    count_roots_with ((<) 0) p +\n    (sign_changes (coeffs p) - count_roots_with ((<) 0) p)", "using descartes_sign_rule_aux[OF assms]"], ["proof (prove)\nusing this:\n  count_roots_with ((<) 0) p \\<le> sign_changes (coeffs p) \\<and>\n  even (sign_changes (coeffs p) - count_roots_with ((<) 0) p)\n\ngoal (1 subgoal):\n 1. even (sign_changes (coeffs p) - count_roots_with ((<) 0) p) \\<and>\n    sign_changes (coeffs p) =\n    count_roots_with ((<) 0) p +\n    (sign_changes (coeffs p) - count_roots_with ((<) 0) p)", "by auto"], ["proof (state)\nthis:\n  even d \\<and> sign_changes (coeffs p) = count_roots_with ((<) 0) p + d\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}