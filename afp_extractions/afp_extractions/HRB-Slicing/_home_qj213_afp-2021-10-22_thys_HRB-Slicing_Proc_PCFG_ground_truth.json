{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/Proc/PCFG.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma Exit_label_incr [dest]: \"Exit = n \\<oplus> i \\<Longrightarrow> n = Exit\"", "lemma label_incr_Exit [dest]: \"n \\<oplus> i = Exit \\<Longrightarrow> n = Exit\"", "lemma Entry_label_incr [dest]: \"Entry = n \\<oplus> i \\<Longrightarrow> n = Entry\"", "lemma label_incr_Entry [dest]: \"n \\<oplus> i = Entry \\<Longrightarrow> n = Entry\"", "lemma label_incr_inj:\n  \"n \\<oplus> c = n' \\<oplus> c \\<Longrightarrow> n = n'\"", "lemma label_incr_simp:\"n \\<oplus> i = m \\<oplus> (i + j) \\<Longrightarrow> n = m \\<oplus> j\"", "lemma label_incr_simp_rev:\"m \\<oplus> (j + i) = n \\<oplus> i \\<Longrightarrow> m \\<oplus> j = n\"", "lemma label_incr_start_Node_smaller:\n  \"Label l = n \\<oplus> i \\<Longrightarrow> n = Label (l - i)\"", "lemma label_incr_start_Node_smaller_rev:\n  \"n \\<oplus> i = Label l \\<Longrightarrow> n = Label (l - i)\"", "lemma label_incr_ge:\"Label l = n \\<oplus> i \\<Longrightarrow> l \\<ge> i\"", "lemma label_incr_0 [dest]:\n  \"\\<lbrakk>Label 0 = n \\<oplus> i; i > 0\\<rbrakk> \\<Longrightarrow> False\"", "lemma label_incr_0_rev [dest]:\n  \"\\<lbrakk>n \\<oplus> i = Label 0; i > 0\\<rbrakk> \\<Longrightarrow> False\"", "lemma Proc_CFG_Exit_no_sourcenode [dest]:\n  \"prog \\<turnstile> Exit -et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\"", "lemma Proc_CFG_Entry_no_targetnode [dest]:\n  \"prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p Entry \\<Longrightarrow> False\"", "lemma Proc_CFG_IEdge_intra_kind:\n  \"prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> intra_kind et\"", "lemma [dest]:\"prog \\<turnstile> n -IEdge (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\"", "lemma [dest]:\"prog \\<turnstile> n -IEdge (Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\"", "lemma Proc_CFG_sourcelabel_less_num_nodes:\n  \"prog \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> l < #:prog\"", "lemma Proc_CFG_targetlabel_less_num_nodes:\n  \"prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow> l < #:prog\"", "lemma Proc_CFG_EntryD:\n  \"prog \\<turnstile> Entry -et\\<rightarrow>\\<^sub>p n' \n  \\<Longrightarrow> (n' = Exit \\<and> et = IEdge(\\<lambda>s. False)\\<^sub>\\<surd>) \\<or> (n' = Label 0 \\<and> et = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>)\"", "lemma Proc_CFG_Exit_edge:\n  obtains l et where \"prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit\" and \"l \\<le> #:prog\"", "lemma Proc_CFG_Call_Labels:\n  \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> \\<exists>l. n = Label l \\<and> n' = Label (Suc l)\"", "lemma Proc_CFG_Call_target_0:\n  \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label 0 \\<Longrightarrow> n = Entry\"", "lemma Proc_CFG_Call_Intra_edge_not_same_source:\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk> \\<Longrightarrow> False\"", "lemma Proc_CFG_Call_Intra_edge_not_same_target:\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk> \\<Longrightarrow> False\"", "lemma Proc_CFG_Call_nodes_eq:\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n  \\<Longrightarrow> n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\"", "lemma Proc_CFG_Call_nodes_eq':\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n  \\<Longrightarrow> n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\"", "lemma Proc_CFG_Call_targetnode_no_Call_sourcenode:\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk> \n  \\<Longrightarrow> False\"", "lemma Proc_CFG_Call_follows_id_edge:\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk> \\<Longrightarrow> et = \\<Up>id\"", "lemma Proc_CFG_edge_det:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk> \\<Longrightarrow> et = et'\"", "lemma WCFG_deterministic:\n  \"\\<lbrakk>prog \\<turnstile> n\\<^sub>1 -et\\<^sub>1\\<rightarrow>\\<^sub>p n\\<^sub>1'; prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'; n\\<^sub>1 = n\\<^sub>2; n\\<^sub>1' \\<noteq> n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'. et\\<^sub>1 = IEdge (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and> \n            (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\"", "lemmas containsCall_induct[case_names Skip LAss Seq Cond While Call] = \n  containsCall.induct", "lemma containsCallcases: \n  \"containsCall procs prog ps p\n  \\<Longrightarrow> ps = [] \\<and> containsCall procs prog ps p \\<or> \n  (\\<exists>q ins outs c ps'. ps = ps'@[q] \\<and> (q,ins,outs,c) \\<in> set procs \\<and>\n  containsCall procs c [] p \\<and> containsCall procs prog ps' q)\"", "lemma containsCallE:\n  \"\\<lbrakk>containsCall procs prog ps p; \n    \\<lbrakk>ps = []; containsCall procs prog ps p\\<rbrakk> \\<Longrightarrow> P procs prog ps p;\n    \\<And>q ins outs c es' rets' ps'. \\<lbrakk>ps = ps'@[q]; (q,ins,outs,c) \\<in> set procs; \n      containsCall procs c [] p; containsCall procs prog ps' q\\<rbrakk> \n     \\<Longrightarrow> P procs prog ps p\\<rbrakk> \\<Longrightarrow> P procs prog ps p\"", "lemma containsCall_in_proc: \n  \"\\<lbrakk>containsCall procs prog qs q; (q,ins,outs,c) \\<in> set procs; \n  containsCall procs c [] p\\<rbrakk>\n  \\<Longrightarrow> containsCall procs prog (qs@[q]) p\"", "lemma containsCall_indirection:\n  \"\\<lbrakk>containsCall procs prog qs q; containsCall procs c ps p;\n  (q,ins,outs,c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> containsCall procs prog (qs@q#ps) p\"", "lemma Proc_CFG_Call_containsCall:\n  \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> containsCall procs prog [] p\"", "lemma containsCall_empty_Proc_CFG_Call_edge: \n  assumes \"containsCall procs prog [] p\"\n  obtains l es rets l' where \"prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l'\""], "translations": [["", "lemma Exit_label_incr [dest]: \"Exit = n \\<oplus> i \\<Longrightarrow> n = Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Exit = n \\<oplus> i \\<Longrightarrow> n = Exit", "by(cases n,auto)"], ["", "lemma label_incr_Exit [dest]: \"n \\<oplus> i = Exit \\<Longrightarrow> n = Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<oplus> i = Exit \\<Longrightarrow> n = Exit", "by(cases n,auto)"], ["", "lemma Entry_label_incr [dest]: \"Entry = n \\<oplus> i \\<Longrightarrow> n = Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Entry = n \\<oplus> i \\<Longrightarrow> n = Entry", "by(cases n,auto)"], ["", "lemma label_incr_Entry [dest]: \"n \\<oplus> i = Entry \\<Longrightarrow> n = Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<oplus> i = Entry \\<Longrightarrow> n = Entry", "by(cases n,auto)"], ["", "lemma label_incr_inj:\n  \"n \\<oplus> c = n' \\<oplus> c \\<Longrightarrow> n = n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<oplus> c = n' \\<oplus> c \\<Longrightarrow> n = n'", "by(cases n)(cases n',auto)+"], ["", "lemma label_incr_simp:\"n \\<oplus> i = m \\<oplus> (i + j) \\<Longrightarrow> n = m \\<oplus> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<oplus> i = m \\<oplus> i + j \\<Longrightarrow> n = m \\<oplus> j", "by(cases n,auto,cases m,auto)"], ["", "lemma label_incr_simp_rev:\"m \\<oplus> (j + i) = n \\<oplus> i \\<Longrightarrow> m \\<oplus> j = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<oplus> j + i = n \\<oplus> i \\<Longrightarrow> m \\<oplus> j = n", "by(cases n,auto,cases m,auto)"], ["", "lemma label_incr_start_Node_smaller:\n  \"Label l = n \\<oplus> i \\<Longrightarrow> n = Label (l - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Label l = n \\<oplus> i \\<Longrightarrow> n = Label (l - i)", "by(cases n,auto)"], ["", "lemma label_incr_start_Node_smaller_rev:\n  \"n \\<oplus> i = Label l \\<Longrightarrow> n = Label (l - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<oplus> i = Label l \\<Longrightarrow> n = Label (l - i)", "by(cases n,auto)"], ["", "lemma label_incr_ge:\"Label l = n \\<oplus> i \\<Longrightarrow> l \\<ge> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Label l = n \\<oplus> i \\<Longrightarrow> i \\<le> l", "by(cases n) auto"], ["", "lemma label_incr_0 [dest]:\n  \"\\<lbrakk>Label 0 = n \\<oplus> i; i > 0\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Label 0 = n \\<oplus> i; 0 < i\\<rbrakk> \\<Longrightarrow> False", "by(cases n) auto"], ["", "lemma label_incr_0_rev [dest]:\n  \"\\<lbrakk>n \\<oplus> i = Label 0; i > 0\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<oplus> i = Label 0; 0 < i\\<rbrakk> \\<Longrightarrow> False", "by(cases n) auto"], ["", "subsubsection \\<open>The edges of the procedure CFG\\<close>"], ["", "text \\<open>Control flow information in this language is the node, to which we return\n  after the calles procedure is finished.\\<close>"], ["", "datatype p_edge_kind = \n  IEdge \"(vname,val,pname \\<times> label,pname) edge_kind\"\n| CEdge \"pname \\<times> expr list \\<times> vname list\""], ["", "type_synonym p_edge = \"(label \\<times> p_edge_kind \\<times> label)\""], ["", "inductive Proc_CFG :: \"cmd \\<Rightarrow> label \\<Rightarrow> p_edge_kind \\<Rightarrow> label \\<Rightarrow> bool\"\n(\"_ \\<turnstile> _ -_\\<rightarrow>\\<^sub>p _\")\nwhere\n\n  Proc_CFG_Entry_Exit:\n  \"prog \\<turnstile> Entry -IEdge (\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Exit\"\n\n| Proc_CFG_Entry:\n  \"prog \\<turnstile> Entry -IEdge (\\<lambda>s. True)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 0\"\n\n| Proc_CFG_Skip: \n  \"Skip \\<turnstile> Label 0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\"\n\n| Proc_CFG_LAss: \n  \"V:=e \\<turnstile> Label 0 -IEdge \\<Up>(\\<lambda>cf. update cf V e)\\<rightarrow>\\<^sub>p Label 1\"\n\n| Proc_CFG_LAssSkip:\n  \"V:=e \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\"\n\n| Proc_CFG_SeqFirst:\n  \"\\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n' \\<noteq> Exit\\<rbrakk> \\<Longrightarrow> c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\"\n\n| Proc_CFG_SeqConnect: \n  \"\\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry\\<rbrakk> \\<Longrightarrow> c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\"\n\n| Proc_CFG_SeqSecond: \n  \"\\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry\\<rbrakk> \\<Longrightarrow> c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\"\n\n| Proc_CFG_CondTrue:\n    \"if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> Label 0 \n  -IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 1\"\n\n| Proc_CFG_CondFalse:\n    \"if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> Label 0 -IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p \n                        Label (#:c\\<^sub>1 + 1)\"\n\n| Proc_CFG_CondThen:\n  \"\\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry\\<rbrakk> \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\"\n\n| Proc_CFG_CondElse:\n  \"\\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry\\<rbrakk> \n  \\<Longrightarrow> if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n \\<oplus> (#:c\\<^sub>1 + 1) -et\\<rightarrow>\\<^sub>p n' \\<oplus> (#:c\\<^sub>1 + 1)\"\n\n| Proc_CFG_WhileTrue:\n    \"while (b) c' \\<turnstile> Label 0 -IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 2\"\n\n| Proc_CFG_WhileFalse:\n    \"while (b) c' \\<turnstile> Label 0 -IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p Label 1\"\n\n| Proc_CFG_WhileFalseSkip:\n  \"while (b) c' \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\"\n\n| Proc_CFG_WhileBody:\n  \"\\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk> \n  \\<Longrightarrow> while (b) c' \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\"\n\n| Proc_CFG_WhileBodyExit:\n  \"\\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry\\<rbrakk> \\<Longrightarrow> while (b) c' \\<turnstile> n \\<oplus> 2 -et\\<rightarrow>\\<^sub>p Label 0\"\n\n| Proc_CFG_Call:\n  \"Call p es rets \\<turnstile> Label 0 -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label 1\"\n\n| Proc_CFG_CallSkip:\n  \"Call p es rets \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\""], ["", "subsubsection\\<open>Some lemmas about the procedure CFG\\<close>"], ["", "lemma Proc_CFG_Exit_no_sourcenode [dest]:\n  \"prog \\<turnstile> Exit -et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> Exit -et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n    False", "by(induct prog n\\<equiv>\"Exit\" et n' rule:Proc_CFG.induct,auto)"], ["", "lemma Proc_CFG_Entry_no_targetnode [dest]:\n  \"prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p Entry \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p Entry \\<Longrightarrow>\n    False", "by(induct prog n et n'\\<equiv>\"Entry\" rule:Proc_CFG.induct,auto)"], ["", "lemma Proc_CFG_IEdge_intra_kind:\n  \"prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> intra_kind et\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n    intra_kind et", "by(induct prog n x\\<equiv>\"IEdge et\" n' rule:Proc_CFG.induct,auto simp:intra_kind_def)"], ["", "lemma [dest]:\"prog \\<turnstile> n -IEdge (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> n -IEdge\n                          (Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n    False", "by(fastforce dest:Proc_CFG_IEdge_intra_kind simp:intra_kind_def)"], ["", "lemma [dest]:\"prog \\<turnstile> n -IEdge (Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> n -IEdge\n                          (Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n    False", "by(fastforce dest:Proc_CFG_IEdge_intra_kind simp:intra_kind_def)"], ["", "lemma Proc_CFG_sourcelabel_less_num_nodes:\n  \"prog \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> l < #:prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n    l < #:prog", "proof(induct prog \"Label l\" et n' arbitrary:l rule:Proc_CFG.induct)"], ["proof (state)\ngoal (17 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>1 et n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n';\n        l < #:c\\<^sub>1; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>c\\<^sub>1 et c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        l < #:c\\<^sub>1; Label l \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 10. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\nA total of 17 subgoals...", "case (Proc_CFG_SeqFirst c\\<^sub>1 et n' c\\<^sub>2 l)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n'\n  l < #:c\\<^sub>1\n  n' \\<noteq> Exit\n\ngoal (17 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>1 et n' c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n';\n        l < #:c\\<^sub>1; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>c\\<^sub>1 et c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        l < #:c\\<^sub>1; Label l \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 10. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\nA total of 17 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p n'\n  l < #:c\\<^sub>1\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1;; c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1;; c\\<^sub>2\n\ngoal (16 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>1 et c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        l < #:c\\<^sub>1; Label l \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 10. \\<And>b c'. 0 < #:while (b) c'\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>1 et c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        l < #:c\\<^sub>1; Label l \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 10. \\<And>b c'. 0 < #:while (b) c'\nA total of 16 subgoals...", "case (Proc_CFG_SeqConnect c\\<^sub>1 et c\\<^sub>2 l)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Exit\n  l < #:c\\<^sub>1\n  Label l \\<noteq> Entry\n\ngoal (16 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>1 et c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n  l -et\\<rightarrow>\\<^sub>p Exit;\n        l < #:c\\<^sub>1; Label l \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 10. \\<And>b c'. 0 < #:while (b) c'\nA total of 16 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label l -et\\<rightarrow>\\<^sub>p Exit\n  l < #:c\\<^sub>1\n  Label l \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1;; c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1;; c\\<^sub>2\n\ngoal (15 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 0 < #:while (b) c'\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 0 < #:while (b) c'\nA total of 15 subgoals...", "case (Proc_CFG_SeqSecond c\\<^sub>2 n et n' c\\<^sub>1 l)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>2\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 = Label l\n\ngoal (15 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 0 < #:while (b) c'\nA total of 15 subgoals...", "note n = \\<open>n \\<oplus> #:c\\<^sub>1 = Label l\\<close>"], ["proof (state)\nthis:\n  n \\<oplus> #:c\\<^sub>1 = Label l\n\ngoal (15 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 0 < #:while (b) c'\nA total of 15 subgoals...", "note IH = \\<open>\\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2\\<close>"], ["proof (state)\nthis:\n  n = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>2\n\ngoal (15 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 0 < #:while (b) c'\nA total of 15 subgoals...", "from n"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 = Label l", "obtain l' where l':\"n = Label l'\""], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n\ngoal (15 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 0 < #:while (b) c'\nA total of 15 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>2", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "."], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (15 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 0 < #:while (b) c'\nA total of 15 subgoals...", "with n l'"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 = Label l\n  n = Label l'\n  l' < #:c\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 = Label l\n  n = Label l'\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1;; c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1;; c\\<^sub>2\n\ngoal (14 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 14 subgoals...", "case (Proc_CFG_CondThen c\\<^sub>1 n et n' b c\\<^sub>2 l)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>1\n  n \\<noteq> Entry\n  n \\<oplus> 1 = Label l\n\ngoal (14 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 14 subgoals...", "note n = \\<open>n \\<oplus> 1 = Label l\\<close>"], ["proof (state)\nthis:\n  n \\<oplus> 1 = Label l\n\ngoal (14 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 14 subgoals...", "note IH = \\<open>\\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1\\<close>"], ["proof (state)\nthis:\n  n = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>1\n\ngoal (14 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 14 subgoals...", "from n"], ["proof (chain)\npicking this:\n  n \\<oplus> 1 = Label l", "obtain l' where l':\"n = Label l'\""], ["proof (prove)\nusing this:\n  n \\<oplus> 1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n\ngoal (14 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 14 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>1", "have \"l' < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>1", "."], ["proof (state)\nthis:\n  l' < #:c\\<^sub>1\n\ngoal (14 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 0 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 14 subgoals...", "with n l'"], ["proof (chain)\npicking this:\n  n \\<oplus> 1 = Label l\n  n = Label l'\n  l' < #:c\\<^sub>1", "show ?case"], ["proof (prove)\nusing this:\n  n \\<oplus> 1 = Label l\n  n = Label l'\n  l' < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. l < #:if (b) c\\<^sub>1 else c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n\ngoal (13 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 13 subgoals...", "case (Proc_CFG_CondElse c\\<^sub>2 n et n' b c\\<^sub>1 l)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>2\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n\ngoal (13 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 13 subgoals...", "note n = \\<open>n \\<oplus> (#:c\\<^sub>1 + 1) = Label l\\<close>"], ["proof (state)\nthis:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n\ngoal (13 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 13 subgoals...", "note IH = \\<open>\\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2\\<close>"], ["proof (state)\nthis:\n  n = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>2\n\ngoal (13 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 13 subgoals...", "from n"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l", "obtain l' where l':\"n = Label l'\""], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n\ngoal (13 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 13 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>2", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "."], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (13 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 0 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 13 subgoals...", "with n l'"], ["proof (chain)\npicking this:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n  n = Label l'\n  l' < #:c\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  n \\<oplus> #:c\\<^sub>1 + 1 = Label l\n  n = Label l'\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. l < #:if (b) c\\<^sub>1 else c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n\ngoal (12 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "case (Proc_CFG_WhileBody c' n et n' b l)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label ?l \\<Longrightarrow> ?l < #:c'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  n \\<oplus> 2 = Label l\n\ngoal (12 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "note n = \\<open>n \\<oplus> 2 = Label l\\<close>"], ["proof (state)\nthis:\n  n \\<oplus> 2 = Label l\n\ngoal (12 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "note IH = \\<open>\\<And>l. n = Label l \\<Longrightarrow> l < #:c'\\<close>"], ["proof (state)\nthis:\n  n = Label ?l \\<Longrightarrow> ?l < #:c'\n\ngoal (12 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "from n"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l", "obtain l' where l':\"n = Label l'\""], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n\ngoal (12 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  l' < #:c'", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. l' < #:c'", "."], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (12 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "with n l'"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l\n  n = Label l'\n  l' < #:c'", "show ?case"], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n  n = Label l'\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. l < #:while (b) c'", "by simp"], ["proof (state)\nthis:\n  l < #:while (b) c'\n\ngoal (11 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>p es rets. 0 < #:Call p es rets\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>p es rets. 0 < #:Call p es rets\nA total of 11 subgoals...", "case (Proc_CFG_WhileBodyExit c' n et b l)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n = Label ?l \\<Longrightarrow> ?l < #:c'\n  n \\<noteq> Entry\n  n \\<oplus> 2 = Label l\n\ngoal (11 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>p es rets. 0 < #:Call p es rets\nA total of 11 subgoals...", "note n = \\<open>n \\<oplus> 2 = Label l\\<close>"], ["proof (state)\nthis:\n  n \\<oplus> 2 = Label l\n\ngoal (11 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>p es rets. 0 < #:Call p es rets\nA total of 11 subgoals...", "note IH = \\<open>\\<And>l. n = Label l \\<Longrightarrow> l < #:c'\\<close>"], ["proof (state)\nthis:\n  n = Label ?l \\<Longrightarrow> ?l < #:c'\n\ngoal (11 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>p es rets. 0 < #:Call p es rets\nA total of 11 subgoals...", "from n"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l", "obtain l' where l':\"n = Label l'\""], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n) auto"], ["proof (state)\nthis:\n  n = Label l'\n\ngoal (11 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>p es rets. 0 < #:Call p es rets\nA total of 11 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  l' < #:c'", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. l' < #:c'", "."], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (11 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>l. n = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>p es rets. 0 < #:Call p es rets\nA total of 11 subgoals...", "with n l'"], ["proof (chain)\npicking this:\n  n \\<oplus> 2 = Label l\n  n = Label l'\n  l' < #:c'", "show ?case"], ["proof (prove)\nusing this:\n  n \\<oplus> 2 = Label l\n  n = Label l'\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. l < #:while (b) c'", "by simp"], ["proof (state)\nthis:\n  l < #:while (b) c'\n\ngoal (10 subgoals):\n 1. 0 < #:Skip\n 2. \\<And>V e. 0 < #:V:=e\n 3. \\<And>V e. 1 < #:V:=e\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 0 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 0 < #:while (b) c'\n 7. \\<And>b c'. 0 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>p es rets. 0 < #:Call p es rets\n 10. \\<And>p es rets. 1 < #:Call p es rets", "qed (auto simp:num_inner_nodes_gr_0)"], ["", "lemma Proc_CFG_targetlabel_less_num_nodes:\n  \"prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow> l < #:prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l \\<Longrightarrow>\n    l < #:prog", "proof(induct prog n et \"Label l\" arbitrary:l rule:Proc_CFG.induct)"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l;\n        l < #:c\\<^sub>1; Label l \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 10. \\<And>b c'. 2 < #:while (b) c'\nA total of 14 subgoals...", "case (Proc_CFG_SeqFirst c\\<^sub>1 n et c\\<^sub>2 l)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l\n  l < #:c\\<^sub>1\n  Label l \\<noteq> Exit\n\ngoal (14 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l;\n        l < #:c\\<^sub>1; Label l \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 10. \\<And>b c'. 2 < #:while (b) c'\nA total of 14 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Label l\n  l < #:c\\<^sub>1\n  Label l \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1;; c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1;; c\\<^sub>2\n\ngoal (13 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 2 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 2 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 13 subgoals...", "case (Proc_CFG_SeqSecond c\\<^sub>2 n et n' c\\<^sub>1 l)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>2\n  n \\<noteq> Entry\n  n' \\<oplus> #:c\\<^sub>1 = Label l\n\ngoal (13 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 2 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 13 subgoals...", "note n' = \\<open>n' \\<oplus> #:c\\<^sub>1 = Label l\\<close>"], ["proof (state)\nthis:\n  n' \\<oplus> #:c\\<^sub>1 = Label l\n\ngoal (13 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 2 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 13 subgoals...", "note IH = \\<open>\\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2\\<close>"], ["proof (state)\nthis:\n  n' = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>2\n\ngoal (13 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 2 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 13 subgoals...", "from n'"], ["proof (chain)\npicking this:\n  n' \\<oplus> #:c\\<^sub>1 = Label l", "obtain l' where l':\"n' = Label l'\""], ["proof (prove)\nusing this:\n  n' \\<oplus> #:c\\<^sub>1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n' = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n') auto"], ["proof (state)\nthis:\n  n' = Label l'\n\ngoal (13 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 2 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 13 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>2", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "."], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (13 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:c\\<^sub>1;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 9. \\<And>b c'. 2 < #:while (b) c'\n 10. \\<And>b c'. 1 < #:while (b) c'\nA total of 13 subgoals...", "with n' l'"], ["proof (chain)\npicking this:\n  n' \\<oplus> #:c\\<^sub>1 = Label l\n  n' = Label l'\n  l' < #:c\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  n' \\<oplus> #:c\\<^sub>1 = Label l\n  n' = Label l'\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1;; c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1;; c\\<^sub>2\n\ngoal (12 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 2 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 2 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "case (Proc_CFG_CondThen c\\<^sub>1 n et n' b c\\<^sub>2 l)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>1\n  n \\<noteq> Entry\n  n' \\<oplus> 1 = Label l\n\ngoal (12 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 2 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "note n' = \\<open>n' \\<oplus> 1 = Label l\\<close>"], ["proof (state)\nthis:\n  n' \\<oplus> 1 = Label l\n\ngoal (12 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 2 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "note IH = \\<open>\\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1\\<close>"], ["proof (state)\nthis:\n  n' = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>1\n\ngoal (12 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 2 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "from n'"], ["proof (chain)\npicking this:\n  n' \\<oplus> 1 = Label l", "obtain l' where l':\"n' = Label l'\""], ["proof (prove)\nusing this:\n  n' \\<oplus> 1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n' = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n') auto"], ["proof (state)\nthis:\n  n' = Label l'\n\ngoal (12 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 2 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>1", "have \"l' < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>1", "."], ["proof (state)\nthis:\n  l' < #:c\\<^sub>1\n\ngoal (12 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 l.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>1;\n        n \\<noteq> Entry; n' \\<oplus> 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 8. \\<And>b c'. 2 < #:while (b) c'\n 9. \\<And>b c'. 1 < #:while (b) c'\n 10. \\<And>c' n et n' b l.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n        \\<Longrightarrow> l < #:while (b) c'\nA total of 12 subgoals...", "with n' l'"], ["proof (chain)\npicking this:\n  n' \\<oplus> 1 = Label l\n  n' = Label l'\n  l' < #:c\\<^sub>1", "show ?case"], ["proof (prove)\nusing this:\n  n' \\<oplus> 1 = Label l\n  n' = Label l'\n  l' < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. l < #:if (b) c\\<^sub>1 else c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n\ngoal (11 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 2 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> 0 < #:while (b) c'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 2 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> 0 < #:while (b) c'\nA total of 11 subgoals...", "case (Proc_CFG_CondElse c\\<^sub>2 n et n' b c\\<^sub>1 l)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>2\n  n \\<noteq> Entry\n  n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\n\ngoal (11 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 2 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> 0 < #:while (b) c'\nA total of 11 subgoals...", "note n' = \\<open>n' \\<oplus> (#:c\\<^sub>1 + 1) = Label l\\<close>"], ["proof (state)\nthis:\n  n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\n\ngoal (11 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 2 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> 0 < #:while (b) c'\nA total of 11 subgoals...", "note IH = \\<open>\\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2\\<close>"], ["proof (state)\nthis:\n  n' = Label ?l \\<Longrightarrow> ?l < #:c\\<^sub>2\n\ngoal (11 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 2 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> 0 < #:while (b) c'\nA total of 11 subgoals...", "from n'"], ["proof (chain)\npicking this:\n  n' \\<oplus> #:c\\<^sub>1 + 1 = Label l", "obtain l' where l':\"n' = Label l'\""], ["proof (prove)\nusing this:\n  n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n' = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n') auto"], ["proof (state)\nthis:\n  n' = Label l'\n\ngoal (11 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 2 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> 0 < #:while (b) c'\nA total of 11 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  l' < #:c\\<^sub>2", "have \"l' < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. l' < #:c\\<^sub>2", "."], ["proof (state)\nthis:\n  l' < #:c\\<^sub>2\n\ngoal (11 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 l.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c\\<^sub>2;\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 7. \\<And>b c'. 2 < #:while (b) c'\n 8. \\<And>b c'. 1 < #:while (b) c'\n 9. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         n \\<noteq> Entry\\<rbrakk>\n        \\<Longrightarrow> 0 < #:while (b) c'\nA total of 11 subgoals...", "with n' l'"], ["proof (chain)\npicking this:\n  n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\n  n' = Label l'\n  l' < #:c\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  n' \\<oplus> #:c\\<^sub>1 + 1 = Label l\n  n' = Label l'\n  l' < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. l < #:if (b) c\\<^sub>1 else c\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  l < #:if (b) c\\<^sub>1 else c\\<^sub>2\n\ngoal (10 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 2 < #:while (b) c'\n 7. \\<And>b c'. 1 < #:while (b) c'\n 8. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> 0 < #:while (b) c'\n 10. \\<And>p es rets. 1 < #:Call p es rets", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 2 < #:while (b) c'\n 7. \\<And>b c'. 1 < #:while (b) c'\n 8. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> 0 < #:while (b) c'\n 10. \\<And>p es rets. 1 < #:Call p es rets", "case (Proc_CFG_WhileBody c' n et n' b l)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' = Label ?l \\<Longrightarrow> ?l < #:c'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  n' \\<oplus> 2 = Label l\n\ngoal (10 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 2 < #:while (b) c'\n 7. \\<And>b c'. 1 < #:while (b) c'\n 8. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> 0 < #:while (b) c'\n 10. \\<And>p es rets. 1 < #:Call p es rets", "note n' = \\<open>n' \\<oplus> 2 = Label l\\<close>"], ["proof (state)\nthis:\n  n' \\<oplus> 2 = Label l\n\ngoal (10 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 2 < #:while (b) c'\n 7. \\<And>b c'. 1 < #:while (b) c'\n 8. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> 0 < #:while (b) c'\n 10. \\<And>p es rets. 1 < #:Call p es rets", "note IH = \\<open>\\<And>l. n' = Label l \\<Longrightarrow> l < #:c'\\<close>"], ["proof (state)\nthis:\n  n' = Label ?l \\<Longrightarrow> ?l < #:c'\n\ngoal (10 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 2 < #:while (b) c'\n 7. \\<And>b c'. 1 < #:while (b) c'\n 8. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> 0 < #:while (b) c'\n 10. \\<And>p es rets. 1 < #:Call p es rets", "from n'"], ["proof (chain)\npicking this:\n  n' \\<oplus> 2 = Label l", "obtain l' where l':\"n' = Label l'\""], ["proof (prove)\nusing this:\n  n' \\<oplus> 2 = Label l\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n' = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n') auto"], ["proof (state)\nthis:\n  n' = Label l'\n\ngoal (10 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 2 < #:while (b) c'\n 7. \\<And>b c'. 1 < #:while (b) c'\n 8. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> 0 < #:while (b) c'\n 10. \\<And>p es rets. 1 < #:Call p es rets", "from IH[OF this]"], ["proof (chain)\npicking this:\n  l' < #:c'", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. l' < #:c'", "."], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (10 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 2 < #:while (b) c'\n 7. \\<And>b c'. 1 < #:while (b) c'\n 8. \\<And>c' n et n' b l.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>l. n' = Label l \\<Longrightarrow> l < #:c'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n' \\<oplus> 2 = Label l\\<rbrakk>\n       \\<Longrightarrow> l < #:while (b) c'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> 0 < #:while (b) c'\n 10. \\<And>p es rets. 1 < #:Call p es rets", "with n' l'"], ["proof (chain)\npicking this:\n  n' \\<oplus> 2 = Label l\n  n' = Label l'\n  l' < #:c'", "show ?case"], ["proof (prove)\nusing this:\n  n' \\<oplus> 2 = Label l\n  n' = Label l'\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. l < #:while (b) c'", "by simp"], ["proof (state)\nthis:\n  l < #:while (b) c'\n\ngoal (9 subgoals):\n 1. \\<And>prog. 0 < #:prog\n 2. \\<And>V e. 1 < #:V:=e\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> #:c\\<^sub>1 < #:c\\<^sub>1;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2. 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       #:c\\<^sub>1 + 1 < #:if (b) c\\<^sub>1 else c\\<^sub>2\n 6. \\<And>b c'. 2 < #:while (b) c'\n 7. \\<And>b c'. 1 < #:while (b) c'\n 8. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> 0 < #:while (b) c'\n 9. \\<And>p es rets. 1 < #:Call p es rets", "qed (auto simp:num_inner_nodes_gr_0)"], ["", "lemma Proc_CFG_EntryD:\n  \"prog \\<turnstile> Entry -et\\<rightarrow>\\<^sub>p n' \n  \\<Longrightarrow> (n' = Exit \\<and> et = IEdge(\\<lambda>s. False)\\<^sub>\\<surd>) \\<or> (n' = Label 0 \\<and> et = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> Entry -et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n    n' = Exit \\<and> et = IEdge (\\<lambda>s. False)\\<^sub>\\<surd> \\<or>\n    n' = Label 0 \\<and> et = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>", "by(induct prog n\\<equiv>\"Entry\" et n' rule:Proc_CFG.induct,auto)"], ["", "lemma Proc_CFG_Exit_edge:\n  obtains l et where \"prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit\" and \"l \\<le> #:prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l et.\n        \\<lbrakk>prog \\<turnstile> Label\n                                    l -IEdge et\\<rightarrow>\\<^sub>p Exit;\n         l \\<le> #:prog\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l et.\n       prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:prog", "show \"\\<exists>l et. prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and> l \\<le> #:prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l et.\n       prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:prog", "proof(induct prog)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<exists>l et.\n       Skip \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:Skip\n 2. \\<And>x1 x2.\n       \\<exists>l et.\n          x1:=x2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:x1:=x2\n 3. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 4. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 5. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 6. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "case Skip"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<exists>l et.\n       Skip \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:Skip\n 2. \\<And>x1 x2.\n       \\<exists>l et.\n          x1:=x2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:x1:=x2\n 3. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 4. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 5. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 6. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "have \"Skip \\<turnstile> Label 0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Skip \\<turnstile> Label 0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit", "by(rule Proc_CFG_Skip)"], ["proof (state)\nthis:\n  Skip \\<turnstile> Label 0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\n\ngoal (6 subgoals):\n 1. \\<exists>l et.\n       Skip \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:Skip\n 2. \\<And>x1 x2.\n       \\<exists>l et.\n          x1:=x2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:x1:=x2\n 3. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 4. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 5. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 6. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "thus ?case"], ["proof (prove)\nusing this:\n  Skip \\<turnstile> Label 0 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. \\<exists>l et.\n       Skip \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:Skip", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>l et.\n     Skip \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:Skip\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<exists>l et.\n          x1:=x2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:x1:=x2\n 2. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 3. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 4. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 5. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<exists>l et.\n          x1:=x2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:x1:=x2\n 2. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 3. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 4. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 5. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "case (LAss V e)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<exists>l et.\n          x1:=x2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:x1:=x2\n 2. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 3. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 4. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 5. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "have \"V:=e \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V:=e \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit", "by(rule Proc_CFG_LAssSkip)"], ["proof (state)\nthis:\n  V:=e \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<exists>l et.\n          x1:=x2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:x1:=x2\n 2. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 3. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 4. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 5. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "thus ?case"], ["proof (prove)\nusing this:\n  V:=e \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. \\<exists>l et.\n       V:=e \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:V:=e", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>l et.\n     V:=e \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:V:=e\n\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 2. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 3. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 4. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 2. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 3. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 4. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "case (Seq c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  \\<exists>l et.\n     c\\<^sub>1 \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:c\\<^sub>1\n  \\<exists>l et.\n     c\\<^sub>2 \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:c\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 2. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 3. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 4. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "from \\<open>\\<exists>l et. c\\<^sub>2 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and> l \\<le> #:c\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>l et.\n     c\\<^sub>2 \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:c\\<^sub>2", "obtain l et where \"c\\<^sub>2 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit\" and \"l \\<le> #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<exists>l et.\n     c\\<^sub>2 \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>l et.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> Label\n   l -IEdge et\\<rightarrow>\\<^sub>p Exit;\n         l \\<le> #:c\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit\n  l \\<le> #:c\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 2. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 3. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 4. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "hence \"c\\<^sub>1;;c\\<^sub>2 \\<turnstile> Label l \\<oplus> #:c\\<^sub>1 -IEdge et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit\n  l \\<le> #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. c\\<^sub>1;;\n    c\\<^sub>2 \\<turnstile> Label\n                            l \\<oplus> #:c\\<^sub>1 -IEdge\n               et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_SeqSecond)"], ["proof (state)\nthis:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l \\<oplus> #:c\\<^sub>1 -IEdge\n             et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1\n\ngoal (4 subgoals):\n 1. \\<And>prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            prog1;;\n                            prog2 \\<turnstile> Label\n          l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:prog1;; prog2\n 2. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 3. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 4. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "with \\<open>l \\<le> #:c\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  l \\<le> #:c\\<^sub>2\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l \\<oplus> #:c\\<^sub>1 -IEdge\n             et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1", "show ?case"], ["proof (prove)\nusing this:\n  l \\<le> #:c\\<^sub>2\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          l \\<oplus> #:c\\<^sub>1 -IEdge\n             et\\<rightarrow>\\<^sub>p Exit \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>l et.\n       c\\<^sub>1;;\n       c\\<^sub>2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:c\\<^sub>1;; c\\<^sub>2", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>l et.\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:c\\<^sub>1;; c\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 2. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 3. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 2. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 3. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "case (Cond b c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  \\<exists>l et.\n     c\\<^sub>1 \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:c\\<^sub>1\n  \\<exists>l et.\n     c\\<^sub>2 \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:c\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 2. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 3. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "from \\<open>\\<exists>l et. c\\<^sub>1 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and> l \\<le> #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>l et.\n     c\\<^sub>1 \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:c\\<^sub>1", "obtain l et where \"c\\<^sub>1 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit\" and \"l \\<le> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>l et.\n     c\\<^sub>1 \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>l et.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> Label\n   l -IEdge et\\<rightarrow>\\<^sub>p Exit;\n         l \\<le> #:c\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit\n  l \\<le> #:c\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 2. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 3. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "hence \"if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> Label l \\<oplus> 1 -IEdge et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit\n  l \\<le> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. if (b) c\\<^sub>1\n    else c\\<^sub>2 \\<turnstile> Label\n                                 l \\<oplus> 1 -IEdge\n          et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1", "by(fastforce intro:Proc_CFG_CondThen)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> Label\n                               l \\<oplus> 1 -IEdge\n        et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1\n\ngoal (3 subgoals):\n 1. \\<And>x1 prog1 prog2.\n       \\<lbrakk>\\<exists>l et.\n                   prog1 \\<turnstile> Label\n l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                   l \\<le> #:prog1;\n        \\<exists>l et.\n           prog2 \\<turnstile> Label\n                               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n           l \\<le> #:prog2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l et.\n                            if (x1) prog1\n                            else prog2 \\<turnstile> Label\n               l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n                            l \\<le> #:if (x1) prog1 else prog2\n 2. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 3. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "with \\<open>l \\<le> #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  l \\<le> #:c\\<^sub>1\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> Label\n                               l \\<oplus> 1 -IEdge\n        et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1", "show ?case"], ["proof (prove)\nusing this:\n  l \\<le> #:c\\<^sub>1\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> Label\n                               l \\<oplus> 1 -IEdge\n        et\\<rightarrow>\\<^sub>p Exit \\<oplus> 1\n\ngoal (1 subgoal):\n 1. \\<exists>l et.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    l -IEdge\n  et\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:if (b) c\\<^sub>1 else c\\<^sub>2", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>l et.\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> Label\n                                  l -IEdge\net\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:if (b) c\\<^sub>1 else c\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 2. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 2. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "case (While b c')"], ["proof (state)\nthis:\n  \\<exists>l et.\n     c' \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:c'\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 2. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "have \"while (b) c' \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while (b) c' \\<turnstile> Label\n                               1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit", "by(rule Proc_CFG_WhileFalseSkip)"], ["proof (state)\nthis:\n  while (b) c' \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\n\ngoal (2 subgoals):\n 1. \\<And>x1 prog.\n       \\<exists>l et.\n          prog \\<turnstile> Label\n                             l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:prog \\<Longrightarrow>\n       \\<exists>l et.\n          while (x1) prog \\<turnstile> Label\n  l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:while (x1) prog\n 2. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "thus ?case"], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. \\<exists>l et.\n       while (b) c' \\<turnstile> Label\n                                  l -IEdge\net\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:while (b) c'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>l et.\n     while (b) c' \\<turnstile> Label\n                                l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:while (b) c'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "case (Call p es rets)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "have \"Call p es rets \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Call p es\n     rets \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit", "by(rule Proc_CFG_CallSkip)"], ["proof (state)\nthis:\n  Call p es\n   rets \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<exists>l et.\n          Call x1 x2\n           x3 \\<turnstile> Label\n                            l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n          l \\<le> #:Call x1 x2 x3", "thus ?case"], ["proof (prove)\nusing this:\n  Call p es\n   rets \\<turnstile> Label 1 -IEdge \\<Up>id\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. \\<exists>l et.\n       Call p es\n        rets \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n       l \\<le> #:Call p es rets", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>l et.\n     Call p es\n      rets \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:Call p es rets\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l et.\n     prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Exit \\<and>\n     l \\<le> #:prog\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Lots of lemmas for call edges \\<open>\\<dots>\\<close>\\<close>"], ["", "lemma Proc_CFG_Call_Labels:\n  \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> \\<exists>l. n = Label l \\<and> n' = Label (Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n    \\<exists>l. n = Label l \\<and> n' = Label (Suc l)", "by(induct prog n et\\<equiv>\"CEdge (p,es,rets)\" n' rule:Proc_CFG.induct,auto)"], ["", "lemma Proc_CFG_Call_target_0:\n  \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label 0 \\<Longrightarrow> n = Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p Label\n                 0 \\<Longrightarrow>\n    n = Entry", "by(induct prog n et\\<equiv>\"CEdge (p,es,rets)\" n'\\<equiv>\"Label 0\" rule:Proc_CFG.induct)\n  (auto dest:Proc_CFG_Call_Labels)"], ["", "lemma Proc_CFG_Call_Intra_edge_not_same_source:\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n    \\<Longrightarrow> False", "proof(induct prog n \"CEdge (p,es,rets)\" n' arbitrary:n'' rule:Proc_CFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_SeqFirst c\\<^sub>1 n n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n -IEdge\n                             et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n' \\<noteq> Exit\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -IEdge\n                             et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \n    \\<open>n' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit", "obtain nx where \"c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> n -IEdge\n                                   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = prog; n = Entry;\n        IEdge et = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = prog; n = Entry;\n        IEdge et = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = Skip; n = Label 0;\n     IEdge et = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = V:=e; n = Label 0;\n        IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = V:=e; n = Label 1;\n        IEdge et = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n eta n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n = n; IEdge et = eta; n'' = n';\n        c\\<^sub>1' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n eta c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n = n; IEdge et = eta; n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n eta n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n = n \\<oplus> #:c\\<^sub>1'; IEdge et = eta;\n        n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n        n = Label 0;\n        IEdge et =\n        IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>1 \\<turnstile> n -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                    thesis;\n         c\\<^sub>1 \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n         n' \\<noteq> Exit;\n         c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n         n = Label 0;\n         IEdge et =\n         IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "apply(auto intro:Proc_CFG_Entry_Exit Proc_CFG_Entry)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                             et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; n = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n)(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_SeqConnect c\\<^sub>1 n c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c\\<^sub>1 \\<turnstile> n -IEdge\n                             et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  False\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_SeqSecond c\\<^sub>2 n n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> n -IEdge\n                             et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -IEdge\n                             et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \n    \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain nx where \"c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> n -IEdge\n                                   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n               et\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n               et\\<rightarrow>\\<^sub>p n'';\n     n'' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n               et\\<rightarrow>\\<^sub>p Exit;\n     n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n'';\n        n'' \\<noteq> Exit; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n               et\\<rightarrow>\\<^sub>p n'';\n     n'' \\<noteq> Exit; n = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n               et\\<rightarrow>\\<^sub>p n'';\n     n'' \\<noteq> Exit; n = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n               et\\<rightarrow>\\<^sub>p Exit;\n     n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n               et\\<rightarrow>\\<^sub>p Exit;\n     n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = Label #:c\\<^sub>1;\n        c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p Exit;\n        n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n               et\\<rightarrow>\\<^sub>p Exit;\n     n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry; n = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n               et\\<rightarrow>\\<^sub>p Exit;\n     n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry; n = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n,auto,case_tac n,auto)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                  et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_CondThen c\\<^sub>1 n n' b c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n -IEdge\n                             et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n       et\\<rightarrow>\\<^sub>p n''\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -IEdge\n                             et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n    \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n       et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain nx where \"c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n       et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> n -IEdge\n                                   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n          et\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> Label\n                                x1 -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Label (Suc x1) = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> Label\n                                x1 -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Label (Suc x1) = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1; n = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> Label\n                                x1 -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Label (Suc x1) = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> Label\n                                x1 -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Label (Suc x1) = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> Label\n                                x1 -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Label (Suc x1) = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n)(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_CondElse c\\<^sub>2 n n' b c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> n -IEdge\n                             et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n   1 -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -IEdge\n                             et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 + 1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n    \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n   1 -IEdge et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain nx where \"c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n   1 -IEdge et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> n -IEdge\n                                   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -IEdge\n     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n      1 -IEdge et\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        n \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        n \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> Label\n                                x1 -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        n \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> Label\n                                x1 -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1; n = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> Label\n                                x1 -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> Label\n                                x1 -CEdge\n                                     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n = Label x1; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        n \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -IEdge\n        et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        n \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n,auto,case_tac n,auto)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -IEdge\net\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_WhileBody c' n n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge et\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n    \\<open>n \\<noteq> Entry\\<close> \\<open>n' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge et\\<rightarrow>\\<^sub>p n''\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit", "obtain nx where \"c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge et\\<rightarrow>\\<^sub>p n''\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c' \\<turnstile> n -IEdge\n                            et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n -IEdge\n                                    et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n        et\\<rightarrow>\\<^sub>p n'';\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n -IEdge\n                                    \\<Up>id\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = Label (Suc 0);\n     et = \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(drule label_incr_ge[OF sym])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n -IEdge\n                                    \\<Up>id\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit; et = \\<Up>id; n'' = Exit;\n     2 \\<le> Suc 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> Label\n                                    x1 -IEdge\n   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> Label\n                         x1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; Label (Suc (Suc x1)) = n \\<oplus> 2;\n        n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> Label\n                                    x1 -IEdge\n   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> Label\n                         x1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; Label (Suc (Suc x1)) = n \\<oplus> 2;\n        n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n = Label x1;\n        n = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> Label\n                                    x1 -IEdge\n   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> Label\n                         x1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; Label (Suc (Suc x1)) = n \\<oplus> 2;\n        n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n = Label x1; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> Label\n                                    x1 -IEdge\n   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> Label\n                         x1 -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; Label (Suc (Suc x1)) = n \\<oplus> 2;\n        n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n = Label x1; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -IEdge\n et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n \\<oplus> 2 = n \\<oplus> 2;\n        n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n,auto,case_tac n,auto)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_WhileBodyExit c' n b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -IEdge\n           et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "show ?case"], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case Proc_CFG_Call"], ["proof (state)\nthis:\n  Call p es rets \\<turnstile> Label 0 -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>Call p es rets \\<turnstile> Label 0 -IEdge et\\<rightarrow>\\<^sub>p n''\\<close>"], ["proof (chain)\npicking this:\n  Call p es rets \\<turnstile> Label 0 -IEdge et\\<rightarrow>\\<^sub>p n''", "show ?case"], ["proof (prove)\nusing this:\n  Call p es rets \\<turnstile> Label 0 -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proc_CFG_Call_Intra_edge_not_same_target:\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     prog \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> False", "proof(induct prog n \"CEdge (p,es,rets)\" n' arbitrary:n'' rule:Proc_CFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p Label\n                        #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "case (Proc_CFG_SeqFirst c\\<^sub>1 n n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> ?n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  False\n  n' \\<noteq> Exit\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p Label\n                        #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> ?n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  False\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p Label\n                        #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \n    \\<open>n' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit", "have \"c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c\\<^sub>1;;\n             c\\<^sub>2 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n';\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n             et\\<rightarrow>\\<^sub>p n'", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = prog; n'' = Entry;\n        IEdge et = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n' = Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n                et\\<rightarrow>\\<^sub>p n'\n 2. \\<And>prog.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = prog; n'' = Entry;\n        IEdge et = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n' = Label 0\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n                et\\<rightarrow>\\<^sub>p n'\n 3. \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = Skip; n'' = Label 0;\n     IEdge et = IEdge \\<Up>id; n' = Exit\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n             et\\<rightarrow>\\<^sub>p n'\n 4. \\<And>V e.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = V:=e; n'' = Label 0;\n        IEdge et = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n' = Label 1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n                et\\<rightarrow>\\<^sub>p n'\n 5. \\<And>V e.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = V:=e; n'' = Label 1;\n        IEdge et = IEdge \\<Up>id; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n                et\\<rightarrow>\\<^sub>p n'\n 6. \\<And>c\\<^sub>1' n eta n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n'' = n; IEdge et = eta; n' = n';\n        c\\<^sub>1' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n                et\\<rightarrow>\\<^sub>p n'\n 7. \\<And>c\\<^sub>1' n eta c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n'' = n; IEdge et = eta; n' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n                et\\<rightarrow>\\<^sub>p n'\n 8. \\<And>c\\<^sub>2' n eta n' c\\<^sub>1'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit; c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n'' = n \\<oplus> #:c\\<^sub>1'; IEdge et = eta;\n        n' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n                et\\<rightarrow>\\<^sub>p n'\n 9. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n        n'' = Label 0;\n        IEdge et =\n        IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        n' = Label 1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n                et\\<rightarrow>\\<^sub>p n'\n 10. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n      (p, es, rets)\\<rightarrow>\\<^sub>p n';\n         n' \\<noteq> Exit;\n         c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n         n'' = Label 0;\n         IEdge et =\n         IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n         n' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -IEdge\n                 et\\<rightarrow>\\<^sub>p n'\nA total of 19 subgoals...", "apply(auto intro:Proc_CFG_Entry dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> Exit; n'' = n \\<oplus> #:c\\<^sub>1;\n        n' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                                   et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by(case_tac n')(auto dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p Label\n                        #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p Label\n                        #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p Label\n                        #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "case (Proc_CFG_SeqConnect c\\<^sub>1 n c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c\\<^sub>1 \\<turnstile> ?n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -IEdge\n                               et\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p Label\n                        #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "from \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  False\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "case (Proc_CFG_SeqSecond c\\<^sub>2 n n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> ?n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -IEdge\n                               et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> ?n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  False\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \n    \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -IEdge\n                               et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain nx where \"c\\<^sub>2 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -IEdge\n                               et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> nx -IEdge\n                                    et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                  et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>s.\n          False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Entry; et = (\\<lambda>s. False)\\<^sub>\\<surd>;\n     n' \\<oplus> #:c\\<^sub>1 = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry;\n     c\\<^sub>1 \\<turnstile> n'' -IEdge\n                                  et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Exit;\n     n'' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(fastforce intro:Proc_CFG_Entry_Exit)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry;\n     c\\<^sub>1 \\<turnstile> n'' -IEdge\n                                  et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Exit;\n     n'' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        c\\<^sub>1 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> Exit; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry;\n     c\\<^sub>1 \\<turnstile> n'' -IEdge\n                                  et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Exit; n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry;\n     c\\<^sub>1 \\<turnstile> n'' -IEdge\n                                  et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Exit; n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Exit;\n     n'' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Exit;\n     n'' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label #:c\\<^sub>1;\n        c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n'' \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Exit;\n     n'' \\<noteq> Entry; n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<oplus> #:c\\<^sub>1 = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Exit;\n     n'' \\<noteq> Entry; n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_Call_target_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> #:c\\<^sub>1;\n        Label (x1 + #:c\\<^sub>1) = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n') auto"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "case (Proc_CFG_CondThen c\\<^sub>1 n n' b c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> ?n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> ?n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  False\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n    \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain nx where \"c\\<^sub>1 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> nx -IEdge\n                                    et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n'' -IEdge\n et\\<rightarrow>\\<^sub>p n' \\<oplus> 1;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>s.\n          False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Entry; et = (\\<lambda>s. False)\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc #:c\\<^sub>1)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         (\\<lambda>s.\n             False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = Entry;\n        et = (\\<lambda>s. False)\\<^sub>\\<surd>; n' \\<oplus> Suc 0 = Exit;\n        n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>s.\n          False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Entry; et = (\\<lambda>s. False)\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Exit; n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>s.\n          False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Entry; et = (\\<lambda>s. False)\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Exit; n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc #:c\\<^sub>1)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto intro:Proc_CFG_Entry_Exit)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc #:c\\<^sub>1)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         (\\<lambda>cf.\n             state_check cf b\n              (Some\n                true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = Label 0;\n        et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        n' \\<oplus> Suc 0 = Label (Suc 0); n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc 0); n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc 0); n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc #:c\\<^sub>1)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_Call_target_0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc #:c\\<^sub>1)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         (\\<lambda>cf.\n             state_check cf b\n              (Some\n                false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = Label 0;\n        et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        n' \\<oplus> Suc 0 = Label (Suc #:c\\<^sub>1); n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc #:c\\<^sub>1); n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc 0 = Label (Suc #:c\\<^sub>1); n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        Label (Suc x1) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        Label (Suc x1) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n' = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        Label (Suc x1) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        Label (Suc x1) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc 0 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        Label (Suc x1) = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        Exit = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        Label (Suc x1) = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n' = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        Label (Suc x1) = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        Label (Suc x1) = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        Exit = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        Exit = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n')(auto dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "case (Proc_CFG_CondElse c\\<^sub>2 n n' b c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> ?n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 +\n                                  1\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> ?n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  False\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n    \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 +\n                                  1\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain nx where \"c\\<^sub>2 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -IEdge\n                                    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 +\n                                  1\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> nx -IEdge\n                                    et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n'' -IEdge\n et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>s.\n          False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Entry; et = (\\<lambda>s. False)\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc #:c\\<^sub>1)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         (\\<lambda>s.\n             False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = Entry;\n        et = (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n' \\<oplus> Suc #:c\\<^sub>1 = Exit; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>s.\n          False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Entry; et = (\\<lambda>s. False)\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Exit; n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>s.\n          False)\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Entry; et = (\\<lambda>s. False)\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Exit; n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc #:c\\<^sub>1)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 6. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto intro:Proc_CFG_Entry_Exit)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc #:c\\<^sub>1)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         (\\<lambda>cf.\n             state_check cf b\n              (Some\n                true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = Label 0;\n        et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc 0); n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc 0); n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc 0); n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc #:c\\<^sub>1)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_Call_target_0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc #:c\\<^sub>1)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         (\\<lambda>cf.\n             state_check cf b\n              (Some\n                false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = Label 0;\n        et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc #:c\\<^sub>1);\n        n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc #:c\\<^sub>1);\n     n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> nx -IEdge\n      (\\<lambda>cf.\n          state_check cf b\n           (Some\n             false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> Suc #:c\\<^sub>1 = Label (Suc #:c\\<^sub>1);\n     n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_Call_target_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0; Exit = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n' = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Label x1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0; Exit = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0; Exit = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0; Exit = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0; Exit = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc 0; Exit = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -IEdge\n         et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n'' = n \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n',auto,case_tac n',auto)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -IEdge\n    et\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "case (Proc_CFG_WhileBody c' n n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c' \\<turnstile> ?n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  while (b) c' \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c' \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> ?n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  False\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "from \\<open>while (b) c' \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<close> \\<open>c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n    \\<open>n \\<noteq> Entry\\<close> \\<open>n' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit", "obtain nx where \"c' \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c' \\<turnstile> nx -IEdge\n                             et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> nx -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     while (b) c' \\<turnstile> n'' -IEdge\n                                     et\\<rightarrow>\\<^sub>p n' \\<oplus> 2;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> nx -IEdge\n                                     (\\<lambda>cf.\n   state_check cf b\n    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> 2 = Label 2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> nx -IEdge\n                                     (\\<lambda>cf.\n   state_check cf b\n    (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> 2 = Label (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> nx -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n'' = n \\<oplus> 2;\n        n' \\<oplus> 2 = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> nx -IEdge\n  (\\<lambda>cf.\n      state_check cf b\n       (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n'' = Label 0;\n        et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        n' \\<oplus> 2 = Label 2; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> nx -IEdge\n                                     (\\<lambda>cf.\n   state_check cf b\n    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> 2 = Label 2; n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> nx -IEdge\n                                     (\\<lambda>cf.\n   state_check cf b\n    (Some true))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n     n' \\<oplus> 2 = Label 2; n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> nx -IEdge\n                                     (\\<lambda>cf.\n   state_check cf b\n    (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> 2 = Label (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> nx -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n'' = n \\<oplus> 2;\n        n' \\<oplus> 2 = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_Call_target_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> nx -IEdge\n                                     (\\<lambda>cf.\n   state_check cf b\n    (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> 2 = Label (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> nx -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n'' = n \\<oplus> 2;\n        n' \\<oplus> 2 = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> nx -IEdge\n  (\\<lambda>cf.\n      state_check cf b\n       (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n'' = Label 0;\n        et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n        n' \\<oplus> 2 = Label (Suc 0); n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> nx -IEdge\n                                     (\\<lambda>cf.\n   state_check cf b\n    (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> 2 = Label (Suc 0); n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> nx -IEdge\n                                     (\\<lambda>cf.\n   state_check cf b\n    (Some false))\\<^sub>\\<surd>\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry; n' \\<noteq> Exit; n'' = Label 0;\n     et = (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n     n' \\<oplus> 2 = Label (Suc 0); n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> nx -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n'' = n \\<oplus> 2;\n        n' \\<oplus> 2 = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> nx -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n'' = n \\<oplus> 2;\n        n' \\<oplus> 2 = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n',auto,case_tac n',auto)"], ["proof (state)\nthis:\n  c' \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c' \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  c' \\<turnstile> nx -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "case (Proc_CFG_WhileBodyExit c' n b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c' \\<turnstile> ?n'' -IEdge et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  while (b) c' \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Label 0\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -IEdge\n                                 et\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -IEdge\n  et\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "from \\<open>c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "show ?case"], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "case Proc_CFG_Call"], ["proof (state)\nthis:\n  Call p es rets \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -IEdge\n                                et\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n       False", "from \\<open>Call p es rets \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Label 1\\<close>"], ["proof (chain)\npicking this:\n  Call p es rets \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Label 1", "show ?case"], ["proof (prove)\nusing this:\n  Call p es rets \\<turnstile> n'' -IEdge et\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proc_CFG_Call_nodes_eq:\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n  \\<Longrightarrow> n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     prog \\<turnstile> n -CEdge\n                           (p', es',\n                            rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n    \\<Longrightarrow> n' = n'' \\<and>\n                      p = p' \\<and> es = es' \\<and> rets = rets'", "proof(induct prog n \"CEdge (p,es,rets)\" n' arbitrary:n'' rule:Proc_CFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_SeqFirst c\\<^sub>1 n n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  n' = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n' \\<noteq> Exit\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\n    \\<Longrightarrow> n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  n' = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"c\\<^sub>1 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n -CEdge\n                               (p', es', rets')\\<rightarrow>\\<^sub>p n''", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c\\<^sub>1;;\n             c\\<^sub>2 \\<turnstile> n -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>1 \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n -CEdge\n                                (p', es', rets')\\<rightarrow>\\<^sub>p Exit;\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\n 2. \\<And>n n'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                          (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n = n \\<oplus> #:c\\<^sub>1; n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "apply(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                          (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n = n \\<oplus> #:c\\<^sub>1; n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by(case_tac n,(fastforce dest:Proc_CFG_sourcelabel_less_num_nodes)+)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by (rule IH)"], ["proof (state)\nthis:\n  n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_SeqConnect c\\<^sub>1 n c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c\\<^sub>1 \\<turnstile> n -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  Exit = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "have False"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. Label #:c\\<^sub>1 = n'' \\<and>\n    p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  Label #:c\\<^sub>1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_SeqSecond c\\<^sub>2 n n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> n -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  n' = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\n    \\<Longrightarrow> n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  n' = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<close> \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  n \\<noteq> Entry", "obtain nx where edge:\"c\\<^sub>2 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx\" and nx:\"nx \\<oplus> #:c\\<^sub>1 = n''\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx;\n         nx \\<oplus> #:c\\<^sub>1 = n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p nx;\n                 nx \\<oplus> #:c\\<^sub>1 = n''\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n               (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p nx;\n                 nx \\<oplus> #:c\\<^sub>1 = n''\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n \\<noteq> Entry;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n               (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     n'' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p nx;\n                 nx \\<oplus> #:c\\<^sub>1 = Label #:c\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n \\<noteq> Entry; n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n               (p', es', rets')\\<rightarrow>\\<^sub>p Exit;\n     n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n                 (p', es', rets')\\<rightarrow>\\<^sub>p nx;\n                    nx \\<oplus> #:c\\<^sub>1 =\n                    n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n,auto dest:Proc_CFG_sourcelabel_less_num_nodes label_incr_inj)+"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n  nx \\<oplus> #:c\\<^sub>1 = n''\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from edge"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx", "have \"n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by (rule IH)"], ["proof (state)\nthis:\n  n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "with nx"], ["proof (chain)\npicking this:\n  nx \\<oplus> #:c\\<^sub>1 = n''\n  n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "show ?case"], ["proof (prove)\nusing this:\n  nx \\<oplus> #:c\\<^sub>1 = n''\n  n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (1 subgoal):\n 1. n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n    p = p' \\<and> es = es' \\<and> rets = rets'", "by auto"], ["proof (state)\nthis:\n  n' \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n  p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_CondThen c\\<^sub>1 n n' b c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  n' = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n       (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\n    \\<Longrightarrow> n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  n' = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n       (p', es', rets')\\<rightarrow>\\<^sub>p n''", "obtain nx where \"c\\<^sub>1 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx \\<and> nx \\<oplus> 1 = n''\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n       (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p nx \\<and>\n        nx \\<oplus> 1 = n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(rule Proc_CFG.cases)"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip; n \\<oplus> 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et; n'' = n';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n \\<oplus> #:c\\<^sub>1'; CEdge (p', es', rets') = et;\n        n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>1 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "fix c\\<^sub>2' nx etx nx' bx c\\<^sub>1'"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip; n \\<oplus> 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et; n'' = n';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n \\<oplus> #:c\\<^sub>1'; CEdge (p', es', rets') = et;\n        n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>1 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "assume \"if (b) c\\<^sub>1 else c\\<^sub>2 = if (bx) c\\<^sub>1' else c\\<^sub>2'\"\n      and \"n \\<oplus> 1 = nx \\<oplus> #:c\\<^sub>1' + 1\" and \"nx \\<noteq> Entry\""], ["proof (state)\nthis:\n  if (b) c\\<^sub>1 else c\\<^sub>2 = if (bx) c\\<^sub>1' else c\\<^sub>2'\n  n \\<oplus> 1 = nx \\<oplus> #:c\\<^sub>1' + 1\n  nx \\<noteq> Entry\n\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip; n \\<oplus> 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et; n'' = n';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n \\<oplus> #:c\\<^sub>1'; CEdge (p', es', rets') = et;\n        n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>1 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "with \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  if (b) c\\<^sub>1 else c\\<^sub>2 = if (bx) c\\<^sub>1' else c\\<^sub>2'\n  n \\<oplus> 1 = nx \\<oplus> #:c\\<^sub>1' + 1\n  nx \\<noteq> Entry", "obtain l where \"n = Label l\" and \"l \\<ge> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  if (b) c\\<^sub>1 else c\\<^sub>2 = if (bx) c\\<^sub>1' else c\\<^sub>2'\n  n \\<oplus> 1 = nx \\<oplus> #:c\\<^sub>1' + 1\n  nx \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>n = Label l; #:c\\<^sub>1 \\<le> l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n,auto,cases nx,auto)"], ["proof (state)\nthis:\n  n = Label l\n  #:c\\<^sub>1 \\<le> l\n\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip; n \\<oplus> 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et; n'' = n';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n \\<oplus> #:c\\<^sub>1'; CEdge (p', es', rets') = et;\n        n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>1 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "with \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  #:c\\<^sub>1 \\<le> l", "have False"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n = Label l\n  #:c\\<^sub>1 \\<le> l\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  False\n\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip; n \\<oplus> 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et; n'' = n';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n \\<oplus> #:c\\<^sub>1'; CEdge (p', es', rets') = et;\n        n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>1 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (18 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n \\<oplus> 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip; n \\<oplus> 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n \\<oplus> 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et; n'' = n';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> 1 = n \\<oplus> #:c\\<^sub>1'; CEdge (p', es', rets') = et;\n        n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>1 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 18 subgoals...", "qed (auto dest:label_incr_inj)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> 1 = n''\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> 1 = n''", "obtain nx where edge:\"c\\<^sub>1 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx\" \n    and nx:\"nx \\<oplus> 1 = n''\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> 1 = n''\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx;\n         nx \\<oplus> 1 = n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n  nx \\<oplus> 1 = n''\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from IH[OF edge] nx"], ["proof (chain)\npicking this:\n  n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> 1 = n''", "show ?case"], ["proof (prove)\nusing this:\n  n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> 1 = n''\n\ngoal (1 subgoal):\n 1. n' \\<oplus> 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  n' \\<oplus> 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_CondElse c\\<^sub>2 n n' b c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> n -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  n' = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n   1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\n    \\<Longrightarrow> n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  n' = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 + 1 -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n   1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''", "obtain nx where \"c\\<^sub>2 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx \\<and> nx \\<oplus> #:c\\<^sub>1 + 1 = n''\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n   1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p nx \\<and>\n        nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(rule Proc_CFG.cases)"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip;\n     n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = n'; c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n \\<oplus> #:c\\<^sub>1';\n        CEdge (p', es', rets') = et; n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>2 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "fix c\\<^sub>1' nx etx nx' bx c\\<^sub>2'"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip;\n     n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = n'; c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n \\<oplus> #:c\\<^sub>1';\n        CEdge (p', es', rets') = et; n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>2 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "assume ifs:\"if (b) c\\<^sub>1 else c\\<^sub>2 = if (bx) c\\<^sub>1' else c\\<^sub>2'\"\n      and \"n \\<oplus> #:c\\<^sub>1 + 1 = nx \\<oplus> 1\" and \"nx \\<noteq> Entry\"\n      and edge:\"c\\<^sub>1' \\<turnstile> nx -etx\\<rightarrow>\\<^sub>p nx'\""], ["proof (state)\nthis:\n  if (b) c\\<^sub>1 else c\\<^sub>2 = if (bx) c\\<^sub>1' else c\\<^sub>2'\n  n \\<oplus> #:c\\<^sub>1 + 1 = nx \\<oplus> 1\n  nx \\<noteq> Entry\n  c\\<^sub>1' \\<turnstile> nx -etx\\<rightarrow>\\<^sub>p nx'\n\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip;\n     n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = n'; c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n \\<oplus> #:c\\<^sub>1';\n        CEdge (p', es', rets') = et; n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>2 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "then"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1 else c\\<^sub>2 = if (bx) c\\<^sub>1' else c\\<^sub>2'\n  n \\<oplus> #:c\\<^sub>1 + 1 = nx \\<oplus> 1\n  nx \\<noteq> Entry\n  c\\<^sub>1' \\<turnstile> nx -etx\\<rightarrow>\\<^sub>p nx'", "obtain l where \"nx = Label l\" and \"l \\<ge> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1 else c\\<^sub>2 = if (bx) c\\<^sub>1' else c\\<^sub>2'\n  n \\<oplus> #:c\\<^sub>1 + 1 = nx \\<oplus> 1\n  nx \\<noteq> Entry\n  c\\<^sub>1' \\<turnstile> nx -etx\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>nx = Label l; #:c\\<^sub>1 \\<le> l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n,auto,cases nx,auto)"], ["proof (state)\nthis:\n  nx = Label l\n  #:c\\<^sub>1 \\<le> l\n\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip;\n     n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = n'; c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n \\<oplus> #:c\\<^sub>1';\n        CEdge (p', es', rets') = et; n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>2 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "with edge ifs"], ["proof (chain)\npicking this:\n  c\\<^sub>1' \\<turnstile> nx -etx\\<rightarrow>\\<^sub>p nx'\n  if (b) c\\<^sub>1 else c\\<^sub>2 = if (bx) c\\<^sub>1' else c\\<^sub>2'\n  nx = Label l\n  #:c\\<^sub>1 \\<le> l", "have False"], ["proof (prove)\nusing this:\n  c\\<^sub>1' \\<turnstile> nx -etx\\<rightarrow>\\<^sub>p nx'\n  if (b) c\\<^sub>1 else c\\<^sub>2 = if (bx) c\\<^sub>1' else c\\<^sub>2'\n  nx = Label l\n  #:c\\<^sub>1 \\<le> l\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  False\n\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip;\n     n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = n'; c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n \\<oplus> #:c\\<^sub>1';\n        CEdge (p', es', rets') = et; n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>2 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (18 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Entry;\n        CEdge (p', es', rets') = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n'' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip;\n     n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n     CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e;\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 1;\n        CEdge (p', es', rets') = IEdge \\<Up>id; n'' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' n et n' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = n'; c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' n et c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n; CEdge (p', es', rets') = et;\n        n'' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' n et n' c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n \\<oplus> #:c\\<^sub>1';\n        CEdge (p', es', rets') = et; n'' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n        CEdge (p', es', rets') =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n'' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>2 \\<turnstile> n -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                    thesis;\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n \\<oplus> #:c\\<^sub>1 + 1 = Label 0;\n         CEdge (p', es', rets') =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n'' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 18 subgoals...", "qed (auto dest:label_incr_inj)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''", "obtain nx where edge:\"c\\<^sub>2 \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx\"\n    and nx:\"nx \\<oplus> #:c\\<^sub>1 + 1 = n''\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx;\n         nx \\<oplus> #:c\\<^sub>1 + 1 = n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from IH[OF edge] nx"], ["proof (chain)\npicking this:\n  n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''", "show ?case"], ["proof (prove)\nusing this:\n  n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''\n\ngoal (1 subgoal):\n 1. n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n    p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  n' \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n  p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_WhileBody c' n n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c' \\<turnstile> n -CEdge\n                      (p', es',\n                       rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  n' = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "note IH = \\<open>\\<And>n''. c' \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\n    \\<Longrightarrow> n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge\n                      (p', es',\n                       rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  n' = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p n''", "obtain nx where \"c' \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx \\<and> nx \\<oplus> 2 = n''\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c' \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n        nx \\<oplus> 2 = n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(rule Proc_CFG.cases,auto dest:label_incr_inj Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> 2 = n''\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "then"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> 2 = n''", "obtain nx where edge:\"c' \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx\" \n    and nx:\"nx \\<oplus> 2 = n''\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> 2 = n''\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>c' \\<turnstile> n -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p nx;\n         nx \\<oplus> 2 = n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n  nx \\<oplus> 2 = n''\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           n' = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> n' \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from IH[OF edge] nx"], ["proof (chain)\npicking this:\n  n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> 2 = n''", "show ?case"], ["proof (prove)\nusing this:\n  n' = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> 2 = n''\n\ngoal (1 subgoal):\n 1. n' \\<oplus> 2 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  n' \\<oplus> 2 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_WhileBodyExit c' n b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c' \\<turnstile> n -CEdge\n                      (p', es',\n                       rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  Exit = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n     (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>c' \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "have False"], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           Exit = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> Label 0 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case Proc_CFG_Call"], ["proof (state)\nthis:\n  Call p es\n   rets \\<turnstile> Label\n                      0 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>Call p es rets \\<turnstile> Label 0 -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<close>"], ["proof (chain)\npicking this:\n  Call p es\n   rets \\<turnstile> Label\n                      0 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''", "have \"p = p' \\<and> es = es' \\<and> rets = rets' \\<and> n'' = Label 1\""], ["proof (prove)\nusing this:\n  Call p es\n   rets \\<turnstile> Label\n                      0 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. p = p' \\<and> es = es' \\<and> rets = rets' \\<and> n'' = Label 1", "by(auto elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  p = p' \\<and> es = es' \\<and> rets = rets' \\<and> n'' = Label 1\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "then"], ["proof (chain)\npicking this:\n  p = p' \\<and> es = es' \\<and> rets = rets' \\<and> n'' = Label 1", "show ?case"], ["proof (prove)\nusing this:\n  p = p' \\<and> es = es' \\<and> rets = rets' \\<and> n'' = Label 1\n\ngoal (1 subgoal):\n 1. Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  Label 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proc_CFG_Call_nodes_eq':\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n  \\<Longrightarrow> n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     prog \\<turnstile> n'' -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> n = n'' \\<and>\n                      p = p' \\<and> es = es' \\<and> rets = rets'", "proof(induct prog n \"CEdge (p,es,rets)\" n' arbitrary:n'' rule:Proc_CFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_SeqFirst c\\<^sub>1 n n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> ?n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n' \\<noteq> Exit\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\n    \\<Longrightarrow> n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> ?n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"c\\<^sub>1 \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n'' -CEdge\n                                 (p', es', rets')\\<rightarrow>\\<^sub>p n'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c\\<^sub>1;;\n             c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n';\n     c\\<^sub>1 \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n'", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1;\n     n' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n'' -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p Exit;\n     n'' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n'' -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\n 2. \\<And>n n'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1;\n        n'' = n \\<oplus> #:c\\<^sub>1; n' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "apply(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1;\n        n'' = n \\<oplus> #:c\\<^sub>1; n' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by(case_tac n',auto dest:Proc_CFG_targetlabel_less_num_nodes Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n'' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n'' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n'' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by (rule IH)"], ["proof (state)\nthis:\n  n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_SeqConnect c\\<^sub>1 n c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c\\<^sub>1 \\<turnstile> ?n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p Label\n                       #:c\\<^sub>1\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "have False"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_SeqSecond c\\<^sub>2 n n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> ?n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\n    \\<Longrightarrow> n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> ?n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "obtain nx where edge:\"c\\<^sub>2 \\<turnstile> nx -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\" and nx:\"nx \\<oplus> #:c\\<^sub>1 = n''\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n'' -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> nx -CEdge\n       (p', es', rets')\\<rightarrow>\\<^sub>p n';\n         nx \\<oplus> #:c\\<^sub>1 = n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                \\<lbrakk>c\\<^sub>2 \\<turnstile> nx -CEdge\n               (p', es', rets')\\<rightarrow>\\<^sub>p n';\n                 nx \\<oplus> #:c\\<^sub>1 = n''\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                \\<lbrakk>c\\<^sub>2 \\<turnstile> nx -CEdge\n               (p', es', rets')\\<rightarrow>\\<^sub>p n';\n                 nx \\<oplus> #:c\\<^sub>1 = n''\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     c\\<^sub>1 \\<turnstile> n'' -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                \\<lbrakk>c\\<^sub>2 \\<turnstile> nx -CEdge\n               (p', es', rets')\\<rightarrow>\\<^sub>p n';\n                 nx \\<oplus> #:c\\<^sub>1 = n''\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     n' \\<oplus> #:c\\<^sub>1 = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n'' -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p Exit;\n     n'' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   \\<lbrakk>c\\<^sub>2 \\<turnstile> nx -CEdge\n                  (p', es', rets')\\<rightarrow>\\<^sub>p n';\n                    nx \\<oplus> #:c\\<^sub>1 =\n                    n \\<oplus> #:c\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        n'' = n \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n',\n       auto dest:Proc_CFG_targetlabel_less_num_nodes Proc_CFG_Call_Labels \n                 label_incr_inj)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  nx \\<oplus> #:c\\<^sub>1 = n''\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from edge"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'", "have \"n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by (rule IH)"], ["proof (state)\nthis:\n  n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "with nx"], ["proof (chain)\npicking this:\n  nx \\<oplus> #:c\\<^sub>1 = n''\n  n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "show ?case"], ["proof (prove)\nusing this:\n  nx \\<oplus> #:c\\<^sub>1 = n''\n  n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (1 subgoal):\n 1. n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n    p = p' \\<and> es = es' \\<and> rets = rets'", "by auto"], ["proof (state)\nthis:\n  n \\<oplus> #:c\\<^sub>1 = n'' \\<and>\n  p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_CondThen c\\<^sub>1 n n' b c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> ?n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\n    \\<Longrightarrow> n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> ?n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1", "obtain nx where \"c\\<^sub>1 \\<turnstile> nx -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n' \\<and> nx \\<oplus> 1 = n''\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> nx -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n' \\<and>\n        nx \\<oplus> 1 = n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> 1; n' \\<oplus> 1 = n' \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> 1 = n' \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Proc_CFG_CondElse nx nx')"], ["proof (state)\nthis:\n  n'' = nx \\<oplus> #:c\\<^sub>1 + 1\n  n' \\<oplus> 1 = nx' \\<oplus> #:c\\<^sub>1 + 1\n  c\\<^sub>2 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> 1; n' \\<oplus> 1 = n' \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> 1 = n' \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "from \\<open>n' \\<oplus> 1 = nx' \\<oplus> #:c\\<^sub>1 + 1\\<close>\n      \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  n' \\<oplus> 1 = nx' \\<oplus> #:c\\<^sub>1 + 1\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "obtain l where \"n' = Label l\" and \"l \\<ge> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  n' \\<oplus> 1 = nx' \\<oplus> #:c\\<^sub>1 + 1\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>n' = Label l; #:c\\<^sub>1 \\<le> l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n', auto dest:Proc_CFG_Call_Labels,cases nx',auto)"], ["proof (state)\nthis:\n  n' = Label l\n  #:c\\<^sub>1 \\<le> l\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> 1; n' \\<oplus> 1 = n' \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> 1 = n' \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n' = Label l\n  #:c\\<^sub>1 \\<le> l", "have False"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n' = Label l\n  #:c\\<^sub>1 \\<le> l\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> 1; n' \\<oplus> 1 = n' \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> 1 = n' \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> 1; n' \\<oplus> 1 = n' \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed (auto dest:label_incr_inj)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> nx -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p n' \\<and>\n  nx \\<oplus> 1 = n''\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> nx -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p n' \\<and>\n  nx \\<oplus> 1 = n''", "obtain nx where edge:\"c\\<^sub>1 \\<turnstile> nx -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\" \n    and nx:\"nx \\<oplus> 1 = n''\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> nx -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p n' \\<and>\n  nx \\<oplus> 1 = n''\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> nx -CEdge\n       (p', es', rets')\\<rightarrow>\\<^sub>p n';\n         nx \\<oplus> 1 = n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  nx \\<oplus> 1 = n''\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from IH[OF edge] nx"], ["proof (chain)\npicking this:\n  n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> 1 = n''", "show ?case"], ["proof (prove)\nusing this:\n  n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> 1 = n''\n\ngoal (1 subgoal):\n 1. n \\<oplus> 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  n \\<oplus> 1 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_CondElse c\\<^sub>2 n n' b c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> ?n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 +\n 1\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\n    \\<Longrightarrow> n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> ?n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 +\n 1", "obtain nx where \"c\\<^sub>2 \\<turnstile> nx -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n' \\<and> nx \\<oplus> #:c\\<^sub>1 + 1 = n''\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n'' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 +\n 1\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> nx -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n' \\<and>\n        nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> 1; n' \\<oplus> #:c\\<^sub>1 + 1 = n' \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = n' \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Proc_CFG_CondThen nx nx')"], ["proof (state)\nthis:\n  n'' = nx \\<oplus> 1\n  n' \\<oplus> #:c\\<^sub>1 + 1 = nx' \\<oplus> 1\n  c\\<^sub>1 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\n  nx \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> 1; n' \\<oplus> #:c\\<^sub>1 + 1 = n' \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = n' \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "from \\<open>n' \\<oplus> #:c\\<^sub>1 + 1 = nx' \\<oplus> 1\\<close>\n      \\<open>c\\<^sub>1 \\<turnstile> nx -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  n' \\<oplus> #:c\\<^sub>1 + 1 = nx' \\<oplus> 1\n  c\\<^sub>1 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'", "obtain l where \"nx' = Label l\" and \"l \\<ge> #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  n' \\<oplus> #:c\\<^sub>1 + 1 = nx' \\<oplus> 1\n  c\\<^sub>1 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>nx' = Label l; #:c\\<^sub>1 \\<le> l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases n',auto,cases nx',auto dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  nx' = Label l\n  #:c\\<^sub>1 \\<le> l\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> 1; n' \\<oplus> #:c\\<^sub>1 + 1 = n' \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = n' \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \\<open>c\\<^sub>1 \\<turnstile> nx -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\n  nx' = Label l\n  #:c\\<^sub>1 \\<le> l", "have False"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx'\n  nx' = Label l\n  #:c\\<^sub>1 \\<le> l\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> 1; n' \\<oplus> #:c\\<^sub>1 + 1 = n' \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = n' \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> nx -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<Longrightarrow>\n                   thesis;\n        n'' = n \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> #:c\\<^sub>1 + 1 = n' \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed (auto dest:label_incr_inj)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> nx -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p n' \\<and>\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> nx -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p n' \\<and>\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''", "obtain nx where edge:\"c\\<^sub>2 \\<turnstile> nx -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\" \n    and nx:\"nx \\<oplus> #:c\\<^sub>1 + 1 = n''\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> nx -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p n' \\<and>\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> nx -CEdge\n       (p', es', rets')\\<rightarrow>\\<^sub>p n';\n         nx \\<oplus> #:c\\<^sub>1 + 1 = n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n'' -CEdge\n    (p', es',\n     rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from IH[OF edge] nx"], ["proof (chain)\npicking this:\n  n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''", "show ?case"], ["proof (prove)\nusing this:\n  n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> #:c\\<^sub>1 + 1 = n''\n\ngoal (1 subgoal):\n 1. n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n    p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  n \\<oplus> #:c\\<^sub>1 + 1 = n'' \\<and>\n  p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_WhileBody c' n n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c' \\<turnstile> ?n'' -CEdge\n                         (p', es',\n                          rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  while (b) c' \\<turnstile> n'' -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "note IH = \\<open>\\<And>n''. c' \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\n    \\<Longrightarrow> n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> ?n'' -CEdge\n                         (p', es',\n                          rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>while (b) c' \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n'' -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2", "obtain nx where edge:\"c' \\<turnstile> nx -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'\" and nx:\"nx \\<oplus> 2 = n''\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n'' -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        \\<lbrakk>c' \\<turnstile> nx -CEdge\n(p', es', rets')\\<rightarrow>\\<^sub>p n';\n         nx \\<oplus> 2 = n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule Proc_CFG.cases,auto dest:label_incr_inj)"], ["proof (state)\nthis:\n  c' \\<turnstile> nx -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'\n  nx \\<oplus> 2 = n''\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from IH[OF edge] nx"], ["proof (chain)\npicking this:\n  n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> 2 = n''", "show ?case"], ["proof (prove)\nusing this:\n  n = nx \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  nx \\<oplus> 2 = n''\n\ngoal (1 subgoal):\n 1. n \\<oplus> 2 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  n \\<oplus> 2 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case (Proc_CFG_WhileBodyExit c' n b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c' \\<turnstile> ?n'' -CEdge\n                         (p', es',\n                          rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n  n = ?n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n  n \\<noteq> Entry\n  while (b) c' \\<turnstile> n'' -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p Label 0\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>c' \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "have False"], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> n'' -CEdge\n                                 (p', es',\n                                  rets')\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n           n = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n'' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p Label 0\\<rbrakk>\n       \\<Longrightarrow> n \\<oplus> 2 = n'' \\<and>\n                         p = p' \\<and> es = es' \\<and> rets = rets'\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n \\<oplus> 2 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  n \\<oplus> 2 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "case Proc_CFG_Call"], ["proof (state)\nthis:\n  Call p es\n   rets \\<turnstile> n'' -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "from \\<open>Call p es rets \\<turnstile> n'' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p Label 1\\<close>"], ["proof (chain)\npicking this:\n  Call p es\n   rets \\<turnstile> n'' -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label 1", "have \"p = p' \\<and> es = es' \\<and> rets = rets' \\<and> n'' = Label 0\""], ["proof (prove)\nusing this:\n  Call p es\n   rets \\<turnstile> n'' -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. p = p' \\<and> es = es' \\<and> rets = rets' \\<and> n'' = Label 0", "by(auto elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  p = p' \\<and> es = es' \\<and> rets = rets' \\<and> n'' = Label 0\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> n'' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p Label\n                        1 \\<Longrightarrow>\n       Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "then"], ["proof (chain)\npicking this:\n  p = p' \\<and> es = es' \\<and> rets = rets' \\<and> n'' = Label 0", "show ?case"], ["proof (prove)\nusing this:\n  p = p' \\<and> es = es' \\<and> rets = rets' \\<and> n'' = Label 0\n\ngoal (1 subgoal):\n 1. Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'", "by simp"], ["proof (state)\nthis:\n  Label 0 = n'' \\<and> p = p' \\<and> es = es' \\<and> rets = rets'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proc_CFG_Call_targetnode_no_Call_sourcenode:\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk> \n  \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     prog \\<turnstile> n' -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n    \\<Longrightarrow> False", "proof(induct prog n \"CEdge (p,es,rets)\" n' arbitrary:n'' rule:Proc_CFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -CEdge\n   (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_SeqFirst c\\<^sub>1 n n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n' -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n' \\<noteq> Exit\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -CEdge\n   (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n' -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -CEdge\n   (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "have \"c\\<^sub>1 \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n''\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n' -CEdge\n                                (p', es', rets')\\<rightarrow>\\<^sub>p n''", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c\\<^sub>1;;\n             c\\<^sub>2 \\<turnstile> n' -CEdge\n   (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>1 \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n' -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n  (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n' -CEdge\n                                 (p', es', rets')\\<rightarrow>\\<^sub>p Exit;\n     n' \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n' -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\n 2. \\<And>n n'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n \\<oplus> #:c\\<^sub>1;\n        n' = n \\<oplus> #:c\\<^sub>1; n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "apply(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n \\<oplus> #:c\\<^sub>1;\n        n' = n \\<oplus> #:c\\<^sub>1; n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -CEdge\n                                   (p', es',\n                                    rets')\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1", "by(case_tac n)(auto dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -CEdge\n   (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -CEdge\n   (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -CEdge\n   (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_SeqConnect c\\<^sub>1 n c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c\\<^sub>1 \\<turnstile> Exit -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          #:c\\<^sub>1 -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -CEdge\n   (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "have False"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -CEdge\n   (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_SeqSecond c\\<^sub>2 n n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> n' -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n' -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "obtain nx where \"c\\<^sub>2 \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n             (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> n' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>2 \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     n'' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                (p', es', rets')\\<rightarrow>\\<^sub>p Exit;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n        n'' \\<noteq> Exit; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     n'' \\<noteq> Exit; n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     n'' \\<noteq> Exit; n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                (p', es', rets')\\<rightarrow>\\<^sub>p Exit;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                (p', es', rets')\\<rightarrow>\\<^sub>p Exit;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n',auto,case_tac n,auto)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -CEdge\n                   (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_CondThen c\\<^sub>1 n n' b c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n' -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n' -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "obtain nx where \"c\\<^sub>1 \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n        (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> n' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n' -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n           (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>1 \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc x1) = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc x1) = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc x1) = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc x1) = n \\<oplus> Suc 0; n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc x1) = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n)(auto dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -CEdge\n              (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_CondElse c\\<^sub>2 n n' b c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> n' -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n    1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n' -CEdge\n                              (p', es',\n                               rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 + 1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<close> \n    \\<open>c\\<^sub>2 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n    1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "obtain nx where \"c\\<^sub>2 \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n    1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> n' -CEdge\n                                    (p', es',\n                                     rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n       1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>2 \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n',auto,case_tac n,auto)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_WhileBody c' n n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c' \\<turnstile> n' -CEdge\n                       (p', es',\n                        rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "note IH = \\<open>\\<And>n''. c' \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> False\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> n' -CEdge\n                       (p', es',\n                        rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c' \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "obtain nx where \"c' \\<turnstile> n' -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n      (p', es', rets')\\<rightarrow>\\<^sub>p n''\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c' \\<turnstile> n' -CEdge\n                             (p', es',\n                              rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n' -CEdge\n                                     (p', es',\nrets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n         (p', es', rets')\\<rightarrow>\\<^sub>p n'';\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -CEdge\n  (p', es', rets')\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = Label 0;\n        c' \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n',auto,case_tac n,auto)+"], ["proof (state)\nthis:\n  c' \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -CEdge\n            (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "then"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c' \\<turnstile> n' -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. False", "by (rule IH)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case (Proc_CFG_WhileBodyExit c' n b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c' \\<turnstile> Exit -CEdge\n                         (p', es',\n                          rets')\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  False\n  n \\<noteq> Entry\n  while (b) c' \\<turnstile> Label\n                             0 -CEdge\n                                 (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -CEdge\n                                  (p', es',\n                                   rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           False;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -CEdge\n (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "show ?case"], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "case Proc_CFG_Call"], ["proof (state)\nthis:\n  Call p es\n   rets \\<turnstile> Label\n                      1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -CEdge\n                               (p', es',\n                                rets')\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       False", "from \\<open>Call p es rets \\<turnstile> Label 1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\\<close>"], ["proof (chain)\npicking this:\n  Call p es\n   rets \\<turnstile> Label\n                      1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''", "show ?case"], ["proof (prove)\nusing this:\n  Call p es\n   rets \\<turnstile> Label\n                      1 -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proc_CFG_Call_follows_id_edge:\n  \"\\<lbrakk>prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk> \\<Longrightarrow> et = \\<Up>id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     prog \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n    \\<Longrightarrow> et = \\<Up>id", "proof(induct prog n \"CEdge (p,es,rets)\" n' arbitrary:n'' rule:Proc_CFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' -IEdge\n                                    et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -IEdge\n        et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "case (Proc_CFG_SeqFirst c\\<^sub>1 n n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n' -IEdge\n                              et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n  n' \\<noteq> Exit\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' -IEdge\n                                    et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -IEdge\n        et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> et = \\<Up>id\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n' -IEdge\n                              et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' -IEdge\n                                    et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -IEdge\n        et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit", "obtain nx where \"c\\<^sub>1 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> n' -IEdge\n                                    et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -IEdge\n                             et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p n \\<oplus> #:c\\<^sub>1;\n        n \\<oplus> #:c\\<^sub>1 \\<noteq> Exit; n' = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n)(auto dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>1 n n' c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' -IEdge\n                                    et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -IEdge\n        et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 7. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 8. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. et = \\<Up>id", "by (rule IH)"], ["proof (state)\nthis:\n  et = \\<Up>id\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -IEdge\n        et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -IEdge\n        et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "case (Proc_CFG_SeqConnect c\\<^sub>1 n c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c\\<^sub>1 \\<turnstile> Exit -IEdge\n                                et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> Label\n                          #:c\\<^sub>1 -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (7 subgoals):\n 1. \\<And>c\\<^sub>1 n c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> Label\n                                #:c\\<^sub>1 -IEdge\n        et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 7. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "from \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. et = \\<Up>id", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  et = \\<Up>id\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "case (Proc_CFG_SeqSecond c\\<^sub>2 n n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> n' -IEdge\n                              et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> et = \\<Up>id\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n' -IEdge\n                              et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "obtain nx where \"c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n             et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> n' -IEdge\n                                    et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                et\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>2 \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                et\\<rightarrow>\\<^sub>p n'';\n     n'' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                et\\<rightarrow>\\<^sub>p Exit;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n'';\n        n'' \\<noteq> Exit; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                et\\<rightarrow>\\<^sub>p n'';\n     n'' \\<noteq> Exit; n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                et\\<rightarrow>\\<^sub>p n'';\n     n'' \\<noteq> Exit; n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                et\\<rightarrow>\\<^sub>p Exit;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 5. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                et\\<rightarrow>\\<^sub>p Exit;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n'' = Label #:c\\<^sub>1;\n        c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p Exit;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                et\\<rightarrow>\\<^sub>p Exit;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Entry; n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n'' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                et\\<rightarrow>\\<^sub>p Exit;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Entry; n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> #:c\\<^sub>1 = n \\<oplus> #:c\\<^sub>1;\n        n'' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n',auto,case_tac n,auto)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (6 subgoals):\n 1. \\<And>c\\<^sub>2 n n' c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 -IEdge\n                   et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 6. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. et = \\<Up>id", "by (rule IH)"], ["proof (state)\nthis:\n  et = \\<Up>id\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "case (Proc_CFG_CondThen c\\<^sub>1 n n' b c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n' -IEdge\n                              et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n        et\\<rightarrow>\\<^sub>p n''\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "note IH = \\<open>\\<And>n''. c\\<^sub>1 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> et = \\<Up>id\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n' -IEdge\n                              et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>\n    \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n        et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain nx where \"c\\<^sub>1 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n        et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> n' -IEdge\n                                    et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n           et\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>1 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; Label (Suc x1) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; Label (Suc x1) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; Label (Suc x1) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; Label (Suc x1) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> Suc 0 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        n \\<noteq> Entry; Label (Suc x1) = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac n)(auto dest:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (5 subgoals):\n 1. \\<And>c\\<^sub>1 n n' b c\\<^sub>2 n''.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>1 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> 1 -IEdge\n              et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 5. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. et = \\<Up>id", "by (rule IH)"], ["proof (state)\nthis:\n  et = \\<Up>id\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "case (Proc_CFG_CondElse c\\<^sub>2 n n' b c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> n' -IEdge\n                              et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n    1 -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "note IH = \\<open>\\<And>n''. c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> et = \\<Up>id\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n' -IEdge\n                              et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 + 1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n    1 -IEdge et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "obtain nx where \"c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n    1 -IEdge et\\<rightarrow>\\<^sub>p n''\n  c\\<^sub>2 \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> n' -IEdge\n                                    et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n' -IEdge\n      et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n       1 -IEdge et\\<rightarrow>\\<^sub>p n'';\n     c\\<^sub>2 \\<turnstile> n -CEdge\n                                (p, es,\n                                 rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> Label\n     x1 -IEdge et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (x1 + #:c\\<^sub>1)) = n \\<oplus> Suc 0;\n        n'' = n' \\<oplus> Suc 0;\n        c\\<^sub>1 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' = Label x1; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n' -IEdge\n         et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -CEdge\n                                   (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> Suc #:c\\<^sub>1 = n \\<oplus> Suc #:c\\<^sub>1;\n        n'' = n' \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n',auto,case_tac n,auto)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>2 n n' b c\\<^sub>1 n''.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -CEdge\n     (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c\\<^sub>2 \\<turnstile> n' -IEdge\n et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n' \\<oplus> #:c\\<^sub>1 +\n          1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 4. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "then"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. et = \\<Up>id", "by (rule IH)"], ["proof (state)\nthis:\n  et = \\<Up>id\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "case (Proc_CFG_WhileBody c' n n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  c' \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "note IH = \\<open>\\<And>n''. c' \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow> et = \\<Up>id\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "from \\<open>while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge et\\<rightarrow>\\<^sub>p n''\\<close> \\<open>c' \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge et\\<rightarrow>\\<^sub>p n''\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "obtain nx where \"c' \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge et\\<rightarrow>\\<^sub>p n''\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c' \\<turnstile> n' -IEdge\n                             et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n' -IEdge\n                                     et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n         et\\<rightarrow>\\<^sub>p n'';\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n' -IEdge\n                                     \\<Up>id\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n' \\<oplus> 2 = Label (Suc 0); et = \\<Up>id; n'' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  \\<Up>id\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = Label (Suc 0); et = \\<Up>id; n'' = Exit;\n        n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n' -IEdge\n                                     \\<Up>id\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n' \\<oplus> 2 = Label (Suc 0); et = \\<Up>id; n'' = Exit;\n     n' = Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n' -IEdge\n                                     \\<Up>id\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n     n' \\<oplus> 2 = Label (Suc 0); et = \\<Up>id; n'' = Exit;\n     n' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n' = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> Label\n                                    x1 -IEdge\n   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (Suc x1)) = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n' = Label x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n n' x1 x1a.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> Label\n                                    x1 -IEdge\n   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (Suc x1)) = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n' = Label x1;\n        n = Label x1a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> Label\n                                    x1 -IEdge\n   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (Suc x1)) = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n' = Label x1;\n        n = Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n n' x1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> Label\n                                    x1 -IEdge\n   et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p Label x1;\n        Label (Suc (Suc x1)) = n \\<oplus> 2; n'' = n' \\<oplus> 2;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<noteq> Exit; n' = Label x1; n = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n' -IEdge\n  et\\<rightarrow>\\<^sub>p nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        n' \\<oplus> 2 = n \\<oplus> 2; n'' = Label 0;\n        c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(cases n',auto,case_tac n,auto)"], ["proof (state)\nthis:\n  c' \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (3 subgoals):\n 1. \\<And>c' n n' b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        \\<And>n''.\n           c' \\<turnstile> n' -IEdge\n                                et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n' \\<oplus> 2 -IEdge\n            et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 3. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "then"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx", "show ?case"], ["proof (prove)\nusing this:\n  c' \\<turnstile> n' -IEdge et\\<rightarrow>\\<^sub>p nx\n\ngoal (1 subgoal):\n 1. et = \\<Up>id", "by (rule IH)"], ["proof (state)\nthis:\n  et = \\<Up>id\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "case (Proc_CFG_WhileBodyExit c' n et' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n  c' \\<turnstile> Exit -IEdge et\\<rightarrow>\\<^sub>p ?n'' \\<Longrightarrow>\n  et = \\<Up>id\n  n \\<noteq> Entry\n  while (et') c' \\<turnstile> Label 0 -IEdge et\\<rightarrow>\\<^sub>p b\n\ngoal (2 subgoals):\n 1. \\<And>c' n b n''.\n       \\<lbrakk>c' \\<turnstile> n -CEdge\n                                    (p, es, rets)\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n''.\n           c' \\<turnstile> Exit -IEdge\n                                  et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n           et = \\<Up>id;\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> Label\n                                   0 -IEdge\n et\\<rightarrow>\\<^sub>p n''\\<rbrakk>\n       \\<Longrightarrow> et = \\<Up>id\n 2. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "from \\<open>c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit", "show ?case"], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. et = \\<Up>id", "by(fastforce dest:Proc_CFG_Call_Labels)"], ["proof (state)\nthis:\n  et = \\<Up>id\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "case Proc_CFG_Call"], ["proof (state)\nthis:\n  Call p es rets \\<turnstile> Label 1 -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. \\<And>n''.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -IEdge\n                               et\\<rightarrow>\\<^sub>p n'' \\<Longrightarrow>\n       et = \\<Up>id", "from \\<open>Call p es rets \\<turnstile> Label 1 -IEdge et\\<rightarrow>\\<^sub>p n''\\<close>"], ["proof (chain)\npicking this:\n  Call p es rets \\<turnstile> Label 1 -IEdge et\\<rightarrow>\\<^sub>p n''", "show ?case"], ["proof (prove)\nusing this:\n  Call p es rets \\<turnstile> Label 1 -IEdge et\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. et = \\<Up>id", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  et = \\<Up>id\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proc_CFG_edge_det:\n  \"\\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; prog \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk> \\<Longrightarrow> et = et'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     prog \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> et = et'", "proof(induct rule:Proc_CFG.induct)"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       prog \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 2. \\<And>prog.\n       prog \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Label\n                    0 \\<Longrightarrow>\n       IEdge (\\<lambda>s. True)\\<^sub>\\<surd> = et'\n 3. Skip \\<turnstile> Label\n                       0 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n    IEdge \\<Up>id = et'\n 4. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 5. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 10. \\<And>b c\\<^sub>1 c\\<^sub>2.\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     0 -et'\\<rightarrow>\\<^sub>p Label\n                            (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n        IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n        et'\nA total of 19 subgoals...", "case Proc_CFG_Entry_Exit"], ["proof (state)\nthis:\n  prog_ \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (19 subgoals):\n 1. \\<And>prog.\n       prog \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 2. \\<And>prog.\n       prog \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Label\n                    0 \\<Longrightarrow>\n       IEdge (\\<lambda>s. True)\\<^sub>\\<surd> = et'\n 3. Skip \\<turnstile> Label\n                       0 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n    IEdge \\<Up>id = et'\n 4. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 5. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 10. \\<And>b c\\<^sub>1 c\\<^sub>2.\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> Label\n                                     0 -et'\\<rightarrow>\\<^sub>p Label\n                            (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n        IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n        et'\nA total of 19 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  prog_ \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. IEdge (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "by(fastforce dest:Proc_CFG_EntryD)"], ["proof (state)\nthis:\n  IEdge (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n\ngoal (18 subgoals):\n 1. \\<And>prog.\n       prog \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Label\n                    0 \\<Longrightarrow>\n       IEdge (\\<lambda>s. True)\\<^sub>\\<surd> = et'\n 2. Skip \\<turnstile> Label\n                       0 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n    IEdge \\<Up>id = et'\n 3. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 4. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>prog.\n       prog \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Label\n                    0 \\<Longrightarrow>\n       IEdge (\\<lambda>s. True)\\<^sub>\\<surd> = et'\n 2. Skip \\<turnstile> Label\n                       0 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n    IEdge \\<Up>id = et'\n 3. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 4. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 18 subgoals...", "case Proc_CFG_Entry"], ["proof (state)\nthis:\n  prog_ \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Label 0\n\ngoal (18 subgoals):\n 1. \\<And>prog.\n       prog \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Label\n                    0 \\<Longrightarrow>\n       IEdge (\\<lambda>s. True)\\<^sub>\\<surd> = et'\n 2. Skip \\<turnstile> Label\n                       0 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n    IEdge \\<Up>id = et'\n 3. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 4. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 18 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  prog_ \\<turnstile> Entry -et'\\<rightarrow>\\<^sub>p Label 0\n\ngoal (1 subgoal):\n 1. IEdge (\\<lambda>s. True)\\<^sub>\\<surd> = et'", "by(fastforce dest:Proc_CFG_EntryD)"], ["proof (state)\nthis:\n  IEdge (\\<lambda>s. True)\\<^sub>\\<surd> = et'\n\ngoal (17 subgoals):\n 1. Skip \\<turnstile> Label\n                       0 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n    IEdge \\<Up>id = et'\n 2. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 3. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 4. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n          1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. Skip \\<turnstile> Label\n                       0 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n    IEdge \\<Up>id = et'\n 2. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 3. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 4. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n          1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 17 subgoals...", "case Proc_CFG_Skip"], ["proof (state)\nthis:\n  Skip \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (17 subgoals):\n 1. Skip \\<turnstile> Label\n                       0 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n    IEdge \\<Up>id = et'\n 2. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 3. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 4. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n          1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 17 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  Skip \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. IEdge \\<Up>id = et'", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  IEdge \\<Up>id = et'\n\ngoal (16 subgoals):\n 1. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 2. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 3. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   0 -et'\\<rightarrow>\\<^sub>p Label\n                          2 \\<Longrightarrow>\n        IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> =\n        et'\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 2. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 3. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   0 -et'\\<rightarrow>\\<^sub>p Label\n                          2 \\<Longrightarrow>\n        IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> =\n        et'\nA total of 16 subgoals...", "case Proc_CFG_LAss"], ["proof (state)\nthis:\n  V_:=e_ \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Label 1\n\ngoal (16 subgoals):\n 1. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          0 -et'\\<rightarrow>\\<^sub>p Label\n                 1 \\<Longrightarrow>\n       IEdge \\<Up>\\<lambda>cf. update cf V e = et'\n 2. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 3. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   0 -et'\\<rightarrow>\\<^sub>p Label\n                          2 \\<Longrightarrow>\n        IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> =\n        et'\nA total of 16 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  V_:=e_ \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. IEdge \\<Up>\\<lambda>cf. update cf V_ e_ = et'", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  IEdge \\<Up>\\<lambda>cf. update cf V_ e_ = et'\n\ngoal (15 subgoals):\n 1. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 2. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   0 -et'\\<rightarrow>\\<^sub>p Label\n                          1 \\<Longrightarrow>\n        IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n        et'\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 2. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   0 -et'\\<rightarrow>\\<^sub>p Label\n                          1 \\<Longrightarrow>\n        IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n        et'\nA total of 15 subgoals...", "case Proc_CFG_LAssSkip"], ["proof (state)\nthis:\n  V_:=e_ \\<turnstile> Label 1 -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (15 subgoals):\n 1. \\<And>V e.\n       V:=e \\<turnstile> Label\n                          1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 2. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   0 -et'\\<rightarrow>\\<^sub>p Label\n                          1 \\<Longrightarrow>\n        IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n        et'\nA total of 15 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  V_:=e_ \\<turnstile> Label 1 -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. IEdge \\<Up>id = et'", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  IEdge \\<Up>id = et'\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'\nA total of 14 subgoals...", "case (Proc_CFG_SeqFirst c\\<^sub>1 n et n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  et = et'\n  n' \\<noteq> Exit\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'\nA total of 14 subgoals...", "note edge = \\<open>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'\nA total of 14 subgoals...", "note IH = \\<open>c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> et = et'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  et = et'\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'\nA total of 14 subgoals...", "from edge \\<open>n' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit", "obtain l where l:\"n' = Label l\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. (\\<And>l. n' = Label l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases n') auto"], ["proof (state)\nthis:\n  n' = Label l\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'\nA total of 14 subgoals...", "with edge"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' = Label l", "have \"l < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' = Label l\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'\nA total of 14 subgoals...", "with \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<close> l"], ["proof (chain)\npicking this:\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n' = Label l\n  l < #:c\\<^sub>1", "have \"c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;; c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n  n' = Label l\n  l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'", "by(fastforce elim:Proc_CFG.cases intro:Proc_CFG.intros dest:label_incr_ge)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 10. \\<And>b c'.\n        while (b) c' \\<turnstile> Label\n                                   1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'\nA total of 14 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  et = et'", "show ?case"], ["proof (prove)\nusing this:\n  et = et'\n\ngoal (1 subgoal):\n 1. et = et'", "."], ["proof (state)\nthis:\n  et = et'\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 13 subgoals...", "case (Proc_CFG_SeqConnect c\\<^sub>1 n et c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n  et = et'\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 13 subgoals...", "note edge = \\<open>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 13 subgoals...", "note IH = \\<open>c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow> et = et'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n  et = et'\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 13 subgoals...", "from edge \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n \\<noteq> Entry", "obtain l where l:\"n = Label l\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>l. n = Label l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) auto"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 13 subgoals...", "with edge"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n = Label l", "have \"l < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n = Label l\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1", "by(fastforce intro: Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 13 subgoals...", "with \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\\<close> l"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\n  n = Label l\n  l < #:c\\<^sub>1", "have \"c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label #:c\\<^sub>1\n  n = Label l\n  l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit", "by(fastforce elim:Proc_CFG.cases \n                dest:Proc_CFG_targetlabel_less_num_nodes label_incr_ge)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Label\n                      #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 9. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 10. \\<And>c' n et n' b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 13 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  et = et'", "show ?case"], ["proof (prove)\nusing this:\n  et = et'\n\ngoal (1 subgoal):\n 1. et = et'", "."], ["proof (state)\nthis:\n  et = et'\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                     0\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                     0\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 12 subgoals...", "case (Proc_CFG_SeqSecond c\\<^sub>2 n et n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  et = et'\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                     0\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 12 subgoals...", "note edge = \\<open>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                     0\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 12 subgoals...", "note IH = \\<open>c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> et = et'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  et = et'\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                     0\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 12 subgoals...", "from edge \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain l where l:\"n = Label l\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>l. n = Label l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) auto"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                     0\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 12 subgoals...", "with edge"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label l", "have \"l < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label l\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>2", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>2\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                     0\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 12 subgoals...", "with \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<close> l"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n  n = Label l\n  l < #:c\\<^sub>2", "have \"c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n  n = Label l\n  l < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'", "by -(erule Proc_CFG.cases,\n    (fastforce dest:Proc_CFG_sourcelabel_less_num_nodes label_incr_ge\n              dest!:label_incr_inj)+)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 8. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 9. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>c' n et b.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n         et = et';\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                     0\\<rbrakk>\n        \\<Longrightarrow> et = et'\nA total of 12 subgoals...", "from IH[OF this]"], ["proof (chain)\npicking this:\n  et = et'", "show ?case"], ["proof (prove)\nusing this:\n  et = et'\n\ngoal (1 subgoal):\n 1. et = et'", "."], ["proof (state)\nthis:\n  et = et'\n\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 3. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 8. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>p es rets.\n        Call p es\n         rets \\<turnstile> Label\n                            0 -et'\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n        CEdge (p, es, rets) = et'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 3. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 8. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>p es rets.\n        Call p es\n         rets \\<turnstile> Label\n                            0 -et'\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n        CEdge (p, es, rets) = et'\nA total of 11 subgoals...", "case Proc_CFG_CondTrue"], ["proof (state)\nthis:\n  if (b_) c\\<^sub>1_\n  else c\\<^sub>2_ \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Label 1\n\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 3. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 7. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 8. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 10. \\<And>p es rets.\n        Call p es\n         rets \\<turnstile> Label\n                            0 -et'\\<rightarrow>\\<^sub>p Label\n                   1 \\<Longrightarrow>\n        CEdge (p, es, rets) = et'\nA total of 11 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  if (b_) c\\<^sub>1_\n  else c\\<^sub>2_ \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. IEdge (\\<lambda>cf. state_check cf b_ (Some true))\\<^sub>\\<surd> = et'", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  IEdge (\\<lambda>cf. state_check cf b_ (Some true))\\<^sub>\\<surd> = et'\n\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 2. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 7. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 10. \\<And>p es rets.\n        Call p es\n         rets \\<turnstile> Label\n                            1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 2. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 7. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 10. \\<And>p es rets.\n        Call p es\n         rets \\<turnstile> Label\n                            1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'", "case Proc_CFG_CondFalse"], ["proof (state)\nthis:\n  if (b_) c\\<^sub>1_\n  else c\\<^sub>2_ \\<turnstile> Label\n                                0 -et'\\<rightarrow>\\<^sub>p Label\n                       (#:c\\<^sub>1_ + 1)\n\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2.\n       if (b) c\\<^sub>1\n       else c\\<^sub>2 \\<turnstile> Label\n                                    0 -et'\\<rightarrow>\\<^sub>p Label\n                           (#:c\\<^sub>1 + 1) \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 2. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 6. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 7. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 10. \\<And>p es rets.\n        Call p es\n         rets \\<turnstile> Label\n                            1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        IEdge \\<Up>id = et'", "thus ?case"], ["proof (prove)\nusing this:\n  if (b_) c\\<^sub>1_\n  else c\\<^sub>2_ \\<turnstile> Label\n                                0 -et'\\<rightarrow>\\<^sub>p Label\n                       (#:c\\<^sub>1_ + 1)\n\ngoal (1 subgoal):\n 1. IEdge (\\<lambda>cf. state_check cf b_ (Some false))\\<^sub>\\<surd> = et'", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  IEdge (\\<lambda>cf. state_check cf b_ (Some false))\\<^sub>\\<surd> = et'\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 6. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 6. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "case (Proc_CFG_CondThen c\\<^sub>1 n et n' b c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  et = et'\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 6. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "note edge = \\<open>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 6. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "note IH = \\<open>c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> et = et'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  et = et'\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 6. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "from edge \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain l where l:\"n = Label l\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>l. n = Label l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) auto"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 6. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "with edge"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label l", "have \"l < #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label l\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>1", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>1\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 6. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "with \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<close> l"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n  n = Label l\n  l < #:c\\<^sub>1", "have \"c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\n  n = Label l\n  l < #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'", "by -(erule Proc_CFG.cases,(fastforce dest:label_incr_ge label_incr_inj)+)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>1 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> 1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 5. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 6. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 9. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  et = et'", "show ?case"], ["proof (prove)\nusing this:\n  et = et'\n\ngoal (1 subgoal):\n 1. et = et'", "."], ["proof (state)\nthis:\n  et = et'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "case (Proc_CFG_CondElse c\\<^sub>2 n et n' b c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  et = et'\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n   1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "note edge = \\<open>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "note IH = \\<open>c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> et = et'\\<close>"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n  et = et'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "from edge \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain l where l:\"n = Label l\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>l. n = Label l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) auto"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "with edge"], ["proof (chain)\npicking this:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label l", "have \"l < #:c\\<^sub>2\""], ["proof (prove)\nusing this:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label l\n\ngoal (1 subgoal):\n 1. l < #:c\\<^sub>2", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c\\<^sub>2\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "with \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n \\<oplus> (#:c\\<^sub>1 + 1) -et'\\<rightarrow>\\<^sub>p n' \\<oplus> (#:c\\<^sub>1 + 1)\\<close> l"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n   1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\n  n = Label l\n  l < #:c\\<^sub>2", "have \"c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n   1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\n  n = Label l\n  l < #:c\\<^sub>2\n\ngoal (1 subgoal):\n 1. c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'", "by -(erule Proc_CFG.cases,(fastforce dest:Proc_CFG_sourcelabel_less_num_nodes \n                             label_incr_inj label_incr_ge label_incr_simp_rev)+)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c\\<^sub>2 \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n \\<oplus> #:c\\<^sub>1 +\n         1 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1 + 1\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 4. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 5. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 8. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  et = et'", "show ?case"], ["proof (prove)\nusing this:\n  et = et'\n\ngoal (1 subgoal):\n 1. et = et'", "."], ["proof (state)\nthis:\n  et = et'\n\ngoal (7 subgoals):\n 1. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 4. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 4. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "case Proc_CFG_WhileTrue"], ["proof (state)\nthis:\n  while (b_) c'_ \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Label 2\n\ngoal (7 subgoals):\n 1. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         2 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> = et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 3. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 4. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 6. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 7. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "thus ?case"], ["proof (prove)\nusing this:\n  while (b_) c'_ \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Label 2\n\ngoal (1 subgoal):\n 1. IEdge (\\<lambda>cf. state_check cf b_ (Some true))\\<^sub>\\<surd> = et'", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  IEdge (\\<lambda>cf. state_check cf b_ (Some true))\\<^sub>\\<surd> = et'\n\ngoal (6 subgoals):\n 1. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 3. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 6. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 3. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 6. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "case Proc_CFG_WhileFalse"], ["proof (state)\nthis:\n  while (b_) c'_ \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Label 1\n\ngoal (6 subgoals):\n 1. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  0 -et'\\<rightarrow>\\<^sub>p Label\n                         1 \\<Longrightarrow>\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       et'\n 2. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 3. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 5. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 6. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "thus ?case"], ["proof (prove)\nusing this:\n  while (b_) c'_ \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. IEdge (\\<lambda>cf. state_check cf b_ (Some false))\\<^sub>\\<surd> = et'", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  IEdge (\\<lambda>cf. state_check cf b_ (Some false))\\<^sub>\\<surd> = et'\n\ngoal (5 subgoals):\n 1. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 2. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 5. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 2. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 5. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "case Proc_CFG_WhileFalseSkip"], ["proof (state)\nthis:\n  while (b_) c'_ \\<turnstile> Label 1 -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (5 subgoals):\n 1. \\<And>b c'.\n       while (b) c' \\<turnstile> Label\n                                  1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'\n 2. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 5. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "thus ?case"], ["proof (prove)\nusing this:\n  while (b_) c'_ \\<turnstile> Label 1 -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. IEdge \\<Up>id = et'", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  IEdge \\<Up>id = et'\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "case (Proc_CFG_WhileBody c' n et n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> et = et'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "note edge = \\<open>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "note IH = \\<open>c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> et = et'\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> et = et'\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "from edge \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry", "obtain l where l:\"n = Label l\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>l. n = Label l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) auto"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "with edge"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label l", "have less:\"l < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = Label l\n\ngoal (1 subgoal):\n 1. l < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c'\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "from edge \\<open>n' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit", "obtain l' where l':\"n' = Label l'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. (\\<And>l'. n' = Label l' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases n') auto"], ["proof (state)\nthis:\n  n' = Label l'\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "with edge"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' = Label l'", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n' = Label l'\n\ngoal (1 subgoal):\n 1. l' < #:c'", "by(fastforce intro:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "with \\<open>while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<close> l less l'"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n  n = Label l\n  l < #:c'\n  n' = Label l'\n  l' < #:c'", "have \"c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\n  n = Label l\n  l < #:c'\n  n' = Label l'\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'", "by(fastforce elim:Proc_CFG.cases dest:label_incr_start_Node_smaller)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n'\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p n' \\<oplus> 2\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 4. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  et = et'", "show ?case"], ["proof (prove)\nusing this:\n  et = et'\n\ngoal (1 subgoal):\n 1. et = et'", "."], ["proof (state)\nthis:\n  et = et'\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "case (Proc_CFG_WhileBodyExit c' n et b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n  et = et'\n  n \\<noteq> Entry\n  while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label 0\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "note edge = \\<open>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "note IH = \\<open>c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow> et = et'\\<close>"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n  et = et'\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "from edge \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n \\<noteq> Entry", "obtain l where l:\"n = Label l\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>l. n = Label l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) auto"], ["proof (state)\nthis:\n  n = Label l\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "with edge"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n = Label l", "have \"l < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n = Label l\n\ngoal (1 subgoal):\n 1. l < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c'\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "with \\<open>while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label 0\\<close> l"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label 0\n  n = Label l\n  l < #:c'", "have \"c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label 0\n  n = Label l\n  l < #:c'\n\ngoal (1 subgoal):\n 1. c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit", "by -(erule Proc_CFG.cases,auto dest:label_incr_start_Node_smaller)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        c' \\<turnstile> n -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n        et = et';\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n \\<oplus> 2 -et'\\<rightarrow>\\<^sub>p Label\n                                    0\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 3. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  et = et'", "show ?case"], ["proof (prove)\nusing this:\n  et = et'\n\ngoal (1 subgoal):\n 1. et = et'", "."], ["proof (state)\nthis:\n  et = et'\n\ngoal (2 subgoals):\n 1. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "case Proc_CFG_Call"], ["proof (state)\nthis:\n  Call p_ es_ rets_ \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Label 1\n\ngoal (2 subgoals):\n 1. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           0 -et'\\<rightarrow>\\<^sub>p Label\n                  1 \\<Longrightarrow>\n       CEdge (p, es, rets) = et'\n 2. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "thus ?case"], ["proof (prove)\nusing this:\n  Call p_ es_ rets_ \\<turnstile> Label 0 -et'\\<rightarrow>\\<^sub>p Label 1\n\ngoal (1 subgoal):\n 1. CEdge (p_, es_, rets_) = et'", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  CEdge (p_, es_, rets_) = et'\n\ngoal (1 subgoal):\n 1. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "case Proc_CFG_CallSkip"], ["proof (state)\nthis:\n  Call p_ es_ rets_ \\<turnstile> Label 1 -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. \\<And>p es rets.\n       Call p es\n        rets \\<turnstile> Label\n                           1 -et'\\<rightarrow>\\<^sub>p Exit \\<Longrightarrow>\n       IEdge \\<Up>id = et'", "thus ?case"], ["proof (prove)\nusing this:\n  Call p_ es_ rets_ \\<turnstile> Label 1 -et'\\<rightarrow>\\<^sub>p Exit\n\ngoal (1 subgoal):\n 1. IEdge \\<Up>id = et'", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  IEdge \\<Up>id = et'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WCFG_deterministic:\n  \"\\<lbrakk>prog \\<turnstile> n\\<^sub>1 -et\\<^sub>1\\<rightarrow>\\<^sub>p n\\<^sub>1'; prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'; n\\<^sub>1 = n\\<^sub>2; n\\<^sub>1' \\<noteq> n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'. et\\<^sub>1 = IEdge (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and> \n            (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<turnstile> n\\<^sub>1 -et\\<^sub>1\\<rightarrow>\\<^sub>p n\\<^sub>1';\n     prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n     n\\<^sub>1 = n\\<^sub>2; n\\<^sub>1' \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Q Q'.\n                         et\\<^sub>1 = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                         et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                         (\\<forall>s.\n                             (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                             (Q' s \\<longrightarrow> \\<not> Q s))", "proof(induct arbitrary:n\\<^sub>2 n\\<^sub>2' rule:Proc_CFG.induct)"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>prog n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Entry = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>prog n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Entry = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge (\\<lambda>s. True)\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>if (b) c\\<^sub>1\n                 else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2;\n         Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some false))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 19 subgoals...", "case (Proc_CFG_Entry_Exit prog)"], ["proof (state)\nthis:\n  prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Entry = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (19 subgoals):\n 1. \\<And>prog n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Entry = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>prog n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Entry = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge (\\<lambda>s. True)\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>if (b) c\\<^sub>1\n                 else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2;\n         Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some false))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 19 subgoals...", "from \\<open>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>Entry = n\\<^sub>2\\<close> \\<open>Exit \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Entry = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'", "have \"et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Entry = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce dest:Proc_CFG_EntryD)"], ["proof (state)\nthis:\n  et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (19 subgoals):\n 1. \\<And>prog n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Entry = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>prog n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Entry = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge (\\<lambda>s. True)\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>if (b) c\\<^sub>1\n                 else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2;\n         Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some false))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 19 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge (\\<lambda>s. False)\\<^sub>\\<surd> =\n       IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge (\\<lambda>s. False)\\<^sub>\\<surd> =\n     IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (18 subgoals):\n 1. \\<And>prog n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Entry = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge (\\<lambda>s. True)\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 1 = n\\<^sub>2;\n         n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>prog n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Entry = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge (\\<lambda>s. True)\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 1 = n\\<^sub>2;\n         n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 18 subgoals...", "case (Proc_CFG_Entry prog)"], ["proof (state)\nthis:\n  prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Entry = n\\<^sub>2\n  Label 0 \\<noteq> n\\<^sub>2'\n\ngoal (18 subgoals):\n 1. \\<And>prog n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Entry = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge (\\<lambda>s. True)\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 1 = n\\<^sub>2;\n         n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 18 subgoals...", "from \\<open>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>Entry = n\\<^sub>2\\<close> \\<open>Label 0 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Entry = n\\<^sub>2\n  Label 0 \\<noteq> n\\<^sub>2'", "have \"et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Entry = n\\<^sub>2\n  Label 0 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce dest:Proc_CFG_EntryD)"], ["proof (state)\nthis:\n  et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (18 subgoals):\n 1. \\<And>prog n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Entry = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge (\\<lambda>s. True)\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 1 = n\\<^sub>2;\n         n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 18 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge (\\<lambda>s. True)\\<^sub>\\<surd> =\n       IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge (\\<lambda>s. True)\\<^sub>\\<surd> = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (17 subgoals):\n 1. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n         n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n         n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 17 subgoals...", "case Proc_CFG_Skip"], ["proof (state)\nthis:\n  Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (17 subgoals):\n 1. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n         n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 17 subgoals...", "from \\<open>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>Label 0 = n\\<^sub>2\\<close> \\<open>Exit \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'", "have False"], ["proof (prove)\nusing this:\n  Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:Proc_CFG.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (17 subgoals):\n 1. \\<And>n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Skip \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         if (b) c\\<^sub>1\n         else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n         n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 17 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (16 subgoals):\n 1. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some true))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some true))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 16 subgoals...", "case (Proc_CFG_LAss V e)"], ["proof (state)\nthis:\n  V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'\n\ngoal (16 subgoals):\n 1. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some true))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 16 subgoals...", "from \\<open>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>Label 0 = n\\<^sub>2\\<close> \\<open>Label 1 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'", "have False"], ["proof (prove)\nusing this:\n  V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. False", "by -(erule Proc_CFG.cases,auto)"], ["proof (state)\nthis:\n  False\n\ngoal (16 subgoals):\n 1. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>\\<lambda>cf. update cf V e =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some true))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 16 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge \\<Up>\\<lambda>cf. update cf V e =\n       IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge \\<Up>\\<lambda>cf. update cf V e = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (15 subgoals):\n 1. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some false))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some false))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 15 subgoals...", "case (Proc_CFG_LAssSkip V e)"], ["proof (state)\nthis:\n  V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 1 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (15 subgoals):\n 1. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some false))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 15 subgoals...", "from \\<open>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>Label 1 = n\\<^sub>2\\<close> \\<open>Exit \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 1 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'", "have False"], ["proof (prove)\nusing this:\n  V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 1 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. False", "by -(erule Proc_CFG.cases,auto)"], ["proof (state)\nthis:\n  False\n\ngoal (15 subgoals):\n 1. \\<And>V e n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>V:=e \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge\n                              (\\<lambda>cf.\n                                  state_check cf b\n                                   (Some false))\\<^sub>\\<surd> =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 15 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 14 subgoals...", "case (Proc_CFG_SeqFirst c\\<^sub>1 n et n' c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>c\\<^sub>1 \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; n' \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n  n' \\<noteq> Exit\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  n = n\\<^sub>2\n  n' \\<noteq> n\\<^sub>2'\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 14 subgoals...", "note IH = \\<open>\\<And>n\\<^sub>2 n\\<^sub>2'. \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'; n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'. et = IEdge (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and> \n            (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>c\\<^sub>1 \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; n' \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 14 subgoals...", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n = n\\<^sub>2\\<close> \\<open>n' \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = n\\<^sub>2\n  n' \\<noteq> n\\<^sub>2'", "have \"c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or> (c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and> n\\<^sub>2' = Label #:c\\<^sub>1)\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n = n\\<^sub>2\n  n' \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n    c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n    n\\<^sub>2' = Label #:c\\<^sub>1", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c\\<^sub>1;;\n             c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n     c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n     n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                      c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                      n\\<^sub>2' = Label #:c\\<^sub>1", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> n\\<^sub>2'; c\\<^sub>1;; c\\<^sub>2 = prog;\n        n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                         c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                         n\\<^sub>2' = Label #:c\\<^sub>1\n 2. \\<And>prog.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> n\\<^sub>2'; c\\<^sub>1;; c\\<^sub>2 = prog;\n        n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 0\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                         c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                         n\\<^sub>2' = Label #:c\\<^sub>1\n 3. \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n     n' \\<noteq> n\\<^sub>2'; c\\<^sub>1;; c\\<^sub>2 = Skip;\n     n\\<^sub>2 = Label 0; et\\<^sub>2 = IEdge \\<Up>id;\n     n\\<^sub>2' = Exit\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                      c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                      n\\<^sub>2' = Label #:c\\<^sub>1\n 4. \\<And>V e.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> n\\<^sub>2'; c\\<^sub>1;; c\\<^sub>2 = V:=e;\n        n\\<^sub>2 = Label 0;\n        et\\<^sub>2 = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                         c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                         n\\<^sub>2' = Label #:c\\<^sub>1\n 5. \\<And>V e.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> n\\<^sub>2'; c\\<^sub>1;; c\\<^sub>2 = V:=e;\n        n\\<^sub>2 = Label 1; et\\<^sub>2 = IEdge \\<Up>id;\n        n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                         c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                         n\\<^sub>2' = Label #:c\\<^sub>1\n 6. \\<And>c\\<^sub>1' n eta n'a c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2'; n\\<^sub>2 = n;\n        et\\<^sub>2 = eta; n\\<^sub>2' = n'a;\n        c\\<^sub>1' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n'a;\n        n'a \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                         c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                         n\\<^sub>2' = Label #:c\\<^sub>1\n 7. \\<And>c\\<^sub>1' n eta c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2'; n\\<^sub>2 = n;\n        et\\<^sub>2 = eta; n\\<^sub>2' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                         c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                         n\\<^sub>2' = Label #:c\\<^sub>1\n 8. \\<And>c\\<^sub>2' n eta n'a c\\<^sub>1'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n\\<^sub>2 = n \\<oplus> #:c\\<^sub>1'; et\\<^sub>2 = eta;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n'a;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                         c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                         n\\<^sub>2' = Label #:c\\<^sub>1\n 9. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n        n\\<^sub>2 = Label 0;\n        et\\<^sub>2 =\n        IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                         c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                         n\\<^sub>2' = Label #:c\\<^sub>1\n 10. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p n';\n         n' \\<noteq> n\\<^sub>2';\n         c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n         n\\<^sub>2 = Label 0;\n         et\\<^sub>2 =\n         IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n         n\\<^sub>2' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n                          c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n                          n\\<^sub>2' = Label #:c\\<^sub>1\nA total of 19 subgoals...", "apply(auto intro:Proc_CFG.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'a.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> n'a \\<oplus> #:c\\<^sub>1;\n        n\\<^sub>2 = n \\<oplus> #:c\\<^sub>1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        n \\<noteq> Entry;\n        \\<not> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit\n 2. \\<And>n n'a.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> n'a \\<oplus> #:c\\<^sub>1;\n        n\\<^sub>2 = n \\<oplus> #:c\\<^sub>1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        n \\<noteq> Entry;\n        \\<not> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> n'a \\<oplus> #:c\\<^sub>1 = Label #:c\\<^sub>1", "by(case_tac n,auto dest:Proc_CFG_sourcelabel_less_num_nodes)+"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n  c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n  n\\<^sub>2' = Label #:c\\<^sub>1\n\ngoal (14 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n' \\<noteq> Exit;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 14 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<or>\n  c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n  n\\<^sub>2' = Label #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n    n\\<^sub>2' = Label #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\""], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n\ngoal (2 subgoals):\n 1. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n    n\\<^sub>2' = Label #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "from IH[OF this \\<open>n = n\\<^sub>2\\<close> \\<open>n' \\<noteq> n\\<^sub>2'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "."], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n    n\\<^sub>2' = Label #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n    n\\<^sub>2' = Label #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and> n\\<^sub>2' = Label #:c\\<^sub>1\""], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n  n\\<^sub>2' = Label #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n    n\\<^sub>2' = Label #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "hence edge:\"c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit\" and n2':\"n\\<^sub>2' = Label #:c\\<^sub>1\""], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n  n\\<^sub>2' = Label #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit &&&\n    n\\<^sub>2' = Label #:c\\<^sub>1", "by simp_all"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit\n  n\\<^sub>2' = Label #:c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit \\<and>\n    n\\<^sub>2' = Label #:c\\<^sub>1 \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "from IH[OF edge \\<open>n = n\\<^sub>2\\<close> \\<open>n' \\<noteq> Exit\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "."], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2;\n         n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2;\n         n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 13 subgoals...", "case (Proc_CFG_SeqConnect c\\<^sub>1 n et c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  \\<lbrakk>c\\<^sub>1 \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; Exit \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  n = n\\<^sub>2\n  Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2;\n         n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 13 subgoals...", "note IH = \\<open>\\<And>n\\<^sub>2 n\\<^sub>2'. \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'; n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'. et = IEdge (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and> \n            (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>c\\<^sub>1 \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; Exit \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2;\n         n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 13 subgoals...", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\\<close> \\<open>n = n\\<^sub>2\\<close> \\<open>n \\<noteq> Entry\\<close>\n    \\<open>Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n = n\\<^sub>2\n  n \\<noteq> Entry\n  Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'", "have \"c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and> Exit \\<noteq> n\\<^sub>2'\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n = n\\<^sub>2\n  n \\<noteq> Entry\n  Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n    Exit \\<noteq> n\\<^sub>2'", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c\\<^sub>1;;\n             c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n     c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n     n\\<^sub>2 \\<noteq> Entry;\n     Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                      Exit \\<noteq> n\\<^sub>2'", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n        n\\<^sub>2 \\<noteq> Entry; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = prog; n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                         Exit \\<noteq> n\\<^sub>2'\n 2. \\<And>prog.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n        n\\<^sub>2 \\<noteq> Entry; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = prog; n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 0\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                         Exit \\<noteq> n\\<^sub>2'\n 3. \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n     n\\<^sub>2 \\<noteq> Entry; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2';\n     c\\<^sub>1;; c\\<^sub>2 = Skip; n\\<^sub>2 = Label 0;\n     et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                      Exit \\<noteq> n\\<^sub>2'\n 4. \\<And>V e.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n        n\\<^sub>2 \\<noteq> Entry; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = V:=e; n\\<^sub>2 = Label 0;\n        et\\<^sub>2 = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                         Exit \\<noteq> n\\<^sub>2'\n 5. \\<And>V e.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n        n\\<^sub>2 \\<noteq> Entry; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = V:=e; n\\<^sub>2 = Label 1;\n        et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                         Exit \\<noteq> n\\<^sub>2'\n 6. \\<And>c\\<^sub>1' n eta n' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n        n\\<^sub>2 \\<noteq> Entry; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2'; n\\<^sub>2 = n;\n        et\\<^sub>2 = eta; n\\<^sub>2' = n';\n        c\\<^sub>1' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                         Exit \\<noteq> n\\<^sub>2'\n 7. \\<And>c\\<^sub>1' n eta c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n        n\\<^sub>2 \\<noteq> Entry; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2'; n\\<^sub>2 = n;\n        et\\<^sub>2 = eta; n\\<^sub>2' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p Exit;\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                         Exit \\<noteq> n\\<^sub>2'\n 8. \\<And>c\\<^sub>2' n eta n' c\\<^sub>1'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n        n\\<^sub>2 \\<noteq> Entry; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n\\<^sub>2 = n \\<oplus> #:c\\<^sub>1'; et\\<^sub>2 = eta;\n        n\\<^sub>2' = n' \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> n -eta\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                         Exit \\<noteq> n\\<^sub>2'\n 9. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n        n\\<^sub>2 \\<noteq> Entry; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2';\n        c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n        n\\<^sub>2 = Label 0;\n        et\\<^sub>2 =\n        IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                         Exit \\<noteq> n\\<^sub>2'\n 10. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<rightarrow>\\<^sub>p Exit;\n         n\\<^sub>2 \\<noteq> Entry; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2';\n         c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n         n\\<^sub>2 = Label 0;\n         et\\<^sub>2 =\n         IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n         n\\<^sub>2' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n                          Exit \\<noteq> n\\<^sub>2'\nA total of 19 subgoals...", "apply(auto intro:Proc_CFG.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry;\n        Label #:c\\<^sub>1 \\<noteq> n' \\<oplus> #:c\\<^sub>1;\n        n\\<^sub>2 = n \\<oplus> #:c\\<^sub>1;\n        n\\<^sub>2' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<^sub>2\\<rightarrow>\\<^sub>p n' \\<oplus> #:c\\<^sub>1\n 2. \\<And>n n'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<rightarrow>\\<^sub>p Exit;\n        n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry;\n        n\\<^sub>2 = n \\<oplus> #:c\\<^sub>1; n\\<^sub>2' = Exit;\n        c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; Exit = n' \\<oplus> #:c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False", "by(case_tac n,auto dest:Proc_CFG_sourcelabel_less_num_nodes)+"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2' \\<and>\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (13 subgoals):\n 1. \\<And>c\\<^sub>1 n et c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n = n\\<^sub>2; Label #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry; n' \\<noteq> Exit;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2;\n         n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 13 subgoals...", "from IH[OF this[THEN conjunct1] \\<open>n = n\\<^sub>2\\<close> this[THEN conjunct2]]"], ["proof (chain)\npicking this:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "."], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 12 subgoals...", "case (Proc_CFG_SeqSecond c\\<^sub>2 n et n' c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>c\\<^sub>2 \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; n' \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n  n \\<noteq> Entry\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2\n  n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 12 subgoals...", "note IH = \\<open>\\<And>n\\<^sub>2 n\\<^sub>2'. \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'; n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'. et = IEdge (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and> \n            (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>c\\<^sub>2 \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; n' \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 12 subgoals...", "from \\<open>c\\<^sub>1;;c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2\\<close>\n    \\<open>n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<close> \\<open>n \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2\n  n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\n  n \\<noteq> Entry", "obtain nx where \"c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and> nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2'\""], ["proof (prove)\nusing this:\n  c\\<^sub>1;;\n  c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2\n  n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\n  n \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n        nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1;;\n     c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n     c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n        c\\<^sub>1;; c\\<^sub>2 = prog; n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n        c\\<^sub>1;; c\\<^sub>2 = prog; n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n     c\\<^sub>1;; c\\<^sub>2 = Skip; n\\<^sub>2 = Label 0;\n     et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n        c\\<^sub>1;; c\\<^sub>2 = V:=e; n\\<^sub>2 = Label 0;\n        et\\<^sub>2 = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n        c\\<^sub>1;; c\\<^sub>2 = V:=e; n\\<^sub>2 = Label 1;\n        et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' na eta n'a c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2'; n\\<^sub>2 = na;\n        et\\<^sub>2 = eta; n\\<^sub>2' = n'a;\n        c\\<^sub>1' \\<turnstile> na -eta\\<rightarrow>\\<^sub>p n'a;\n        n'a \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' na eta c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2'; n\\<^sub>2 = na;\n        et\\<^sub>2 = eta; n\\<^sub>2' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> na -eta\\<rightarrow>\\<^sub>p Exit;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' na eta n'a c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n        c\\<^sub>1;; c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1'; et\\<^sub>2 = eta;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> na -eta\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n        c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n        n\\<^sub>2 = Label 0;\n        et\\<^sub>2 =\n        IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>b c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                    nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                    thesis;\n         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n         n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n         c\\<^sub>1;; c\\<^sub>2 = if (b) c\\<^sub>1' else c\\<^sub>2';\n         n\\<^sub>2 = Label 0;\n         et\\<^sub>2 =\n         IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd>;\n         n\\<^sub>2' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "apply(auto intro:Proc_CFG.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2' \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'; n \\<noteq> Entry;\n     n\\<^sub>2 = n \\<oplus> #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n     n\\<^sub>2' \\<noteq> Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 =\n                Label #:c\\<^sub>1 \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Label #:c\\<^sub>1; n \\<noteq> Entry;\n     n\\<^sub>2 = n \\<oplus> #:c\\<^sub>1; n\\<^sub>2' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit;\n     n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 =\n                   n'a \\<oplus> #:c\\<^sub>1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = na \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n'a \\<oplus> #:c\\<^sub>1;\n        n \\<noteq> Entry; n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n,auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                nx \\<oplus> #:c\\<^sub>1 =\n                Label #:c\\<^sub>1 \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n     n' \\<oplus> #:c\\<^sub>1 \\<noteq> Label #:c\\<^sub>1; n \\<noteq> Entry;\n     n\\<^sub>2 = n \\<oplus> #:c\\<^sub>1; n\\<^sub>2' = Label #:c\\<^sub>1;\n     c\\<^sub>1 \\<turnstile> n \\<oplus> #:c\\<^sub>1 -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit;\n     n \\<oplus> #:c\\<^sub>1 \\<noteq> Entry\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 =\n                   n'a \\<oplus> #:c\\<^sub>1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = na \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n'a \\<oplus> #:c\\<^sub>1;\n        n \\<noteq> Entry; n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases n,auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   nx \\<oplus> #:c\\<^sub>1 =\n                   n'a \\<oplus> #:c\\<^sub>1 \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<oplus> #:c\\<^sub>1 = na \\<oplus> #:c\\<^sub>1;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n'a \\<oplus> #:c\\<^sub>1;\n        n \\<noteq> Entry; n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(fastforce dest:label_incr_inj)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2'\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 12 subgoals...", "with \\<open>n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\n  c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2'", "have edge:\"c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx\" and neq:\"n' \\<noteq> nx\""], ["proof (prove)\nusing this:\n  n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\n  c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n  nx \\<oplus> #:c\\<^sub>1 = n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx &&&\n    n' \\<noteq> nx", "by auto"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx\n  n' \\<noteq> nx\n\ngoal (12 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        c\\<^sub>1;;\n        c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n         \\<And>n\\<^sub>2 n\\<^sub>2'.\n            \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n             n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n            \\<Longrightarrow> \\<exists>Q Q'.\n                                 et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                 et\\<^sub>2 =\n                                 IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                 (\\<forall>s.\n                                     (Q s \\<longrightarrow>\n\\<not> Q' s) \\<and>\n                                     (Q' s \\<longrightarrow> \\<not> Q s));\n         n \\<noteq> Entry;\n         while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 12 subgoals...", "from IH[OF edge _ neq]"], ["proof (chain)\npicking this:\n  n = n \\<Longrightarrow>\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))", "show ?case"], ["proof (prove)\nusing this:\n  n = n \\<Longrightarrow>\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>Call p es\n                  rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             CEdge (p, es, rets) =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>Call p es\n                  rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             CEdge (p, es, rets) =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 11 subgoals...", "case (Proc_CFG_CondTrue b c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'\n\ngoal (11 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>Call p es\n                  rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             CEdge (p, es, rets) =\n                             IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))\nA total of 11 subgoals...", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>Label 0 = n\\<^sub>2\\<close> \\<open>Label 1 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'", "show ?case"], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> =\n       IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by -(erule Proc_CFG.cases,auto)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> =\n     IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>Call p es\n                  rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>Call p es\n                  rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "case (Proc_CFG_CondFalse b c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\n\ngoal (10 subgoals):\n 1. \\<And>b c\\<^sub>1 c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>if (b) c\\<^sub>1\n                else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2;\n        Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 10. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n        \\<lbrakk>Call p es\n                  rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n         Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                             et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>Label 0 = n\\<^sub>2\\<close> \\<open>Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'", "show ?case"], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label (#:c\\<^sub>1 + 1) \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by -(erule Proc_CFG.cases,auto)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n     IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (Proc_CFG_CondThen c\\<^sub>1 n et n' b c\\<^sub>2)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>c\\<^sub>1 \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; n' \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  n \\<oplus> 1 = n\\<^sub>2\n  n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "note IH = \\<open>\\<And>n\\<^sub>2 n\\<^sub>2'. \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'; n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Q Q'. et = IEdge (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and> \n              (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>c\\<^sub>1 \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; n' \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<noteq> Entry\\<close> \n    \\<open>n \\<oplus> 1 = n\\<^sub>2\\<close> \\<open>n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n \\<oplus> 1 = n\\<^sub>2\n  n' \\<oplus> 1 \\<noteq> n\\<^sub>2'", "obtain nx where \"c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and> n' \\<noteq> nx\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n \\<oplus> 1 = n\\<^sub>2\n  n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n        n' \\<noteq> nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                n' \\<noteq> nx \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n     c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n     n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = n\\<^sub>2;\n        n' \\<oplus> 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = n\\<^sub>2;\n        n' \\<oplus> 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                n' \\<noteq> nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n     n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2';\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip; n\\<^sub>2 = Label 0;\n     et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = n\\<^sub>2;\n        n' \\<oplus> 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n\\<^sub>2 = Label 0;\n        et\\<^sub>2 = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = n\\<^sub>2;\n        n' \\<oplus> 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n\\<^sub>2 = Label 1;\n        et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' na eta n'a c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = n\\<^sub>2;\n        n' \\<oplus> 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n\\<^sub>2 = na; et\\<^sub>2 = eta; n\\<^sub>2' = n'a;\n        c\\<^sub>1' \\<turnstile> na -eta\\<rightarrow>\\<^sub>p n'a;\n        n'a \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' na eta c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = n\\<^sub>2;\n        n' \\<oplus> 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n\\<^sub>2 = na; et\\<^sub>2 = eta; n\\<^sub>2' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> na -eta\\<rightarrow>\\<^sub>p Exit;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' na eta n'a c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = n\\<^sub>2;\n        n' \\<oplus> 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1'; et\\<^sub>2 = eta;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> na -eta\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = n\\<^sub>2;\n        n' \\<oplus> 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n\\<^sub>2 = Label 0;\n        et\\<^sub>2 =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                    n' \\<noteq> nx \\<Longrightarrow>\n                    thesis;\n         c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         n \\<noteq> Entry; n \\<oplus> 1 = n\\<^sub>2;\n         n' \\<oplus> 1 \\<noteq> n\\<^sub>2';\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n\\<^sub>2 = Label 0;\n         et\\<^sub>2 =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n\\<^sub>2' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "apply(auto intro:Proc_CFG.intros simp del:One_nat_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = na \\<oplus> 1;\n        n' \\<oplus> 1 \\<noteq> n'a \\<oplus> 1; n\\<^sub>2 = na \\<oplus> 1;\n        n\\<^sub>2' = n'a \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> 1 \\<noteq> n'a \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(drule label_incr_inj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n' \\<oplus> 1 \\<noteq> n'a \\<oplus> 1;\n        n\\<^sub>2 = na \\<oplus> 1; n\\<^sub>2' = n'a \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry; n = na\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> 1 \\<noteq> n'a \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp del:One_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> 1 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> 1 \\<noteq> n'a \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(drule label_incr_simp_rev[OF sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        n' \\<oplus> 1 \\<noteq> n'a \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry; na \\<oplus> #:c\\<^sub>1 = n\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(case_tac na,auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n  n' \\<noteq> nx\n\ngoal (9 subgoals):\n 1. \\<And>c\\<^sub>1 n et n' b c\\<^sub>2 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>1 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 1 = n\\<^sub>2; n' \\<oplus> 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 9. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from IH[OF this[THEN conjunct1] _ this[THEN conjunct2]]"], ["proof (chain)\npicking this:\n  n = n \\<Longrightarrow>\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))", "show ?case"], ["proof (prove)\nusing this:\n  n = n \\<Longrightarrow>\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (Proc_CFG_CondElse c\\<^sub>2 n et n' b c\\<^sub>1)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>c\\<^sub>2 \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; n' \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n  n \\<noteq> Entry\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2\n  n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "note IH = \\<open>\\<And>n\\<^sub>2 n\\<^sub>2'. \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'; n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Q Q'. et = IEdge (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and> \n              (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>c\\<^sub>2 \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; n' \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>if (b) c\\<^sub>1 else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<noteq> Entry\\<close> \n    \\<open>n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2\\<close> \\<open>n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2\n  n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'", "obtain nx where \"c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and> n' \\<noteq> nx\""], ["proof (prove)\nusing this:\n  if (b) c\\<^sub>1\n  else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2\n  n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n        n' \\<noteq> nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                n' \\<noteq> nx \\<Longrightarrow>\n                thesis;\n     if (b) c\\<^sub>1\n     else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n     c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n     n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n     n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = prog; n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                n' \\<noteq> nx \\<Longrightarrow>\n                thesis;\n     c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n     n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n     n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2';\n     if (b) c\\<^sub>1 else c\\<^sub>2 = Skip; n\\<^sub>2 = Label 0;\n     et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n\\<^sub>2 = Label 0;\n        et\\<^sub>2 = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = V:=e; n\\<^sub>2 = Label 1;\n        et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1' na eta n'a c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n\\<^sub>2 = na; et\\<^sub>2 = eta; n\\<^sub>2' = n'a;\n        c\\<^sub>1' \\<turnstile> na -eta\\<rightarrow>\\<^sub>p n'a;\n        n'a \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1' na eta c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n\\<^sub>2 = na; et\\<^sub>2 = eta; n\\<^sub>2' = Label #:c\\<^sub>1';\n        c\\<^sub>1' \\<turnstile> na -eta\\<rightarrow>\\<^sub>p Exit;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2' na eta n'a c\\<^sub>1'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = c\\<^sub>1';; c\\<^sub>2';\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1'; et\\<^sub>2 = eta;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1';\n        c\\<^sub>2' \\<turnstile> na -eta\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2';\n        if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n        else c\\<^sub>2';\n        n\\<^sub>2 = Label 0;\n        et\\<^sub>2 =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1' c\\<^sub>2'.\n        \\<lbrakk>\\<And>nx.\n                    c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                    n' \\<noteq> nx \\<Longrightarrow>\n                    thesis;\n         c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n         n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n         n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2';\n         if (b) c\\<^sub>1 else c\\<^sub>2 = if (ba) c\\<^sub>1'\n         else c\\<^sub>2';\n         n\\<^sub>2 = Label 0;\n         et\\<^sub>2 =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n\\<^sub>2' = Label (#:c\\<^sub>1' + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "apply(auto intro:Proc_CFG.intros simp del:One_nat_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 + 1 = na \\<oplus> 1;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n'a \\<oplus> 1;\n        n\\<^sub>2 = na \\<oplus> 1; n\\<^sub>2' = n'a \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        n \\<oplus> #:c\\<^sub>1 + 1 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n'a \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(drule label_incr_simp_rev)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n'a \\<oplus> 1;\n        n\\<^sub>2 = na \\<oplus> 1; n\\<^sub>2' = n'a \\<oplus> 1;\n        c\\<^sub>1 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry; n \\<oplus> #:c\\<^sub>1 = na\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        n \\<oplus> #:c\\<^sub>1 + 1 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n'a \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1 + 1;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1 + 1;\n        c\\<^sub>2 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(case_tac na,auto,cases n,auto dest:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        n \\<noteq> Entry;\n        n \\<oplus> Suc #:c\\<^sub>1 = na \\<oplus> Suc #:c\\<^sub>1;\n        n' \\<oplus> Suc #:c\\<^sub>1 \\<noteq> n'a \\<oplus> Suc #:c\\<^sub>1;\n        n\\<^sub>2 = na \\<oplus> Suc #:c\\<^sub>1;\n        n\\<^sub>2' = n'a \\<oplus> Suc #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(fastforce dest:label_incr_inj)"], ["proof (state)\nthis:\n  c\\<^sub>2 \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n  n' \\<noteq> nx\n\ngoal (8 subgoals):\n 1. \\<And>c\\<^sub>2 n et n' b c\\<^sub>1 n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>2 \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        if (b) c\\<^sub>1\n        else c\\<^sub>2 \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> #:c\\<^sub>1 + 1 = n\\<^sub>2;\n        n' \\<oplus> #:c\\<^sub>1 + 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from IH[OF this[THEN conjunct1] _ this[THEN conjunct2]]"], ["proof (chain)\npicking this:\n  n = n \\<Longrightarrow>\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))", "show ?case"], ["proof (prove)\nusing this:\n  n = n \\<Longrightarrow>\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (7 subgoals):\n 1. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (Proc_CFG_WhileTrue b c')"], ["proof (state)\nthis:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 2 \\<noteq> n\\<^sub>2'\n\ngoal (7 subgoals):\n 1. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some true))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>Label 0 = n\\<^sub>2\\<close> \\<open>Label 2 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 2 \\<noteq> n\\<^sub>2'", "show ?case"], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 2 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> =\n       IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by -(erule Proc_CFG.cases,auto)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge (\\<lambda>cf. state_check cf b (Some true))\\<^sub>\\<surd> =\n     IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (6 subgoals):\n 1. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (Proc_CFG_WhileFalse b c')"], ["proof (state)\nthis:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'\n\ngoal (6 subgoals):\n 1. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge\n                             (\\<lambda>cf.\n                                 state_check cf b\n                                  (Some false))\\<^sub>\\<surd> =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>Label 0 = n\\<^sub>2\\<close> \\<open>Label 1 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'", "show ?case"], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n       IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by -(erule Proc_CFG.cases,auto)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge (\\<lambda>cf. state_check cf b (Some false))\\<^sub>\\<surd> =\n     IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (5 subgoals):\n 1. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (Proc_CFG_WhileFalseSkip b c')"], ["proof (state)\nthis:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 1 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (5 subgoals):\n 1. \\<And>b c' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>Label 1 = n\\<^sub>2\\<close> \\<open>Exit \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 1 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'", "show ?case"], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 1 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by -(erule Proc_CFG.cases,auto dest:label_incr_ge)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (Proc_CFG_WhileBody c' n et n' b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  \\<lbrakk>c' \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; n' \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  n \\<oplus> 2 = n\\<^sub>2\n  n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "note IH = \\<open>\\<And>n\\<^sub>2 n\\<^sub>2'. \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'; n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Q Q'. et = IEdge (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and> \n              (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>c' \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; n' \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>n \\<noteq> Entry\\<close>\n    \\<open>n' \\<noteq> Exit\\<close> \\<open>n \\<oplus> 2 = n\\<^sub>2\\<close> \\<open>n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  n \\<oplus> 2 = n\\<^sub>2\n  n' \\<oplus> 2 \\<noteq> n\\<^sub>2'", "obtain nx where \"c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and> n' \\<noteq> nx\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'\n  n \\<noteq> Entry\n  n' \\<noteq> Exit\n  n \\<oplus> 2 = n\\<^sub>2\n  n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n        n' \\<noteq> nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                n' \\<noteq> nx \\<Longrightarrow>\n                thesis;\n     while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n     c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n     n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n     n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n        n' \\<oplus> 2 \\<noteq> n\\<^sub>2'; while (b) c' = prog;\n        n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n        n' \\<oplus> 2 \\<noteq> n\\<^sub>2'; while (b) c' = prog;\n        n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                n' \\<noteq> nx \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n     n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n     n' \\<oplus> 2 \\<noteq> n\\<^sub>2'; while (b) c' = Skip;\n     n\\<^sub>2 = Label 0; et\\<^sub>2 = IEdge \\<Up>id;\n     n\\<^sub>2' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n        n' \\<oplus> 2 \\<noteq> n\\<^sub>2'; while (b) c' = V:=e;\n        n\\<^sub>2 = Label 0;\n        et\\<^sub>2 = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n        n' \\<oplus> 2 \\<noteq> n\\<^sub>2'; while (b) c' = V:=e;\n        n\\<^sub>2 = Label 1; et\\<^sub>2 = IEdge \\<Up>id;\n        n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1 na eta n'a c\\<^sub>2.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n        n' \\<oplus> 2 \\<noteq> n\\<^sub>2';\n        while (b) c' = c\\<^sub>1;; c\\<^sub>2; n\\<^sub>2 = na;\n        et\\<^sub>2 = eta; n\\<^sub>2' = n'a;\n        c\\<^sub>1 \\<turnstile> na -eta\\<rightarrow>\\<^sub>p n'a;\n        n'a \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1 na eta c\\<^sub>2.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n        n' \\<oplus> 2 \\<noteq> n\\<^sub>2';\n        while (b) c' = c\\<^sub>1;; c\\<^sub>2; n\\<^sub>2 = na;\n        et\\<^sub>2 = eta; n\\<^sub>2' = Label #:c\\<^sub>1;\n        c\\<^sub>1 \\<turnstile> na -eta\\<rightarrow>\\<^sub>p Exit;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2 na eta n'a c\\<^sub>1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n        n' \\<oplus> 2 \\<noteq> n\\<^sub>2';\n        while (b) c' = c\\<^sub>1;; c\\<^sub>2;\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1; et\\<^sub>2 = eta;\n        n\\<^sub>2' = n'a \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> na -eta\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n        n' \\<oplus> 2 \\<noteq> n\\<^sub>2';\n        while (b) c' = if (ba) c\\<^sub>1 else c\\<^sub>2;\n        n\\<^sub>2 = Label 0;\n        et\\<^sub>2 =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1 c\\<^sub>2.\n        \\<lbrakk>\\<And>nx.\n                    c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                    n' \\<noteq> nx \\<Longrightarrow>\n                    thesis;\n         c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n         n' \\<noteq> Exit; n \\<oplus> 2 = n\\<^sub>2;\n         n' \\<oplus> 2 \\<noteq> n\\<^sub>2';\n         while (b) c' = if (ba) c\\<^sub>1 else c\\<^sub>2;\n         n\\<^sub>2 = Label 0;\n         et\\<^sub>2 =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n\\<^sub>2' = Label (#:c\\<^sub>1 + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "apply(auto intro:Proc_CFG.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n -IEdge\n                                    \\<Up>id\\<rightarrow>\\<^sub>p nx \\<and>\n                n' \\<noteq> nx \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n     n' \\<noteq> Exit; n \\<oplus> 2 = Label (Suc 0);\n     n' \\<oplus> 2 \\<noteq> Exit; n\\<^sub>2 = Label (Suc 0);\n     et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = na \\<oplus> 2;\n        n' \\<oplus> 2 \\<noteq> n'a \\<oplus> 2; n\\<^sub>2 = na \\<oplus> 2;\n        n\\<^sub>2' = n'a \\<oplus> 2;\n        c' \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry; n'a \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>na.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = na \\<oplus> 2;\n        n' \\<oplus> 2 \\<noteq> Label 0; n\\<^sub>2 = na \\<oplus> 2;\n        n\\<^sub>2' = Label 0;\n        c' \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(fastforce dest:label_incr_ge[OF sym])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na n'a.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = na \\<oplus> 2;\n        n' \\<oplus> 2 \\<noteq> n'a \\<oplus> 2; n\\<^sub>2 = na \\<oplus> 2;\n        n\\<^sub>2' = n'a \\<oplus> 2;\n        c' \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n'a;\n        na \\<noteq> Entry; n'a \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>na.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = na \\<oplus> 2;\n        n' \\<oplus> 2 \\<noteq> Label 0; n\\<^sub>2 = na \\<oplus> 2;\n        n\\<^sub>2' = Label 0;\n        c' \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(fastforce dest:label_incr_inj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   n' \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n'; n \\<noteq> Entry;\n        n' \\<noteq> Exit; n \\<oplus> 2 = na \\<oplus> 2;\n        n' \\<oplus> 2 \\<noteq> Label 0; n\\<^sub>2 = na \\<oplus> 2;\n        n\\<^sub>2' = Label 0;\n        c' \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p Exit;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(fastforce dest:label_incr_inj)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n  n' \\<noteq> nx\n\ngoal (4 subgoals):\n 1. \\<And>c' n et n' b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p n';\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; n' \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry; n' \\<noteq> Exit;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; n' \\<oplus> 2 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from IH[OF this[THEN conjunct1] _ this[THEN conjunct2]]"], ["proof (chain)\npicking this:\n  n = n \\<Longrightarrow>\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))", "show ?case"], ["proof (prove)\nusing this:\n  n = n \\<Longrightarrow>\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (Proc_CFG_WhileBodyExit c' n et b)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  \\<lbrakk>c' \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; Exit \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n  n \\<noteq> Entry\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  n \\<oplus> 2 = n\\<^sub>2\n  Label 0 \\<noteq> n\\<^sub>2'\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "note IH = \\<open>\\<And>n\\<^sub>2 n\\<^sub>2'. \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'; n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Q Q'. et = IEdge (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and> \n              (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>c' \\<turnstile> ?n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p ?n\\<^sub>2';\n   n = ?n\\<^sub>2; Exit \\<noteq> ?n\\<^sub>2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'.\n                       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                       (\\<forall>s.\n                           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                           (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\\<close> \\<open>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\\<close> \\<open>n \\<noteq> Entry\\<close>\n    \\<open>n \\<oplus> 2 = n\\<^sub>2\\<close> \\<open>Label 0 \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n \\<noteq> Entry\n  n \\<oplus> 2 = n\\<^sub>2\n  Label 0 \\<noteq> n\\<^sub>2'", "obtain nx where \"c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and> Exit \\<noteq> nx\""], ["proof (prove)\nusing this:\n  while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit\n  n \\<noteq> Entry\n  n \\<oplus> 2 = n\\<^sub>2\n  Label 0 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>nx.\n        c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n        Exit \\<noteq> nx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                Exit \\<noteq> nx \\<Longrightarrow>\n                thesis;\n     while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n     c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n     n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule Proc_CFG.cases)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   Exit \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2';\n        while (b) c' = prog; n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. False)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>prog.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   Exit \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2';\n        while (b) c' = prog; n\\<^sub>2 = Entry;\n        et\\<^sub>2 = IEdge (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                Exit \\<noteq> nx \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n     n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2';\n     while (b) c' = Skip; n\\<^sub>2 = Label 0; et\\<^sub>2 = IEdge \\<Up>id;\n     n\\<^sub>2' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 4. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   Exit \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2';\n        while (b) c' = V:=e; n\\<^sub>2 = Label 0;\n        et\\<^sub>2 = IEdge \\<Up>\\<lambda>cf. update cf V e;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>V e.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   Exit \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2';\n        while (b) c' = V:=e; n\\<^sub>2 = Label 1;\n        et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 6. \\<And>c\\<^sub>1 na eta n' c\\<^sub>2.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   Exit \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2';\n        while (b) c' = c\\<^sub>1;; c\\<^sub>2; n\\<^sub>2 = na;\n        et\\<^sub>2 = eta; n\\<^sub>2' = n';\n        c\\<^sub>1 \\<turnstile> na -eta\\<rightarrow>\\<^sub>p n';\n        n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis\n 7. \\<And>c\\<^sub>1 na eta c\\<^sub>2.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   Exit \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2';\n        while (b) c' = c\\<^sub>1;; c\\<^sub>2; n\\<^sub>2 = na;\n        et\\<^sub>2 = eta; n\\<^sub>2' = Label #:c\\<^sub>1;\n        c\\<^sub>1 \\<turnstile> na -eta\\<rightarrow>\\<^sub>p Exit;\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 8. \\<And>c\\<^sub>2 na eta n' c\\<^sub>1.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   Exit \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2';\n        while (b) c' = c\\<^sub>1;; c\\<^sub>2;\n        n\\<^sub>2 = na \\<oplus> #:c\\<^sub>1; et\\<^sub>2 = eta;\n        n\\<^sub>2' = n' \\<oplus> #:c\\<^sub>1;\n        c\\<^sub>2 \\<turnstile> na -eta\\<rightarrow>\\<^sub>p n';\n        na \\<noteq> Entry\\<rbrakk>\n       \\<Longrightarrow> thesis\n 9. \\<And>ba c\\<^sub>1 c\\<^sub>2.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   Exit \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2';\n        while (b) c' = if (ba) c\\<^sub>1 else c\\<^sub>2;\n        n\\<^sub>2 = Label 0;\n        et\\<^sub>2 =\n        IEdge (\\<lambda>cf. state_check cf ba (Some true))\\<^sub>\\<surd>;\n        n\\<^sub>2' = Label 1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 10. \\<And>ba c\\<^sub>1 c\\<^sub>2.\n        \\<lbrakk>\\<And>nx.\n                    c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                    Exit \\<noteq> nx \\<Longrightarrow>\n                    thesis;\n         c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n         n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2';\n         while (b) c' = if (ba) c\\<^sub>1 else c\\<^sub>2;\n         n\\<^sub>2 = Label 0;\n         et\\<^sub>2 =\n         IEdge (\\<lambda>cf. state_check cf ba (Some false))\\<^sub>\\<surd>;\n         n\\<^sub>2' = Label (#:c\\<^sub>1 + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis\nA total of 19 subgoals...", "apply(auto intro:Proc_CFG.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>nx.\n                c' \\<turnstile> n -IEdge\n                                    \\<Up>id\\<rightarrow>\\<^sub>p nx \\<and>\n                Exit \\<noteq> nx \\<Longrightarrow>\n                thesis;\n     c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n     n \\<oplus> 2 = Label (Suc 0); n\\<^sub>2 = Label (Suc 0);\n     et\\<^sub>2 = IEdge \\<Up>id; n\\<^sub>2' = Exit\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>na n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   Exit \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n        n \\<oplus> 2 = na \\<oplus> 2; Label 0 \\<noteq> n' \\<oplus> 2;\n        n\\<^sub>2 = na \\<oplus> 2; n\\<^sub>2' = n' \\<oplus> 2;\n        c' \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n';\n        na \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(fastforce dest:label_incr_ge[OF sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na n'.\n       \\<lbrakk>\\<And>nx.\n                   c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n                   Exit \\<noteq> nx \\<Longrightarrow>\n                   thesis;\n        c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit; n \\<noteq> Entry;\n        n \\<oplus> 2 = na \\<oplus> 2; Label 0 \\<noteq> n' \\<oplus> 2;\n        n\\<^sub>2 = na \\<oplus> 2; n\\<^sub>2' = n' \\<oplus> 2;\n        c' \\<turnstile> na -et\\<^sub>2\\<rightarrow>\\<^sub>p n';\n        na \\<noteq> Entry; n' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(fastforce dest:label_incr_inj)"], ["proof (state)\nthis:\n  c' \\<turnstile> n -et\\<^sub>2\\<rightarrow>\\<^sub>p nx \\<and>\n  Exit \\<noteq> nx\n\ngoal (3 subgoals):\n 1. \\<And>c' n et b n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>c' \\<turnstile> n -et\\<rightarrow>\\<^sub>p Exit;\n        \\<And>n\\<^sub>2 n\\<^sub>2'.\n           \\<lbrakk>c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n            n = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>Q Q'.\n                                et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                                et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                                (\\<forall>s.\n                                    (Q s \\<longrightarrow>\n                                     \\<not> Q' s) \\<and>\n                                    (Q' s \\<longrightarrow> \\<not> Q s));\n        n \\<noteq> Entry;\n        while (b) c' \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        n \\<oplus> 2 = n\\<^sub>2; Label 0 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from IH[OF this[THEN conjunct1] _ this[THEN conjunct2]]"], ["proof (chain)\npicking this:\n  n = n \\<Longrightarrow>\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))", "show ?case"], ["proof (prove)\nusing this:\n  n = n \\<Longrightarrow>\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (2 subgoals):\n 1. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case Proc_CFG_Call"], ["proof (state)\nthis:\n  Call p_ es_\n   rets_ \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'\n\ngoal (2 subgoals):\n 1. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 0 = n\\<^sub>2; Label 1 \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            CEdge (p, es, rets) =\n                            IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?case"], ["proof (prove)\nusing this:\n  Call p_ es_\n   rets_ \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 0 = n\\<^sub>2\n  Label 1 \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       CEdge (p_, es_, rets_) = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by -(erule Proc_CFG.cases,auto)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     CEdge (p_, es_, rets_) = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case Proc_CFG_CallSkip"], ["proof (state)\nthis:\n  Call p_ es_\n   rets_ \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 1 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>p es rets n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>Call p es\n                 rets \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2';\n        Label 1 = n\\<^sub>2; Exit \\<noteq> n\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?case"], ["proof (prove)\nusing this:\n  Call p_ es_\n   rets_ \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow>\\<^sub>p n\\<^sub>2'\n  Label 1 = n\\<^sub>2\n  Exit \\<noteq> n\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by -(erule Proc_CFG.cases,auto)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     IEdge \\<Up>id = IEdge (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = IEdge (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>And now: the interprocedural CFG\\<close>"], ["", "subsubsection \\<open>Statements containing calls\\<close>"], ["", "text \\<open>A procedure is a tuple composed of its name, its input and output variables\n  and its method body\\<close>"], ["", "type_synonym proc = \"(pname \\<times> vname list \\<times> vname list \\<times> cmd)\""], ["", "type_synonym procs = \"proc list\""], ["", "text \\<open>\\<open>containsCall\\<close> guarantees that a call to procedure p is in\n  a certain statement.\\<close>"], ["", "declare conj_cong[fundef_cong]"], ["", "function containsCall :: \n  \"procs \\<Rightarrow> cmd \\<Rightarrow> pname list \\<Rightarrow> pname \\<Rightarrow> bool\"\nwhere \"containsCall procs Skip ps p \\<longleftrightarrow> False\"\n  | \"containsCall procs (V:=e) ps p \\<longleftrightarrow> False\"\n  | \"containsCall procs (c\\<^sub>1;;c\\<^sub>2) ps p \\<longleftrightarrow> \n       containsCall procs c\\<^sub>1 ps p \\<or> containsCall procs c\\<^sub>2 ps p\"\n  | \"containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps p \\<longleftrightarrow> \n       containsCall procs c\\<^sub>1 ps p \\<or> containsCall procs c\\<^sub>2 ps p\"\n  | \"containsCall procs (while (b) c) ps p \\<longleftrightarrow> \n       containsCall procs c ps p\"\n  | \"containsCall procs (Call q es' rets') ps p \\<longleftrightarrow> p = q \\<and> ps = [] \\<or> \n       (\\<exists>ins outs c ps'. ps = q#ps' \\<and> (q,ins,outs,c) \\<in> set procs \\<and>\n                     containsCall procs c ps' p)\""], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>procs ps p.\n                   x = (procs, Skip, ps, p) \\<Longrightarrow> P;\n        \\<And>procs V e ps p. x = (procs, V:=e, ps, p) \\<Longrightarrow> P;\n        \\<And>procs c\\<^sub>1 c\\<^sub>2 ps p.\n           x = (procs, c\\<^sub>1;; c\\<^sub>2, ps, p) \\<Longrightarrow> P;\n        \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps p.\n           x =\n           (procs, if (b) c\\<^sub>1 else c\\<^sub>2, ps, p) \\<Longrightarrow>\n           P;\n        \\<And>procs b c ps p.\n           x = (procs, while (b) c, ps, p) \\<Longrightarrow> P;\n        \\<And>procs q es' rets' ps p.\n           x = (procs, Call q es' rets', ps, p) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>procs ps p procsa psa pa.\n       (procs, Skip, ps, p) = (procsa, Skip, psa, pa) \\<Longrightarrow>\n       False = False\n 3. \\<And>procs ps p procsa V e psa pa.\n       (procs, Skip, ps, p) = (procsa, V:=e, psa, pa) \\<Longrightarrow>\n       False = False\n 4. \\<And>procs ps p procsa c\\<^sub>1 c\\<^sub>2 psa pa.\n       (procs, Skip, ps, p) =\n       (procsa, c\\<^sub>1;; c\\<^sub>2, psa, pa) \\<Longrightarrow>\n       False =\n       (containsCall_sumC (procsa, c\\<^sub>1, psa, pa) \\<or>\n        containsCall_sumC (procsa, c\\<^sub>2, psa, pa))\n 5. \\<And>procs ps p procsa b c\\<^sub>1 c\\<^sub>2 psa pa.\n       (procs, Skip, ps, p) =\n       (procsa, if (b) c\\<^sub>1 else c\\<^sub>2, psa, pa) \\<Longrightarrow>\n       False =\n       (containsCall_sumC (procsa, c\\<^sub>1, psa, pa) \\<or>\n        containsCall_sumC (procsa, c\\<^sub>2, psa, pa))\n 6. \\<And>procs ps p procsa b c psa pa.\n       (procs, Skip, ps, p) =\n       (procsa, while (b) c, psa, pa) \\<Longrightarrow>\n       False = containsCall_sumC (procsa, c, psa, pa)\n 7. \\<And>procs ps p procsa q es' rets' psa pa.\n       (procs, Skip, ps, p) =\n       (procsa, Call q es' rets', psa, pa) \\<Longrightarrow>\n       False =\n       (pa = q \\<and> psa = [] \\<or>\n        (\\<exists>ins outs c ps'.\n            psa = q # ps' \\<and>\n            (q, ins, outs, c) \\<in> set procsa \\<and>\n            containsCall_sumC (procsa, c, ps', pa)))\n 8. \\<And>procs V e ps p procsa Va ea psa pa.\n       (procs, V:=e, ps, p) = (procsa, Va:=ea, psa, pa) \\<Longrightarrow>\n       False = False\n 9. \\<And>procs V e ps p procsa c\\<^sub>1 c\\<^sub>2 psa pa.\n       (procs, V:=e, ps, p) =\n       (procsa, c\\<^sub>1;; c\\<^sub>2, psa, pa) \\<Longrightarrow>\n       False =\n       (containsCall_sumC (procsa, c\\<^sub>1, psa, pa) \\<or>\n        containsCall_sumC (procsa, c\\<^sub>2, psa, pa))\n 10. \\<And>procs V e ps p procsa b c\\<^sub>1 c\\<^sub>2 psa pa.\n        (procs, V:=e, ps, p) =\n        (procsa, if (b) c\\<^sub>1 else c\\<^sub>2, psa, pa) \\<Longrightarrow>\n        False =\n        (containsCall_sumC (procsa, c\\<^sub>1, psa, pa) \\<or>\n         containsCall_sumC (procsa, c\\<^sub>2, psa, pa))\nA total of 22 subgoals...", "by pat_completeness auto"], ["", "termination containsCall"], ["proof (prove)\ngoal (1 subgoal):\n 1. All containsCall_dom", "by(relation \"measures [\\<lambda>(procs,c,ps,p). length ps, \n  \\<lambda>(procs,c,ps,p). size c]\") auto"], ["", "lemmas containsCall_induct[case_names Skip LAss Seq Cond While Call] = \n  containsCall.induct"], ["", "lemma containsCallcases: \n  \"containsCall procs prog ps p\n  \\<Longrightarrow> ps = [] \\<and> containsCall procs prog ps p \\<or> \n  (\\<exists>q ins outs c ps'. ps = ps'@[q] \\<and> (q,ins,outs,c) \\<in> set procs \\<and>\n  containsCall procs c [] p \\<and> containsCall procs prog ps' q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. containsCall procs prog ps p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs prog ps p \\<or>\n    (\\<exists>q ins outs c ps'.\n        ps = ps' @ [q] \\<and>\n        (q, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and> containsCall procs prog ps' q)", "proof(induct procs prog ps p rule:containsCall_induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>procs ps p.\n       containsCall procs Skip ps p \\<Longrightarrow>\n       ps = [] \\<and> containsCall procs Skip ps p \\<or>\n       (\\<exists>q ins outs c ps'.\n           ps = ps' @ [q] \\<and>\n           (q, ins, outs, c) \\<in> set procs \\<and>\n           containsCall procs c [] p \\<and> containsCall procs Skip ps' q)\n 2. \\<And>procs V e ps p.\n       containsCall procs (V:=e) ps p \\<Longrightarrow>\n       ps = [] \\<and> containsCall procs (V:=e) ps p \\<or>\n       (\\<exists>q ins outs c ps'.\n           ps = ps' @ [q] \\<and>\n           (q, ins, outs, c) \\<in> set procs \\<and>\n           containsCall procs c [] p \\<and> containsCall procs (V:=e) ps' q)\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 ps p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c\\<^sub>1 ps p \\<or>\n                (\\<exists>q ins outs c ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, c) \\<in> set procs \\<and>\n                    containsCall procs c [] p \\<and>\n                    containsCall procs c\\<^sub>1 ps' q);\n        containsCall procs c\\<^sub>2 ps p \\<Longrightarrow>\n        ps = [] \\<and> containsCall procs c\\<^sub>2 ps p \\<or>\n        (\\<exists>q ins outs c ps'.\n            ps = ps' @ [q] \\<and>\n            (q, ins, outs, c) \\<in> set procs \\<and>\n            containsCall procs c [] p \\<and>\n            containsCall procs c\\<^sub>2 ps' q);\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps\n                          p \\<or>\n                         (\\<exists>q ins outs c ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps'\n                              q)\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c\\<^sub>1 ps p \\<or>\n                (\\<exists>q ins outs c ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, c) \\<in> set procs \\<and>\n                    containsCall procs c [] p \\<and>\n                    containsCall procs c\\<^sub>1 ps' q);\n        containsCall procs c\\<^sub>2 ps p \\<Longrightarrow>\n        ps = [] \\<and> containsCall procs c\\<^sub>2 ps p \\<or>\n        (\\<exists>q ins outs c ps'.\n            ps = ps' @ [q] \\<and>\n            (q, ins, outs, c) \\<in> set procs \\<and>\n            containsCall procs c [] p \\<and>\n            containsCall procs c\\<^sub>2 ps' q);\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) ps p \\<or>\n                         (\\<exists>q ins outs c ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs\n                              (if (b) c\\<^sub>1 else c\\<^sub>2) ps' q)\n 5. \\<And>procs b c ps p.\n       \\<lbrakk>containsCall procs c ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c ps p \\<or>\n                (\\<exists>q ins outs ca ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, ca) \\<in> set procs \\<and>\n                    containsCall procs ca [] p \\<and>\n                    containsCall procs c ps' q);\n        containsCall procs (while (b) c) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (while (b) c) ps p \\<or>\n                         (\\<exists>q ins outs ca ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, ca) \\<in> set procs \\<and>\n                             containsCall procs ca [] p \\<and>\n                             containsCall procs (while (b) c) ps' q)\n 6. \\<And>procs q es' rets' ps p.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>ps = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc p\\<rbrakk>\n                   \\<Longrightarrow> xc = [] \\<and>\n                                     containsCall procs xb xc p \\<or>\n                                     (\\<exists>q ins outs c ps'.\n   xc = ps' @ [q] \\<and>\n   (q, ins, outs, c) \\<in> set procs \\<and>\n   containsCall procs c [] p \\<and> containsCall procs xb ps' q);\n        containsCall procs (Call q es' rets') ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (Call q es' rets') ps p \\<or>\n                         (\\<exists>qa ins outs c ps'.\n                             ps = ps' @ [qa] \\<and>\n                             (qa, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs (Call q es' rets') ps' qa)", "case (Call procs q es' rets' ps p)"], ["proof (state)\nthis:\n  \\<lbrakk>ps = q # ?xc; (q, ?x, ?xa, ?xb) \\<in> set procs;\n   containsCall procs ?xb ?xc p\\<rbrakk>\n  \\<Longrightarrow> ?xc = [] \\<and> containsCall procs ?xb ?xc p \\<or>\n                    (\\<exists>q ins outs c ps'.\n                        ?xc = ps' @ [q] \\<and>\n                        (q, ins, outs, c) \\<in> set procs \\<and>\n                        containsCall procs c [] p \\<and>\n                        containsCall procs ?xb ps' q)\n  containsCall procs (Call q es' rets') ps p\n\ngoal (6 subgoals):\n 1. \\<And>procs ps p.\n       containsCall procs Skip ps p \\<Longrightarrow>\n       ps = [] \\<and> containsCall procs Skip ps p \\<or>\n       (\\<exists>q ins outs c ps'.\n           ps = ps' @ [q] \\<and>\n           (q, ins, outs, c) \\<in> set procs \\<and>\n           containsCall procs c [] p \\<and> containsCall procs Skip ps' q)\n 2. \\<And>procs V e ps p.\n       containsCall procs (V:=e) ps p \\<Longrightarrow>\n       ps = [] \\<and> containsCall procs (V:=e) ps p \\<or>\n       (\\<exists>q ins outs c ps'.\n           ps = ps' @ [q] \\<and>\n           (q, ins, outs, c) \\<in> set procs \\<and>\n           containsCall procs c [] p \\<and> containsCall procs (V:=e) ps' q)\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 ps p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c\\<^sub>1 ps p \\<or>\n                (\\<exists>q ins outs c ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, c) \\<in> set procs \\<and>\n                    containsCall procs c [] p \\<and>\n                    containsCall procs c\\<^sub>1 ps' q);\n        containsCall procs c\\<^sub>2 ps p \\<Longrightarrow>\n        ps = [] \\<and> containsCall procs c\\<^sub>2 ps p \\<or>\n        (\\<exists>q ins outs c ps'.\n            ps = ps' @ [q] \\<and>\n            (q, ins, outs, c) \\<in> set procs \\<and>\n            containsCall procs c [] p \\<and>\n            containsCall procs c\\<^sub>2 ps' q);\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps\n                          p \\<or>\n                         (\\<exists>q ins outs c ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps'\n                              q)\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c\\<^sub>1 ps p \\<or>\n                (\\<exists>q ins outs c ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, c) \\<in> set procs \\<and>\n                    containsCall procs c [] p \\<and>\n                    containsCall procs c\\<^sub>1 ps' q);\n        containsCall procs c\\<^sub>2 ps p \\<Longrightarrow>\n        ps = [] \\<and> containsCall procs c\\<^sub>2 ps p \\<or>\n        (\\<exists>q ins outs c ps'.\n            ps = ps' @ [q] \\<and>\n            (q, ins, outs, c) \\<in> set procs \\<and>\n            containsCall procs c [] p \\<and>\n            containsCall procs c\\<^sub>2 ps' q);\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) ps p \\<or>\n                         (\\<exists>q ins outs c ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs\n                              (if (b) c\\<^sub>1 else c\\<^sub>2) ps' q)\n 5. \\<And>procs b c ps p.\n       \\<lbrakk>containsCall procs c ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c ps p \\<or>\n                (\\<exists>q ins outs ca ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, ca) \\<in> set procs \\<and>\n                    containsCall procs ca [] p \\<and>\n                    containsCall procs c ps' q);\n        containsCall procs (while (b) c) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (while (b) c) ps p \\<or>\n                         (\\<exists>q ins outs ca ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, ca) \\<in> set procs \\<and>\n                             containsCall procs ca [] p \\<and>\n                             containsCall procs (while (b) c) ps' q)\n 6. \\<And>procs q es' rets' ps p.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>ps = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc p\\<rbrakk>\n                   \\<Longrightarrow> xc = [] \\<and>\n                                     containsCall procs xb xc p \\<or>\n                                     (\\<exists>q ins outs c ps'.\n   xc = ps' @ [q] \\<and>\n   (q, ins, outs, c) \\<in> set procs \\<and>\n   containsCall procs c [] p \\<and> containsCall procs xb ps' q);\n        containsCall procs (Call q es' rets') ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (Call q es' rets') ps p \\<or>\n                         (\\<exists>qa ins outs c ps'.\n                             ps = ps' @ [qa] \\<and>\n                             (qa, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs (Call q es' rets') ps' qa)", "note IH = \\<open>\\<And>x y z ps'. \\<lbrakk>ps = q#ps'; (q,x,y,z) \\<in> set procs;\n    containsCall procs z ps' p\\<rbrakk>\n    \\<Longrightarrow> ps' = [] \\<and> containsCall procs z ps' p \\<or> \n    (\\<exists>qx ins outs c psx. ps' = psx@[qx] \\<and> (qx,ins,outs,c) \\<in> set procs \\<and>\n    containsCall procs c [] p \\<and> \n    containsCall procs z psx qx)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>ps = q # ?ps'; (q, ?x, ?y, ?z) \\<in> set procs;\n   containsCall procs ?z ?ps' p\\<rbrakk>\n  \\<Longrightarrow> ?ps' = [] \\<and> containsCall procs ?z ?ps' p \\<or>\n                    (\\<exists>qx ins outs c psx.\n                        ?ps' = psx @ [qx] \\<and>\n                        (qx, ins, outs, c) \\<in> set procs \\<and>\n                        containsCall procs c [] p \\<and>\n                        containsCall procs ?z psx qx)\n\ngoal (6 subgoals):\n 1. \\<And>procs ps p.\n       containsCall procs Skip ps p \\<Longrightarrow>\n       ps = [] \\<and> containsCall procs Skip ps p \\<or>\n       (\\<exists>q ins outs c ps'.\n           ps = ps' @ [q] \\<and>\n           (q, ins, outs, c) \\<in> set procs \\<and>\n           containsCall procs c [] p \\<and> containsCall procs Skip ps' q)\n 2. \\<And>procs V e ps p.\n       containsCall procs (V:=e) ps p \\<Longrightarrow>\n       ps = [] \\<and> containsCall procs (V:=e) ps p \\<or>\n       (\\<exists>q ins outs c ps'.\n           ps = ps' @ [q] \\<and>\n           (q, ins, outs, c) \\<in> set procs \\<and>\n           containsCall procs c [] p \\<and> containsCall procs (V:=e) ps' q)\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 ps p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c\\<^sub>1 ps p \\<or>\n                (\\<exists>q ins outs c ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, c) \\<in> set procs \\<and>\n                    containsCall procs c [] p \\<and>\n                    containsCall procs c\\<^sub>1 ps' q);\n        containsCall procs c\\<^sub>2 ps p \\<Longrightarrow>\n        ps = [] \\<and> containsCall procs c\\<^sub>2 ps p \\<or>\n        (\\<exists>q ins outs c ps'.\n            ps = ps' @ [q] \\<and>\n            (q, ins, outs, c) \\<in> set procs \\<and>\n            containsCall procs c [] p \\<and>\n            containsCall procs c\\<^sub>2 ps' q);\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps\n                          p \\<or>\n                         (\\<exists>q ins outs c ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps'\n                              q)\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c\\<^sub>1 ps p \\<or>\n                (\\<exists>q ins outs c ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, c) \\<in> set procs \\<and>\n                    containsCall procs c [] p \\<and>\n                    containsCall procs c\\<^sub>1 ps' q);\n        containsCall procs c\\<^sub>2 ps p \\<Longrightarrow>\n        ps = [] \\<and> containsCall procs c\\<^sub>2 ps p \\<or>\n        (\\<exists>q ins outs c ps'.\n            ps = ps' @ [q] \\<and>\n            (q, ins, outs, c) \\<in> set procs \\<and>\n            containsCall procs c [] p \\<and>\n            containsCall procs c\\<^sub>2 ps' q);\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) ps p \\<or>\n                         (\\<exists>q ins outs c ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs\n                              (if (b) c\\<^sub>1 else c\\<^sub>2) ps' q)\n 5. \\<And>procs b c ps p.\n       \\<lbrakk>containsCall procs c ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c ps p \\<or>\n                (\\<exists>q ins outs ca ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, ca) \\<in> set procs \\<and>\n                    containsCall procs ca [] p \\<and>\n                    containsCall procs c ps' q);\n        containsCall procs (while (b) c) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (while (b) c) ps p \\<or>\n                         (\\<exists>q ins outs ca ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, ca) \\<in> set procs \\<and>\n                             containsCall procs ca [] p \\<and>\n                             containsCall procs (while (b) c) ps' q)\n 6. \\<And>procs q es' rets' ps p.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>ps = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc p\\<rbrakk>\n                   \\<Longrightarrow> xc = [] \\<and>\n                                     containsCall procs xb xc p \\<or>\n                                     (\\<exists>q ins outs c ps'.\n   xc = ps' @ [q] \\<and>\n   (q, ins, outs, c) \\<in> set procs \\<and>\n   containsCall procs c [] p \\<and> containsCall procs xb ps' q);\n        containsCall procs (Call q es' rets') ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (Call q es' rets') ps p \\<or>\n                         (\\<exists>qa ins outs c ps'.\n                             ps = ps' @ [qa] \\<and>\n                             (qa, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs (Call q es' rets') ps' qa)", "from \\<open>containsCall procs (Call q es' rets') ps p\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs (Call q es' rets') ps p", "have \"p = q \\<and> ps = [] \\<or> \n    (\\<exists>ins outs c ps'. ps = q#ps' \\<and> (q,ins,outs,c) \\<in> set procs \\<and>\n                  containsCall procs c ps' p)\""], ["proof (prove)\nusing this:\n  containsCall procs (Call q es' rets') ps p\n\ngoal (1 subgoal):\n 1. p = q \\<and> ps = [] \\<or>\n    (\\<exists>ins outs c ps'.\n        ps = q # ps' \\<and>\n        (q, ins, outs, c) \\<in> set procs \\<and> containsCall procs c ps' p)", "by simp"], ["proof (state)\nthis:\n  p = q \\<and> ps = [] \\<or>\n  (\\<exists>ins outs c ps'.\n      ps = q # ps' \\<and>\n      (q, ins, outs, c) \\<in> set procs \\<and> containsCall procs c ps' p)\n\ngoal (6 subgoals):\n 1. \\<And>procs ps p.\n       containsCall procs Skip ps p \\<Longrightarrow>\n       ps = [] \\<and> containsCall procs Skip ps p \\<or>\n       (\\<exists>q ins outs c ps'.\n           ps = ps' @ [q] \\<and>\n           (q, ins, outs, c) \\<in> set procs \\<and>\n           containsCall procs c [] p \\<and> containsCall procs Skip ps' q)\n 2. \\<And>procs V e ps p.\n       containsCall procs (V:=e) ps p \\<Longrightarrow>\n       ps = [] \\<and> containsCall procs (V:=e) ps p \\<or>\n       (\\<exists>q ins outs c ps'.\n           ps = ps' @ [q] \\<and>\n           (q, ins, outs, c) \\<in> set procs \\<and>\n           containsCall procs c [] p \\<and> containsCall procs (V:=e) ps' q)\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 ps p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c\\<^sub>1 ps p \\<or>\n                (\\<exists>q ins outs c ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, c) \\<in> set procs \\<and>\n                    containsCall procs c [] p \\<and>\n                    containsCall procs c\\<^sub>1 ps' q);\n        containsCall procs c\\<^sub>2 ps p \\<Longrightarrow>\n        ps = [] \\<and> containsCall procs c\\<^sub>2 ps p \\<or>\n        (\\<exists>q ins outs c ps'.\n            ps = ps' @ [q] \\<and>\n            (q, ins, outs, c) \\<in> set procs \\<and>\n            containsCall procs c [] p \\<and>\n            containsCall procs c\\<^sub>2 ps' q);\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps\n                          p \\<or>\n                         (\\<exists>q ins outs c ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps'\n                              q)\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c\\<^sub>1 ps p \\<or>\n                (\\<exists>q ins outs c ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, c) \\<in> set procs \\<and>\n                    containsCall procs c [] p \\<and>\n                    containsCall procs c\\<^sub>1 ps' q);\n        containsCall procs c\\<^sub>2 ps p \\<Longrightarrow>\n        ps = [] \\<and> containsCall procs c\\<^sub>2 ps p \\<or>\n        (\\<exists>q ins outs c ps'.\n            ps = ps' @ [q] \\<and>\n            (q, ins, outs, c) \\<in> set procs \\<and>\n            containsCall procs c [] p \\<and>\n            containsCall procs c\\<^sub>2 ps' q);\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) ps p \\<or>\n                         (\\<exists>q ins outs c ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs\n                              (if (b) c\\<^sub>1 else c\\<^sub>2) ps' q)\n 5. \\<And>procs b c ps p.\n       \\<lbrakk>containsCall procs c ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c ps p \\<or>\n                (\\<exists>q ins outs ca ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, ca) \\<in> set procs \\<and>\n                    containsCall procs ca [] p \\<and>\n                    containsCall procs c ps' q);\n        containsCall procs (while (b) c) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (while (b) c) ps p \\<or>\n                         (\\<exists>q ins outs ca ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, ca) \\<in> set procs \\<and>\n                             containsCall procs ca [] p \\<and>\n                             containsCall procs (while (b) c) ps' q)\n 6. \\<And>procs q es' rets' ps p.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>ps = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc p\\<rbrakk>\n                   \\<Longrightarrow> xc = [] \\<and>\n                                     containsCall procs xb xc p \\<or>\n                                     (\\<exists>q ins outs c ps'.\n   xc = ps' @ [q] \\<and>\n   (q, ins, outs, c) \\<in> set procs \\<and>\n   containsCall procs c [] p \\<and> containsCall procs xb ps' q);\n        containsCall procs (Call q es' rets') ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (Call q es' rets') ps p \\<or>\n                         (\\<exists>qa ins outs c ps'.\n                             ps = ps' @ [qa] \\<and>\n                             (qa, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs (Call q es' rets') ps' qa)", "thus ?case"], ["proof (prove)\nusing this:\n  p = q \\<and> ps = [] \\<or>\n  (\\<exists>ins outs c ps'.\n      ps = q # ps' \\<and>\n      (q, ins, outs, c) \\<in> set procs \\<and> containsCall procs c ps' p)\n\ngoal (1 subgoal):\n 1. ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p = q \\<and> ps = [] \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)\n 2. \\<exists>ins outs c ps'.\n       ps = q # ps' \\<and>\n       (q, ins, outs, c) \\<in> set procs \\<and>\n       containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "assume assms:\"p = q \\<and> ps = []\""], ["proof (state)\nthis:\n  p = q \\<and> ps = []\n\ngoal (2 subgoals):\n 1. p = q \\<and> ps = [] \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)\n 2. \\<exists>ins outs c ps'.\n       ps = q # ps' \\<and>\n       (q, ins, outs, c) \\<in> set procs \\<and>\n       containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "hence \"containsCall procs (Call q es' rets') ps p\""], ["proof (prove)\nusing this:\n  p = q \\<and> ps = []\n\ngoal (1 subgoal):\n 1. containsCall procs (Call q es' rets') ps p", "by simp"], ["proof (state)\nthis:\n  containsCall procs (Call q es' rets') ps p\n\ngoal (2 subgoals):\n 1. p = q \\<and> ps = [] \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)\n 2. \\<exists>ins outs c ps'.\n       ps = q # ps' \\<and>\n       (q, ins, outs, c) \\<in> set procs \\<and>\n       containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "with assms"], ["proof (chain)\npicking this:\n  p = q \\<and> ps = []\n  containsCall procs (Call q es' rets') ps p", "show ?thesis"], ["proof (prove)\nusing this:\n  p = q \\<and> ps = []\n  containsCall procs (Call q es' rets') ps p\n\ngoal (1 subgoal):\n 1. ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "by simp"], ["proof (state)\nthis:\n  ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n  (\\<exists>qa ins outs c ps'.\n      ps = ps' @ [qa] \\<and>\n      (qa, ins, outs, c) \\<in> set procs \\<and>\n      containsCall procs c [] p \\<and>\n      containsCall procs (Call q es' rets') ps' qa)\n\ngoal (1 subgoal):\n 1. \\<exists>ins outs c ps'.\n       ps = q # ps' \\<and>\n       (q, ins, outs, c) \\<in> set procs \\<and>\n       containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ins outs c ps'.\n       ps = q # ps' \\<and>\n       (q, ins, outs, c) \\<in> set procs \\<and>\n       containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "assume \"\\<exists>ins outs c ps'. ps = q#ps' \\<and> (q,ins,outs,c) \\<in> set procs \\<and>\n      containsCall procs c ps' p\""], ["proof (state)\nthis:\n  \\<exists>ins outs c ps'.\n     ps = q # ps' \\<and>\n     (q, ins, outs, c) \\<in> set procs \\<and> containsCall procs c ps' p\n\ngoal (1 subgoal):\n 1. \\<exists>ins outs c ps'.\n       ps = q # ps' \\<and>\n       (q, ins, outs, c) \\<in> set procs \\<and>\n       containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ins outs c ps'.\n     ps = q # ps' \\<and>\n     (q, ins, outs, c) \\<in> set procs \\<and> containsCall procs c ps' p", "obtain ins outs c ps' where \"ps = q#ps'\" and \"(q,ins,outs,c) \\<in> set procs\"\n      and \"containsCall procs c ps' p\""], ["proof (prove)\nusing this:\n  \\<exists>ins outs c ps'.\n     ps = q # ps' \\<and>\n     (q, ins, outs, c) \\<in> set procs \\<and> containsCall procs c ps' p\n\ngoal (1 subgoal):\n 1. (\\<And>ps' ins outs c.\n        \\<lbrakk>ps = q # ps'; (q, ins, outs, c) \\<in> set procs;\n         containsCall procs c ps' p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ps = q # ps'\n  (q, ins, outs, c) \\<in> set procs\n  containsCall procs c ps' p\n\ngoal (1 subgoal):\n 1. \\<exists>ins outs c ps'.\n       ps = q # ps' \\<and>\n       (q, ins, outs, c) \\<in> set procs \\<and>\n       containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "from IH[OF this]"], ["proof (chain)\npicking this:\n  ps' = [] \\<and> containsCall procs c ps' p \\<or>\n  (\\<exists>qx ins outs ca psx.\n      ps' = psx @ [qx] \\<and>\n      (qx, ins, outs, ca) \\<in> set procs \\<and>\n      containsCall procs ca [] p \\<and> containsCall procs c psx qx)", "have \"ps' = [] \\<and> containsCall procs c ps' p \\<or>\n      (\\<exists>qx insx outsx cx psx. \n         ps' = psx @ [qx] \\<and> (qx,insx,outsx,cx) \\<in> set procs \\<and>\n         containsCall procs cx [] p \\<and> containsCall procs c psx qx)\""], ["proof (prove)\nusing this:\n  ps' = [] \\<and> containsCall procs c ps' p \\<or>\n  (\\<exists>qx ins outs ca psx.\n      ps' = psx @ [qx] \\<and>\n      (qx, ins, outs, ca) \\<in> set procs \\<and>\n      containsCall procs ca [] p \\<and> containsCall procs c psx qx)\n\ngoal (1 subgoal):\n 1. ps' = [] \\<and> containsCall procs c ps' p \\<or>\n    (\\<exists>qx insx outsx cx psx.\n        ps' = psx @ [qx] \\<and>\n        (qx, insx, outsx, cx) \\<in> set procs \\<and>\n        containsCall procs cx [] p \\<and> containsCall procs c psx qx)", "."], ["proof (state)\nthis:\n  ps' = [] \\<and> containsCall procs c ps' p \\<or>\n  (\\<exists>qx insx outsx cx psx.\n      ps' = psx @ [qx] \\<and>\n      (qx, insx, outsx, cx) \\<in> set procs \\<and>\n      containsCall procs cx [] p \\<and> containsCall procs c psx qx)\n\ngoal (1 subgoal):\n 1. \\<exists>ins outs c ps'.\n       ps = q # ps' \\<and>\n       (q, ins, outs, c) \\<in> set procs \\<and>\n       containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps' = [] \\<and> containsCall procs c ps' p \\<or>\n  (\\<exists>qx insx outsx cx psx.\n      ps' = psx @ [qx] \\<and>\n      (qx, insx, outsx, cx) \\<in> set procs \\<and>\n      containsCall procs cx [] p \\<and> containsCall procs c psx qx)\n\ngoal (1 subgoal):\n 1. ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ps' = [] \\<and> containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)\n 2. \\<exists>qx insx outsx cx psx.\n       ps' = psx @ [qx] \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx [] p \\<and>\n       containsCall procs c psx qx \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "assume assms:\"ps' = [] \\<and> containsCall procs c ps' p\""], ["proof (state)\nthis:\n  ps' = [] \\<and> containsCall procs c ps' p\n\ngoal (2 subgoals):\n 1. ps' = [] \\<and> containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)\n 2. \\<exists>qx insx outsx cx psx.\n       ps' = psx @ [qx] \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx [] p \\<and>\n       containsCall procs c psx qx \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "have \"containsCall procs (Call q es' rets') [] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. containsCall procs (Call q es' rets') [] q", "by simp"], ["proof (state)\nthis:\n  containsCall procs (Call q es' rets') [] q\n\ngoal (2 subgoals):\n 1. ps' = [] \\<and> containsCall procs c ps' p \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)\n 2. \\<exists>qx insx outsx cx psx.\n       ps' = psx @ [qx] \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx [] p \\<and>\n       containsCall procs c psx qx \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "with assms \\<open>ps = q#ps'\\<close> \\<open>(q,ins,outs,c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  ps' = [] \\<and> containsCall procs c ps' p\n  ps = q # ps'\n  (q, ins, outs, c) \\<in> set procs\n  containsCall procs (Call q es' rets') [] q", "show ?thesis"], ["proof (prove)\nusing this:\n  ps' = [] \\<and> containsCall procs c ps' p\n  ps = q # ps'\n  (q, ins, outs, c) \\<in> set procs\n  containsCall procs (Call q es' rets') [] q\n\ngoal (1 subgoal):\n 1. ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "by fastforce"], ["proof (state)\nthis:\n  ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n  (\\<exists>qa ins outs c ps'.\n      ps = ps' @ [qa] \\<and>\n      (qa, ins, outs, c) \\<in> set procs \\<and>\n      containsCall procs c [] p \\<and>\n      containsCall procs (Call q es' rets') ps' qa)\n\ngoal (1 subgoal):\n 1. \\<exists>qx insx outsx cx psx.\n       ps' = psx @ [qx] \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx [] p \\<and>\n       containsCall procs c psx qx \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>qx insx outsx cx psx.\n       ps' = psx @ [qx] \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx [] p \\<and>\n       containsCall procs c psx qx \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "assume \"\\<exists>qx insx outsx cx psx. \n        ps' = psx@[qx] \\<and> (qx,insx,outsx,cx) \\<in> set procs \\<and>\n        containsCall procs cx [] p \\<and> containsCall procs c psx qx\""], ["proof (state)\nthis:\n  \\<exists>qx insx outsx cx psx.\n     ps' = psx @ [qx] \\<and>\n     (qx, insx, outsx, cx) \\<in> set procs \\<and>\n     containsCall procs cx [] p \\<and> containsCall procs c psx qx\n\ngoal (1 subgoal):\n 1. \\<exists>qx insx outsx cx psx.\n       ps' = psx @ [qx] \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx [] p \\<and>\n       containsCall procs c psx qx \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "then"], ["proof (chain)\npicking this:\n  \\<exists>qx insx outsx cx psx.\n     ps' = psx @ [qx] \\<and>\n     (qx, insx, outsx, cx) \\<in> set procs \\<and>\n     containsCall procs cx [] p \\<and> containsCall procs c psx qx", "obtain qx insx outsx cx psx\n        where \"ps' = psx@[qx]\" and \"(qx,insx,outsx,cx) \\<in> set procs\"\n        and \"containsCall procs cx [] p\"\n        and \"containsCall procs c psx qx\""], ["proof (prove)\nusing this:\n  \\<exists>qx insx outsx cx psx.\n     ps' = psx @ [qx] \\<and>\n     (qx, insx, outsx, cx) \\<in> set procs \\<and>\n     containsCall procs cx [] p \\<and> containsCall procs c psx qx\n\ngoal (1 subgoal):\n 1. (\\<And>psx qx insx outsx cx.\n        \\<lbrakk>ps' = psx @ [qx]; (qx, insx, outsx, cx) \\<in> set procs;\n         containsCall procs cx [] p; containsCall procs c psx qx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ps' = psx @ [qx]\n  (qx, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx [] p\n  containsCall procs c psx qx\n\ngoal (1 subgoal):\n 1. \\<exists>qx insx outsx cx psx.\n       ps' = psx @ [qx] \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx [] p \\<and>\n       containsCall procs c psx qx \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "from \\<open>(q,ins,outs,c) \\<in> set procs\\<close> \\<open>containsCall procs c psx qx\\<close>"], ["proof (chain)\npicking this:\n  (q, ins, outs, c) \\<in> set procs\n  containsCall procs c psx qx", "have \"containsCall procs (Call q es' rets') (q#psx) qx\""], ["proof (prove)\nusing this:\n  (q, ins, outs, c) \\<in> set procs\n  containsCall procs c psx qx\n\ngoal (1 subgoal):\n 1. containsCall procs (Call q es' rets') (q # psx) qx", "by fastforce"], ["proof (state)\nthis:\n  containsCall procs (Call q es' rets') (q # psx) qx\n\ngoal (1 subgoal):\n 1. \\<exists>qx insx outsx cx psx.\n       ps' = psx @ [qx] \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx [] p \\<and>\n       containsCall procs c psx qx \\<Longrightarrow>\n    ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "with \\<open>ps' = psx@[qx]\\<close> \\<open>ps = q#ps'\\<close> \\<open>(qx,insx,outsx,cx) \\<in> set procs\\<close>\n        \\<open>containsCall procs cx [] p\\<close>"], ["proof (chain)\npicking this:\n  ps' = psx @ [qx]\n  ps = q # ps'\n  (qx, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx [] p\n  containsCall procs (Call q es' rets') (q # psx) qx", "show ?thesis"], ["proof (prove)\nusing this:\n  ps' = psx @ [qx]\n  ps = q # ps'\n  (qx, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx [] p\n  containsCall procs (Call q es' rets') (q # psx) qx\n\ngoal (1 subgoal):\n 1. ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n    (\\<exists>qa ins outs c ps'.\n        ps = ps' @ [qa] \\<and>\n        (qa, ins, outs, c) \\<in> set procs \\<and>\n        containsCall procs c [] p \\<and>\n        containsCall procs (Call q es' rets') ps' qa)", "by fastforce"], ["proof (state)\nthis:\n  ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n  (\\<exists>qa ins outs c ps'.\n      ps = ps' @ [qa] \\<and>\n      (qa, ins, outs, c) \\<in> set procs \\<and>\n      containsCall procs c [] p \\<and>\n      containsCall procs (Call q es' rets') ps' qa)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n  (\\<exists>qa ins outs c ps'.\n      ps = ps' @ [qa] \\<and>\n      (qa, ins, outs, c) \\<in> set procs \\<and>\n      containsCall procs c [] p \\<and>\n      containsCall procs (Call q es' rets') ps' qa)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ps = [] \\<and> containsCall procs (Call q es' rets') ps p \\<or>\n  (\\<exists>qa ins outs c ps'.\n      ps = ps' @ [qa] \\<and>\n      (qa, ins, outs, c) \\<in> set procs \\<and>\n      containsCall procs c [] p \\<and>\n      containsCall procs (Call q es' rets') ps' qa)\n\ngoal (5 subgoals):\n 1. \\<And>procs ps p.\n       containsCall procs Skip ps p \\<Longrightarrow>\n       ps = [] \\<and> containsCall procs Skip ps p \\<or>\n       (\\<exists>q ins outs c ps'.\n           ps = ps' @ [q] \\<and>\n           (q, ins, outs, c) \\<in> set procs \\<and>\n           containsCall procs c [] p \\<and> containsCall procs Skip ps' q)\n 2. \\<And>procs V e ps p.\n       containsCall procs (V:=e) ps p \\<Longrightarrow>\n       ps = [] \\<and> containsCall procs (V:=e) ps p \\<or>\n       (\\<exists>q ins outs c ps'.\n           ps = ps' @ [q] \\<and>\n           (q, ins, outs, c) \\<in> set procs \\<and>\n           containsCall procs c [] p \\<and> containsCall procs (V:=e) ps' q)\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 ps p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c\\<^sub>1 ps p \\<or>\n                (\\<exists>q ins outs c ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, c) \\<in> set procs \\<and>\n                    containsCall procs c [] p \\<and>\n                    containsCall procs c\\<^sub>1 ps' q);\n        containsCall procs c\\<^sub>2 ps p \\<Longrightarrow>\n        ps = [] \\<and> containsCall procs c\\<^sub>2 ps p \\<or>\n        (\\<exists>q ins outs c ps'.\n            ps = ps' @ [q] \\<and>\n            (q, ins, outs, c) \\<in> set procs \\<and>\n            containsCall procs c [] p \\<and>\n            containsCall procs c\\<^sub>2 ps' q);\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps\n                          p \\<or>\n                         (\\<exists>q ins outs c ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps'\n                              q)\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c\\<^sub>1 ps p \\<or>\n                (\\<exists>q ins outs c ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, c) \\<in> set procs \\<and>\n                    containsCall procs c [] p \\<and>\n                    containsCall procs c\\<^sub>1 ps' q);\n        containsCall procs c\\<^sub>2 ps p \\<Longrightarrow>\n        ps = [] \\<and> containsCall procs c\\<^sub>2 ps p \\<or>\n        (\\<exists>q ins outs c ps'.\n            ps = ps' @ [q] \\<and>\n            (q, ins, outs, c) \\<in> set procs \\<and>\n            containsCall procs c [] p \\<and>\n            containsCall procs c\\<^sub>2 ps' q);\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) ps p \\<or>\n                         (\\<exists>q ins outs c ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, c) \\<in> set procs \\<and>\n                             containsCall procs c [] p \\<and>\n                             containsCall procs\n                              (if (b) c\\<^sub>1 else c\\<^sub>2) ps' q)\n 5. \\<And>procs b c ps p.\n       \\<lbrakk>containsCall procs c ps p \\<Longrightarrow>\n                ps = [] \\<and> containsCall procs c ps p \\<or>\n                (\\<exists>q ins outs ca ps'.\n                    ps = ps' @ [q] \\<and>\n                    (q, ins, outs, ca) \\<in> set procs \\<and>\n                    containsCall procs ca [] p \\<and>\n                    containsCall procs c ps' q);\n        containsCall procs (while (b) c) ps p\\<rbrakk>\n       \\<Longrightarrow> ps = [] \\<and>\n                         containsCall procs (while (b) c) ps p \\<or>\n                         (\\<exists>q ins outs ca ps'.\n                             ps = ps' @ [q] \\<and>\n                             (q, ins, outs, ca) \\<in> set procs \\<and>\n                             containsCall procs ca [] p \\<and>\n                             containsCall procs (while (b) c) ps' q)", "qed auto"], ["", "lemma containsCallE:\n  \"\\<lbrakk>containsCall procs prog ps p; \n    \\<lbrakk>ps = []; containsCall procs prog ps p\\<rbrakk> \\<Longrightarrow> P procs prog ps p;\n    \\<And>q ins outs c es' rets' ps'. \\<lbrakk>ps = ps'@[q]; (q,ins,outs,c) \\<in> set procs; \n      containsCall procs c [] p; containsCall procs prog ps' q\\<rbrakk> \n     \\<Longrightarrow> P procs prog ps p\\<rbrakk> \\<Longrightarrow> P procs prog ps p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>containsCall procs prog ps p;\n     \\<lbrakk>ps = []; containsCall procs prog ps p\\<rbrakk>\n     \\<Longrightarrow> P procs prog ps p;\n     \\<And>q ins outs c es' rets' ps'.\n        \\<lbrakk>ps = ps' @ [q]; (q, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p; containsCall procs prog ps' q\\<rbrakk>\n        \\<Longrightarrow> P procs prog ps p\\<rbrakk>\n    \\<Longrightarrow> P procs prog ps p", "by(auto dest:containsCallcases)"], ["", "lemma containsCall_in_proc: \n  \"\\<lbrakk>containsCall procs prog qs q; (q,ins,outs,c) \\<in> set procs; \n  containsCall procs c [] p\\<rbrakk>\n  \\<Longrightarrow> containsCall procs prog (qs@[q]) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>containsCall procs prog qs q;\n     (q, ins, outs, c) \\<in> set procs; containsCall procs c [] p\\<rbrakk>\n    \\<Longrightarrow> containsCall procs prog (qs @ [q]) p", "proof(induct procs prog qs q rule:containsCall_induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>procs ps pa.\n       \\<lbrakk>containsCall procs Skip ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs Skip (ps @ [pa]) p\n 2. \\<And>procs V e ps pa.\n       \\<lbrakk>containsCall procs (V:=e) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (V:=e) (ps @ [pa]) p\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1 (ps @ [pa])\n                                   p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 ps pa;\n         (pa, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (ps @ [pa]) p;\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (c\\<^sub>1;; c\\<^sub>2)\n                          (ps @ [pa]) p\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1 (ps @ [pa])\n                                   p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 ps pa;\n         (pa, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (ps @ [pa]) p;\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) (ps @ [pa]) p\n 5. \\<And>procs b ca ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs ca ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs ca (ps @ [pa]) p;\n        containsCall procs (while (b) ca) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (while (b) ca) (ps @ [pa]) p\n 6. \\<And>procs q es' rets' ps pa.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>ps = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc pa;\n                    (pa, ins, outs, c) \\<in> set procs;\n                    containsCall procs c [] p\\<rbrakk>\n                   \\<Longrightarrow> containsCall procs xb (xc @ [pa]) p;\n        containsCall procs (Call q es' rets') ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (Call q es' rets') (ps @ [pa]) p", "case (Call procs qx esx retsx ps p')"], ["proof (state)\nthis:\n  \\<lbrakk>ps = qx # ?xc; (qx, ?x, ?xa, ?xb) \\<in> set procs;\n   containsCall procs ?xb ?xc p'; (p', ins, outs, c) \\<in> set procs;\n   containsCall procs c [] p\\<rbrakk>\n  \\<Longrightarrow> containsCall procs ?xb (?xc @ [p']) p\n  containsCall procs (Call qx esx retsx) ps p'\n  (p', ins, outs, c) \\<in> set procs\n  containsCall procs c [] p\n\ngoal (6 subgoals):\n 1. \\<And>procs ps pa.\n       \\<lbrakk>containsCall procs Skip ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs Skip (ps @ [pa]) p\n 2. \\<And>procs V e ps pa.\n       \\<lbrakk>containsCall procs (V:=e) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (V:=e) (ps @ [pa]) p\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1 (ps @ [pa])\n                                   p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 ps pa;\n         (pa, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (ps @ [pa]) p;\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (c\\<^sub>1;; c\\<^sub>2)\n                          (ps @ [pa]) p\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1 (ps @ [pa])\n                                   p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 ps pa;\n         (pa, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (ps @ [pa]) p;\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) (ps @ [pa]) p\n 5. \\<And>procs b ca ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs ca ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs ca (ps @ [pa]) p;\n        containsCall procs (while (b) ca) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (while (b) ca) (ps @ [pa]) p\n 6. \\<And>procs q es' rets' ps pa.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>ps = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc pa;\n                    (pa, ins, outs, c) \\<in> set procs;\n                    containsCall procs c [] p\\<rbrakk>\n                   \\<Longrightarrow> containsCall procs xb (xc @ [pa]) p;\n        containsCall procs (Call q es' rets') ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (Call q es' rets') (ps @ [pa]) p", "note IH = \\<open>\\<And>x y z psx. \\<lbrakk>ps = qx#psx; (qx,x,y,z) \\<in> set procs;\n    containsCall procs z psx p'; (p',ins,outs,c) \\<in> set procs; \n    containsCall procs c [] p\\<rbrakk> \\<Longrightarrow> containsCall procs z (psx@[p']) p\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>ps = qx # ?psx; (qx, ?x, ?y, ?z) \\<in> set procs;\n   containsCall procs ?z ?psx p'; (p', ins, outs, c) \\<in> set procs;\n   containsCall procs c [] p\\<rbrakk>\n  \\<Longrightarrow> containsCall procs ?z (?psx @ [p']) p\n\ngoal (6 subgoals):\n 1. \\<And>procs ps pa.\n       \\<lbrakk>containsCall procs Skip ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs Skip (ps @ [pa]) p\n 2. \\<And>procs V e ps pa.\n       \\<lbrakk>containsCall procs (V:=e) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (V:=e) (ps @ [pa]) p\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1 (ps @ [pa])\n                                   p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 ps pa;\n         (pa, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (ps @ [pa]) p;\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (c\\<^sub>1;; c\\<^sub>2)\n                          (ps @ [pa]) p\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1 (ps @ [pa])\n                                   p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 ps pa;\n         (pa, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (ps @ [pa]) p;\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) (ps @ [pa]) p\n 5. \\<And>procs b ca ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs ca ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs ca (ps @ [pa]) p;\n        containsCall procs (while (b) ca) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (while (b) ca) (ps @ [pa]) p\n 6. \\<And>procs q es' rets' ps pa.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>ps = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc pa;\n                    (pa, ins, outs, c) \\<in> set procs;\n                    containsCall procs c [] p\\<rbrakk>\n                   \\<Longrightarrow> containsCall procs xb (xc @ [pa]) p;\n        containsCall procs (Call q es' rets') ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (Call q es' rets') (ps @ [pa]) p", "from \\<open>containsCall procs (Call qx esx retsx) ps p'\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs (Call qx esx retsx) ps p'", "have \"p' = qx \\<and> ps = [] \\<or>\n    (\\<exists>insx outsx cx psx. ps = qx#psx \\<and> (qx,insx,outsx,cx) \\<in> set procs \\<and>\n    containsCall procs cx psx p')\""], ["proof (prove)\nusing this:\n  containsCall procs (Call qx esx retsx) ps p'\n\ngoal (1 subgoal):\n 1. p' = qx \\<and> ps = [] \\<or>\n    (\\<exists>insx outsx cx psx.\n        ps = qx # psx \\<and>\n        (qx, insx, outsx, cx) \\<in> set procs \\<and>\n        containsCall procs cx psx p')", "by simp"], ["proof (state)\nthis:\n  p' = qx \\<and> ps = [] \\<or>\n  (\\<exists>insx outsx cx psx.\n      ps = qx # psx \\<and>\n      (qx, insx, outsx, cx) \\<in> set procs \\<and>\n      containsCall procs cx psx p')\n\ngoal (6 subgoals):\n 1. \\<And>procs ps pa.\n       \\<lbrakk>containsCall procs Skip ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs Skip (ps @ [pa]) p\n 2. \\<And>procs V e ps pa.\n       \\<lbrakk>containsCall procs (V:=e) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (V:=e) (ps @ [pa]) p\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1 (ps @ [pa])\n                                   p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 ps pa;\n         (pa, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (ps @ [pa]) p;\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (c\\<^sub>1;; c\\<^sub>2)\n                          (ps @ [pa]) p\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1 (ps @ [pa])\n                                   p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 ps pa;\n         (pa, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (ps @ [pa]) p;\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) (ps @ [pa]) p\n 5. \\<And>procs b ca ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs ca ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs ca (ps @ [pa]) p;\n        containsCall procs (while (b) ca) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (while (b) ca) (ps @ [pa]) p\n 6. \\<And>procs q es' rets' ps pa.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>ps = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc pa;\n                    (pa, ins, outs, c) \\<in> set procs;\n                    containsCall procs c [] p\\<rbrakk>\n                   \\<Longrightarrow> containsCall procs xb (xc @ [pa]) p;\n        containsCall procs (Call q es' rets') ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (Call q es' rets') (ps @ [pa]) p", "thus ?case"], ["proof (prove)\nusing this:\n  p' = qx \\<and> ps = [] \\<or>\n  (\\<exists>insx outsx cx psx.\n      ps = qx # psx \\<and>\n      (qx, insx, outsx, cx) \\<in> set procs \\<and>\n      containsCall procs cx psx p')\n\ngoal (1 subgoal):\n 1. containsCall procs (Call qx esx retsx) (ps @ [p']) p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p' = qx \\<and> ps = [] \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p\n 2. \\<exists>insx outsx cx psx.\n       ps = qx # psx \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p", "assume assms:\"p' = qx \\<and> ps = []\""], ["proof (state)\nthis:\n  p' = qx \\<and> ps = []\n\ngoal (2 subgoals):\n 1. p' = qx \\<and> ps = [] \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p\n 2. \\<exists>insx outsx cx psx.\n       ps = qx # psx \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p", "with \\<open>(p', ins, outs, c) \\<in> set procs\\<close> \\<open>containsCall procs c [] p\\<close>"], ["proof (chain)\npicking this:\n  (p', ins, outs, c) \\<in> set procs\n  containsCall procs c [] p\n  p' = qx \\<and> ps = []", "have \"containsCall procs (Call qx esx retsx) [p'] p\""], ["proof (prove)\nusing this:\n  (p', ins, outs, c) \\<in> set procs\n  containsCall procs c [] p\n  p' = qx \\<and> ps = []\n\ngoal (1 subgoal):\n 1. containsCall procs (Call qx esx retsx) [p'] p", "by fastforce"], ["proof (state)\nthis:\n  containsCall procs (Call qx esx retsx) [p'] p\n\ngoal (2 subgoals):\n 1. p' = qx \\<and> ps = [] \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p\n 2. \\<exists>insx outsx cx psx.\n       ps = qx # psx \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p", "with assms"], ["proof (chain)\npicking this:\n  p' = qx \\<and> ps = []\n  containsCall procs (Call qx esx retsx) [p'] p", "show ?thesis"], ["proof (prove)\nusing this:\n  p' = qx \\<and> ps = []\n  containsCall procs (Call qx esx retsx) [p'] p\n\ngoal (1 subgoal):\n 1. containsCall procs (Call qx esx retsx) (ps @ [p']) p", "by simp"], ["proof (state)\nthis:\n  containsCall procs (Call qx esx retsx) (ps @ [p']) p\n\ngoal (1 subgoal):\n 1. \\<exists>insx outsx cx psx.\n       ps = qx # psx \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>insx outsx cx psx.\n       ps = qx # psx \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p", "assume \"\\<exists>insx outsx cx psx. ps = qx#psx \\<and> (qx,insx,outsx,cx) \\<in> set procs \\<and>\n      containsCall procs cx psx p'\""], ["proof (state)\nthis:\n  \\<exists>insx outsx cx psx.\n     ps = qx # psx \\<and>\n     (qx, insx, outsx, cx) \\<in> set procs \\<and>\n     containsCall procs cx psx p'\n\ngoal (1 subgoal):\n 1. \\<exists>insx outsx cx psx.\n       ps = qx # psx \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p", "then"], ["proof (chain)\npicking this:\n  \\<exists>insx outsx cx psx.\n     ps = qx # psx \\<and>\n     (qx, insx, outsx, cx) \\<in> set procs \\<and>\n     containsCall procs cx psx p'", "obtain insx outsx cx psx where \"ps = qx#psx\" \n      and \"(qx,insx,outsx,cx) \\<in> set procs\"\n      and \"containsCall procs cx psx p'\""], ["proof (prove)\nusing this:\n  \\<exists>insx outsx cx psx.\n     ps = qx # psx \\<and>\n     (qx, insx, outsx, cx) \\<in> set procs \\<and>\n     containsCall procs cx psx p'\n\ngoal (1 subgoal):\n 1. (\\<And>psx insx outsx cx.\n        \\<lbrakk>ps = qx # psx; (qx, insx, outsx, cx) \\<in> set procs;\n         containsCall procs cx psx p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ps = qx # psx\n  (qx, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx psx p'\n\ngoal (1 subgoal):\n 1. \\<exists>insx outsx cx psx.\n       ps = qx # psx \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p", "from IH[OF this \\<open>(p', ins, outs, c) \\<in> set procs\\<close> \n      \\<open>containsCall procs c [] p\\<close>]"], ["proof (chain)\npicking this:\n  containsCall procs cx (psx @ [p']) p", "have \"containsCall procs cx (psx @ [p']) p\""], ["proof (prove)\nusing this:\n  containsCall procs cx (psx @ [p']) p\n\ngoal (1 subgoal):\n 1. containsCall procs cx (psx @ [p']) p", "."], ["proof (state)\nthis:\n  containsCall procs cx (psx @ [p']) p\n\ngoal (1 subgoal):\n 1. \\<exists>insx outsx cx psx.\n       ps = qx # psx \\<and>\n       (qx, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call qx esx retsx) (ps @ [p']) p", "with \\<open>ps = qx#psx\\<close> \\<open>(qx,insx,outsx,cx) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  ps = qx # psx\n  (qx, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx (psx @ [p']) p", "show ?thesis"], ["proof (prove)\nusing this:\n  ps = qx # psx\n  (qx, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx (psx @ [p']) p\n\ngoal (1 subgoal):\n 1. containsCall procs (Call qx esx retsx) (ps @ [p']) p", "by fastforce"], ["proof (state)\nthis:\n  containsCall procs (Call qx esx retsx) (ps @ [p']) p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  containsCall procs (Call qx esx retsx) (ps @ [p']) p\n\ngoal (5 subgoals):\n 1. \\<And>procs ps pa.\n       \\<lbrakk>containsCall procs Skip ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs Skip (ps @ [pa]) p\n 2. \\<And>procs V e ps pa.\n       \\<lbrakk>containsCall procs (V:=e) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (V:=e) (ps @ [pa]) p\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1 (ps @ [pa])\n                                   p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 ps pa;\n         (pa, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (ps @ [pa]) p;\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (c\\<^sub>1;; c\\<^sub>2)\n                          (ps @ [pa]) p\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1 (ps @ [pa])\n                                   p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 ps pa;\n         (pa, ins, outs, c) \\<in> set procs;\n         containsCall procs c [] p\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (ps @ [pa]) p;\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) (ps @ [pa]) p\n 5. \\<And>procs b ca ps pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs ca ps pa;\n                 (pa, ins, outs, c) \\<in> set procs;\n                 containsCall procs c [] p\\<rbrakk>\n                \\<Longrightarrow> containsCall procs ca (ps @ [pa]) p;\n        containsCall procs (while (b) ca) ps pa;\n        (pa, ins, outs, c) \\<in> set procs;\n        containsCall procs c [] p\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (while (b) ca) (ps @ [pa]) p", "qed auto"], ["", "lemma containsCall_indirection:\n  \"\\<lbrakk>containsCall procs prog qs q; containsCall procs c ps p;\n  (q,ins,outs,c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> containsCall procs prog (qs@q#ps) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>containsCall procs prog qs q; containsCall procs c ps p;\n     (q, ins, outs, c) \\<in> set procs\\<rbrakk>\n    \\<Longrightarrow> containsCall procs prog (qs @ q # ps) p", "proof(induct procs prog qs q rule:containsCall_induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>procs psa pa.\n       \\<lbrakk>containsCall procs Skip psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs Skip (psa @ pa # ps) p\n 2. \\<And>procs V e psa pa.\n       \\<lbrakk>containsCall procs (V:=e) psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (V:=e) (psa @ pa # ps) p\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1\n                                   (psa @ pa # ps) p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 psa pa;\n         containsCall procs c ps p;\n         (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (psa @ pa # ps) p;\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (c\\<^sub>1;; c\\<^sub>2)\n                          (psa @ pa # ps) p\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1\n                                   (psa @ pa # ps) p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 psa pa;\n         containsCall procs c ps p;\n         (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (psa @ pa # ps) p;\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) (psa @ pa # ps)\n                          p\n 5. \\<And>procs b ca psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs ca psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs ca (psa @ pa # ps) p;\n        containsCall procs (while (b) ca) psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (while (b) ca) (psa @ pa # ps) p\n 6. \\<And>procs q es' rets' psa pa.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>psa = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc pa; containsCall procs c ps p;\n                    (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> containsCall procs xb (xc @ pa # ps) p;\n        containsCall procs (Call q es' rets') psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (Call q es' rets')\n                          (psa @ pa # ps) p", "case (Call procs px esx retsx ps' p')"], ["proof (state)\nthis:\n  \\<lbrakk>ps' = px # ?xc; (px, ?x, ?xa, ?xb) \\<in> set procs;\n   containsCall procs ?xb ?xc p'; containsCall procs c ps p;\n   (p', ins, outs, c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> containsCall procs ?xb (?xc @ p' # ps) p\n  containsCall procs (Call px esx retsx) ps' p'\n  containsCall procs c ps p\n  (p', ins, outs, c) \\<in> set procs\n\ngoal (6 subgoals):\n 1. \\<And>procs psa pa.\n       \\<lbrakk>containsCall procs Skip psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs Skip (psa @ pa # ps) p\n 2. \\<And>procs V e psa pa.\n       \\<lbrakk>containsCall procs (V:=e) psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (V:=e) (psa @ pa # ps) p\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1\n                                   (psa @ pa # ps) p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 psa pa;\n         containsCall procs c ps p;\n         (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (psa @ pa # ps) p;\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (c\\<^sub>1;; c\\<^sub>2)\n                          (psa @ pa # ps) p\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1\n                                   (psa @ pa # ps) p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 psa pa;\n         containsCall procs c ps p;\n         (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (psa @ pa # ps) p;\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) (psa @ pa # ps)\n                          p\n 5. \\<And>procs b ca psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs ca psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs ca (psa @ pa # ps) p;\n        containsCall procs (while (b) ca) psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (while (b) ca) (psa @ pa # ps) p\n 6. \\<And>procs q es' rets' psa pa.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>psa = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc pa; containsCall procs c ps p;\n                    (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> containsCall procs xb (xc @ pa # ps) p;\n        containsCall procs (Call q es' rets') psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (Call q es' rets')\n                          (psa @ pa # ps) p", "note IH = \\<open>\\<And>x y z psx. \\<lbrakk>ps' = px # psx; (px, x, y, z) \\<in> set procs;\n    containsCall procs z psx p'; containsCall procs c ps p;\n    (p', ins, outs, c) \\<in> set procs\\<rbrakk>\n    \\<Longrightarrow> containsCall procs z (psx @ p' # ps) p\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>ps' = px # ?psx; (px, ?x, ?y, ?z) \\<in> set procs;\n   containsCall procs ?z ?psx p'; containsCall procs c ps p;\n   (p', ins, outs, c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> containsCall procs ?z (?psx @ p' # ps) p\n\ngoal (6 subgoals):\n 1. \\<And>procs psa pa.\n       \\<lbrakk>containsCall procs Skip psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs Skip (psa @ pa # ps) p\n 2. \\<And>procs V e psa pa.\n       \\<lbrakk>containsCall procs (V:=e) psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (V:=e) (psa @ pa # ps) p\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1\n                                   (psa @ pa # ps) p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 psa pa;\n         containsCall procs c ps p;\n         (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (psa @ pa # ps) p;\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (c\\<^sub>1;; c\\<^sub>2)\n                          (psa @ pa # ps) p\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1\n                                   (psa @ pa # ps) p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 psa pa;\n         containsCall procs c ps p;\n         (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (psa @ pa # ps) p;\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) (psa @ pa # ps)\n                          p\n 5. \\<And>procs b ca psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs ca psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs ca (psa @ pa # ps) p;\n        containsCall procs (while (b) ca) psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (while (b) ca) (psa @ pa # ps) p\n 6. \\<And>procs q es' rets' psa pa.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>psa = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc pa; containsCall procs c ps p;\n                    (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> containsCall procs xb (xc @ pa # ps) p;\n        containsCall procs (Call q es' rets') psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (Call q es' rets')\n                          (psa @ pa # ps) p", "from \\<open>containsCall procs (Call px esx retsx) ps' p'\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs (Call px esx retsx) ps' p'", "have \"p' = px \\<and> ps' = [] \\<or>\n    (\\<exists>insx outsx cx psx. ps' = px#psx \\<and> (px,insx,outsx,cx) \\<in> set procs \\<and>\n    containsCall procs cx psx p')\""], ["proof (prove)\nusing this:\n  containsCall procs (Call px esx retsx) ps' p'\n\ngoal (1 subgoal):\n 1. p' = px \\<and> ps' = [] \\<or>\n    (\\<exists>insx outsx cx psx.\n        ps' = px # psx \\<and>\n        (px, insx, outsx, cx) \\<in> set procs \\<and>\n        containsCall procs cx psx p')", "by simp"], ["proof (state)\nthis:\n  p' = px \\<and> ps' = [] \\<or>\n  (\\<exists>insx outsx cx psx.\n      ps' = px # psx \\<and>\n      (px, insx, outsx, cx) \\<in> set procs \\<and>\n      containsCall procs cx psx p')\n\ngoal (6 subgoals):\n 1. \\<And>procs psa pa.\n       \\<lbrakk>containsCall procs Skip psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs Skip (psa @ pa # ps) p\n 2. \\<And>procs V e psa pa.\n       \\<lbrakk>containsCall procs (V:=e) psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (V:=e) (psa @ pa # ps) p\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1\n                                   (psa @ pa # ps) p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 psa pa;\n         containsCall procs c ps p;\n         (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (psa @ pa # ps) p;\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (c\\<^sub>1;; c\\<^sub>2)\n                          (psa @ pa # ps) p\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1\n                                   (psa @ pa # ps) p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 psa pa;\n         containsCall procs c ps p;\n         (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (psa @ pa # ps) p;\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) (psa @ pa # ps)\n                          p\n 5. \\<And>procs b ca psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs ca psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs ca (psa @ pa # ps) p;\n        containsCall procs (while (b) ca) psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (while (b) ca) (psa @ pa # ps) p\n 6. \\<And>procs q es' rets' psa pa.\n       \\<lbrakk>\\<And>x xa xb xc.\n                   \\<lbrakk>psa = q # xc; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb xc pa; containsCall procs c ps p;\n                    (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                   \\<Longrightarrow> containsCall procs xb (xc @ pa # ps) p;\n        containsCall procs (Call q es' rets') psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (Call q es' rets')\n                          (psa @ pa # ps) p", "thus ?case"], ["proof (prove)\nusing this:\n  p' = px \\<and> ps' = [] \\<or>\n  (\\<exists>insx outsx cx psx.\n      ps' = px # psx \\<and>\n      (px, insx, outsx, cx) \\<in> set procs \\<and>\n      containsCall procs cx psx p')\n\ngoal (1 subgoal):\n 1. containsCall procs (Call px esx retsx) (ps' @ p' # ps) p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p' = px \\<and> ps' = [] \\<Longrightarrow>\n    containsCall procs (Call px esx retsx) (ps' @ p' # ps) p\n 2. \\<exists>insx outsx cx psx.\n       ps' = px # psx \\<and>\n       (px, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call px esx retsx) (ps' @ p' # ps) p", "assume \"p' = px \\<and> ps' = []\""], ["proof (state)\nthis:\n  p' = px \\<and> ps' = []\n\ngoal (2 subgoals):\n 1. p' = px \\<and> ps' = [] \\<Longrightarrow>\n    containsCall procs (Call px esx retsx) (ps' @ p' # ps) p\n 2. \\<exists>insx outsx cx psx.\n       ps' = px # psx \\<and>\n       (px, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call px esx retsx) (ps' @ p' # ps) p", "with \\<open>containsCall procs c ps p\\<close> \\<open>(p', ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs c ps p\n  (p', ins, outs, c) \\<in> set procs\n  p' = px \\<and> ps' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  containsCall procs c ps p\n  (p', ins, outs, c) \\<in> set procs\n  p' = px \\<and> ps' = []\n\ngoal (1 subgoal):\n 1. containsCall procs (Call px esx retsx) (ps' @ p' # ps) p", "by fastforce"], ["proof (state)\nthis:\n  containsCall procs (Call px esx retsx) (ps' @ p' # ps) p\n\ngoal (1 subgoal):\n 1. \\<exists>insx outsx cx psx.\n       ps' = px # psx \\<and>\n       (px, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call px esx retsx) (ps' @ p' # ps) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>insx outsx cx psx.\n       ps' = px # psx \\<and>\n       (px, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call px esx retsx) (ps' @ p' # ps) p", "assume \"\\<exists>insx outsx cx psx. ps' = px#psx \\<and> (px,insx,outsx,cx) \\<in> set procs \\<and>\n      containsCall procs cx psx p'\""], ["proof (state)\nthis:\n  \\<exists>insx outsx cx psx.\n     ps' = px # psx \\<and>\n     (px, insx, outsx, cx) \\<in> set procs \\<and>\n     containsCall procs cx psx p'\n\ngoal (1 subgoal):\n 1. \\<exists>insx outsx cx psx.\n       ps' = px # psx \\<and>\n       (px, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call px esx retsx) (ps' @ p' # ps) p", "then"], ["proof (chain)\npicking this:\n  \\<exists>insx outsx cx psx.\n     ps' = px # psx \\<and>\n     (px, insx, outsx, cx) \\<in> set procs \\<and>\n     containsCall procs cx psx p'", "obtain insx outsx cx psx where \"ps' = px#psx\" \n      and \"(px,insx,outsx,cx) \\<in> set procs\"\n      and \"containsCall procs cx psx p'\""], ["proof (prove)\nusing this:\n  \\<exists>insx outsx cx psx.\n     ps' = px # psx \\<and>\n     (px, insx, outsx, cx) \\<in> set procs \\<and>\n     containsCall procs cx psx p'\n\ngoal (1 subgoal):\n 1. (\\<And>psx insx outsx cx.\n        \\<lbrakk>ps' = px # psx; (px, insx, outsx, cx) \\<in> set procs;\n         containsCall procs cx psx p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ps' = px # psx\n  (px, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx psx p'\n\ngoal (1 subgoal):\n 1. \\<exists>insx outsx cx psx.\n       ps' = px # psx \\<and>\n       (px, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call px esx retsx) (ps' @ p' # ps) p", "from IH[OF this \\<open>containsCall procs c ps p\\<close>\n      \\<open>(p', ins, outs, c) \\<in> set procs\\<close>]"], ["proof (chain)\npicking this:\n  containsCall procs cx (psx @ p' # ps) p", "have \"containsCall procs cx (psx @ p' # ps) p\""], ["proof (prove)\nusing this:\n  containsCall procs cx (psx @ p' # ps) p\n\ngoal (1 subgoal):\n 1. containsCall procs cx (psx @ p' # ps) p", "."], ["proof (state)\nthis:\n  containsCall procs cx (psx @ p' # ps) p\n\ngoal (1 subgoal):\n 1. \\<exists>insx outsx cx psx.\n       ps' = px # psx \\<and>\n       (px, insx, outsx, cx) \\<in> set procs \\<and>\n       containsCall procs cx psx p' \\<Longrightarrow>\n    containsCall procs (Call px esx retsx) (ps' @ p' # ps) p", "with \\<open>ps' = px#psx\\<close> \\<open>(px,insx,outsx,cx) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  ps' = px # psx\n  (px, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx (psx @ p' # ps) p", "show ?thesis"], ["proof (prove)\nusing this:\n  ps' = px # psx\n  (px, insx, outsx, cx) \\<in> set procs\n  containsCall procs cx (psx @ p' # ps) p\n\ngoal (1 subgoal):\n 1. containsCall procs (Call px esx retsx) (ps' @ p' # ps) p", "by fastforce"], ["proof (state)\nthis:\n  containsCall procs (Call px esx retsx) (ps' @ p' # ps) p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  containsCall procs (Call px esx retsx) (ps' @ p' # ps) p\n\ngoal (5 subgoals):\n 1. \\<And>procs psa pa.\n       \\<lbrakk>containsCall procs Skip psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs Skip (psa @ pa # ps) p\n 2. \\<And>procs V e psa pa.\n       \\<lbrakk>containsCall procs (V:=e) psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (V:=e) (psa @ pa # ps) p\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1\n                                   (psa @ pa # ps) p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 psa pa;\n         containsCall procs c ps p;\n         (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (psa @ pa # ps) p;\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (c\\<^sub>1;; c\\<^sub>2)\n                          (psa @ pa # ps) p\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs c\\<^sub>1 psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs c\\<^sub>1\n                                   (psa @ pa # ps) p;\n        \\<lbrakk>containsCall procs c\\<^sub>2 psa pa;\n         containsCall procs c ps p;\n         (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> containsCall procs c\\<^sub>2 (psa @ pa # ps) p;\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) psa pa;\n        containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs\n                          (if (b) c\\<^sub>1 else c\\<^sub>2) (psa @ pa # ps)\n                          p\n 5. \\<And>procs b ca psa pa.\n       \\<lbrakk>\\<lbrakk>containsCall procs ca psa pa;\n                 containsCall procs c ps p;\n                 (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n                \\<Longrightarrow> containsCall procs ca (psa @ pa # ps) p;\n        containsCall procs (while (b) ca) psa pa; containsCall procs c ps p;\n        (pa, ins, outs, c) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> containsCall procs (while (b) ca) (psa @ pa # ps) p", "qed auto"], ["", "lemma Proc_CFG_Call_containsCall:\n  \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> containsCall procs prog [] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> n -CEdge\n                          (p, es,\n                           rets)\\<rightarrow>\\<^sub>p n' \\<Longrightarrow>\n    containsCall procs prog [] p", "by(induct prog n et\\<equiv>\"CEdge (p,es,rets)\" n' rule:Proc_CFG.induct,auto)"], ["", "lemma containsCall_empty_Proc_CFG_Call_edge: \n  assumes \"containsCall procs prog [] p\"\n  obtains l es rets l' where \"prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l es rets l'.\n        prog \\<turnstile> Label\n                           l -CEdge\n                               (p, es,\n                                rets)\\<rightarrow>\\<^sub>p Label\n                      l' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l es rets l'.\n       prog \\<turnstile> Label\n                          l -CEdge\n                              (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "from \\<open>containsCall procs prog [] p\\<close>"], ["proof (chain)\npicking this:\n  containsCall procs prog [] p", "show \"\\<exists>l es rets l'. prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l'\""], ["proof (prove)\nusing this:\n  containsCall procs prog [] p\n\ngoal (1 subgoal):\n 1. \\<exists>l es rets l'.\n       prog \\<turnstile> Label\n                          l -CEdge\n                              (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "proof(induct procs prog ps\\<equiv>\"[]::pname list\" p rule:containsCall_induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs c\\<^sub>2 [] p \\<Longrightarrow>\n        \\<exists>l es rets l'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'. c\\<^sub>1;;\n                            c\\<^sub>2 \\<turnstile> Label\n              l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs c\\<^sub>2 [] p \\<Longrightarrow>\n        \\<exists>l es rets l'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'. if (b) c\\<^sub>1\n                            else c\\<^sub>2 \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>procs b c p.\n       \\<lbrakk>containsCall procs c [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (while (b) c) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            while (b) c \\<turnstile> Label\n                l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "case Seq"], ["proof (state)\nthis:\n  containsCall procs_ c\\<^sub>1_ [] p_ \\<Longrightarrow>\n  \\<exists>l es rets l'.\n     c\\<^sub>1_ \\<turnstile> Label\n                              l -CEdge\n                                  (p_, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ c\\<^sub>2_ [] p_ \\<Longrightarrow>\n  \\<exists>l es rets l'.\n     c\\<^sub>2_ \\<turnstile> Label\n                              l -CEdge\n                                  (p_, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ (c\\<^sub>1_;; c\\<^sub>2_) [] p_\n\ngoal (6 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs c\\<^sub>1 c\\<^sub>2 p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs c\\<^sub>2 [] p \\<Longrightarrow>\n        \\<exists>l es rets l'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (c\\<^sub>1;; c\\<^sub>2) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'. c\\<^sub>1;;\n                            c\\<^sub>2 \\<turnstile> Label\n              l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>procs b c\\<^sub>1 c\\<^sub>2 p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs c\\<^sub>2 [] p \\<Longrightarrow>\n        \\<exists>l es rets l'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'. if (b) c\\<^sub>1\n                            else c\\<^sub>2 \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>procs b c p.\n       \\<lbrakk>containsCall procs c [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (while (b) c) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            while (b) c \\<turnstile> Label\n                l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 6. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "thus ?case"], ["proof (prove)\nusing this:\n  containsCall procs_ c\\<^sub>1_ [] p_ \\<Longrightarrow>\n  \\<exists>l es rets l'.\n     c\\<^sub>1_ \\<turnstile> Label\n                              l -CEdge\n                                  (p_, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ c\\<^sub>2_ [] p_ \\<Longrightarrow>\n  \\<exists>l es rets l'.\n     c\\<^sub>2_ \\<turnstile> Label\n                              l -CEdge\n                                  (p_, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ (c\\<^sub>1_;; c\\<^sub>2_) [] p_\n\ngoal (1 subgoal):\n 1. \\<exists>l es rets l'. c\\<^sub>1_;;\n       c\\<^sub>2_ \\<turnstile> Label\n                                l -CEdge\n                                    (p_, es,\n                                     rets)\\<rightarrow>\\<^sub>p Label l'", "by auto(fastforce dest:Proc_CFG_SeqFirst,fastforce dest:Proc_CFG_SeqSecond)"], ["proof (state)\nthis:\n  \\<exists>l es rets l'. c\\<^sub>1_;;\n     c\\<^sub>2_ \\<turnstile> Label\n                              l -CEdge\n                                  (p_, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (5 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs b c\\<^sub>1 c\\<^sub>2 p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs c\\<^sub>2 [] p \\<Longrightarrow>\n        \\<exists>l es rets l'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'. if (b) c\\<^sub>1\n                            else c\\<^sub>2 \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>procs b c p.\n       \\<lbrakk>containsCall procs c [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (while (b) c) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            while (b) c \\<turnstile> Label\n                l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs b c\\<^sub>1 c\\<^sub>2 p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs c\\<^sub>2 [] p \\<Longrightarrow>\n        \\<exists>l es rets l'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'. if (b) c\\<^sub>1\n                            else c\\<^sub>2 \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>procs b c p.\n       \\<lbrakk>containsCall procs c [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (while (b) c) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            while (b) c \\<turnstile> Label\n                l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "case Cond"], ["proof (state)\nthis:\n  containsCall procs_ c\\<^sub>1_ [] p_ \\<Longrightarrow>\n  \\<exists>l es rets l'.\n     c\\<^sub>1_ \\<turnstile> Label\n                              l -CEdge\n                                  (p_, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ c\\<^sub>2_ [] p_ \\<Longrightarrow>\n  \\<exists>l es rets l'.\n     c\\<^sub>2_ \\<turnstile> Label\n                              l -CEdge\n                                  (p_, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ (if (b_) c\\<^sub>1_ else c\\<^sub>2_) [] p_\n\ngoal (5 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs b c\\<^sub>1 c\\<^sub>2 p.\n       \\<lbrakk>containsCall procs c\\<^sub>1 [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c\\<^sub>1 \\<turnstile> Label\n     l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs c\\<^sub>2 [] p \\<Longrightarrow>\n        \\<exists>l es rets l'.\n           c\\<^sub>2 \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (if (b) c\\<^sub>1 else c\\<^sub>2) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'. if (b) c\\<^sub>1\n                            else c\\<^sub>2 \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>procs b c p.\n       \\<lbrakk>containsCall procs c [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (while (b) c) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            while (b) c \\<turnstile> Label\n                l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 5. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "thus ?case"], ["proof (prove)\nusing this:\n  containsCall procs_ c\\<^sub>1_ [] p_ \\<Longrightarrow>\n  \\<exists>l es rets l'.\n     c\\<^sub>1_ \\<turnstile> Label\n                              l -CEdge\n                                  (p_, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ c\\<^sub>2_ [] p_ \\<Longrightarrow>\n  \\<exists>l es rets l'.\n     c\\<^sub>2_ \\<turnstile> Label\n                              l -CEdge\n                                  (p_, es,\n                                   rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ (if (b_) c\\<^sub>1_ else c\\<^sub>2_) [] p_\n\ngoal (1 subgoal):\n 1. \\<exists>l es rets l'. if (b_) c\\<^sub>1_\n       else c\\<^sub>2_ \\<turnstile> Label\n                                     l -CEdge\n   (p_, es, rets)\\<rightarrow>\\<^sub>p Label l'", "by auto(fastforce dest:Proc_CFG_CondThen,fastforce dest:Proc_CFG_CondElse)"], ["proof (state)\nthis:\n  \\<exists>l es rets l'. if (b_) c\\<^sub>1_\n     else c\\<^sub>2_ \\<turnstile> Label\n                                   l -CEdge\n (p_, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (4 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs b c p.\n       \\<lbrakk>containsCall procs c [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (while (b) c) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            while (b) c \\<turnstile> Label\n                l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs b c p.\n       \\<lbrakk>containsCall procs c [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (while (b) c) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            while (b) c \\<turnstile> Label\n                l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "case While"], ["proof (state)\nthis:\n  containsCall procs_ c_ [] p_ \\<Longrightarrow>\n  \\<exists>l es rets l'.\n     c_ \\<turnstile> Label\n                      l -CEdge (p_, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ (while (b_) c_) [] p_\n\ngoal (4 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs b c p.\n       \\<lbrakk>containsCall procs c [] p \\<Longrightarrow>\n                \\<exists>l es rets l'.\n                   c \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (while (b) c) [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            while (b) c \\<turnstile> Label\n                l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 4. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "thus ?case"], ["proof (prove)\nusing this:\n  containsCall procs_ c_ [] p_ \\<Longrightarrow>\n  \\<exists>l es rets l'.\n     c_ \\<turnstile> Label\n                      l -CEdge (p_, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ (while (b_) c_) [] p_\n\ngoal (1 subgoal):\n 1. \\<exists>l es rets l'.\n       while (b_) c_ \\<turnstile> Label\n                                   l -CEdge\n (p_, es, rets)\\<rightarrow>\\<^sub>p Label l'", "by(fastforce dest:Proc_CFG_WhileBody)"], ["proof (state)\nthis:\n  \\<exists>l es rets l'.\n     while (b_) c_ \\<turnstile> Label\n                                 l -CEdge\n                                     (p_, es,\nrets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (3 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "case Call"], ["proof (state)\nthis:\n  \\<lbrakk>[] = [q_]; (q_, ?x, ?xa, ?xb) \\<in> set procs_;\n   containsCall procs_ ?xb [] p_\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l es rets l'.\n                       ?xb \\<turnstile> Label\n   l -CEdge (p_, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ (Call q_ es'_ rets'_) [] p_\n\ngoal (3 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 3. \\<And>procs q es' rets' p.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>[] = [q]; (q, x, xa, xb) \\<in> set procs;\n                    containsCall procs xb [] p\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l es rets l'.\n  xb \\<turnstile> Label\n                   l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs (Call q es' rets') [] p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l es rets l'.\n                            Call q es'\n                             rets' \\<turnstile> Label\n           l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>[] = [q_]; (q_, ?x, ?xa, ?xb) \\<in> set procs_;\n   containsCall procs_ ?xb [] p_\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l es rets l'.\n                       ?xb \\<turnstile> Label\n   l -CEdge (p_, es, rets)\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs_ (Call q_ es'_ rets'_) [] p_\n\ngoal (1 subgoal):\n 1. \\<exists>l es rets l'.\n       Call q_ es'_\n        rets'_ \\<turnstile> Label\n                             l -CEdge\n                                 (p_, es,\n                                  rets)\\<rightarrow>\\<^sub>p Label l'", "by(fastforce intro:Proc_CFG_Call)"], ["proof (state)\nthis:\n  \\<exists>l es rets l'.\n     Call q_ es'_\n      rets'_ \\<turnstile> Label\n                           l -CEdge\n                               (p_, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal (2 subgoals):\n 1. \\<And>procs p.\n       containsCall procs Skip [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          Skip \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n 2. \\<And>procs V e p.\n       containsCall procs (V:=e) [] p \\<Longrightarrow>\n       \\<exists>l es rets l'.\n          V:=e \\<turnstile> Label\n                             l -CEdge\n                                 (p, es, rets)\\<rightarrow>\\<^sub>p Label l'", "qed auto"], ["proof (state)\nthis:\n  \\<exists>l es rets l'.\n     prog \\<turnstile> Label\n                        l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>The edges of the combined CFG\\<close>"], ["", "type_synonym node = \"(pname \\<times> label)\""], ["", "type_synonym edge = \"(node \\<times> (vname,val,node,pname) edge_kind \\<times> node)\""], ["", "fun get_proc :: \"node \\<Rightarrow> pname\"\n  where \"get_proc (p,l) = p\""], ["", "inductive PCFG :: \n  \"cmd \\<Rightarrow> procs \\<Rightarrow> node \\<Rightarrow> (vname,val,node,pname) edge_kind \\<Rightarrow> node \\<Rightarrow> bool\" \n(\"_,_ \\<turnstile> _ -_\\<rightarrow> _\" [51,51,0,0,0] 81)\nfor prog::cmd and procs::procs\nwhere\n\n  Main:\n  \"prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n' \\<Longrightarrow> prog,procs \\<turnstile> (Main,n) -et\\<rightarrow> (Main,n')\"\n\n| Proc:\n  \"\\<lbrakk>(p,ins,outs,c) \\<in> set procs; c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'; \n    containsCall procs prog ps p\\<rbrakk> \n  \\<Longrightarrow> prog,procs \\<turnstile> (p,n) -et\\<rightarrow> (p,n')\"\n\n\n| MainCall:\n  \"\\<lbrakk>prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'; (p,ins,outs,c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> prog,procs \\<turnstile> (Main,Label l) \n                  -(\\<lambda>s. True):(Main,n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) es\\<rightarrow> (p,Entry)\"\n\n| ProcCall:\n  \"\\<lbrakk>(p,ins,outs,c) \\<in> set procs; c \\<turnstile> Label l -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p Label l';\n    (p',ins',outs',c') \\<in> set procs; containsCall procs prog ps p\\<rbrakk>\n  \\<Longrightarrow> prog,procs \\<turnstile> (p,Label l) \n               -(\\<lambda>s. True):(p,Label l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map (\\<lambda>e cf. interpret e cf) es'\\<rightarrow> (p',Entry)\"\n\n| MainReturn:\n  \"\\<lbrakk>prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l'; (p,ins,outs,c) \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> prog,procs \\<turnstile> (p,Exit) -(\\<lambda>cf. snd cf = (Main,Label l'))\\<hookleftarrow>\\<^bsub>p\\<^esub>\n       (\\<lambda>cf cf'. cf'(rets [:=] map cf outs))\\<rightarrow> (Main,Label l')\"\n\n| ProcReturn:\n  \"\\<lbrakk>(p,ins,outs,c) \\<in> set procs; c \\<turnstile> Label l -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p Label l'; \n   (p',ins',outs',c') \\<in> set procs; containsCall procs prog ps p\\<rbrakk>\n  \\<Longrightarrow> prog,procs \\<turnstile> (p',Exit) -(\\<lambda>cf. snd cf = (p,Label l'))\\<hookleftarrow>\\<^bsub>p'\\<^esub>\n       (\\<lambda>cf cf'. cf'(rets' [:=] map cf outs'))\\<rightarrow> (p,Label l')\"\n\n| MainCallReturn:\n  \"prog \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\n  \\<Longrightarrow> prog,procs \\<turnstile> (Main,n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (Main,n')\"\n\n| ProcCallReturn:\n  \"\\<lbrakk>(p,ins,outs,c) \\<in> set procs; c \\<turnstile> n -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p n'; \n    containsCall procs prog ps p\\<rbrakk> \n  \\<Longrightarrow> prog,procs \\<turnstile> (p,n) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (p,n')\""], ["", "end"]]}