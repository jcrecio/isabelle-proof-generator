{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/ReturnAndCallNodes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma return_node_determines_call_node:\n  assumes \"return_node n\"\n  shows \"\\<exists>!n'. \\<exists>a a'. valid_edge a \\<and> n' = sourcenode a \\<and> valid_edge a' \\<and> \n    a' \\<in> get_return_edges a \\<and> n = targetnode a'\"", "lemma return_node_THE_call_node:\n  \"\\<lbrakk>return_node n; valid_edge a; valid_edge a'; a' \\<in> get_return_edges a; \n  n = targetnode a'\\<rbrakk>\n  \\<Longrightarrow> (THE n'. \\<exists>a a'. valid_edge a \\<and> n' = sourcenode a \\<and> valid_edge a' \\<and> \n  a' \\<in> get_return_edges a \\<and> n = targetnode a') = sourcenode a\"", "lemma return_node_call_of_return_node:\n  \"return_node n \\<Longrightarrow> \\<exists>!n'. call_of_return_node n n'\"", "lemma call_of_return_nodes_det [dest]:\n  assumes \"call_of_return_node n n'\" and \"call_of_return_node n n''\"\n  shows \"n' = n''\"", "lemma get_return_edges_call_of_return_nodes:\n  \"\\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n    \\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i); length rs = length cs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i<length cs. call_of_return_node (targetnodes rs!i) (sourcenode (cs!i))\""], "translations": [["", "lemma return_node_determines_call_node:\n  assumes \"return_node n\"\n  shows \"\\<exists>!n'. \\<exists>a a'. valid_edge a \\<and> n' = sourcenode a \\<and> valid_edge a' \\<and> \n    a' \\<in> get_return_edges a \\<and> n = targetnode a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!n'.\n       \\<exists>a a'.\n          valid_edge a \\<and>\n          n' = sourcenode a \\<and>\n          valid_edge a' \\<and>\n          a' \\<in> get_return_edges a \\<and> n = targetnode a'", "proof(rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n' a a'.\n       valid_edge a \\<and>\n       n' = sourcenode a \\<and>\n       valid_edge a' \\<and>\n       a' \\<in> get_return_edges a \\<and> n = targetnode a'\n 2. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "from \\<open>return_node n\\<close>"], ["proof (chain)\npicking this:\n  return_node n", "show \"\\<exists>n' a a'. valid_edge a \\<and> n' = sourcenode a \\<and> valid_edge a' \\<and> \n    a' \\<in> get_return_edges a \\<and> n = targetnode a'\""], ["proof (prove)\nusing this:\n  return_node n\n\ngoal (1 subgoal):\n 1. \\<exists>n' a a'.\n       valid_edge a \\<and>\n       n' = sourcenode a \\<and>\n       valid_edge a' \\<and>\n       a' \\<in> get_return_edges a \\<and> n = targetnode a'", "by(simp add:return_node_def) blast"], ["proof (state)\nthis:\n  \\<exists>n' a a'.\n     valid_edge a \\<and>\n     n' = sourcenode a \\<and>\n     valid_edge a' \\<and>\n     a' \\<in> get_return_edges a \\<and> n = targetnode a'\n\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "fix n' nx"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "assume \"\\<exists>a a'. valid_edge a \\<and> n' = sourcenode a \\<and> valid_edge a' \\<and> \n    a' \\<in> get_return_edges a \\<and> n = targetnode a'\"\n    and \"\\<exists>a a'. valid_edge a \\<and> nx = sourcenode a \\<and> valid_edge a' \\<and> \n    a' \\<in> get_return_edges a \\<and> n = targetnode a'\""], ["proof (state)\nthis:\n  \\<exists>a a'.\n     valid_edge a \\<and>\n     n' = sourcenode a \\<and>\n     valid_edge a' \\<and>\n     a' \\<in> get_return_edges a \\<and> n = targetnode a'\n  \\<exists>a a'.\n     valid_edge a \\<and>\n     nx = sourcenode a \\<and>\n     valid_edge a' \\<and>\n     a' \\<in> get_return_edges a \\<and> n = targetnode a'\n\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "then"], ["proof (chain)\npicking this:\n  \\<exists>a a'.\n     valid_edge a \\<and>\n     n' = sourcenode a \\<and>\n     valid_edge a' \\<and>\n     a' \\<in> get_return_edges a \\<and> n = targetnode a'\n  \\<exists>a a'.\n     valid_edge a \\<and>\n     nx = sourcenode a \\<and>\n     valid_edge a' \\<and>\n     a' \\<in> get_return_edges a \\<and> n = targetnode a'", "obtain a a' ax ax' where \"valid_edge a\" and \"n' = sourcenode a\"\n    and \"valid_edge a'\" and \"a' \\<in> get_return_edges a\"\n    and \"n = targetnode a'\" and \"valid_edge ax\" and \"nx = sourcenode ax\" \n   and \"valid_edge ax'\" and \"ax' \\<in> get_return_edges ax\"\n    and \"n = targetnode ax'\""], ["proof (prove)\nusing this:\n  \\<exists>a a'.\n     valid_edge a \\<and>\n     n' = sourcenode a \\<and>\n     valid_edge a' \\<and>\n     a' \\<in> get_return_edges a \\<and> n = targetnode a'\n  \\<exists>a a'.\n     valid_edge a \\<and>\n     nx = sourcenode a \\<and>\n     valid_edge a' \\<and>\n     a' \\<in> get_return_edges a \\<and> n = targetnode a'\n\ngoal (1 subgoal):\n 1. (\\<And>a a' ax ax'.\n        \\<lbrakk>valid_edge a; n' = sourcenode a; valid_edge a';\n         a' \\<in> get_return_edges a; n = targetnode a'; valid_edge ax;\n         nx = sourcenode ax; valid_edge ax'; ax' \\<in> get_return_edges ax;\n         n = targetnode ax'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge a\n  n' = sourcenode a\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  n = targetnode a'\n  valid_edge ax\n  nx = sourcenode ax\n  valid_edge ax'\n  ax' \\<in> get_return_edges ax\n  n = targetnode ax'\n\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain a''\n    where intra_edge1:\"valid_edge a''\" \"sourcenode a'' = sourcenode a\"\n    \"targetnode a'' = targetnode a'\" \"kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = sourcenode a;\n         targetnode a'' = targetnode a';\n         kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "from \\<open>valid_edge ax\\<close> \\<open>ax' \\<in> get_return_edges ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  ax' \\<in> get_return_edges ax", "obtain ax''\n    where intra_edge2:\"valid_edge ax''\" \"sourcenode ax'' = sourcenode ax\"\n    \"targetnode ax'' = targetnode ax'\" \"kind ax'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  ax' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. (\\<And>ax''.\n        \\<lbrakk>valid_edge ax''; sourcenode ax'' = sourcenode ax;\n         targetnode ax'' = targetnode ax';\n         kind ax'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge)"], ["proof (state)\nthis:\n  valid_edge ax''\n  sourcenode ax'' = sourcenode ax\n  targetnode ax'' = targetnode ax'\n  kind ax'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain Q r p fs where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "with \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain Q' p f' \n    where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q' p f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"\\<exists>!a''. valid_edge a'' \\<and> targetnode a'' = targetnode a' \\<and> intra_kind(kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>!a''.\n       valid_edge a'' \\<and>\n       targetnode a'' = targetnode a' \\<and> intra_kind (kind a'')", "by(rule return_only_one_intra_edge)"], ["proof (state)\nthis:\n  \\<exists>!a''.\n     valid_edge a'' \\<and>\n     targetnode a'' = targetnode a' \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "with intra_edge1 intra_edge2 \\<open>n = targetnode a'\\<close> \\<open>n = targetnode ax'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  valid_edge ax''\n  sourcenode ax'' = sourcenode ax\n  targetnode ax'' = targetnode ax'\n  kind ax'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  n = targetnode a'\n  n = targetnode ax'\n  \\<exists>!a''.\n     valid_edge a'' \\<and>\n     targetnode a'' = targetnode a' \\<and> intra_kind (kind a'')", "have \"a'' = ax''\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  kind a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  valid_edge ax''\n  sourcenode ax'' = sourcenode ax\n  targetnode ax'' = targetnode ax'\n  kind ax'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  n = targetnode a'\n  n = targetnode ax'\n  \\<exists>!a''.\n     valid_edge a'' \\<and>\n     targetnode a'' = targetnode a' \\<and> intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. a'' = ax''", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  a'' = ax''\n\ngoal (1 subgoal):\n 1. \\<And>n' y.\n       \\<lbrakk>\\<exists>a a'.\n                   valid_edge a \\<and>\n                   n' = sourcenode a \\<and>\n                   valid_edge a' \\<and>\n                   a' \\<in> get_return_edges a \\<and> n = targetnode a';\n        \\<exists>a a'.\n           valid_edge a \\<and>\n           y = sourcenode a \\<and>\n           valid_edge a' \\<and>\n           a' \\<in> get_return_edges a \\<and> n = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> n' = y", "with \\<open>sourcenode a'' = sourcenode a\\<close> \\<open>sourcenode ax'' = sourcenode ax\\<close>\n    \\<open>n' = sourcenode a\\<close> \\<open>nx = sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a'' = sourcenode a\n  sourcenode ax'' = sourcenode ax\n  n' = sourcenode a\n  nx = sourcenode ax\n  a'' = ax''", "show \"n' = nx\""], ["proof (prove)\nusing this:\n  sourcenode a'' = sourcenode a\n  sourcenode ax'' = sourcenode ax\n  n' = sourcenode a\n  nx = sourcenode ax\n  a'' = ax''\n\ngoal (1 subgoal):\n 1. n' = nx", "by simp"], ["proof (state)\nthis:\n  n' = nx\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma return_node_THE_call_node:\n  \"\\<lbrakk>return_node n; valid_edge a; valid_edge a'; a' \\<in> get_return_edges a; \n  n = targetnode a'\\<rbrakk>\n  \\<Longrightarrow> (THE n'. \\<exists>a a'. valid_edge a \\<and> n' = sourcenode a \\<and> valid_edge a' \\<and> \n  a' \\<in> get_return_edges a \\<and> n = targetnode a') = sourcenode a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>return_node n; valid_edge a; valid_edge a';\n     a' \\<in> get_return_edges a; n = targetnode a'\\<rbrakk>\n    \\<Longrightarrow> (THE n'.\n                          \\<exists>a a'.\n                             valid_edge a \\<and>\n                             n' = sourcenode a \\<and>\n                             valid_edge a' \\<and>\n                             a' \\<in> get_return_edges a \\<and>\n                             n = targetnode a') =\n                      sourcenode a", "by(fastforce intro!:the1_equality return_node_determines_call_node)"], ["", "subsection \\<open>Defining call nodes belonging to a certain \\<open>return_node\\<close>\\<close>"], ["", "definition call_of_return_node :: \"'node \\<Rightarrow> 'node \\<Rightarrow> bool\"\n  where \"call_of_return_node n n' \\<equiv> \\<exists>a a'. return_node n \\<and> \n  valid_edge a \\<and> n' = sourcenode a \\<and> valid_edge a' \\<and>\n  a' \\<in> get_return_edges a \\<and> n = targetnode a'\""], ["", "lemma return_node_call_of_return_node:\n  \"return_node n \\<Longrightarrow> \\<exists>!n'. call_of_return_node n n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_node n \\<Longrightarrow> \\<exists>!n'. call_of_return_node n n'", "by -(frule return_node_determines_call_node,unfold call_of_return_node_def,simp)"], ["", "lemma call_of_return_nodes_det [dest]:\n  assumes \"call_of_return_node n n'\" and \"call_of_return_node n n''\"\n  shows \"n' = n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' = n''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n' = n''", "from \\<open>call_of_return_node n n'\\<close>"], ["proof (chain)\npicking this:\n  call_of_return_node n n'", "have \"return_node n\""], ["proof (prove)\nusing this:\n  call_of_return_node n n'\n\ngoal (1 subgoal):\n 1. return_node n", "by(simp add:call_of_return_node_def)"], ["proof (state)\nthis:\n  return_node n\n\ngoal (1 subgoal):\n 1. n' = n''", "hence \"\\<exists>!n'. call_of_return_node n n'\""], ["proof (prove)\nusing this:\n  return_node n\n\ngoal (1 subgoal):\n 1. \\<exists>!n'. call_of_return_node n n'", "by(rule return_node_call_of_return_node)"], ["proof (state)\nthis:\n  \\<exists>!n'. call_of_return_node n n'\n\ngoal (1 subgoal):\n 1. n' = n''", "with \\<open>call_of_return_node n n'\\<close> \\<open>call_of_return_node n n''\\<close>"], ["proof (chain)\npicking this:\n  call_of_return_node n n'\n  call_of_return_node n n''\n  \\<exists>!n'. call_of_return_node n n'", "show ?thesis"], ["proof (prove)\nusing this:\n  call_of_return_node n n'\n  call_of_return_node n n''\n  \\<exists>!n'. call_of_return_node n n'\n\ngoal (1 subgoal):\n 1. n' = n''", "by auto"], ["proof (state)\nthis:\n  n' = n''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma get_return_edges_call_of_return_nodes:\n  \"\\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n    \\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i); length rs = length cs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i<length cs. call_of_return_node (targetnodes rs!i) (sourcenode (cs!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     length rs = length cs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length cs.\n                         call_of_return_node (targetnodes rs ! i)\n                          (sourcenode (cs ! i))", "proof(induct cs arbitrary:m rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m rs.\n       \\<lbrakk>valid_call_list [] m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n        length rs = length []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length [].\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ([] ! i))\n 2. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "case Nil"], ["proof (state)\nthis:\n  valid_call_list [] m\n  valid_return_list rs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i)\n  length rs = length []\n\ngoal (2 subgoals):\n 1. \\<And>m rs.\n       \\<lbrakk>valid_call_list [] m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i);\n        length rs = length []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length [].\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ([] ! i))\n 2. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "thus ?case"], ["proof (prove)\nusing this:\n  valid_call_list [] m\n  valid_return_list rs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges ([] ! i)\n  length rs = length []\n\ngoal (1 subgoal):\n 1. \\<forall>i<length [].\n       call_of_return_node (targetnodes rs ! i) (sourcenode ([] ! i))", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<length [].\n     call_of_return_node (targetnodes rs ! i) (sourcenode ([] ! i))\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "case (Cons c' cs')"], ["proof (state)\nthis:\n  \\<lbrakk>valid_call_list cs' ?m; valid_return_list ?rs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (cs' ! i);\n   length ?rs = length cs'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i<length cs'.\n                       call_of_return_node (targetnodes ?rs ! i)\n                        (sourcenode (cs' ! i))\n  valid_call_list (c' # cs') m\n  valid_return_list rs m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((c' # cs') ! i)\n  length rs = length (c' # cs')\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "note IH = \\<open>\\<And>m rs. \\<lbrakk>valid_call_list cs' m; valid_return_list rs m;\n    \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs' ! i); length rs = length cs'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length cs'. call_of_return_node (targetnodes rs ! i) (sourcenode (cs'!i))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_call_list cs' ?m; valid_return_list ?rs ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (cs' ! i);\n   length ?rs = length cs'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i<length cs'.\n                       call_of_return_node (targetnodes ?rs ! i)\n                        (sourcenode (cs' ! i))\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "from \\<open>length rs = length (c' # cs')\\<close>"], ["proof (chain)\npicking this:\n  length rs = length (c' # cs')", "obtain r' rs' where \"rs = r' # rs'\"\n    and \"length rs' = length cs'\""], ["proof (prove)\nusing this:\n  length rs = length (c' # cs')\n\ngoal (1 subgoal):\n 1. (\\<And>r' rs'.\n        \\<lbrakk>rs = r' # rs'; length rs' = length cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases rs) auto"], ["proof (state)\nthis:\n  rs = r' # rs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "with \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges ((c' # cs') ! i)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((c' # cs') ! i)\n  rs = r' # rs'\n  length rs' = length cs'", "have \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n    and \"r' \\<in> get_return_edges c'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((c' # cs') ! i)\n  rs = r' # rs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i) &&&\n    r' \\<in> get_return_edges c'", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "from \\<open>valid_call_list (c'#cs') m\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list (c' # cs') m", "have \"valid_edge c'\""], ["proof (prove)\nusing this:\n  valid_call_list (c' # cs') m\n\ngoal (1 subgoal):\n 1. valid_edge c'", "by(fastforce simp:valid_call_list_def)"], ["proof (state)\nthis:\n  valid_edge c'\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "from this \\<open>r' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'", "have \"get_proc (sourcenode c') = get_proc (targetnode r')\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode c') = get_proc (targetnode r')", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode c') = get_proc (targetnode r')\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "from \\<open>valid_call_list (c'#cs') m\\<close>"], ["proof (chain)\npicking this:\n  valid_call_list (c' # cs') m", "have \"valid_call_list cs' (sourcenode c')\""], ["proof (prove)\nusing this:\n  valid_call_list (c' # cs') m\n\ngoal (1 subgoal):\n 1. valid_call_list cs' (sourcenode c')", "apply(clarsimp simp:valid_call_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs'a c cs''.\n       \\<lbrakk>\\<forall>cs'aa ca.\n                   (\\<exists>cs''a.\n                       c' # cs'a @ c # cs'' =\n                       cs'aa @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q r fs.\n                       kind ca =\n                       Q:r\\<hookrightarrow>\\<^bsub>get_proc\n              (case cs'aa of [] \\<Rightarrow> m\n               | a # list \\<Rightarrow>\n                   last (sourcenodes cs'aa))\\<^esub>fs);\n        cs' = cs'a @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q r fs.\n                             kind c =\n                             Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                    (case cs'a of [] \\<Rightarrow> sourcenode c'\n                     | a # list \\<Rightarrow>\n                         last (sourcenodes cs'a))\\<^esub>fs)", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<forall>cs'a ca.\n          (\\<exists>cs''a.\n              c' # cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n          valid_edge ca \\<and>\n          (\\<exists>Q r fs.\n              kind ca =\n              Q:r\\<hookrightarrow>\\<^bsub>get_proc\n     (case cs'a of [] \\<Rightarrow> m\n      | a # list \\<Rightarrow>\n          last (sourcenodes cs'a))\\<^esub>fs) \\<Longrightarrow>\n       valid_edge c \\<and>\n       (\\<exists>Q r fs.\n           kind c =\n           Q:r\\<hookrightarrow>\\<^bsub>get_proc\n  (case cs' of [] \\<Rightarrow> sourcenode c'\n   | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)", "apply(erule_tac x=\"c'#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<forall>ca.\n          (\\<exists>cs''a.\n              c' # cs' @ c # cs'' =\n              (c' # cs') @ ca # cs''a) \\<longrightarrow>\n          valid_edge ca \\<and>\n          (\\<exists>Q r fs.\n              kind ca =\n              Q:r\\<hookrightarrow>\\<^bsub>get_proc\n     (case c' # cs' of [] \\<Rightarrow> m\n      | a # list \\<Rightarrow>\n          last (sourcenodes (c' # cs')))\\<^esub>fs) \\<Longrightarrow>\n       valid_edge c \\<and>\n       (\\<exists>Q r fs.\n           kind c =\n           Q:r\\<hookrightarrow>\\<^bsub>get_proc\n  (case cs' of [] \\<Rightarrow> sourcenode c'\n   | a # list \\<Rightarrow> last (sourcenodes cs'))\\<^esub>fs)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c Q r fs.\n       \\<lbrakk>valid_edge c;\n        kind c =\n        Q:r\\<hookrightarrow>\\<^bsub>get_proc\n                                     (last\n (sourcenodes (c' # cs')))\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> get_proc (last (sourcenodes (c' # cs'))) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode c'\n                           | a # list \\<Rightarrow> last (sourcenodes cs'))", "by(case_tac cs')(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  valid_call_list cs' (sourcenode c')\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "from \\<open>valid_return_list rs m\\<close> \\<open>rs = r' # rs'\\<close> \n    \\<open>get_proc (sourcenode c') = get_proc (targetnode r')\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  rs = r' # rs'\n  get_proc (sourcenode c') = get_proc (targetnode r')", "have \"valid_return_list rs' (sourcenode c')\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  rs = r' # rs'\n  get_proc (sourcenode c') = get_proc (targetnode r')\n\ngoal (1 subgoal):\n 1. valid_return_list rs' (sourcenode c')", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       r' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> m\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        rs = r' # cs' @ c # cs'';\n        get_proc (sourcenode c') = get_proc (targetnode r');\n        rs' = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode c'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(erule_tac x=\"r'#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>rs = r' # cs' @ c # cs'';\n        get_proc (sourcenode c') = get_proc (targetnode r');\n        rs' = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               r' # cs' @ c # cs'' =\n               (r' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case r' # cs' of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow>\n        last (targetnodes (r' # cs')))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> sourcenode c'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>rs = r' # cs' @ c # cs'';\n        get_proc (sourcenode c') = get_proc (targetnode r');\n        rs' = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (last\n                                    (targetnodes\n(r' # cs')))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc (last (targetnodes (r' # cs'))) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode c'\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs')(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list rs' (sourcenode c')\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "from IH[OF \\<open>valid_call_list cs' (sourcenode c')\\<close> \n    \\<open>valid_return_list rs' (sourcenode c')\\<close>\n    \\<open>\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\\<close> \\<open>length rs' = length cs'\\<close>]"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs'.\n     call_of_return_node (targetnodes rs' ! i) (sourcenode (cs' ! i))", "have all:\"\\<forall>i<length cs'.\n    call_of_return_node (targetnodes rs' ! i) (sourcenode (cs' ! i))\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs'.\n     call_of_return_node (targetnodes rs' ! i) (sourcenode (cs' ! i))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cs'.\n       call_of_return_node (targetnodes rs' ! i) (sourcenode (cs' ! i))", "."], ["proof (state)\nthis:\n  \\<forall>i<length cs'.\n     call_of_return_node (targetnodes rs' ! i) (sourcenode (cs' ! i))\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "from \\<open>valid_edge c'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'", "have \"valid_edge r'\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. valid_edge r'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge r'\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "from \\<open>valid_edge r'\\<close> \\<open>valid_edge c'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge r'\n  valid_edge c'\n  r' \\<in> get_return_edges c'", "have \"return_node (targetnode r')\""], ["proof (prove)\nusing this:\n  valid_edge r'\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. return_node (targetnode r')", "by(fastforce simp:return_node_def)"], ["proof (state)\nthis:\n  return_node (targetnode r')\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "with \\<open>valid_edge c'\\<close> \\<open>r' \\<in> get_return_edges c'\\<close> \\<open>valid_edge r'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n  valid_edge r'\n  return_node (targetnode r')", "have \"call_of_return_node (targetnode r') (sourcenode c')\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  r' \\<in> get_return_edges c'\n  valid_edge r'\n  return_node (targetnode r')\n\ngoal (1 subgoal):\n 1. call_of_return_node (targetnode r') (sourcenode c')", "by(simp add:call_of_return_node_def) blast"], ["proof (state)\nthis:\n  call_of_return_node (targetnode r') (sourcenode c')\n\ngoal (1 subgoal):\n 1. \\<And>a cs m rs.\n       \\<lbrakk>\\<And>m rs.\n                   \\<lbrakk>valid_call_list cs m; valid_return_list rs m;\n                    \\<forall>i<length rs.\n                       rs ! i \\<in> get_return_edges (cs ! i);\n                    length rs = length cs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>i<length cs.\n  call_of_return_node (targetnodes rs ! i) (sourcenode (cs ! i));\n        valid_call_list (a # cs) m; valid_return_list rs m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges ((a # cs) ! i);\n        length rs = length (a # cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # cs).\n                            call_of_return_node (targetnodes rs ! i)\n                             (sourcenode ((a # cs) ! i))", "with all \\<open>rs = r' # rs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs'.\n     call_of_return_node (targetnodes rs' ! i) (sourcenode (cs' ! i))\n  rs = r' # rs'\n  call_of_return_node (targetnode r') (sourcenode c')", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i<length cs'.\n     call_of_return_node (targetnodes rs' ! i) (sourcenode (cs' ! i))\n  rs = r' # rs'\n  call_of_return_node (targetnode r') (sourcenode c')\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (c' # cs').\n       call_of_return_node (targetnodes rs ! i)\n        (sourcenode ((c' # cs') ! i))", "by auto(case_tac i,auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  \\<forall>i<length (c' # cs').\n     call_of_return_node (targetnodes rs ! i) (sourcenode ((c' # cs') ! i))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}